(declare-fun |b54[DafnyPreludebpl.696:17]| () Bool)
(declare-fun |b14[cast:U_2_string]| () Bool)
(declare-fun |b46[funType:Set#Intersection]| () Bool)
(declare-fun |b61[DafnyPreludebpl.952:18]| () Bool)
(declare-fun |b8[cast:U_2_bool]| () Bool)
(declare-fun |b78[SequenceSetsidfy.22:16]| () Bool)
(declare-fun |b15[funType:string_2_U]| () Bool)
(declare-fun |b84[]| () Bool)
(declare-fun |b69[unknown.0:0!131]| () Bool)
(declare-fun |b59[funType:Seq#Empty]| () Bool)
(declare-fun |b96[]| () Bool)
(declare-fun |b26[mapAx0:MapType0Select]| () Bool)
(declare-fun |b92[]| () Bool)
(declare-fun |b66[funType:SequenceSetsMod.__default.Members]| () Bool)
(declare-fun |b70[funType:SequenceSetsMod.__default.ArbitrarySequentialization]| () Bool)
(declare-fun |b60[k!213]| () Bool)
(declare-fun |b42[DafnyPreludebpl.653:18]| () Bool)
(declare-fun |b51[DafnyPreludebpl.684:18]| () Bool)
(declare-fun |b34[funType:Set#Empty]| () Bool)
(declare-fun |b39[DafnyPreludebpl.643:18]| () Bool)
(declare-fun |b9[funType:bool_2_U]| () Bool)
(declare-fun |b27[mapAx1:MapType0Select:0]| () Bool)
(declare-fun |b23[typeInv:MapType0TypeInv1]| () Bool)
(declare-fun |b17[cast:U_2_regex]| () Bool)
(declare-fun |b47[DafnyPreludebpl.669:18]| () Bool)
(declare-fun |b76[unknown.0:0!156]| () Bool)
(declare-fun |b75[unknown.0:0!139]| () Bool)
(declare-fun |b31[DafnyPreludebpl.219:15]| () Bool)
(declare-fun |b11[cast:U_2_rmode]| () Bool)
(declare-fun |b82[]| () Bool)
(declare-fun |b41[funType:Set#Union]| () Bool)
(declare-fun |b71[unknown.0:0!132]| () Bool)
(declare-fun |b89[]| () Bool)
(declare-fun |b36[DafnyPreludebpl.628:18]| () Bool)
(declare-fun |b50[DafnyPreludebpl.680:18]| () Bool)
(declare-fun |b7[typeInv:U_2_bool]| () Bool)
(declare-fun |b29[ctor:SeqType]| () Bool)
(declare-fun |b86[]| () Bool)
(declare-fun |b40[DafnyPreludebpl.649:18]| () Bool)
(declare-fun |b74[funType:$let#0_x]| () Bool)
(declare-fun |b81[]| () Bool)
(declare-fun |b5[cast:U_2_real]| () Bool)
(declare-fun |b99[]| () Bool)
(declare-fun |b12[funType:rmode_2_U]| () Bool)
(declare-fun |b94[]| () Bool)
(declare-fun |b3[funType:int_2_U]| () Bool)
(declare-fun |b1[typeInv:U_2_int]| () Bool)
(declare-fun |b52[DafnyPreludebpl.686:18]| () Bool)
(declare-fun |b88[]| () Bool)
(declare-fun |b30[typeInv:SeqTypeInv0]| () Bool)
(declare-fun |b64[DafnyPreludebpl.999:18]| () Bool)
(declare-fun |b55[DafnyPreludebpl.704:17]| () Bool)
(declare-fun |b79[]| () Bool)
(declare-fun |b49[DafnyPreludebpl.674:18]| () Bool)
(declare-fun |b85[]| () Bool)
(declare-fun |b20[DafnyPreludebpl.95:29]| () Bool)
(declare-fun |b77[SequenceSetsidfy.21:11]| () Bool)
(declare-fun |b80[]| () Bool)
(declare-fun |b13[typeInv:U_2_string]| () Bool)
(declare-fun |b22[typeInv:MapType0TypeInv0]| () Bool)
(declare-fun |b16[typeInv:U_2_regex]| () Bool)
(declare-fun |b67[unknown.0:0!127]| () Bool)
(declare-fun |b62[DafnyPreludebpl.974:18]| () Bool)
(declare-fun |b90[]| () Bool)
(declare-fun |b24[funType:MapType0Select]| () Bool)
(declare-fun |b32[funType:$LS]| () Bool)
(declare-fun |b28[mapAx2:MapType0Select]| () Bool)
(declare-fun |b33[DafnyPreludebpl.624:18]| () Bool)
(declare-fun |b68[unknown.0:0!130]| () Bool)
(declare-fun |b44[funType:Set#Difference]| () Bool)
(declare-fun |b25[funType:MapType0Store]| () Bool)
(declare-fun |b35[DafnyPreludebpl.627:18]| () Bool)
(declare-fun |b65[DafnyPreludebpl.1004:18]| () Bool)
(declare-fun |b73[unknown.0:0!135]| () Bool)
(declare-fun |b21[ctor:MapType0Type]| () Bool)
(declare-fun |b91[]| () Bool)
(declare-fun |b72[funType:AsFuelBottom]| () Bool)
(declare-fun |b43[DafnyPreludebpl.657:18]| () Bool)
(declare-fun |b63[DafnyPreludebpl.995:18]| () Bool)
(declare-fun |b4[typeInv:U_2_real]| () Bool)
(declare-fun |b6[funType:real_2_U]| () Bool)
(declare-fun |b48[DafnyPreludebpl.672:18]| () Bool)
(declare-fun |b87[]| () Bool)
(declare-fun |b95[]| () Bool)
(declare-fun |b56[DafnyPreludebpl.706:17]| () Bool)
(declare-fun |b57[DafnyPreludebpl.710:18]| () Bool)
(declare-fun |b38[DafnyPreludebpl.641:18]| () Bool)
(declare-fun |b37[funType:Set#UnionOne]| () Bool)
(declare-fun |b10[typeInv:U_2_rmode]| () Bool)
(declare-fun |b93[]| () Bool)
(declare-fun |b58[funType:Seq#Build]| () Bool)
(declare-fun |b97[]| () Bool)
(declare-fun |b53[DafnyPreludebpl.688:18]| () Bool)
(declare-fun |b83[]| () Bool)
(declare-fun |b19[DafnyPreludebpl.89:29]| () Bool)
(declare-fun |b18[funType:regex_2_U]| () Bool)
(declare-fun |b2[cast:U_2_int]| () Bool)
(declare-fun |b98[]| () Bool)
(declare-fun |b45[DafnyPreludebpl.659:18]| () Bool)
(set-info :smt-lib-version |2.6|)
(set-info :category |"industrial"|)
(set-info :boogie-vc-id CheckWellformed$$SequenceSetsMod.__default.ArbitrarySequentialization)
(set-option :print-success false)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(declare-sort T@T 0)
(declare-sort T@U 0)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun Lit (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun bx@@10!398!0 (T@U T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun TyType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun refType () T@T)
(declare-fun $OneHeap () T@U)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun x@@18!470!1 (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun o@@23!493!2 (T@U T@U) T@U)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun o@@24!495!3 (T@U T@U) T@U)
(declare-fun o@@25!498!4 (T@U T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun SequenceSetsMod.__default.Members (T@U T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |SequenceSetsMod.__default.Members#canCall| (T@U T@U) Bool)
(declare-fun |lambda#2| (T@U T@U) T@U)
(declare-fun SequenceSetsMod.__default.ArbitrarySequentialization (T@U T@U T@U) T@U)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun |SequenceSetsMod.__default.ArbitrarySequentialization#canCall| (T@U T@U) Bool)
(declare-fun |$let#0_x| (T@U T@U) T@U)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun |$let#0$canCall| (T@U T@U) Bool)
(declare-fun |b#4| () T@U)
(declare-fun |a#0@@15| () T@U)
(declare-fun SequenceSetsMod._default.ArbitrarySequentialization$T@@6 () T@U)
(declare-fun |x#2@0| () T@U)
(declare-fun $Heap@@2 () T@U)
(declare-fun |b#Z#0@0| () T@U)
(declare-fun |##a#1@0| () T@U)
(declare-fun MapType4Type (T@T T@T) T@T)
(declare-fun $_Frame@0 () T@U)
(declare-fun |let#0#0#0| () T@U)
(declare-fun |##a#3@0| () T@U)
(declare-fun |##a#4@0| () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun alloc () T@U)
(declare-fun null () T@U)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun MapType4Select (T@U T@U T@U) T@U)
(declare-fun $f@@3!906!6 () T@U)
(declare-fun $o@@15!906!7 () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun |x#3@@0!905!5| () T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(assert (= (Ctor intType) 0)) ;; !QUANTIFIER-FREE!
(assert (= (Ctor realType) 1)) ;; !QUANTIFIER-FREE!
(assert (= (Ctor boolType) 2)) ;; !QUANTIFIER-FREE!
(assert (= (Ctor rmodeType) 3)) ;; !QUANTIFIER-FREE!
(assert (= (Ctor stringType) 4)) ;; !QUANTIFIER-FREE!
(assert (= (Ctor regexType) 5)) ;; !QUANTIFIER-FREE!
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type))) ;; !QUANTIFIER-FREE!
(assert (= (type $LZ) LayerTypeType)) ;; !QUANTIFIER-FREE!
(assert (= (type |b#4|) (SeqType BoxType))) ;; !QUANTIFIER-FREE!
(assert (= (type |a#0@@15|) (MapType0Type BoxType boolType))) ;; !QUANTIFIER-FREE!
(assert (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@6) TyType)) ;; !QUANTIFIER-FREE!
(assert (= (type |x#2@0|) BoxType)) ;; !QUANTIFIER-FREE!
(assert (= (type $Heap@@2) (MapType0Type refType MapType1Type))) ;; !QUANTIFIER-FREE!
(assert (= (type |b#Z#0@0|) (SeqType BoxType))) ;; !QUANTIFIER-FREE!
(assert (= (type |##a#1@0|) (MapType0Type BoxType boolType))) ;; !QUANTIFIER-FREE!
(assert (= (type $_Frame@0) (MapType4Type refType boolType))) ;; !QUANTIFIER-FREE!
(assert (= (type |let#0#0#0|) (SeqType BoxType))) ;; !QUANTIFIER-FREE!
(assert (= (type |##a#3@0|) (MapType0Type BoxType boolType))) ;; !QUANTIFIER-FREE!
(assert (= (type |##a#4@0|) (SeqType BoxType))) ;; !QUANTIFIER-FREE!
(assert (= (type $_Frame@0@@0) (MapType4Type refType boolType))) ;; !QUANTIFIER-FREE!
(assert (= (ControlFlow 0 0) 48819)) ;; !QUANTIFIER-FREE!
(assert ($IsGoodHeap $Heap@@2)) ;; !QUANTIFIER-FREE!
(assert ($IsHeapAnchor $Heap@@2)) ;; !QUANTIFIER-FREE!
(assert ($Is |a#0@@15| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) ;; !QUANTIFIER-FREE!
(assert ($Is |b#4| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) ;; !QUANTIFIER-FREE!
(assert (= 1 $FunctionContextHeight)) ;; !QUANTIFIER-FREE!
(assert (= (ControlFlow 0 48819) 34999)) ;; !QUANTIFIER-FREE!
(assert (= $_Frame@0 (|lambda#4| null $Heap@@2 alloc false))) ;; !QUANTIFIER-FREE!
(check-sat)
