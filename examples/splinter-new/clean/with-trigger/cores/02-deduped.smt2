(set-option :print-success false)
(set-info :smt-lib-version |2.6|)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(set-info :category |"industrial"|)
(declare-sort T@U 0)
(declare-sort T@T 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (T@U T@U) Bool)
(declare-fun UOrdering3 (T@T T@U T@U) Bool)
(declare-fun tickleBool (Bool) Bool)
(declare-fun U_2_int (T@U) Int)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TORDINAL () T@U)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun alloc () T@U)
(declare-fun allocName () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun class._System.object? () T@U)
(declare-fun Tagclass._System.object? () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array? () T@U)
(declare-fun Tagclass._System.array? () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun Tagclass._System.___hPartialFunc1 () T@U)
(declare-fun Tagclass._System.___hTotalFunc1 () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hPartialFunc0 () T@U)
(declare-fun Tagclass._System.___hTotalFunc0 () T@U)
(declare-fun class._System.__default () T@U)
(declare-fun Tagclass._System.__default () T@U)
(declare-fun Tagclass._System.___hFunc2 () T@U)
(declare-fun Tagclass._System.___hPartialFunc2 () T@U)
(declare-fun Tagclass._System.___hTotalFunc2 () T@U)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2 () T@U)
(declare-fun class._System.Tuple2 () T@U)
(declare-fun |##_System._tuple#0._#Make0| () T@U)
(declare-fun Tagclass._System.Tuple0 () T@U)
(declare-fun class._System.Tuple0 () T@U)
(declare-fun class.SequenceSetsMod.__default () T@U)
(declare-fun Tagclass.SequenceSetsMod.__default () T@U)
(declare-fun tytagFamily$nat () T@U)
(declare-fun tytagFamily$object () T@U)
(declare-fun tytagFamily$array () T@U)
(declare-fun |tytagFamily$_#Func1| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1| () T@U)
(declare-fun |tytagFamily$_#Func0| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0| () T@U)
(declare-fun tytagFamily$_default () T@U)
(declare-fun |tytagFamily$_#Func2| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2| () T@U)
(declare-fun |tytagFamily$_tuple#2| () T@U)
(declare-fun |tytagFamily$_tuple#0| () T@U)
(declare-fun TyType () T@T)
(declare-fun TyTagType () T@T)
(declare-fun ClassNameType () T@T)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun NameFamilyType () T@T)
(declare-fun DtCtorIdType () T@T)
(declare-fun TyTagFamilyType () T@T)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TBitvector (Int) T@U)
(declare-fun Inv0_TBitvector (T@U) Int)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun $Box (T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun LitInt (Int) Int)
(declare-fun LitReal (Real) Real)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#Plus| (T@U T@U) T@U)
(declare-fun |char#Minus| (T@U T@U) T@U)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun refType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun Tclass._System.Tuple2 (T@U T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object? () T@U)
(declare-fun BoxRank (T@U) Int)
(declare-fun DatatypeTypeType () T@T)
(declare-fun DtRank (T@U) Int)
(declare-fun |ORD#Offset| (T@U) Int)
(declare-fun |ORD#FromNat| (Int) T@U)
(declare-fun |ORD#IsNat| (T@U) Bool)
(declare-fun |ORD#Less| (T@U T@U) Bool)
(declare-fun |ORD#LessThanLimit| (T@U T@U) Bool)
(declare-fun |ORD#Plus| (T@U T@U) T@U)
(declare-fun |ORD#Minus| (T@U T@U) T@U)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $OneHeap () T@U)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Create| (T@U T@U Int T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2._0 (T@U) T@U)
(declare-fun _System.Tuple2._1 (T@U) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Merge| (T@U T@U) T@U)
(declare-fun |Map#Subtract| (T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun |IMap#Merge| (T@U T@U) T@U)
(declare-fun |IMap#Subtract| (T@U T@U) T@U)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun Mul (Int Int) Int)
(declare-fun Div (Int Int) Int)
(declare-fun Mod (Int Int) Int)
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun _System.__default.rank__is__less__than (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.nat () T@U)
(declare-fun TagFamily (T@U) T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun Tclass._System.array? (T@U) T@U)
(declare-fun Tclass._System.array?_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.__default () T@U)
(declare-fun |_System.__default.rank__is__less__than#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |_System.__default.rank__is__less__than#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_2 (T@U) T@U)
(declare-fun Apply2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle2 (T@U T@U T@U) T@U)
(declare-fun MapType3Type (T@T T@T T@T T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U T@U) T@U)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3TypeInv2 (T@T) T@T)
(declare-fun MapType3TypeInv3 (T@T) T@T)
(declare-fun MapType3Store (T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires2 (T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_2 (T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.Tuple2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2_1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2| (T@U) Bool)
(declare-fun |_System.Tuple2#Equal| (T@U T@U) Bool)
(declare-fun |#_System._tuple#0._#Make0| () T@U)
(declare-fun _System.Tuple0.___hMake0_q (T@U) Bool)
(declare-fun Tclass._System.Tuple0 () T@U)
(declare-fun |$IsA#_System.Tuple0| (T@U) Bool)
(declare-fun |_System.Tuple0#Equal| (T@U T@U) Bool)
(declare-fun Tclass.SequenceSetsMod.__default () T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun SequenceSetsMod.__default.SequenceSubset (T@U T@U T@U) Bool)
(declare-fun |SequenceSetsMod.__default.SequenceSubset#canCall| (T@U T@U T@U) Bool)
(declare-fun |SequenceSetsMod.__default.SequenceSubset#requires| (T@U T@U T@U) Bool)
(declare-fun SequenceSetsMod.__default.Members (T@U T@U) T@U)
(declare-fun |SequenceSetsMod.__default.Members#canCall| (T@U T@U) Bool)
(declare-fun |SequenceSetsMod.__default.Members#requires| (T@U T@U) Bool)
(declare-fun |lambda#2| (T@U T@U) T@U)
(declare-fun SequenceSetsMod.__default.ArbitrarySequentialization (T@U T@U T@U) T@U)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun |SequenceSetsMod.__default.ArbitrarySequentialization#canCall| (T@U T@U) Bool)
(declare-fun |SequenceSetsMod.__default.ArbitrarySequentialization#requires| (T@U T@U T@U) Bool)
(declare-fun |$let#0_x| (T@U T@U) T@U)
(declare-fun |$let#0$canCall| (T@U T@U) Bool)
(declare-fun MapType4Select (T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U Bool) T@U)
(declare-fun MapType4Type (T@T T@T) T@T)
(declare-fun MapType4TypeInv0 (T@T) T@T)
(declare-fun MapType4TypeInv1 (T@T) T@T)
(declare-fun MapType4Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(assert (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (= (Ctor rmodeType) 3)) (= (Ctor stringType) 4)) (= (Ctor regexType) 5)) (forall ((arg0 Int)) (! (= (U_2_int (int_2_U arg0)) arg0) :qid |typeInv:U_2_int| :pattern ( (int_2_U arg0))))) (forall ((x T@U)) (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x)) :qid |cast:U_2_int| :pattern ( (U_2_int x))))) (forall ((arg0@@0 Int)) (! (= (type (int_2_U arg0@@0)) intType) :qid |funType:int_2_U| :pattern ( (int_2_U arg0@@0))))) (forall ((arg0@@1 Real)) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :qid |typeInv:U_2_real| :pattern ( (real_2_U arg0@@1))))) (forall ((x@@0 T@U)) (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0)) :qid |cast:U_2_real| :pattern ( (U_2_real x@@0))))) (forall ((arg0@@2 Real)) (! (= (type (real_2_U arg0@@2)) realType) :qid |funType:real_2_U| :pattern ( (real_2_U arg0@@2))))) (forall ((arg0@@3 Bool)) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :qid |typeInv:U_2_bool| :pattern ( (bool_2_U arg0@@3))))) (forall ((x@@1 T@U)) (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1)) :qid |cast:U_2_bool| :pattern ( (U_2_bool x@@1))))) (forall ((arg0@@4 Bool)) (! (= (type (bool_2_U arg0@@4)) boolType) :qid |funType:bool_2_U| :pattern ( (bool_2_U arg0@@4))))) (forall ((arg0@@5 RoundingMode)) (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5) :qid |typeInv:U_2_rmode| :pattern ( (rmode_2_U arg0@@5))))) (forall ((x@@2 T@U)) (! (=> (= (type x@@2) rmodeType) (= (rmode_2_U (U_2_rmode x@@2)) x@@2)) :qid |cast:U_2_rmode| :pattern ( (U_2_rmode x@@2))))) (forall ((arg0@@6 RoundingMode)) (! (= (type (rmode_2_U arg0@@6)) rmodeType) :qid |funType:rmode_2_U| :pattern ( (rmode_2_U arg0@@6))))) (forall ((arg0@@7 String)) (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7) :qid |typeInv:U_2_string| :pattern ( (string_2_U arg0@@7))))) (forall ((x@@3 T@U)) (! (=> (= (type x@@3) stringType) (= (string_2_U (U_2_string x@@3)) x@@3)) :qid |cast:U_2_string| :pattern ( (U_2_string x@@3))))) (forall ((arg0@@8 String)) (! (= (type (string_2_U arg0@@8)) stringType) :qid |funType:string_2_U| :pattern ( (string_2_U arg0@@8))))) (forall ((arg0@@9 (RegEx String))) (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9) :qid |typeInv:U_2_regex| :pattern ( (regex_2_U arg0@@9))))) (forall ((x@@4 T@U)) (! (=> (= (type x@@4) regexType) (= (regex_2_U (U_2_regex x@@4)) x@@4)) :qid |cast:U_2_regex| :pattern ( (U_2_regex x@@4))))) (forall ((arg0@@10 (RegEx String))) (! (= (type (regex_2_U arg0@@10)) regexType) :qid |funType:regex_2_U| :pattern ( (regex_2_U arg0@@10))))))
(assert (forall ((x@@8 T@U)) (! (= (Lit x@@8) x@@8) :qid |DafnyPreludebpl.89:29| :skolemid |362| :pattern ( (Lit x@@8)))))
(assert (forall ((x@@10 Int)) (! (= (LitInt x@@10) x@@10) :qid |DafnyPreludebpl.95:29| :skolemid |364| :pattern ( (LitInt x@@10)))))
(assert (and (and (and (and (and (and (forall ((arg0@@35 T@T)(arg1@@3 T@T)) (! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15) :qid |ctor:MapType0Type|)) (forall ((arg0@@36 T@T)(arg1@@4 T@T)) (! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36) :qid |typeInv:MapType0TypeInv0| :pattern ( (MapType0Type arg0@@36 arg1@@4))))) (forall ((arg0@@37 T@T)(arg1@@5 T@T)) (! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5) :qid |typeInv:MapType0TypeInv1| :pattern ( (MapType0Type arg0@@37 arg1@@5))))) (forall ((arg0@@38 T@U)(arg1@@6 T@U)) (! (= (type (MapType0Select arg0@@38 arg1@@6)) (MapType0TypeInv1 (type arg0@@38))) :qid |funType:MapType0Select| :pattern ( (MapType0Select arg0@@38 arg1@@6))))) (forall ((arg2 T@U)(arg0@@39 T@U)(arg1@@7 T@U)) (! (= (type (MapType0Store arg0@@39 arg1@@7 arg2)) (MapType0Type (type arg1@@7) (type arg2))) :qid |funType:MapType0Store| :pattern ( (MapType0Store arg0@@39 arg1@@7 arg2))))) (forall ((m T@U)(x0 T@U)(val T@U)) (! (=> (= (type val) (MapType0TypeInv1 (type m))) (= (MapType0Select (MapType0Store m x0 val) x0) val)) :qid |mapAx0:MapType0Select| :weight 0))) (and (forall ((x0@@0 T@U)(y0 T@U)(val@@0 T@U)(m@@0 T@U)) (! (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0))) :qid |mapAx1:MapType0Select:0| :weight 0)) (forall ((y0@@0 T@U)(val@@1 T@U)(m@@1 T@U)(x0@@1 T@U)) (! (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0))) :qid |mapAx2:MapType0Select| :weight 0)))))
(assert (and (forall ((arg0@@40 T@T)) (! (= (Ctor (SeqType arg0@@40)) 16) :qid |ctor:SeqType|)) (forall ((arg0@@41 T@T)) (! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41) :qid |typeInv:SeqTypeInv0| :pattern ( (SeqType arg0@@41))))))
(assert (forall ((v@@13 T@U)(t0 T@U)) (! (=> (and (= (type v@@13) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (= ($Is v@@13 (TSet t0)) (forall ((bx@@10 T@U)) (! (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@13 bx@@10))) ($IsBox bx@@10 t0)) :qid |DafnyPreludebpl.221:11| :skolemid |398| :pattern ( (MapType0Select v@@13 bx@@10)))))) :qid |DafnyPreludebpl.219:15| :skolemid |399| :pattern ( ($Is v@@13 (TSet t0))))))
(assert (forall ((arg0@@68 T@U)) (! (= (type ($LS arg0@@68)) LayerTypeType) :qid |funType:$LS| :pattern ( ($LS arg0@@68)))))
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type)))
(assert (forall ((s@@3 T@U)) (! (=> (= (type s@@3) (MapType0Type (MapType0TypeInv0 (type s@@3)) boolType)) (<= 0 (|Set#Card| s@@3))) :qid |DafnyPreludebpl.624:18| :skolemid |468| :pattern ( (|Set#Card| s@@3)))))
(assert (forall ((T@@6 T@T)) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType)) :qid |funType:Set#Empty| :pattern ( (|Set#Empty| T@@6)))))
(assert (forall ((o@@17 T@U)) (! (not (U_2_bool (MapType0Select (|Set#Empty| (type o@@17)) o@@17))) :qid |DafnyPreludebpl.627:18| :skolemid |469| :pattern ( (let ((T@@7 (type o@@17)))  (MapType0Select (|Set#Empty| T@@7) o@@17))))))
(assert (forall ((s@@4 T@U)) (! (=> (= (type s@@4) (MapType0Type (MapType0TypeInv0 (type s@@4)) boolType)) (and (= (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| (MapType0TypeInv0 (type s@@4))))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@18 T@U)) (! (and (= (type x@@18) (MapType0TypeInv0 (type s@@4))) (U_2_bool (MapType0Select s@@4 x@@18))) :qid |DafnyPreludebpl.630:33| :skolemid |470| :no-pattern (U_2_int x@@18) :no-pattern (type x@@18) :no-pattern (U_2_bool x@@18)))))) :qid |DafnyPreludebpl.628:18| :skolemid |471| :pattern ( (|Set#Card| s@@4)))))
(assert (forall ((arg0@@76 T@U)(arg1@@24 T@U)) (! (= (type (|Set#UnionOne| arg0@@76 arg1@@24)) (MapType0Type (type arg1@@24) boolType)) :qid |funType:Set#UnionOne| :pattern ( (|Set#UnionOne| arg0@@76 arg1@@24)))))
(assert (forall ((a@@3 T@U)(x@@19 T@U)(o@@19 T@U)) (! (=> (and (= (type a@@3) (MapType0Type (type x@@19) boolType)) (= (type o@@19) (type x@@19))) (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19)) (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))) :qid |DafnyPreludebpl.641:18| :skolemid |475| :pattern ( (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19)))))
(assert (forall ((a@@4 T@U)(x@@20 T@U)) (! (=> (= (type a@@4) (MapType0Type (type x@@20) boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20))) :qid |DafnyPreludebpl.643:18| :skolemid |476| :pattern ( (|Set#UnionOne| a@@4 x@@20)))))
(assert (forall ((a@@7 T@U)(x@@23 T@U)) (! (=> (and (= (type a@@7) (MapType0Type (type x@@23) boolType)) (not (U_2_bool (MapType0Select a@@7 x@@23)))) (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))) :qid |DafnyPreludebpl.649:18| :skolemid |479| :pattern ( (|Set#Card| (|Set#UnionOne| a@@7 x@@23))))))
(assert (forall ((arg0@@77 T@U)(arg1@@25 T@U)) (! (= (type (|Set#Union| arg0@@77 arg1@@25)) (MapType0Type (MapType0TypeInv0 (type arg0@@77)) boolType)) :qid |funType:Set#Union| :pattern ( (|Set#Union| arg0@@77 arg1@@25)))))
(assert (forall ((a@@8 T@U)(b@@3 T@U)(o@@20 T@U)) (! (=> (and (= (type a@@8) (MapType0Type (type o@@20) boolType)) (= (type b@@3) (MapType0Type (type o@@20) boolType))) (= (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) o@@20)) (or (U_2_bool (MapType0Select a@@8 o@@20)) (U_2_bool (MapType0Select b@@3 o@@20))))) :qid |DafnyPreludebpl.653:18| :skolemid |480| :pattern ( (MapType0Select (|Set#Union| a@@8 b@@3) o@@20)))))
(assert (forall ((a@@10 T@U)(b@@5 T@U)(y@@3 T@U)) (! (=> (and (and (= (type a@@10) (MapType0Type (type y@@3) boolType)) (= (type b@@5) (MapType0Type (type y@@3) boolType))) (U_2_bool (MapType0Select b@@5 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@10 b@@5) y@@3))) :qid |DafnyPreludebpl.657:18| :skolemid |482| :pattern ( (|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3)))))
(assert (forall ((arg0@@78 T@U)(arg1@@26 T@U)) (! (= (type (|Set#Difference| arg0@@78 arg1@@26)) (MapType0Type (MapType0TypeInv0 (type arg0@@78)) boolType)) :qid |funType:Set#Difference| :pattern ( (|Set#Difference| arg0@@78 arg1@@26)))))
(assert (forall ((a@@11 T@U)(b@@6 T@U)) (! (=> (and (and (= (type a@@11) (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType)) (= (type b@@6) (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType))) (|Set#Disjoint| a@@11 b@@6)) (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6) (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))) :qid |DafnyPreludebpl.659:18| :skolemid |483| :pattern ( (|Set#Union| a@@11 b@@6)))))
(assert (forall ((arg1@@27 T@U)(arg0@@79 T@U)) (! (= (type (|Set#Intersection| arg0@@79 arg1@@27)) (MapType0Type (MapType0TypeInv0 (type arg0@@79)) boolType)) :qid |funType:Set#Intersection| :pattern ( (|Set#Intersection| arg0@@79 arg1@@27)))))
(assert (forall ((a@@12 T@U)(b@@7 T@U)(o@@21 T@U)) (! (=> (and (= (type a@@12) (MapType0Type (type o@@21) boolType)) (= (type b@@7) (MapType0Type (type o@@21) boolType))) (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21)) (and (U_2_bool (MapType0Select a@@12 o@@21)) (U_2_bool (MapType0Select b@@7 o@@21))))) :qid |DafnyPreludebpl.669:18| :skolemid |484| :pattern ( (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21)))))
(assert (forall ((a@@13 T@U)(b@@8 T@U)) (! (=> (and (= (type a@@13) (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType)) (= (type b@@8) (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType))) (= (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8) (|Set#Union| a@@13 b@@8))) :qid |DafnyPreludebpl.672:18| :skolemid |485| :pattern ( (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8)))))
(assert (forall ((a@@14 T@U)(b@@9 T@U)) (! (=> (and (= (type a@@14) (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType)) (= (type b@@9) (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType))) (= (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)) (|Set#Union| a@@14 b@@9))) :qid |DafnyPreludebpl.674:18| :skolemid |486| :pattern ( (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9))))))
(assert (forall ((a@@17 T@U)(b@@12 T@U)) (! (=> (and (= (type a@@17) (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType)) (= (type b@@12) (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType))) (= (+ (|Set#Card| (|Set#Union| a@@17 b@@12)) (|Set#Card| (|Set#Intersection| a@@17 b@@12))) (+ (|Set#Card| a@@17) (|Set#Card| b@@12)))) :qid |DafnyPreludebpl.680:18| :skolemid |489| :pattern ( (|Set#Card| (|Set#Intersection| a@@17 b@@12))) :pattern ( (|Set#Card| (|Set#Union| a@@17 b@@12))))))
(assert (forall ((b@@13 T@U)(o@@22 T@U)(a@@18 T@U)) (! (=> (and (= (type a@@18) (MapType0Type (type o@@22) boolType)) (= (type b@@13) (MapType0Type (type o@@22) boolType))) (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22)) (and (U_2_bool (MapType0Select a@@18 o@@22)) (not (U_2_bool (MapType0Select b@@13 o@@22)))))) :qid |DafnyPreludebpl.684:18| :skolemid |490| :pattern ( (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22)))))
(assert (forall ((b@@14 T@U)(y@@4 T@U)(a@@19 T@U)) (! (=> (and (and (= (type a@@19) (MapType0Type (type y@@4) boolType)) (= (type b@@14) (MapType0Type (type y@@4) boolType))) (U_2_bool (MapType0Select b@@14 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14) y@@4)))) :qid |DafnyPreludebpl.686:18| :skolemid |491| :pattern ( (|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4)))))
(assert (forall ((a@@20 T@U)(b@@15 T@U)) (! (=> (and (= (type a@@20) (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType)) (= (type b@@15) (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@20 b@@15)) (|Set#Card| (|Set#Difference| b@@15 a@@20))) (|Set#Card| (|Set#Intersection| a@@20 b@@15))) (|Set#Card| (|Set#Union| a@@20 b@@15))) (= (|Set#Card| (|Set#Difference| a@@20 b@@15)) (- (|Set#Card| a@@20) (|Set#Card| (|Set#Intersection| a@@20 b@@15)))))) :qid |DafnyPreludebpl.688:18| :skolemid |492| :pattern ( (|Set#Card| (|Set#Difference| a@@20 b@@15))))))
(assert (forall ((a@@21 T@U)(b@@16 T@U)) (! (=> (and (= (type a@@21) (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType)) (= (type b@@16) (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType))) (= (|Set#Subset| a@@21 b@@16) (forall ((o@@23 T@U)) (! (=> (and (= (type o@@23) (MapType0TypeInv0 (type a@@21))) (U_2_bool (MapType0Select a@@21 o@@23))) (U_2_bool (MapType0Select b@@16 o@@23))) :qid |DafnyPreludebpl.697:32| :skolemid |493| :pattern ( (MapType0Select a@@21 o@@23)) :pattern ( (MapType0Select b@@16 o@@23)))))) :qid |DafnyPreludebpl.696:17| :skolemid |494| :pattern ( (|Set#Subset| a@@21 b@@16)))))
(assert (forall ((a@@22 T@U)(b@@17 T@U)) (! (=> (and (= (type a@@22) (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType)) (= (type b@@17) (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType))) (= (|Set#Equal| a@@22 b@@17) (forall ((o@@24 T@U)) (! (=> (= (type o@@24) (MapType0TypeInv0 (type a@@22))) (= (U_2_bool (MapType0Select a@@22 o@@24)) (U_2_bool (MapType0Select b@@17 o@@24)))) :qid |DafnyPreludebpl.705:31| :skolemid |495| :pattern ( (MapType0Select b@@17 o@@24)) :pattern ( (MapType0Select a@@22 o@@24)))))) :qid |DafnyPreludebpl.704:17| :skolemid |496| :pattern ( (|Set#Equal| a@@22 b@@17)))))
(assert (forall ((a@@23 T@U)(b@@18 T@U)) (! (=> (and (and (= (type a@@23) (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType)) (= (type b@@18) (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType))) (|Set#Equal| a@@23 b@@18)) (= a@@23 b@@18)) :qid |DafnyPreludebpl.706:17| :skolemid |497| :pattern ( (|Set#Equal| a@@23 b@@18)))))
(assert (forall ((a@@24 T@U)(b@@19 T@U)) (! (=> (and (= (type a@@24) (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType)) (= (type b@@19) (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType))) (= (|Set#Disjoint| a@@24 b@@19) (forall ((o@@25 T@U)) (! (=> (= (type o@@25) (MapType0TypeInv0 (type a@@24))) (or (not (U_2_bool (MapType0Select a@@24 o@@25))) (not (U_2_bool (MapType0Select b@@19 o@@25))))) :qid |DafnyPreludebpl.711:34| :skolemid |498| :pattern ( (MapType0Select b@@19 o@@25)) :pattern ( (MapType0Select a@@24 o@@25)))))) :qid |DafnyPreludebpl.710:18| :skolemid |499| :pattern ( (|Set#Disjoint| a@@24 b@@19)))))
(assert (forall ((arg0@@91 T@U)(arg1@@36 T@U)) (! (= (type (|Seq#Build| arg0@@91 arg1@@36)) (SeqType (type arg1@@36))) :qid |funType:Seq#Build| :pattern ( (|Seq#Build| arg0@@91 arg1@@36)))))
(assert (forall ((T@@99 T@T)) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99)) :qid |funType:Seq#Empty| :pattern ( (|Seq#Empty| T@@99)))))
(assert (forall ((T@@107 T@T)) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :skolemid |567| :pattern ( (|Seq#Empty| T@@107)) :qid k!213)))
(assert (forall ((s@@18 T@U)(v@@31 T@U)) (! (=> (= (type s@@18) (SeqType (type v@@31))) (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18)))) :qid |DafnyPreludebpl.952:18| :skolemid |571| :pattern ( (|Seq#Build| s@@18 v@@31)))))
(assert (forall ((s0 T@U)(s1 T@U)) (! (=> (and (= (type s0) (SeqType (SeqTypeInv0 (type s0)))) (= (type s1) (SeqType (SeqTypeInv0 (type s0))))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1)))) :qid |DafnyPreludebpl.974:18| :skolemid |576| :pattern ( (|Seq#Length| (|Seq#Append| s0 s1))))))
(assert (forall ((x@@37 T@U)) (! (not (|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37)) :qid |DafnyPreludebpl.995:18| :skolemid |583| :pattern ( (let ((T@@120 (type x@@37)))  (|Seq#Contains| (|Seq#Empty| T@@120) x@@37))))))
(assert (forall ((x@@38 T@U)(s0@@1 T@U)(s1@@1 T@U)) (! (=> (and (= (type s0@@1) (SeqType (type x@@38))) (= (type s1@@1) (SeqType (type x@@38)))) (= (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38) (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))) :qid |DafnyPreludebpl.999:18| :skolemid |584| :pattern ( (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38)))))
(assert (forall ((x@@39 T@U)(s@@24 T@U)(v@@35 T@U)) (! (=> (and (= (type s@@24) (SeqType (type v@@35))) (= (type x@@39) (type v@@35))) (= (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39) (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))) :qid |DafnyPreludebpl.1004:18| :skolemid |585| :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39)))))
(assert (forall ((arg0@@170 T@U)(arg1@@80 T@U)) (! (= (type (SequenceSetsMod.__default.Members arg0@@170 arg1@@80)) (MapType0Type BoxType boolType)) :qid |funType:SequenceSetsMod.__default.Members| :pattern ( (SequenceSetsMod.__default.Members arg0@@170 arg1@@80)))))
(assert (=> (<= 0 $FunctionContextHeight) (forall ((SequenceSetsMod._default.Members$T T@U)(|a#0@@5| T@U)) (! (=> (and (and (= (type SequenceSetsMod._default.Members$T) TyType) (= (type |a#0@@5|) (SeqType BoxType))) (or (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T |a#0@@5|) (and (not (= 0 $FunctionContextHeight)) ($Is |a#0@@5| (TSeq SequenceSetsMod._default.Members$T))))) ($Is (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T |a#0@@5|) (TSet SequenceSetsMod._default.Members$T))) :qid |unknown.0:0!127| :skolemid |894| :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T |a#0@@5|))))))
(assert (=> (<= 0 $FunctionContextHeight) (forall ((SequenceSetsMod._default.Members$T@@1 T@U)(|a#0@@7| T@U)) (! (=> (and (and (= (type SequenceSetsMod._default.Members$T@@1) TyType) (= (type |a#0@@7|) (SeqType BoxType))) (or (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T@@1 |a#0@@7|) (and (not (= 0 $FunctionContextHeight)) ($Is |a#0@@7| (TSeq SequenceSetsMod._default.Members$T@@1))))) (= (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@1 |a#0@@7|) (|lambda#2| SequenceSetsMod._default.Members$T@@1 |a#0@@7|))) :qid |unknown.0:0!130| :skolemid |896| :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@1 |a#0@@7|))))))
(assert (=> (<= 0 $FunctionContextHeight) (forall ((SequenceSetsMod._default.Members$T@@2 T@U)(|a#0@@8| T@U)) (! (=> (and (and (= (type SequenceSetsMod._default.Members$T@@2) TyType) (= (type |a#0@@8|) (SeqType BoxType))) (or (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T@@2 (Lit |a#0@@8|)) (and (not (= 0 $FunctionContextHeight)) ($Is |a#0@@8| (TSeq SequenceSetsMod._default.Members$T@@2))))) (= (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@2 (Lit |a#0@@8|)) (|lambda#2| SequenceSetsMod._default.Members$T@@2 |a#0@@8|))) :qid |unknown.0:0!131| :weight 3 :skolemid |897| :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@2 (Lit |a#0@@8|)))))))
(assert (forall ((arg0@@172 T@U)(arg1@@82 T@U)(arg2@@32 T@U)) (! (= (type (SequenceSetsMod.__default.ArbitrarySequentialization arg0@@172 arg1@@82 arg2@@32)) (SeqType BoxType)) :qid |funType:SequenceSetsMod.__default.ArbitrarySequentialization| :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization arg0@@172 arg1@@82 arg2@@32)))))
(assert (forall ((SequenceSetsMod._default.ArbitrarySequentialization$T T@U)($ly T@U)(|a#0@@9| T@U)) (! (=> (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T) TyType) (= (type $ly) LayerTypeType)) (= (type |a#0@@9|) (MapType0Type BoxType boolType))) (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T ($LS $ly) |a#0@@9|) (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T $ly |a#0@@9|))) :qid |unknown.0:0!132| :skolemid |898| :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T ($LS $ly) |a#0@@9|)))))
(assert (and (forall ((arg0@@173 T@U)) (! (= (type (AsFuelBottom arg0@@173)) LayerTypeType) :qid |funType:AsFuelBottom| :pattern ( (AsFuelBottom arg0@@173)))) (= (type $LZ) LayerTypeType)))
(assert (=> (<= 1 $FunctionContextHeight) (forall (($ly@@1 T@U)(|a#0@@11| T@U)(SequenceSetsMod._default.ArbitrarySequentialization$T@@1 T@U)) (! (=> (and (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@1) TyType) (= (type $ly@@1) LayerTypeType)) (= (type |a#0@@11|) (MapType0Type BoxType boolType))) (or (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@1 |a#0@@11|) (and (not (= 1 $FunctionContextHeight)) ($Is |a#0@@11| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@1))))) (and (and (= (|Seq#Length| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|)) (|Set#Card| |a#0@@11|)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@1 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|)) |a#0@@11|)) ($Is (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|) (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@1)))) :qid |unknown.0:0!135| :skolemid |900| :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|))))))
(assert (forall ((arg0@@174 T@U)(arg1@@83 T@U)) (! (= (type (|$let#0_x| arg0@@174 arg1@@83)) BoxType) :qid |funType:$let#0_x| :pattern ( (|$let#0_x| arg0@@174 arg1@@83)))))
(assert (=> (<= 1 $FunctionContextHeight) (forall (($Heap@@0 T@U)(|a#0@@13| T@U)(SequenceSetsMod._default.ArbitrarySequentialization$T@@4 T@U)($ly@@3 T@U)) (! (=> (and (and (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@4) TyType) (= (type $ly@@3) LayerTypeType)) (= (type $Heap@@0) (MapType0Type refType MapType1Type))) (= (type |a#0@@13|) (MapType0Type BoxType boolType))) (or (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|) (and (not (= 1 $FunctionContextHeight)) (and ($IsGoodHeap $Heap@@0) ($Is |a#0@@13| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@4)))))) (and (=> (not (= (|Set#Card| |a#0@@13|) (LitInt 0))) (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|) (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 (|Set#Difference| |a#0@@13| (|Set#UnionOne| (|Set#Empty| BoxType) (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|)))))) (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 ($LS $ly@@3) |a#0@@13|) (ite (= (|Set#Card| |a#0@@13|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 $ly@@3 (|Set#Difference| |a#0@@13| (|Set#UnionOne| (|Set#Empty| BoxType) (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|)))) (|Seq#Build| (|Seq#Empty| BoxType) (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|))))))) :qid |unknown.0:0!139| :skolemid |903| :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 ($LS $ly@@3) |a#0@@13|) ($IsGoodHeap $Heap@@0))))))
(assert (forall ((|l#0@@1| T@U)(|l#1@@1| T@U)(|$y#0| T@U)) (! (=> (and (and (= (type |l#0@@1|) TyType) (= (type |l#1@@1|) (SeqType BoxType))) (= (type |$y#0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|) |$y#0|)) (and ($IsBox |$y#0| |l#0@@1|) (|Seq#Contains| |l#1@@1| |$y#0|)))) :qid |unknown.0:0!156| :skolemid |909| :pattern ( (MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|) |$y#0|)))))
(declare-fun ControlFlow (Int Int) Int)
(declare-fun |b#4| () T@U)
(declare-fun |a#0@@15| () T@U)
(declare-fun SequenceSetsMod._default.ArbitrarySequentialization$T@@6 () T@U)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun |x#2@0| () T@U)
(declare-fun $Heap@@2 () T@U)
(declare-fun |b#Z#0@0| () T@U)
(declare-fun |##a#1@0| () T@U)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun $_Frame@0 () T@U)
(declare-fun |let#0#0#0| () T@U)
(declare-fun |##a#3@0| () T@U)
(declare-fun |##a#4@0| () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun $IsHeapAnchor (T@U) Bool)
(assert (and (and (and (and (and (and (and (and (and (and (and (= (type |b#4|) (SeqType BoxType)) (= (type |a#0@@15|) (MapType0Type BoxType boolType))) (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@6) TyType)) (= (type |x#2@0|) BoxType)) (= (type $Heap@@2) (MapType0Type refType MapType1Type))) (= (type |b#Z#0@0|) (SeqType BoxType))) (= (type |##a#1@0|) (MapType0Type BoxType boolType))) (= (type $_Frame@0) (MapType4Type refType boolType))) (= (type |let#0#0#0|) (SeqType BoxType))) (= (type |##a#3@0|) (MapType0Type BoxType boolType))) (= (type |##a#4@0|) (SeqType BoxType))) (= (type $_Frame@0@@0) (MapType4Type refType boolType))))
(set-info :boogie-vc-id CheckWellformed$$SequenceSetsMod.__default.ArbitrarySequentialization)
(assert (not (=> (= (ControlFlow 0 0) 48819) (=> (and ($IsGoodHeap $Heap@@2) ($IsHeapAnchor $Heap@@2)) (=> (and (and ($Is |a#0@@15| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6)) ($Is |b#4| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) (and (= 1 $FunctionContextHeight) (= (ControlFlow 0 48819) 34999))) (=> (= $_Frame@0 (|lambda#4| null $Heap@@2 alloc false)) (and (=> (= (ControlFlow 0 34999) 35003) true) (=> (= (ControlFlow 0 34999) 35010) (=> (= $_Frame@0@@0 (|lambda#5| null $Heap@@2 alloc false)) (and (=> (= (ControlFlow 0 35010) 35012) (=> (= (|Set#Card| |a#0@@15|) (LitInt 0)) (=> (and (and (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (Lit (|Seq#Empty| BoxType))) ($Is (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) (and (= |b$reqreads#0@1| true) (= (ControlFlow 0 35012) 35027))) (=> (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) |b#4|) (and (=> (= (ControlFlow 0 35027) (- 0 49626)) |b$reqreads#0@1|) (=> |b$reqreads#0@1| (=> (= (ControlFlow 0 35027) 48802) (and (=> (= (ControlFlow 0 48802) (- 0 49627)) (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|))) (=> (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|)) (=> (= (ControlFlow 0 48802) (- 0 49637)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#4|) |a#0@@15|))))))))))) (=> (= (ControlFlow 0 35010) 35019) (=> (not (= (|Set#Card| |a#0@@15|) (LitInt 0))) (and (=> (= (ControlFlow 0 35019) 35021) (=> (and (and ($IsBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) ($IsAllocBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 $Heap@@2)) (= (ControlFlow 0 35021) 35025)) (and (=> (= (ControlFlow 0 35025) (- 0 49075)) (exists ((|x#3| T@U)) (! (and (= (type |x#3|) BoxType) (and ($IsBox |x#3| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) (U_2_bool (MapType0Select |a#0@@15| |x#3|)))) :qid |SequenceSetsidfy.21:11| :skolemid |905| :no-pattern (type |x#3|) :no-pattern (U_2_int |x#3|) :no-pattern (U_2_bool |x#3|)))) (=> (exists ((|x#3@@0| T@U)) (! (and (= (type |x#3@@0|) BoxType) (and ($IsBox |x#3@@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) (U_2_bool (MapType0Select |a#0@@15| |x#3@@0|)))) :qid |SequenceSetsidfy.21:11!170| :skolemid |905| :no-pattern (U_2_bool |x#3@@0|) :no-pattern (U_2_int |x#3@@0|) :no-pattern (type |x#3@@0|))) (=> (and (and ($IsBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) ($IsAllocBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 $Heap@@2)) (U_2_bool (MapType0Select |a#0@@15| |x#2@0|))) (=> (and (and (and ($Is |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)) ($IsAlloc |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2)) (= |##a#1@0| (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (and ($IsAlloc |##a#1@0| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (= |b$reqreads#0@0| (forall (($o@@15 T@U)($f@@3 T@U)) (! (=> (and (and (= (type $o@@15) refType) (= (type $f@@3) (FieldType (FieldTypeInv0 (type $f@@3))))) false) (U_2_bool (MapType4Select $_Frame@0 $o@@15 $f@@3))) :qid |SequenceSetsidfy.22:16| :skolemid |906| :no-pattern (U_2_int $f@@3) :no-pattern (U_2_int $o@@15) :no-pattern (type $o@@15) :no-pattern (U_2_bool $o@@15) :no-pattern (type $f@@3) :no-pattern (U_2_bool $f@@3)))))) (and (=> (= (ControlFlow 0 35025) (- 0 49178)) (and (|Set#Subset| |##a#1@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#1@0|)))) (=> (and (|Set#Subset| |##a#1@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#1@0|))) (=> (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (=> (and (and (and (= |let#0#0#0| (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|))) (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (and ($Is |let#0#0#0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)) (= |b#Z#0@0| |let#0#0#0|))) (and (and ($IsAlloc |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|)) (and (= |##a#3@0| (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) ($IsAlloc |##a#3@0| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2)))) (and (=> (= (ControlFlow 0 35025) (- 0 49309)) (and (|Set#Subset| |##a#3@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#3@0|)))) (=> (and (|Set#Subset| |##a#3@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#3@0|))) (=> (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (= |##a#4@0| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))) (=> (and (and ($IsAlloc |##a#4@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))) (and (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))))) (and (=> (= (ControlFlow 0 35025) (- 0 49442)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (|Set#Union| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS ($LS $LZ)) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (=> (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (|Set#Union| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (=> (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |a#0@@15|) (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|)))) (=> (and (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) ($Is (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) (and (= |b$reqreads#0@1| |b$reqreads#0@0|) (= (ControlFlow 0 35025) 35027))) (=> (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) |b#4|) (and (=> (= (ControlFlow 0 35027) (- 0 49626)) |b$reqreads#0@1|) (=> |b$reqreads#0@1| (=> (= (ControlFlow 0 35027) 48802) (and (=> (= (ControlFlow 0 48802) (- 0 49627)) (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|))) (=> (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|)) (=> (= (ControlFlow 0 48802) (- 0 49637)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#4|) |a#0@@15|)))))))))))))))))))))))))) (=> (= (ControlFlow 0 35019) 35023) (=> (and (not (and ($IsBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) ($IsAllocBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 $Heap@@2))) (= (ControlFlow 0 35023) 35025)) (and (=> (= (ControlFlow 0 35025) (- 0 49075)) (exists ((|x#3| T@U)) (! (and (= (type |x#3|) BoxType) (and ($IsBox |x#3| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) (U_2_bool (MapType0Select |a#0@@15| |x#3|)))) :qid |SequenceSetsidfy.21:11| :skolemid |905| :no-pattern (type |x#3|) :no-pattern (U_2_int |x#3|) :no-pattern (U_2_bool |x#3|)))) (=> (exists ((|x#3@@0| T@U)) (! (and (= (type |x#3@@0|) BoxType) (and ($IsBox |x#3@@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) (U_2_bool (MapType0Select |a#0@@15| |x#3@@0|)))) :qid |SequenceSetsidfy.21:11!170| :skolemid |905| :no-pattern (U_2_bool |x#3@@0|) :no-pattern (U_2_int |x#3@@0|) :no-pattern (type |x#3@@0|))) (=> (and (and ($IsBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6) ($IsAllocBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 $Heap@@2)) (U_2_bool (MapType0Select |a#0@@15| |x#2@0|))) (=> (and (and (and ($Is |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)) ($IsAlloc |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2)) (= |##a#1@0| (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (and ($IsAlloc |##a#1@0| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (= |b$reqreads#0@0| (forall (($o@@15 T@U)($f@@3 T@U)) (! (=> (and (and (= (type $o@@15) refType) (= (type $f@@3) (FieldType (FieldTypeInv0 (type $f@@3))))) false) (U_2_bool (MapType4Select $_Frame@0 $o@@15 $f@@3))) :qid |SequenceSetsidfy.22:16| :skolemid |906| :no-pattern (U_2_int $f@@3) :no-pattern (U_2_int $o@@15) :no-pattern (type $o@@15) :no-pattern (U_2_bool $o@@15) :no-pattern (type $f@@3) :no-pattern (U_2_bool $f@@3)))))) (and (=> (= (ControlFlow 0 35025) (- 0 49178)) (and (|Set#Subset| |##a#1@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#1@0|)))) (=> (and (|Set#Subset| |##a#1@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#1@0|))) (=> (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (=> (and (and (and (= |let#0#0#0| (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|))) (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (and ($Is |let#0#0#0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)) (= |b#Z#0@0| |let#0#0#0|))) (and (and ($IsAlloc |b#Z#0@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|)) (and (= |##a#3@0| (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) ($IsAlloc |##a#3@0| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2)))) (and (=> (= (ControlFlow 0 35025) (- 0 49309)) (and (|Set#Subset| |##a#3@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#3@0|)))) (=> (and (|Set#Subset| |##a#3@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#3@0|))) (=> (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (= |##a#4@0| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))) (=> (and (and ($IsAlloc |##a#4@0| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6) $Heap@@2) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))) (and (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))))) (and (=> (= (ControlFlow 0 35025) (- 0 49442)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (|Set#Union| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS ($LS $LZ)) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (=> (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|) (|Set#Union| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))) (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (=> (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |a#0@@15|) (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|)))) (=> (and (and (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 (|Set#Difference| |a#0@@15| (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))) ($Is (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))) (and (= |b$reqreads#0@1| |b$reqreads#0@0|) (= (ControlFlow 0 35025) 35027))) (=> (= (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS $LZ) |a#0@@15|) |b#4|) (and (=> (= (ControlFlow 0 35027) (- 0 49626)) |b$reqreads#0@1|) (=> |b$reqreads#0@1| (=> (= (ControlFlow 0 35027) 48802) (and (=> (= (ControlFlow 0 48802) (- 0 49627)) (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|))) (=> (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|)) (=> (= (ControlFlow 0 48802) (- 0 49637)) (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#4|) |a#0@@15|)))))))))))))))))))))))))))))))))))))))
(check-sat)
