
(set-info :smt-lib-version |2.6|)
(set-info :category |"industrial"|)
(set-info :boogie-vc-id CheckWellformed$$SequenceSetsMod.__default.ArbitrarySequentialization)
(set-option :print-success false)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
(declare-sort T@T 0)
(declare-sort T@U 0)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun U_2_int (T@U) Int)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun Lit (T@U) T@U)
(declare-fun LitInt (Int) Int)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun bx@@10!398!0 (T@U T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun TyType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun refType () T@T)
(declare-fun $OneHeap () T@U)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun x@@18!470!1 (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun o@@23!493!2 (T@U T@U) T@U)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun o@@24!495!3 (T@U T@U) T@U)
(declare-fun o@@25!498!4 (T@U T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun SequenceSetsMod.__default.Members (T@U T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |SequenceSetsMod.__default.Members#canCall| (T@U T@U) Bool)
(declare-fun |lambda#2| (T@U T@U) T@U)
(declare-fun SequenceSetsMod.__default.ArbitrarySequentialization             (T@U T@U T@U)             T@U)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun |SequenceSetsMod.__default.ArbitrarySequentialization#canCall|             (T@U T@U)             Bool)
(declare-fun |$let#0_x| (T@U T@U) T@U)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun |$let#0$canCall| (T@U T@U) Bool)
(declare-fun |b#4| () T@U)
(declare-fun |a#0@@15| () T@U)
(declare-fun SequenceSetsMod._default.ArbitrarySequentialization$T@@6 () T@U)
(declare-fun |x#2@0| () T@U)
(declare-fun $Heap@@2 () T@U)
(declare-fun |b#Z#0@0| () T@U)
(declare-fun |##a#1@0| () T@U)
(declare-fun MapType4Type (T@T T@T) T@T)
(declare-fun $_Frame@0 () T@U)
(declare-fun |let#0#0#0| () T@U)
(declare-fun |##a#3@0| () T@U)
(declare-fun |##a#4@0| () T@U)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun alloc () T@U)
(declare-fun null () T@U)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun MapType4Select (T@U T@U T@U) T@U)
(declare-fun $f@@3!906!6 () T@U)
(declare-fun $o@@15!906!7 () T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun |x#3@@0!905!5| () T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(assert (= (Ctor intType) 0))
(assert (= (Ctor realType) 1))
(assert (= (Ctor boolType) 2))
(assert (= (Ctor rmodeType) 3))
(assert (= (Ctor stringType) 4))
(assert (= (Ctor regexType) 5))
(assert (forall ((arg0 Int))  (! (= (U_2_int (int_2_U arg0)) arg0)     :pattern ((int_2_U arg0))     :qid |typeInv:U_2_int|)))
(assert (forall ((x T@U))  (! (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))     :pattern ((U_2_int x))     :qid |cast:U_2_int|)))
(assert (forall ((arg0@@0 Int))  (! (= (type (int_2_U arg0@@0)) intType)     :pattern ((int_2_U arg0@@0))     :qid |funType:int_2_U|)))
(assert (forall ((arg0@@1 Real))  (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)     :pattern ((real_2_U arg0@@1))     :qid |typeInv:U_2_real|)))
(assert (forall ((x@@0 T@U))  (! (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))     :pattern ((U_2_real x@@0))     :qid |cast:U_2_real|)))
(assert (forall ((arg0@@2 Real))  (! (= (type (real_2_U arg0@@2)) realType)     :pattern ((real_2_U arg0@@2))     :qid |funType:real_2_U|)))
(assert (forall ((arg0@@3 Bool))  (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)     :pattern ((bool_2_U arg0@@3))     :qid |typeInv:U_2_bool|)))
(assert (forall ((x@@1 T@U))  (! (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))     :pattern ((U_2_bool x@@1))     :qid |cast:U_2_bool|)))
(assert (forall ((arg0@@4 Bool))  (! (= (type (bool_2_U arg0@@4)) boolType)     :pattern ((bool_2_U arg0@@4))     :qid |funType:bool_2_U|)))
(assert (forall ((arg0@@5 RoundingMode))  (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)     :pattern ((rmode_2_U arg0@@5))     :qid |typeInv:U_2_rmode|)))
(assert (forall ((x@@2 T@U))  (! (=> (= (type x@@2) rmodeType) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))     :pattern ((U_2_rmode x@@2))     :qid |cast:U_2_rmode|)))
(assert (forall ((arg0@@6 RoundingMode))  (! (= (type (rmode_2_U arg0@@6)) rmodeType)     :pattern ((rmode_2_U arg0@@6))     :qid |funType:rmode_2_U|)))
(assert (forall ((arg0@@7 String))  (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)     :pattern ((string_2_U arg0@@7))     :qid |typeInv:U_2_string|)))
(assert (forall ((x@@3 T@U))  (! (=> (= (type x@@3) stringType) (= (string_2_U (U_2_string x@@3)) x@@3))     :pattern ((U_2_string x@@3))     :qid |cast:U_2_string|)))
(assert (forall ((arg0@@8 String))  (! (= (type (string_2_U arg0@@8)) stringType)     :pattern ((string_2_U arg0@@8))     :qid |funType:string_2_U|)))
(assert (forall ((arg0@@9 (RegEx String)))  (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)     :pattern ((regex_2_U arg0@@9))     :qid |typeInv:U_2_regex|)))
(assert (forall ((x@@4 T@U))  (! (=> (= (type x@@4) regexType) (= (regex_2_U (U_2_regex x@@4)) x@@4))     :pattern ((U_2_regex x@@4))     :qid |cast:U_2_regex|)))
(assert (forall ((arg0@@10 (RegEx String)))  (! (= (type (regex_2_U arg0@@10)) regexType)     :pattern ((regex_2_U arg0@@10))     :qid |funType:regex_2_U|)))
(assert (forall ((x@@8 T@U))  (! (= (Lit x@@8) x@@8)     :pattern ((Lit x@@8))     :skolemid |362|     :qid |DafnyPreludebpl.89:29|)))
(assert (forall ((x@@10 Int))  (! (= (LitInt x@@10) x@@10)     :pattern ((LitInt x@@10))     :skolemid |364|     :qid |DafnyPreludebpl.95:29|)))
(assert (forall ((arg0@@35 T@T) (arg1@@3 T@T))  (! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15) :qid |ctor:MapType0Type|)))
(assert (forall ((arg0@@36 T@T) (arg1@@4 T@T))  (! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36)     :pattern ((MapType0Type arg0@@36 arg1@@4))     :qid |typeInv:MapType0TypeInv0|)))
(assert (forall ((arg0@@37 T@T) (arg1@@5 T@T))  (! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5)     :pattern ((MapType0Type arg0@@37 arg1@@5))     :qid |typeInv:MapType0TypeInv1|)))
(assert (forall ((arg0@@38 T@U) (arg1@@6 T@U))  (! (= (type (MapType0Select arg0@@38 arg1@@6))        (MapType0TypeInv1 (type arg0@@38)))     :pattern ((MapType0Select arg0@@38 arg1@@6))     :qid |funType:MapType0Select|)))
(assert (forall ((arg2 T@U) (arg0@@39 T@U) (arg1@@7 T@U))  (! (= (type (MapType0Store arg0@@39 arg1@@7 arg2))        (MapType0Type (type arg1@@7) (type arg2)))     :pattern ((MapType0Store arg0@@39 arg1@@7 arg2))     :qid |funType:MapType0Store|)))
(assert (forall ((m T@U) (x0 T@U) (val T@U))  (! (=> (= (type val) (MapType0TypeInv1 (type m)))         (= (MapType0Select (MapType0Store m x0 val) x0) val))     :weight 0     :qid |mapAx0:MapType0Select|)))
(assert (forall ((x0@@0 T@U) (y0 T@U) (val@@0 T@U) (m@@0 T@U))  (! (or (= x0@@0 y0)         (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0)            (MapType0Select m@@0 y0)))     :weight 0     :qid |mapAx1:MapType0Select:0|)))
(assert (forall ((y0@@0 T@U) (val@@1 T@U) (m@@1 T@U) (x0@@1 T@U))  (! (or true         (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0)            (MapType0Select m@@1 y0@@0)))     :weight 0     :qid |mapAx2:MapType0Select|)))
(assert (forall ((arg0@@40 T@T))  (! (= (Ctor (SeqType arg0@@40)) 16) :qid |ctor:SeqType|)))
(assert (forall ((arg0@@41 T@T))  (! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41)     :pattern ((SeqType arg0@@41))     :qid |typeInv:SeqTypeInv0|)))
(assert (forall ((v@@13 T@U) (t0 T@U))  (! (let ((a!1 (not (and (= (type v@@13) (MapType0Type BoxType boolType))                          (= (type t0) TyType))))           (a!2 (forall ((bx@@10 T@U))                  (! (=> (and (= (type bx@@10) BoxType)                              (U_2_bool (MapType0Select v@@13 bx@@10)))                         ($IsBox bx@@10 t0))                     :pattern ((MapType0Select v@@13 bx@@10))                     :skolemid |398|                     :qid |DafnyPreludebpl.221:11|)))           (a!4 (and (= (type (bx@@10!398!0 t0 v@@13)) BoxType)                     (U_2_bool (MapType0Select v@@13 (bx@@10!398!0 t0 v@@13))))))     (let ((a!3 (or (not ($Is v@@13 (TSet t0))) a!2))           (a!5 (not (=> a!4 ($IsBox (bx@@10!398!0 t0 v@@13) t0)))))     (let ((a!6 (and a!3 (or ($Is v@@13 (TSet t0)) a!5))))       (or a!1 a!6))))     :pattern (($Is v@@13 (TSet t0)))     :skolemid |399|     :qid |DafnyPreludebpl.219:15|)))
(assert (forall ((arg0@@68 T@U))  (! (= (type ($LS arg0@@68)) LayerTypeType)     :pattern (($LS arg0@@68))     :qid |funType:$LS|)))
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type)))
(assert (forall ((s@@3 T@U))  (! (let ((a!1 (= (type s@@3)                   (MapType0Type (MapType0TypeInv0 (type s@@3)) boolType))))       (=> a!1 (<= 0 (|Set#Card| s@@3))))     :pattern ((|Set#Card| s@@3))     :skolemid |468|     :qid |DafnyPreludebpl.624:18|)))
(assert (forall ((T@@6 T@T))  (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType))     :pattern ((|Set#Empty| T@@6))     :qid |funType:Set#Empty|)))
(assert (forall ((o@@17 T@U))  (! (let ((a!1 (U_2_bool (MapType0Select (|Set#Empty| (type o@@17)) o@@17))))       (not a!1))     :pattern ((MapType0Select (|Set#Empty| (type o@@17)) o@@17))     :skolemid |469|     :qid |DafnyPreludebpl.627:18|)))
(assert (forall ((s@@4 T@U))  (! (let ((a!1 (= (type s@@4)                   (MapType0Type (MapType0TypeInv0 (type s@@4)) boolType)))           (a!2 (= s@@4 (|Set#Empty| (MapType0TypeInv0 (type s@@4)))))           (a!3 (not (not (= (|Set#Card| s@@4) 0))))           (a!4 (and (= (type (x@@18!470!1 s@@4))                        (MapType0TypeInv0 (type s@@4)))                     (U_2_bool (MapType0Select s@@4 (x@@18!470!1 s@@4))))))     (let ((a!5 (and (= (= (|Set#Card| s@@4) 0) a!2) (or a!3 a!4))))       (or (not a!1) a!5)))     :pattern ((|Set#Card| s@@4))     :skolemid |471|     :qid |DafnyPreludebpl.628:18|)))
(assert (forall ((arg0@@76 T@U) (arg1@@24 T@U))  (! (= (type (|Set#UnionOne| arg0@@76 arg1@@24))        (MapType0Type (type arg1@@24) boolType))     :pattern ((|Set#UnionOne| arg0@@76 arg1@@24))     :qid |funType:Set#UnionOne|)))
(assert (forall ((a@@3 T@U) (x@@19 T@U) (o@@19 T@U))  (! (let ((a!1 (and (= (type a@@3) (MapType0Type (type x@@19) boolType))                     (= (type o@@19) (type x@@19))))           (a!2 (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))                   (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))))       (=> a!1 a!2))     :pattern ((MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))     :skolemid |475|     :qid |DafnyPreludebpl.641:18|)))
(assert (forall ((a@@4 T@U) (x@@20 T@U))  (! (=> (= (type a@@4) (MapType0Type (type x@@20) boolType))         (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20)))     :pattern ((|Set#UnionOne| a@@4 x@@20))     :skolemid |476|     :qid |DafnyPreludebpl.643:18|)))
(assert (forall ((a@@7 T@U) (x@@23 T@U))  (! (let ((a!1 (and (= (type a@@7) (MapType0Type (type x@@23) boolType))                     (not (U_2_bool (MapType0Select a@@7 x@@23))))))       (=> a!1           (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))))     :pattern ((|Set#Card| (|Set#UnionOne| a@@7 x@@23)))     :skolemid |479|     :qid |DafnyPreludebpl.649:18|)))
(assert (forall ((arg0@@77 T@U) (arg1@@25 T@U))  (! (= (type (|Set#Union| arg0@@77 arg1@@25))        (MapType0Type (MapType0TypeInv0 (type arg0@@77)) boolType))     :pattern ((|Set#Union| arg0@@77 arg1@@25))     :qid |funType:Set#Union|)))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (o@@20 T@U))  (! (let ((a!1 (and (= (type a@@8) (MapType0Type (type o@@20) boolType))                     (= (type b@@3) (MapType0Type (type o@@20) boolType))))           (a!2 (= (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))                   (or (U_2_bool (MapType0Select a@@8 o@@20))                       (U_2_bool (MapType0Select b@@3 o@@20))))))       (=> a!1 a!2))     :pattern ((MapType0Select (|Set#Union| a@@8 b@@3) o@@20))     :skolemid |480|     :qid |DafnyPreludebpl.653:18|)))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (y@@3 T@U))  (! (let ((a!1 (and (= (type a@@10) (MapType0Type (type y@@3) boolType))                     (= (type b@@5) (MapType0Type (type y@@3) boolType))                     (U_2_bool (MapType0Select b@@5 y@@3)))))       (=> a!1 (U_2_bool (MapType0Select (|Set#Union| a@@10 b@@5) y@@3))))     :pattern ((|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3))     :skolemid |482|     :qid |DafnyPreludebpl.657:18|)))
(assert (forall ((arg0@@78 T@U) (arg1@@26 T@U))  (! (= (type (|Set#Difference| arg0@@78 arg1@@26))        (MapType0Type (MapType0TypeInv0 (type arg0@@78)) boolType))     :pattern ((|Set#Difference| arg0@@78 arg1@@26))     :qid |funType:Set#Difference|)))
(assert (forall ((a@@11 T@U) (b@@6 T@U))  (! (let ((a!1 (= (type a@@11)                   (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType)))           (a!2 (= (type b@@6)                   (MapType0Type (MapType0TypeInv0 (type a@@11)) boolType)))           (a!3 (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6)                     (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))))       (=> (and a!1 a!2 (|Set#Disjoint| a@@11 b@@6)) a!3))     :pattern ((|Set#Union| a@@11 b@@6))     :skolemid |483|     :qid |DafnyPreludebpl.659:18|)))
(assert (forall ((arg1@@27 T@U) (arg0@@79 T@U))  (! (= (type (|Set#Intersection| arg0@@79 arg1@@27))        (MapType0Type (MapType0TypeInv0 (type arg0@@79)) boolType))     :pattern ((|Set#Intersection| arg0@@79 arg1@@27))     :qid |funType:Set#Intersection|)))
(assert (forall ((a@@12 T@U) (b@@7 T@U) (o@@21 T@U))  (! (let ((a!1 (and (= (type a@@12) (MapType0Type (type o@@21) boolType))                     (= (type b@@7) (MapType0Type (type o@@21) boolType))))           (a!2 (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7)                                             o@@21))                   (and (U_2_bool (MapType0Select a@@12 o@@21))                        (U_2_bool (MapType0Select b@@7 o@@21))))))       (=> a!1 a!2))     :pattern ((MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))     :skolemid |484|     :qid |DafnyPreludebpl.669:18|)))
(assert (forall ((a@@13 T@U) (b@@8 T@U))  (! (let ((a!1 (= (type a@@13)                   (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType)))           (a!2 (= (type b@@8)                   (MapType0Type (MapType0TypeInv0 (type a@@13)) boolType))))       (=> (and a!1 a!2)           (= (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8)              (|Set#Union| a@@13 b@@8))))     :pattern ((|Set#Union| (|Set#Union| a@@13 b@@8) b@@8))     :skolemid |485|     :qid |DafnyPreludebpl.672:18|)))
(assert (forall ((a@@14 T@U) (b@@9 T@U))  (! (let ((a!1 (= (type a@@14)                   (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType)))           (a!2 (= (type b@@9)                   (MapType0Type (MapType0TypeInv0 (type a@@14)) boolType))))       (=> (and a!1 a!2)           (= (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9))              (|Set#Union| a@@14 b@@9))))     :pattern ((|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)))     :skolemid |486|     :qid |DafnyPreludebpl.674:18|)))
(assert (forall ((a@@17 T@U) (b@@12 T@U))  (! (let ((a!1 (= (type a@@17)                   (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType)))           (a!2 (= (type b@@12)                   (MapType0Type (MapType0TypeInv0 (type a@@17)) boolType)))           (a!3 (= (+ (|Set#Card| (|Set#Union| a@@17 b@@12))                      (|Set#Card| (|Set#Intersection| a@@17 b@@12)))                   (+ (|Set#Card| a@@17) (|Set#Card| b@@12)))))       (=> (and a!1 a!2) a!3))     :pattern ((|Set#Card| (|Set#Intersection| a@@17 b@@12)))     :pattern ((|Set#Card| (|Set#Union| a@@17 b@@12)))     :skolemid |489|     :qid |DafnyPreludebpl.680:18|)))
(assert (forall ((b@@13 T@U) (o@@22 T@U) (a@@18 T@U))  (! (let ((a!1 (and (= (type a@@18) (MapType0Type (type o@@22) boolType))                     (= (type b@@13) (MapType0Type (type o@@22) boolType))))           (a!2 (and (U_2_bool (MapType0Select a@@18 o@@22))                     (not (U_2_bool (MapType0Select b@@13 o@@22))))))     (let ((a!3 (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13)                                             o@@22))                   a!2)))       (=> a!1 a!3)))     :pattern ((MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))     :skolemid |490|     :qid |DafnyPreludebpl.684:18|)))
(assert (forall ((b@@14 T@U) (y@@4 T@U) (a@@19 T@U))  (! (let ((a!1 (and (= (type a@@19) (MapType0Type (type y@@4) boolType))                     (= (type b@@14) (MapType0Type (type y@@4) boolType))                     (U_2_bool (MapType0Select b@@14 y@@4))))           (a!2 (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14)                                               y@@4)))))       (=> a!1 a!2))     :pattern ((|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4))     :skolemid |491|     :qid |DafnyPreludebpl.686:18|)))
(assert (forall ((a@@20 T@U) (b@@15 T@U))  (! (let ((a!1 (= (type a@@20)                   (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType)))           (a!2 (= (type b@@15)                   (MapType0Type (MapType0TypeInv0 (type a@@20)) boolType)))           (a!3 (= (+ (|Set#Card| (|Set#Difference| a@@20 b@@15))                      (|Set#Card| (|Set#Difference| b@@15 a@@20))                      (|Set#Card| (|Set#Intersection| a@@20 b@@15)))                   (|Set#Card| (|Set#Union| a@@20 b@@15))))           (a!4 (= (|Set#Card| (|Set#Difference| a@@20 b@@15))                   (- (|Set#Card| a@@20)                      (|Set#Card| (|Set#Intersection| a@@20 b@@15))))))       (=> (and a!1 a!2) (and a!3 a!4)))     :pattern ((|Set#Card| (|Set#Difference| a@@20 b@@15)))     :skolemid |492|     :qid |DafnyPreludebpl.688:18|)))
(assert (forall ((a@@21 T@U) (b@@16 T@U))  (! (let ((a!1 (= (type a@@21)                   (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType)))           (a!2 (= (type b@@16)                   (MapType0Type (MapType0TypeInv0 (type a@@21)) boolType)))           (a!3 (forall ((o@@23 T@U))                  (! (let ((a!1 (and (= (type o@@23)                                        (MapType0TypeInv0 (type a@@21)))                                     (U_2_bool (MapType0Select a@@21 o@@23)))))                       (=> a!1 (U_2_bool (MapType0Select b@@16 o@@23))))                     :pattern ((MapType0Select a@@21 o@@23))                     :pattern ((MapType0Select b@@16 o@@23))                     :skolemid |493|                     :qid |DafnyPreludebpl.697:32|)))           (a!4 (and (= (type (o@@23!493!2 b@@16 a@@21))                        (MapType0TypeInv0 (type a@@21)))                     (U_2_bool (MapType0Select a@@21 (o@@23!493!2 b@@16 a@@21))))))     (let ((a!5 (=> a!4                    (U_2_bool (MapType0Select b@@16 (o@@23!493!2 b@@16 a@@21))))))     (let ((a!6 (and (or (not (|Set#Subset| a@@21 b@@16)) a!3)                     (or (|Set#Subset| a@@21 b@@16) (not a!5)))))       (or (not (and a!1 a!2)) a!6))))     :pattern ((|Set#Subset| a@@21 b@@16))     :skolemid |494|     :qid |DafnyPreludebpl.696:17|)))
(assert (forall ((a@@22 T@U) (b@@17 T@U))  (! (let ((a!1 (= (type a@@22)                   (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType)))           (a!2 (= (type b@@17)                   (MapType0Type (MapType0TypeInv0 (type a@@22)) boolType)))           (a!3 (forall ((o@@24 T@U))                  (! (=> (= (type o@@24) (MapType0TypeInv0 (type a@@22)))                         (= (U_2_bool (MapType0Select a@@22 o@@24))                            (U_2_bool (MapType0Select b@@17 o@@24))))                     :pattern ((MapType0Select b@@17 o@@24))                     :pattern ((MapType0Select a@@22 o@@24))                     :skolemid |495|                     :qid |DafnyPreludebpl.705:31|)))           (a!4 (= (U_2_bool (MapType0Select a@@22 (o@@24!495!3 b@@17 a@@22)))                   (U_2_bool (MapType0Select b@@17 (o@@24!495!3 b@@17 a@@22))))))     (let ((a!5 (=> (= (type (o@@24!495!3 b@@17 a@@22))                       (MapType0TypeInv0 (type a@@22)))                    a!4)))     (let ((a!6 (and (or (not (|Set#Equal| a@@22 b@@17)) a!3)                     (or (|Set#Equal| a@@22 b@@17) (not a!5)))))       (or (not (and a!1 a!2)) a!6))))     :pattern ((|Set#Equal| a@@22 b@@17))     :skolemid |496|     :qid |DafnyPreludebpl.704:17|)))
(assert (forall ((a@@23 T@U) (b@@18 T@U))  (! (let ((a!1 (= (type a@@23)                   (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType)))           (a!2 (= (type b@@18)                   (MapType0Type (MapType0TypeInv0 (type a@@23)) boolType))))       (=> (and a!1 a!2 (|Set#Equal| a@@23 b@@18)) (= a@@23 b@@18)))     :pattern ((|Set#Equal| a@@23 b@@18))     :skolemid |497|     :qid |DafnyPreludebpl.706:17|)))
(assert (forall ((a@@24 T@U) (b@@19 T@U))  (! (let ((a!1 (= (type a@@24)                   (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType)))           (a!2 (= (type b@@19)                   (MapType0Type (MapType0TypeInv0 (type a@@24)) boolType)))           (a!3 (forall ((o@@25 T@U))                  (! (let ((a!1 (or (not (U_2_bool (MapType0Select a@@24 o@@25)))                                    (not (U_2_bool (MapType0Select b@@19 o@@25))))))                       (=> (= (type o@@25) (MapType0TypeInv0 (type a@@24))) a!1))                     :pattern ((MapType0Select b@@19 o@@25))                     :pattern ((MapType0Select a@@24 o@@25))                     :skolemid |498|                     :qid |DafnyPreludebpl.711:34|)))           (a!4 (not (U_2_bool (MapType0Select a@@24 (o@@25!498!4 b@@19 a@@24)))))           (a!5 (not (U_2_bool (MapType0Select b@@19 (o@@25!498!4 b@@19 a@@24))))))     (let ((a!6 (=> (= (type (o@@25!498!4 b@@19 a@@24))                       (MapType0TypeInv0 (type a@@24)))                    (or a!4 a!5))))     (let ((a!7 (and (or (not (|Set#Disjoint| a@@24 b@@19)) a!3)                     (or (|Set#Disjoint| a@@24 b@@19) (not a!6)))))       (or (not (and a!1 a!2)) a!7))))     :pattern ((|Set#Disjoint| a@@24 b@@19))     :skolemid |499|     :qid |DafnyPreludebpl.710:18|)))
(assert (forall ((arg0@@91 T@U) (arg1@@36 T@U))  (! (= (type (|Seq#Build| arg0@@91 arg1@@36)) (SeqType (type arg1@@36)))     :pattern ((|Seq#Build| arg0@@91 arg1@@36))     :qid |funType:Seq#Build|)))
(assert (forall ((T@@99 T@T))  (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99))     :pattern ((|Seq#Empty| T@@99))     :qid |funType:Seq#Empty|)))
(assert (forall ((T@@107 T@T))  (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0)     :pattern ((|Seq#Empty| T@@107))     :skolemid |567|     :qid k!213)))
(assert (forall ((s@@18 T@U) (v@@31 T@U))  (! (=> (= (type s@@18) (SeqType (type v@@31)))         (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18))))     :pattern ((|Seq#Build| s@@18 v@@31))     :skolemid |571|     :qid |DafnyPreludebpl.952:18|)))
(assert (forall ((s0 T@U) (s1 T@U))  (! (let ((a!1 (= (type s0) (SeqType (SeqTypeInv0 (type s0)))))           (a!2 (= (type s1) (SeqType (SeqTypeInv0 (type s0))))))       (=> (and a!1 a!2)           (= (|Seq#Length| (|Seq#Append| s0 s1))              (+ (|Seq#Length| s0) (|Seq#Length| s1)))))     :pattern ((|Seq#Length| (|Seq#Append| s0 s1)))     :skolemid |576|     :qid |DafnyPreludebpl.974:18|)))
(assert (forall ((x@@37 T@U))  (! (not (|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37))     :pattern ((|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37))     :skolemid |583|     :qid |DafnyPreludebpl.995:18|)))
(assert (forall ((x@@38 T@U) (s0@@1 T@U) (s1@@1 T@U))  (! (let ((a!1 (and (= (type s0@@1) (SeqType (type x@@38)))                     (= (type s1@@1) (SeqType (type x@@38))))))       (=> a!1           (= (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38)              (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))))     :pattern ((|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38))     :skolemid |584|     :qid |DafnyPreludebpl.999:18|)))
(assert (forall ((x@@39 T@U) (s@@24 T@U) (v@@35 T@U))  (! (let ((a!1 (and (= (type s@@24) (SeqType (type v@@35)))                     (= (type x@@39) (type v@@35)))))       (=> a!1           (= (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39)              (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))))     :pattern ((|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39))     :skolemid |585|     :qid |DafnyPreludebpl.1004:18|)))
(assert (forall ((arg0@@170 T@U) (arg1@@80 T@U))  (! (= (type (SequenceSetsMod.__default.Members arg0@@170 arg1@@80))        (MapType0Type BoxType boolType))     :pattern ((SequenceSetsMod.__default.Members arg0@@170 arg1@@80))     :qid |funType:SequenceSetsMod.__default.Members|)))
(assert (let ((a!1 (forall ((SequenceSetsMod._default.Members$T T@U) (|a#0@@5| T@U))             (! (let ((a!1 (or (|SequenceSetsMod.__default.Members#canCall|                                 SequenceSetsMod._default.Members$T                                 |a#0@@5|)                               (and (not (= 0 $FunctionContextHeight))                                    ($Is |a#0@@5|                                         (TSeq SequenceSetsMod._default.Members$T))))))                  (=> (and (= (type SequenceSetsMod._default.Members$T) TyType)                           (= (type |a#0@@5|) (SeqType BoxType))                           a!1)                      ($Is (SequenceSetsMod.__default.Members                             SequenceSetsMod._default.Members$T                             |a#0@@5|)                           (TSet SequenceSetsMod._default.Members$T))))                :pattern ((SequenceSetsMod.__default.Members                            SequenceSetsMod._default.Members$T                            |a#0@@5|))                :skolemid |894|                :qid |unknown.0:0!127|))))  (or (not (<= 0 $FunctionContextHeight)) a!1)))
(assert (let ((a!1 (forall ((SequenceSetsMod._default.Members$T@@1 T@U) (|a#0@@7| T@U))             (! (let ((a!1 (or (|SequenceSetsMod.__default.Members#canCall|                                 SequenceSetsMod._default.Members$T@@1                                 |a#0@@7|)                               (and (not (= 0 $FunctionContextHeight))                                    ($Is |a#0@@7|                                         (TSeq SequenceSetsMod._default.Members$T@@1))))))                  (=> (and (= (type SequenceSetsMod._default.Members$T@@1)                              TyType)                           (= (type |a#0@@7|) (SeqType BoxType))                           a!1)                      (= (SequenceSetsMod.__default.Members                           SequenceSetsMod._default.Members$T@@1                           |a#0@@7|)                         (|lambda#2| SequenceSetsMod._default.Members$T@@1                                     |a#0@@7|))))                :pattern ((SequenceSetsMod.__default.Members                            SequenceSetsMod._default.Members$T@@1                            |a#0@@7|))                :skolemid |896|                :qid |unknown.0:0!130|))))  (or (not (<= 0 $FunctionContextHeight)) a!1)))
(assert (let ((a!1 (forall ((SequenceSetsMod._default.Members$T@@2 T@U) (|a#0@@8| T@U))             (! (let ((a!1 (or (|SequenceSetsMod.__default.Members#canCall|                                 SequenceSetsMod._default.Members$T@@2                                 (Lit |a#0@@8|))                               (and (not (= 0 $FunctionContextHeight))                                    ($Is |a#0@@8|                                         (TSeq SequenceSetsMod._default.Members$T@@2))))))                  (=> (and (= (type SequenceSetsMod._default.Members$T@@2)                              TyType)                           (= (type |a#0@@8|) (SeqType BoxType))                           a!1)                      (= (SequenceSetsMod.__default.Members                           SequenceSetsMod._default.Members$T@@2                           (Lit |a#0@@8|))                         (|lambda#2| SequenceSetsMod._default.Members$T@@2                                     |a#0@@8|))))                :pattern ((SequenceSetsMod.__default.Members                            SequenceSetsMod._default.Members$T@@2                            (Lit |a#0@@8|)))                :weight 3                :skolemid |897|                :qid |unknown.0:0!131|))))  (or (not (<= 0 $FunctionContextHeight)) a!1)))
(assert (forall ((arg0@@172 T@U) (arg1@@82 T@U) (arg2@@32 T@U))  (! (= (type (SequenceSetsMod.__default.ArbitrarySequentialization                arg0@@172                arg1@@82                arg2@@32))        (SeqType BoxType))     :pattern ((SequenceSetsMod.__default.ArbitrarySequentialization                 arg0@@172                 arg1@@82                 arg2@@32))     :qid |funType:SequenceSetsMod.__default.ArbitrarySequentialization|)))
(assert (forall ((SequenceSetsMod._default.ArbitrarySequentialization$T T@U)         ($ly T@U)         (|a#0@@9| T@U))  (! (=> (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T)                 TyType)              (= (type $ly) LayerTypeType)              (= (type |a#0@@9|) (MapType0Type BoxType boolType)))         (= (SequenceSetsMod.__default.ArbitrarySequentialization              SequenceSetsMod._default.ArbitrarySequentialization$T              ($LS $ly)              |a#0@@9|)            (SequenceSetsMod.__default.ArbitrarySequentialization              SequenceSetsMod._default.ArbitrarySequentialization$T              $ly              |a#0@@9|)))     :pattern ((SequenceSetsMod.__default.ArbitrarySequentialization                 SequenceSetsMod._default.ArbitrarySequentialization$T                 ($LS $ly)                 |a#0@@9|))     :skolemid |898|     :qid |unknown.0:0!132|)))
(assert (forall ((arg0@@173 T@U))  (! (= (type (AsFuelBottom arg0@@173)) LayerTypeType)     :pattern ((AsFuelBottom arg0@@173))     :qid |funType:AsFuelBottom|)))
(assert (= (type $LZ) LayerTypeType))
(assert (let ((a!1 (forall (($ly@@1 T@U)                    (|a#0@@11| T@U)                    (SequenceSetsMod._default.ArbitrarySequentialization$T@@1 T@U))             (! (let ((a!1 (or (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall|                                 SequenceSetsMod._default.ArbitrarySequentialization$T@@1                                 |a#0@@11|)                               (and (not (= 1 $FunctionContextHeight))                                    ($Is |a#0@@11|                                         (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@1)))))                      (a!2 (and (= (|Seq#Length| (SequenceSetsMod.__default.ArbitrarySequentialization                                                   SequenceSetsMod._default.ArbitrarySequentialization$T@@1                                                   $ly@@1                                                   |a#0@@11|))                                   (|Set#Card| |a#0@@11|))                                (|Set#Equal| (SequenceSetsMod.__default.Members                                               SequenceSetsMod._default.ArbitrarySequentialization$T@@1                                               (SequenceSetsMod.__default.ArbitrarySequentialization                                                 SequenceSetsMod._default.ArbitrarySequentialization$T@@1                                                 $ly@@1                                                 |a#0@@11|))                                             |a#0@@11|)                                ($Is (SequenceSetsMod.__default.ArbitrarySequentialization                                       SequenceSetsMod._default.ArbitrarySequentialization$T@@1                                       $ly@@1                                       |a#0@@11|)                                     (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@1)))))                  (=> (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@1)                              TyType)                           (= (type $ly@@1) LayerTypeType)                           (= (type |a#0@@11|) (MapType0Type BoxType boolType))                           a!1)                      a!2))                :pattern ((SequenceSetsMod.__default.ArbitrarySequentialization                            SequenceSetsMod._default.ArbitrarySequentialization$T@@1                            $ly@@1                            |a#0@@11|))                :skolemid |900|                :qid |unknown.0:0!135|))))  (or (not (<= 1 $FunctionContextHeight)) a!1)))
(assert (forall ((arg0@@174 T@U) (arg1@@83 T@U))  (! (= (type (|$let#0_x| arg0@@174 arg1@@83)) BoxType)     :pattern ((|$let#0_x| arg0@@174 arg1@@83))     :qid |funType:$let#0_x|)))
(assert (let ((a!1 (forall (($Heap@@0 T@U)                    (|a#0@@13| T@U)                    (SequenceSetsMod._default.ArbitrarySequentialization$T@@4 T@U)                    ($ly@@3 T@U))             (! (let ((a!1 (or (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall|                                 SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                 |a#0@@13|)                               (and (not (= 1 $FunctionContextHeight))                                    ($IsGoodHeap $Heap@@0)                                    ($Is |a#0@@13|                                         (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@4)))))                      (a!2 (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall|                             SequenceSetsMod._default.ArbitrarySequentialization$T@@4                             (|Set#Difference| |a#0@@13|                                               (|Set#UnionOne| (|Set#Empty| BoxType)                                                               (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                                                           |a#0@@13|)))))                      (a!4 (SequenceSetsMod.__default.ArbitrarySequentialization                             SequenceSetsMod._default.ArbitrarySequentialization$T@@4                             $ly@@3                             (|Set#Difference| |a#0@@13|                                               (|Set#UnionOne| (|Set#Empty| BoxType)                                                               (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                                                           |a#0@@13|))))))                (let ((a!3 (=> (not (= (|Set#Card| |a#0@@13|) (LitInt 0)))                               (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                                      |a#0@@13|)                                    a!2)))                      (a!5 (ite (= (|Set#Card| |a#0@@13|) (LitInt 0))                                (|Seq#Empty| BoxType)                                (|Seq#Append| a!4                                              (|Seq#Build| (|Seq#Empty| BoxType)                                                           (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                                                       |a#0@@13|))))))                (let ((a!6 (and a!3                                (= (SequenceSetsMod.__default.ArbitrarySequentialization                                     SequenceSetsMod._default.ArbitrarySequentialization$T@@4                                     ($LS $ly@@3)                                     |a#0@@13|)                                   a!5))))                  (=> (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@4)                              TyType)                           (= (type $ly@@3) LayerTypeType)                           (= (type $Heap@@0)                              (MapType0Type refType MapType1Type))                           (= (type |a#0@@13|) (MapType0Type BoxType boolType))                           a!1)                      a!6))))                :pattern ((SequenceSetsMod.__default.ArbitrarySequentialization                            SequenceSetsMod._default.ArbitrarySequentialization$T@@4                            ($LS $ly@@3)                            |a#0@@13|)                          ($IsGoodHeap $Heap@@0))                :skolemid |903|                :qid |unknown.0:0!139|))))  (or (not (<= 1 $FunctionContextHeight)) a!1)))
(assert (forall ((|l#0@@1| T@U) (|l#1@@1| T@U) (|$y#0| T@U))  (! (let ((a!1 (= (U_2_bool (MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|)                                             |$y#0|))                   (and ($IsBox |$y#0| |l#0@@1|)                        (|Seq#Contains| |l#1@@1| |$y#0|)))))       (=> (and (= (type |l#0@@1|) TyType)                (= (type |l#1@@1|) (SeqType BoxType))                (= (type |$y#0|) BoxType))           a!1))     :pattern ((MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|) |$y#0|))     :skolemid |909|     :qid |unknown.0:0!156|)))
(assert (= (type |b#4|) (SeqType BoxType)))
(assert (= (type |a#0@@15|) (MapType0Type BoxType boolType)))
(assert (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@6) TyType))
(assert (= (type |x#2@0|) BoxType))
(assert (= (type $Heap@@2) (MapType0Type refType MapType1Type)))
(assert (= (type |b#Z#0@0|) (SeqType BoxType)))
(assert (= (type |##a#1@0|) (MapType0Type BoxType boolType)))
(assert (= (type $_Frame@0) (MapType4Type refType boolType)))
(assert (= (type |let#0#0#0|) (SeqType BoxType)))
(assert (= (type |##a#3@0|) (MapType0Type BoxType boolType)))
(assert (= (type |##a#4@0|) (SeqType BoxType)))
(assert (= (type $_Frame@0@@0) (MapType4Type refType boolType)))
(assert (= (ControlFlow 0 0) 48819))
(assert ($IsGoodHeap $Heap@@2))
(assert ($IsHeapAnchor $Heap@@2))
(assert ($Is |a#0@@15| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
(assert ($Is |b#4| (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
(assert (= 1 $FunctionContextHeight))
(assert (= (ControlFlow 0 48819) 34999))
(assert (= $_Frame@0 (|lambda#4| null $Heap@@2 alloc false)))
(assert (let ((a!1 (not (=> (= (ControlFlow 0 34999) 35003) true)))      (a!2 (and (= (SequenceSetsMod.__default.ArbitrarySequentialization                     SequenceSetsMod._default.ArbitrarySequentialization$T@@6                     ($LS $LZ)                     |a#0@@15|)                   (Lit (|Seq#Empty| BoxType)))                ($Is (SequenceSetsMod.__default.ArbitrarySequentialization                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                       ($LS $LZ)                       |a#0@@15|)                     (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))                (= |b$reqreads#0@1| true)                (= (ControlFlow 0 35012) 35027)))      (a!3 (=> (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|))               (=> (= (ControlFlow 0 48802) (- 0 49637))                   (|Set#Equal| (SequenceSetsMod.__default.Members                                  SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                  |b#4|)                                |a#0@@15|))))      (a!9 (forall ((|x#3| T@U))             (! (not (and (= (type |x#3|) BoxType)                          ($IsBox |x#3|                                  SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                          (U_2_bool (MapType0Select |a#0@@15| |x#3|))))                :no-pattern (type |x#3|)                :no-pattern (U_2_int |x#3|)                :no-pattern (U_2_bool |x#3|)                :skolemid |905|                :qid |SequenceSetsidfy.21:11|)))      (a!10 (= |##a#1@0|               (|Set#Difference| |a#0@@15|                                 (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))      (a!11 (forall (($o@@15 T@U) ($f@@3 T@U))              (! (let ((a!1 (= (type $f@@3)                               (FieldType (FieldTypeInv0 (type $f@@3))))))                   (=> (and (= (type $o@@15) refType) a!1 false)                       (U_2_bool (MapType4Select $_Frame@0 $o@@15 $f@@3))))                 :no-pattern (U_2_int $f@@3)                 :no-pattern (U_2_int $o@@15)                 :no-pattern (type $o@@15)                 :no-pattern (U_2_bool $o@@15)                 :no-pattern (type $f@@3)                 :no-pattern (U_2_bool $f@@3)                 :skolemid |906|                 :qid |SequenceSetsidfy.22:16|)))      (a!12 (= (type $f@@3!906!6)               (FieldType (FieldTypeInv0 (type $f@@3!906!6)))))      (a!14 (=> (= (ControlFlow 0 35025) (- 0 49178))                (and (|Set#Subset| |##a#1@0| |a#0@@15|)                     (not (|Set#Subset| |a#0@@15| |##a#1@0|)))))      (a!15 (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall|              SequenceSetsMod._default.ArbitrarySequentialization$T@@6              (|Set#Difference| |a#0@@15|                                (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))      (a!16 (SequenceSetsMod.__default.ArbitrarySequentialization              SequenceSetsMod._default.ArbitrarySequentialization$T@@6              ($LS $LZ)              (|Set#Difference| |a#0@@15|                                (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))      (a!18 (= |##a#3@0|               (|Set#Difference| |a#0@@15|                                 (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|))))      (a!19 (=> (= (ControlFlow 0 35025) (- 0 49309))                (and (|Set#Subset| |##a#3@0| |a#0@@15|)                     (not (|Set#Subset| |a#0@@15| |##a#3@0|)))))      (a!20 (SequenceSetsMod.__default.ArbitrarySequentialization              SequenceSetsMod._default.ArbitrarySequentialization$T@@6              ($LS ($LS $LZ))              (|Set#Difference| |a#0@@15|                                (|Set#UnionOne| (|Set#Empty| BoxType) |x#2@0|)))))
(let ((a!4 (and (=> (= (ControlFlow 0 48802) (- 0 49627))                    (= (|Seq#Length| |b#4|) (|Set#Card| |a#0@@15|)))                a!3))      (a!13 (=> (and (= (type $o@@15!906!7) refType) a!12 false)                (U_2_bool (MapType4Select $_Frame@0 $o@@15!906!7 $f@@3!906!6))))      (a!17 (= |let#0#0#0|               (|Seq#Append| a!16 (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|))))      (a!21 (|Set#Equal| (SequenceSetsMod.__default.Members                           SequenceSetsMod._default.ArbitrarySequentialization$T@@6                           |b#Z#0@0|)                         (|Set#Union| (SequenceSetsMod.__default.Members                                        SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                        a!20)                                      (|Set#UnionOne| (|Set#Empty| BoxType)                                                      |x#2@0|))))      (a!22 (|Set#Equal| (SequenceSetsMod.__default.Members                           SequenceSetsMod._default.ArbitrarySequentialization$T@@6                           |b#Z#0@0|)                         (|Set#Union| (SequenceSetsMod.__default.Members                                        SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                        a!16)                                      (|Set#UnionOne| (|Set#Empty| BoxType)                                                      |x#2@0|))))      (a!23 (= (SequenceSetsMod.__default.ArbitrarySequentialization                 SequenceSetsMod._default.ArbitrarySequentialization$T@@6                 ($LS $LZ)                 |a#0@@15|)               (|Seq#Append| a!16 (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|))))      (a!24 (and a!15                 ($Is (SequenceSetsMod.__default.ArbitrarySequentialization                        SequenceSetsMod._default.ArbitrarySequentialization$T@@6                        ($LS $LZ)                        |a#0@@15|)                      (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))                 (= |b$reqreads#0@1| |b$reqreads#0@0|)                 (= (ControlFlow 0 35025) 35027))))
(let ((a!5 (=> |b$reqreads#0@1| (=> (= (ControlFlow 0 35027) 48802) a!4))))
(let ((a!6 (and (=> (= (ControlFlow 0 35027) (- 0 49626)) |b$reqreads#0@1|) a!5)))
(let ((a!7 (=> (= (SequenceSetsMod.__default.ArbitrarySequentialization                    SequenceSetsMod._default.ArbitrarySequentialization$T@@6                    ($LS $LZ)                    |a#0@@15|)                  |b#4|)               a!6)))
(let ((a!8 (=> (= (ControlFlow 0 35010) 35012)               (=> (= (|Set#Card| |a#0@@15|) (LitInt 0)) (=> a!2 a!7))))      (a!25 (=> a!22                (=> (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                           |a#0@@15|)                         a!23)                    (=> a!24 a!7)))))
(let ((a!26 (and (=> (= (ControlFlow 0 35025) (- 0 49442)) a!21) a!25)))
(let ((a!27 (=> (and ($IsAlloc |##a#4@0|                               (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                               $Heap@@2)                     (|SequenceSetsMod.__default.Members#canCall|                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                       a!16)                     (|SequenceSetsMod.__default.Members#canCall|                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                       |b#Z#0@0|)                     a!15                     (|SequenceSetsMod.__default.Members#canCall|                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                       a!16))                a!26)))
(let ((a!28 (=> (and (|Set#Subset| |##a#3@0| |a#0@@15|)                     (not (|Set#Subset| |a#0@@15| |##a#3@0|)))                (=> (and a!15 (= |##a#4@0| a!16)) a!27))))
(let ((a!29 (=> (and a!17                     a!15                     ($Is |let#0#0#0|                          (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))                     (= |b#Z#0@0| |let#0#0#0|)                     ($IsAlloc |b#Z#0@0|                               (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                               $Heap@@2)                     (|SequenceSetsMod.__default.Members#canCall|                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                       |b#Z#0@0|)                     a!18                     ($IsAlloc |##a#3@0|                               (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                               $Heap@@2))                (and a!19 a!28))))
(let ((a!30 (=> (and (|Set#Subset| |##a#1@0| |a#0@@15|)                     (not (|Set#Subset| |a#0@@15| |##a#1@0|)))                (=> a!15 a!29))))
(let ((a!31 (or (and (= (ControlFlow 0 35025) (- 0 49075)) a!9)                (and (= (type |x#3@@0!905!5|) BoxType)                     ($IsBox |x#3@@0!905!5|                             SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                     (U_2_bool (MapType0Select |a#0@@15| |x#3@@0!905!5|))                     (and ($IsBox |x#2@0|                                  SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                          ($IsAllocBox |x#2@0|                                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                       $Heap@@2))                     (U_2_bool (MapType0Select |a#0@@15| |x#2@0|))                     ($Is |b#Z#0@0|                          (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6))                     ($IsAlloc |b#Z#0@0|                               (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                               $Heap@@2)                     a!10                     ($IsAlloc |##a#1@0|                               (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                               $Heap@@2)                     (or (not |b$reqreads#0@0|) a!11)                     (or |b$reqreads#0@0| (not a!13))                     (not (and a!14 a!30))))))
(let ((a!32 (and (= (ControlFlow 0 35019) 35023)                 (not (and ($IsBox |x#2@0|                                   SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                           ($IsAllocBox |x#2@0|                                        SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                        $Heap@@2)))                 (= (ControlFlow 0 35023) 35025)                 a!31)))
(let ((a!33 (or (and (= (ControlFlow 0 35019) 35021)                     (and ($IsBox |x#2@0|                                  SequenceSetsMod._default.ArbitrarySequentialization$T@@6)                          ($IsAllocBox |x#2@0|                                       SequenceSetsMod._default.ArbitrarySequentialization$T@@6                                       $Heap@@2))                     (= (ControlFlow 0 35021) 35025)                     a!31)                a!32)))
(let ((a!34 (and (= (ControlFlow 0 35010) 35019)                 (not (= (|Set#Card| |a#0@@15|) (LitInt 0)))                 a!33)))  (or a!1      (and (= (ControlFlow 0 34999) 35010)           (= $_Frame@0@@0 (|lambda#5| null $Heap@@2 alloc false))           (or (not a!8) a!34)))))))))))))))))))
(check-sat)