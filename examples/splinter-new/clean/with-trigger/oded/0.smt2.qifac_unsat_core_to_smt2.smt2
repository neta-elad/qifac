
(set-option :print-success false)
(set-info :smt-lib-version |2.6|)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; benchmark generated from python API
(set-info :status unknown)
(declare-sort T@U 0)
 (declare-sort T@T 0)
 (declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun regexType () T@T)
(declare-fun type (T@U) T@T)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun string_2_U (String) T@U)
(declare-fun stringType () T@T)
(declare-fun U_2_string (T@U) String)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun rmodeType () T@T)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun boolType () T@T)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun real_2_U (Real) T@U)
(declare-fun realType () T@T)
(declare-fun U_2_real (T@U) Real)
(declare-fun int_2_U (Int) T@U)
(declare-fun intType () T@T)
(declare-fun U_2_int (T@U) Int)
(declare-fun Ctor (T@T) Int)
(declare-fun MapType4Type (T@T T@T) T@T)
(declare-fun refType () T@T)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun BoxType () T@T)
(declare-fun |##a#4@0| () T@U)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun |##a#3@0| () T@U)
(declare-fun |let#0#0#0| () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun |##a#1@0| () T@U)
(declare-fun |b#Z#0@0| () T@U)
(declare-fun MapType1Type () T@T)
(declare-fun $Heap@@2 () T@U)
(declare-fun |x#2@0| () T@U)
(declare-fun TyType () T@T)
(declare-fun SequenceSetsMod._default.ArbitrarySequentialization$T@@6 () T@U)
(declare-fun |a#0@@15| () T@U)
(declare-fun |b#4| () T@U)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun SequenceSetsMod.__default.Members (T@U T@U) T@U)
(declare-fun ControlFlow (Int Int) Int)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |b$reqreads#0@1| () Bool)
(declare-fun SequenceSetsMod.__default.ArbitrarySequentialization (T@U T@U T@U) T@U)
(declare-fun $LS (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun TSeq (T@U) T@U)
(declare-fun |SequenceSetsMod.__default.ArbitrarySequentialization#canCall| (T@U T@U) Bool)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |$let#0$canCall| (T@U T@U) Bool)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |SequenceSetsMod.__default.Members#canCall| (T@U T@U) Bool)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun TSet (T@U) T@U)
(declare-fun MapType4Select (T@U T@U T@U) T@U)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun LitInt (Int) Int)
(declare-fun Lit (T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(declare-fun alloc () T@U)
(declare-fun null () T@U)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun |lambda#2| (T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |$let#0_x| (T@U T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun $OneHeap () T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(assert
 (let (($x168 (forall ((arg0@@10 (RegEx String)) )(! (= (type (regex_2_U arg0@@10)) regexType) :pattern ( (regex_2_U arg0@@10) ) :qid funType:regex_2_U))
 ))
 (let (($x164 (forall ((x@@4 T@U) )(! (let (($x161 (= (regex_2_U (U_2_regex x@@4)) x@@4)))
 (let ((?x63 (type x@@4)))
 (let (($x158 (= ?x63 regexType)))
 (=> $x158 $x161)))) :pattern ( (U_2_regex x@@4) ) :qid cast:U_2_regex))
 ))
 (let (($x156 (forall ((arg0@@9 (RegEx String)) )(! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9) :pattern ( (regex_2_U arg0@@9) ) :qid typeInv:U_2_regex))
 ))
 (let (($x149 (forall ((arg0@@8 String) )(! (= (type (string_2_U arg0@@8)) stringType) :pattern ( (string_2_U arg0@@8) ) :qid funType:string_2_U))
 ))
 (let (($x145 (forall ((x@@3 T@U) )(! (let (($x142 (= (string_2_U (U_2_string x@@3)) x@@3)))
 (let ((?x63 (type x@@3)))
 (let (($x139 (= ?x63 stringType)))
 (=> $x139 $x142)))) :pattern ( (U_2_string x@@3) ) :qid cast:U_2_string))
 ))
 (let (($x137 (forall ((arg0@@7 String) )(! (let ((?x133 (string_2_U arg0@@7)))
 (let ((?x134 (U_2_string ?x133)))
 (= ?x134 arg0@@7))) :pattern ( (string_2_U arg0@@7) ) :qid typeInv:U_2_string))
 ))
 (let (($x130 (forall ((arg0@@6 RoundingMode) )(! (= (type (rmode_2_U arg0@@6)) rmodeType) :pattern ( (rmode_2_U arg0@@6) ) :qid funType:rmode_2_U))
 ))
 (let (($x126 (forall ((x@@2 T@U) )(! (let (($x123 (= (rmode_2_U (U_2_rmode x@@2)) x@@2)))
 (let ((?x63 (type x@@2)))
 (let (($x120 (= ?x63 rmodeType)))
 (=> $x120 $x123)))) :pattern ( (U_2_rmode x@@2) ) :qid cast:U_2_rmode))
 ))
 (let (($x118 (forall ((arg0@@5 RoundingMode) )(! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5) :pattern ( (rmode_2_U arg0@@5) ) :qid typeInv:U_2_rmode))
 ))
 (let (($x111 (forall ((arg0@@4 Bool) )(! (= (type (bool_2_U arg0@@4)) boolType) :pattern ( (bool_2_U arg0@@4) ) :qid funType:bool_2_U))
 ))
 (let (($x107 (forall ((x@@1 T@U) )(! (let (($x104 (= (bool_2_U (U_2_bool x@@1)) x@@1)))
 (let ((?x63 (type x@@1)))
 (let (($x101 (= ?x63 boolType)))
 (=> $x101 $x104)))) :pattern ( (U_2_bool x@@1) ) :qid cast:U_2_bool))
 ))
 (let (($x99 (forall ((arg0@@3 Bool) )(! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3) :pattern ( (bool_2_U arg0@@3) ) :qid typeInv:U_2_bool))
 ))
 (let (($x92 (forall ((arg0@@2 Real) )(! (= (type (real_2_U arg0@@2)) realType) :pattern ( (real_2_U arg0@@2) ) :qid funType:real_2_U))
 ))
 (let (($x88 (forall ((x@@0 T@U) )(! (let (($x85 (= (real_2_U (U_2_real x@@0)) x@@0)))
 (let ((?x63 (type x@@0)))
 (let (($x82 (= ?x63 realType)))
 (=> $x82 $x85)))) :pattern ( (U_2_real x@@0) ) :qid cast:U_2_real))
 ))
 (let (($x80 (forall ((arg0@@1 Real) )(! (= (U_2_real (real_2_U arg0@@1)) arg0@@1) :pattern ( (real_2_U arg0@@1) ) :qid typeInv:U_2_real))
 ))
 (let (($x74 (forall ((arg0@@0 Int) )(! (= (type (int_2_U arg0@@0)) intType) :pattern ( (int_2_U arg0@@0) ) :qid funType:int_2_U))
 ))
 (let (($x70 (forall ((x T@U) )(! (let (($x67 (= (int_2_U (U_2_int x)) x)))
 (let ((?x63 (type x)))
 (let (($x64 (= ?x63 intType)))
 (=> $x64 $x67)))) :pattern ( (U_2_int x) ) :qid cast:U_2_int))
 ))
 (let (($x60 (forall ((arg0 Int) )(! (= (U_2_int (int_2_U arg0)) arg0) :pattern ( (int_2_U arg0) ) :qid typeInv:U_2_int))
 ))
 (let (($x53 (= (Ctor regexType) 5)))
 (let (($x48 (= (Ctor stringType) 4)))
 (let (($x43 (= (Ctor rmodeType) 3)))
 (let (($x38 (= (Ctor boolType) 2)))
 (let (($x39 (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) $x38)))
 (let (($x75 (and (and (and (and (and (and $x39 $x43) $x48) $x53) $x60) $x70) $x74)))
 (let (($x112 (and (and (and (and (and (and $x75 $x80) $x88) $x92) $x99) $x107) $x111)))
 (let (($x150 (and (and (and (and (and (and $x112 $x118) $x126) $x130) $x137) $x145) $x149)))
 (and (and (and $x150 $x156) $x164) $x168))))))))))))))))))))))))))))
(assert
 (let ((?x10157 (MapType4Type refType boolType)))
 (let (($x10273 (= (type $_Frame@0@@0) ?x10157)))
 (let ((?x5070 (SeqType BoxType)))
 (let (($x10269 (= (type |##a#4@0|) ?x5070)))
 (let ((?x5021 (MapType0Type BoxType boolType)))
 (let (($x10265 (= (type |##a#3@0|) ?x5021)))
 (let (($x10261 (= (type |let#0#0#0|) ?x5070)))
 (let (($x10257 (= (type $_Frame@0) ?x10157)))
 (let (($x10253 (= (type |##a#1@0|) ?x5021)))
 (let (($x10249 (= (type |b#Z#0@0|) ?x5070)))
 (let ((?x5185 (MapType0Type refType MapType1Type)))
 (let (($x10245 (= (type $Heap@@2) ?x5185)))
 (let ((?x10240 (type |x#2@0|)))
 (let (($x10241 (= ?x10240 BoxType)))
 (let ((?x10236 (type SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let (($x10237 (= ?x10236 TyType)))
 (let (($x10242 (and (and (and (= (type |b#4|) ?x5070) (= (type |a#0@@15|) ?x5021)) $x10237) $x10241)))
 (let (($x10266 (and (and (and (and (and (and $x10242 $x10245) $x10249) $x10253) $x10257) $x10261) $x10265)))
 (and (and $x10266 $x10269) $x10273))))))))))))))))))))
(assert
 (let ((?x10337 (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#4|)))
 (let (($x10338 (|Set#Equal| ?x10337 |a#0@@15|)))
 (let ((?x10304 (|Set#Card| |a#0@@15|)))
 (let (($x10332 (= (|Seq#Length| |b#4|) ?x10304)))
 (let (($x10341 (and (=> (= (ControlFlow 0 48802) (- 0 49627)) $x10332) (=> (and $x10332 (= (ControlFlow 0 48802) (- 0 49637))) $x10338))))
 (let ((?x10320 (ControlFlow 0 35027)))
 (let (($x10326 (= ?x10320 48802)))
 (let (($x10344 (and (=> (= ?x10320 (- 0 49626)) |b$reqreads#0@1|) (=> (and |b$reqreads#0@1| $x10326) $x10341))))
 (let ((?x10306 ($LS $LZ)))
 (let ((?x10307 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10306 |a#0@@15|)))
 (let (($x10319 (= ?x10307 |b#4|)))
 (let (($x10345 (=> $x10319 $x10344)))
 (let ((?x10362 (ControlFlow 0 35025)))
 (let (($x10453 (= ?x10362 35027)))
 (let (($x10452 (= |b$reqreads#0@1| |b$reqreads#0@0|)))
 (let ((?x10283 (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let (($x10310 ($Is ?x10307 ?x10283)))
 (let ((?x8403 (|Set#Empty| BoxType)))
 (let ((?x10380 (|Set#UnionOne| ?x8403 |x#2@0|)))
 (let ((?x10381 (|Set#Difference| |a#0@@15| ?x10380)))
 (let (($x10402 (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10381)))
 (let ((?x10403 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10306 ?x10381)))
 (let ((?x10405 (|Seq#Append| ?x10403 (|Seq#Build| (|Seq#Empty| BoxType) |x#2@0|))))
 (let (($x10448 (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |a#0@@15|)))
 (let (($x10450 (and $x10448 (= ?x10307 ?x10405))))
 (let ((?x10445 (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10403)))
 (let ((?x10438 (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|)))
 (let (($x10447 (|Set#Equal| ?x10438 (|Set#Union| ?x10445 ?x10380))))
 (let ((?x10440 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ($LS ?x10306) ?x10381)))
 (let ((?x10441 (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10440)))
 (let (($x10443 (|Set#Equal| ?x10438 (|Set#Union| ?x10441 ?x10380))))
 (let (($x10459 (and (=> (= ?x10362 (- 0 49442)) $x10443) (=> (and $x10447 $x10450 (and (and $x10402 $x10310) (and $x10452 $x10453)) $x10319) $x10344))))
 (let (($x10430 (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 ?x10403)))
 (let (($x10412 (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 |b#Z#0@0|)))
 (let (($x10434 (and (and ($IsAlloc |##a#4@0| ?x10283 $Heap@@2) $x10430) (and $x10412 (and $x10402 $x10430)))))
 (let (($x10428 (and $x10402 (= |##a#4@0| ?x10403))))
 (let (($x10425 (and (|Set#Subset| |##a#3@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#3@0|)))))
 (let (($x10463 (and (=> (= ?x10362 (- 0 49309)) $x10425) (=> (and $x10425 $x10428 $x10434) $x10459))))
 (let ((?x10281 (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let (($x10415 ($IsAlloc |##a#3@0| ?x10281 $Heap@@2)))
 (let (($x10414 (= |##a#3@0| ?x10381)))
 (let (($x10411 (and (and (= |let#0#0#0| ?x10405) $x10402) (and ($Is |let#0#0#0| ?x10283) (= |b#Z#0@0| |let#0#0#0|)))))
 (let (($x10418 (and $x10411 (and (and ($IsAlloc |b#Z#0@0| ?x10283 $Heap@@2) $x10412) (and $x10414 $x10415)))))
 (let (($x10400 (and (|Set#Subset| |##a#1@0| |a#0@@15|) (not (|Set#Subset| |a#0@@15| |##a#1@0|)))))
 (let (($x10467 (and (=> (= ?x10362 (- 0 49178)) $x10400) (=> (and $x10400 $x10402 $x10418) $x10463))))
 (let (($x10390 (forall (($o@@15 T@U) ($f@@3 T@U) )(! (let ((?x63 (type $f@@3)))
 (let ((?x5145 (FieldTypeInv0 ?x63)))
 (let ((?x5870 (FieldType ?x5145)))
 (let (($x6005 (= ?x63 ?x5870)))
 (let ((?x176 (type $o@@15)))
 (let (($x5963 (= ?x176 refType)))
 (let (($x6006 (and $x5963 $x6005)))
 (=> (and $x6006 false) (U_2_bool (MapType4Select $_Frame@0 $o@@15 $f@@3)))))))))) :qid SequenceSetsidfy.22:16))
 ))
 (let (($x10384 ($IsAlloc |##a#1@0| ?x10281 $Heap@@2)))
 (let (($x10382 (= |##a#1@0| ?x10381)))
 (let (($x10383 (and (and ($Is |b#Z#0@0| ?x10283) ($IsAlloc |b#Z#0@0| ?x10283 $Heap@@2)) $x10382)))
 (let (($x10375 (U_2_bool (MapType0Select |a#0@@15| |x#2@0|))))
 (let (($x10356 ($IsAllocBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6 $Heap@@2)))
 (let (($x10355 ($IsBox |x#2@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let (($x10357 (and $x10355 $x10356)))
 (let (($x10469 (=> (and (and $x10357 $x10375) (and $x10383 (and $x10384 (= |b$reqreads#0@0| $x10390)))) $x10467)))
 (let (($x10373 (exists ((|x#3@@0| T@U) )(! (let (($x10368 (U_2_bool (MapType0Select |a#0@@15| |x#3@@0|))))
 (let (($x10366 ($IsBox |x#3@@0| SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let ((?x63 (type |x#3@@0|)))
 (let (($x4926 (= ?x63 BoxType)))
 (and $x4926 (and $x10366 $x10368)))))) :qid SequenceSetsidfy.21:11!170))
 ))
 (let (($x10371 (exists ((|x#3| T@U) )(! (let (($x10368 (U_2_bool (MapType0Select |a#0@@15| |x#3|))))
 (let (($x10366 ($IsBox |x#3| SequenceSetsMod._default.ArbitrarySequentialization$T@@6)))
 (let ((?x63 (type |x#3|)))
 (let (($x4926 (= ?x63 BoxType)))
 (and $x4926 (and $x10366 $x10368)))))) :qid SequenceSetsidfy.21:11))
 ))
 (let (($x10471 (and (=> (= ?x10362 (- 0 49075)) $x10371) (=> (and $x10373 (and $x10357 $x10375) (and $x10383 (and $x10384 (= |b$reqreads#0@0| $x10390)))) $x10467))))
 (let (($x10479 (and (not $x10357) (= (ControlFlow 0 35023) 35025))))
 (let ((?x10352 (ControlFlow 0 35019)))
 (let (($x10475 (= ?x10352 35023)))
 (let (($x10354 (= ?x10352 35021)))
 (let (($x10482 (and (=> (and $x10354 (and $x10357 (= (ControlFlow 0 35021) 35025))) $x10471) (=> (and $x10475 $x10479) $x10471))))
 (let ((?x10057 (LitInt 0)))
 (let (($x10305 (= ?x10304 ?x10057)))
 (let (($x10351 (not $x10305)))
 (let ((?x10301 (ControlFlow 0 35010)))
 (let (($x10350 (= ?x10301 35019)))
 (let (($x10318 (and (and (= ?x10307 (Lit (|Seq#Empty| BoxType))) $x10310) (and (= |b$reqreads#0@1| true) (= (ControlFlow 0 35012) 35027)))))
 (let (($x10303 (= ?x10301 35012)))
 (let ((?x10299 (|lambda#5| null $Heap@@2 alloc false)))
 (let (($x10300 (= $_Frame@0@@0 ?x10299)))
 (let (($x10486 (=> $x10300 (and (=> (and $x10303 $x10305 $x10318 $x10319) $x10344) (=> (and $x10350 $x10351) $x10482)))))
 (let ((?x10293 (ControlFlow 0 34999)))
 (let (($x10298 (= ?x10293 35010)))
 (let ((?x10291 (|lambda#4| null $Heap@@2 alloc false)))
 (let (($x10292 (= $_Frame@0 ?x10291)))
 (let (($x10288 (= (ControlFlow 0 48819) 34999)))
 (let (($x10006 (= 1 $FunctionContextHeight)))
 (let (($x10490 (=> (and (and (and ($Is |a#0@@15| ?x10281) ($Is |b#4| ?x10283)) (and $x10006 $x10288)) $x10292) (and (=> (= ?x10293 35003) true) (=> (and $x10298 $x10300) (and (=> (and $x10303 $x10305 $x10318 $x10319) $x10344) (=> (and $x10350 $x10351) $x10482)))))))
 (let (($x10277 (= (ControlFlow 0 0) 48819)))
 (let (($x10492 (=> (and $x10277 (and ($IsGoodHeap $Heap@@2) ($IsHeapAnchor $Heap@@2)) (and (and ($Is |a#0@@15| ?x10281) ($Is |b#4| ?x10283)) (and $x10006 $x10288)) $x10292) (and (=> (= ?x10293 35003) true) (=> (and $x10298 $x10300) (and (=> (and $x10303 $x10305 $x10318 $x10319) $x10344) (=> (and $x10350 $x10351) $x10482)))))))
 (not $x10492)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(assert
 (forall ((|l#0@@1| T@U) (|l#1@@1| T@U) (|$y#0| T@U) )(! (let (($x10199 (= (U_2_bool (MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|) |$y#0|)) (and ($IsBox |$y#0| |l#0@@1|) (|Seq#Contains| |l#1@@1| |$y#0|)))))
 (let ((?x63 (type |$y#0|)))
 (let (($x4926 (= ?x63 BoxType)))
 (let ((?x5070 (SeqType BoxType)))
 (let ((?x176 (type |l#1@@1|)))
 (let (($x5299 (= ?x176 ?x5070)))
 (let ((?x174 (type |l#0@@1|)))
 (let (($x5093 (= ?x174 TyType)))
 (let (($x9868 (and $x5093 $x5299)))
 (=> (and $x9868 $x4926) $x10199)))))))))) :pattern ( (MapType0Select (|lambda#2| |l#0@@1| |l#1@@1|) |$y#0|) ) :qid unknown.0:0!156))
 )
(assert
 (let (($x10077 (forall (($Heap@@0 T@U) (|a#0@@13| T@U) (SequenceSetsMod._default.ArbitrarySequentialization$T@@4 T@U) ($ly@@3 T@U) )(! (let ((?x10063 (|Set#Difference| |a#0@@13| (|Set#UnionOne| (|Set#Empty| BoxType) (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|)))))
 (let ((?x10071 (|Seq#Append| (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 $ly@@3 ?x10063) (|Seq#Build| (|Seq#Empty| BoxType) (|$let#0_x| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|)))))
 (let ((?x10068 (|Seq#Empty| BoxType)))
 (let ((?x10057 (LitInt 0)))
 (let (($x10058 (= (|Set#Card| |a#0@@13|) ?x10057)))
 (let ((?x5834 ($LS $ly@@3)))
 (let ((?x10067 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 ?x5834 |a#0@@13|)))
 (let (($x10073 (= ?x10067 (ite $x10058 ?x10068 ?x10071))))
 (let (($x10065 (and (|$let#0$canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|) (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 ?x10063))))
 (let (($x10006 (= 1 $FunctionContextHeight)))
 (let (($x10007 (not $x10006)))
 (let (($x10050 (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@4 |a#0@@13|)))
 (let ((?x5021 (MapType0Type BoxType boolType)))
 (let ((?x174 (type |a#0@@13|)))
 (let (($x5328 (= ?x174 ?x5021)))
 (let ((?x5185 (MapType0Type refType MapType1Type)))
 (let ((?x5410 (type $Heap@@0)))
 (let (($x5922 (= ?x5410 ?x5185)))
 (let (($x10048 (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@4) TyType) (= (type $ly@@3) LayerTypeType)) $x5922)))
 (let (($x10055 (and (and $x10048 $x5328) (or $x10050 (and $x10007 (and ($IsGoodHeap $Heap@@0) ($Is |a#0@@13| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@4))))))))
 (=> $x10055 (and (=> (not $x10058) $x10065) $x10073)))))))))))))))))))))) :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@4 ($LS $ly@@3) |a#0@@13|) ($IsGoodHeap $Heap@@0) ) :qid unknown.0:0!139))
 ))
 (let (($x10004 (<= 1 $FunctionContextHeight)))
 (=> $x10004 $x10077))))
(assert
 (let (($x10020 (forall ((SequenceSetsMod._default.ArbitrarySequentialization$T@@1 T@U) ($ly@@1 T@U) (|a#0@@11| T@U) )(! (let ((?x9873 (TSeq SequenceSetsMod._default.ArbitrarySequentialization$T@@1)))
 (let ((?x9974 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|)))
 (let (($x10017 ($Is ?x9974 ?x9873)))
 (let (($x10015 (|Set#Equal| (SequenceSetsMod.__default.Members SequenceSetsMod._default.ArbitrarySequentialization$T@@1 ?x9974) |a#0@@11|)))
 (let ((?x6024 (|Set#Card| |a#0@@11|)))
 (let (($x10013 (= (|Seq#Length| ?x9974) ?x6024)))
 (let (($x10005 (|SequenceSetsMod.__default.ArbitrarySequentialization#canCall| SequenceSetsMod._default.ArbitrarySequentialization$T@@1 |a#0@@11|)))
 (let (($x10010 (or $x10005 (and (not (= 1 $FunctionContextHeight)) ($Is |a#0@@11| (TSet SequenceSetsMod._default.ArbitrarySequentialization$T@@1))))))
 (let ((?x5021 (MapType0Type BoxType boolType)))
 (let ((?x63 (type |a#0@@11|)))
 (let (($x5314 (= ?x63 ?x5021)))
 (let (($x9981 (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T@@1) TyType) (= (type $ly@@1) LayerTypeType)) $x5314)))
 (=> (and $x9981 $x10010) (and (and $x10013 $x10015) $x10017)))))))))))))) :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T@@1 $ly@@1 |a#0@@11|) ) :qid unknown.0:0!135))
 ))
 (let (($x10004 (<= 1 $FunctionContextHeight)))
 (=> $x10004 $x10020))))
(assert
 (forall ((arg0@@174 T@U) (arg1@@83 T@U) )(! (= (type (|$let#0_x| arg0@@174 arg1@@83)) BoxType) :pattern ( (|$let#0_x| arg0@@174 arg1@@83) ) :qid funType:$let#0_x))
 )
(assert
 (let (($x9972 (forall ((SequenceSetsMod._default.Members$T@@2 T@U) (|a#0@@8| T@U) )(! (let ((?x9956 (|lambda#2| SequenceSetsMod._default.Members$T@@2 |a#0@@8|)))
 (let ((?x4821 (Lit |a#0@@8|)))
 (let ((?x9968 (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@2 ?x4821)))
 (let (($x9969 (= ?x9968 ?x9956)))
 (let ((?x5360 (TSeq SequenceSetsMod._default.Members$T@@2)))
 (let (($x9894 ($Is |a#0@@8| ?x5360)))
 (let (($x9943 (and (not (= 0 $FunctionContextHeight)) $x9894)))
 (let (($x9965 (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T@@2 ?x4821)))
 (let ((?x5070 (SeqType BoxType)))
 (let ((?x63 (type |a#0@@8|)))
 (let (($x7226 (= ?x63 ?x5070)))
 (let ((?x176 (type SequenceSetsMod._default.Members$T@@2)))
 (let (($x4738 (= ?x176 TyType)))
 (let (($x9891 (and $x4738 $x7226)))
 (=> (and $x9891 (or $x9965 $x9943)) $x9969))))))))))))))) :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@2 (Lit |a#0@@8|)) ) :qid unknown.0:0!131))
 ))
 (let (($x9939 (<= 0 $FunctionContextHeight)))
 (=> $x9939 $x9972))))
(assert
 (forall ((arg0@@172 T@U) (arg1@@82 T@U) (arg2@@32 T@U) )(! (let ((?x5070 (SeqType BoxType)))
 (let ((?x9974 (SequenceSetsMod.__default.ArbitrarySequentialization arg0@@172 arg1@@82 arg2@@32)))
 (= (type ?x9974) ?x5070))) :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization arg0@@172 arg1@@82 arg2@@32) ) :qid funType:SequenceSetsMod.__default.ArbitrarySequentialization))
 )
(assert
 (forall ((SequenceSetsMod._default.ArbitrarySequentialization$T T@U) ($ly T@U) (|a#0@@9| T@U) )(! (let ((?x9974 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T $ly |a#0@@9|)))
 (let ((?x9983 (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T ($LS $ly) |a#0@@9|)))
 (let (($x9984 (= ?x9983 ?x9974)))
 (let ((?x5021 (MapType0Type BoxType boolType)))
 (let ((?x63 (type |a#0@@9|)))
 (let (($x5314 (= ?x63 ?x5021)))
 (let (($x9981 (and (and (= (type SequenceSetsMod._default.ArbitrarySequentialization$T) TyType) (= (type $ly) LayerTypeType)) $x5314)))
 (=> $x9981 $x9984)))))))) :pattern ( (SequenceSetsMod.__default.ArbitrarySequentialization SequenceSetsMod._default.ArbitrarySequentialization$T ($LS $ly) |a#0@@9|) ) :qid unknown.0:0!132))
 )
(assert
 (let ((?x9994 (type $LZ)))
 (let (($x9995 (= ?x9994 LayerTypeType)))
 (let (($x9992 (forall ((arg0@@173 T@U) )(! (= (type (AsFuelBottom arg0@@173)) LayerTypeType) :pattern ( (AsFuelBottom arg0@@173) ) :qid funType:AsFuelBottom))
 ))
 (and $x9992 $x9995)))))
(assert
 (forall ((arg0@@170 T@U) (arg1@@80 T@U) )(! (let ((?x5021 (MapType0Type BoxType boolType)))
 (= (type (SequenceSetsMod.__default.Members arg0@@170 arg1@@80)) ?x5021)) :pattern ( (SequenceSetsMod.__default.Members arg0@@170 arg1@@80) ) :qid funType:SequenceSetsMod.__default.Members))
 )
(assert
 (let (($x9948 (forall ((SequenceSetsMod._default.Members$T T@U) (|a#0@@5| T@U) )(! (let ((?x5457 (TSet SequenceSetsMod._default.Members$T)))
 (let ((?x9934 (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T |a#0@@5|)))
 (let (($x9946 ($Is ?x9934 ?x5457)))
 (let ((?x5360 (TSeq SequenceSetsMod._default.Members$T)))
 (let (($x9894 ($Is |a#0@@5| ?x5360)))
 (let (($x9943 (and (not (= 0 $FunctionContextHeight)) $x9894)))
 (let (($x9940 (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T |a#0@@5|)))
 (let ((?x5070 (SeqType BoxType)))
 (let ((?x63 (type |a#0@@5|)))
 (let (($x7226 (= ?x63 ?x5070)))
 (let ((?x176 (type SequenceSetsMod._default.Members$T)))
 (let (($x4738 (= ?x176 TyType)))
 (let (($x9891 (and $x4738 $x7226)))
 (let (($x9945 (and $x9891 (or $x9940 $x9943))))
 (=> $x9945 $x9946))))))))))))))) :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T |a#0@@5|) ) :qid unknown.0:0!127))
 ))
 (let (($x9939 (<= 0 $FunctionContextHeight)))
 (=> $x9939 $x9948))))
(assert
 (let (($x9963 (forall ((SequenceSetsMod._default.Members$T@@1 T@U) (|a#0@@7| T@U) )(! (let ((?x9956 (|lambda#2| SequenceSetsMod._default.Members$T@@1 |a#0@@7|)))
 (let ((?x9934 (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@1 |a#0@@7|)))
 (let (($x9961 (= ?x9934 ?x9956)))
 (let ((?x5360 (TSeq SequenceSetsMod._default.Members$T@@1)))
 (let (($x9894 ($Is |a#0@@7| ?x5360)))
 (let (($x9943 (and (not (= 0 $FunctionContextHeight)) $x9894)))
 (let (($x9940 (|SequenceSetsMod.__default.Members#canCall| SequenceSetsMod._default.Members$T@@1 |a#0@@7|)))
 (let ((?x5070 (SeqType BoxType)))
 (let ((?x63 (type |a#0@@7|)))
 (let (($x7226 (= ?x63 ?x5070)))
 (let ((?x176 (type SequenceSetsMod._default.Members$T@@1)))
 (let (($x4738 (= ?x176 TyType)))
 (let (($x9891 (and $x4738 $x7226)))
 (let (($x9945 (and $x9891 (or $x9940 $x9943))))
 (=> $x9945 $x9961))))))))))))))) :pattern ( (SequenceSetsMod.__default.Members SequenceSetsMod._default.Members$T@@1 |a#0@@7|) ) :qid unknown.0:0!130))
 ))
 (let (($x9939 (<= 0 $FunctionContextHeight)))
 (=> $x9939 $x9963))))
(assert
 (forall ((x@@38 T@U) (s0@@1 T@U) (s1@@1 T@U) )(! (let ((?x6744 (|Seq#Append| s0@@1 s1@@1)))
 (let (($x6978 (|Seq#Contains| ?x6744 x@@38)))
 (let (($x6982 (= $x6978 (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))))
 (let ((?x174 (type x@@38)))
 (let ((?x6844 (SeqType ?x174)))
 (let ((?x176 (type s0@@1)))
 (let (($x6845 (= ?x176 ?x6844)))
 (let (($x6977 (and $x6845 (= (type s1@@1) ?x6844))))
 (=> $x6977 $x6982))))))))) :pattern ( (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38) ) :qid DafnyPreludebpl.999:18))
 )
(assert
 (forall ((s@@24 T@U) (v@@35 T@U) (x@@39 T@U) )(! (let ((?x6864 (|Seq#Build| s@@24 v@@35)))
 (let (($x6988 (|Seq#Contains| ?x6864 x@@39)))
 (let (($x6991 (= $x6988 (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))))
 (let ((?x176 (type v@@35)))
 (let ((?x63 (type x@@39)))
 (let (($x6080 (= ?x63 ?x176)))
 (let ((?x6761 (SeqType ?x176)))
 (let ((?x174 (type s@@24)))
 (let (($x6986 (= ?x174 ?x6761)))
 (let (($x6987 (and $x6986 $x6080)))
 (=> $x6987 $x6991))))))))))) :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39) ) :qid DafnyPreludebpl.1004:18))
 )
(assert
 (forall ((x@@37 T@U) )(! (let (($x6972 (|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37)))
 (not $x6972)) :pattern ( (|Seq#Contains| (|Seq#Empty| (type x@@37)) x@@37) ) :qid DafnyPreludebpl.995:18))
 )
(assert
 (forall ((s0 T@U) (s1 T@U) )(! (let ((?x6744 (|Seq#Append| s0 s1)))
 (let ((?x6913 (|Seq#Length| ?x6744)))
 (let ((?x176 (type s0)))
 (let ((?x5295 (SeqTypeInv0 ?x176)))
 (let ((?x6746 (SeqType ?x5295)))
 (let (($x6750 (= ?x176 ?x6746)))
 (let (($x6752 (and $x6750 (= (type s1) ?x6746))))
 (=> $x6752 (= ?x6913 (+ (|Seq#Length| s0) (|Seq#Length| s1))))))))))) :pattern ( (|Seq#Length| (|Seq#Append| s0 s1)) ) :qid DafnyPreludebpl.974:18))
 )
(assert
 (forall ((s@@18 T@U) (v@@31 T@U) )(! (let ((?x63 (type v@@31)))
 (let ((?x6724 (SeqType ?x63)))
 (let ((?x176 (type s@@18)))
 (let (($x6728 (= ?x176 ?x6724)))
 (=> $x6728 (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18)))))))) :pattern ( (|Seq#Build| s@@18 v@@31) ) :qid DafnyPreludebpl.952:18))
 )
(assert
 (forall ((T@@107 T@T) )(! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0) :pattern ( (|Seq#Empty| T@@107) ) :qid k!213))
 )
(assert
 (forall ((T@@99 T@T) )(! (let ((?x5058 (SeqType T@@99)))
 (= (type (|Seq#Empty| T@@99)) ?x5058)) :pattern ( (|Seq#Empty| T@@99) ) :qid funType:Seq#Empty))
 )
(assert
 (forall ((arg0@@91 T@U) (arg1@@36 T@U) )(! (let ((?x63 (type arg1@@36)))
 (let ((?x6724 (SeqType ?x63)))
 (= (type (|Seq#Build| arg0@@91 arg1@@36)) ?x6724))) :pattern ( (|Seq#Build| arg0@@91 arg1@@36) ) :qid funType:Seq#Build))
 )
(assert
 (forall ((arg0@@77 T@U) (arg1@@25 T@U) )(! (let ((?x176 (type arg0@@77)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (= (type (|Set#Union| arg0@@77 arg1@@25)) ?x6123)))) :pattern ( (|Set#Union| arg0@@77 arg1@@25) ) :qid funType:Set#Union))
 )
(assert
 (forall ((a@@7 T@U) (x@@23 T@U) )(! (let ((?x4981 (MapType0Select a@@7 x@@23)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let (($x6115 (not $x5319)))
 (let ((?x63 (type x@@23)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type a@@7)))
 (let (($x6090 (= ?x176 ?x6056)))
 (let (($x6116 (and $x6090 $x6115)))
 (=> $x6116 (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))))))))))) :pattern ( (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) ) :qid DafnyPreludebpl.649:18))
 )
(assert
 (forall ((a@@8 T@U) (b@@3 T@U) (o@@20 T@U) )(! (let ((?x4981 (MapType0Select b@@3 o@@20)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x5006 (MapType0Select a@@8 o@@20)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let (($x6132 (or $x5255 $x5319)))
 (let ((?x6129 (|Set#Union| a@@8 b@@3)))
 (let ((?x6130 (MapType0Select ?x6129 o@@20)))
 (let (($x6131 (U_2_bool ?x6130)))
 (let (($x6133 (= $x6131 $x6132)))
 (let ((?x63 (type o@@20)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type b@@3)))
 (let (($x6090 (= ?x176 ?x6056)))
 (let ((?x174 (type a@@8)))
 (let (($x6127 (= ?x174 ?x6056)))
 (let (($x6128 (and $x6127 $x6090)))
 (=> $x6128 $x6133))))))))))))))))) :pattern ( (MapType0Select (|Set#Union| a@@8 b@@3) o@@20) ) :qid DafnyPreludebpl.653:18))
 )
(assert
 (forall ((a@@13 T@U) (b@@8 T@U) )(! (let ((?x6121 (|Set#Union| a@@13 b@@8)))
 (let ((?x6180 (|Set#Union| ?x6121 b@@8)))
 (let (($x6181 (= ?x6180 ?x6121)))
 (let ((?x176 (type a@@13)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@8)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 $x6181))))))))))) :pattern ( (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8) ) :qid DafnyPreludebpl.672:18))
 )
(assert
 (forall ((a@@14 T@U) (b@@9 T@U) )(! (let ((?x6121 (|Set#Union| a@@14 b@@9)))
 (let ((?x6185 (|Set#Union| a@@14 ?x6121)))
 (let (($x6186 (= ?x6185 ?x6121)))
 (let ((?x176 (type a@@14)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@9)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 $x6186))))))))))) :pattern ( (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)) ) :qid DafnyPreludebpl.674:18))
 )
(assert
 (forall ((a@@23 T@U) (b@@18 T@U) )(! (let (($x5003 (= a@@23 b@@18)))
 (let (($x6251 (|Set#Equal| a@@23 b@@18)))
 (let ((?x176 (type a@@23)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@18)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> (and $x6157 $x6251) $x5003)))))))))) :pattern ( (|Set#Equal| a@@23 b@@18) ) :qid DafnyPreludebpl.706:17))
 )
(assert
 (forall ((a@@24 T@U) (b@@19 T@U) )(! (let (($x6265 (forall ((o@@25 T@U) )(! (let ((?x4981 (MapType0Select b@@19 o@@25)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let (($x6115 (not $x5319)))
 (let ((?x5006 (MapType0Select a@@24 o@@25)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let (($x6262 (not $x5255)))
 (let ((?x174 (type a@@24)))
 (let ((?x6242 (MapType0TypeInv0 ?x174)))
 (let ((?x63 (type o@@25)))
 (let (($x6243 (= ?x63 ?x6242)))
 (=> $x6243 (or $x6262 $x6115)))))))))))) :pattern ( (MapType0Select b@@19 o@@25) ) :pattern ( (MapType0Select a@@24 o@@25) ) :qid DafnyPreludebpl.711:34))
 ))
 (let (($x6158 (|Set#Disjoint| a@@24 b@@19)))
 (let ((?x176 (type a@@24)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@19)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 (= $x6158 $x6265))))))))))) :pattern ( (|Set#Disjoint| a@@24 b@@19) ) :qid DafnyPreludebpl.710:18))
 )
(assert
 (forall ((b@@14 T@U) (y@@4 T@U) (a@@19 T@U) )(! (let (($x6225 (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14) y@@4)))))
 (let ((?x5968 (MapType0Select b@@14 y@@4)))
 (let (($x6220 (U_2_bool ?x5968)))
 (let ((?x176 (type y@@4)))
 (let ((?x6078 (MapType0Type ?x176 boolType)))
 (let ((?x174 (type b@@14)))
 (let (($x6079 (= ?x174 ?x6078)))
 (let ((?x63 (type a@@19)))
 (let (($x6137 (= ?x63 ?x6078)))
 (let (($x6138 (and $x6137 $x6079)))
 (let (($x6221 (and $x6138 $x6220)))
 (=> $x6221 $x6225)))))))))))) :pattern ( (|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4) ) :qid DafnyPreludebpl.686:18))
 )
(assert
 (forall ((a@@20 T@U) (b@@15 T@U) )(! (let ((?x6150 (|Set#Difference| a@@20 b@@15)))
 (let ((?x6229 (|Set#Card| ?x6150)))
 (let ((?x6121 (|Set#Union| a@@20 b@@15)))
 (let ((?x6203 (|Set#Card| ?x6121)))
 (let ((?x6190 (|Set#Intersection| a@@20 b@@15)))
 (let ((?x6204 (|Set#Card| ?x6190)))
 (let (($x6237 (and (= (+ (+ ?x6229 (|Set#Card| (|Set#Difference| b@@15 a@@20))) ?x6204) ?x6203) (= ?x6229 (- (|Set#Card| a@@20) ?x6204)))))
 (let ((?x176 (type a@@20)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@15)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 $x6237))))))))))))))) :pattern ( (|Set#Card| (|Set#Difference| a@@20 b@@15)) ) :qid DafnyPreludebpl.688:18))
 )
(assert
 (forall ((a@@21 T@U) (b@@16 T@U) )(! (let (($x6246 (forall ((o@@23 T@U) )(! (let ((?x4981 (MapType0Select b@@16 o@@23)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x5006 (MapType0Select a@@21 o@@23)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let ((?x174 (type a@@21)))
 (let ((?x6242 (MapType0TypeInv0 ?x174)))
 (let ((?x63 (type o@@23)))
 (let (($x6243 (= ?x63 ?x6242)))
 (let (($x6244 (and $x6243 $x5255)))
 (=> $x6244 $x5319)))))))))) :pattern ( (MapType0Select a@@21 o@@23) ) :pattern ( (MapType0Select b@@16 o@@23) ) :qid DafnyPreludebpl.697:32))
 ))
 (let (($x6241 (|Set#Subset| a@@21 b@@16)))
 (let ((?x176 (type a@@21)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@16)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 (= $x6241 $x6246))))))))))) :pattern ( (|Set#Subset| a@@21 b@@16) ) :qid DafnyPreludebpl.696:17))
 )
(assert
 (forall ((a@@22 T@U) (b@@17 T@U) )(! (let (($x6254 (forall ((o@@24 T@U) )(! (let ((?x4981 (MapType0Select b@@17 o@@24)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x5006 (MapType0Select a@@22 o@@24)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let (($x6252 (= $x5255 $x5319)))
 (let ((?x174 (type a@@22)))
 (let ((?x6242 (MapType0TypeInv0 ?x174)))
 (let ((?x63 (type o@@24)))
 (let (($x6243 (= ?x63 ?x6242)))
 (=> $x6243 $x6252)))))))))) :pattern ( (MapType0Select a@@22 o@@24) ) :pattern ( (MapType0Select b@@17 o@@24) ) :qid DafnyPreludebpl.705:31))
 ))
 (let (($x6251 (|Set#Equal| a@@22 b@@17)))
 (let ((?x176 (type a@@22)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@17)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 (= $x6251 $x6254))))))))))) :pattern ( (|Set#Equal| a@@22 b@@17) ) :qid DafnyPreludebpl.704:17))
 )
(assert
 (forall ((a@@17 T@U) (b@@12 T@U) )(! (let ((?x6190 (|Set#Intersection| a@@17 b@@12)))
 (let ((?x6204 (|Set#Card| ?x6190)))
 (let ((?x6121 (|Set#Union| a@@17 b@@12)))
 (let ((?x6203 (|Set#Card| ?x6121)))
 (let ((?x176 (type a@@17)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@12)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> $x6157 (= (+ ?x6203 ?x6204) (+ (|Set#Card| a@@17) (|Set#Card| b@@12))))))))))))))) :pattern ( (|Set#Card| (|Set#Union| a@@17 b@@12)) ) :pattern ( (|Set#Card| (|Set#Intersection| a@@17 b@@12)) ) :qid DafnyPreludebpl.680:18))
 )
(assert
 (forall ((a@@18 T@U) (b@@13 T@U) (o@@22 T@U) )(! (let ((?x4981 (MapType0Select b@@13 o@@22)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let (($x6115 (not $x5319)))
 (let ((?x5006 (MapType0Select a@@18 o@@22)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let (($x6215 (and $x5255 $x6115)))
 (let (($x6216 (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22)) $x6215)))
 (let ((?x63 (type o@@22)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type b@@13)))
 (let (($x6090 (= ?x176 ?x6056)))
 (let ((?x174 (type a@@18)))
 (let (($x6127 (= ?x174 ?x6056)))
 (let (($x6128 (and $x6127 $x6090)))
 (=> $x6128 $x6216))))))))))))))) :pattern ( (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22) ) :qid DafnyPreludebpl.684:18))
 )
(assert
 (forall ((a@@10 T@U) (b@@5 T@U) (y@@3 T@U) )(! (let ((?x6129 (|Set#Union| a@@10 b@@5)))
 (let ((?x6130 (MapType0Select ?x6129 y@@3)))
 (let (($x6131 (U_2_bool ?x6130)))
 (let ((?x4981 (MapType0Select b@@5 y@@3)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x63 (type y@@3)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type b@@5)))
 (let (($x6090 (= ?x176 ?x6056)))
 (let ((?x174 (type a@@10)))
 (let (($x6127 (= ?x174 ?x6056)))
 (let (($x6128 (and $x6127 $x6090)))
 (let (($x6146 (and $x6128 $x5319)))
 (=> $x6146 $x6131)))))))))))))) :pattern ( (|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3) ) :qid DafnyPreludebpl.657:18))
 )
(assert
 (forall ((arg0@@78 T@U) (arg1@@26 T@U) )(! (let ((?x176 (type arg0@@78)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (= (type (|Set#Difference| arg0@@78 arg1@@26)) ?x6123)))) :pattern ( (|Set#Difference| arg0@@78 arg1@@26) ) :qid funType:Set#Difference))
 )
(assert
 (forall ((a@@11 T@U) (b@@6 T@U) )(! (let (($x6164 (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6) (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))))
 (let (($x6158 (|Set#Disjoint| a@@11 b@@6)))
 (let ((?x176 (type a@@11)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x6123 (MapType0Type ?x6046 boolType)))
 (let ((?x63 (type b@@6)))
 (let (($x6156 (= ?x63 ?x6123)))
 (let (($x6155 (= ?x176 ?x6123)))
 (let (($x6157 (and $x6155 $x6156)))
 (=> (and $x6157 $x6158) $x6164)))))))))) :pattern ( (|Set#Union| a@@11 b@@6) ) :qid DafnyPreludebpl.659:18))
 )
(assert
 (forall ((arg1@@27 T@U) (arg0@@79 T@U) )(! (let ((?x63 (type arg0@@79)))
 (let ((?x6021 (MapType0TypeInv0 ?x63)))
 (let ((?x6022 (MapType0Type ?x6021 boolType)))
 (= (type (|Set#Intersection| arg0@@79 arg1@@27)) ?x6022)))) :pattern ( (|Set#Intersection| arg0@@79 arg1@@27) ) :qid funType:Set#Intersection))
 )
(assert
 (forall ((a@@12 T@U) (b@@7 T@U) (o@@21 T@U) )(! (let ((?x4981 (MapType0Select b@@7 o@@21)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x5006 (MapType0Select a@@12 o@@21)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let (($x6176 (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21)) (and $x5255 $x5319))))
 (let ((?x63 (type o@@21)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type b@@7)))
 (let (($x6090 (= ?x176 ?x6056)))
 (let ((?x174 (type a@@12)))
 (let (($x6127 (= ?x174 ?x6056)))
 (let (($x6128 (and $x6127 $x6090)))
 (=> $x6128 $x6176))))))))))))) :pattern ( (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21) ) :qid DafnyPreludebpl.669:18))
 )
(assert
 (forall ((a@@4 T@U) (x@@20 T@U) )(! (let (($x6092 (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20))))
 (let ((?x63 (type x@@20)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (let ((?x176 (type a@@4)))
 (let (($x6090 (= ?x176 ?x6056)))
 (=> $x6090 $x6092)))))) :pattern ( (|Set#UnionOne| a@@4 x@@20) ) :qid DafnyPreludebpl.643:18))
 )
(assert
 (forall ((arg0@@76 T@U) (arg1@@24 T@U) )(! (let ((?x63 (type arg1@@24)))
 (let ((?x6056 (MapType0Type ?x63 boolType)))
 (= (type (|Set#UnionOne| arg0@@76 arg1@@24)) ?x6056))) :pattern ( (|Set#UnionOne| arg0@@76 arg1@@24) ) :qid funType:Set#UnionOne))
 )
(assert
 (forall ((a@@3 T@U) (x@@19 T@U) (o@@19 T@U) )(! (let (($x6086 (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19)) (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))))
 (let ((?x176 (type x@@19)))
 (let ((?x63 (type o@@19)))
 (let (($x6080 (= ?x63 ?x176)))
 (let ((?x6078 (MapType0Type ?x176 boolType)))
 (let ((?x174 (type a@@3)))
 (let (($x6079 (= ?x174 ?x6078)))
 (let (($x6081 (and $x6079 $x6080)))
 (=> $x6081 $x6086))))))))) :pattern ( (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19) ) :qid DafnyPreludebpl.641:18))
 )
(assert
 (forall ((s@@3 T@U) )(! (let ((?x63 (type s@@3)))
 (let ((?x6021 (MapType0TypeInv0 ?x63)))
 (let ((?x6022 (MapType0Type ?x6021 boolType)))
 (let (($x6023 (= ?x63 ?x6022)))
 (=> $x6023 (<= 0 (|Set#Card| s@@3))))))) :pattern ( (|Set#Card| s@@3) ) :qid DafnyPreludebpl.624:18))
 )
(assert
 (forall ((o@@17 T@U) )(! (not (U_2_bool (MapType0Select (|Set#Empty| (type o@@17)) o@@17))) :pattern ( (MapType0Select (|Set#Empty| (type o@@17)) o@@17) ) :qid DafnyPreludebpl.627:18))
 )
(assert
 (forall ((T@@6 T@T) )(! (let ((?x6031 (MapType0Type T@@6 boolType)))
 (= (type (|Set#Empty| T@@6)) ?x6031)) :pattern ( (|Set#Empty| T@@6) ) :qid funType:Set#Empty))
 )
(assert
 (forall ((s@@4 T@U) )(! (let (($x6049 (exists ((x@@18 T@U) )(! (let ((?x4981 (MapType0Select s@@4 x@@18)))
 (let (($x5319 (U_2_bool ?x4981)))
 (let ((?x176 (type s@@4)))
 (let ((?x6046 (MapType0TypeInv0 ?x176)))
 (let ((?x63 (type x@@18)))
 (let (($x6047 (= ?x63 ?x6046)))
 (and $x6047 $x5319))))))) :qid DafnyPreludebpl.630:33))
 ))
 (let ((?x6024 (|Set#Card| s@@4)))
 (let (($x6041 (= ?x6024 0)))
 (let (($x6044 (= $x6041 (= s@@4 (|Set#Empty| (MapType0TypeInv0 (type s@@4)))))))
 (let ((?x63 (type s@@4)))
 (let ((?x6021 (MapType0TypeInv0 ?x63)))
 (let ((?x6022 (MapType0Type ?x6021 boolType)))
 (let (($x6023 (= ?x63 ?x6022)))
 (=> $x6023 (and $x6044 (=> (not $x6041) $x6049))))))))))) :pattern ( (|Set#Card| s@@4) ) :qid DafnyPreludebpl.628:18))
 )
(assert
 (let ((?x5185 (MapType0Type refType MapType1Type)))
 (= (type $OneHeap) ?x5185)))
(assert
 (forall ((arg0@@68 T@U) )(! (= (type ($LS arg0@@68)) LayerTypeType) :pattern ( ($LS arg0@@68) ) :qid funType:$LS))
 )
(assert
 (forall ((x@@8 T@U) )(! (let ((?x4821 (Lit x@@8)))
 (= ?x4821 x@@8)) :pattern ( (Lit x@@8) ) :qid DafnyPreludebpl.89:29))
 )
(assert
 (forall ((x@@10 Int) )(! (let ((?x4843 (LitInt x@@10)))
 (= ?x4843 x@@10)) :pattern ( (LitInt x@@10) ) :qid DafnyPreludebpl.95:29))
 )
(assert
 (forall ((v@@13 T@U) (t0 T@U) )(! (let (($x5260 (forall ((bx@@10 T@U) )(! (let (($x5257 ($IsBox bx@@10 t0)))
 (let ((?x5006 (MapType0Select v@@13 bx@@10)))
 (let (($x5255 (U_2_bool ?x5006)))
 (let ((?x63 (type bx@@10)))
 (let (($x4926 (= ?x63 BoxType)))
 (let (($x5256 (and $x4926 $x5255)))
 (=> $x5256 $x5257))))))) :pattern ( (MapType0Select v@@13 bx@@10) ) :qid DafnyPreludebpl.221:11))
 ))
 (let ((?x4666 (TSet t0)))
 (let (($x5254 ($Is v@@13 ?x4666)))
 (let ((?x63 (type t0)))
 (let (($x4677 (= ?x63 TyType)))
 (let (($x5253 (and (= (type v@@13) (MapType0Type BoxType boolType)) $x4677)))
 (=> $x5253 (= $x5254 $x5260)))))))) :pattern ( ($Is v@@13 (TSet t0)) ) :qid DafnyPreludebpl.219:15))
 )
(assert
 (let (($x5015 (forall ((y0@@0 T@U) (val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) )(! (let ((?x5012 (MapType0Select m@@1 y0@@0)))
 (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) ?x5012))) :qid mapAx2:MapType0Select))
 ))
 (let (($x5009 (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) )(! (let ((?x5006 (MapType0Select m@@0 y0)))
 (let (($x5003 (= x0@@0 y0)))
 (or $x5003 (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) ?x5006)))) :qid mapAx1:MapType0Select:0))
 ))
 (let (($x5000 (forall ((m T@U) (x0 T@U) (val T@U) )(! (let (($x4998 (= (MapType0Select (MapType0Store m x0 val) x0) val)))
 (let ((?x63 (type val)))
 (let (($x4996 (= ?x63 (MapType0TypeInv1 (type m)))))
 (=> $x4996 $x4998)))) :qid mapAx0:MapType0Select))
 ))
 (let (($x4993 (forall ((arg0@@39 T@U) (arg1@@7 T@U) (arg2 T@U) )(! (= (type (MapType0Store arg0@@39 arg1@@7 arg2)) (MapType0Type (type arg1@@7) (type arg2))) :pattern ( (MapType0Store arg0@@39 arg1@@7 arg2) ) :qid funType:MapType0Store))
 ))
 (let (($x4986 (forall ((arg0@@38 T@U) (arg1@@6 T@U) )(! (let ((?x176 (type arg0@@38)))
 (let ((?x4983 (MapType0TypeInv1 ?x176)))
 (= (type (MapType0Select arg0@@38 arg1@@6)) ?x4983))) :pattern ( (MapType0Select arg0@@38 arg1@@6) ) :qid funType:MapType0Select))
 ))
 (let (($x4979 (forall ((arg0@@37 T@T) (arg1@@5 T@T) )(! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5) :pattern ( (MapType0Type arg0@@37 arg1@@5) ) :qid typeInv:MapType0TypeInv1))
 ))
 (let (($x4975 (forall ((arg0@@36 T@T) (arg1@@4 T@T) )(! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36) :pattern ( (MapType0Type arg0@@36 arg1@@4) ) :qid typeInv:MapType0TypeInv0))
 ))
 (let (($x4971 (forall ((arg0@@35 T@T) (arg1@@3 T@T) )(! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15) :qid ctor:MapType0Type))
 ))
 (and (and (and (and (and (and $x4971 $x4975) $x4979) $x4986) $x4993) $x5000) (and $x5009 $x5015)))))))))))
(assert
 (let (($x5066 (forall ((arg0@@41 T@T) )(! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41) :pattern ( (SeqType arg0@@41) ) :qid typeInv:SeqTypeInv0))
 ))
 (let (($x5062 (forall ((arg0@@40 T@T) )(! (= (Ctor (SeqType arg0@@40)) 16) :qid ctor:SeqType))
 ))
 (and $x5062 $x5066))))
(check-sat)
