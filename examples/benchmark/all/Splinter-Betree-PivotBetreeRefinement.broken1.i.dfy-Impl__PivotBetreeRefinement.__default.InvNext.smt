(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun U_2_int (T@U) Int)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TORDINAL () T@U)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun alloc () T@U)
(declare-fun allocName () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun class._System.object? () T@U)
(declare-fun Tagclass._System.object? () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array? () T@U)
(declare-fun Tagclass._System.array? () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun Tagclass._System.___hPartialFunc1 () T@U)
(declare-fun Tagclass._System.___hTotalFunc1 () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hPartialFunc0 () T@U)
(declare-fun Tagclass._System.___hTotalFunc0 () T@U)
(declare-fun class._System.__default () T@U)
(declare-fun Tagclass._System.__default () T@U)
(declare-fun Tagclass._System.___hFunc2 () T@U)
(declare-fun Tagclass._System.___hPartialFunc2 () T@U)
(declare-fun Tagclass._System.___hTotalFunc2 () T@U)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2 () T@U)
(declare-fun class._System.Tuple2 () T@U)
(declare-fun Tagclass._System.___hFunc4 () T@U)
(declare-fun Tagclass._System.___hPartialFunc4 () T@U)
(declare-fun Tagclass._System.___hTotalFunc4 () T@U)
(declare-fun Tagclass._System.___hFunc3 () T@U)
(declare-fun Tagclass._System.___hPartialFunc3 () T@U)
(declare-fun Tagclass._System.___hTotalFunc3 () T@U)
(declare-fun Tagclass._System.___hFunc2OSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2OSO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2OSO () T@U)
(declare-fun Tagclass._System.___hFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hFunc1OS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OS () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OS () T@U)
(declare-fun Tagclass._System.___hFunc0L () T@U)
(declare-fun Tagclass._System.___hPartialFunc0L () T@U)
(declare-fun Tagclass._System.___hTotalFunc0L () T@U)
(declare-fun Tagclass._System.___hFunc2LOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LOO () T@U)
(declare-fun |##_System._tuple#0._#Make0| () T@U)
(declare-fun Tagclass._System.Tuple0 () T@U)
(declare-fun class._System.Tuple0 () T@U)
(declare-fun Tagclass._System.___hFunc1OL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OL () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OL () T@U)
(declare-fun Tagclass._System.___hFunc1LO () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LO () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LO () T@U)
(declare-fun |##_System._tuple#2OLL._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2OLL () T@U)
(declare-fun class._System.Tuple2OLL () T@U)
(declare-fun Tagclass._System.___hFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hFunc2SSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2SSO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2SSO () T@U)
(declare-fun Tagclass._System.___hFunc2LLO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LLO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LLO () T@U)
(declare-fun Tagclass._System.___hFunc1SS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1SS () T@U)
(declare-fun Tagclass._System.___hTotalFunc1SS () T@U)
(declare-fun Tagclass._System.___hFunc1LL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LL () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LL () T@U)
(declare-fun class.PivotBetreeRefinement.__default () T@U)
(declare-fun Tagclass.PivotBetreeRefinement.__default () T@U)
(declare-fun Tagclass.PivotBetree.BetreeNode () T@U)
(declare-fun Tagclass.PagedBetree.ChildMap () T@U)
(declare-fun Tagclass.KeyType.Key () T@U)
(declare-fun Tagclass.PagedBetree.BetreeNode () T@U)
(declare-fun Tagclass.StampedMod.Stamped () T@U)
(declare-fun Tagclass.PivotBetree.TransitionLabel () T@U)
(declare-fun Tagclass.PagedBetree.TransitionLabel () T@U)
(declare-fun Tagclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun Tagclass.ValueType.Value () T@U)
(declare-fun Tagclass.NativeTypes.byte () T@U)
(declare-fun Tagclass.PivotBetree.Variables () T@U)
(declare-fun Tagclass.PagedBetree.Variables () T@U)
(declare-fun Tagclass.PivotBetree.Step () T@U)
(declare-fun Tagclass.PivotBetree.Path () T@U)
(declare-fun Tagclass.SplitRequestMod.SplitRequest () T@U)
(declare-fun Tagclass.Buffers.BufferStack () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun Tagclass.PagedBetree.Path () T@U)
(declare-fun Tagclass.PivotBetree.QueryReceiptLine () T@U)
(declare-fun Tagclass.PagedBetree.QueryReceiptLine () T@U)
(declare-fun Tagclass.PivotBetree.QueryReceipt () T@U)
(declare-fun Tagclass.PagedBetree.QueryReceipt () T@U)
(declare-fun Tagclass.DomainMod.Domain () T@U)
(declare-fun Tagclass.PagedBetree.Step () T@U)
(declare-fun Tagclass.MemtableMod.Memtable () T@U)
(declare-fun |##Options.Option.None| () T@U)
(declare-fun Tagclass.Options.Option () T@U)
(declare-fun |##Options.Option.Some| () T@U)
(declare-fun class.Options.Option () T@U)
(declare-fun class.Options.__default () T@U)
(declare-fun Tagclass.Options.__default () T@U)
(declare-fun Tagclass.NativeTypes.sbyte () T@U)
(declare-fun class.NativeTypes.sbyte () T@U)
(declare-fun class.NativeTypes.byte () T@U)
(declare-fun Tagclass.NativeTypes.int16 () T@U)
(declare-fun class.NativeTypes.int16 () T@U)
(declare-fun Tagclass.NativeTypes.uint16 () T@U)
(declare-fun class.NativeTypes.uint16 () T@U)
(declare-fun Tagclass.NativeTypes.int32 () T@U)
(declare-fun class.NativeTypes.int32 () T@U)
(declare-fun Tagclass.NativeTypes.uint32 () T@U)
(declare-fun class.NativeTypes.uint32 () T@U)
(declare-fun Tagclass.NativeTypes.int64 () T@U)
(declare-fun class.NativeTypes.int64 () T@U)
(declare-fun Tagclass.NativeTypes.uint64 () T@U)
(declare-fun class.NativeTypes.uint64 () T@U)
(declare-fun Tagclass.NativeTypes.nat8 () T@U)
(declare-fun class.NativeTypes.nat8 () T@U)
(declare-fun Tagclass.NativeTypes.nat16 () T@U)
(declare-fun class.NativeTypes.nat16 () T@U)
(declare-fun Tagclass.NativeTypes.nat32 () T@U)
(declare-fun class.NativeTypes.nat32 () T@U)
(declare-fun Tagclass.NativeTypes.nat64 () T@U)
(declare-fun class.NativeTypes.nat64 () T@U)
(declare-fun Tagclass.NativeTypes.uint128 () T@U)
(declare-fun class.NativeTypes.uint128 () T@U)
(declare-fun class.NativeTypes.__default () T@U)
(declare-fun Tagclass.NativeTypes.__default () T@U)
(declare-fun class.KeyType.__default () T@U)
(declare-fun Tagclass.KeyType.__default () T@U)
(declare-fun class.ValueType.__default () T@U)
(declare-fun Tagclass.ValueType.__default () T@U)
(declare-fun class.LinearMaybe.predefined () T@U)
(declare-fun class.LinearMaybe.__default () T@U)
(declare-fun Tagclass.LinearMaybe.__default () T@U)
(declare-fun class.LinearExtern.predefined () T@U)
(declare-fun class.LinearExtern.__default () T@U)
(declare-fun Tagclass.LinearExtern.__default () T@U)
(declare-fun |##ValueMessage.Delta.NoDelta| () T@U)
(declare-fun Tagclass.ValueMessage.Delta () T@U)
(declare-fun class.ValueMessage.Delta () T@U)
(declare-fun class.ValueMessage.__default () T@U)
(declare-fun Tagclass.ValueMessage.__default () T@U)
(declare-fun Tagclass.ValueMessage.Message () T@U)
(declare-fun |##ValueMessage.Message.Define| () T@U)
(declare-fun |##ValueMessage.Message.Update| () T@U)
(declare-fun class.ValueMessage.Message () T@U)
(declare-fun class.TotalKMMapMod.__default () T@U)
(declare-fun Tagclass.TotalKMMapMod.__default () T@U)
(declare-fun Tagclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun class.LSNMod.__default () T@U)
(declare-fun Tagclass.LSNMod.__default () T@U)
(declare-fun |##StampedMod.Stamped.Stamped| () T@U)
(declare-fun class.StampedMod.Stamped () T@U)
(declare-fun class.StampedMod.__default () T@U)
(declare-fun Tagclass.StampedMod.__default () T@U)
(declare-fun class.SequencesLite.__default () T@U)
(declare-fun Tagclass.SequencesLite.__default () T@U)
(declare-fun class.Mathematics.__default () T@U)
(declare-fun Tagclass.Mathematics.__default () T@U)
(declare-fun class.LinearSequence__i.__default () T@U)
(declare-fun Tagclass.LinearSequence__i.__default () T@U)
(declare-fun class.Sequences.__default () T@U)
(declare-fun Tagclass.Sequences.__default () T@U)
(declare-fun class.MapRemove_s.__default () T@U)
(declare-fun Tagclass.MapRemove_s.__default () T@U)
(declare-fun class.Maps.__default () T@U)
(declare-fun Tagclass.Maps.__default () T@U)
(declare-fun |##MsgHistoryMod.KeyedMessage.KeyedMessage| () T@U)
(declare-fun Tagclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun class.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun |##MsgHistoryMod.MsgHistory.MsgHistory| () T@U)
(declare-fun class.MsgHistoryMod.MsgHistory () T@U)
(declare-fun class.MsgHistoryMod.__default () T@U)
(declare-fun Tagclass.MsgHistoryMod.__default () T@U)
(declare-fun |##Buffers.Buffer.Buffer| () T@U)
(declare-fun Tagclass.Buffers.Buffer () T@U)
(declare-fun class.Buffers.Buffer () T@U)
(declare-fun |##Buffers.BufferStack.BufferStack| () T@U)
(declare-fun class.Buffers.BufferStack () T@U)
(declare-fun class.Buffers.__default () T@U)
(declare-fun Tagclass.Buffers.__default () T@U)
(declare-fun |##MemtableMod.Memtable.Memtable| () T@U)
(declare-fun class.MemtableMod.Memtable () T@U)
(declare-fun class.MemtableMod.__default () T@U)
(declare-fun Tagclass.MemtableMod.__default () T@U)
(declare-fun class.Sets.__default () T@U)
(declare-fun Tagclass.Sets.__default () T@U)
(declare-fun class.SeqComparison.__default () T@U)
(declare-fun Tagclass.SeqComparison.__default () T@U)
(declare-fun class.NativeArrays.__default () T@U)
(declare-fun Tagclass.NativeArrays.__default () T@U)
(declare-fun class.Byte__Order.__default () T@U)
(declare-fun Tagclass.Byte__Order.__default () T@U)
(declare-fun class.Lexicographic__Byte__Order.__default () T@U)
(declare-fun Tagclass.Lexicographic__Byte__Order.__default () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun |##Upperbounded_Lexicographic_Byte_Order.Element.Element| () T@U)
(declare-fun |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun class.BoundedPivotsLib.__default () T@U)
(declare-fun Tagclass.BoundedPivotsLib.__default () T@U)
(declare-fun |##DomainMod.Domain.EmptyDomain| () T@U)
(declare-fun |##DomainMod.Domain.Domain| () T@U)
(declare-fun class.DomainMod.Domain () T@U)
(declare-fun class.DomainMod.__default () T@U)
(declare-fun Tagclass.DomainMod.__default () T@U)
(declare-fun |##SplitRequestMod.SplitRequest.SplitLeaf| () T@U)
(declare-fun |##SplitRequestMod.SplitRequest.SplitIndex| () T@U)
(declare-fun class.SplitRequestMod.SplitRequest () T@U)
(declare-fun class.SplitRequestMod.__default () T@U)
(declare-fun Tagclass.SplitRequestMod.__default () T@U)
(declare-fun |##PivotBetree.TransitionLabel.QueryLabel| () T@U)
(declare-fun |##PivotBetree.TransitionLabel.PutLabel| () T@U)
(declare-fun |##PivotBetree.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##PivotBetree.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun |##PivotBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun class.PivotBetree.TransitionLabel () T@U)
(declare-fun |##PivotBetree.BetreeNode.Nil| () T@U)
(declare-fun |##PivotBetree.BetreeNode.BetreeNode| () T@U)
(declare-fun class.PivotBetree.BetreeNode () T@U)
(declare-fun |##PivotBetree.QueryReceiptLine.QueryReceiptLine| () T@U)
(declare-fun class.PivotBetree.QueryReceiptLine () T@U)
(declare-fun |##PivotBetree.QueryReceipt.QueryReceipt| () T@U)
(declare-fun class.PivotBetree.QueryReceipt () T@U)
(declare-fun |##PivotBetree.Variables.Variables| () T@U)
(declare-fun class.PivotBetree.Variables () T@U)
(declare-fun |##PivotBetree.Path.Path| () T@U)
(declare-fun class.PivotBetree.Path () T@U)
(declare-fun |##PivotBetree.Step.QueryStep| () T@U)
(declare-fun |##PivotBetree.Step.PutStep| () T@U)
(declare-fun |##PivotBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |##PivotBetree.Step.FreezeAsStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalGrowStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalSplitStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalFlushStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalCompactStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalNoOpStep| () T@U)
(declare-fun class.PivotBetree.Step () T@U)
(declare-fun class.PivotBetree.__default () T@U)
(declare-fun Tagclass.PivotBetree.__default () T@U)
(declare-fun |##PagedBetree.TransitionLabel.QueryLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.PutLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun |##PagedBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun class.PagedBetree.TransitionLabel () T@U)
(declare-fun |##PagedBetree.ChildMap.ChildMap| () T@U)
(declare-fun class.PagedBetree.ChildMap () T@U)
(declare-fun |##PagedBetree.BetreeNode.Nil| () T@U)
(declare-fun |##PagedBetree.BetreeNode.BetreeNode| () T@U)
(declare-fun class.PagedBetree.BetreeNode () T@U)
(declare-fun |##PagedBetree.QueryReceiptLine.QueryReceiptLine| () T@U)
(declare-fun class.PagedBetree.QueryReceiptLine () T@U)
(declare-fun |##PagedBetree.QueryReceipt.QueryReceipt| () T@U)
(declare-fun class.PagedBetree.QueryReceipt () T@U)
(declare-fun |##PagedBetree.Variables.Variables| () T@U)
(declare-fun class.PagedBetree.Variables () T@U)
(declare-fun |##PagedBetree.Path.Path| () T@U)
(declare-fun class.PagedBetree.Path () T@U)
(declare-fun |##PagedBetree.Step.QueryStep| () T@U)
(declare-fun |##PagedBetree.Step.PutStep| () T@U)
(declare-fun |##PagedBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |##PagedBetree.Step.FreezeAsStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalGrowStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalSplitStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalFlushStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalCompactStep| () T@U)
(declare-fun |##PagedBetree.Step.InternalNoOpStep| () T@U)
(declare-fun class.PagedBetree.Step () T@U)
(declare-fun class.PagedBetree.__default () T@U)
(declare-fun Tagclass.PagedBetree.__default () T@U)
(declare-fun |##AbstractMap.TransitionLabel.QueryLabel| () T@U)
(declare-fun Tagclass.AbstractMap.TransitionLabel () T@U)
(declare-fun |##AbstractMap.TransitionLabel.PutLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun |##AbstractMap.TransitionLabel.InternalLabel| () T@U)
(declare-fun class.AbstractMap.TransitionLabel () T@U)
(declare-fun |##AbstractMap.Variables.Variables| () T@U)
(declare-fun Tagclass.AbstractMap.Variables () T@U)
(declare-fun class.AbstractMap.Variables () T@U)
(declare-fun class.AbstractMap.__default () T@U)
(declare-fun Tagclass.AbstractMap.__default () T@U)
(declare-fun class.PagedBetreeRefinement.__default () T@U)
(declare-fun Tagclass.PagedBetreeRefinement.__default () T@U)
(declare-fun tytagFamily$nat () T@U)
(declare-fun tytagFamily$object () T@U)
(declare-fun tytagFamily$array () T@U)
(declare-fun |tytagFamily$_#Func1| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1| () T@U)
(declare-fun |tytagFamily$_#Func0| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0| () T@U)
(declare-fun tytagFamily$_default () T@U)
(declare-fun |tytagFamily$_#Func2| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2| () T@U)
(declare-fun |tytagFamily$_tuple#2| () T@U)
(declare-fun |tytagFamily$_#Func4| () T@U)
(declare-fun |tytagFamily$_#PartialFunc4| () T@U)
(declare-fun |tytagFamily$_#TotalFunc4| () T@U)
(declare-fun |tytagFamily$_#Func3| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3| () T@U)
(declare-fun |tytagFamily$_#Func2OSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#Func3LLOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#Func1OS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OS| () T@U)
(declare-fun |tytagFamily$_#Func0L| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0L| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0L| () T@U)
(declare-fun |tytagFamily$_#Func2LOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LOO| () T@U)
(declare-fun |tytagFamily$_tuple#0| () T@U)
(declare-fun |tytagFamily$_#Func1OL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OL| () T@U)
(declare-fun |tytagFamily$_#Func1LO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LO| () T@U)
(declare-fun |tytagFamily$_tuple#2OLL| () T@U)
(declare-fun |tytagFamily$_#Func3LLOL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#Func2SSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#Func2LLO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#Func1SS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1SS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1SS| () T@U)
(declare-fun |tytagFamily$_#Func1LL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LL| () T@U)
(declare-fun tytagFamily$BetreeNode () T@U)
(declare-fun tytagFamily$ChildMap () T@U)
(declare-fun tytagFamily$Key () T@U)
(declare-fun tytagFamily$Stamped () T@U)
(declare-fun tytagFamily$TransitionLabel () T@U)
(declare-fun tytagFamily$MsgHistory () T@U)
(declare-fun tytagFamily$Value () T@U)
(declare-fun tytagFamily$byte () T@U)
(declare-fun tytagFamily$Variables () T@U)
(declare-fun tytagFamily$Step () T@U)
(declare-fun tytagFamily$Path () T@U)
(declare-fun tytagFamily$SplitRequest () T@U)
(declare-fun tytagFamily$BufferStack () T@U)
(declare-fun tytagFamily$Element () T@U)
(declare-fun tytagFamily$QueryReceiptLine () T@U)
(declare-fun tytagFamily$QueryReceipt () T@U)
(declare-fun tytagFamily$Domain () T@U)
(declare-fun tytagFamily$Memtable () T@U)
(declare-fun tytagFamily$Option () T@U)
(declare-fun tytagFamily$sbyte () T@U)
(declare-fun tytagFamily$int16 () T@U)
(declare-fun tytagFamily$uint16 () T@U)
(declare-fun tytagFamily$int32 () T@U)
(declare-fun tytagFamily$uint32 () T@U)
(declare-fun tytagFamily$int64 () T@U)
(declare-fun tytagFamily$uint64 () T@U)
(declare-fun tytagFamily$nat8 () T@U)
(declare-fun tytagFamily$nat16 () T@U)
(declare-fun tytagFamily$nat32 () T@U)
(declare-fun tytagFamily$nat64 () T@U)
(declare-fun tytagFamily$uint128 () T@U)
(declare-fun tytagFamily$Delta () T@U)
(declare-fun tytagFamily$Message () T@U)
(declare-fun tytagFamily$TotalMap () T@U)
(declare-fun tytagFamily$KeyedMessage () T@U)
(declare-fun tytagFamily$Buffer () T@U)
(declare-fun TyType () T@T)
(declare-fun TyTagType () T@T)
(declare-fun ClassNameType () T@T)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun NameFamilyType () T@T)
(declare-fun DtCtorIdType () T@T)
(declare-fun TyTagFamilyType () T@T)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TBitvector (Int) T@U)
(declare-fun Inv0_TBitvector (T@U) Int)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun $Box (T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun LitInt (Int) Int)
(declare-fun LitReal (Real) Real)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#Plus| (T@U T@U) T@U)
(declare-fun |char#Minus| (T@U T@U) T@U)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun refType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun Tclass._System.Tuple2 (T@U T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object? () T@U)
(declare-fun BoxRank (T@U) Int)
(declare-fun DatatypeTypeType () T@T)
(declare-fun DtRank (T@U) Int)
(declare-fun |ORD#Offset| (T@U) Int)
(declare-fun |ORD#FromNat| (Int) T@U)
(declare-fun |ORD#IsNat| (T@U) Bool)
(declare-fun |ORD#Less| (T@U T@U) Bool)
(declare-fun |ORD#LessThanLimit| (T@U T@U) Bool)
(declare-fun |ORD#Plus| (T@U T@U) T@U)
(declare-fun |ORD#Minus| (T@U T@U) T@U)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $OneHeap () T@U)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Create| (T@U T@U Int T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2._0 (T@U) T@U)
(declare-fun _System.Tuple2._1 (T@U) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Merge| (T@U T@U) T@U)
(declare-fun |Map#Subtract| (T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun |IMap#Merge| (T@U T@U) T@U)
(declare-fun |IMap#Subtract| (T@U T@U) T@U)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun Mul (Int Int) Int)
(declare-fun Div (Int Int) Int)
(declare-fun Mod (Int Int) Int)
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun _System.__default.rank__is__less__than (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.nat () T@U)
(declare-fun TagFamily (T@U) T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun Tclass._System.array? (T@U) T@U)
(declare-fun Tclass._System.array?_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.__default () T@U)
(declare-fun |_System.__default.rank__is__less__than#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |_System.__default.rank__is__less__than#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_2 (T@U) T@U)
(declare-fun Apply2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle2 (T@U T@U T@U) T@U)
(declare-fun MapType3Type (T@T T@T T@T T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U T@U) T@U)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3TypeInv2 (T@T) T@T)
(declare-fun MapType3TypeInv3 (T@T) T@T)
(declare-fun MapType3Store (T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires2 (T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_2 (T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.Tuple2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2_1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2| (T@U) Bool)
(declare-fun |_System.Tuple2#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_4 (T@U) T@U)
(declare-fun Apply4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle4 (T@U T@U T@U) T@U)
(declare-fun MapType4Type (T@T T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType4Select (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType4TypeInv0 (T@T) T@T)
(declare-fun MapType4TypeInv1 (T@T) T@T)
(declare-fun MapType4TypeInv2 (T@T) T@T)
(declare-fun MapType4TypeInv3 (T@T) T@T)
(declare-fun MapType4TypeInv4 (T@T) T@T)
(declare-fun MapType4TypeInv5 (T@T) T@T)
(declare-fun MapType4Store (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_3 (T@U) T@U)
(declare-fun Apply3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle3 (T@U T@U T@U) T@U)
(declare-fun MapType5Type (T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType5Select (T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType5TypeInv0 (T@T) T@T)
(declare-fun MapType5TypeInv1 (T@T) T@T)
(declare-fun MapType5TypeInv2 (T@T) T@T)
(declare-fun MapType5TypeInv3 (T@T) T@T)
(declare-fun MapType5TypeInv4 (T@T) T@T)
(declare-fun MapType5Store (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_2 (T@U) T@U)
(declare-fun |#_System._tuple#0._#Make0| () T@U)
(declare-fun _System.Tuple0.___hMake0_q (T@U) Bool)
(declare-fun Tclass._System.Tuple0 () T@U)
(declare-fun |$IsA#_System.Tuple0| (T@U) Bool)
(declare-fun |_System.Tuple0#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_1 (T@U) T@U)
(declare-fun |#_System._tuple#2OLL._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2OLL.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2OLL (T@U T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_1 (T@U) T@U)
(declare-fun _System.Tuple2OLL._0 (T@U) T@U)
(declare-fun _System.Tuple2OLL._1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2OLL| (T@U) Bool)
(declare-fun |_System.Tuple2OLL#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_1 (T@U) T@U)
(declare-fun Tclass.PivotBetreeRefinement.__default () T@U)
(declare-fun PivotBetreeRefinement.__default.IChildren (T@U T@U) T@U)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun Tclass.PivotBetree.BetreeNode () T@U)
(declare-fun Tclass.PagedBetree.ChildMap () T@U)
(declare-fun $FunctionContextHeight () Int)
(declare-fun |PivotBetreeRefinement.__default.IChildren#canCall| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.WF (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.BetreeNode_q (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.IChildren#requires| (T@U T@U) Bool)
(declare-fun Tclass.KeyType.Key () T@U)
(declare-fun Tclass.PagedBetree.BetreeNode () T@U)
(declare-fun PivotBetree.BetreeNode.Child (T@U T@U) T@U)
(declare-fun PivotBetree.BetreeNode.KeySet (T@U) T@U)
(declare-fun Buffers.__default.AnyKey (T@U) Bool)
(declare-fun |Buffers.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeySet#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Child#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.INode#canCall| (T@U) Bool)
(declare-fun |#PagedBetree.ChildMap.ChildMap| (T@U) T@U)
(declare-fun |lambda#0| (T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U T@U) T@U)
(declare-fun |#PagedBetree.BetreeNode.Nil| () T@U)
(declare-fun PivotBetreeRefinement.__default.INode (T@U T@U) T@U)
(declare-fun PagedBetree.BetreeNode.WF (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.INode#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.Nil_q (T@U) Bool)
(declare-fun |#PagedBetree.BetreeNode.BetreeNode| (T@U T@U) T@U)
(declare-fun PivotBetree.BetreeNode.buffers (T@U) T@U)
(declare-fun Tclass.StampedMod.Stamped (T@U) T@U)
(declare-fun Tclass.StampedMod.Stamped_0 (T@U) T@U)
(declare-fun PivotBetreeRefinement.__default.IStampedBetree (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IStampedBetree#canCall| (T@U) Bool)
(declare-fun StampedMod.Stamped.value (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IStampedBetree#requires| (T@U) Bool)
(declare-fun StampedMod.Stamped.Stamped_q (T@U) Bool)
(declare-fun |#StampedMod.Stamped.Stamped| (T@U Int) T@U)
(declare-fun StampedMod.Stamped.seqEnd (T@U) Int)
(declare-fun Tclass.PivotBetree.TransitionLabel () T@U)
(declare-fun Tclass.PagedBetree.TransitionLabel () T@U)
(declare-fun PivotBetreeRefinement.__default.ILbl (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.ILbl#canCall| (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.ILbl#requires| (T@U) Bool)
(declare-fun PivotBetree.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun PivotBetree.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun PivotBetree.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun PivotBetree.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun PivotBetree.TransitionLabel.stampedBetree (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.__default.EmptyImage#canCall| () Bool)
(declare-fun PivotBetree.TransitionLabel.value (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.key (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.endLsn (T@U) Int)
(declare-fun |#PagedBetree.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.puts (T@U) T@U)
(declare-fun |#PagedBetree.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun |#PagedBetree.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun |#PagedBetree.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun PagedBetree.__default.EmptyImage () T@U)
(declare-fun |#PagedBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun Tclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun Tclass.ValueType.Value () T@U)
(declare-fun Tclass.NativeTypes.byte () T@U)
(declare-fun Tclass.PivotBetree.Variables () T@U)
(declare-fun Tclass.PagedBetree.Variables () T@U)
(declare-fun PivotBetreeRefinement.__default.I (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.I#canCall| (T@U) Bool)
(declare-fun PivotBetree.Variables.WF (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.I#requires| (T@U) Bool)
(declare-fun PivotBetree.Variables.Variables_q (T@U) Bool)
(declare-fun PivotBetree.Variables.root (T@U) T@U)
(declare-fun |#PagedBetree.Variables.Variables| (T@U T@U) T@U)
(declare-fun PivotBetree.Variables.memtable (T@U) T@U)
(declare-fun PivotBetreeRefinement.__default.Inv (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.Inv#canCall| (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.Inv#requires| (T@U) Bool)
(declare-fun |PivotBetree.Variables.WF#canCall| (T@U) Bool)
(declare-fun |$IsA#DomainMod.Domain| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.MyDomain (T@U) T@U)
(declare-fun DomainMod.__default.TotalDomain () T@U)
(declare-fun |PivotBetree.BetreeNode.MyDomain#canCall| (T@U) Bool)
(declare-fun |DomainMod.__default.TotalDomain#canCall| () Bool)
(declare-fun |DomainMod.Domain#Equal| (T@U T@U) Bool)
(declare-fun Tclass.PivotBetree.Step () T@U)
(declare-fun Tclass.PivotBetree.Path () T@U)
(declare-fun Tclass.SplitRequestMod.SplitRequest () T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#Handle| (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.SplitParentDefn (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#requires| (T@U T@U) Bool)
(declare-fun Tclass.Buffers.BufferStack () T@U)
(declare-fun PivotBetreeRefinement.__default.Routing (T@U T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.Routing#canCall| (T@U) Bool)
(declare-fun PivotBetree.Path.Valid (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.Routing#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.Path_q (T@U) Bool)
(declare-fun PivotBetree.Path.depth (T@U) Int)
(declare-fun |BoundedPivotsLib.__default.Route#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.pivotTable (T@U) T@U)
(declare-fun PivotBetree.Path.node (T@U) T@U)
(declare-fun PivotBetree.Path.key (T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (T@U Int) Bool)
(declare-fun BoundedPivotsLib.__default.Route (T@U T@U) Int)
(declare-fun |PivotBetree.Path.Subpath#canCall| (T@U) Bool)
(declare-fun PivotBetree.Path.Subpath (T@U) T@U)
(declare-fun BoundedPivotsLib.__default.PivotTableBucketKeySet (T@U Int) T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun Tclass.PagedBetree.Path () T@U)
(declare-fun PivotBetreeRefinement.__default.IPath (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IPath#canCall| (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.IPath#requires| (T@U) Bool)
(declare-fun |#PagedBetree.Path.Path| (T@U T@U T@U) T@U)
(declare-fun Tclass.PivotBetree.QueryReceiptLine () T@U)
(declare-fun Tclass.PagedBetree.QueryReceiptLine () T@U)
(declare-fun PivotBetreeRefinement.__default.IReceiptLine (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IReceiptLine#canCall| (T@U) Bool)
(declare-fun PivotBetree.QueryReceiptLine.WF (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.IReceiptLine#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceiptLine.QueryReceiptLine_q (T@U) Bool)
(declare-fun PivotBetree.QueryReceiptLine.node (T@U) T@U)
(declare-fun |#PagedBetree.QueryReceiptLine.QueryReceiptLine| (T@U T@U) T@U)
(declare-fun PivotBetree.QueryReceiptLine.result (T@U) T@U)
(declare-fun Tclass.PivotBetree.QueryReceipt () T@U)
(declare-fun Tclass.PagedBetree.QueryReceipt () T@U)
(declare-fun PivotBetreeRefinement.__default.IReceipt (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IReceipt#canCall| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Valid (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.IReceipt#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.QueryReceipt_q (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.root (T@U) T@U)
(declare-fun PivotBetree.QueryReceipt.lines (T@U) T@U)
(declare-fun |#PagedBetree.QueryReceipt.QueryReceipt| (T@U T@U T@U) T@U)
(declare-fun PivotBetree.QueryReceipt.key (T@U) T@U)
(declare-fun |lambda#35| (T@U) T@U)
(declare-fun |lambda#31| (T@U) T@U)
(declare-fun |lambda#32| (T@U Int Int) T@U)
(declare-fun |lambda#34| (T@U) T@U)
(declare-fun |lambda#33| (Bool) T@U)
(declare-fun PivotBetreeRefinement.__default.SplitChildKeys (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.SplitChildKeys#canCall| (T@U) Bool)
(declare-fun PivotBetree.Step.WF (T@U) Bool)
(declare-fun PivotBetree.Step.InternalSplitStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.path (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.SplitChildKeys#requires| (T@U) Bool)
(declare-fun |PivotBetree.Path.Target#canCall| (T@U) Bool)
(declare-fun SplitRequestMod.SplitRequest.SplitLeaf_q (T@U) Bool)
(declare-fun PivotBetree.Step.request (T@U) T@U)
(declare-fun SplitRequestMod.SplitRequest.SplitIndex_q (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (T@U Int) Bool)
(declare-fun PivotBetree.Path.Target (T@U T@U) T@U)
(declare-fun SplitRequestMod.SplitRequest.childIdx (T@U) Int)
(declare-fun |DomainMod.Domain.KeySet#canCall| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.DomainRoutedToChild (T@U Int) T@U)
(declare-fun DomainMod.Domain.KeySet (T@U) T@U)
(declare-fun Tclass.DomainMod.Domain () T@U)
(declare-fun PivotBetreeRefinement.__default.SplitLeftKeys (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.SplitLeftKeys#canCall| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.CanSplitParent (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.SplitLeftKeys#requires| (T@U) Bool)
(declare-fun |#Upperbounded_Lexicographic_Byte_Order.Element.Element| (T@U) T@U)
(declare-fun |PivotBetree.Step.SplitKey#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.Step.SplitKey (T@U) T@U)
(declare-fun |lambda#56| (T@U T@U T@U) T@U)
(declare-fun Tclass.PagedBetree.Step () T@U)
(declare-fun PivotBetreeRefinement.__default.IStep (T@U) T@U)
(declare-fun |PivotBetreeRefinement.__default.IStep#canCall| (T@U) Bool)
(declare-fun PagedBetree.Step.WF (T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.IStep#requires| (T@U) Bool)
(declare-fun PivotBetree.Step.QueryStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.receipt (T@U) T@U)
(declare-fun PivotBetree.Step.PutStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.QueryEndLsnStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.FreezeAsStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.InternalGrowStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.InternalFlushMemtableStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.InternalFlushStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.childIdx (T@U) Int)
(declare-fun PivotBetree.Step.InternalCompactStep_q (T@U) Bool)
(declare-fun |#PagedBetree.Step.QueryStep| (T@U) T@U)
(declare-fun |#PagedBetree.Step.PutStep| () T@U)
(declare-fun |#PagedBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |#PagedBetree.Step.FreezeAsStep| () T@U)
(declare-fun |#PagedBetree.Step.InternalGrowStep| () T@U)
(declare-fun |#PagedBetree.Step.InternalSplitStep| (T@U T@U T@U) T@U)
(declare-fun |#PagedBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |#PagedBetree.Step.InternalFlushStep| (T@U T@U) T@U)
(declare-fun PivotBetree.Step.compactedBuffers (T@U) T@U)
(declare-fun |#PagedBetree.Step.InternalCompactStep| (T@U T@U) T@U)
(declare-fun |#PagedBetree.Step.InternalNoOpStep| () T@U)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#Handle| (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.SplitLeaf (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#Handle| (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.SplitIndex (T@U Int) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#requires| (T@U Int) Bool)
(declare-fun PivotBetreeRefinement.__default.EquivalentBufferCompaction (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.EquivalentBufferCompaction#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetreeRefinement.__default.EquivalentBufferCompaction#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#canCall| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.Equivalent (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.children (T@U) T@U)
(declare-fun Tclass.MemtableMod.Memtable () T@U)
(declare-fun |#Options.Option.None| () T@U)
(declare-fun Options.Option.None_q (T@U) Bool)
(declare-fun Tclass.Options.Option (T@U) T@U)
(declare-fun Tclass.Options.Option_0 (T@U) T@U)
(declare-fun |#Options.Option.Some| (T@U) T@U)
(declare-fun Options.Option.Some_q (T@U) Bool)
(declare-fun Options.Option.value (T@U) T@U)
(declare-fun |$IsA#Options.Option| (T@U) Bool)
(declare-fun |Options.Option#Equal| (T@U T@U) Bool)
(declare-fun Tclass.Options.__default () T@U)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun Options.__default.MapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Options.__default.MapOption#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Options.__default.MapOption#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Options.__default.FlatMapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Options.__default.FlatMapOption#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Options.__default.FlatMapOption#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Tclass.NativeTypes.sbyte () T@U)
(declare-fun Tclass.NativeTypes.int16 () T@U)
(declare-fun Tclass.NativeTypes.uint16 () T@U)
(declare-fun Tclass.NativeTypes.int32 () T@U)
(declare-fun Tclass.NativeTypes.uint32 () T@U)
(declare-fun Tclass.NativeTypes.int64 () T@U)
(declare-fun Tclass.NativeTypes.uint64 () T@U)
(declare-fun Tclass.NativeTypes.nat8 () T@U)
(declare-fun Tclass.NativeTypes.nat16 () T@U)
(declare-fun Tclass.NativeTypes.nat32 () T@U)
(declare-fun Tclass.NativeTypes.nat64 () T@U)
(declare-fun Tclass.NativeTypes.uint128 () T@U)
(declare-fun Tclass.NativeTypes.__default () T@U)
(declare-fun NativeTypes.__default.Uint64Size () Int)
(declare-fun |NativeTypes.__default.Uint64Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32Size () Int)
(declare-fun |NativeTypes.__default.Uint32Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint16Size () Int)
(declare-fun |NativeTypes.__default.Uint16Size#requires| () Bool)
(declare-fun |NativeTypes.__default.Uint64UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint64UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint32UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32UpperBound () Int)
(declare-fun NativeTypes.__default.Uint8UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint8UpperBound#requires| () Bool)
(declare-fun Tclass.KeyType.__default () T@U)
(declare-fun KeyType.__default.MaxLen () Int)
(declare-fun |KeyType.__default.MaxLen#requires| () Bool)
(declare-fun Tclass.ValueType.__default () T@U)
(declare-fun ValueType.__default.MaxLen () Int)
(declare-fun |ValueType.__default.MaxLen#requires| () Bool)
(declare-fun ValueType.__default.DefaultValue () T@U)
(declare-fun |ValueType.__default.DefaultValue#requires| () Bool)
(declare-fun ValueType.__default.Len (T@U) Int)
(declare-fun |ValueType.__default.Len#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.Len#requires| (T@U) Bool)
(declare-fun ValueType.__default.ValidMessageBytestring (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#requires| (T@U) Bool)
(declare-fun |ValueType.__default.MaxLen#canCall| () Bool)
(declare-fun ValueType.__default.ValidMessageBytestrings (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#requires| (T@U) Bool)
(declare-fun Tclass.LinearMaybe.__default () T@U)
(declare-fun LinearMaybe.__default.has (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.has#canCall| (T@U T@U) Bool)
(declare-fun |#$maybe| (T@U) T@U)
(declare-fun |LinearMaybe.__default.has#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.read (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.read#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.read#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.peek (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.peek#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.peek#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.unwrap (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.unwrap#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.unwrap#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.give (T@U T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.give#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.give#requires| (T@U T@U T@U) Bool)
(declare-fun LinearMaybe.__default.empty (T@U) T@U)
(declare-fun |LinearMaybe.__default.empty#requires| (T@U) Bool)
(declare-fun LinearMaybe.__default.discard (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.discard#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.discard#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.imagine (T@U Bool T@U) T@U)
(declare-fun |LinearMaybe.__default.imagine#canCall| (T@U Bool T@U) Bool)
(declare-fun |LinearMaybe.__default.imagine#requires| (T@U Bool T@U) Bool)
(declare-fun Tclass.LinearExtern.__default () T@U)
(declare-fun LinearExtern.__default.seq_get (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.seq_get#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.seq_get#requires| (T@U T@U Int) Bool)
(declare-fun LinearExtern.__default.seq_set (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_set#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_set#requires| (T@U T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_length (T@U T@U) Int)
(declare-fun |LinearExtern.__default.seq_length#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_length#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_empty (T@U) T@U)
(declare-fun |LinearExtern.__default.seq_empty#requires| (T@U) Bool)
(declare-fun LinearExtern.__default.seq_alloc (T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_alloc#canCall| (T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_alloc#requires| (T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_free (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_free#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_free#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_unleash (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_unleash#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_unleash#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseqs__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseqs__raw#canCall| (T@U T@U) Bool)
(declare-fun |#$lseq| (T@U) T@U)
(declare-fun |LinearExtern.__default.lseqs__raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq__has (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq__has#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq__has#requires| (T@U T@U) Bool)
(declare-fun |lambda#139| (T@U T@U) T@U)
(declare-fun LinearExtern.__default.imagine__lseq__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_length_raw (T@U T@U) Int)
(declare-fun |LinearExtern.__default.lseq_length_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_length_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_alloc_raw (T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#canCall| (T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#requires| (T@U Int) Bool)
(declare-fun LinearExtern.__default.lseq_free_raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_free_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_free_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_swap_raw_fun (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#requires| (T@U T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.lseq_share_raw (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_share_raw#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_share_raw#requires| (T@U T@U Int) Bool)
(declare-fun |#ValueMessage.Delta.NoDelta| () T@U)
(declare-fun ValueMessage.Delta.NoDelta_q (T@U) Bool)
(declare-fun Tclass.ValueMessage.Delta () T@U)
(declare-fun |$IsA#ValueMessage.Delta| (T@U) Bool)
(declare-fun |ValueMessage.Delta#Equal| (T@U T@U) Bool)
(declare-fun Tclass.ValueMessage.__default () T@U)
(declare-fun ValueMessage.__default.NopDelta () T@U)
(declare-fun |ValueMessage.__default.NopDelta#requires| () Bool)
(declare-fun ValueMessage.__default.DefaultValue () T@U)
(declare-fun |ValueMessage.__default.DefaultValue#requires| () Bool)
(declare-fun |ValueType.__default.DefaultValue#canCall| () Bool)
(declare-fun ValueMessage.__default.CombineDeltas (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.CombineDeltas#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.CombineDeltas#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.__default.ApplyDelta (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.ApplyDelta#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.ApplyDelta#requires| (T@U T@U) Bool)
(declare-fun Tclass.ValueMessage.Message () T@U)
(declare-fun ValueMessage.__default.MakeValueMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.MakeValueMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.MakeValueMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.__default.EncodableMessage (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.Define_q (T@U) Bool)
(declare-fun ValueMessage.__default.EvaluateMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.EvaluateMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EvaluateMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.value (T@U) T@U)
(declare-fun ValueMessage.__default.Merge (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.Merge#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.Merge#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.Message.delta (T@U) T@U)
(declare-fun |#ValueMessage.Message.Define| (T@U) T@U)
(declare-fun |#ValueMessage.Message.Update| (T@U) T@U)
(declare-fun ValueMessage.__default.IdentityMessage () T@U)
(declare-fun |ValueMessage.__default.IdentityMessage#requires| () Bool)
(declare-fun |ValueMessage.__default.NopDelta#canCall| () Bool)
(declare-fun ValueMessage.__default.DefaultMessage () T@U)
(declare-fun |ValueMessage.__default.DefaultMessage#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultValue#canCall| () Bool)
(declare-fun ValueMessage.Message.Update_q (T@U) Bool)
(declare-fun |$IsA#ValueMessage.Message| (T@U) Bool)
(declare-fun |ValueMessage.Message#Equal| (T@U T@U) Bool)
(declare-fun Tclass.TotalKMMapMod.__default () T@U)
(declare-fun TotalKMMapMod.__default.TerminalValue (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.DefaultV () T@U)
(declare-fun |TotalKMMapMod.__default.DefaultV#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultMessage#canCall| () Bool)
(declare-fun TotalKMMapMod.__default.AnyKey (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.Defined (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#canCall| (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#requires| (T@U T@U) Bool)
(declare-fun TotalKMMapMod.__default.TotalMapIsFull (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.EmptyTotalMap () T@U)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#requires| () Bool)
(declare-fun |TotalKMMapMod.__default.DefaultV#canCall| () Bool)
(declare-fun |lambda#149| (T@U) T@U)
(declare-fun |lambda#150| (T@U) T@U)
(declare-fun TotalKMMapMod.__default.Witness () T@U)
(declare-fun |TotalKMMapMod.__default.Witness#requires| () Bool)
(declare-fun Tclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun Tclass.LSNMod.__default () T@U)
(declare-fun |$IsA#StampedMod.Stamped| (T@U) Bool)
(declare-fun |StampedMod.Stamped#Equal| (T@U T@U) Bool)
(declare-fun Tclass.StampedMod.__default () T@U)
(declare-fun StampedMod.__default.Empty () T@U)
(declare-fun |StampedMod.__default.Empty#requires| () Bool)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#canCall| () Bool)
(declare-fun Tclass.SequencesLite.__default () T@U)
(declare-fun SequencesLite.__default.Last (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.Last#requires| (T@U T@U) Bool)
(declare-fun SequencesLite.__default.DropLast (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Tclass.Mathematics.__default () T@U)
(declare-fun Mathematics.__default.min (Int Int) Int)
(declare-fun |Mathematics.__default.min#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.max (Int Int) Int)
(declare-fun |Mathematics.__default.max#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.Set (T@U T@U) T@U)
(declare-fun |Mathematics.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.Set#requires| (T@U T@U) Bool)
(declare-fun |lambda#153| (T@U T@U Int) T@U)
(declare-fun Mathematics.__default.ISet (T@U T@U) T@U)
(declare-fun |Mathematics.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun |lambda#155| (T@U T@U) T@U)
(declare-fun Tclass.LinearSequence__i.__default () T@U)
(declare-fun LinearSequence__i.__default.seq__alloc__init (T@U Int T@U) T@U)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#canCall| (T@U Int T@U) Bool)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#requires| (T@U Int T@U) Bool)
(declare-fun LinearSequence__i.__default.lseqs (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseqs#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseqs#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.imagine__lseq (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.imagine__lseq#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.imagine__lseq#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.linLast (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.linLast#canCall| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.operator_kcardinality_qlseq (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.linLast#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.ldroplast (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.ldroplast#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.ldroplast#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__has__all (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__length__as__uint64 (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__length (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__length#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.operator_ksubscript_qlseq (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.operator_kin_qlseq (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__add (T@U T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__add#canCall| (T@U T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__add#requires| (T@U T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__peek (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__peek#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.lseq__peek#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__free__fun (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__take__fun (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__full (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#requires| (T@U T@U) Bool)
(declare-fun Tclass.Sequences.__default () T@U)
(declare-fun Sequences.__default.Last (T@U T@U) T@U)
(declare-fun |Sequences.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Last#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.FirstOpt (T@U T@U) T@U)
(declare-fun |Sequences.__default.FirstOpt#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FirstOpt#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.DropLast (T@U T@U) T@U)
(declare-fun |Sequences.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Set (T@U T@U) T@U)
(declare-fun |Sequences.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Set#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.ISet (T@U T@U) T@U)
(declare-fun |Sequences.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.NoDupes (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IndexOf (T@U T@U T@U) Int)
(declare-fun |Sequences.__default.IndexOf#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IndexOf#requires| (T@U T@U T@U) Bool)
(declare-fun |$let#0_i| (T@U T@U T@U) Int)
(declare-fun |$let#0$canCall| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Range (T@U Int) T@U)
(declare-fun |Sequences.__default.Range#canCall| (Int) Bool)
(declare-fun |Sequences.__default.Range#requires| (T@U Int) Bool)
(declare-fun Sequences.__default.Apply (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Apply#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Apply#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#161| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#162| (T@U Int Int T@U T@U T@U T@U) T@U)
(declare-fun |lambda#164| (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Sequences.__default.ApplyOpaque (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.ApplyOpaque#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.ApplyOpaque#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Filter (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Filter#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Filter#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldLeft (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldLeft#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldLeft#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldRight#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldRight#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldFromRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldFromRight#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldFromRight#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldSets (T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldSets#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldSets#requires| (T@U T@U) Bool)
(declare-fun |lambda#176| () T@U)
(declare-fun |lambda#177| (T@U T@U) T@U)
(declare-fun |lambda#179| (T@U) T@U)
(declare-fun Sequences.__default.remove (T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.remove#canCall| (T@U T@U Int) Bool)
(declare-fun |Sequences.__default.remove#requires| (T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.RemoveOneValue (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.RemoveOneValue#canCall| (T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.NoDupes () T@U)
(declare-fun |Sequences.__default.RemoveOneValue#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |$let#4_i| (T@U T@U T@U) Int)
(declare-fun |$let#4$canCall| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Sequences._default.NoDupes0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.NoDupes () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes1 () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes2 () T@U)
(declare-fun Sequences.__default.insert (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.insert#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.insert#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.replace1with2 (T@U T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.replace1with2#canCall| (T@U T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.replace1with2#requires| (T@U T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.replace2with1 (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.replace2with1#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.replace2with1#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.concat (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concat3 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat3#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat3#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concatSeq (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concatSeq#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.concatSeq#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsPrefix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsSuffix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.SeqIndexIterate (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.SeqIndexIterate#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.SeqIndexIterate#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.SeqIndex (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.SeqIndex#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqIndex#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.SeqIndexIterate () T@U)
(declare-fun Sequences.__default.SeqOfLength (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqOfLength#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.SeqOfLength#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqIndexUpdate (T@U T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqIndexUpdate#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |Sequences.__default.SeqIndexUpdate#requires| (T@U T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.Zip (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Zip#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Zip#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Unzip (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Unzip#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Unzip#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenShape (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FlattenShape#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FlattenShape#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenLength (T@U T@U) Int)
(declare-fun |Sequences.__default.FlattenLength#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.FlattenLength#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Flatten (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Flatten#canCall| (T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.FlattenLength () T@U)
(declare-fun StartFuel_Sequences._default.FlattenShape () T@U)
(declare-fun |Sequences.__default.Flatten#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Sequences._default.FlattenShape0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.FlattenShape () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenShape1 () T@U)
(declare-fun Sequences.__default.FlattenIndex (T@U Int Int) Int)
(declare-fun |Sequences.__default.FlattenIndex#canCall| (T@U Int Int) Bool)
(declare-fun |Sequences.__default.FlattenIndex#requires| (T@U Int Int) Bool)
(declare-fun Sequences.__default.UnflattenIndex (T@U T@U Int) T@U)
(declare-fun |Sequences.__default.UnflattenIndex#canCall| (T@U Int) Bool)
(declare-fun |Sequences.__default.UnflattenIndex#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Sequences._default.FlattenLength0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.FlattenLength () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenLength1 () T@U)
(declare-fun Sequences.__default.seqMax (T@U T@U) Int)
(declare-fun |Sequences.__default.seqMax#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.seqMax#requires| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.max#canCall| (Int Int) Bool)
(declare-fun Sequences.__default.fill (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.fill#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.fill#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqHasUniqueElems (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#requires| (T@U T@U) Bool)
(declare-fun Tclass.MapRemove_s.__default () T@U)
(declare-fun MapRemove_s.__default.MapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |MapRemove_s.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |MapRemove_s.__default.MapRemove1#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#196| (T@U T@U T@U) T@U)
(declare-fun |lambda#197| (T@U) T@U)
(declare-fun Tclass.Maps.__default () T@U)
(declare-fun Maps.__default.IMapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapInjective (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IsSubIMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IsSubMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgree (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#202| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapRemoveStrong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemoveStrong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemoveStrong#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove0 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1 (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1Strong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1Strong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1Strong#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove10 () T@U)
(declare-fun StartFuelAssert_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove11 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove12 () T@U)
(declare-fun Maps.__default.IMapInvert (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapInvert#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInvert#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |$let#8_a| (T@U T@U T@U T@U) T@U)
(declare-fun |$let#8$canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#207| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.IMapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove1#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#218| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapIRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapIRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapIRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapDisjointUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapDisjointUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapDisjointUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#233| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferA#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferB#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapUnionPreferA () T@U)
(declare-fun Maps.__default.IMapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferA#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferB#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.IMapUnionPreferA () T@U)
(declare-fun Maps.__default.MapDisjointUnion3 (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapDisjointUnion3#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapDisjointUnion () T@U)
(declare-fun |Maps.__default.MapDisjointUnion3#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#253| (T@U T@U T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapToImap (T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapToImap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapToImap#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.ImapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.ImapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.ImapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.KeyedMessage.KeyedMessage| (T@U T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.KeyedMessage_q (T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun MsgHistoryMod.KeyedMessage.key (T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.message (T@U) T@U)
(declare-fun |$IsA#MsgHistoryMod.KeyedMessage| (T@U) Bool)
(declare-fun |MsgHistoryMod.KeyedMessage#Equal| (T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.MsgHistory.MsgHistory| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.MsgHistory_q (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.msgs (T@U) T@U)
(declare-fun MsgHistoryMod.MsgHistory.seqStart (T@U) Int)
(declare-fun MsgHistoryMod.MsgHistory.seqEnd (T@U) Int)
(declare-fun |$IsA#MsgHistoryMod.MsgHistory| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory#Equal| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.WF (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#requires| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ContainsExactly (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#requires| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Contains (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.LSNSet (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#requires| (T@U T@U) Bool)
(declare-fun |lambda#260| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.IsEmpty (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Len (T@U) Int)
(declare-fun |MsgHistoryMod.MsgHistory.Len#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Len#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanConcat (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#requires| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#canCall| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanFollow (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Concat (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#canCall| (T@U T@U) Bool)
(declare-fun StartFuel_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#requires| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ApplyToStampedMap (T@U T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| (T@U T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardRecent (T@U Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.CanDiscardTo (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.MaybeDiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.IncludesSubseq (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#requires| (T@U T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.__default () T@U)
(declare-fun MsgHistoryMod.__default.EmptyHistoryAt (Int) T@U)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#canCall| (Int) Bool)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#requires| (Int) Bool)
(declare-fun MsgHistoryMod.__default.SingletonAt (Int T@U) T@U)
(declare-fun |MsgHistoryMod.__default.SingletonAt#canCall| (Int T@U) Bool)
(declare-fun |MsgHistoryMod.__default.SingletonAt#requires| (Int T@U) Bool)
(declare-fun MsgHistoryMod.__default.MapPlusHistory (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#requires| (T@U T@U) Bool)
(declare-fun |#Buffers.Buffer.Buffer| (T@U) T@U)
(declare-fun Buffers.Buffer.Buffer_q (T@U) Bool)
(declare-fun Tclass.Buffers.Buffer () T@U)
(declare-fun Buffers.Buffer.mapp (T@U) T@U)
(declare-fun |$IsA#Buffers.Buffer| (T@U) Bool)
(declare-fun |Buffers.Buffer#Equal| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.Query (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.Query#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.Query#requires| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.ApplyFilter (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun |#Buffers.BufferStack.BufferStack| (T@U) T@U)
(declare-fun Buffers.BufferStack.BufferStack_q (T@U) Bool)
(declare-fun Buffers.BufferStack.buffers (T@U) T@U)
(declare-fun |$IsA#Buffers.BufferStack| (T@U) Bool)
(declare-fun |Buffers.BufferStack#Equal| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.QueryUpTo (T@U T@U T@U Int) T@U)
(declare-fun |Buffers.BufferStack.QueryUpTo#canCall| (T@U T@U Int) Bool)
(declare-fun |Buffers.BufferStack.QueryUpTo#requires| (T@U T@U T@U Int) Bool)
(declare-fun Buffers.BufferStack.Query (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.Query#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.Query#requires| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.ApplyFilter (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun |lambda#276| (T@U T@U) T@U)
(declare-fun Buffers.BufferStack.PushBufferStack (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#requires| (T@U T@U) Bool)
(declare-fun Tclass.Buffers.__default () T@U)
(declare-fun |Buffers.__default.AnyKey#requires| (T@U) Bool)
(declare-fun Buffers.__default.Total (T@U) Bool)
(declare-fun |Buffers.__default.Total#canCall| (T@U) Bool)
(declare-fun |Buffers.__default.Total#requires| (T@U) Bool)
(declare-fun Buffers.__default.AllKeys () T@U)
(declare-fun |Buffers.__default.AllKeys#requires| () Bool)
(declare-fun |#MemtableMod.Memtable.Memtable| (T@U Int) T@U)
(declare-fun MemtableMod.Memtable.Memtable_q (T@U) Bool)
(declare-fun MemtableMod.Memtable.mapp (T@U) T@U)
(declare-fun MemtableMod.Memtable.seqEnd (T@U) Int)
(declare-fun |$IsA#MemtableMod.Memtable| (T@U) Bool)
(declare-fun |MemtableMod.Memtable#Equal| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Get (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Get#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Get#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.ApplyPut (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPut#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPut#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.ApplyPuts (T@U T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPuts#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPuts#requires| (T@U T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Query (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Query#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Query#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Drain (T@U) T@U)
(declare-fun |MemtableMod.Memtable.Drain#canCall| (T@U) Bool)
(declare-fun |MemtableMod.Memtable.Drain#requires| (T@U) Bool)
(declare-fun |MemtableMod.__default.EmptyMemtable#canCall| (Int) Bool)
(declare-fun MemtableMod.__default.EmptyMemtable (Int) T@U)
(declare-fun MemtableMod.Memtable.IsEmpty (T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#canCall| (T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#requires| (T@U) Bool)
(declare-fun Tclass.MemtableMod.__default () T@U)
(declare-fun |MemtableMod.__default.EmptyMemtable#requires| (Int) Bool)
(declare-fun Tclass.Sets.__default () T@U)
(declare-fun Sets.__default.SetRange (Int) T@U)
(declare-fun |Sets.__default.SetRange#requires| (Int) Bool)
(declare-fun Sets.__default.SetMax (T@U T@U) Int)
(declare-fun |Sets.__default.SetMax#canCall| (T@U) Bool)
(declare-fun |Sets.__default.SetMax#requires| (T@U T@U) Bool)
(declare-fun |$let#13_e| (T@U) Int)
(declare-fun |$let#13$canCall| (T@U) Bool)
(declare-fun Sets.__default.UnionSeqOfSets (T@U T@U T@U) T@U)
(declare-fun |Sets.__default.UnionSeqOfSets#canCall| (T@U T@U) Bool)
(declare-fun |Sets.__default.UnionSeqOfSets#requires| (T@U T@U T@U) Bool)
(declare-fun Tclass.SeqComparison.__default () T@U)
(declare-fun SeqComparison.__default.lte (T@U T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lte#requires| (T@U T@U T@U) Bool)
(declare-fun SeqComparison.__default.lt (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_SeqComparison._default.lte () T@U)
(declare-fun Tclass.NativeArrays.__default () T@U)
(declare-fun Tclass.Byte__Order.__default () T@U)
(declare-fun Byte__Order.__default.SomeElement () Int)
(declare-fun |Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun Byte__Order.__default.lte (T@U Int Int) Bool)
(declare-fun |Byte__Order.__default.lte#canCall| (Int Int) Bool)
(declare-fun Byte__Order.__default.ltedef (T@U Int Int) Bool)
(declare-fun StartFuel_Byte_Order._default.ltedef () T@U)
(declare-fun |Byte__Order.__default.lte#requires| (T@U Int Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.ltedef0 () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.ltedef () T@U)
(declare-fun MoreFuel_Byte_Order._default.ltedef1 () T@U)
(declare-fun |Byte__Order.__default.ltedef#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.ltedef#requires| (T@U Int Int) Bool)
(declare-fun Byte__Order.__default.LargestLteDefn (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLteDefn#canCall| (T@U Int) Bool)
(declare-fun Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.IsSorted () T@U)
(declare-fun |Byte__Order.__default.LargestLteDefn#requires| (T@U T@U Int) Bool)
(declare-fun |Byte__Order.__default.lt#canCall| (Int Int) Bool)
(declare-fun Byte__Order.__default.lt (Int Int) Bool)
(declare-fun Byte__Order.__default.LargestLte (T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLte#canCall| (T@U Int) Bool)
(declare-fun StartFuel_Byte_Order._default.lte () T@U)
(declare-fun |Byte__Order.__default.LargestLte#requires| (T@U Int) Bool)
(declare-fun Byte__Order.__default.LargestLt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.LargestLt#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Byte__Order.__default.IndexOfFirstGte (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.IndexOfFirstGte#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U Int Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U Int Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U Int Int Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U Int Int) Bool)
(declare-fun Byte__Order.__default.IndexOfFirstGt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.IndexOfFirstGt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U Int Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U Int Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U Int Int Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.NotMinimum (T@U Int) Bool)
(declare-fun |Byte__Order.__default.NotMinimum#canCall| (Int) Bool)
(declare-fun |Byte__Order.__default.NotMinimum#requires| (T@U Int) Bool)
(declare-fun Byte__Order.__default.MapPivotedUnion (T@U T@U Int T@U) T@U)
(declare-fun |Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U Int T@U) Bool)
(declare-fun |lambda#295| (T@U Int) T@U)
(declare-fun |lambda#297| (T@U T@U Int) T@U)
(declare-fun Byte__Order.__default.SetSuccessor (T@U Int) T@U)
(declare-fun |Byte__Order.__default.SetSuccessor#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.SetSuccessor#requires| (T@U Int) Bool)
(declare-fun |$let#16_next| (T@U Int) Int)
(declare-fun |$let#16$canCall| (T@U Int) Bool)
(declare-fun Byte__Order.__default.MapSuccessor (T@U T@U Int) T@U)
(declare-fun |Byte__Order.__default.MapSuccessor#canCall| (T@U T@U Int) Bool)
(declare-fun |Byte__Order.__default.MapSuccessor#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.SeqSuccessor (T@U Int) T@U)
(declare-fun |Byte__Order.__default.SeqSuccessor#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.SeqSuccessor#requires| (T@U Int) Bool)
(declare-fun |lambda#307| (T@U T@U) T@U)
(declare-fun Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.Unzip () T@U)
(declare-fun |Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Byte__Order.__default.minimum (T@U T@U) Int)
(declare-fun |Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#19_a| (T@U) Int)
(declare-fun |$let#19$canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.minimum () T@U)
(declare-fun Byte__Order.__default.maximum (T@U T@U) Int)
(declare-fun |Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#22_a| (T@U) Int)
(declare-fun |$let#22$canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.maximum () T@U)
(declare-fun |Byte__Order.__default.lt#requires| (Int Int) Bool)
(declare-fun Byte__Order.__default.Min (Int Int) Int)
(declare-fun |Byte__Order.__default.Min#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.Min#requires| (Int Int) Bool)
(declare-fun Byte__Order.__default.Max (Int Int) Int)
(declare-fun |Byte__Order.__default.Max#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.Max#requires| (Int Int) Bool)
(declare-fun |Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.BiggestInSet (Int T@U) Bool)
(declare-fun |Byte__Order.__default.BiggestInSet#canCall| (Int T@U) Bool)
(declare-fun |Byte__Order.__default.BiggestInSet#requires| (Int T@U) Bool)
(declare-fun Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#25_e| (T@U) Int)
(declare-fun |$let#25$canCall| (T@U) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Lexicographic__Byte__Order.__default () T@U)
(declare-fun Lexicographic__Byte__Order.__default.SomeElement () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun Lexicographic__Byte__Order.__default.lte (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.ltedef (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lte#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.ltedef#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.ltedef#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsSmallestElement (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSmallestElement#requires| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.lt (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.NotMinimum (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.NotMinimum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.GetSmallestElement () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| () Bool)
(declare-fun |$let#28$canCall| () Bool)
(declare-fun |$let#28_b| () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| () Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLteDefn (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLteDefn#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLte (T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLte#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.IndexOfFirstGte (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U T@U Int Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U T@U Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U T@U Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U T@U Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IndexOfFirstGt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U T@U Int Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.NotMinimum#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.MapPivotedUnion (T@U T@U T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#311| (T@U T@U) T@U)
(declare-fun |lambda#313| (T@U T@U) T@U)
(declare-fun Lexicographic__Byte__Order.__default.SetSuccessor (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetSuccessor#requires| (T@U T@U) Bool)
(declare-fun |$let#31_next| (T@U T@U) T@U)
(declare-fun |$let#31$canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.MapSuccessor (T@U T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.MapSuccessor#canCall| (T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.MapSuccessor#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SeqSuccessor (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SeqSuccessor#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Lexicographic__Byte__Order.__default.minimum (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#34_a| (T@U) T@U)
(declare-fun |$let#34$canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun Lexicographic__Byte__Order.__default.maximum (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#37_a| (T@U) T@U)
(declare-fun |$let#37$canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.lt#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.Min (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.Min#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.Min#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.Max (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.Max#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.Max#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.BiggestInSet (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.BiggestInSet#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#40_e| (T@U) T@U)
(declare-fun |$let#40$canCall| (T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.Element_q (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.e (T@U) T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.lt (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| () Bool)
(declare-fun |$let#43$canCall| () Bool)
(declare-fun |$let#43_b| () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| () Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SomeElement () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.ToElements (T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| (T@U) Bool)
(declare-fun |lambda#327| (T@U) T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.lte (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.ltedef (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.Element#Equal| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U T@U Int Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U T@U Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U T@U Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U T@U Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U T@U Int Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion (T@U T@U T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#337| (T@U T@U) T@U)
(declare-fun |lambda#339| (T@U T@U) T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| (T@U T@U) Bool)
(declare-fun |$let#46_next| (T@U T@U) T@U)
(declare-fun |$let#46$canCall| (T@U T@U) Bool)
(declare-fun |$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor (T@U T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| (T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.minimum (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#49_a| (T@U) T@U)
(declare-fun |$let#49$canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.maximum (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#52_a| (T@U) T@U)
(declare-fun |$let#52$canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.Min (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.Max (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#55_e| (T@U) T@U)
(declare-fun |$let#55$canCall| (T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun Tclass.BoundedPivotsLib.__default () T@U)
(declare-fun BoundedPivotsLib.__default.ElementIsKey (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementIsKey#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementIsKey#requires| (T@U) Bool)
(declare-fun |KeyType.__default.MaxLen#canCall| () Bool)
(declare-fun BoundedPivotsLib.__default.ElementsAreKeys (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementsAreKeys#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementsAreKeys#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.KeyToElement (T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.KeyToElement#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.KeyToElement#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.KeysToElements (T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.KeysToElements#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.KeysToElements#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.WFPivots (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.WFPivots#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.WFPivots#requires| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.NumBuckets#canCall| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.NumBuckets (T@U) Int)
(declare-fun BoundedPivotsLib.__default.ContainsAllKeys (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsAllKeys#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsAllKeys#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.ContainsRange (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsRange#canCall| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsRange#requires| (T@U T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedKey (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKey#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKey#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedKeySeq (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKeySeq#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKeySeq#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedSortedKeySeq (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.ValidLeftCutOffKey (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.NumBuckets#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.PivotSize (T@U) Int)
(declare-fun |BoundedPivotsLib.__default.PivotSize#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotSize#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.InBetween (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InBetween#canCall| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InBetween#requires| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.Route#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.InitPivotTable () T@U)
(declare-fun |BoundedPivotsLib.__default.InitPivotTable#requires| () Bool)
(declare-fun BoundedPivotsLib.__default.GetKey (T@U Int) T@U)
(declare-fun |BoundedPivotsLib.__default.GetKey#canCall| (T@U Int) Bool)
(declare-fun |BoundedPivotsLib.__default.GetKey#requires| (T@U Int) Bool)
(declare-fun BoundedPivotsLib.__default.PivotInsertable (T@U Int T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotInsertable#canCall| (T@U Int T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotInsertable#requires| (T@U Int T@U) Bool)
(declare-fun BoundedPivotsLib.__default.InsertPivot (T@U Int T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.InsertPivot#canCall| (T@U Int T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InsertPivot#requires| (T@U Int T@U) Bool)
(declare-fun StartFuel_Sequences._default.insert () T@U)
(declare-fun BoundedPivotsLib.__default.CutoffForLeft (T@U T@U T@U) Int)
(declare-fun |BoundedPivotsLib.__default.CutoffForLeft#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.CutoffForLeft#requires| (T@U T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.SplitLeft (T@U T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.SplitLeft#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.SplitLeft#requires| (T@U T@U) Bool)
(declare-fun StartFuel_BoundedPivotsLib._default.CutoffForLeft () T@U)
(declare-fun BoundedPivotsLib.__default.CutoffForRight (T@U T@U T@U) Int)
(declare-fun |BoundedPivotsLib.__default.CutoffForRight#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.CutoffForRight#requires| (T@U T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.SplitRight (T@U T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.SplitRight#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.SplitRight#requires| (T@U T@U) Bool)
(declare-fun StartFuel_BoundedPivotsLib._default.CutoffForRight () T@U)
(declare-fun |BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| (T@U Int) Bool)
(declare-fun |lambda#363| (T@U T@U T@U Int) T@U)
(declare-fun |#DomainMod.Domain.EmptyDomain| () T@U)
(declare-fun DomainMod.Domain.EmptyDomain_q (T@U) Bool)
(declare-fun |#DomainMod.Domain.Domain| (T@U T@U) T@U)
(declare-fun DomainMod.Domain.Domain_q (T@U) Bool)
(declare-fun DomainMod.Domain.start (T@U) T@U)
(declare-fun DomainMod.Domain.end (T@U) T@U)
(declare-fun DomainMod.Domain.SaneKeys (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.SaneKeys#canCall| (T@U) Bool)
(declare-fun |DomainMod.Domain.SaneKeys#requires| (T@U T@U) Bool)
(declare-fun DomainMod.Domain.WF (T@U) Bool)
(declare-fun |DomainMod.Domain.WF#canCall| (T@U) Bool)
(declare-fun |DomainMod.Domain.WF#requires| (T@U) Bool)
(declare-fun StartFuel_DomainMod.Domain.SaneKeys () T@U)
(declare-fun DomainMod.Domain.Contains (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.Contains#canCall| (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.Contains#requires| (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.KeySet#requires| (T@U) Bool)
(declare-fun |lambda#365| (T@U T@U) T@U)
(declare-fun Tclass.DomainMod.__default () T@U)
(declare-fun |DomainMod.__default.TotalDomain#requires| () Bool)
(declare-fun |#SplitRequestMod.SplitRequest.SplitLeaf| (Int T@U) T@U)
(declare-fun SplitRequestMod.SplitRequest.splitKey (T@U) T@U)
(declare-fun |#SplitRequestMod.SplitRequest.SplitIndex| (Int Int) T@U)
(declare-fun SplitRequestMod.SplitRequest.childPivotIdx (T@U) Int)
(declare-fun |$IsA#SplitRequestMod.SplitRequest| (T@U) Bool)
(declare-fun |SplitRequestMod.SplitRequest#Equal| (T@U T@U) Bool)
(declare-fun Tclass.SplitRequestMod.__default () T@U)
(declare-fun |#PivotBetree.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun |#PivotBetree.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun PivotBetree.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#PivotBetree.TransitionLabel| (T@U) Bool)
(declare-fun |PivotBetree.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun |#PivotBetree.BetreeNode.Nil| () T@U)
(declare-fun |#PivotBetree.BetreeNode.BetreeNode| (T@U T@U T@U) T@U)
(declare-fun |$IsA#PivotBetree.BetreeNode| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.LocalStructure (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LocalStructure#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LocalStructure#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.ValidChildIndex (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.ValidChildIndex#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.ValidChildIndex#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.LinkedChildren (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LinkedChildren#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LinkedChildren#requires| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.WF#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.WFChildren#canCall| (T@U) Bool)
(declare-fun PivotBetree.__default.WFChildren (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.PushBufferStack (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.IsLeaf (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsLeaf#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsLeaf#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.IsIndex (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsIndex#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsIndex#requires| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.CanSplitParent#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.CanSplitParent#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.SplitKey (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitKey#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitKey#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#canCall| (T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.replace1with2 () T@U)
(declare-fun PivotBetree.BetreeNode.SplitParent (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParent#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitParent#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.Promote (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Promote#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Promote#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.EmptyRoot#canCall| (T@U) Bool)
(declare-fun PivotBetree.__default.EmptyRoot (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.MyDomain#requires| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.DomainRoutedToChild#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.CanFlush (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.CanFlush#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.CanFlush#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.Flush (T@U Int) T@U)
(declare-fun |PivotBetree.BetreeNode.Flush#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.Flush#requires| (T@U Int) Bool)
(declare-fun |Buffers.__default.AllKeys#canCall| () Bool)
(declare-fun PivotBetree.BetreeNode.Buffers (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Buffers#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Buffers#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.Children (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Children#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Children#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.KeyInDomain (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeyInDomain#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeyInDomain#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeySet#requires| (T@U) Bool)
(declare-fun |lambda#367| (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Child#requires| (T@U T@U) Bool)
(declare-fun |#PivotBetree.QueryReceiptLine.QueryReceiptLine| (T@U T@U) T@U)
(declare-fun |$IsA#PivotBetree.QueryReceiptLine| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine#Equal| (T@U T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine.WF#requires| (T@U) Bool)
(declare-fun |#PivotBetree.QueryReceipt.QueryReceipt| (T@U T@U T@U) T@U)
(declare-fun |$IsA#PivotBetree.QueryReceipt| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Structure (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Structure#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Structure#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.AllLinesWF (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.AllLinesWF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.AllLinesWF#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.ChildAt (T@U Int) T@U)
(declare-fun |PivotBetree.QueryReceipt.ChildAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ChildLinkedAt (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildLinkedAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ResultAt (T@U Int) T@U)
(declare-fun |PivotBetree.QueryReceipt.ResultAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ResultLinkedAt (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultLinkedAt#requires| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.Valid#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Valid#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Result (T@U) T@U)
(declare-fun |PivotBetree.QueryReceipt.Result#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Result#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.ValidFor (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.ValidFor#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.ValidFor#requires| (T@U T@U T@U) Bool)
(declare-fun |#PivotBetree.Variables.Variables| (T@U T@U) T@U)
(declare-fun |$IsA#PivotBetree.Variables| (T@U) Bool)
(declare-fun |PivotBetree.Variables#Equal| (T@U T@U) Bool)
(declare-fun |PivotBetree.Variables.WF#requires| (T@U) Bool)
(declare-fun |#PivotBetree.Path.Path| (T@U T@U Int) T@U)
(declare-fun |$IsA#PivotBetree.Path| (T@U) Bool)
(declare-fun |PivotBetree.Path#Equal| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Subpath#requires| (T@U) Bool)
(declare-fun |PivotBetree.Path.Valid#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Path.Valid#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Target#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ChildrenHaveMatchingDomains (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ChildrenHaveMatchingDomains#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ReplacedChildren (T@U T@U T@U) T@U)
(declare-fun |PivotBetree.Path.ReplacedChildren#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ValidReplacement (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ReplacedChildren#requires| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Substitute#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.Substitute (T@U T@U T@U) T@U)
(declare-fun |PivotBetree.Path.ValidReplacement#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ValidReplacement#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Substitute#requires| (T@U T@U T@U) Bool)
(declare-fun |#PivotBetree.Step.QueryStep| (T@U) T@U)
(declare-fun |#PivotBetree.Step.PutStep| () T@U)
(declare-fun |#PivotBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |#PivotBetree.Step.FreezeAsStep| () T@U)
(declare-fun |#PivotBetree.Step.InternalGrowStep| () T@U)
(declare-fun |#PivotBetree.Step.InternalSplitStep| (T@U T@U) T@U)
(declare-fun |#PivotBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |#PivotBetree.Step.InternalFlushStep| (T@U Int) T@U)
(declare-fun |#PivotBetree.Step.InternalCompactStep| (T@U T@U) T@U)
(declare-fun |#PivotBetree.Step.InternalNoOpStep| () T@U)
(declare-fun PivotBetree.Step.InternalNoOpStep_q (T@U) Bool)
(declare-fun |$IsA#PivotBetree.Step| (T@U) Bool)
(declare-fun |PivotBetree.Step#Equal| (T@U T@U) Bool)
(declare-fun |PivotBetree.Step.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Step.WF#requires| (T@U) Bool)
(declare-fun |PivotBetree.Step.SplitKey#requires| (T@U) Bool)
(declare-fun Tclass.PivotBetree.__default () T@U)
(declare-fun |PivotBetree.__default.WFChildren#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.EmptyRoot#requires| (T@U) Bool)
(declare-fun PivotBetree.__default.EmptyImage () T@U)
(declare-fun |PivotBetree.__default.EmptyImage#requires| () Bool)
(declare-fun PivotBetree.__default.PushMemtable (T@U T@U) T@U)
(declare-fun |PivotBetree.__default.PushMemtable#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.PushMemtable#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.Query (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Query#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Query#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.Put (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalFlushMemtable (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlushMemtable#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlushMemtable#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalGrow (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalGrow#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalGrow#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalSplit (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalSplit#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalSplit#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalFlush (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlush#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlush#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.CompactedNode (T@U T@U) T@U)
(declare-fun |PivotBetree.__default.CompactedNode#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.CompactedNode#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalCompact (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalCompact#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalCompact#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalNoOp (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalNoOp#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalNoOp#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.Init (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Init#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.NextStep (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.NextStep#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.NextStep#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.Next (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.endLsn (T@U) Int)
(declare-fun PagedBetree.TransitionLabel.key (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.value (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.puts (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun PagedBetree.TransitionLabel.stampedBetree (T@U) T@U)
(declare-fun PagedBetree.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#PagedBetree.TransitionLabel| (T@U) Bool)
(declare-fun |PagedBetree.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.ChildMap.ChildMap_q (T@U) Bool)
(declare-fun PagedBetree.ChildMap.mapp (T@U) T@U)
(declare-fun |$IsA#PagedBetree.ChildMap| (T@U) Bool)
(declare-fun |PagedBetree.ChildMap#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.ChildMap.WF (T@U T@U) Bool)
(declare-fun |PagedBetree.ChildMap.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.ChildMap.WF#requires| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.WF#canCall| (T@U) Bool)
(declare-fun PagedBetree.BetreeNode.Nil_q (T@U) Bool)
(declare-fun PagedBetree.BetreeNode.BetreeNode_q (T@U) Bool)
(declare-fun PagedBetree.BetreeNode.buffers (T@U) T@U)
(declare-fun PagedBetree.BetreeNode.children (T@U) T@U)
(declare-fun |$IsA#PagedBetree.BetreeNode| (T@U) Bool)
(declare-fun |PagedBetree.BetreeNode#Equal| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.WF#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.Child (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Child#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Child#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.PushMemtable (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.PushMemtable#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.PushMemtable#requires| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Promote#canCall| (T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.Promote (T@U) T@U)
(declare-fun PagedBetree.BetreeNode.PushBufferStack (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.BetreeNode.FilterBuffersAndChildren (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.FilterBuffersAndChildren#requires| (T@U T@U) Bool)
(declare-fun |lambda#370| (T@U T@U T@U) T@U)
(declare-fun PagedBetree.BetreeNode.Split (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Split#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Split#requires| (T@U T@U T@U) Bool)
(declare-fun |lambda#376| (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Promote#requires| (T@U) Bool)
(declare-fun |PagedBetree.__default.EmptyRoot#canCall| () Bool)
(declare-fun PagedBetree.__default.EmptyRoot () T@U)
(declare-fun PagedBetree.BetreeNode.Flush (T@U T@U) T@U)
(declare-fun |PagedBetree.BetreeNode.Flush#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.BetreeNode.Flush#requires| (T@U T@U) Bool)
(declare-fun |lambda#382| (T@U T@U T@U T@U) T@U)
(declare-fun PagedBetree.QueryReceiptLine.QueryReceiptLine_q (T@U) Bool)
(declare-fun PagedBetree.QueryReceiptLine.node (T@U) T@U)
(declare-fun PagedBetree.QueryReceiptLine.result (T@U) T@U)
(declare-fun |$IsA#PagedBetree.QueryReceiptLine| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.QueryReceiptLine.WF (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceiptLine.WF#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.QueryReceipt_q (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.key (T@U) T@U)
(declare-fun PagedBetree.QueryReceipt.root (T@U) T@U)
(declare-fun PagedBetree.QueryReceipt.lines (T@U) T@U)
(declare-fun |$IsA#PagedBetree.QueryReceipt| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.Structure (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Structure#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Structure#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.AllLinesWF (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.AllLinesWF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.AllLinesWF#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.ChildAt (T@U Int) T@U)
(declare-fun |PagedBetree.QueryReceipt.ChildAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ChildLinkedAt (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ChildLinkedAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ResultAt (T@U Int) T@U)
(declare-fun |PagedBetree.QueryReceipt.ResultAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.ResultLinkedAt (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PagedBetree.QueryReceipt.ResultLinkedAt#requires| (T@U Int) Bool)
(declare-fun PagedBetree.QueryReceipt.Valid (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Valid#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Valid#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.Result (T@U) T@U)
(declare-fun |PagedBetree.QueryReceipt.Result#canCall| (T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.Result#requires| (T@U) Bool)
(declare-fun PagedBetree.QueryReceipt.ValidFor (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.ValidFor#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.QueryReceipt.ValidFor#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.Variables.Variables_q (T@U) Bool)
(declare-fun PagedBetree.Variables.memtable (T@U) T@U)
(declare-fun PagedBetree.Variables.root (T@U) T@U)
(declare-fun |$IsA#PagedBetree.Variables| (T@U) Bool)
(declare-fun |PagedBetree.Variables#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.Variables.WF (T@U) Bool)
(declare-fun |PagedBetree.Variables.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Variables.WF#requires| (T@U) Bool)
(declare-fun PagedBetree.Path.Path_q (T@U) Bool)
(declare-fun PagedBetree.Path.node (T@U) T@U)
(declare-fun PagedBetree.Path.key (T@U) T@U)
(declare-fun PagedBetree.Path.routing (T@U) T@U)
(declare-fun |$IsA#PagedBetree.Path| (T@U) Bool)
(declare-fun |PagedBetree.Path#Equal| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.Subpath (T@U) T@U)
(declare-fun |PagedBetree.Path.Subpath#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Subpath#requires| (T@U) Bool)
(declare-fun PagedBetree.Path.CommonChildren (T@U) Bool)
(declare-fun |PagedBetree.Path.CommonChildren#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.CommonChildren#requires| (T@U) Bool)
(declare-fun PagedBetree.Path.Valid (T@U T@U) Bool)
(declare-fun |PagedBetree.Path.Valid#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Valid#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.Target (T@U T@U) T@U)
(declare-fun |PagedBetree.Path.Target#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Path.Target#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.ReplacedChildren (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.Path.ReplacedChildren#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.Path.ReplacedChildren#requires| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.Path.Substitute#canCall| (T@U T@U) Bool)
(declare-fun PagedBetree.Path.Substitute (T@U T@U T@U) T@U)
(declare-fun |lambda#388| (T@U T@U T@U) T@U)
(declare-fun |PagedBetree.Path.Substitute#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.Step.QueryStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.receipt (T@U) T@U)
(declare-fun PagedBetree.Step.PutStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.QueryEndLsnStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.FreezeAsStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.InternalGrowStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.InternalSplitStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.path (T@U) T@U)
(declare-fun PagedBetree.Step.leftKeys (T@U) T@U)
(declare-fun PagedBetree.Step.rightKeys (T@U) T@U)
(declare-fun PagedBetree.Step.InternalFlushMemtableStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.InternalFlushStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.downKeys (T@U) T@U)
(declare-fun PagedBetree.Step.InternalCompactStep_q (T@U) Bool)
(declare-fun PagedBetree.Step.compactedBuffers (T@U) T@U)
(declare-fun PagedBetree.Step.InternalNoOpStep_q (T@U) Bool)
(declare-fun |$IsA#PagedBetree.Step| (T@U) Bool)
(declare-fun |PagedBetree.Step#Equal| (T@U T@U) Bool)
(declare-fun |PagedBetree.Step.WF#canCall| (T@U) Bool)
(declare-fun |PagedBetree.Step.WF#requires| (T@U) Bool)
(declare-fun Tclass.PagedBetree.__default () T@U)
(declare-fun |PagedBetree.__default.EmptyImage#requires| () Bool)
(declare-fun PagedBetree.__default.ConstantChildMap (T@U) T@U)
(declare-fun |PagedBetree.__default.ConstantChildMap#canCall| (T@U) Bool)
(declare-fun |PagedBetree.__default.ConstantChildMap#requires| (T@U) Bool)
(declare-fun PagedBetree.__default.EmptyChildMap () T@U)
(declare-fun |PagedBetree.__default.EmptyChildMap#requires| () Bool)
(declare-fun |PagedBetree.__default.EmptyRoot#requires| () Bool)
(declare-fun PagedBetree.__default.Query (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Query#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Query#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.Put (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalFlushMemtable (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlushMemtable#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlushMemtable#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalGrow (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalGrow#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalGrow#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalSplit (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalSplit#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalSplit#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalFlush (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlush#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalFlush#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.CompactedNode (T@U T@U) T@U)
(declare-fun |PagedBetree.__default.CompactedNode#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.CompactedNode#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalCompact (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalCompact#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalCompact#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.InternalNoOp (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalNoOp#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.InternalNoOp#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.Init (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Init#requires| (T@U T@U) Bool)
(declare-fun PagedBetree.__default.NextStep (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.NextStep#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.NextStep#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PagedBetree.__default.Next (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |PagedBetree.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun |#AbstractMap.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun Tclass.AbstractMap.TransitionLabel () T@U)
(declare-fun AbstractMap.TransitionLabel.endLsn (T@U) Int)
(declare-fun AbstractMap.TransitionLabel.key (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.value (T@U) T@U)
(declare-fun |#AbstractMap.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.puts (T@U) T@U)
(declare-fun |#AbstractMap.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun AbstractMap.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun |#AbstractMap.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun AbstractMap.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun AbstractMap.TransitionLabel.stampedMap (T@U) T@U)
(declare-fun |#AbstractMap.TransitionLabel.InternalLabel| () T@U)
(declare-fun AbstractMap.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#AbstractMap.TransitionLabel| (T@U) Bool)
(declare-fun |AbstractMap.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun |#AbstractMap.Variables.Variables| (T@U) T@U)
(declare-fun AbstractMap.Variables.Variables_q (T@U) Bool)
(declare-fun Tclass.AbstractMap.Variables () T@U)
(declare-fun AbstractMap.Variables.stampedMap (T@U) T@U)
(declare-fun |$IsA#AbstractMap.Variables| (T@U) Bool)
(declare-fun |AbstractMap.Variables#Equal| (T@U T@U) Bool)
(declare-fun Tclass.AbstractMap.__default () T@U)
(declare-fun AbstractMap.__default.Query (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Query#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Query#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.Put (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun AbstractMap.__default.Init (T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Init#requires| (T@U T@U) Bool)
(declare-fun AbstractMap.__default.Next (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |AbstractMap.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun Tclass.PagedBetreeRefinement.__default () T@U)
(declare-fun PagedBetreeRefinement.__default.BuildQueryReceipt (T@U T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.BuildQueryReceipt#requires| (T@U T@U T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.INodeAt (T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.INodeAt#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.INodeAt#requires| (T@U T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.INode (T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.INode#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.INode#requires| (T@U T@U) Bool)
(declare-fun |lambda#398| (T@U) T@U)
(declare-fun PagedBetreeRefinement.__default.IStampedBetree (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.IStampedBetree#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.IStampedBetree#requires| (T@U) Bool)
(declare-fun StartFuel_PagedBetreeRefinement._default.INode () T@U)
(declare-fun PagedBetreeRefinement.__default.ILbl (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.ILbl#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.ILbl#requires| (T@U) Bool)
(declare-fun |StampedMod.__default.Empty#canCall| () Bool)
(declare-fun PagedBetreeRefinement.__default.I (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.I#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.I#requires| (T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.MapApply (T@U T@U T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.MapApply#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.MapApply#requires| (T@U T@U T@U) Bool)
(declare-fun |lambda#402| (T@U T@U) T@U)
(declare-fun PagedBetreeRefinement.__default.ReceiptDropFirst (T@U) T@U)
(declare-fun |PagedBetreeRefinement.__default.ReceiptDropFirst#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.ReceiptDropFirst#requires| (T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.EquivalentBufferCompaction (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall| (T@U T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires| (T@U T@U) Bool)
(declare-fun PagedBetreeRefinement.__default.Inv (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.Inv#canCall| (T@U) Bool)
(declare-fun |PagedBetreeRefinement.__default.Inv#requires| (T@U) Bool)
(declare-fun MapType6Select (T@U T@U T@U) T@U)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun MapType6Type (T@T T@T) T@T)
(declare-fun MapType6TypeInv0 (T@T) T@T)
(declare-fun MapType6TypeInv1 (T@T) T@T)
(declare-fun MapType6Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#8| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#9| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#10| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#11| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#12| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#13| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#14| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#15| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#16| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#17| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#18| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#19| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#20| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#21| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#22| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#23| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#24| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#25| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#26| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#27| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#28| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#29| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#30| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#41| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#42| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#53| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#54| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#55| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#58| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#59| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#61| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#62| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#63| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#64| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#65| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#66| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#67| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#68| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#69| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#70| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#71| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#72| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#73| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#74| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#75| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#76| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#77| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#78| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#79| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#80| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#81| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#82| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#83| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#84| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#85| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#86| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#87| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#88| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#89| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#90| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#91| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#92| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#93| (T@U T@U T@U) T@U)
(declare-fun |lambda#94| (T@U) T@U)
(declare-fun |lambda#97| (T@U T@U T@U) T@U)
(declare-fun |lambda#98| (T@U T@U T@U) T@U)
(declare-fun |lambda#102| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#103| (T@U T@U T@U) T@U)
(declare-fun |lambda#107| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#108| (T@U T@U) T@U)
(declare-fun |lambda#112| (T@U T@U T@U) T@U)
(declare-fun |lambda#113| (T@U T@U T@U) T@U)
(declare-fun |lambda#117| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#118| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#119| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#120| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#121| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#122| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#123| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#124| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#125| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#126| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#127| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#128| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#129| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#130| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#131| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#132| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#133| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#134| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#135| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#136| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#137| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#138| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#163| (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (= (Ctor rmodeType) 3)) (= (Ctor stringType) 4)) (= (Ctor regexType) 5)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0)
 :qid |typeInv:U_2_int|
 :pattern ( (int_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
 :qid |cast:U_2_int|
 :pattern ( (U_2_int x))
))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType)
 :qid |funType:int_2_U|
 :pattern ( (int_2_U arg0@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :qid |typeInv:U_2_real|
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))
 :qid |cast:U_2_real|
 :pattern ( (U_2_real x@@0))
))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType)
 :qid |funType:real_2_U|
 :pattern ( (real_2_U arg0@@2))
))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
 :qid |typeInv:U_2_bool|
 :pattern ( (bool_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))
 :qid |cast:U_2_bool|
 :pattern ( (U_2_bool x@@1))
))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType)
 :qid |funType:bool_2_U|
 :pattern ( (bool_2_U arg0@@4))
))) (forall ((arg0@@5 RoundingMode) ) (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
 :qid |typeInv:U_2_rmode|
 :pattern ( (rmode_2_U arg0@@5))
))) (forall ((x@@2 T@U) ) (!  (=> (= (type x@@2) rmodeType) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
 :qid |cast:U_2_rmode|
 :pattern ( (U_2_rmode x@@2))
))) (forall ((arg0@@6 RoundingMode) ) (! (= (type (rmode_2_U arg0@@6)) rmodeType)
 :qid |funType:rmode_2_U|
 :pattern ( (rmode_2_U arg0@@6))
))) (forall ((arg0@@7 String) ) (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
 :qid |typeInv:U_2_string|
 :pattern ( (string_2_U arg0@@7))
))) (forall ((x@@3 T@U) ) (!  (=> (= (type x@@3) stringType) (= (string_2_U (U_2_string x@@3)) x@@3))
 :qid |cast:U_2_string|
 :pattern ( (U_2_string x@@3))
))) (forall ((arg0@@8 String) ) (! (= (type (string_2_U arg0@@8)) stringType)
 :qid |funType:string_2_U|
 :pattern ( (string_2_U arg0@@8))
))) (forall ((arg0@@9 (RegEx String)) ) (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
 :qid |typeInv:U_2_regex|
 :pattern ( (regex_2_U arg0@@9))
))) (forall ((x@@4 T@U) ) (!  (=> (= (type x@@4) regexType) (= (regex_2_U (U_2_regex x@@4)) x@@4))
 :qid |cast:U_2_regex|
 :pattern ( (U_2_regex x@@4))
))) (forall ((arg0@@10 (RegEx String)) ) (! (= (type (regex_2_U arg0@@10)) regexType)
 :qid |funType:regex_2_U|
 :pattern ( (regex_2_U arg0@@10))
))))
(assert (forall ((x@@5 T@U) ) (! (UOrdering2 x@@5 x@@5)
 :qid |bg:subtype-refl|
 :no-pattern (U_2_int x@@5)
 :no-pattern (U_2_bool x@@5)
)))
(assert (forall ((x@@6 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@6)))
 (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@6 y) (UOrdering2 y z))) (UOrdering2 x@@6 z)))
 :qid |bg:subtype-trans|
 :pattern ( (UOrdering2 x@@6 y) (UOrdering2 y z))
)))
(assert (forall ((x@@7 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@7)))
 (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)) (= x@@7 y@@0))))
 :qid |bg:subtype-antisymm|
 :pattern ( (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 6) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TReal) TyType)) (= (type TORDINAL) TyType)) (= (Ctor TyTagType) 7)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagORDINAL) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 8)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@11 T@T) ) (! (= (Ctor (FieldType arg0@@11)) 9)
 :qid |ctor:FieldType|
))) (forall ((arg0@@12 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@12)) arg0@@12)
 :qid |typeInv:FieldTypeInv0|
 :pattern ( (FieldType arg0@@12))
))) (= (type alloc) (FieldType boolType))) (= (Ctor NameFamilyType) 10)) (= (type allocName) NameFamilyType)) (= (type Tagclass._System.nat) TyTagType)) (= (type class._System.object?) ClassNameType)) (= (type Tagclass._System.object?) TyTagType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array?) ClassNameType)) (= (type Tagclass._System.array?) TyTagType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type Tagclass._System.___hPartialFunc1) TyTagType)) (= (type Tagclass._System.___hTotalFunc1) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hPartialFunc0) TyTagType)) (= (type Tagclass._System.___hTotalFunc0) TyTagType)) (= (type class._System.__default) ClassNameType)) (= (type Tagclass._System.__default) TyTagType)) (= (type Tagclass._System.___hFunc2) TyTagType)) (= (type Tagclass._System.___hPartialFunc2) TyTagType)) (= (type Tagclass._System.___hTotalFunc2) TyTagType)) (= (Ctor DtCtorIdType) 11)) (= (type |##_System._tuple#2._#Make2|) DtCtorIdType)) (= (type Tagclass._System.Tuple2) TyTagType)) (= (type class._System.Tuple2) ClassNameType)) (= (type Tagclass._System.___hFunc4) TyTagType)) (= (type Tagclass._System.___hPartialFunc4) TyTagType)) (= (type Tagclass._System.___hTotalFunc4) TyTagType)) (= (type Tagclass._System.___hFunc3) TyTagType)) (= (type Tagclass._System.___hPartialFunc3) TyTagType)) (= (type Tagclass._System.___hTotalFunc3) TyTagType)) (= (type Tagclass._System.___hFunc2OSO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2OSO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2OSO) TyTagType)) (= (type Tagclass._System.___hFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hPartialFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hTotalFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hFunc1OS) TyTagType)) (= (type Tagclass._System.___hPartialFunc1OS) TyTagType)) (= (type Tagclass._System.___hTotalFunc1OS) TyTagType)) (= (type Tagclass._System.___hFunc0L) TyTagType)) (= (type Tagclass._System.___hPartialFunc0L) TyTagType)) (= (type Tagclass._System.___hTotalFunc0L) TyTagType)) (= (type Tagclass._System.___hFunc2LOO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2LOO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2LOO) TyTagType)) (= (type |##_System._tuple#0._#Make0|) DtCtorIdType)) (= (type Tagclass._System.Tuple0) TyTagType)) (= (type class._System.Tuple0) ClassNameType)) (= (type Tagclass._System.___hFunc1OL) TyTagType)) (= (type Tagclass._System.___hPartialFunc1OL) TyTagType)) (= (type Tagclass._System.___hTotalFunc1OL) TyTagType)) (= (type Tagclass._System.___hFunc1LO) TyTagType)) (= (type Tagclass._System.___hPartialFunc1LO) TyTagType)) (= (type Tagclass._System.___hTotalFunc1LO) TyTagType)) (= (type |##_System._tuple#2OLL._#Make2|) DtCtorIdType)) (= (type Tagclass._System.Tuple2OLL) TyTagType)) (= (type class._System.Tuple2OLL) ClassNameType)) (= (type Tagclass._System.___hFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hPartialFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hTotalFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hFunc2SSO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2SSO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2SSO) TyTagType)) (= (type Tagclass._System.___hFunc2LLO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2LLO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2LLO) TyTagType)) (= (type Tagclass._System.___hFunc1SS) TyTagType)) (= (type Tagclass._System.___hPartialFunc1SS) TyTagType)) (= (type Tagclass._System.___hTotalFunc1SS) TyTagType)) (= (type Tagclass._System.___hFunc1LL) TyTagType)) (= (type Tagclass._System.___hPartialFunc1LL) TyTagType)) (= (type Tagclass._System.___hTotalFunc1LL) TyTagType)) (= (type class.PivotBetreeRefinement.__default) ClassNameType)) (= (type Tagclass.PivotBetreeRefinement.__default) TyTagType)) (= (type Tagclass.PivotBetree.BetreeNode) TyTagType)) (= (type Tagclass.PagedBetree.ChildMap) TyTagType)) (= (type Tagclass.KeyType.Key) TyTagType)) (= (type Tagclass.PagedBetree.BetreeNode) TyTagType)) (= (type Tagclass.StampedMod.Stamped) TyTagType)) (= (type Tagclass.PivotBetree.TransitionLabel) TyTagType)) (= (type Tagclass.PagedBetree.TransitionLabel) TyTagType)) (= (type Tagclass.MsgHistoryMod.MsgHistory) TyTagType)) (= (type Tagclass.ValueType.Value) TyTagType)) (= (type Tagclass.NativeTypes.byte) TyTagType)) (= (type Tagclass.PivotBetree.Variables) TyTagType)) (= (type Tagclass.PagedBetree.Variables) TyTagType)) (= (type Tagclass.PivotBetree.Step) TyTagType)) (= (type Tagclass.PivotBetree.Path) TyTagType)) (= (type Tagclass.SplitRequestMod.SplitRequest) TyTagType)) (= (type Tagclass.Buffers.BufferStack) TyTagType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order.Element) TyTagType)) (= (type Tagclass.PagedBetree.Path) TyTagType)) (= (type Tagclass.PivotBetree.QueryReceiptLine) TyTagType)) (= (type Tagclass.PagedBetree.QueryReceiptLine) TyTagType)) (= (type Tagclass.PivotBetree.QueryReceipt) TyTagType)) (= (type Tagclass.PagedBetree.QueryReceipt) TyTagType)) (= (type Tagclass.DomainMod.Domain) TyTagType)) (= (type Tagclass.PagedBetree.Step) TyTagType)) (= (type Tagclass.MemtableMod.Memtable) TyTagType)) (= (type |##Options.Option.None|) DtCtorIdType)) (= (type Tagclass.Options.Option) TyTagType)) (= (type |##Options.Option.Some|) DtCtorIdType)) (= (type class.Options.Option) ClassNameType)) (= (type class.Options.__default) ClassNameType)) (= (type Tagclass.Options.__default) TyTagType)) (= (type Tagclass.NativeTypes.sbyte) TyTagType)) (= (type class.NativeTypes.sbyte) ClassNameType)) (= (type class.NativeTypes.byte) ClassNameType)) (= (type Tagclass.NativeTypes.int16) TyTagType)) (= (type class.NativeTypes.int16) ClassNameType)) (= (type Tagclass.NativeTypes.uint16) TyTagType)) (= (type class.NativeTypes.uint16) ClassNameType)) (= (type Tagclass.NativeTypes.int32) TyTagType)) (= (type class.NativeTypes.int32) ClassNameType)) (= (type Tagclass.NativeTypes.uint32) TyTagType)) (= (type class.NativeTypes.uint32) ClassNameType)) (= (type Tagclass.NativeTypes.int64) TyTagType)) (= (type class.NativeTypes.int64) ClassNameType)) (= (type Tagclass.NativeTypes.uint64) TyTagType)) (= (type class.NativeTypes.uint64) ClassNameType)) (= (type Tagclass.NativeTypes.nat8) TyTagType)) (= (type class.NativeTypes.nat8) ClassNameType)) (= (type Tagclass.NativeTypes.nat16) TyTagType)) (= (type class.NativeTypes.nat16) ClassNameType)) (= (type Tagclass.NativeTypes.nat32) TyTagType)) (= (type class.NativeTypes.nat32) ClassNameType)) (= (type Tagclass.NativeTypes.nat64) TyTagType)) (= (type class.NativeTypes.nat64) ClassNameType)) (= (type Tagclass.NativeTypes.uint128) TyTagType)) (= (type class.NativeTypes.uint128) ClassNameType)) (= (type class.NativeTypes.__default) ClassNameType)) (= (type Tagclass.NativeTypes.__default) TyTagType)) (= (type class.KeyType.__default) ClassNameType)) (= (type Tagclass.KeyType.__default) TyTagType)) (= (type class.ValueType.__default) ClassNameType)) (= (type Tagclass.ValueType.__default) TyTagType)) (= (type class.LinearMaybe.predefined) ClassNameType)) (= (type class.LinearMaybe.__default) ClassNameType)) (= (type Tagclass.LinearMaybe.__default) TyTagType)) (= (type class.LinearExtern.predefined) ClassNameType)) (= (type class.LinearExtern.__default) ClassNameType)) (= (type Tagclass.LinearExtern.__default) TyTagType)) (= (type |##ValueMessage.Delta.NoDelta|) DtCtorIdType)) (= (type Tagclass.ValueMessage.Delta) TyTagType)) (= (type class.ValueMessage.Delta) ClassNameType)) (= (type class.ValueMessage.__default) ClassNameType)) (= (type Tagclass.ValueMessage.__default) TyTagType)) (= (type Tagclass.ValueMessage.Message) TyTagType)) (= (type |##ValueMessage.Message.Define|) DtCtorIdType)) (= (type |##ValueMessage.Message.Update|) DtCtorIdType)) (= (type class.ValueMessage.Message) ClassNameType)) (= (type class.TotalKMMapMod.__default) ClassNameType)) (= (type Tagclass.TotalKMMapMod.__default) TyTagType)) (= (type Tagclass.TotalKMMapMod.TotalMap) TyTagType)) (= (type class.LSNMod.__default) ClassNameType)) (= (type Tagclass.LSNMod.__default) TyTagType)) (= (type |##StampedMod.Stamped.Stamped|) DtCtorIdType)) (= (type class.StampedMod.Stamped) ClassNameType)) (= (type class.StampedMod.__default) ClassNameType)) (= (type Tagclass.StampedMod.__default) TyTagType)) (= (type class.SequencesLite.__default) ClassNameType)) (= (type Tagclass.SequencesLite.__default) TyTagType)) (= (type class.Mathematics.__default) ClassNameType)) (= (type Tagclass.Mathematics.__default) TyTagType)) (= (type class.LinearSequence__i.__default) ClassNameType)) (= (type Tagclass.LinearSequence__i.__default) TyTagType)) (= (type class.Sequences.__default) ClassNameType)) (= (type Tagclass.Sequences.__default) TyTagType)) (= (type class.MapRemove_s.__default) ClassNameType)) (= (type Tagclass.MapRemove_s.__default) TyTagType)) (= (type class.Maps.__default) ClassNameType)) (= (type Tagclass.Maps.__default) TyTagType)) (= (type |##MsgHistoryMod.KeyedMessage.KeyedMessage|) DtCtorIdType)) (= (type Tagclass.MsgHistoryMod.KeyedMessage) TyTagType)) (= (type class.MsgHistoryMod.KeyedMessage) ClassNameType)) (= (type |##MsgHistoryMod.MsgHistory.MsgHistory|) DtCtorIdType)) (= (type class.MsgHistoryMod.MsgHistory) ClassNameType)) (= (type class.MsgHistoryMod.__default) ClassNameType)) (= (type Tagclass.MsgHistoryMod.__default) TyTagType)) (= (type |##Buffers.Buffer.Buffer|) DtCtorIdType)) (= (type Tagclass.Buffers.Buffer) TyTagType)) (= (type class.Buffers.Buffer) ClassNameType)) (= (type |##Buffers.BufferStack.BufferStack|) DtCtorIdType)) (= (type class.Buffers.BufferStack) ClassNameType)) (= (type class.Buffers.__default) ClassNameType)) (= (type Tagclass.Buffers.__default) TyTagType)) (= (type |##MemtableMod.Memtable.Memtable|) DtCtorIdType)) (= (type class.MemtableMod.Memtable) ClassNameType)) (= (type class.MemtableMod.__default) ClassNameType)) (= (type Tagclass.MemtableMod.__default) TyTagType)) (= (type class.Sets.__default) ClassNameType)) (= (type Tagclass.Sets.__default) TyTagType)) (= (type class.SeqComparison.__default) ClassNameType)) (= (type Tagclass.SeqComparison.__default) TyTagType)) (= (type class.NativeArrays.__default) ClassNameType)) (= (type Tagclass.NativeArrays.__default) TyTagType)) (= (type class.Byte__Order.__default) ClassNameType)) (= (type Tagclass.Byte__Order.__default) TyTagType)) (= (type class.Lexicographic__Byte__Order.__default) ClassNameType)) (= (type Tagclass.Lexicographic__Byte__Order.__default) TyTagType)) (= (type class.Upperbounded__Lexicographic__Byte__Order.__default) ClassNameType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order.__default) TyTagType)) (= (type |##Upperbounded_Lexicographic_Byte_Order.Element.Element|) DtCtorIdType)) (= (type |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) DtCtorIdType)) (= (type class.Upperbounded__Lexicographic__Byte__Order.Element) ClassNameType)) (= (type class.Upperbounded__Lexicographic__Byte__Order__Impl.__default) ClassNameType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) TyTagType)) (= (type class.BoundedPivotsLib.__default) ClassNameType)) (= (type Tagclass.BoundedPivotsLib.__default) TyTagType)) (= (type |##DomainMod.Domain.EmptyDomain|) DtCtorIdType)) (= (type |##DomainMod.Domain.Domain|) DtCtorIdType)) (= (type class.DomainMod.Domain) ClassNameType)) (= (type class.DomainMod.__default) ClassNameType)) (= (type Tagclass.DomainMod.__default) TyTagType)) (= (type |##SplitRequestMod.SplitRequest.SplitLeaf|) DtCtorIdType)) (= (type |##SplitRequestMod.SplitRequest.SplitIndex|) DtCtorIdType)) (= (type class.SplitRequestMod.SplitRequest) ClassNameType)) (= (type class.SplitRequestMod.__default) ClassNameType)) (= (type Tagclass.SplitRequestMod.__default) TyTagType)) (= (type |##PivotBetree.TransitionLabel.QueryLabel|) DtCtorIdType)) (= (type |##PivotBetree.TransitionLabel.PutLabel|) DtCtorIdType)) (= (type |##PivotBetree.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)) (= (type |##PivotBetree.TransitionLabel.FreezeAsLabel|) DtCtorIdType)) (= (type |##PivotBetree.TransitionLabel.InternalLabel|) DtCtorIdType)) (= (type class.PivotBetree.TransitionLabel) ClassNameType)) (= (type |##PivotBetree.BetreeNode.Nil|) DtCtorIdType)) (= (type |##PivotBetree.BetreeNode.BetreeNode|) DtCtorIdType)) (= (type class.PivotBetree.BetreeNode) ClassNameType)) (= (type |##PivotBetree.QueryReceiptLine.QueryReceiptLine|) DtCtorIdType)) (= (type class.PivotBetree.QueryReceiptLine) ClassNameType)) (= (type |##PivotBetree.QueryReceipt.QueryReceipt|) DtCtorIdType)) (= (type class.PivotBetree.QueryReceipt) ClassNameType)) (= (type |##PivotBetree.Variables.Variables|) DtCtorIdType)) (= (type class.PivotBetree.Variables) ClassNameType)) (= (type |##PivotBetree.Path.Path|) DtCtorIdType)) (= (type class.PivotBetree.Path) ClassNameType)) (= (type |##PivotBetree.Step.QueryStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.PutStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.QueryEndLsnStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.FreezeAsStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalGrowStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalSplitStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalFlushMemtableStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalFlushStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalCompactStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalNoOpStep|) DtCtorIdType)) (= (type class.PivotBetree.Step) ClassNameType)) (= (type class.PivotBetree.__default) ClassNameType)) (= (type Tagclass.PivotBetree.__default) TyTagType)) (= (type |##PagedBetree.TransitionLabel.QueryLabel|) DtCtorIdType)) (= (type |##PagedBetree.TransitionLabel.PutLabel|) DtCtorIdType)) (= (type |##PagedBetree.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)) (= (type |##PagedBetree.TransitionLabel.FreezeAsLabel|) DtCtorIdType)) (= (type |##PagedBetree.TransitionLabel.InternalLabel|) DtCtorIdType)) (= (type class.PagedBetree.TransitionLabel) ClassNameType)) (= (type |##PagedBetree.ChildMap.ChildMap|) DtCtorIdType)) (= (type class.PagedBetree.ChildMap) ClassNameType)) (= (type |##PagedBetree.BetreeNode.Nil|) DtCtorIdType)) (= (type |##PagedBetree.BetreeNode.BetreeNode|) DtCtorIdType)) (= (type class.PagedBetree.BetreeNode) ClassNameType)) (= (type |##PagedBetree.QueryReceiptLine.QueryReceiptLine|) DtCtorIdType)) (= (type class.PagedBetree.QueryReceiptLine) ClassNameType)) (= (type |##PagedBetree.QueryReceipt.QueryReceipt|) DtCtorIdType)) (= (type class.PagedBetree.QueryReceipt) ClassNameType)) (= (type |##PagedBetree.Variables.Variables|) DtCtorIdType)) (= (type class.PagedBetree.Variables) ClassNameType)) (= (type |##PagedBetree.Path.Path|) DtCtorIdType)) (= (type class.PagedBetree.Path) ClassNameType)) (= (type |##PagedBetree.Step.QueryStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.PutStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.QueryEndLsnStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.FreezeAsStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalGrowStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalSplitStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalFlushMemtableStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalFlushStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalCompactStep|) DtCtorIdType)) (= (type |##PagedBetree.Step.InternalNoOpStep|) DtCtorIdType)) (= (type class.PagedBetree.Step) ClassNameType)) (= (type class.PagedBetree.__default) ClassNameType)) (= (type Tagclass.PagedBetree.__default) TyTagType)) (= (type |##AbstractMap.TransitionLabel.QueryLabel|) DtCtorIdType)) (= (type Tagclass.AbstractMap.TransitionLabel) TyTagType)) (= (type |##AbstractMap.TransitionLabel.PutLabel|) DtCtorIdType)) (= (type |##AbstractMap.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)) (= (type |##AbstractMap.TransitionLabel.FreezeAsLabel|) DtCtorIdType)) (= (type |##AbstractMap.TransitionLabel.InternalLabel|) DtCtorIdType)) (= (type class.AbstractMap.TransitionLabel) ClassNameType)) (= (type |##AbstractMap.Variables.Variables|) DtCtorIdType)) (= (type Tagclass.AbstractMap.Variables) TyTagType)) (= (type class.AbstractMap.Variables) ClassNameType)) (= (type class.AbstractMap.__default) ClassNameType)) (= (type Tagclass.AbstractMap.__default) TyTagType)) (= (type class.PagedBetreeRefinement.__default) ClassNameType)) (= (type Tagclass.PagedBetreeRefinement.__default) TyTagType)) (= (Ctor TyTagFamilyType) 12)) (= (type tytagFamily$nat) TyTagFamilyType)) (= (type tytagFamily$object) TyTagFamilyType)) (= (type tytagFamily$array) TyTagFamilyType)) (= (type |tytagFamily$_#Func1|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1|) TyTagFamilyType)) (= (type |tytagFamily$_#Func0|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc0|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc0|) TyTagFamilyType)) (= (type tytagFamily$_default) TyTagFamilyType)) (= (type |tytagFamily$_#Func2|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#2|) TyTagFamilyType)) (= (type |tytagFamily$_#Func4|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc4|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc4|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#Func0L|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc0L|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc0L|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#0|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1LO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1LO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1LO|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#2OLL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1LL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1LL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1LL|) TyTagFamilyType)) (= (type tytagFamily$BetreeNode) TyTagFamilyType)) (= (type tytagFamily$ChildMap) TyTagFamilyType)) (= (type tytagFamily$Key) TyTagFamilyType)) (= (type tytagFamily$Stamped) TyTagFamilyType)) (= (type tytagFamily$TransitionLabel) TyTagFamilyType)) (= (type tytagFamily$MsgHistory) TyTagFamilyType)) (= (type tytagFamily$Value) TyTagFamilyType)) (= (type tytagFamily$byte) TyTagFamilyType)) (= (type tytagFamily$Variables) TyTagFamilyType)) (= (type tytagFamily$Step) TyTagFamilyType)) (= (type tytagFamily$Path) TyTagFamilyType)) (= (type tytagFamily$SplitRequest) TyTagFamilyType)) (= (type tytagFamily$BufferStack) TyTagFamilyType)) (= (type tytagFamily$Element) TyTagFamilyType)) (= (type tytagFamily$QueryReceiptLine) TyTagFamilyType)) (= (type tytagFamily$QueryReceipt) TyTagFamilyType)) (= (type tytagFamily$Domain) TyTagFamilyType)) (= (type tytagFamily$Memtable) TyTagFamilyType)) (= (type tytagFamily$Option) TyTagFamilyType)) (= (type tytagFamily$sbyte) TyTagFamilyType)) (= (type tytagFamily$int16) TyTagFamilyType)) (= (type tytagFamily$uint16) TyTagFamilyType)) (= (type tytagFamily$int32) TyTagFamilyType)) (= (type tytagFamily$uint32) TyTagFamilyType)) (= (type tytagFamily$int64) TyTagFamilyType)) (= (type tytagFamily$uint64) TyTagFamilyType)) (= (type tytagFamily$nat8) TyTagFamilyType)) (= (type tytagFamily$nat16) TyTagFamilyType)) (= (type tytagFamily$nat32) TyTagFamilyType)) (= (type tytagFamily$nat64) TyTagFamilyType)) (= (type tytagFamily$uint128) TyTagFamilyType)) (= (type tytagFamily$Delta) TyTagFamilyType)) (= (type tytagFamily$Message) TyTagFamilyType)) (= (type tytagFamily$TotalMap) TyTagFamilyType)) (= (type tytagFamily$KeyedMessage) TyTagFamilyType)) (= (type tytagFamily$Buffer) TyTagFamilyType)))
(assert (distinct TBool TChar TInt TReal TORDINAL TagBool TagChar TagInt TagReal TagORDINAL TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc allocName Tagclass._System.nat class._System.object? Tagclass._System.object? Tagclass._System.object class._System.array? Tagclass._System.array? Tagclass._System.array Tagclass._System.___hFunc1 Tagclass._System.___hPartialFunc1 Tagclass._System.___hTotalFunc1 Tagclass._System.___hFunc0 Tagclass._System.___hPartialFunc0 Tagclass._System.___hTotalFunc0 class._System.__default Tagclass._System.__default Tagclass._System.___hFunc2 Tagclass._System.___hPartialFunc2 Tagclass._System.___hTotalFunc2 |##_System._tuple#2._#Make2| Tagclass._System.Tuple2 class._System.Tuple2 Tagclass._System.___hFunc4 Tagclass._System.___hPartialFunc4 Tagclass._System.___hTotalFunc4 Tagclass._System.___hFunc3 Tagclass._System.___hPartialFunc3 Tagclass._System.___hTotalFunc3 Tagclass._System.___hFunc2OSO Tagclass._System.___hPartialFunc2OSO Tagclass._System.___hTotalFunc2OSO Tagclass._System.___hFunc3LLOO Tagclass._System.___hPartialFunc3LLOO Tagclass._System.___hTotalFunc3LLOO Tagclass._System.___hFunc1OS Tagclass._System.___hPartialFunc1OS Tagclass._System.___hTotalFunc1OS Tagclass._System.___hFunc0L Tagclass._System.___hPartialFunc0L Tagclass._System.___hTotalFunc0L Tagclass._System.___hFunc2LOO Tagclass._System.___hPartialFunc2LOO Tagclass._System.___hTotalFunc2LOO |##_System._tuple#0._#Make0| Tagclass._System.Tuple0 class._System.Tuple0 Tagclass._System.___hFunc1OL Tagclass._System.___hPartialFunc1OL Tagclass._System.___hTotalFunc1OL Tagclass._System.___hFunc1LO Tagclass._System.___hPartialFunc1LO Tagclass._System.___hTotalFunc1LO |##_System._tuple#2OLL._#Make2| Tagclass._System.Tuple2OLL class._System.Tuple2OLL Tagclass._System.___hFunc3LLOL Tagclass._System.___hPartialFunc3LLOL Tagclass._System.___hTotalFunc3LLOL Tagclass._System.___hFunc2SSO Tagclass._System.___hPartialFunc2SSO Tagclass._System.___hTotalFunc2SSO Tagclass._System.___hFunc2LLO Tagclass._System.___hPartialFunc2LLO Tagclass._System.___hTotalFunc2LLO Tagclass._System.___hFunc1SS Tagclass._System.___hPartialFunc1SS Tagclass._System.___hTotalFunc1SS Tagclass._System.___hFunc1LL Tagclass._System.___hPartialFunc1LL Tagclass._System.___hTotalFunc1LL class.PivotBetreeRefinement.__default Tagclass.PivotBetreeRefinement.__default Tagclass.PivotBetree.BetreeNode Tagclass.PagedBetree.ChildMap Tagclass.KeyType.Key Tagclass.PagedBetree.BetreeNode Tagclass.StampedMod.Stamped Tagclass.PivotBetree.TransitionLabel Tagclass.PagedBetree.TransitionLabel Tagclass.MsgHistoryMod.MsgHistory Tagclass.ValueType.Value Tagclass.NativeTypes.byte Tagclass.PivotBetree.Variables Tagclass.PagedBetree.Variables Tagclass.PivotBetree.Step Tagclass.PivotBetree.Path Tagclass.SplitRequestMod.SplitRequest Tagclass.Buffers.BufferStack Tagclass.Upperbounded__Lexicographic__Byte__Order.Element Tagclass.PagedBetree.Path Tagclass.PivotBetree.QueryReceiptLine Tagclass.PagedBetree.QueryReceiptLine Tagclass.PivotBetree.QueryReceipt Tagclass.PagedBetree.QueryReceipt Tagclass.DomainMod.Domain Tagclass.PagedBetree.Step Tagclass.MemtableMod.Memtable |##Options.Option.None| Tagclass.Options.Option |##Options.Option.Some| class.Options.Option class.Options.__default Tagclass.Options.__default Tagclass.NativeTypes.sbyte class.NativeTypes.sbyte class.NativeTypes.byte Tagclass.NativeTypes.int16 class.NativeTypes.int16 Tagclass.NativeTypes.uint16 class.NativeTypes.uint16 Tagclass.NativeTypes.int32 class.NativeTypes.int32 Tagclass.NativeTypes.uint32 class.NativeTypes.uint32 Tagclass.NativeTypes.int64 class.NativeTypes.int64 Tagclass.NativeTypes.uint64 class.NativeTypes.uint64 Tagclass.NativeTypes.nat8 class.NativeTypes.nat8 Tagclass.NativeTypes.nat16 class.NativeTypes.nat16 Tagclass.NativeTypes.nat32 class.NativeTypes.nat32 Tagclass.NativeTypes.nat64 class.NativeTypes.nat64 Tagclass.NativeTypes.uint128 class.NativeTypes.uint128 class.NativeTypes.__default Tagclass.NativeTypes.__default class.KeyType.__default Tagclass.KeyType.__default class.ValueType.__default Tagclass.ValueType.__default class.LinearMaybe.predefined class.LinearMaybe.__default Tagclass.LinearMaybe.__default class.LinearExtern.predefined class.LinearExtern.__default Tagclass.LinearExtern.__default |##ValueMessage.Delta.NoDelta| Tagclass.ValueMessage.Delta class.ValueMessage.Delta class.ValueMessage.__default Tagclass.ValueMessage.__default Tagclass.ValueMessage.Message |##ValueMessage.Message.Define| |##ValueMessage.Message.Update| class.ValueMessage.Message class.TotalKMMapMod.__default Tagclass.TotalKMMapMod.__default Tagclass.TotalKMMapMod.TotalMap class.LSNMod.__default Tagclass.LSNMod.__default |##StampedMod.Stamped.Stamped| class.StampedMod.Stamped class.StampedMod.__default Tagclass.StampedMod.__default class.SequencesLite.__default Tagclass.SequencesLite.__default class.Mathematics.__default Tagclass.Mathematics.__default class.LinearSequence__i.__default Tagclass.LinearSequence__i.__default class.Sequences.__default Tagclass.Sequences.__default class.MapRemove_s.__default Tagclass.MapRemove_s.__default class.Maps.__default Tagclass.Maps.__default |##MsgHistoryMod.KeyedMessage.KeyedMessage| Tagclass.MsgHistoryMod.KeyedMessage class.MsgHistoryMod.KeyedMessage |##MsgHistoryMod.MsgHistory.MsgHistory| class.MsgHistoryMod.MsgHistory class.MsgHistoryMod.__default Tagclass.MsgHistoryMod.__default |##Buffers.Buffer.Buffer| Tagclass.Buffers.Buffer class.Buffers.Buffer |##Buffers.BufferStack.BufferStack| class.Buffers.BufferStack class.Buffers.__default Tagclass.Buffers.__default |##MemtableMod.Memtable.Memtable| class.MemtableMod.Memtable class.MemtableMod.__default Tagclass.MemtableMod.__default class.Sets.__default Tagclass.Sets.__default class.SeqComparison.__default Tagclass.SeqComparison.__default class.NativeArrays.__default Tagclass.NativeArrays.__default class.Byte__Order.__default Tagclass.Byte__Order.__default class.Lexicographic__Byte__Order.__default Tagclass.Lexicographic__Byte__Order.__default class.Upperbounded__Lexicographic__Byte__Order.__default Tagclass.Upperbounded__Lexicographic__Byte__Order.__default |##Upperbounded_Lexicographic_Byte_Order.Element.Element| |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| class.Upperbounded__Lexicographic__Byte__Order.Element class.Upperbounded__Lexicographic__Byte__Order__Impl.__default Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default class.BoundedPivotsLib.__default Tagclass.BoundedPivotsLib.__default |##DomainMod.Domain.EmptyDomain| |##DomainMod.Domain.Domain| class.DomainMod.Domain class.DomainMod.__default Tagclass.DomainMod.__default |##SplitRequestMod.SplitRequest.SplitLeaf| |##SplitRequestMod.SplitRequest.SplitIndex| class.SplitRequestMod.SplitRequest class.SplitRequestMod.__default Tagclass.SplitRequestMod.__default |##PivotBetree.TransitionLabel.QueryLabel| |##PivotBetree.TransitionLabel.PutLabel| |##PivotBetree.TransitionLabel.QueryEndLsnLabel| |##PivotBetree.TransitionLabel.FreezeAsLabel| |##PivotBetree.TransitionLabel.InternalLabel| class.PivotBetree.TransitionLabel |##PivotBetree.BetreeNode.Nil| |##PivotBetree.BetreeNode.BetreeNode| class.PivotBetree.BetreeNode |##PivotBetree.QueryReceiptLine.QueryReceiptLine| class.PivotBetree.QueryReceiptLine |##PivotBetree.QueryReceipt.QueryReceipt| class.PivotBetree.QueryReceipt |##PivotBetree.Variables.Variables| class.PivotBetree.Variables |##PivotBetree.Path.Path| class.PivotBetree.Path |##PivotBetree.Step.QueryStep| |##PivotBetree.Step.PutStep| |##PivotBetree.Step.QueryEndLsnStep| |##PivotBetree.Step.FreezeAsStep| |##PivotBetree.Step.InternalGrowStep| |##PivotBetree.Step.InternalSplitStep| |##PivotBetree.Step.InternalFlushMemtableStep| |##PivotBetree.Step.InternalFlushStep| |##PivotBetree.Step.InternalCompactStep| |##PivotBetree.Step.InternalNoOpStep| class.PivotBetree.Step class.PivotBetree.__default Tagclass.PivotBetree.__default |##PagedBetree.TransitionLabel.QueryLabel| |##PagedBetree.TransitionLabel.PutLabel| |##PagedBetree.TransitionLabel.QueryEndLsnLabel| |##PagedBetree.TransitionLabel.FreezeAsLabel| |##PagedBetree.TransitionLabel.InternalLabel| class.PagedBetree.TransitionLabel |##PagedBetree.ChildMap.ChildMap| class.PagedBetree.ChildMap |##PagedBetree.BetreeNode.Nil| |##PagedBetree.BetreeNode.BetreeNode| class.PagedBetree.BetreeNode |##PagedBetree.QueryReceiptLine.QueryReceiptLine| class.PagedBetree.QueryReceiptLine |##PagedBetree.QueryReceipt.QueryReceipt| class.PagedBetree.QueryReceipt |##PagedBetree.Variables.Variables| class.PagedBetree.Variables |##PagedBetree.Path.Path| class.PagedBetree.Path |##PagedBetree.Step.QueryStep| |##PagedBetree.Step.PutStep| |##PagedBetree.Step.QueryEndLsnStep| |##PagedBetree.Step.FreezeAsStep| |##PagedBetree.Step.InternalGrowStep| |##PagedBetree.Step.InternalSplitStep| |##PagedBetree.Step.InternalFlushMemtableStep| |##PagedBetree.Step.InternalFlushStep| |##PagedBetree.Step.InternalCompactStep| |##PagedBetree.Step.InternalNoOpStep| class.PagedBetree.Step class.PagedBetree.__default Tagclass.PagedBetree.__default |##AbstractMap.TransitionLabel.QueryLabel| Tagclass.AbstractMap.TransitionLabel |##AbstractMap.TransitionLabel.PutLabel| |##AbstractMap.TransitionLabel.QueryEndLsnLabel| |##AbstractMap.TransitionLabel.FreezeAsLabel| |##AbstractMap.TransitionLabel.InternalLabel| class.AbstractMap.TransitionLabel |##AbstractMap.Variables.Variables| Tagclass.AbstractMap.Variables class.AbstractMap.Variables class.AbstractMap.__default Tagclass.AbstractMap.__default class.PagedBetreeRefinement.__default Tagclass.PagedBetreeRefinement.__default tytagFamily$nat tytagFamily$object tytagFamily$array |tytagFamily$_#Func1| |tytagFamily$_#PartialFunc1| |tytagFamily$_#TotalFunc1| |tytagFamily$_#Func0| |tytagFamily$_#PartialFunc0| |tytagFamily$_#TotalFunc0| tytagFamily$_default |tytagFamily$_#Func2| |tytagFamily$_#PartialFunc2| |tytagFamily$_#TotalFunc2| |tytagFamily$_tuple#2| |tytagFamily$_#Func4| |tytagFamily$_#PartialFunc4| |tytagFamily$_#TotalFunc4| |tytagFamily$_#Func3| |tytagFamily$_#PartialFunc3| |tytagFamily$_#TotalFunc3| |tytagFamily$_#Func2OSO| |tytagFamily$_#PartialFunc2OSO| |tytagFamily$_#TotalFunc2OSO| |tytagFamily$_#Func3LLOO| |tytagFamily$_#PartialFunc3LLOO| |tytagFamily$_#TotalFunc3LLOO| |tytagFamily$_#Func1OS| |tytagFamily$_#PartialFunc1OS| |tytagFamily$_#TotalFunc1OS| |tytagFamily$_#Func0L| |tytagFamily$_#PartialFunc0L| |tytagFamily$_#TotalFunc0L| |tytagFamily$_#Func2LOO| |tytagFamily$_#PartialFunc2LOO| |tytagFamily$_#TotalFunc2LOO| |tytagFamily$_tuple#0| |tytagFamily$_#Func1OL| |tytagFamily$_#PartialFunc1OL| |tytagFamily$_#TotalFunc1OL| |tytagFamily$_#Func1LO| |tytagFamily$_#PartialFunc1LO| |tytagFamily$_#TotalFunc1LO| |tytagFamily$_tuple#2OLL| |tytagFamily$_#Func3LLOL| |tytagFamily$_#PartialFunc3LLOL| |tytagFamily$_#TotalFunc3LLOL| |tytagFamily$_#Func2SSO| |tytagFamily$_#PartialFunc2SSO| |tytagFamily$_#TotalFunc2SSO| |tytagFamily$_#Func2LLO| |tytagFamily$_#PartialFunc2LLO| |tytagFamily$_#TotalFunc2LLO| |tytagFamily$_#Func1SS| |tytagFamily$_#PartialFunc1SS| |tytagFamily$_#TotalFunc1SS| |tytagFamily$_#Func1LL| |tytagFamily$_#PartialFunc1LL| |tytagFamily$_#TotalFunc1LL| tytagFamily$BetreeNode tytagFamily$ChildMap tytagFamily$Key tytagFamily$Stamped tytagFamily$TransitionLabel tytagFamily$MsgHistory tytagFamily$Value tytagFamily$byte tytagFamily$Variables tytagFamily$Step tytagFamily$Path tytagFamily$SplitRequest tytagFamily$BufferStack tytagFamily$Element tytagFamily$QueryReceiptLine tytagFamily$QueryReceipt tytagFamily$Domain tytagFamily$Memtable tytagFamily$Option tytagFamily$sbyte tytagFamily$int16 tytagFamily$uint16 tytagFamily$int32 tytagFamily$uint32 tytagFamily$int64 tytagFamily$uint64 tytagFamily$nat8 tytagFamily$nat16 tytagFamily$nat32 tytagFamily$nat64 tytagFamily$uint128 tytagFamily$Delta tytagFamily$Message tytagFamily$TotalMap tytagFamily$KeyedMessage tytagFamily$Buffer)
)
(assert $$Language$Dafny)
(assert (forall ((arg0@@13 Int) ) (! (= (type (TBitvector arg0@@13)) TyType)
 :qid |funType:TBitvector|
 :pattern ( (TBitvector arg0@@13))
)))
(assert (forall ((w Int) ) (! (= (Inv0_TBitvector (TBitvector w)) w)
 :qid |DafnyPreludebpl.34:15|
 :skolemid |347|
 :pattern ( (TBitvector w))
)))
(assert  (and (forall ((arg0@@14 T@U) ) (! (= (type (TSet arg0@@14)) TyType)
 :qid |funType:TSet|
 :pattern ( (TSet arg0@@14))
)) (forall ((arg0@@15 T@U) ) (! (= (type (Inv0_TSet arg0@@15)) TyType)
 :qid |funType:Inv0_TSet|
 :pattern ( (Inv0_TSet arg0@@15))
))))
(assert (forall ((t T@U) ) (!  (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t))
 :qid |DafnyPreludebpl.36:15|
 :skolemid |348|
 :pattern ( (TSet t))
)))
(assert  (and (forall ((arg0@@16 T@U) ) (! (= (type (TISet arg0@@16)) TyType)
 :qid |funType:TISet|
 :pattern ( (TISet arg0@@16))
)) (forall ((arg0@@17 T@U) ) (! (= (type (Inv0_TISet arg0@@17)) TyType)
 :qid |funType:Inv0_TISet|
 :pattern ( (Inv0_TISet arg0@@17))
))))
(assert (forall ((t@@0 T@U) ) (!  (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0))
 :qid |DafnyPreludebpl.38:15|
 :skolemid |349|
 :pattern ( (TISet t@@0))
)))
(assert  (and (forall ((arg0@@18 T@U) ) (! (= (type (TSeq arg0@@18)) TyType)
 :qid |funType:TSeq|
 :pattern ( (TSeq arg0@@18))
)) (forall ((arg0@@19 T@U) ) (! (= (type (Inv0_TSeq arg0@@19)) TyType)
 :qid |funType:Inv0_TSeq|
 :pattern ( (Inv0_TSeq arg0@@19))
))))
(assert (forall ((t@@1 T@U) ) (!  (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1))
 :qid |DafnyPreludebpl.40:15|
 :skolemid |350|
 :pattern ( (TSeq t@@1))
)))
(assert  (and (forall ((arg0@@20 T@U) ) (! (= (type (TMultiSet arg0@@20)) TyType)
 :qid |funType:TMultiSet|
 :pattern ( (TMultiSet arg0@@20))
)) (forall ((arg0@@21 T@U) ) (! (= (type (Inv0_TMultiSet arg0@@21)) TyType)
 :qid |funType:Inv0_TMultiSet|
 :pattern ( (Inv0_TMultiSet arg0@@21))
))))
(assert (forall ((t@@2 T@U) ) (!  (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2))
 :qid |DafnyPreludebpl.42:15|
 :skolemid |351|
 :pattern ( (TMultiSet t@@2))
)))
(assert  (and (forall ((arg0@@22 T@U) (arg1 T@U) ) (! (= (type (TMap arg0@@22 arg1)) TyType)
 :qid |funType:TMap|
 :pattern ( (TMap arg0@@22 arg1))
)) (forall ((arg0@@23 T@U) ) (! (= (type (Inv0_TMap arg0@@23)) TyType)
 :qid |funType:Inv0_TMap|
 :pattern ( (Inv0_TMap arg0@@23))
))))
(assert (forall ((t@@3 T@U) (u T@U) ) (!  (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3))
 :qid |DafnyPreludebpl.45:15|
 :skolemid |352|
 :pattern ( (TMap t@@3 u))
)))
(assert (forall ((arg0@@24 T@U) ) (! (= (type (Inv1_TMap arg0@@24)) TyType)
 :qid |funType:Inv1_TMap|
 :pattern ( (Inv1_TMap arg0@@24))
)))
(assert (forall ((t@@4 T@U) (u@@0 T@U) ) (!  (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0))
 :qid |DafnyPreludebpl.46:15|
 :skolemid |353|
 :pattern ( (TMap t@@4 u@@0))
)))
(assert  (and (forall ((arg0@@25 T@U) (arg1@@0 T@U) ) (! (= (type (TIMap arg0@@25 arg1@@0)) TyType)
 :qid |funType:TIMap|
 :pattern ( (TIMap arg0@@25 arg1@@0))
)) (forall ((arg0@@26 T@U) ) (! (= (type (Inv0_TIMap arg0@@26)) TyType)
 :qid |funType:Inv0_TIMap|
 :pattern ( (Inv0_TIMap arg0@@26))
))))
(assert (forall ((t@@5 T@U) (u@@1 T@U) ) (!  (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5))
 :qid |DafnyPreludebpl.49:15|
 :skolemid |354|
 :pattern ( (TIMap t@@5 u@@1))
)))
(assert (forall ((arg0@@27 T@U) ) (! (= (type (Inv1_TIMap arg0@@27)) TyType)
 :qid |funType:Inv1_TIMap|
 :pattern ( (Inv1_TIMap arg0@@27))
)))
(assert (forall ((t@@6 T@U) (u@@2 T@U) ) (!  (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2))
 :qid |DafnyPreludebpl.50:15|
 :skolemid |355|
 :pattern ( (TIMap t@@6 u@@2))
)))
(assert (forall ((arg0@@28 T@U) ) (! (= (type (Tag arg0@@28)) TyTagType)
 :qid |funType:Tag|
 :pattern ( (Tag arg0@@28))
)))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (= (Tag TORDINAL) TagORDINAL))
(assert (forall ((t@@7 T@U) ) (!  (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet))
 :qid |DafnyPreludebpl.76:15|
 :skolemid |356|
 :pattern ( (TSet t@@7))
)))
(assert (forall ((t@@8 T@U) ) (!  (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet))
 :qid |DafnyPreludebpl.77:15|
 :skolemid |357|
 :pattern ( (TISet t@@8))
)))
(assert (forall ((t@@9 T@U) ) (!  (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet))
 :qid |DafnyPreludebpl.78:15|
 :skolemid |358|
 :pattern ( (TMultiSet t@@9))
)))
(assert (forall ((t@@10 T@U) ) (!  (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq))
 :qid |DafnyPreludebpl.79:15|
 :skolemid |359|
 :pattern ( (TSeq t@@10))
)))
(assert (forall ((t@@11 T@U) (u@@3 T@U) ) (!  (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap))
 :qid |DafnyPreludebpl.80:15|
 :skolemid |360|
 :pattern ( (TMap t@@11 u@@3))
)))
(assert (forall ((t@@12 T@U) (u@@4 T@U) ) (!  (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap))
 :qid |DafnyPreludebpl.81:15|
 :skolemid |361|
 :pattern ( (TIMap t@@12 u@@4))
)))
(assert (forall ((arg0@@29 T@U) ) (! (let ((T (type arg0@@29)))
(= (type (Lit arg0@@29)) T))
 :qid |funType:Lit|
 :pattern ( (Lit arg0@@29))
)))
(assert (forall ((x@@8 T@U) ) (! (= (Lit x@@8) x@@8)
 :qid |DafnyPreludebpl.89:29|
 :skolemid |362|
 :pattern ( (Lit x@@8))
)))
(assert  (and (= (Ctor BoxType) 13) (forall ((arg0@@30 T@U) ) (! (= (type ($Box arg0@@30)) BoxType)
 :qid |funType:$Box|
 :pattern ( ($Box arg0@@30))
))))
(assert (forall ((x@@9 T@U) ) (! (= ($Box (Lit x@@9)) (Lit ($Box x@@9)))
 :qid |DafnyPreludebpl.90:18|
 :skolemid |363|
 :pattern ( ($Box (Lit x@@9)))
)))
(assert (forall ((x@@10 Int) ) (! (= (LitInt x@@10) x@@10)
 :qid |DafnyPreludebpl.95:29|
 :skolemid |364|
 :pattern ( (LitInt x@@10))
)))
(assert (forall ((x@@11 Int) ) (! (= ($Box (int_2_U (LitInt x@@11))) (Lit ($Box (int_2_U x@@11))))
 :qid |DafnyPreludebpl.96:15|
 :skolemid |365|
 :pattern ( ($Box (int_2_U (LitInt x@@11))))
)))
(assert (forall ((x@@12 Real) ) (! (= (LitReal x@@12) x@@12)
 :qid |DafnyPreludebpl.97:30|
 :skolemid |366|
 :pattern ( (LitReal x@@12))
)))
(assert (forall ((x@@13 Real) ) (! (= ($Box (real_2_U (LitReal x@@13))) (Lit ($Box (real_2_U x@@13))))
 :qid |DafnyPreludebpl.98:15|
 :skolemid |367|
 :pattern ( ($Box (real_2_U (LitReal x@@13))))
)))
(assert  (and (= (Ctor charType) 14) (forall ((arg0@@31 Int) ) (! (= (type (|char#FromInt| arg0@@31)) charType)
 :qid |funType:char#FromInt|
 :pattern ( (|char#FromInt| arg0@@31))
))))
(assert (forall ((ch T@U) ) (!  (=> (= (type ch) charType) (and (and (= (|char#FromInt| (|char#ToInt| ch)) ch) (<= 0 (|char#ToInt| ch))) (< (|char#ToInt| ch) 65536)))
 :qid |DafnyPreludebpl.107:15|
 :skolemid |368|
 :pattern ( (|char#ToInt| ch))
)))
(assert (forall ((n Int) ) (!  (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n))
 :qid |DafnyPreludebpl.111:15|
 :skolemid |369|
 :pattern ( (|char#FromInt| n))
)))
(assert (forall ((arg0@@32 T@U) (arg1@@1 T@U) ) (! (= (type (|char#Plus| arg0@@32 arg1@@1)) charType)
 :qid |funType:char#Plus|
 :pattern ( (|char#Plus| arg0@@32 arg1@@1))
)))
(assert (forall ((a T@U) (b T@U) ) (!  (=> (and (= (type a) charType) (= (type b) charType)) (= (|char#Plus| a b) (|char#FromInt| (+ (|char#ToInt| a) (|char#ToInt| b)))))
 :qid |DafnyPreludebpl.117:15|
 :skolemid |370|
 :pattern ( (|char#Plus| a b))
)))
(assert (forall ((arg0@@33 T@U) (arg1@@2 T@U) ) (! (= (type (|char#Minus| arg0@@33 arg1@@2)) charType)
 :qid |funType:char#Minus|
 :pattern ( (|char#Minus| arg0@@33 arg1@@2))
)))
(assert (forall ((a@@0 T@U) (b@@0 T@U) ) (!  (=> (and (= (type a@@0) charType) (= (type b@@0) charType)) (= (|char#Minus| a@@0 b@@0) (|char#FromInt| (- (|char#ToInt| a@@0) (|char#ToInt| b@@0)))))
 :qid |DafnyPreludebpl.120:15|
 :skolemid |371|
 :pattern ( (|char#Minus| a@@0 b@@0))
)))
(assert (forall ((T@@0 T@T) (arg0@@34 T@U) ) (! (= (type ($Unbox T@@0 arg0@@34)) T@@0)
 :qid |funType:$Unbox|
 :pattern ( ($Unbox T@@0 arg0@@34))
)))
(assert (forall ((x@@14 T@U) ) (! (let ((T@@1 (type x@@14)))
(= ($Unbox T@@1 ($Box x@@14)) x@@14))
 :qid |DafnyPreludebpl.141:18|
 :skolemid |372|
 :pattern ( ($Box x@@14))
)))
(assert (forall ((bx T@U) ) (!  (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt)))
 :qid |DafnyPreludebpl.143:15|
 :skolemid |373|
 :pattern ( ($IsBox bx TInt))
)))
(assert (forall ((bx@@0 T@U) ) (!  (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TReal)) (and (= ($Box ($Unbox realType bx@@0)) bx@@0) ($Is ($Unbox realType bx@@0) TReal)))
 :qid |DafnyPreludebpl.146:15|
 :skolemid |374|
 :pattern ( ($IsBox bx@@0 TReal))
)))
(assert (forall ((bx@@1 T@U) ) (!  (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TBool)) (and (= ($Box ($Unbox boolType bx@@1)) bx@@1) ($Is ($Unbox boolType bx@@1) TBool)))
 :qid |DafnyPreludebpl.149:15|
 :skolemid |375|
 :pattern ( ($IsBox bx@@1 TBool))
)))
(assert (forall ((bx@@2 T@U) ) (!  (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TChar)) (and (= ($Box ($Unbox charType bx@@2)) bx@@2) ($Is ($Unbox charType bx@@2) TChar)))
 :qid |DafnyPreludebpl.152:15|
 :skolemid |376|
 :pattern ( ($IsBox bx@@2 TChar))
)))
(assert  (and (and (and (and (and (and (forall ((arg0@@35 T@T) (arg1@@3 T@T) ) (! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15)
 :qid |ctor:MapType0Type|
)) (forall ((arg0@@36 T@T) (arg1@@4 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36)
 :qid |typeInv:MapType0TypeInv0|
 :pattern ( (MapType0Type arg0@@36 arg1@@4))
))) (forall ((arg0@@37 T@T) (arg1@@5 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5)
 :qid |typeInv:MapType0TypeInv1|
 :pattern ( (MapType0Type arg0@@37 arg1@@5))
))) (forall ((arg0@@38 T@U) (arg1@@6 T@U) ) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@38))))
(= (type (MapType0Select arg0@@38 arg1@@6)) aVar1))
 :qid |funType:MapType0Select|
 :pattern ( (MapType0Select arg0@@38 arg1@@6))
))) (forall ((arg0@@39 T@U) (arg1@@7 T@U) (arg2 T@U) ) (! (let ((aVar1@@0 (type arg2)))
(let ((aVar0 (type arg1@@7)))
(= (type (MapType0Store arg0@@39 arg1@@7 arg2)) (MapType0Type aVar0 aVar1@@0))))
 :qid |funType:MapType0Store|
 :pattern ( (MapType0Store arg0@@39 arg1@@7 arg2))
))) (forall ((m T@U) (x0 T@U) (val T@U) ) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m))))
 (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val)))
 :qid |mapAx0:MapType0Select|
 :weight 0
))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0)))
 :qid |mapAx1:MapType0Select:0|
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0)))
 :qid |mapAx2:MapType0Select|
 :weight 0
)))))
(assert (forall ((bx@@3 T@U) ) (!  (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 (TBitvector 0))) (and (= ($Box ($Unbox intType bx@@3)) bx@@3) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@3) (TBitvector 0))))
 :qid |DafnyPreludebpl.158:15|
 :skolemid |377|
 :pattern ( ($IsBox bx@@3 (TBitvector 0)))
)))
(assert (forall ((bx@@4 T@U) (t@@13 T@U) ) (!  (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13))))
 :qid |DafnyPreludebpl.162:15|
 :skolemid |378|
 :pattern ( ($IsBox bx@@4 (TSet t@@13)))
)))
(assert (forall ((bx@@5 T@U) (t@@14 T@U) ) (!  (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14))))
 :qid |DafnyPreludebpl.165:15|
 :skolemid |379|
 :pattern ( ($IsBox bx@@5 (TISet t@@14)))
)))
(assert (forall ((bx@@6 T@U) (t@@15 T@U) ) (!  (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15))))
 :qid |DafnyPreludebpl.168:15|
 :skolemid |380|
 :pattern ( ($IsBox bx@@6 (TMultiSet t@@15)))
)))
(assert  (and (forall ((arg0@@40 T@T) ) (! (= (Ctor (SeqType arg0@@40)) 16)
 :qid |ctor:SeqType|
)) (forall ((arg0@@41 T@T) ) (! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41)
 :qid |typeInv:SeqTypeInv0|
 :pattern ( (SeqType arg0@@41))
))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U) ) (!  (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16))))
 :qid |DafnyPreludebpl.171:15|
 :skolemid |381|
 :pattern ( ($IsBox bx@@7 (TSeq t@@16)))
)))
(assert  (and (and (forall ((arg0@@42 T@T) (arg1@@8 T@T) ) (! (= (Ctor (MapType arg0@@42 arg1@@8)) 17)
 :qid |ctor:MapType|
)) (forall ((arg0@@43 T@T) (arg1@@9 T@T) ) (! (= (MapTypeInv0 (MapType arg0@@43 arg1@@9)) arg0@@43)
 :qid |typeInv:MapTypeInv0|
 :pattern ( (MapType arg0@@43 arg1@@9))
))) (forall ((arg0@@44 T@T) (arg1@@10 T@T) ) (! (= (MapTypeInv1 (MapType arg0@@44 arg1@@10)) arg1@@10)
 :qid |typeInv:MapTypeInv1|
 :pattern ( (MapType arg0@@44 arg1@@10))
))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U) ) (!  (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17))))
 :qid |DafnyPreludebpl.174:15|
 :skolemid |382|
 :pattern ( ($IsBox bx@@8 (TMap s t@@17)))
)))
(assert  (and (and (forall ((arg0@@45 T@T) (arg1@@11 T@T) ) (! (= (Ctor (IMapType arg0@@45 arg1@@11)) 18)
 :qid |ctor:IMapType|
)) (forall ((arg0@@46 T@T) (arg1@@12 T@T) ) (! (= (IMapTypeInv0 (IMapType arg0@@46 arg1@@12)) arg0@@46)
 :qid |typeInv:IMapTypeInv0|
 :pattern ( (IMapType arg0@@46 arg1@@12))
))) (forall ((arg0@@47 T@T) (arg1@@13 T@T) ) (! (= (IMapTypeInv1 (IMapType arg0@@47 arg1@@13)) arg1@@13)
 :qid |typeInv:IMapTypeInv1|
 :pattern ( (IMapType arg0@@47 arg1@@13))
))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U) ) (!  (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18))))
 :qid |DafnyPreludebpl.177:15|
 :skolemid |383|
 :pattern ( ($IsBox bx@@9 (TIMap s@@0 t@@18)))
)))
(assert (forall ((v T@U) (t@@19 T@U) ) (!  (=> (= (type t@@19) TyType) (= ($IsBox ($Box v) t@@19) ($Is v t@@19)))
 :qid |DafnyPreludebpl.181:18|
 :skolemid |384|
 :pattern ( ($IsBox ($Box v) t@@19))
)))
(assert  (and (and (and (and (and (forall ((arg0@@48 T@U) (arg1@@14 T@U) ) (! (let ((alpha@@1 (FieldTypeInv0 (type arg1@@14))))
(= (type (MapType1Select arg0@@48 arg1@@14)) alpha@@1))
 :qid |funType:MapType1Select|
 :pattern ( (MapType1Select arg0@@48 arg1@@14))
)) (= (Ctor MapType1Type) 19)) (forall ((arg0@@49 T@U) (arg1@@15 T@U) (arg2@@0 T@U) ) (! (= (type (MapType1Store arg0@@49 arg1@@15 arg2@@0)) MapType1Type)
 :qid |funType:MapType1Store|
 :pattern ( (MapType1Store arg0@@49 arg1@@15 arg2@@0))
))) (forall ((m@@2 T@U) (x0@@2 T@U) (val@@2 T@U) ) (! (let ((alpha@@2 (FieldTypeInv0 (type x0@@2))))
 (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 val@@2) x0@@2) val@@2)))
 :qid |mapAx0:MapType1Select|
 :weight 0
))) (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (y0@@1 T@U) ) (!  (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) y0@@1) (MapType1Select m@@3 y0@@1)))
 :qid |mapAx1:MapType1Select:0|
 :weight 0
)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :qid |mapAx2:MapType1Select|
 :weight 0
)))) (= (Ctor refType) 20)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U) ) (!  (=> (and (= (type t@@20) TyType) (= (type h) (MapType0Type refType MapType1Type))) (= ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)))
 :qid |DafnyPreludebpl.184:18|
 :skolemid |385|
 :pattern ( ($IsAllocBox ($Box v@@0) t@@20 h))
)))
(assert (forall ((v@@1 T@U) ) (!  (=> (= (type v@@1) intType) ($Is v@@1 TInt))
 :qid |DafnyPreludebpl.202:14|
 :skolemid |386|
 :pattern ( ($Is v@@1 TInt))
)))
(assert (forall ((v@@2 T@U) ) (!  (=> (= (type v@@2) realType) ($Is v@@2 TReal))
 :qid |DafnyPreludebpl.203:14|
 :skolemid |387|
 :pattern ( ($Is v@@2 TReal))
)))
(assert (forall ((v@@3 T@U) ) (!  (=> (= (type v@@3) boolType) ($Is v@@3 TBool))
 :qid |DafnyPreludebpl.204:14|
 :skolemid |388|
 :pattern ( ($Is v@@3 TBool))
)))
(assert (forall ((v@@4 T@U) ) (!  (=> (= (type v@@4) charType) ($Is v@@4 TChar))
 :qid |DafnyPreludebpl.205:14|
 :skolemid |389|
 :pattern ( ($Is v@@4 TChar))
)))
(assert (forall ((v@@5 T@U) ) (!  (=> (= (type v@@5) BoxType) ($Is v@@5 TORDINAL))
 :qid |DafnyPreludebpl.206:14|
 :skolemid |390|
 :pattern ( ($Is v@@5 TORDINAL))
)))
(assert (forall ((h@@0 T@U) (v@@6 T@U) ) (!  (=> (and (= (type h@@0) (MapType0Type refType MapType1Type)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0))
 :qid |DafnyPreludebpl.208:14|
 :skolemid |391|
 :pattern ( ($IsAlloc v@@6 TInt h@@0))
)))
(assert (forall ((h@@1 T@U) (v@@7 T@U) ) (!  (=> (and (= (type h@@1) (MapType0Type refType MapType1Type)) (= (type v@@7) realType)) ($IsAlloc v@@7 TReal h@@1))
 :qid |DafnyPreludebpl.209:14|
 :skolemid |392|
 :pattern ( ($IsAlloc v@@7 TReal h@@1))
)))
(assert (forall ((h@@2 T@U) (v@@8 T@U) ) (!  (=> (and (= (type h@@2) (MapType0Type refType MapType1Type)) (= (type v@@8) boolType)) ($IsAlloc v@@8 TBool h@@2))
 :qid |DafnyPreludebpl.210:14|
 :skolemid |393|
 :pattern ( ($IsAlloc v@@8 TBool h@@2))
)))
(assert (forall ((h@@3 T@U) (v@@9 T@U) ) (!  (=> (and (= (type h@@3) (MapType0Type refType MapType1Type)) (= (type v@@9) charType)) ($IsAlloc v@@9 TChar h@@3))
 :qid |DafnyPreludebpl.211:14|
 :skolemid |394|
 :pattern ( ($IsAlloc v@@9 TChar h@@3))
)))
(assert (forall ((h@@4 T@U) (v@@10 T@U) ) (!  (=> (and (= (type h@@4) (MapType0Type refType MapType1Type)) (= (type v@@10) BoxType)) ($IsAlloc v@@10 TORDINAL h@@4))
 :qid |DafnyPreludebpl.212:14|
 :skolemid |395|
 :pattern ( ($IsAlloc v@@10 TORDINAL h@@4))
)))
(assert (forall ((v@@11 T@U) ) (!  (=> (= (type v@@11) intType) ($Is v@@11 (TBitvector 0)))
 :qid |DafnyPreludebpl.216:15|
 :skolemid |396|
 :pattern ( ($Is v@@11 (TBitvector 0)))
)))
(assert (forall ((v@@12 T@U) (h@@5 T@U) ) (!  (=> (and (= (type v@@12) intType) (= (type h@@5) (MapType0Type refType MapType1Type))) ($IsAlloc v@@12 (TBitvector 0) h@@5))
 :qid |DafnyPreludebpl.217:15|
 :skolemid |397|
 :pattern ( ($IsAlloc v@@12 (TBitvector 0) h@@5))
)))
(assert (forall ((v@@13 T@U) (t0 T@U) ) (!  (=> (and (= (type v@@13) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (= ($Is v@@13 (TSet t0)) (forall ((bx@@10 T@U) ) (!  (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@13 bx@@10))) ($IsBox bx@@10 t0))
 :qid |DafnyPreludebpl.221:11|
 :skolemid |398|
 :pattern ( (MapType0Select v@@13 bx@@10))
))))
 :qid |DafnyPreludebpl.219:15|
 :skolemid |399|
 :pattern ( ($Is v@@13 (TSet t0)))
)))
(assert (forall ((v@@14 T@U) (t0@@0 T@U) ) (!  (=> (and (= (type v@@14) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (= ($Is v@@14 (TISet t0@@0)) (forall ((bx@@11 T@U) ) (!  (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@14 bx@@11))) ($IsBox bx@@11 t0@@0))
 :qid |DafnyPreludebpl.225:11|
 :skolemid |400|
 :pattern ( (MapType0Select v@@14 bx@@11))
))))
 :qid |DafnyPreludebpl.223:15|
 :skolemid |401|
 :pattern ( ($Is v@@14 (TISet t0@@0)))
)))
(assert (forall ((v@@15 T@U) (t0@@1 T@U) ) (!  (=> (and (= (type v@@15) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (= ($Is v@@15 (TMultiSet t0@@1)) (forall ((bx@@12 T@U) ) (!  (=> (and (= (type bx@@12) BoxType) (< 0 (U_2_int (MapType0Select v@@15 bx@@12)))) ($IsBox bx@@12 t0@@1))
 :qid |DafnyPreludebpl.229:11|
 :skolemid |402|
 :pattern ( (MapType0Select v@@15 bx@@12))
))))
 :qid |DafnyPreludebpl.227:15|
 :skolemid |403|
 :pattern ( ($Is v@@15 (TMultiSet t0@@1)))
)))
(assert (forall ((v@@16 T@U) (t0@@2 T@U) ) (!  (=> (and (and (= (type v@@16) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@16 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@16))
 :qid |DafnyPreludebpl.231:15|
 :skolemid |404|
 :pattern ( ($Is v@@16 (TMultiSet t0@@2)))
)))
(assert (forall ((arg0@@50 T@U) (arg1@@16 Int) ) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@50))))
(= (type (|Seq#Index| arg0@@50 arg1@@16)) T@@2))
 :qid |funType:Seq#Index|
 :pattern ( (|Seq#Index| arg0@@50 arg1@@16))
)))
(assert (forall ((v@@17 T@U) (t0@@3 T@U) ) (!  (=> (and (= (type v@@17) (SeqType BoxType)) (= (type t0@@3) TyType)) (= ($Is v@@17 (TSeq t0@@3)) (forall ((i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| v@@17))) ($IsBox (|Seq#Index| v@@17 i) t0@@3))
 :qid |DafnyPreludebpl.235:11|
 :skolemid |405|
 :pattern ( (|Seq#Index| v@@17 i))
))))
 :qid |DafnyPreludebpl.233:15|
 :skolemid |406|
 :pattern ( ($Is v@@17 (TSeq t0@@3)))
)))
(assert (forall ((v@@18 T@U) (t0@@4 T@U) (h@@6 T@U) ) (!  (=> (and (and (= (type v@@18) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@6) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@18 (TSet t0@@4) h@@6) (forall ((bx@@13 T@U) ) (!  (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@18 bx@@13))) ($IsAllocBox bx@@13 t0@@4 h@@6))
 :qid |DafnyPreludebpl.240:11|
 :skolemid |407|
 :pattern ( (MapType0Select v@@18 bx@@13))
))))
 :qid |DafnyPreludebpl.238:15|
 :skolemid |408|
 :pattern ( ($IsAlloc v@@18 (TSet t0@@4) h@@6))
)))
(assert (forall ((v@@19 T@U) (t0@@5 T@U) (h@@7 T@U) ) (!  (=> (and (and (= (type v@@19) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@7) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@19 (TISet t0@@5) h@@7) (forall ((bx@@14 T@U) ) (!  (=> (and (= (type bx@@14) BoxType) (U_2_bool (MapType0Select v@@19 bx@@14))) ($IsAllocBox bx@@14 t0@@5 h@@7))
 :qid |DafnyPreludebpl.244:11|
 :skolemid |409|
 :pattern ( (MapType0Select v@@19 bx@@14))
))))
 :qid |DafnyPreludebpl.242:15|
 :skolemid |410|
 :pattern ( ($IsAlloc v@@19 (TISet t0@@5) h@@7))
)))
(assert (forall ((v@@20 T@U) (t0@@6 T@U) (h@@8 T@U) ) (!  (=> (and (and (= (type v@@20) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@8) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@20 (TMultiSet t0@@6) h@@8) (forall ((bx@@15 T@U) ) (!  (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@20 bx@@15)))) ($IsAllocBox bx@@15 t0@@6 h@@8))
 :qid |DafnyPreludebpl.248:11|
 :skolemid |411|
 :pattern ( (MapType0Select v@@20 bx@@15))
))))
 :qid |DafnyPreludebpl.246:15|
 :skolemid |412|
 :pattern ( ($IsAlloc v@@20 (TMultiSet t0@@6) h@@8))
)))
(assert (forall ((v@@21 T@U) (t0@@7 T@U) (h@@9 T@U) ) (!  (=> (and (and (= (type v@@21) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@9) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@21 (TSeq t0@@7) h@@9) (forall ((i@@0 Int) ) (!  (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@21))) ($IsAllocBox (|Seq#Index| v@@21 i@@0) t0@@7 h@@9))
 :qid |DafnyPreludebpl.252:11|
 :skolemid |413|
 :pattern ( (|Seq#Index| v@@21 i@@0))
))))
 :qid |DafnyPreludebpl.250:15|
 :skolemid |414|
 :pattern ( ($IsAlloc v@@21 (TSeq t0@@7) h@@9))
)))
(assert  (and (forall ((arg0@@51 T@U) ) (! (let ((V (MapTypeInv1 (type arg0@@51))))
(let ((U (MapTypeInv0 (type arg0@@51))))
(= (type (|Map#Elements| arg0@@51)) (MapType0Type U V))))
 :qid |funType:Map#Elements|
 :pattern ( (|Map#Elements| arg0@@51))
)) (forall ((arg0@@52 T@U) ) (! (let ((U@@0 (MapTypeInv0 (type arg0@@52))))
(= (type (|Map#Domain| arg0@@52)) (MapType0Type U@@0 boolType)))
 :qid |funType:Map#Domain|
 :pattern ( (|Map#Domain| arg0@@52))
))))
(assert (forall ((v@@22 T@U) (t0@@8 T@U) (t1 T@U) ) (!  (=> (and (and (= (type v@@22) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (= ($Is v@@22 (TMap t0@@8 t1)) (forall ((bx@@16 T@U) ) (!  (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@22) bx@@16))) (and ($IsBox (MapType0Select (|Map#Elements| v@@22) bx@@16) t1) ($IsBox bx@@16 t0@@8)))
 :qid |DafnyPreludebpl.259:19|
 :skolemid |415|
 :pattern ( (MapType0Select (|Map#Elements| v@@22) bx@@16))
 :pattern ( (MapType0Select (|Map#Domain| v@@22) bx@@16))
))))
 :qid |DafnyPreludebpl.256:15|
 :skolemid |416|
 :pattern ( ($Is v@@22 (TMap t0@@8 t1)))
)))
(assert (forall ((v@@23 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@10 T@U) ) (!  (=> (and (and (and (= (type v@@23) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@10) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10) (forall ((bx@@17 T@U) ) (!  (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@23) bx@@17))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@23) bx@@17) t1@@0 h@@10) ($IsAllocBox bx@@17 t0@@9 h@@10)))
 :qid |DafnyPreludebpl.267:19|
 :skolemid |417|
 :pattern ( (MapType0Select (|Map#Elements| v@@23) bx@@17))
 :pattern ( (MapType0Select (|Map#Domain| v@@23) bx@@17))
))))
 :qid |DafnyPreludebpl.264:15|
 :skolemid |418|
 :pattern ( ($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10))
)))
(assert  (and (and (forall ((arg0@@53 T@U) ) (! (let ((V@@0 (MapTypeInv1 (type arg0@@53))))
(= (type (|Map#Values| arg0@@53)) (MapType0Type V@@0 boolType)))
 :qid |funType:Map#Values|
 :pattern ( (|Map#Values| arg0@@53))
)) (forall ((arg0@@54 T@U) ) (! (= (type (|Map#Items| arg0@@54)) (MapType0Type BoxType boolType))
 :qid |funType:Map#Items|
 :pattern ( (|Map#Items| arg0@@54))
))) (forall ((arg0@@55 T@U) (arg1@@17 T@U) ) (! (= (type (Tclass._System.Tuple2 arg0@@55 arg1@@17)) TyType)
 :qid |funType:Tclass._System.Tuple2|
 :pattern ( (Tclass._System.Tuple2 arg0@@55 arg1@@17))
))))
(assert (forall ((v@@24 T@U) (t0@@10 T@U) (t1@@1 T@U) ) (!  (=> (and (and (and (= (type v@@24) (MapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) ($Is v@@24 (TMap t0@@10 t1@@1))) (and (and ($Is (|Map#Domain| v@@24) (TSet t0@@10)) ($Is (|Map#Values| v@@24) (TSet t1@@1))) ($Is (|Map#Items| v@@24) (TSet (Tclass._System.Tuple2 t0@@10 t1@@1)))))
 :qid |DafnyPreludebpl.272:15|
 :skolemid |419|
 :pattern ( ($Is v@@24 (TMap t0@@10 t1@@1)))
)))
(assert  (and (forall ((arg0@@56 T@U) ) (! (let ((V@@1 (IMapTypeInv1 (type arg0@@56))))
(let ((U@@1 (IMapTypeInv0 (type arg0@@56))))
(= (type (|IMap#Elements| arg0@@56)) (MapType0Type U@@1 V@@1))))
 :qid |funType:IMap#Elements|
 :pattern ( (|IMap#Elements| arg0@@56))
)) (forall ((arg0@@57 T@U) ) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@57))))
(= (type (|IMap#Domain| arg0@@57)) (MapType0Type U@@2 boolType)))
 :qid |funType:IMap#Domain|
 :pattern ( (|IMap#Domain| arg0@@57))
))))
(assert (forall ((v@@25 T@U) (t0@@11 T@U) (t1@@2 T@U) ) (!  (=> (and (and (= (type v@@25) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= ($Is v@@25 (TIMap t0@@11 t1@@2)) (forall ((bx@@18 T@U) ) (!  (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@25) bx@@18))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@25) bx@@18) t1@@2) ($IsBox bx@@18 t0@@11)))
 :qid |DafnyPreludebpl.282:19|
 :skolemid |420|
 :pattern ( (MapType0Select (|IMap#Elements| v@@25) bx@@18))
 :pattern ( (MapType0Select (|IMap#Domain| v@@25) bx@@18))
))))
 :qid |DafnyPreludebpl.279:15|
 :skolemid |421|
 :pattern ( ($Is v@@25 (TIMap t0@@11 t1@@2)))
)))
(assert (forall ((v@@26 T@U) (t0@@12 T@U) (t1@@3 T@U) (h@@11 T@U) ) (!  (=> (and (and (and (= (type v@@26) (IMapType BoxType BoxType)) (= (type t0@@12) TyType)) (= (type t1@@3) TyType)) (= (type h@@11) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11) (forall ((bx@@19 T@U) ) (!  (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@26) bx@@19))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@26) bx@@19) t1@@3 h@@11) ($IsAllocBox bx@@19 t0@@12 h@@11)))
 :qid |DafnyPreludebpl.290:19|
 :skolemid |422|
 :pattern ( (MapType0Select (|IMap#Elements| v@@26) bx@@19))
 :pattern ( (MapType0Select (|IMap#Domain| v@@26) bx@@19))
))))
 :qid |DafnyPreludebpl.287:15|
 :skolemid |423|
 :pattern ( ($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11))
)))
(assert  (and (forall ((arg0@@58 T@U) ) (! (let ((V@@2 (IMapTypeInv1 (type arg0@@58))))
(= (type (|IMap#Values| arg0@@58)) (MapType0Type V@@2 boolType)))
 :qid |funType:IMap#Values|
 :pattern ( (|IMap#Values| arg0@@58))
)) (forall ((arg0@@59 T@U) ) (! (= (type (|IMap#Items| arg0@@59)) (MapType0Type BoxType boolType))
 :qid |funType:IMap#Items|
 :pattern ( (|IMap#Items| arg0@@59))
))))
(assert (forall ((v@@27 T@U) (t0@@13 T@U) (t1@@4 T@U) ) (!  (=> (and (and (and (= (type v@@27) (IMapType BoxType BoxType)) (= (type t0@@13) TyType)) (= (type t1@@4) TyType)) ($Is v@@27 (TIMap t0@@13 t1@@4))) (and (and ($Is (|IMap#Domain| v@@27) (TISet t0@@13)) ($Is (|IMap#Values| v@@27) (TISet t1@@4))) ($Is (|IMap#Items| v@@27) (TISet (Tclass._System.Tuple2 t0@@13 t1@@4)))))
 :qid |DafnyPreludebpl.295:15|
 :skolemid |424|
 :pattern ( ($Is v@@27 (TIMap t0@@13 t1@@4)))
)))
(assert  (and (and (forall ((arg0@@60 T@U) (arg1@@18 T@U) ) (! (= (type (TypeTuple arg0@@60 arg1@@18)) ClassNameType)
 :qid |funType:TypeTuple|
 :pattern ( (TypeTuple arg0@@60 arg1@@18))
)) (forall ((arg0@@61 T@U) ) (! (= (type (TypeTupleCar arg0@@61)) ClassNameType)
 :qid |funType:TypeTupleCar|
 :pattern ( (TypeTupleCar arg0@@61))
))) (forall ((arg0@@62 T@U) ) (! (= (type (TypeTupleCdr arg0@@62)) ClassNameType)
 :qid |funType:TypeTupleCdr|
 :pattern ( (TypeTupleCdr arg0@@62))
))))
(assert (forall ((a@@1 T@U) (b@@1 T@U) ) (!  (=> (and (= (type a@@1) ClassNameType) (= (type b@@1) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a@@1 b@@1)) a@@1) (= (TypeTupleCdr (TypeTuple a@@1 b@@1)) b@@1)))
 :qid |DafnyPreludebpl.322:15|
 :skolemid |425|
 :pattern ( (TypeTuple a@@1 b@@1))
)))
(assert (forall ((arg0@@63 T@U) ) (! (= (type (SetRef_to_SetBox arg0@@63)) (MapType0Type BoxType boolType))
 :qid |funType:SetRef_to_SetBox|
 :pattern ( (SetRef_to_SetBox arg0@@63))
)))
(assert (forall ((s@@1 T@U) (bx@@20 T@U) ) (!  (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@20) BoxType)) (= (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@20)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@20)))))
 :qid |DafnyPreludebpl.331:15|
 :skolemid |426|
 :pattern ( (MapType0Select (SetRef_to_SetBox s@@1) bx@@20))
)))
(assert (= (type Tclass._System.object?) TyType))
(assert (forall ((s@@2 T@U) ) (!  (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object?)))
 :qid |DafnyPreludebpl.333:15|
 :skolemid |427|
 :pattern ( (SetRef_to_SetBox s@@2))
)))
(assert (= (Ctor DatatypeTypeType) 21))
(assert (forall ((d T@U) ) (!  (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d)))
 :qid |DafnyPreludebpl.352:15|
 :skolemid |428|
 :pattern ( (BoxRank ($Box d)))
)))
(assert (forall ((o T@U) ) (!  (=> (= (type o) BoxType) (<= 0 (|ORD#Offset| o)))
 :qid |DafnyPreludebpl.367:15|
 :skolemid |429|
 :pattern ( (|ORD#Offset| o))
)))
(assert (forall ((arg0@@64 Int) ) (! (= (type (|ORD#FromNat| arg0@@64)) BoxType)
 :qid |funType:ORD#FromNat|
 :pattern ( (|ORD#FromNat| arg0@@64))
)))
(assert (forall ((n@@0 Int) ) (!  (=> (<= 0 n@@0) (and (|ORD#IsNat| (|ORD#FromNat| n@@0)) (= (|ORD#Offset| (|ORD#FromNat| n@@0)) n@@0)))
 :qid |DafnyPreludebpl.373:15|
 :skolemid |430|
 :pattern ( (|ORD#FromNat| n@@0))
)))
(assert (forall ((o@@0 T@U) ) (!  (=> (and (= (type o@@0) BoxType) (|ORD#IsNat| o@@0)) (= o@@0 (|ORD#FromNat| (|ORD#Offset| o@@0))))
 :qid |DafnyPreludebpl.375:15|
 :skolemid |431|
 :pattern ( (|ORD#Offset| o@@0))
 :pattern ( (|ORD#IsNat| o@@0))
)))
(assert (forall ((o@@1 T@U) (p T@U) ) (!  (=> (and (= (type o@@1) BoxType) (= (type p) BoxType)) (and (and (and (=> (|ORD#Less| o@@1 p) (not (= o@@1 p))) (=> (and (|ORD#IsNat| o@@1) (not (|ORD#IsNat| p))) (|ORD#Less| o@@1 p))) (=> (and (|ORD#IsNat| o@@1) (|ORD#IsNat| p)) (= (|ORD#Less| o@@1 p) (< (|ORD#Offset| o@@1) (|ORD#Offset| p))))) (=> (and (|ORD#Less| o@@1 p) (|ORD#IsNat| p)) (|ORD#IsNat| o@@1))))
 :qid |DafnyPreludebpl.379:15|
 :skolemid |432|
 :pattern ( (|ORD#Less| o@@1 p))
)))
(assert (forall ((o@@2 T@U) (p@@0 T@U) ) (!  (=> (and (= (type o@@2) BoxType) (= (type p@@0) BoxType)) (or (or (|ORD#Less| o@@2 p@@0) (= o@@2 p@@0)) (|ORD#Less| p@@0 o@@2)))
 :qid |DafnyPreludebpl.385:15|
 :skolemid |433|
 :pattern ( (|ORD#Less| o@@2 p@@0) (|ORD#Less| p@@0 o@@2))
)))
(assert (forall ((o@@3 T@U) (p@@1 T@U) (r T@U) ) (!  (=> (and (and (and (= (type o@@3) BoxType) (= (type p@@1) BoxType)) (= (type r) BoxType)) (and (|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 r))) (|ORD#Less| o@@3 r))
 :qid |DafnyPreludebpl.388:15|
 :skolemid |434|
 :pattern ( (|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 r))
 :pattern ( (|ORD#Less| o@@3 p@@1) (|ORD#Less| o@@3 r))
)))
(assert (forall ((o@@4 T@U) (p@@2 T@U) ) (!  (=> (and (= (type o@@4) BoxType) (= (type p@@2) BoxType)) (= (|ORD#LessThanLimit| o@@4 p@@2) (|ORD#Less| o@@4 p@@2)))
 :qid |DafnyPreludebpl.395:15|
 :skolemid |435|
 :pattern ( (|ORD#LessThanLimit| o@@4 p@@2))
)))
(assert (forall ((arg0@@65 T@U) (arg1@@19 T@U) ) (! (= (type (|ORD#Plus| arg0@@65 arg1@@19)) BoxType)
 :qid |funType:ORD#Plus|
 :pattern ( (|ORD#Plus| arg0@@65 arg1@@19))
)))
(assert (forall ((o@@5 T@U) (p@@3 T@U) ) (!  (=> (and (= (type o@@5) BoxType) (= (type p@@3) BoxType)) (and (=> (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3)) (and (|ORD#IsNat| o@@5) (|ORD#IsNat| p@@3))) (=> (|ORD#IsNat| p@@3) (and (= (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3)) (|ORD#IsNat| o@@5)) (= (|ORD#Offset| (|ORD#Plus| o@@5 p@@3)) (+ (|ORD#Offset| o@@5) (|ORD#Offset| p@@3)))))))
 :qid |DafnyPreludebpl.399:15|
 :skolemid |436|
 :pattern ( (|ORD#Plus| o@@5 p@@3))
)))
(assert (forall ((o@@6 T@U) (p@@4 T@U) ) (!  (=> (and (= (type o@@6) BoxType) (= (type p@@4) BoxType)) (and (or (= o@@6 (|ORD#Plus| o@@6 p@@4)) (|ORD#Less| o@@6 (|ORD#Plus| o@@6 p@@4))) (or (= p@@4 (|ORD#Plus| o@@6 p@@4)) (|ORD#Less| p@@4 (|ORD#Plus| o@@6 p@@4)))))
 :qid |DafnyPreludebpl.404:15|
 :skolemid |437|
 :pattern ( (|ORD#Plus| o@@6 p@@4))
)))
(assert (forall ((o@@7 T@U) (p@@5 T@U) ) (!  (=> (and (= (type o@@7) BoxType) (= (type p@@5) BoxType)) (and (=> (= o@@7 (|ORD#FromNat| 0)) (= (|ORD#Plus| o@@7 p@@5) p@@5)) (=> (= p@@5 (|ORD#FromNat| 0)) (= (|ORD#Plus| o@@7 p@@5) o@@7))))
 :qid |DafnyPreludebpl.407:15|
 :skolemid |438|
 :pattern ( (|ORD#Plus| o@@7 p@@5))
)))
(assert (forall ((arg0@@66 T@U) (arg1@@20 T@U) ) (! (= (type (|ORD#Minus| arg0@@66 arg1@@20)) BoxType)
 :qid |funType:ORD#Minus|
 :pattern ( (|ORD#Minus| arg0@@66 arg1@@20))
)))
(assert (forall ((o@@8 T@U) (p@@6 T@U) ) (!  (=> (and (and (= (type o@@8) BoxType) (= (type p@@6) BoxType)) (and (|ORD#IsNat| p@@6) (<= (|ORD#Offset| p@@6) (|ORD#Offset| o@@8)))) (and (= (|ORD#IsNat| (|ORD#Minus| o@@8 p@@6)) (|ORD#IsNat| o@@8)) (= (|ORD#Offset| (|ORD#Minus| o@@8 p@@6)) (- (|ORD#Offset| o@@8) (|ORD#Offset| p@@6)))))
 :qid |DafnyPreludebpl.412:15|
 :skolemid |439|
 :pattern ( (|ORD#Minus| o@@8 p@@6))
)))
(assert (forall ((o@@9 T@U) (p@@7 T@U) ) (!  (=> (and (and (= (type o@@9) BoxType) (= (type p@@7) BoxType)) (and (|ORD#IsNat| p@@7) (<= (|ORD#Offset| p@@7) (|ORD#Offset| o@@9)))) (or (and (= p@@7 (|ORD#FromNat| 0)) (= (|ORD#Minus| o@@9 p@@7) o@@9)) (and (not (= p@@7 (|ORD#FromNat| 0))) (|ORD#Less| (|ORD#Minus| o@@9 p@@7) o@@9))))
 :qid |DafnyPreludebpl.416:15|
 :skolemid |440|
 :pattern ( (|ORD#Minus| o@@9 p@@7))
)))
(assert (forall ((o@@10 T@U) (m@@5 Int) (n@@1 Int) ) (!  (=> (= (type o@@10) BoxType) (=> (and (<= 0 m@@5) (<= 0 n@@1)) (= (|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5)) (|ORD#FromNat| n@@1)) (|ORD#Plus| o@@10 (|ORD#FromNat| (+ m@@5 n@@1))))))
 :qid |DafnyPreludebpl.422:15|
 :skolemid |441|
 :pattern ( (|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5)) (|ORD#FromNat| n@@1)))
)))
(assert (forall ((o@@11 T@U) (m@@6 Int) (n@@2 Int) ) (!  (=> (= (type o@@11) BoxType) (=> (and (and (<= 0 m@@6) (<= 0 n@@2)) (<= (+ m@@6 n@@2) (|ORD#Offset| o@@11))) (= (|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6)) (|ORD#FromNat| n@@2)) (|ORD#Minus| o@@11 (|ORD#FromNat| (+ m@@6 n@@2))))))
 :qid |DafnyPreludebpl.427:15|
 :skolemid |442|
 :pattern ( (|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6)) (|ORD#FromNat| n@@2)))
)))
(assert (forall ((o@@12 T@U) (m@@7 Int) (n@@3 Int) ) (!  (=> (= (type o@@12) BoxType) (=> (and (and (<= 0 m@@7) (<= 0 n@@3)) (<= n@@3 (+ (|ORD#Offset| o@@12) m@@7))) (and (=> (<= 0 (- m@@7 n@@3)) (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)) (|ORD#Plus| o@@12 (|ORD#FromNat| (- m@@7 n@@3))))) (=> (<= (- m@@7 n@@3) 0) (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)) (|ORD#Minus| o@@12 (|ORD#FromNat| (- n@@3 m@@7))))))))
 :qid |DafnyPreludebpl.432:15|
 :skolemid |443|
 :pattern ( (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)))
)))
(assert (forall ((o@@13 T@U) (m@@8 Int) (n@@4 Int) ) (!  (=> (= (type o@@13) BoxType) (=> (and (and (<= 0 m@@8) (<= 0 n@@4)) (<= n@@4 (+ (|ORD#Offset| o@@13) m@@8))) (and (=> (<= 0 (- m@@8 n@@4)) (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)) (|ORD#Minus| o@@13 (|ORD#FromNat| (- m@@8 n@@4))))) (=> (<= (- m@@8 n@@4) 0) (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)) (|ORD#Plus| o@@13 (|ORD#FromNat| (- n@@4 m@@8))))))))
 :qid |DafnyPreludebpl.438:15|
 :skolemid |444|
 :pattern ( (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)))
)))
(assert  (and (= (Ctor LayerTypeType) 22) (forall ((arg0@@67 T@U) (arg1@@21 T@U) ) (! (let ((A (MapType0TypeInv1 (type arg0@@67))))
(= (type (AtLayer arg0@@67 arg1@@21)) A))
 :qid |funType:AtLayer|
 :pattern ( (AtLayer arg0@@67 arg1@@21))
))))
(assert (forall ((f T@U) (ly T@U) ) (! (let ((A@@0 (MapType0TypeInv1 (type f))))
 (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly))))
 :qid |DafnyPreludebpl.462:18|
 :skolemid |445|
 :pattern ( (AtLayer f ly))
)))
(assert (forall ((arg0@@68 T@U) ) (! (= (type ($LS arg0@@68)) LayerTypeType)
 :qid |funType:$LS|
 :pattern ( ($LS arg0@@68))
)))
(assert (forall ((f@@0 T@U) (ly@@0 T@U) ) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0))))
 (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0))))
 :qid |DafnyPreludebpl.463:18|
 :skolemid |446|
 :pattern ( (AtLayer f@@0 ($LS ly@@0)))
)))
(assert (forall ((arg0@@69 Int) ) (! (= (type (IndexField arg0@@69)) (FieldType BoxType))
 :qid |funType:IndexField|
 :pattern ( (IndexField arg0@@69))
)))
(assert (forall ((i@@1 Int) ) (! (= (FDim (IndexField i@@1)) 1)
 :qid |DafnyPreludebpl.474:15|
 :skolemid |447|
 :pattern ( (IndexField i@@1))
)))
(assert (forall ((i@@2 Int) ) (! (= (IndexField_Inverse (IndexField i@@2)) i@@2)
 :qid |DafnyPreludebpl.476:15|
 :skolemid |448|
 :pattern ( (IndexField i@@2))
)))
(assert (forall ((arg0@@70 T@U) (arg1@@22 Int) ) (! (= (type (MultiIndexField arg0@@70 arg1@@22)) (FieldType BoxType))
 :qid |funType:MultiIndexField|
 :pattern ( (MultiIndexField arg0@@70 arg1@@22))
)))
(assert (forall ((f@@1 T@U) (i@@3 Int) ) (!  (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@3)) (+ (FDim f@@1) 1)))
 :qid |DafnyPreludebpl.479:15|
 :skolemid |449|
 :pattern ( (MultiIndexField f@@1 i@@3))
)))
(assert (forall ((arg0@@71 T@U) ) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@71))))
(= (type (MultiIndexField_Inverse0 arg0@@71)) (FieldType T@@3)))
 :qid |funType:MultiIndexField_Inverse0|
 :pattern ( (MultiIndexField_Inverse0 arg0@@71))
)))
(assert (forall ((f@@2 T@U) (i@@4 Int) ) (!  (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@4)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@4)) i@@4)))
 :qid |DafnyPreludebpl.482:15|
 :skolemid |450|
 :pattern ( (MultiIndexField f@@2 i@@4))
)))
(assert  (and (and (forall ((alpha@@3 T@T) (arg0@@72 T@U) (arg1@@23 T@U) ) (! (= (type (FieldOfDecl alpha@@3 arg0@@72 arg1@@23)) (FieldType alpha@@3))
 :qid |funType:FieldOfDecl|
 :pattern ( (FieldOfDecl alpha@@3 arg0@@72 arg1@@23))
)) (forall ((arg0@@73 T@U) ) (! (= (type (DeclType arg0@@73)) ClassNameType)
 :qid |funType:DeclType|
 :pattern ( (DeclType arg0@@73))
))) (forall ((arg0@@74 T@U) ) (! (= (type (DeclName arg0@@74)) NameFamilyType)
 :qid |funType:DeclName|
 :pattern ( (DeclName arg0@@74))
))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T) ) (!  (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm)))
 :qid |DafnyPreludebpl.491:18|
 :skolemid |451|
 :pattern ( (FieldOfDecl T@@4 cl nm))
)))
(assert (forall ((h@@12 T@U) (k T@U) (v@@28 T@U) (t@@21 T@U) ) (!  (=> (and (and (and (and (= (type h@@12) (MapType0Type refType MapType1Type)) (= (type k) (MapType0Type refType MapType1Type))) (= (type t@@21) TyType)) ($HeapSucc h@@12 k)) ($IsAlloc v@@28 t@@21 h@@12)) ($IsAlloc v@@28 t@@21 k))
 :qid |DafnyPreludebpl.504:17|
 :skolemid |452|
 :pattern ( ($HeapSucc h@@12 k) ($IsAlloc v@@28 t@@21 h@@12))
)))
(assert (forall ((h@@13 T@U) (k@@0 T@U) (bx@@21 T@U) (t@@22 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@13) (MapType0Type refType MapType1Type)) (= (type k@@0) (MapType0Type refType MapType1Type))) (= (type bx@@21) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@13 k@@0)) ($IsAllocBox bx@@21 t@@22 h@@13)) ($IsAllocBox bx@@21 t@@22 k@@0))
 :qid |DafnyPreludebpl.507:14|
 :skolemid |453|
 :pattern ( ($HeapSucc h@@13 k@@0) ($IsAllocBox bx@@21 t@@22 h@@13))
)))
(assert (= (FDim alloc) 0))
(assert (= (DeclName alloc) allocName))
(assert  (not ($IsGhostField alloc)))
(assert (forall ((o@@14 T@U) ) (!  (=> (= (type o@@14) refType) (<= 0 (_System.array.Length o@@14)))
 :qid |DafnyPreludebpl.524:15|
 :skolemid |454|
 :no-pattern (type o@@14)
 :no-pattern (U_2_int o@@14)
 :no-pattern (U_2_bool o@@14)
)))
(assert (forall ((x@@15 Real) ) (! (= (q@Int x@@15) (to_int x@@15))
 :qid |DafnyPreludebpl.530:14|
 :skolemid |455|
 :pattern ( (q@Int x@@15))
)))
(assert (forall ((x@@16 Int) ) (! (= (q@Real x@@16) (to_real x@@16))
 :qid |DafnyPreludebpl.531:15|
 :skolemid |456|
 :pattern ( (q@Real x@@16))
)))
(assert (forall ((i@@5 Int) ) (! (= (q@Int (q@Real i@@5)) i@@5)
 :qid |DafnyPreludebpl.532:15|
 :skolemid |457|
 :pattern ( (q@Int (q@Real i@@5)))
)))
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type)))
(assert ($IsGoodHeap $OneHeap))
(assert (forall ((h@@14 T@U) (r@@0 T@U) (f@@3 T@U) (x@@17 T@U) ) (! (let ((alpha@@4 (type x@@17)))
 (=> (and (and (and (= (type h@@14) (MapType0Type refType MapType1Type)) (= (type r@@0) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))) ($HeapSucc h@@14 (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))))
 :qid |DafnyPreludebpl.554:22|
 :skolemid |458|
 :pattern ( (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))
)))
(assert (forall ((a@@2 T@U) (b@@2 T@U) (c T@U) ) (!  (=> (and (and (and (and (= (type a@@2) (MapType0Type refType MapType1Type)) (= (type b@@2) (MapType0Type refType MapType1Type))) (= (type c) (MapType0Type refType MapType1Type))) (not (= a@@2 c))) (and ($HeapSucc a@@2 b@@2) ($HeapSucc b@@2 c))) ($HeapSucc a@@2 c))
 :qid |DafnyPreludebpl.557:15|
 :skolemid |459|
 :pattern ( ($HeapSucc a@@2 b@@2) ($HeapSucc b@@2 c))
)))
(assert (forall ((h@@15 T@U) (k@@1 T@U) ) (!  (=> (and (and (= (type h@@15) (MapType0Type refType MapType1Type)) (= (type k@@1) (MapType0Type refType MapType1Type))) ($HeapSucc h@@15 k@@1)) (forall ((o@@15 T@U) ) (!  (=> (and (= (type o@@15) refType) (U_2_bool (MapType1Select (MapType0Select h@@15 o@@15) alloc))) (U_2_bool (MapType1Select (MapType0Select k@@1 o@@15) alloc)))
 :qid |DafnyPreludebpl.560:30|
 :skolemid |460|
 :pattern ( (MapType1Select (MapType0Select k@@1 o@@15) alloc))
)))
 :qid |DafnyPreludebpl.559:15|
 :skolemid |461|
 :pattern ( ($HeapSucc h@@15 k@@1))
)))
(assert (forall ((h@@16 T@U) (k@@2 T@U) ) (!  (=> (and (and (= (type h@@16) (MapType0Type refType MapType1Type)) (= (type k@@2) (MapType0Type refType MapType1Type))) ($HeapSuccGhost h@@16 k@@2)) (and ($HeapSucc h@@16 k@@2) (forall ((o@@16 T@U) (f@@4 T@U) ) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4))))
 (=> (and (and (= (type o@@16) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select (MapType0Select h@@16 o@@16) f@@4) (MapType1Select (MapType0Select k@@2 o@@16) f@@4))))
 :qid |DafnyPreludebpl.566:20|
 :skolemid |462|
 :pattern ( (MapType1Select (MapType0Select k@@2 o@@16) f@@4))
))))
 :qid |DafnyPreludebpl.563:15|
 :skolemid |463|
 :pattern ( ($HeapSuccGhost h@@16 k@@2))
)))
(assert (forall ((s@@3 T@U) ) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3))))
 (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3))))
 :qid |DafnyPreludebpl.624:18|
 :skolemid |468|
 :pattern ( (|Set#Card| s@@3))
)))
(assert (forall ((T@@6 T@T) ) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType))
 :qid |funType:Set#Empty|
 :pattern ( (|Set#Empty| T@@6))
)))
(assert (forall ((o@@17 T@U) ) (! (let ((T@@7 (type o@@17)))
 (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@17))))
 :qid |DafnyPreludebpl.627:18|
 :skolemid |469|
 :pattern ( (let ((T@@7 (type o@@17)))
(MapType0Select (|Set#Empty| T@@7) o@@17)))
)))
(assert (forall ((s@@4 T@U) ) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4))))
 (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (= (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@18 T@U) ) (!  (and (= (type x@@18) T@@8) (U_2_bool (MapType0Select s@@4 x@@18)))
 :qid |DafnyPreludebpl.630:33|
 :skolemid |470|
 :no-pattern (type x@@18)
 :no-pattern (U_2_int x@@18)
 :no-pattern (U_2_bool x@@18)
))))))
 :qid |DafnyPreludebpl.628:18|
 :skolemid |471|
 :pattern ( (|Set#Card| s@@4))
)))
(assert (forall ((arg0@@75 T@U) ) (! (let ((T@@9 (type arg0@@75)))
(= (type (|Set#Singleton| arg0@@75)) (MapType0Type T@@9 boolType)))
 :qid |funType:Set#Singleton|
 :pattern ( (|Set#Singleton| arg0@@75))
)))
(assert (forall ((r@@1 T@U) ) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@1) r@@1))
 :qid |DafnyPreludebpl.636:18|
 :skolemid |472|
 :pattern ( (|Set#Singleton| r@@1))
)))
(assert (forall ((r@@2 T@U) (o@@18 T@U) ) (! (let ((T@@10 (type r@@2)))
 (=> (= (type o@@18) T@@10) (= (U_2_bool (MapType0Select (|Set#Singleton| r@@2) o@@18)) (= r@@2 o@@18))))
 :qid |DafnyPreludebpl.637:18|
 :skolemid |473|
 :pattern ( (MapType0Select (|Set#Singleton| r@@2) o@@18))
)))
(assert (forall ((r@@3 T@U) ) (! (= (|Set#Card| (|Set#Singleton| r@@3)) 1)
 :qid |DafnyPreludebpl.638:18|
 :skolemid |474|
 :pattern ( (|Set#Card| (|Set#Singleton| r@@3)))
)))
(assert (forall ((arg0@@76 T@U) (arg1@@24 T@U) ) (! (let ((T@@11 (type arg1@@24)))
(= (type (|Set#UnionOne| arg0@@76 arg1@@24)) (MapType0Type T@@11 boolType)))
 :qid |funType:Set#UnionOne|
 :pattern ( (|Set#UnionOne| arg0@@76 arg1@@24))
)))
(assert (forall ((a@@3 T@U) (x@@19 T@U) (o@@19 T@U) ) (! (let ((T@@12 (type x@@19)))
 (=> (and (= (type a@@3) (MapType0Type T@@12 boolType)) (= (type o@@19) T@@12)) (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))  (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))))
 :qid |DafnyPreludebpl.641:18|
 :skolemid |475|
 :pattern ( (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))
)))
(assert (forall ((a@@4 T@U) (x@@20 T@U) ) (! (let ((T@@13 (type x@@20)))
 (=> (= (type a@@4) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20))))
 :qid |DafnyPreludebpl.643:18|
 :skolemid |476|
 :pattern ( (|Set#UnionOne| a@@4 x@@20))
)))
(assert (forall ((a@@5 T@U) (x@@21 T@U) (y@@1 T@U) ) (! (let ((T@@14 (type x@@21)))
 (=> (and (and (= (type a@@5) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@5 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@5 x@@21) y@@1))))
 :qid |DafnyPreludebpl.645:18|
 :skolemid |477|
 :pattern ( (|Set#UnionOne| a@@5 x@@21) (MapType0Select a@@5 y@@1))
)))
(assert (forall ((a@@6 T@U) (x@@22 T@U) ) (! (let ((T@@15 (type x@@22)))
 (=> (and (= (type a@@6) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@6 x@@22))) (= (|Set#Card| (|Set#UnionOne| a@@6 x@@22)) (|Set#Card| a@@6))))
 :qid |DafnyPreludebpl.647:18|
 :skolemid |478|
 :pattern ( (|Set#Card| (|Set#UnionOne| a@@6 x@@22)))
)))
(assert (forall ((a@@7 T@U) (x@@23 T@U) ) (! (let ((T@@16 (type x@@23)))
 (=> (and (= (type a@@7) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@7 x@@23)))) (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))))
 :qid |DafnyPreludebpl.649:18|
 :skolemid |479|
 :pattern ( (|Set#Card| (|Set#UnionOne| a@@7 x@@23)))
)))
(assert (forall ((arg0@@77 T@U) (arg1@@25 T@U) ) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@77))))
(= (type (|Set#Union| arg0@@77 arg1@@25)) (MapType0Type T@@17 boolType)))
 :qid |funType:Set#Union|
 :pattern ( (|Set#Union| arg0@@77 arg1@@25))
)))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (o@@20 T@U) ) (! (let ((T@@18 (type o@@20)))
 (=> (and (= (type a@@8) (MapType0Type T@@18 boolType)) (= (type b@@3) (MapType0Type T@@18 boolType))) (= (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))  (or (U_2_bool (MapType0Select a@@8 o@@20)) (U_2_bool (MapType0Select b@@3 o@@20))))))
 :qid |DafnyPreludebpl.653:18|
 :skolemid |480|
 :pattern ( (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))
)))
(assert (forall ((a@@9 T@U) (b@@4 T@U) (y@@2 T@U) ) (! (let ((T@@19 (type y@@2)))
 (=> (and (and (= (type a@@9) (MapType0Type T@@19 boolType)) (= (type b@@4) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@9 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@9 b@@4) y@@2))))
 :qid |DafnyPreludebpl.655:18|
 :skolemid |481|
 :pattern ( (|Set#Union| a@@9 b@@4) (MapType0Select a@@9 y@@2))
)))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (y@@3 T@U) ) (! (let ((T@@20 (type y@@3)))
 (=> (and (and (= (type a@@10) (MapType0Type T@@20 boolType)) (= (type b@@5) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@5 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@10 b@@5) y@@3))))
 :qid |DafnyPreludebpl.657:18|
 :skolemid |482|
 :pattern ( (|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3))
)))
(assert (forall ((arg0@@78 T@U) (arg1@@26 T@U) ) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@78))))
(= (type (|Set#Difference| arg0@@78 arg1@@26)) (MapType0Type T@@21 boolType)))
 :qid |funType:Set#Difference|
 :pattern ( (|Set#Difference| arg0@@78 arg1@@26))
)))
(assert (forall ((a@@11 T@U) (b@@6 T@U) ) (! (let ((T@@22 (MapType0TypeInv0 (type a@@11))))
 (=> (and (and (= (type a@@11) (MapType0Type T@@22 boolType)) (= (type b@@6) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@11 b@@6)) (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6) (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))))
 :qid |DafnyPreludebpl.659:18|
 :skolemid |483|
 :pattern ( (|Set#Union| a@@11 b@@6))
)))
(assert (forall ((arg0@@79 T@U) (arg1@@27 T@U) ) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@79))))
(= (type (|Set#Intersection| arg0@@79 arg1@@27)) (MapType0Type T@@23 boolType)))
 :qid |funType:Set#Intersection|
 :pattern ( (|Set#Intersection| arg0@@79 arg1@@27))
)))
(assert (forall ((a@@12 T@U) (b@@7 T@U) (o@@21 T@U) ) (! (let ((T@@24 (type o@@21)))
 (=> (and (= (type a@@12) (MapType0Type T@@24 boolType)) (= (type b@@7) (MapType0Type T@@24 boolType))) (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))  (and (U_2_bool (MapType0Select a@@12 o@@21)) (U_2_bool (MapType0Select b@@7 o@@21))))))
 :qid |DafnyPreludebpl.669:18|
 :skolemid |484|
 :pattern ( (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))
)))
(assert (forall ((a@@13 T@U) (b@@8 T@U) ) (! (let ((T@@25 (MapType0TypeInv0 (type a@@13))))
 (=> (and (= (type a@@13) (MapType0Type T@@25 boolType)) (= (type b@@8) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8) (|Set#Union| a@@13 b@@8))))
 :qid |DafnyPreludebpl.672:18|
 :skolemid |485|
 :pattern ( (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8))
)))
(assert (forall ((a@@14 T@U) (b@@9 T@U) ) (! (let ((T@@26 (MapType0TypeInv0 (type a@@14))))
 (=> (and (= (type a@@14) (MapType0Type T@@26 boolType)) (= (type b@@9) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)) (|Set#Union| a@@14 b@@9))))
 :qid |DafnyPreludebpl.674:18|
 :skolemid |486|
 :pattern ( (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)))
)))
(assert (forall ((a@@15 T@U) (b@@10 T@U) ) (! (let ((T@@27 (MapType0TypeInv0 (type a@@15))))
 (=> (and (= (type a@@15) (MapType0Type T@@27 boolType)) (= (type b@@10) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10) (|Set#Intersection| a@@15 b@@10))))
 :qid |DafnyPreludebpl.676:18|
 :skolemid |487|
 :pattern ( (|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10))
)))
(assert (forall ((a@@16 T@U) (b@@11 T@U) ) (! (let ((T@@28 (MapType0TypeInv0 (type a@@16))))
 (=> (and (= (type a@@16) (MapType0Type T@@28 boolType)) (= (type b@@11) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11)) (|Set#Intersection| a@@16 b@@11))))
 :qid |DafnyPreludebpl.678:18|
 :skolemid |488|
 :pattern ( (|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11)))
)))
(assert (forall ((a@@17 T@U) (b@@12 T@U) ) (! (let ((T@@29 (MapType0TypeInv0 (type a@@17))))
 (=> (and (= (type a@@17) (MapType0Type T@@29 boolType)) (= (type b@@12) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@17 b@@12)) (|Set#Card| (|Set#Intersection| a@@17 b@@12))) (+ (|Set#Card| a@@17) (|Set#Card| b@@12)))))
 :qid |DafnyPreludebpl.680:18|
 :skolemid |489|
 :pattern ( (|Set#Card| (|Set#Union| a@@17 b@@12)))
 :pattern ( (|Set#Card| (|Set#Intersection| a@@17 b@@12)))
)))
(assert (forall ((a@@18 T@U) (b@@13 T@U) (o@@22 T@U) ) (! (let ((T@@30 (type o@@22)))
 (=> (and (= (type a@@18) (MapType0Type T@@30 boolType)) (= (type b@@13) (MapType0Type T@@30 boolType))) (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))  (and (U_2_bool (MapType0Select a@@18 o@@22)) (not (U_2_bool (MapType0Select b@@13 o@@22)))))))
 :qid |DafnyPreludebpl.684:18|
 :skolemid |490|
 :pattern ( (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))
)))
(assert (forall ((a@@19 T@U) (b@@14 T@U) (y@@4 T@U) ) (! (let ((T@@31 (type y@@4)))
 (=> (and (and (= (type a@@19) (MapType0Type T@@31 boolType)) (= (type b@@14) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@14 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14) y@@4)))))
 :qid |DafnyPreludebpl.686:18|
 :skolemid |491|
 :pattern ( (|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4))
)))
(assert (forall ((a@@20 T@U) (b@@15 T@U) ) (! (let ((T@@32 (MapType0TypeInv0 (type a@@20))))
 (=> (and (= (type a@@20) (MapType0Type T@@32 boolType)) (= (type b@@15) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@20 b@@15)) (|Set#Card| (|Set#Difference| b@@15 a@@20))) (|Set#Card| (|Set#Intersection| a@@20 b@@15))) (|Set#Card| (|Set#Union| a@@20 b@@15))) (= (|Set#Card| (|Set#Difference| a@@20 b@@15)) (- (|Set#Card| a@@20) (|Set#Card| (|Set#Intersection| a@@20 b@@15)))))))
 :qid |DafnyPreludebpl.688:18|
 :skolemid |492|
 :pattern ( (|Set#Card| (|Set#Difference| a@@20 b@@15)))
)))
(assert (forall ((a@@21 T@U) (b@@16 T@U) ) (! (let ((T@@33 (MapType0TypeInv0 (type a@@21))))
 (=> (and (= (type a@@21) (MapType0Type T@@33 boolType)) (= (type b@@16) (MapType0Type T@@33 boolType))) (= (|Set#Subset| a@@21 b@@16) (forall ((o@@23 T@U) ) (!  (=> (and (= (type o@@23) T@@33) (U_2_bool (MapType0Select a@@21 o@@23))) (U_2_bool (MapType0Select b@@16 o@@23)))
 :qid |DafnyPreludebpl.697:32|
 :skolemid |493|
 :pattern ( (MapType0Select a@@21 o@@23))
 :pattern ( (MapType0Select b@@16 o@@23))
)))))
 :qid |DafnyPreludebpl.696:17|
 :skolemid |494|
 :pattern ( (|Set#Subset| a@@21 b@@16))
)))
(assert (forall ((a@@22 T@U) (b@@17 T@U) ) (! (let ((T@@34 (MapType0TypeInv0 (type a@@22))))
 (=> (and (= (type a@@22) (MapType0Type T@@34 boolType)) (= (type b@@17) (MapType0Type T@@34 boolType))) (= (|Set#Equal| a@@22 b@@17) (forall ((o@@24 T@U) ) (!  (=> (= (type o@@24) T@@34) (= (U_2_bool (MapType0Select a@@22 o@@24)) (U_2_bool (MapType0Select b@@17 o@@24))))
 :qid |DafnyPreludebpl.705:31|
 :skolemid |495|
 :pattern ( (MapType0Select a@@22 o@@24))
 :pattern ( (MapType0Select b@@17 o@@24))
)))))
 :qid |DafnyPreludebpl.704:17|
 :skolemid |496|
 :pattern ( (|Set#Equal| a@@22 b@@17))
)))
(assert (forall ((a@@23 T@U) (b@@18 T@U) ) (! (let ((T@@35 (MapType0TypeInv0 (type a@@23))))
 (=> (and (and (= (type a@@23) (MapType0Type T@@35 boolType)) (= (type b@@18) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@23 b@@18)) (= a@@23 b@@18)))
 :qid |DafnyPreludebpl.706:17|
 :skolemid |497|
 :pattern ( (|Set#Equal| a@@23 b@@18))
)))
(assert (forall ((a@@24 T@U) (b@@19 T@U) ) (! (let ((T@@36 (MapType0TypeInv0 (type a@@24))))
 (=> (and (= (type a@@24) (MapType0Type T@@36 boolType)) (= (type b@@19) (MapType0Type T@@36 boolType))) (= (|Set#Disjoint| a@@24 b@@19) (forall ((o@@25 T@U) ) (!  (=> (= (type o@@25) T@@36) (or (not (U_2_bool (MapType0Select a@@24 o@@25))) (not (U_2_bool (MapType0Select b@@19 o@@25)))))
 :qid |DafnyPreludebpl.711:34|
 :skolemid |498|
 :pattern ( (MapType0Select a@@24 o@@25))
 :pattern ( (MapType0Select b@@19 o@@25))
)))))
 :qid |DafnyPreludebpl.710:18|
 :skolemid |499|
 :pattern ( (|Set#Disjoint| a@@24 b@@19))
)))
(assert (forall ((T@@37 T@T) ) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType))
 :qid |funType:ISet#Empty|
 :pattern ( (|ISet#Empty| T@@37))
)))
(assert (forall ((o@@26 T@U) ) (! (let ((T@@38 (type o@@26)))
 (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@26))))
 :qid |DafnyPreludebpl.720:18|
 :skolemid |500|
 :pattern ( (let ((T@@38 (type o@@26)))
(MapType0Select (|ISet#Empty| T@@38) o@@26)))
)))
(assert (forall ((arg0@@80 T@U) (arg1@@28 T@U) ) (! (let ((T@@39 (type arg1@@28)))
(= (type (|ISet#UnionOne| arg0@@80 arg1@@28)) (MapType0Type T@@39 boolType)))
 :qid |funType:ISet#UnionOne|
 :pattern ( (|ISet#UnionOne| arg0@@80 arg1@@28))
)))
(assert (forall ((a@@25 T@U) (x@@24 T@U) (o@@27 T@U) ) (! (let ((T@@40 (type x@@24)))
 (=> (and (= (type a@@25) (MapType0Type T@@40 boolType)) (= (type o@@27) T@@40)) (= (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@24) o@@27))  (or (= o@@27 x@@24) (U_2_bool (MapType0Select a@@25 o@@27))))))
 :qid |DafnyPreludebpl.727:18|
 :skolemid |501|
 :pattern ( (MapType0Select (|ISet#UnionOne| a@@25 x@@24) o@@27))
)))
(assert (forall ((a@@26 T@U) (x@@25 T@U) ) (! (let ((T@@41 (type x@@25)))
 (=> (= (type a@@26) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@26 x@@25) x@@25))))
 :qid |DafnyPreludebpl.729:18|
 :skolemid |502|
 :pattern ( (|ISet#UnionOne| a@@26 x@@25))
)))
(assert (forall ((a@@27 T@U) (x@@26 T@U) (y@@5 T@U) ) (! (let ((T@@42 (type x@@26)))
 (=> (and (and (= (type a@@27) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@27 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@27 x@@26) y@@5))))
 :qid |DafnyPreludebpl.731:18|
 :skolemid |503|
 :pattern ( (|ISet#UnionOne| a@@27 x@@26) (MapType0Select a@@27 y@@5))
)))
(assert (forall ((arg0@@81 T@U) (arg1@@29 T@U) ) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@81))))
(= (type (|ISet#Union| arg0@@81 arg1@@29)) (MapType0Type T@@43 boolType)))
 :qid |funType:ISet#Union|
 :pattern ( (|ISet#Union| arg0@@81 arg1@@29))
)))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (o@@28 T@U) ) (! (let ((T@@44 (type o@@28)))
 (=> (and (= (type a@@28) (MapType0Type T@@44 boolType)) (= (type b@@20) (MapType0Type T@@44 boolType))) (= (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))  (or (U_2_bool (MapType0Select a@@28 o@@28)) (U_2_bool (MapType0Select b@@20 o@@28))))))
 :qid |DafnyPreludebpl.735:18|
 :skolemid |504|
 :pattern ( (MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))
)))
(assert (forall ((a@@29 T@U) (b@@21 T@U) (y@@6 T@U) ) (! (let ((T@@45 (type y@@6)))
 (=> (and (and (= (type a@@29) (MapType0Type T@@45 boolType)) (= (type b@@21) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@29 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@29 b@@21) y@@6))))
 :qid |DafnyPreludebpl.737:18|
 :skolemid |505|
 :pattern ( (|ISet#Union| a@@29 b@@21) (MapType0Select a@@29 y@@6))
)))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (y@@7 T@U) ) (! (let ((T@@46 (type y@@7)))
 (=> (and (and (= (type a@@30) (MapType0Type T@@46 boolType)) (= (type b@@22) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@22 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@30 b@@22) y@@7))))
 :qid |DafnyPreludebpl.739:18|
 :skolemid |506|
 :pattern ( (|ISet#Union| a@@30 b@@22) (MapType0Select b@@22 y@@7))
)))
(assert (forall ((arg0@@82 T@U) (arg1@@30 T@U) ) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@82))))
(= (type (|ISet#Difference| arg0@@82 arg1@@30)) (MapType0Type T@@47 boolType)))
 :qid |funType:ISet#Difference|
 :pattern ( (|ISet#Difference| arg0@@82 arg1@@30))
)))
(assert (forall ((a@@31 T@U) (b@@23 T@U) ) (! (let ((T@@48 (MapType0TypeInv0 (type a@@31))))
 (=> (and (and (= (type a@@31) (MapType0Type T@@48 boolType)) (= (type b@@23) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@31 b@@23)) (and (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) a@@31) b@@23) (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) b@@23) a@@31))))
 :qid |DafnyPreludebpl.741:18|
 :skolemid |507|
 :pattern ( (|ISet#Union| a@@31 b@@23))
)))
(assert (forall ((arg0@@83 T@U) (arg1@@31 T@U) ) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@83))))
(= (type (|ISet#Intersection| arg0@@83 arg1@@31)) (MapType0Type T@@49 boolType)))
 :qid |funType:ISet#Intersection|
 :pattern ( (|ISet#Intersection| arg0@@83 arg1@@31))
)))
(assert (forall ((a@@32 T@U) (b@@24 T@U) (o@@29 T@U) ) (! (let ((T@@50 (type o@@29)))
 (=> (and (= (type a@@32) (MapType0Type T@@50 boolType)) (= (type b@@24) (MapType0Type T@@50 boolType))) (= (U_2_bool (MapType0Select (|ISet#Intersection| a@@32 b@@24) o@@29))  (and (U_2_bool (MapType0Select a@@32 o@@29)) (U_2_bool (MapType0Select b@@24 o@@29))))))
 :qid |DafnyPreludebpl.747:18|
 :skolemid |508|
 :pattern ( (MapType0Select (|ISet#Intersection| a@@32 b@@24) o@@29))
)))
(assert (forall ((a@@33 T@U) (b@@25 T@U) ) (! (let ((T@@51 (MapType0TypeInv0 (type a@@33))))
 (=> (and (= (type a@@33) (MapType0Type T@@51 boolType)) (= (type b@@25) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25) (|ISet#Union| a@@33 b@@25))))
 :qid |DafnyPreludebpl.750:18|
 :skolemid |509|
 :pattern ( (|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25))
)))
(assert (forall ((a@@34 T@U) (b@@26 T@U) ) (! (let ((T@@52 (MapType0TypeInv0 (type a@@34))))
 (=> (and (= (type a@@34) (MapType0Type T@@52 boolType)) (= (type b@@26) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26)) (|ISet#Union| a@@34 b@@26))))
 :qid |DafnyPreludebpl.752:18|
 :skolemid |510|
 :pattern ( (|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26)))
)))
(assert (forall ((a@@35 T@U) (b@@27 T@U) ) (! (let ((T@@53 (MapType0TypeInv0 (type a@@35))))
 (=> (and (= (type a@@35) (MapType0Type T@@53 boolType)) (= (type b@@27) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27) (|ISet#Intersection| a@@35 b@@27))))
 :qid |DafnyPreludebpl.754:18|
 :skolemid |511|
 :pattern ( (|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27))
)))
(assert (forall ((a@@36 T@U) (b@@28 T@U) ) (! (let ((T@@54 (MapType0TypeInv0 (type a@@36))))
 (=> (and (= (type a@@36) (MapType0Type T@@54 boolType)) (= (type b@@28) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28)) (|ISet#Intersection| a@@36 b@@28))))
 :qid |DafnyPreludebpl.756:18|
 :skolemid |512|
 :pattern ( (|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28)))
)))
(assert (forall ((a@@37 T@U) (b@@29 T@U) (o@@30 T@U) ) (! (let ((T@@55 (type o@@30)))
 (=> (and (= (type a@@37) (MapType0Type T@@55 boolType)) (= (type b@@29) (MapType0Type T@@55 boolType))) (= (U_2_bool (MapType0Select (|ISet#Difference| a@@37 b@@29) o@@30))  (and (U_2_bool (MapType0Select a@@37 o@@30)) (not (U_2_bool (MapType0Select b@@29 o@@30)))))))
 :qid |DafnyPreludebpl.761:18|
 :skolemid |513|
 :pattern ( (MapType0Select (|ISet#Difference| a@@37 b@@29) o@@30))
)))
(assert (forall ((a@@38 T@U) (b@@30 T@U) (y@@8 T@U) ) (! (let ((T@@56 (type y@@8)))
 (=> (and (and (= (type a@@38) (MapType0Type T@@56 boolType)) (= (type b@@30) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@30 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@38 b@@30) y@@8)))))
 :qid |DafnyPreludebpl.763:18|
 :skolemid |514|
 :pattern ( (|ISet#Difference| a@@38 b@@30) (MapType0Select b@@30 y@@8))
)))
(assert (forall ((a@@39 T@U) (b@@31 T@U) ) (! (let ((T@@57 (MapType0TypeInv0 (type a@@39))))
 (=> (and (= (type a@@39) (MapType0Type T@@57 boolType)) (= (type b@@31) (MapType0Type T@@57 boolType))) (= (|ISet#Subset| a@@39 b@@31) (forall ((o@@31 T@U) ) (!  (=> (and (= (type o@@31) T@@57) (U_2_bool (MapType0Select a@@39 o@@31))) (U_2_bool (MapType0Select b@@31 o@@31)))
 :qid |DafnyPreludebpl.768:33|
 :skolemid |515|
 :pattern ( (MapType0Select a@@39 o@@31))
 :pattern ( (MapType0Select b@@31 o@@31))
)))))
 :qid |DafnyPreludebpl.767:17|
 :skolemid |516|
 :pattern ( (|ISet#Subset| a@@39 b@@31))
)))
(assert (forall ((a@@40 T@U) (b@@32 T@U) ) (! (let ((T@@58 (MapType0TypeInv0 (type a@@40))))
 (=> (and (= (type a@@40) (MapType0Type T@@58 boolType)) (= (type b@@32) (MapType0Type T@@58 boolType))) (= (|ISet#Equal| a@@40 b@@32) (forall ((o@@32 T@U) ) (!  (=> (= (type o@@32) T@@58) (= (U_2_bool (MapType0Select a@@40 o@@32)) (U_2_bool (MapType0Select b@@32 o@@32))))
 :qid |DafnyPreludebpl.772:32|
 :skolemid |517|
 :pattern ( (MapType0Select a@@40 o@@32))
 :pattern ( (MapType0Select b@@32 o@@32))
)))))
 :qid |DafnyPreludebpl.771:17|
 :skolemid |518|
 :pattern ( (|ISet#Equal| a@@40 b@@32))
)))
(assert (forall ((a@@41 T@U) (b@@33 T@U) ) (! (let ((T@@59 (MapType0TypeInv0 (type a@@41))))
 (=> (and (and (= (type a@@41) (MapType0Type T@@59 boolType)) (= (type b@@33) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@41 b@@33)) (= a@@41 b@@33)))
 :qid |DafnyPreludebpl.773:17|
 :skolemid |519|
 :pattern ( (|ISet#Equal| a@@41 b@@33))
)))
(assert (forall ((a@@42 T@U) (b@@34 T@U) ) (! (let ((T@@60 (MapType0TypeInv0 (type a@@42))))
 (=> (and (= (type a@@42) (MapType0Type T@@60 boolType)) (= (type b@@34) (MapType0Type T@@60 boolType))) (= (|ISet#Disjoint| a@@42 b@@34) (forall ((o@@33 T@U) ) (!  (=> (= (type o@@33) T@@60) (or (not (U_2_bool (MapType0Select a@@42 o@@33))) (not (U_2_bool (MapType0Select b@@34 o@@33)))))
 :qid |DafnyPreludebpl.778:35|
 :skolemid |520|
 :pattern ( (MapType0Select a@@42 o@@33))
 :pattern ( (MapType0Select b@@34 o@@33))
)))))
 :qid |DafnyPreludebpl.777:18|
 :skolemid |521|
 :pattern ( (|ISet#Disjoint| a@@42 b@@34))
)))
(assert (forall ((a@@43 Int) (b@@35 Int) ) (! (= (<= a@@43 b@@35) (= (|Math#min| a@@43 b@@35) a@@43))
 :qid |DafnyPreludebpl.785:15|
 :skolemid |522|
 :pattern ( (|Math#min| a@@43 b@@35))
)))
(assert (forall ((a@@44 Int) (b@@36 Int) ) (! (= (<= b@@36 a@@44) (= (|Math#min| a@@44 b@@36) b@@36))
 :qid |DafnyPreludebpl.786:15|
 :skolemid |523|
 :pattern ( (|Math#min| a@@44 b@@36))
)))
(assert (forall ((a@@45 Int) (b@@37 Int) ) (!  (or (= (|Math#min| a@@45 b@@37) a@@45) (= (|Math#min| a@@45 b@@37) b@@37))
 :qid |DafnyPreludebpl.787:15|
 :skolemid |524|
 :pattern ( (|Math#min| a@@45 b@@37))
)))
(assert (forall ((a@@46 Int) ) (!  (=> (<= 0 a@@46) (= (|Math#clip| a@@46) a@@46))
 :qid |DafnyPreludebpl.790:15|
 :skolemid |525|
 :pattern ( (|Math#clip| a@@46))
)))
(assert (forall ((a@@47 Int) ) (!  (=> (< a@@47 0) (= (|Math#clip| a@@47) 0))
 :qid |DafnyPreludebpl.791:15|
 :skolemid |526|
 :pattern ( (|Math#clip| a@@47))
)))
(assert (forall ((ms T@U) ) (! (let ((T@@61 (MapType0TypeInv0 (type ms))))
 (=> (= (type ms) (MapType0Type T@@61 intType)) (= ($IsGoodMultiSet ms) (forall ((bx@@22 T@U) ) (!  (=> (= (type bx@@22) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@22))) (<= (U_2_int (MapType0Select ms bx@@22)) (|MultiSet#Card| ms))))
 :qid |DafnyPreludebpl.799:11|
 :skolemid |527|
 :pattern ( (MapType0Select ms bx@@22))
)))))
 :qid |DafnyPreludebpl.797:18|
 :skolemid |528|
 :pattern ( ($IsGoodMultiSet ms))
)))
(assert (forall ((s@@5 T@U) ) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5))))
 (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5))))
 :qid |DafnyPreludebpl.802:18|
 :skolemid |529|
 :pattern ( (|MultiSet#Card| s@@5))
)))
(assert (forall ((s@@6 T@U) (x@@27 T@U) (n@@5 T@U) ) (! (let ((T@@63 (type x@@27)))
 (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@5) intType)) (<= 0 (U_2_int n@@5))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@27))) (U_2_int n@@5)))))
 :qid |DafnyPreludebpl.803:18|
 :skolemid |530|
 :pattern ( (|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)))
)))
(assert (forall ((T@@64 T@T) ) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType))
 :qid |funType:MultiSet#Empty|
 :pattern ( (|MultiSet#Empty| T@@64))
)))
(assert (forall ((o@@34 T@U) ) (! (let ((T@@65 (type o@@34)))
(= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@34)) 0))
 :qid |DafnyPreludebpl.807:18|
 :skolemid |531|
 :pattern ( (let ((T@@65 (type o@@34)))
(MapType0Select (|MultiSet#Empty| T@@65) o@@34)))
)))
(assert (forall ((s@@7 T@U) ) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7))))
 (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (= (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@28 T@U) ) (!  (and (= (type x@@28) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@28))))
 :qid |DafnyPreludebpl.810:38|
 :skolemid |532|
 :no-pattern (type x@@28)
 :no-pattern (U_2_int x@@28)
 :no-pattern (U_2_bool x@@28)
))))))
 :qid |DafnyPreludebpl.808:18|
 :skolemid |533|
 :pattern ( (|MultiSet#Card| s@@7))
)))
(assert (forall ((arg0@@84 T@U) ) (! (let ((T@@67 (type arg0@@84)))
(= (type (|MultiSet#Singleton| arg0@@84)) (MapType0Type T@@67 intType)))
 :qid |funType:MultiSet#Singleton|
 :pattern ( (|MultiSet#Singleton| arg0@@84))
)))
(assert (forall ((r@@4 T@U) (o@@35 T@U) ) (! (let ((T@@68 (type r@@4)))
 (=> (= (type o@@35) T@@68) (and (= (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35)) 1) (= r@@4 o@@35)) (= (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35)) 0) (not (= r@@4 o@@35))))))
 :qid |DafnyPreludebpl.813:18|
 :skolemid |534|
 :pattern ( (MapType0Select (|MultiSet#Singleton| r@@4) o@@35))
)))
(assert (forall ((arg0@@85 T@U) (arg1@@32 T@U) ) (! (let ((T@@69 (type arg1@@32)))
(= (type (|MultiSet#UnionOne| arg0@@85 arg1@@32)) (MapType0Type T@@69 intType)))
 :qid |funType:MultiSet#UnionOne|
 :pattern ( (|MultiSet#UnionOne| arg0@@85 arg1@@32))
)))
(assert (forall ((r@@5 T@U) ) (! (let ((T@@70 (type r@@5)))
(= (|MultiSet#Singleton| r@@5) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@5)))
 :qid |DafnyPreludebpl.815:18|
 :skolemid |535|
 :pattern ( (|MultiSet#Singleton| r@@5))
)))
(assert (forall ((a@@48 T@U) (x@@29 T@U) (o@@36 T@U) ) (! (let ((T@@71 (type x@@29)))
 (=> (and (= (type a@@48) (MapType0Type T@@71 intType)) (= (type o@@36) T@@71)) (= (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@29) o@@36)))  (or (= o@@36 x@@29) (< 0 (U_2_int (MapType0Select a@@48 o@@36)))))))
 :qid |DafnyPreludebpl.819:18|
 :skolemid |536|
 :pattern ( (MapType0Select (|MultiSet#UnionOne| a@@48 x@@29) o@@36))
)))
(assert (forall ((a@@49 T@U) (x@@30 T@U) ) (! (let ((T@@72 (type x@@30)))
 (=> (= (type a@@49) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@30) x@@30)) (+ (U_2_int (MapType0Select a@@49 x@@30)) 1))))
 :qid |DafnyPreludebpl.822:18|
 :skolemid |537|
 :pattern ( (|MultiSet#UnionOne| a@@49 x@@30))
)))
(assert (forall ((a@@50 T@U) (x@@31 T@U) (y@@9 T@U) ) (! (let ((T@@73 (type x@@31)))
 (=> (and (and (= (type a@@50) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@50 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@50 x@@31) y@@9)))))
 :qid |DafnyPreludebpl.825:18|
 :skolemid |538|
 :pattern ( (|MultiSet#UnionOne| a@@50 x@@31) (MapType0Select a@@50 y@@9))
)))
(assert (forall ((a@@51 T@U) (x@@32 T@U) (y@@10 T@U) ) (! (let ((T@@74 (type x@@32)))
 (=> (and (and (= (type a@@51) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@32 y@@10))) (= (U_2_int (MapType0Select a@@51 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@51 x@@32) y@@10)))))
 :qid |DafnyPreludebpl.828:18|
 :skolemid |539|
 :pattern ( (|MultiSet#UnionOne| a@@51 x@@32) (MapType0Select a@@51 y@@10))
)))
(assert (forall ((a@@52 T@U) (x@@33 T@U) ) (! (let ((T@@75 (type x@@33)))
 (=> (= (type a@@52) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33)) (+ (|MultiSet#Card| a@@52) 1))))
 :qid |DafnyPreludebpl.830:18|
 :skolemid |540|
 :pattern ( (|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33)))
)))
(assert (forall ((arg0@@86 T@U) (arg1@@33 T@U) ) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@86))))
(= (type (|MultiSet#Union| arg0@@86 arg1@@33)) (MapType0Type T@@76 intType)))
 :qid |funType:MultiSet#Union|
 :pattern ( (|MultiSet#Union| arg0@@86 arg1@@33))
)))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@37 T@U) ) (! (let ((T@@77 (type o@@37)))
 (=> (and (= (type a@@53) (MapType0Type T@@77 intType)) (= (type b@@38) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@53 b@@38) o@@37)) (+ (U_2_int (MapType0Select a@@53 o@@37)) (U_2_int (MapType0Select b@@38 o@@37))))))
 :qid |DafnyPreludebpl.836:18|
 :skolemid |541|
 :pattern ( (MapType0Select (|MultiSet#Union| a@@53 b@@38) o@@37))
)))
(assert (forall ((a@@54 T@U) (b@@39 T@U) ) (! (let ((T@@78 (MapType0TypeInv0 (type a@@54))))
 (=> (and (= (type a@@54) (MapType0Type T@@78 intType)) (= (type b@@39) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39)) (+ (|MultiSet#Card| a@@54) (|MultiSet#Card| b@@39)))))
 :qid |DafnyPreludebpl.838:18|
 :skolemid |542|
 :pattern ( (|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39)))
)))
(assert (forall ((arg0@@87 T@U) (arg1@@34 T@U) ) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@87))))
(= (type (|MultiSet#Intersection| arg0@@87 arg1@@34)) (MapType0Type T@@79 intType)))
 :qid |funType:MultiSet#Intersection|
 :pattern ( (|MultiSet#Intersection| arg0@@87 arg1@@34))
)))
(assert (forall ((a@@55 T@U) (b@@40 T@U) (o@@38 T@U) ) (! (let ((T@@80 (type o@@38)))
 (=> (and (= (type a@@55) (MapType0Type T@@80 intType)) (= (type b@@40) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@55 b@@40) o@@38)) (|Math#min| (U_2_int (MapType0Select a@@55 o@@38)) (U_2_int (MapType0Select b@@40 o@@38))))))
 :qid |DafnyPreludebpl.842:18|
 :skolemid |543|
 :pattern ( (MapType0Select (|MultiSet#Intersection| a@@55 b@@40) o@@38))
)))
(assert (forall ((a@@56 T@U) (b@@41 T@U) ) (! (let ((T@@81 (MapType0TypeInv0 (type a@@56))))
 (=> (and (= (type a@@56) (MapType0Type T@@81 intType)) (= (type b@@41) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@56 b@@41) b@@41) (|MultiSet#Intersection| a@@56 b@@41))))
 :qid |DafnyPreludebpl.846:18|
 :skolemid |544|
 :pattern ( (|MultiSet#Intersection| (|MultiSet#Intersection| a@@56 b@@41) b@@41))
)))
(assert (forall ((a@@57 T@U) (b@@42 T@U) ) (! (let ((T@@82 (MapType0TypeInv0 (type a@@57))))
 (=> (and (= (type a@@57) (MapType0Type T@@82 intType)) (= (type b@@42) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@57 (|MultiSet#Intersection| a@@57 b@@42)) (|MultiSet#Intersection| a@@57 b@@42))))
 :qid |DafnyPreludebpl.848:18|
 :skolemid |545|
 :pattern ( (|MultiSet#Intersection| a@@57 (|MultiSet#Intersection| a@@57 b@@42)))
)))
(assert (forall ((arg0@@88 T@U) (arg1@@35 T@U) ) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@88))))
(= (type (|MultiSet#Difference| arg0@@88 arg1@@35)) (MapType0Type T@@83 intType)))
 :qid |funType:MultiSet#Difference|
 :pattern ( (|MultiSet#Difference| arg0@@88 arg1@@35))
)))
(assert (forall ((a@@58 T@U) (b@@43 T@U) (o@@39 T@U) ) (! (let ((T@@84 (type o@@39)))
 (=> (and (= (type a@@58) (MapType0Type T@@84 intType)) (= (type b@@43) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@58 b@@43) o@@39)) (|Math#clip| (- (U_2_int (MapType0Select a@@58 o@@39)) (U_2_int (MapType0Select b@@43 o@@39)))))))
 :qid |DafnyPreludebpl.853:18|
 :skolemid |546|
 :pattern ( (MapType0Select (|MultiSet#Difference| a@@58 b@@43) o@@39))
)))
(assert (forall ((a@@59 T@U) (b@@44 T@U) (y@@11 T@U) ) (! (let ((T@@85 (type y@@11)))
 (=> (and (and (= (type a@@59) (MapType0Type T@@85 intType)) (= (type b@@44) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@59 y@@11)) (U_2_int (MapType0Select b@@44 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@59 b@@44) y@@11)) 0)))
 :qid |DafnyPreludebpl.855:18|
 :skolemid |547|
 :pattern ( (|MultiSet#Difference| a@@59 b@@44) (MapType0Select b@@44 y@@11) (MapType0Select a@@59 y@@11))
)))
(assert (forall ((a@@60 T@U) (b@@45 T@U) ) (! (let ((T@@86 (MapType0TypeInv0 (type a@@60))))
 (=> (and (= (type a@@60) (MapType0Type T@@86 intType)) (= (type b@@45) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)) (|MultiSet#Card| (|MultiSet#Difference| b@@45 a@@60))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45)))) (|MultiSet#Card| (|MultiSet#Union| a@@60 b@@45))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)) (- (|MultiSet#Card| a@@60) (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45)))))))
 :qid |DafnyPreludebpl.857:18|
 :skolemid |548|
 :pattern ( (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)))
)))
(assert (forall ((a@@61 T@U) (b@@46 T@U) ) (! (let ((T@@87 (MapType0TypeInv0 (type a@@61))))
 (=> (and (= (type a@@61) (MapType0Type T@@87 intType)) (= (type b@@46) (MapType0Type T@@87 intType))) (= (|MultiSet#Subset| a@@61 b@@46) (forall ((o@@40 T@U) ) (!  (=> (= (type o@@40) T@@87) (<= (U_2_int (MapType0Select a@@61 o@@40)) (U_2_int (MapType0Select b@@46 o@@40))))
 :qid |DafnyPreludebpl.867:37|
 :skolemid |549|
 :pattern ( (MapType0Select a@@61 o@@40))
 :pattern ( (MapType0Select b@@46 o@@40))
)))))
 :qid |DafnyPreludebpl.866:17|
 :skolemid |550|
 :pattern ( (|MultiSet#Subset| a@@61 b@@46))
)))
(assert (forall ((a@@62 T@U) (b@@47 T@U) ) (! (let ((T@@88 (MapType0TypeInv0 (type a@@62))))
 (=> (and (= (type a@@62) (MapType0Type T@@88 intType)) (= (type b@@47) (MapType0Type T@@88 intType))) (= (|MultiSet#Equal| a@@62 b@@47) (forall ((o@@41 T@U) ) (!  (=> (= (type o@@41) T@@88) (= (U_2_int (MapType0Select a@@62 o@@41)) (U_2_int (MapType0Select b@@47 o@@41))))
 :qid |DafnyPreludebpl.871:36|
 :skolemid |551|
 :pattern ( (MapType0Select a@@62 o@@41))
 :pattern ( (MapType0Select b@@47 o@@41))
)))))
 :qid |DafnyPreludebpl.870:17|
 :skolemid |552|
 :pattern ( (|MultiSet#Equal| a@@62 b@@47))
)))
(assert (forall ((a@@63 T@U) (b@@48 T@U) ) (! (let ((T@@89 (MapType0TypeInv0 (type a@@63))))
 (=> (and (and (= (type a@@63) (MapType0Type T@@89 intType)) (= (type b@@48) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@63 b@@48)) (= a@@63 b@@48)))
 :qid |DafnyPreludebpl.873:17|
 :skolemid |553|
 :pattern ( (|MultiSet#Equal| a@@63 b@@48))
)))
(assert (forall ((a@@64 T@U) (b@@49 T@U) ) (! (let ((T@@90 (MapType0TypeInv0 (type a@@64))))
 (=> (and (= (type a@@64) (MapType0Type T@@90 intType)) (= (type b@@49) (MapType0Type T@@90 intType))) (= (|MultiSet#Disjoint| a@@64 b@@49) (forall ((o@@42 T@U) ) (!  (=> (= (type o@@42) T@@90) (or (= (U_2_int (MapType0Select a@@64 o@@42)) 0) (= (U_2_int (MapType0Select b@@49 o@@42)) 0)))
 :qid |DafnyPreludebpl.878:39|
 :skolemid |554|
 :pattern ( (MapType0Select a@@64 o@@42))
 :pattern ( (MapType0Select b@@49 o@@42))
)))))
 :qid |DafnyPreludebpl.877:18|
 :skolemid |555|
 :pattern ( (|MultiSet#Disjoint| a@@64 b@@49))
)))
(assert (forall ((arg0@@89 T@U) ) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@89))))
(= (type (|MultiSet#FromSet| arg0@@89)) (MapType0Type T@@91 intType)))
 :qid |funType:MultiSet#FromSet|
 :pattern ( (|MultiSet#FromSet| arg0@@89))
)))
(assert (forall ((s@@8 T@U) (a@@65 T@U) ) (! (let ((T@@92 (type a@@65)))
 (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (= (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 0)  (not (U_2_bool (MapType0Select s@@8 a@@65)))) (= (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 1) (U_2_bool (MapType0Select s@@8 a@@65))))))
 :qid |DafnyPreludebpl.882:18|
 :skolemid |556|
 :pattern ( (MapType0Select (|MultiSet#FromSet| s@@8) a@@65))
)))
(assert (forall ((s@@9 T@U) ) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9))))
 (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9))))
 :qid |DafnyPreludebpl.885:18|
 :skolemid |557|
 :pattern ( (|MultiSet#Card| (|MultiSet#FromSet| s@@9)))
)))
(assert (forall ((arg0@@90 T@U) ) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@90))))
(= (type (|MultiSet#FromSeq| arg0@@90)) (MapType0Type T@@94 intType)))
 :qid |funType:MultiSet#FromSeq|
 :pattern ( (|MultiSet#FromSeq| arg0@@90))
)))
(assert (forall ((s@@10 T@U) ) (! (let ((T@@95 (SeqTypeInv0 (type s@@10))))
 (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10))))
 :qid |DafnyPreludebpl.891:18|
 :skolemid |558|
 :pattern ( (|MultiSet#FromSeq| s@@10))
)))
(assert (forall ((s@@11 T@U) ) (! (let ((T@@96 (SeqTypeInv0 (type s@@11))))
 (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11))))
 :qid |DafnyPreludebpl.893:18|
 :skolemid |559|
 :pattern ( (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)))
)))
(assert (forall ((arg0@@91 T@U) (arg1@@36 T@U) ) (! (let ((T@@97 (type arg1@@36)))
(= (type (|Seq#Build| arg0@@91 arg1@@36)) (SeqType T@@97)))
 :qid |funType:Seq#Build|
 :pattern ( (|Seq#Build| arg0@@91 arg1@@36))
)))
(assert (forall ((s@@12 T@U) (v@@29 T@U) ) (! (let ((T@@98 (type v@@29)))
 (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@29))))
 :qid |DafnyPreludebpl.897:18|
 :skolemid |560|
 :pattern ( (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29)))
)))
(assert (forall ((T@@99 T@T) ) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99))
 :qid |funType:Seq#Empty|
 :pattern ( (|Seq#Empty| T@@99))
)))
(assert (forall ((T@@100 T@T) ) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100))
 :skolemid |561|
)))
(assert (forall ((arg0@@92 T@U) (arg1@@37 T@U) ) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@92))))
(= (type (|Seq#Append| arg0@@92 arg1@@37)) (SeqType T@@101)))
 :qid |funType:Seq#Append|
 :pattern ( (|Seq#Append| arg0@@92 arg1@@37))
)))
(assert (forall ((a@@66 T@U) (b@@50 T@U) ) (! (let ((T@@102 (SeqTypeInv0 (type a@@66))))
 (=> (and (= (type a@@66) (SeqType T@@102)) (= (type b@@50) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@66) (|MultiSet#FromSeq| b@@50)))))
 :qid |DafnyPreludebpl.904:18|
 :skolemid |562|
 :pattern ( (|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50)))
)))
(assert (forall ((arg0@@93 T@U) (arg1@@38 Int) (arg2@@1 T@U) ) (! (let ((T@@103 (type arg2@@1)))
(= (type (|Seq#Update| arg0@@93 arg1@@38 arg2@@1)) (SeqType T@@103)))
 :qid |funType:Seq#Update|
 :pattern ( (|Seq#Update| arg0@@93 arg1@@38 arg2@@1))
)))
(assert (forall ((s@@13 T@U) (i@@6 Int) (v@@30 T@U) (x@@34 T@U) ) (! (let ((T@@104 (type v@@30)))
 (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@34) T@@104)) (and (<= 0 i@@6) (< i@@6 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@6 v@@30)) x@@34)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@6))) (|MultiSet#Singleton| v@@30)) x@@34)))))
 :qid |DafnyPreludebpl.909:18|
 :skolemid |563|
 :pattern ( (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@6 v@@30)) x@@34))
)))
(assert (forall ((s@@14 T@U) (x@@35 T@U) ) (! (let ((T@@105 (type x@@35)))
 (=> (= (type s@@14) (SeqType T@@105)) (= (exists ((i@@7 Int) ) (!  (and (and (<= 0 i@@7) (< i@@7 (|Seq#Length| s@@14))) (= x@@35 (|Seq#Index| s@@14 i@@7)))
 :qid |DafnyPreludebpl.916:11|
 :skolemid |564|
 :pattern ( (|Seq#Index| s@@14 i@@7))
)) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@35))))))
 :qid |DafnyPreludebpl.915:18|
 :skolemid |565|
 :pattern ( (MapType0Select (|MultiSet#FromSeq| s@@14) x@@35))
)))
(assert (forall ((s@@15 T@U) ) (! (let ((T@@106 (SeqTypeInv0 (type s@@15))))
 (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15))))
 :qid |DafnyPreludebpl.925:18|
 :skolemid |566|
 :pattern ( (|Seq#Length| s@@15))
)))
(assert (forall ((T@@107 T@T) ) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0)
 :skolemid |567|
 :pattern ( (|Seq#Empty| T@@107))
)))
(assert (forall ((s@@16 T@U) ) (! (let ((T@@108 (SeqTypeInv0 (type s@@16))))
 (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108))))
 :qid |DafnyPreludebpl.929:18|
 :skolemid |568|
 :pattern ( (|Seq#Length| s@@16))
)))
(assert (forall ((arg0@@94 T@U) ) (! (let ((T@@109 (type arg0@@94)))
(= (type (|Seq#Singleton| arg0@@94)) (SeqType T@@109)))
 :qid |funType:Seq#Singleton|
 :pattern ( (|Seq#Singleton| arg0@@94))
)))
(assert (forall ((t@@23 T@U) ) (! (= (|Seq#Length| (|Seq#Singleton| t@@23)) 1)
 :qid |DafnyPreludebpl.942:18|
 :skolemid |569|
 :pattern ( (|Seq#Length| (|Seq#Singleton| t@@23)))
)))
(assert  (and (forall ((arg0@@95 T@U) ) (! (let ((T@@110 (SeqTypeInv0 (type arg0@@95))))
(= (type (|Seq#Build_inv0| arg0@@95)) (SeqType T@@110)))
 :qid |funType:Seq#Build_inv0|
 :pattern ( (|Seq#Build_inv0| arg0@@95))
)) (forall ((arg0@@96 T@U) ) (! (let ((T@@111 (SeqTypeInv0 (type arg0@@96))))
(= (type (|Seq#Build_inv1| arg0@@96)) T@@111))
 :qid |funType:Seq#Build_inv1|
 :pattern ( (|Seq#Build_inv1| arg0@@96))
))))
(assert (forall ((s@@17 T@U) (val@@5 T@U) ) (! (let ((T@@112 (type val@@5)))
 (=> (= (type s@@17) (SeqType T@@112)) (and (= (|Seq#Build_inv0| (|Seq#Build| s@@17 val@@5)) s@@17) (= (|Seq#Build_inv1| (|Seq#Build| s@@17 val@@5)) val@@5))))
 :qid |DafnyPreludebpl.947:18|
 :skolemid |570|
 :pattern ( (|Seq#Build| s@@17 val@@5))
)))
(assert (forall ((s@@18 T@U) (v@@31 T@U) ) (! (let ((T@@113 (type v@@31)))
 (=> (= (type s@@18) (SeqType T@@113)) (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18)))))
 :qid |DafnyPreludebpl.952:18|
 :skolemid |571|
 :pattern ( (|Seq#Build| s@@18 v@@31))
)))
(assert (forall ((s@@19 T@U) (i@@8 Int) (v@@32 T@U) ) (! (let ((T@@114 (type v@@32)))
 (=> (= (type s@@19) (SeqType T@@114)) (and (=> (= i@@8 (|Seq#Length| s@@19)) (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8) v@@32)) (=> (not (= i@@8 (|Seq#Length| s@@19))) (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8) (|Seq#Index| s@@19 i@@8))))))
 :qid |DafnyPreludebpl.955:18|
 :skolemid |572|
 :pattern ( (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8))
)))
(assert (forall ((s@@20 T@U) (bx@@23 T@U) (t@@24 T@U) ) (!  (=> (and (and (and (= (type s@@20) (SeqType BoxType)) (= (type bx@@23) BoxType)) (= (type t@@24) TyType)) (and ($Is s@@20 (TSeq t@@24)) ($IsBox bx@@23 t@@24))) ($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
 :qid |DafnyPreludebpl.960:15|
 :skolemid |573|
 :pattern ( ($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
)))
(assert  (and (= (Ctor HandleTypeType) 23) (forall ((arg0@@97 T@U) (arg1@@39 T@U) (arg2@@2 Int) (arg3 T@U) ) (! (= (type (|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3)) (SeqType BoxType))
 :qid |funType:Seq#Create|
 :pattern ( (|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3))
))))
(assert (forall ((ty T@U) (heap T@U) (len Int) (init T@U) ) (!  (=> (and (and (and (= (type ty) TyType) (= (type heap) (MapType0Type refType MapType1Type))) (= (type init) HandleTypeType)) (and ($IsGoodHeap heap) (<= 0 len))) (= (|Seq#Length| (|Seq#Create| ty heap len init)) len))
 :qid |DafnyPreludebpl.964:15|
 :skolemid |574|
 :pattern ( (|Seq#Length| (|Seq#Create| ty heap len init)))
)))
(assert (forall ((arg0@@98 T@U) (arg1@@40 T@U) (arg2@@3 T@U) (arg3@@0 T@U) (arg4 T@U) ) (! (= (type (Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4)) BoxType)
 :qid |funType:Apply1|
 :pattern ( (Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4))
)))
(assert (forall ((ty@@0 T@U) (heap@@0 T@U) (len@@0 Int) (init@@0 T@U) (i@@9 Int) ) (!  (=> (and (and (and (= (type ty@@0) TyType) (= (type heap@@0) (MapType0Type refType MapType1Type))) (= (type init@@0) HandleTypeType)) (and (and ($IsGoodHeap heap@@0) (<= 0 i@@9)) (< i@@9 len@@0))) (= (|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0) i@@9) (Apply1 TInt (TSeq ty@@0) heap@@0 init@@0 ($Box (int_2_U i@@9)))))
 :qid |DafnyPreludebpl.968:15|
 :skolemid |575|
 :pattern ( (|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0) i@@9))
)))
(assert (forall ((s0 T@U) (s1 T@U) ) (! (let ((T@@115 (SeqTypeInv0 (type s0))))
 (=> (and (= (type s0) (SeqType T@@115)) (= (type s1) (SeqType T@@115))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1)))))
 :qid |DafnyPreludebpl.974:18|
 :skolemid |576|
 :pattern ( (|Seq#Length| (|Seq#Append| s0 s1)))
)))
(assert (forall ((t@@25 T@U) ) (! (= (|Seq#Index| (|Seq#Singleton| t@@25) 0) t@@25)
 :qid |DafnyPreludebpl.978:18|
 :skolemid |577|
 :pattern ( (|Seq#Index| (|Seq#Singleton| t@@25) 0))
)))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (n@@6 Int) ) (! (let ((T@@116 (SeqTypeInv0 (type s0@@0))))
 (=> (and (= (type s0@@0) (SeqType T@@116)) (= (type s1@@0) (SeqType T@@116))) (and (=> (< n@@6 (|Seq#Length| s0@@0)) (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6) (|Seq#Index| s0@@0 n@@6))) (=> (<= (|Seq#Length| s0@@0) n@@6) (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6) (|Seq#Index| s1@@0 (- n@@6 (|Seq#Length| s0@@0))))))))
 :qid |DafnyPreludebpl.979:18|
 :skolemid |578|
 :pattern ( (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6))
)))
(assert (forall ((s@@21 T@U) (i@@10 Int) (v@@33 T@U) ) (! (let ((T@@117 (type v@@33)))
 (=> (= (type s@@21) (SeqType T@@117)) (=> (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@21))) (= (|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33)) (|Seq#Length| s@@21)))))
 :qid |DafnyPreludebpl.984:18|
 :skolemid |579|
 :pattern ( (|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33)))
)))
(assert (forall ((s@@22 T@U) (i@@11 Int) (v@@34 T@U) (n@@7 Int) ) (! (let ((T@@118 (type v@@34)))
 (=> (= (type s@@22) (SeqType T@@118)) (=> (and (<= 0 n@@7) (< n@@7 (|Seq#Length| s@@22))) (and (=> (= i@@11 n@@7) (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7) v@@34)) (=> (not (= i@@11 n@@7)) (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7) (|Seq#Index| s@@22 n@@7)))))))
 :qid |DafnyPreludebpl.986:18|
 :skolemid |580|
 :pattern ( (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7))
)))
(assert (forall ((s@@23 T@U) (x@@36 T@U) ) (! (let ((T@@119 (type x@@36)))
 (=> (= (type s@@23) (SeqType T@@119)) (= (|Seq#Contains| s@@23 x@@36) (exists ((i@@12 Int) ) (!  (and (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@12) x@@36))
 :qid |DafnyPreludebpl.994:13|
 :skolemid |581|
 :pattern ( (|Seq#Index| s@@23 i@@12))
)))))
 :qid |DafnyPreludebpl.992:18|
 :skolemid |582|
 :pattern ( (|Seq#Contains| s@@23 x@@36))
)))
(assert (forall ((x@@37 T@U) ) (! (let ((T@@120 (type x@@37)))
 (not (|Seq#Contains| (|Seq#Empty| T@@120) x@@37)))
 :qid |DafnyPreludebpl.995:18|
 :skolemid |583|
 :pattern ( (let ((T@@120 (type x@@37)))
(|Seq#Contains| (|Seq#Empty| T@@120) x@@37)))
)))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (x@@38 T@U) ) (! (let ((T@@121 (type x@@38)))
 (=> (and (= (type s0@@1) (SeqType T@@121)) (= (type s1@@1) (SeqType T@@121))) (= (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38)  (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))))
 :qid |DafnyPreludebpl.999:18|
 :skolemid |584|
 :pattern ( (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38))
)))
(assert (forall ((s@@24 T@U) (v@@35 T@U) (x@@39 T@U) ) (! (let ((T@@122 (type v@@35)))
 (=> (and (= (type s@@24) (SeqType T@@122)) (= (type x@@39) T@@122)) (= (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39)  (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))))
 :qid |DafnyPreludebpl.1004:18|
 :skolemid |585|
 :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39))
)))
(assert (forall ((arg0@@99 T@U) (arg1@@41 Int) ) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@99))))
(= (type (|Seq#Take| arg0@@99 arg1@@41)) (SeqType T@@123)))
 :qid |funType:Seq#Take|
 :pattern ( (|Seq#Take| arg0@@99 arg1@@41))
)))
(assert (forall ((s@@25 T@U) (n@@8 Int) (x@@40 T@U) ) (! (let ((T@@124 (type x@@40)))
 (=> (= (type s@@25) (SeqType T@@124)) (= (|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40) (exists ((i@@13 Int) ) (!  (and (and (and (<= 0 i@@13) (< i@@13 n@@8)) (< i@@13 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@13) x@@40))
 :qid |DafnyPreludebpl.1011:13|
 :skolemid |586|
 :pattern ( (|Seq#Index| s@@25 i@@13))
)))))
 :qid |DafnyPreludebpl.1008:18|
 :skolemid |587|
 :pattern ( (|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40))
)))
(assert (forall ((arg0@@100 T@U) (arg1@@42 Int) ) (! (let ((T@@125 (SeqTypeInv0 (type arg0@@100))))
(= (type (|Seq#Drop| arg0@@100 arg1@@42)) (SeqType T@@125)))
 :qid |funType:Seq#Drop|
 :pattern ( (|Seq#Drop| arg0@@100 arg1@@42))
)))
(assert (forall ((s@@26 T@U) (n@@9 Int) (x@@41 T@U) ) (! (let ((T@@126 (type x@@41)))
 (=> (= (type s@@26) (SeqType T@@126)) (= (|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41) (exists ((i@@14 Int) ) (!  (and (and (and (<= 0 n@@9) (<= n@@9 i@@14)) (< i@@14 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@14) x@@41))
 :qid |DafnyPreludebpl.1016:13|
 :skolemid |588|
 :pattern ( (|Seq#Index| s@@26 i@@14))
)))))
 :qid |DafnyPreludebpl.1013:18|
 :skolemid |589|
 :pattern ( (|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41))
)))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) ) (! (let ((T@@127 (SeqTypeInv0 (type s0@@2))))
 (=> (and (= (type s0@@2) (SeqType T@@127)) (= (type s1@@2) (SeqType T@@127))) (= (|Seq#Equal| s0@@2 s1@@2)  (and (= (|Seq#Length| s0@@2) (|Seq#Length| s1@@2)) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|Seq#Length| s0@@2))) (= (|Seq#Index| s0@@2 j) (|Seq#Index| s1@@2 j)))
 :qid |DafnyPreludebpl.1023:13|
 :skolemid |590|
 :pattern ( (|Seq#Index| s0@@2 j))
 :pattern ( (|Seq#Index| s1@@2 j))
))))))
 :qid |DafnyPreludebpl.1020:18|
 :skolemid |591|
 :pattern ( (|Seq#Equal| s0@@2 s1@@2))
)))
(assert (forall ((a@@67 T@U) (b@@51 T@U) ) (! (let ((T@@128 (SeqTypeInv0 (type a@@67))))
 (=> (and (and (= (type a@@67) (SeqType T@@128)) (= (type b@@51) (SeqType T@@128))) (|Seq#Equal| a@@67 b@@51)) (= a@@67 b@@51)))
 :qid |DafnyPreludebpl.1025:18|
 :skolemid |592|
 :pattern ( (|Seq#Equal| a@@67 b@@51))
)))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U) (n@@10 Int) ) (! (let ((T@@129 (SeqTypeInv0 (type s0@@3))))
 (=> (and (= (type s0@@3) (SeqType T@@129)) (= (type s1@@3) (SeqType T@@129))) (= (|Seq#SameUntil| s0@@3 s1@@3 n@@10) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 n@@10)) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0)))
 :qid |DafnyPreludebpl.1031:13|
 :skolemid |593|
 :pattern ( (|Seq#Index| s0@@3 j@@0))
 :pattern ( (|Seq#Index| s1@@3 j@@0))
)))))
 :qid |DafnyPreludebpl.1029:18|
 :skolemid |594|
 :pattern ( (|Seq#SameUntil| s0@@3 s1@@3 n@@10))
)))
(assert (forall ((s@@27 T@U) (n@@11 Int) ) (! (let ((T@@130 (SeqTypeInv0 (type s@@27))))
 (=> (= (type s@@27) (SeqType T@@130)) (=> (and (<= 0 n@@11) (<= n@@11 (|Seq#Length| s@@27))) (= (|Seq#Length| (|Seq#Take| s@@27 n@@11)) n@@11))))
 :qid |DafnyPreludebpl.1035:18|
 :skolemid |595|
 :pattern ( (|Seq#Length| (|Seq#Take| s@@27 n@@11)))
)))
(assert (forall ((s@@28 T@U) (n@@12 Int) (j@@1 Int) ) (! (let ((T@@131 (SeqTypeInv0 (type s@@28))))
 (=> (= (type s@@28) (SeqType T@@131)) (=> (and (and (<= 0 j@@1) (< j@@1 n@@12)) (< j@@1 (|Seq#Length| s@@28))) (= (|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1) (|Seq#Index| s@@28 j@@1)))))
 :qid |DafnyPreludebpl.1037:18|
 :weight 25
 :skolemid |596|
 :pattern ( (|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1))
 :pattern ( (|Seq#Index| s@@28 j@@1) (|Seq#Take| s@@28 n@@12))
)))
(assert (forall ((s@@29 T@U) (n@@13 Int) ) (! (let ((T@@132 (SeqTypeInv0 (type s@@29))))
 (=> (= (type s@@29) (SeqType T@@132)) (=> (and (<= 0 n@@13) (<= n@@13 (|Seq#Length| s@@29))) (= (|Seq#Length| (|Seq#Drop| s@@29 n@@13)) (- (|Seq#Length| s@@29) n@@13)))))
 :qid |DafnyPreludebpl.1045:18|
 :skolemid |597|
 :pattern ( (|Seq#Length| (|Seq#Drop| s@@29 n@@13)))
)))
(assert (forall ((s@@30 T@U) (n@@14 Int) (j@@2 Int) ) (! (let ((T@@133 (SeqTypeInv0 (type s@@30))))
 (=> (= (type s@@30) (SeqType T@@133)) (=> (and (and (<= 0 n@@14) (<= 0 j@@2)) (< j@@2 (- (|Seq#Length| s@@30) n@@14))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2) (|Seq#Index| s@@30 (+ j@@2 n@@14))))))
 :qid |DafnyPreludebpl.1047:18|
 :weight 25
 :skolemid |598|
 :pattern ( (|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2))
)))
(assert (forall ((s@@31 T@U) (n@@15 Int) (k@@3 Int) ) (! (let ((T@@134 (SeqTypeInv0 (type s@@31))))
 (=> (= (type s@@31) (SeqType T@@134)) (=> (and (and (<= 0 n@@15) (<= n@@15 k@@3)) (< k@@3 (|Seq#Length| s@@31))) (= (|Seq#Index| (|Seq#Drop| s@@31 n@@15) (- k@@3 n@@15)) (|Seq#Index| s@@31 k@@3)))))
 :qid |DafnyPreludebpl.1052:18|
 :weight 25
 :skolemid |599|
 :pattern ( (|Seq#Index| s@@31 k@@3) (|Seq#Drop| s@@31 n@@15))
)))
(assert (forall ((s@@32 T@U) (t@@26 T@U) (n@@16 Int) ) (! (let ((T@@135 (SeqTypeInv0 (type s@@32))))
 (=> (and (and (= (type s@@32) (SeqType T@@135)) (= (type t@@26) (SeqType T@@135))) (= n@@16 (|Seq#Length| s@@32))) (and (= (|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16) s@@32) (= (|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16) t@@26))))
 :qid |DafnyPreludebpl.1058:18|
 :skolemid |600|
 :pattern ( (|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16))
 :pattern ( (|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16))
)))
(assert (forall ((arg0@@101 T@U) (arg1@@43 T@U) ) (! (= (type (|Seq#FromArray| arg0@@101 arg1@@43)) (SeqType BoxType))
 :qid |funType:Seq#FromArray|
 :pattern ( (|Seq#FromArray| arg0@@101 arg1@@43))
)))
(assert (forall ((h@@17 T@U) (a@@68 T@U) ) (!  (=> (and (= (type h@@17) (MapType0Type refType MapType1Type)) (= (type a@@68) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@17 a@@68)) (_System.array.Length a@@68)))
 :qid |DafnyPreludebpl.1067:15|
 :skolemid |601|
 :pattern ( (|Seq#Length| (|Seq#FromArray| h@@17 a@@68)))
)))
(assert (forall ((h@@18 T@U) (a@@69 T@U) ) (!  (=> (and (= (type h@@18) (MapType0Type refType MapType1Type)) (= (type a@@69) refType)) (forall ((i@@15 Int) ) (!  (=> (and (<= 0 i@@15) (< i@@15 (|Seq#Length| (|Seq#FromArray| h@@18 a@@69)))) (= (|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15) (MapType1Select (MapType0Select h@@18 a@@69) (IndexField i@@15))))
 :qid |DafnyPreludebpl.1072:11|
 :skolemid |602|
 :pattern ( (MapType1Select (MapType0Select h@@18 a@@69) (IndexField i@@15)))
 :pattern ( (|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15))
)))
 :qid |DafnyPreludebpl.1070:15|
 :skolemid |603|
 :pattern ( (|Seq#FromArray| h@@18 a@@69))
)))
(assert (forall ((h0 T@U) (h1 T@U) (a@@70 T@U) ) (!  (=> (and (and (= (type h0) (MapType0Type refType MapType1Type)) (= (type h1) (MapType0Type refType MapType1Type))) (= (type a@@70) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (= (MapType0Select h0 a@@70) (MapType0Select h1 a@@70))) (= (|Seq#FromArray| h0 a@@70) (|Seq#FromArray| h1 a@@70))))
 :qid |DafnyPreludebpl.1082:15|
 :skolemid |604|
 :pattern ( (|Seq#FromArray| h1 a@@70) ($HeapSucc h0 h1))
)))
(assert (forall ((h@@19 T@U) (i@@16 Int) (v@@36 T@U) (a@@71 T@U) ) (!  (=> (and (and (and (= (type h@@19) (MapType0Type refType MapType1Type)) (= (type v@@36) BoxType)) (= (type a@@71) refType)) (and (<= 0 i@@16) (< i@@16 (_System.array.Length a@@71)))) (= (|Seq#FromArray| (MapType0Store h@@19 a@@71 (MapType1Store (MapType0Select h@@19 a@@71) (IndexField i@@16) v@@36)) a@@71) (|Seq#Update| (|Seq#FromArray| h@@19 a@@71) i@@16 v@@36)))
 :qid |DafnyPreludebpl.1087:15|
 :skolemid |605|
 :pattern ( (|Seq#FromArray| (MapType0Store h@@19 a@@71 (MapType1Store (MapType0Select h@@19 a@@71) (IndexField i@@16) v@@36)) a@@71))
)))
(assert (forall ((s@@33 T@U) (i@@17 Int) (v@@37 T@U) (n@@17 Int) ) (! (let ((T@@136 (type v@@37)))
 (=> (= (type s@@33) (SeqType T@@136)) (=> (and (and (<= 0 i@@17) (< i@@17 n@@17)) (<= n@@17 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17) (|Seq#Update| (|Seq#Take| s@@33 n@@17) i@@17 v@@37)))))
 :qid |DafnyPreludebpl.1092:18|
 :skolemid |606|
 :pattern ( (|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17))
)))
(assert (forall ((s@@34 T@U) (i@@18 Int) (v@@38 T@U) (n@@18 Int) ) (! (let ((T@@137 (type v@@38)))
 (=> (= (type s@@34) (SeqType T@@137)) (=> (and (<= n@@18 i@@18) (< i@@18 (|Seq#Length| s@@34))) (= (|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18) (|Seq#Take| s@@34 n@@18)))))
 :qid |DafnyPreludebpl.1095:18|
 :skolemid |607|
 :pattern ( (|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18))
)))
(assert (forall ((s@@35 T@U) (i@@19 Int) (v@@39 T@U) (n@@19 Int) ) (! (let ((T@@138 (type v@@39)))
 (=> (= (type s@@35) (SeqType T@@138)) (=> (and (and (<= 0 n@@19) (<= n@@19 i@@19)) (< i@@19 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19) (|Seq#Update| (|Seq#Drop| s@@35 n@@19) (- i@@19 n@@19) v@@39)))))
 :qid |DafnyPreludebpl.1098:18|
 :skolemid |608|
 :pattern ( (|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19))
)))
(assert (forall ((s@@36 T@U) (i@@20 Int) (v@@40 T@U) (n@@20 Int) ) (! (let ((T@@139 (type v@@40)))
 (=> (= (type s@@36) (SeqType T@@139)) (=> (and (and (<= 0 i@@20) (< i@@20 n@@20)) (< n@@20 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20) (|Seq#Drop| s@@36 n@@20)))))
 :qid |DafnyPreludebpl.1101:18|
 :skolemid |609|
 :pattern ( (|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20))
)))
(assert (forall ((h@@20 T@U) (a@@72 T@U) (n0 Int) (n1 Int) ) (!  (=> (and (= (type h@@20) (MapType0Type refType MapType1Type)) (= (type a@@72) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@72))) (= (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0) (MapType1Select (MapType0Select h@@20 a@@72) (IndexField n0))))))
 :qid |DafnyPreludebpl.1105:15|
 :skolemid |610|
 :pattern ( (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0) (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1))
)))
(assert (forall ((s@@37 T@U) (v@@41 T@U) (n@@21 Int) ) (! (let ((T@@140 (type v@@41)))
 (=> (= (type s@@37) (SeqType T@@140)) (=> (and (<= 0 n@@21) (<= n@@21 (|Seq#Length| s@@37))) (= (|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21) (|Seq#Build| (|Seq#Drop| s@@37 n@@21) v@@41)))))
 :qid |DafnyPreludebpl.1109:18|
 :skolemid |611|
 :pattern ( (|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21))
)))
(assert (forall ((s@@38 T@U) (i@@21 Int) ) (!  (=> (= (type s@@38) (SeqType BoxType)) (=> (and (<= 0 i@@21) (< i@@21 (|Seq#Length| s@@38))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21))) (|Seq#Rank| s@@38))))
 :qid |DafnyPreludebpl.1114:15|
 :skolemid |612|
 :pattern ( (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21))))
)))
(assert (forall ((s@@39 T@U) (i@@22 Int) ) (! (let ((T@@141 (SeqTypeInv0 (type s@@39))))
 (=> (= (type s@@39) (SeqType T@@141)) (=> (and (< 0 i@@22) (<= i@@22 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Drop| s@@39 i@@22)) (|Seq#Rank| s@@39)))))
 :qid |DafnyPreludebpl.1117:18|
 :skolemid |613|
 :pattern ( (|Seq#Rank| (|Seq#Drop| s@@39 i@@22)))
)))
(assert (forall ((s@@40 T@U) (i@@23 Int) ) (! (let ((T@@142 (SeqTypeInv0 (type s@@40))))
 (=> (= (type s@@40) (SeqType T@@142)) (=> (and (<= 0 i@@23) (< i@@23 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Take| s@@40 i@@23)) (|Seq#Rank| s@@40)))))
 :qid |DafnyPreludebpl.1120:18|
 :skolemid |614|
 :pattern ( (|Seq#Rank| (|Seq#Take| s@@40 i@@23)))
)))
(assert (forall ((s@@41 T@U) (i@@24 Int) (j@@3 Int) ) (! (let ((T@@143 (SeqTypeInv0 (type s@@41))))
 (=> (= (type s@@41) (SeqType T@@143)) (=> (and (and (<= 0 i@@24) (< i@@24 j@@3)) (<= j@@3 (|Seq#Length| s@@41))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24) (|Seq#Drop| s@@41 j@@3))) (|Seq#Rank| s@@41)))))
 :qid |DafnyPreludebpl.1123:18|
 :skolemid |615|
 :pattern ( (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24) (|Seq#Drop| s@@41 j@@3))))
)))
(assert (forall ((s@@42 T@U) (n@@22 Int) ) (! (let ((T@@144 (SeqTypeInv0 (type s@@42))))
 (=> (and (= (type s@@42) (SeqType T@@144)) (= n@@22 0)) (= (|Seq#Drop| s@@42 n@@22) s@@42)))
 :qid |DafnyPreludebpl.1128:18|
 :skolemid |616|
 :pattern ( (|Seq#Drop| s@@42 n@@22))
)))
(assert (forall ((s@@43 T@U) (n@@23 Int) ) (! (let ((T@@145 (SeqTypeInv0 (type s@@43))))
 (=> (and (= (type s@@43) (SeqType T@@145)) (= n@@23 0)) (= (|Seq#Take| s@@43 n@@23) (|Seq#Empty| T@@145))))
 :qid |DafnyPreludebpl.1130:18|
 :skolemid |617|
 :pattern ( (|Seq#Take| s@@43 n@@23))
)))
(assert (forall ((s@@44 T@U) (m@@9 Int) (n@@24 Int) ) (! (let ((T@@146 (SeqTypeInv0 (type s@@44))))
 (=> (= (type s@@44) (SeqType T@@146)) (=> (and (and (<= 0 m@@9) (<= 0 n@@24)) (<= (+ m@@9 n@@24) (|Seq#Length| s@@44))) (= (|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24) (|Seq#Drop| s@@44 (+ m@@9 n@@24))))))
 :qid |DafnyPreludebpl.1132:18|
 :skolemid |618|
 :pattern ( (|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24))
)))
(assert (forall ((m@@10 T@U) ) (! (let ((V@@3 (MapTypeInv1 (type m@@10))))
(let ((U@@3 (MapTypeInv0 (type m@@10))))
 (=> (= (type m@@10) (MapType U@@3 V@@3)) (<= 0 (|Map#Card| m@@10)))))
 :qid |DafnyPreludebpl.1150:20|
 :skolemid |619|
 :pattern ( (|Map#Card| m@@10))
)))
(assert (forall ((U@@4 T@T) (V@@4 T@T) ) (! (= (type (|Map#Empty| U@@4 V@@4)) (MapType U@@4 V@@4))
 :qid |funType:Map#Empty|
 :pattern ( (|Map#Empty| U@@4 V@@4))
)))
(assert (forall ((m@@11 T@U) ) (! (let ((V@@5 (MapTypeInv1 (type m@@11))))
(let ((U@@5 (MapTypeInv0 (type m@@11))))
 (=> (= (type m@@11) (MapType U@@5 V@@5)) (= (= (|Map#Card| m@@11) 0) (= m@@11 (|Map#Empty| U@@5 V@@5))))))
 :qid |DafnyPreludebpl.1152:21|
 :skolemid |620|
 :pattern ( (|Map#Card| m@@11))
)))
(assert (forall ((m@@12 T@U) ) (! (let ((V@@6 (MapTypeInv1 (type m@@12))))
(let ((U@@6 (MapTypeInv0 (type m@@12))))
 (=> (= (type m@@12) (MapType U@@6 V@@6)) (or (= m@@12 (|Map#Empty| U@@6 V@@6)) (exists ((k@@4 T@U) ) (!  (and (= (type k@@4) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@12) k@@4)))
 :qid |DafnyPreludebpl.1158:31|
 :skolemid |621|
 :no-pattern (type k@@4)
 :no-pattern (U_2_int k@@4)
 :no-pattern (U_2_bool k@@4)
))))))
 :qid |DafnyPreludebpl.1156:21|
 :skolemid |622|
 :pattern ( (|Map#Domain| m@@12))
)))
(assert (forall ((m@@13 T@U) ) (! (let ((V@@7 (MapTypeInv1 (type m@@13))))
(let ((U@@7 (MapTypeInv0 (type m@@13))))
 (=> (= (type m@@13) (MapType U@@7 V@@7)) (or (= m@@13 (|Map#Empty| U@@7 V@@7)) (exists ((v@@42 T@U) ) (!  (and (= (type v@@42) V@@7) (U_2_bool (MapType0Select (|Map#Values| m@@13) v@@42)))
 :qid |DafnyPreludebpl.1161:31|
 :skolemid |623|
 :no-pattern (type v@@42)
 :no-pattern (U_2_int v@@42)
 :no-pattern (U_2_bool v@@42)
))))))
 :qid |DafnyPreludebpl.1159:21|
 :skolemid |624|
 :pattern ( (|Map#Values| m@@13))
)))
(assert (forall ((arg0@@102 T@U) (arg1@@44 T@U) ) (! (= (type (|#_System._tuple#2._#Make2| arg0@@102 arg1@@44)) DatatypeTypeType)
 :qid |funType:#_System._tuple#2._#Make2|
 :pattern ( (|#_System._tuple#2._#Make2| arg0@@102 arg1@@44))
)))
(assert (forall ((m@@14 T@U) ) (! (let ((V@@8 (MapTypeInv1 (type m@@14))))
(let ((U@@8 (MapTypeInv0 (type m@@14))))
 (=> (= (type m@@14) (MapType U@@8 V@@8)) (or (= m@@14 (|Map#Empty| U@@8 V@@8)) (exists ((k@@5 T@U) (v@@43 T@U) ) (!  (and (and (= (type k@@5) BoxType) (= (type v@@43) BoxType)) (U_2_bool (MapType0Select (|Map#Items| m@@14) ($Box (|#_System._tuple#2._#Make2| k@@5 v@@43)))))
 :qid |DafnyPreludebpl.1164:31|
 :skolemid |625|
 :no-pattern (type k@@5)
 :no-pattern (type v@@43)
 :no-pattern (U_2_int k@@5)
 :no-pattern (U_2_bool k@@5)
 :no-pattern (U_2_int v@@43)
 :no-pattern (U_2_bool v@@43)
))))))
 :qid |DafnyPreludebpl.1162:21|
 :skolemid |626|
 :pattern ( (|Map#Items| m@@14))
)))
(assert (forall ((m@@15 T@U) ) (! (let ((V@@9 (MapTypeInv1 (type m@@15))))
(let ((U@@9 (MapTypeInv0 (type m@@15))))
 (=> (= (type m@@15) (MapType U@@9 V@@9)) (= (|Set#Card| (|Map#Domain| m@@15)) (|Map#Card| m@@15)))))
 :qid |DafnyPreludebpl.1166:21|
 :skolemid |627|
 :pattern ( (|Set#Card| (|Map#Domain| m@@15)))
)))
(assert (forall ((m@@16 T@U) ) (! (let ((V@@10 (MapTypeInv1 (type m@@16))))
(let ((U@@10 (MapTypeInv0 (type m@@16))))
 (=> (= (type m@@16) (MapType U@@10 V@@10)) (<= (|Set#Card| (|Map#Values| m@@16)) (|Map#Card| m@@16)))))
 :qid |DafnyPreludebpl.1169:21|
 :skolemid |628|
 :pattern ( (|Set#Card| (|Map#Values| m@@16)))
)))
(assert (forall ((m@@17 T@U) ) (! (let ((V@@11 (MapTypeInv1 (type m@@17))))
(let ((U@@11 (MapTypeInv0 (type m@@17))))
 (=> (= (type m@@17) (MapType U@@11 V@@11)) (= (|Set#Card| (|Map#Items| m@@17)) (|Map#Card| m@@17)))))
 :qid |DafnyPreludebpl.1172:21|
 :skolemid |629|
 :pattern ( (|Set#Card| (|Map#Items| m@@17)))
)))
(assert (forall ((m@@18 T@U) (v@@44 T@U) ) (! (let ((V@@12 (type v@@44)))
(let ((U@@12 (MapTypeInv0 (type m@@18))))
 (=> (= (type m@@18) (MapType U@@12 V@@12)) (= (U_2_bool (MapType0Select (|Map#Values| m@@18) v@@44)) (exists ((u@@5 T@U) ) (!  (and (= (type u@@5) U@@12) (and (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@5)) (= v@@44 (MapType0Select (|Map#Elements| m@@18) u@@5))))
 :qid |DafnyPreludebpl.1185:10|
 :skolemid |630|
 :pattern ( (MapType0Select (|Map#Domain| m@@18) u@@5))
 :pattern ( (MapType0Select (|Map#Elements| m@@18) u@@5))
))))))
 :qid |DafnyPreludebpl.1183:20|
 :skolemid |631|
 :pattern ( (MapType0Select (|Map#Values| m@@18) v@@44))
)))
(assert  (and (forall ((arg0@@103 T@U) ) (! (= (type (_System.Tuple2._0 arg0@@103)) BoxType)
 :qid |funType:_System.Tuple2._0|
 :pattern ( (_System.Tuple2._0 arg0@@103))
)) (forall ((arg0@@104 T@U) ) (! (= (type (_System.Tuple2._1 arg0@@104)) BoxType)
 :qid |funType:_System.Tuple2._1|
 :pattern ( (_System.Tuple2._1 arg0@@104))
))))
(assert (forall ((m@@19 T@U) (item T@U) ) (!  (=> (and (= (type m@@19) (MapType BoxType BoxType)) (= (type item) BoxType)) (= (U_2_bool (MapType0Select (|Map#Items| m@@19) item))  (and (U_2_bool (MapType0Select (|Map#Domain| m@@19) (_System.Tuple2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@19) (_System.Tuple2._0 ($Unbox DatatypeTypeType item))) (_System.Tuple2._1 ($Unbox DatatypeTypeType item))))))
 :qid |DafnyPreludebpl.1204:15|
 :skolemid |632|
 :pattern ( (MapType0Select (|Map#Items| m@@19) item))
)))
(assert (forall ((u@@6 T@U) (V@@13 T@T) ) (! (let ((U@@13 (type u@@6)))
 (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@13 V@@13)) u@@6))))
 :qid |DafnyPreludebpl.1212:21|
 :skolemid |633|
 :pattern ( (let ((U@@13 (type u@@6)))
(MapType0Select (|Map#Domain| (|Map#Empty| U@@13 V@@13)) u@@6)))
)))
(assert (forall ((arg0@@105 T@U) (arg1@@45 T@U) (arg2@@4 T@U) ) (! (let ((V@@14 (MapType0TypeInv1 (type arg1@@45))))
(let ((U@@14 (MapType0TypeInv0 (type arg0@@105))))
(= (type (|Map#Glue| arg0@@105 arg1@@45 arg2@@4)) (MapType U@@14 V@@14))))
 :qid |funType:Map#Glue|
 :pattern ( (|Map#Glue| arg0@@105 arg1@@45 arg2@@4))
)))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@27 T@U) ) (! (let ((V@@15 (MapType0TypeInv1 (type b@@52))))
(let ((U@@15 (MapType0TypeInv0 (type a@@73))))
 (=> (and (and (= (type a@@73) (MapType0Type U@@15 boolType)) (= (type b@@52) (MapType0Type U@@15 V@@15))) (= (type t@@27) TyType)) (= (|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)) a@@73))))
 :qid |DafnyPreludebpl.1217:21|
 :skolemid |634|
 :pattern ( (|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)))
)))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@28 T@U) ) (! (let ((V@@16 (MapType0TypeInv1 (type b@@53))))
(let ((U@@16 (MapType0TypeInv0 (type a@@74))))
 (=> (and (and (= (type a@@74) (MapType0Type U@@16 boolType)) (= (type b@@53) (MapType0Type U@@16 V@@16))) (= (type t@@28) TyType)) (= (|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)) b@@53))))
 :qid |DafnyPreludebpl.1220:21|
 :skolemid |635|
 :pattern ( (|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)))
)))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t0@@14 T@U) (t1@@5 T@U) ) (!  (=> (and (and (and (and (= (type a@@75) (MapType0Type BoxType boolType)) (= (type b@@54) (MapType0Type BoxType BoxType))) (= (type t0@@14) TyType)) (= (type t1@@5) TyType)) (forall ((bx@@24 T@U) ) (!  (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select a@@75 bx@@24))) (and ($IsBox bx@@24 t0@@14) ($IsBox (MapType0Select b@@54 bx@@24) t1@@5)))
 :qid |DafnyPreludebpl.1226:11|
 :skolemid |636|
 :no-pattern (type bx@@24)
 :no-pattern (U_2_int bx@@24)
 :no-pattern (U_2_bool bx@@24)
))) ($Is (|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5)) (TMap t0@@14 t1@@5)))
 :qid |DafnyPreludebpl.1223:15|
 :skolemid |637|
 :pattern ( (|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5)))
)))
(assert (forall ((arg0@@106 T@U) (arg1@@46 T@U) (arg2@@5 T@U) ) (! (let ((V@@17 (type arg2@@5)))
(let ((U@@17 (type arg1@@46)))
(= (type (|Map#Build| arg0@@106 arg1@@46 arg2@@5)) (MapType U@@17 V@@17))))
 :qid |funType:Map#Build|
 :pattern ( (|Map#Build| arg0@@106 arg1@@46 arg2@@5))
)))
(assert (forall ((m@@20 T@U) (u@@7 T@U) (|u'| T@U) (v@@45 T@U) ) (! (let ((V@@18 (type v@@45)))
(let ((U@@18 (type u@@7)))
 (=> (and (= (type m@@20) (MapType U@@18 V@@18)) (= (type |u'|) U@@18)) (and (=> (= |u'| u@@7) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|) v@@45))) (=> (not (= |u'| u@@7)) (and (= (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@20) |u'|))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|) (MapType0Select (|Map#Elements| m@@20) |u'|))))))))
 :qid |DafnyPreludebpl.1237:21|
 :skolemid |638|
 :pattern ( (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|))
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|))
)))
(assert (forall ((m@@21 T@U) (u@@8 T@U) (v@@46 T@U) ) (! (let ((V@@19 (type v@@46)))
(let ((U@@19 (type u@@8)))
 (=> (and (= (type m@@21) (MapType U@@19 V@@19)) (U_2_bool (MapType0Select (|Map#Domain| m@@21) u@@8))) (= (|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)) (|Map#Card| m@@21)))))
 :qid |DafnyPreludebpl.1243:21|
 :skolemid |639|
 :pattern ( (|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)))
)))
(assert (forall ((m@@22 T@U) (u@@9 T@U) (v@@47 T@U) ) (! (let ((V@@20 (type v@@47)))
(let ((U@@20 (type u@@9)))
 (=> (and (= (type m@@22) (MapType U@@20 V@@20)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@22) u@@9)))) (= (|Map#Card| (|Map#Build| m@@22 u@@9 v@@47)) (+ (|Map#Card| m@@22) 1)))))
 :qid |DafnyPreludebpl.1245:21|
 :skolemid |640|
 :pattern ( (|Map#Card| (|Map#Build| m@@22 u@@9 v@@47)))
)))
(assert (forall ((arg0@@107 T@U) (arg1@@47 T@U) ) (! (let ((V@@21 (MapTypeInv1 (type arg0@@107))))
(let ((U@@21 (MapTypeInv0 (type arg0@@107))))
(= (type (|Map#Merge| arg0@@107 arg1@@47)) (MapType U@@21 V@@21))))
 :qid |funType:Map#Merge|
 :pattern ( (|Map#Merge| arg0@@107 arg1@@47))
)))
(assert (forall ((m@@23 T@U) (n@@25 T@U) ) (! (let ((V@@22 (MapTypeInv1 (type m@@23))))
(let ((U@@22 (MapTypeInv0 (type m@@23))))
 (=> (and (= (type m@@23) (MapType U@@22 V@@22)) (= (type n@@25) (MapType U@@22 V@@22))) (= (|Map#Domain| (|Map#Merge| m@@23 n@@25)) (|Set#Union| (|Map#Domain| m@@23) (|Map#Domain| n@@25))))))
 :qid |DafnyPreludebpl.1250:21|
 :skolemid |641|
 :pattern ( (|Map#Domain| (|Map#Merge| m@@23 n@@25)))
)))
(assert (forall ((m@@24 T@U) (n@@26 T@U) (u@@10 T@U) ) (! (let ((V@@23 (MapTypeInv1 (type m@@24))))
(let ((U@@23 (type u@@10)))
 (=> (and (and (= (type m@@24) (MapType U@@23 V@@23)) (= (type n@@26) (MapType U@@23 V@@23))) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Merge| m@@24 n@@26)) u@@10))) (and (=> (not (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10))) (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10) (MapType0Select (|Map#Elements| m@@24) u@@10))) (=> (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10)) (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10) (MapType0Select (|Map#Elements| n@@26) u@@10)))))))
 :qid |DafnyPreludebpl.1253:21|
 :skolemid |642|
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10))
)))
(assert (forall ((arg0@@108 T@U) (arg1@@48 T@U) ) (! (let ((V@@24 (MapTypeInv1 (type arg0@@108))))
(let ((U@@24 (MapTypeInv0 (type arg0@@108))))
(= (type (|Map#Subtract| arg0@@108 arg1@@48)) (MapType U@@24 V@@24))))
 :qid |funType:Map#Subtract|
 :pattern ( (|Map#Subtract| arg0@@108 arg1@@48))
)))
(assert (forall ((m@@25 T@U) (s@@45 T@U) ) (! (let ((V@@25 (MapTypeInv1 (type m@@25))))
(let ((U@@25 (MapTypeInv0 (type m@@25))))
 (=> (and (= (type m@@25) (MapType U@@25 V@@25)) (= (type s@@45) (MapType0Type U@@25 boolType))) (= (|Map#Domain| (|Map#Subtract| m@@25 s@@45)) (|Set#Difference| (|Map#Domain| m@@25) s@@45)))))
 :qid |DafnyPreludebpl.1260:21|
 :skolemid |643|
 :pattern ( (|Map#Domain| (|Map#Subtract| m@@25 s@@45)))
)))
(assert (forall ((m@@26 T@U) (s@@46 T@U) (u@@11 T@U) ) (! (let ((V@@26 (MapTypeInv1 (type m@@26))))
(let ((U@@26 (type u@@11)))
 (=> (and (and (= (type m@@26) (MapType U@@26 V@@26)) (= (type s@@46) (MapType0Type U@@26 boolType))) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Subtract| m@@26 s@@46)) u@@11))) (= (MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46)) u@@11) (MapType0Select (|Map#Elements| m@@26) u@@11)))))
 :qid |DafnyPreludebpl.1263:21|
 :skolemid |644|
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46)) u@@11))
)))
(assert (forall ((m@@27 T@U) (|m'| T@U) ) (! (let ((V@@27 (MapTypeInv1 (type m@@27))))
(let ((U@@27 (MapTypeInv0 (type m@@27))))
 (=> (and (= (type m@@27) (MapType U@@27 V@@27)) (= (type |m'|) (MapType U@@27 V@@27))) (= (|Map#Equal| m@@27 |m'|)  (and (forall ((u@@12 T@U) ) (!  (=> (= (type u@@12) U@@27) (= (U_2_bool (MapType0Select (|Map#Domain| m@@27) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12))))
 :qid |DafnyPreludebpl.1272:35|
 :skolemid |645|
 :no-pattern (type u@@12)
 :no-pattern (U_2_int u@@12)
 :no-pattern (U_2_bool u@@12)
)) (forall ((u@@13 T@U) ) (!  (=> (and (= (type u@@13) U@@27) (U_2_bool (MapType0Select (|Map#Domain| m@@27) u@@13))) (= (MapType0Select (|Map#Elements| m@@27) u@@13) (MapType0Select (|Map#Elements| |m'|) u@@13)))
 :qid |DafnyPreludebpl.1273:35|
 :skolemid |646|
 :no-pattern (type u@@13)
 :no-pattern (U_2_int u@@13)
 :no-pattern (U_2_bool u@@13)
)))))))
 :qid |DafnyPreludebpl.1270:21|
 :skolemid |647|
 :pattern ( (|Map#Equal| m@@27 |m'|))
)))
(assert (forall ((m@@28 T@U) (|m'@@0| T@U) ) (! (let ((V@@28 (MapTypeInv1 (type m@@28))))
(let ((U@@28 (MapTypeInv0 (type m@@28))))
 (=> (and (and (= (type m@@28) (MapType U@@28 V@@28)) (= (type |m'@@0|) (MapType U@@28 V@@28))) (|Map#Equal| m@@28 |m'@@0|)) (= m@@28 |m'@@0|))))
 :qid |DafnyPreludebpl.1275:21|
 :skolemid |648|
 :pattern ( (|Map#Equal| m@@28 |m'@@0|))
)))
(assert (forall ((m@@29 T@U) (|m'@@1| T@U) ) (! (let ((V@@29 (MapTypeInv1 (type m@@29))))
(let ((U@@29 (MapTypeInv0 (type m@@29))))
 (=> (and (= (type m@@29) (MapType U@@29 V@@29)) (= (type |m'@@1|) (MapType U@@29 V@@29))) (= (|Map#Disjoint| m@@29 |m'@@1|) (forall ((o@@43 T@U) ) (!  (=> (= (type o@@43) U@@29) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@29) o@@43))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@43)))))
 :qid |DafnyPreludebpl.1282:38|
 :skolemid |649|
 :pattern ( (MapType0Select (|Map#Domain| m@@29) o@@43))
 :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@43))
))))))
 :qid |DafnyPreludebpl.1280:21|
 :skolemid |650|
 :pattern ( (|Map#Disjoint| m@@29 |m'@@1|))
)))
(assert (forall ((U@@30 T@T) (V@@30 T@T) ) (! (= (type (|IMap#Empty| U@@30 V@@30)) (IMapType U@@30 V@@30))
 :qid |funType:IMap#Empty|
 :pattern ( (|IMap#Empty| U@@30 V@@30))
)))
(assert (forall ((m@@30 T@U) ) (! (let ((V@@31 (IMapTypeInv1 (type m@@30))))
(let ((U@@31 (IMapTypeInv0 (type m@@30))))
 (=> (= (type m@@30) (IMapType U@@31 V@@31)) (or (= m@@30 (|IMap#Empty| U@@31 V@@31)) (exists ((k@@6 T@U) ) (!  (and (= (type k@@6) U@@31) (U_2_bool (MapType0Select (|IMap#Domain| m@@30) k@@6)))
 :qid |DafnyPreludebpl.1298:32|
 :skolemid |651|
 :no-pattern (type k@@6)
 :no-pattern (U_2_int k@@6)
 :no-pattern (U_2_bool k@@6)
))))))
 :qid |DafnyPreludebpl.1296:21|
 :skolemid |652|
 :pattern ( (|IMap#Domain| m@@30))
)))
(assert (forall ((m@@31 T@U) ) (! (let ((V@@32 (IMapTypeInv1 (type m@@31))))
(let ((U@@32 (IMapTypeInv0 (type m@@31))))
 (=> (= (type m@@31) (IMapType U@@32 V@@32)) (or (= m@@31 (|IMap#Empty| U@@32 V@@32)) (exists ((v@@48 T@U) ) (!  (and (= (type v@@48) V@@32) (U_2_bool (MapType0Select (|IMap#Values| m@@31) v@@48)))
 :qid |DafnyPreludebpl.1301:32|
 :skolemid |653|
 :no-pattern (type v@@48)
 :no-pattern (U_2_int v@@48)
 :no-pattern (U_2_bool v@@48)
))))))
 :qid |DafnyPreludebpl.1299:21|
 :skolemid |654|
 :pattern ( (|IMap#Values| m@@31))
)))
(assert (forall ((m@@32 T@U) ) (! (let ((V@@33 (IMapTypeInv1 (type m@@32))))
(let ((U@@33 (IMapTypeInv0 (type m@@32))))
 (=> (= (type m@@32) (IMapType U@@33 V@@33)) (or (= m@@32 (|IMap#Empty| U@@33 V@@33)) (exists ((k@@7 T@U) (v@@49 T@U) ) (!  (and (and (= (type k@@7) BoxType) (= (type v@@49) BoxType)) (U_2_bool (MapType0Select (|IMap#Items| m@@32) ($Box (|#_System._tuple#2._#Make2| k@@7 v@@49)))))
 :qid |DafnyPreludebpl.1304:32|
 :skolemid |655|
 :no-pattern (type k@@7)
 :no-pattern (type v@@49)
 :no-pattern (U_2_int k@@7)
 :no-pattern (U_2_bool k@@7)
 :no-pattern (U_2_int v@@49)
 :no-pattern (U_2_bool v@@49)
))))))
 :qid |DafnyPreludebpl.1302:21|
 :skolemid |656|
 :pattern ( (|IMap#Items| m@@32))
)))
(assert (forall ((m@@33 T@U) ) (! (let ((V@@34 (IMapTypeInv1 (type m@@33))))
(let ((U@@34 (IMapTypeInv0 (type m@@33))))
 (=> (= (type m@@33) (IMapType U@@34 V@@34)) (= (= m@@33 (|IMap#Empty| U@@34 V@@34)) (= (|IMap#Domain| m@@33) (|ISet#Empty| U@@34))))))
 :qid |DafnyPreludebpl.1306:21|
 :skolemid |657|
 :pattern ( (|IMap#Domain| m@@33))
)))
(assert (forall ((m@@34 T@U) ) (! (let ((V@@35 (IMapTypeInv1 (type m@@34))))
(let ((U@@35 (IMapTypeInv0 (type m@@34))))
 (=> (= (type m@@34) (IMapType U@@35 V@@35)) (= (= m@@34 (|IMap#Empty| U@@35 V@@35)) (= (|IMap#Values| m@@34) (|ISet#Empty| V@@35))))))
 :qid |DafnyPreludebpl.1309:21|
 :skolemid |658|
 :pattern ( (|IMap#Values| m@@34))
)))
(assert (forall ((m@@35 T@U) ) (! (let ((V@@36 (IMapTypeInv1 (type m@@35))))
(let ((U@@36 (IMapTypeInv0 (type m@@35))))
 (=> (= (type m@@35) (IMapType U@@36 V@@36)) (= (= m@@35 (|IMap#Empty| U@@36 V@@36)) (= (|IMap#Items| m@@35) (|ISet#Empty| BoxType))))))
 :qid |DafnyPreludebpl.1312:21|
 :skolemid |659|
 :pattern ( (|IMap#Items| m@@35))
)))
(assert (forall ((m@@36 T@U) (v@@50 T@U) ) (! (let ((V@@37 (type v@@50)))
(let ((U@@37 (IMapTypeInv0 (type m@@36))))
 (=> (= (type m@@36) (IMapType U@@37 V@@37)) (= (U_2_bool (MapType0Select (|IMap#Values| m@@36) v@@50)) (exists ((u@@14 T@U) ) (!  (and (= (type u@@14) U@@37) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@36) u@@14)) (= v@@50 (MapType0Select (|IMap#Elements| m@@36) u@@14))))
 :qid |DafnyPreludebpl.1325:10|
 :skolemid |660|
 :pattern ( (MapType0Select (|IMap#Domain| m@@36) u@@14))
 :pattern ( (MapType0Select (|IMap#Elements| m@@36) u@@14))
))))))
 :qid |DafnyPreludebpl.1323:20|
 :skolemid |661|
 :pattern ( (MapType0Select (|IMap#Values| m@@36) v@@50))
)))
(assert (forall ((m@@37 T@U) (item@@0 T@U) ) (!  (=> (and (= (type m@@37) (IMapType BoxType BoxType)) (= (type item@@0) BoxType)) (= (U_2_bool (MapType0Select (|IMap#Items| m@@37) item@@0))  (and (U_2_bool (MapType0Select (|IMap#Domain| m@@37) (_System.Tuple2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@37) (_System.Tuple2._0 ($Unbox DatatypeTypeType item@@0))) (_System.Tuple2._1 ($Unbox DatatypeTypeType item@@0))))))
 :qid |DafnyPreludebpl.1340:15|
 :skolemid |662|
 :pattern ( (MapType0Select (|IMap#Items| m@@37) item@@0))
)))
(assert (forall ((u@@15 T@U) (V@@38 T@T) ) (! (let ((U@@38 (type u@@15)))
 (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@38 V@@38)) u@@15))))
 :qid |DafnyPreludebpl.1347:21|
 :skolemid |663|
 :pattern ( (let ((U@@38 (type u@@15)))
(MapType0Select (|IMap#Domain| (|IMap#Empty| U@@38 V@@38)) u@@15)))
)))
(assert (forall ((arg0@@109 T@U) (arg1@@49 T@U) (arg2@@6 T@U) ) (! (let ((V@@39 (MapType0TypeInv1 (type arg1@@49))))
(let ((U@@39 (MapType0TypeInv0 (type arg0@@109))))
(= (type (|IMap#Glue| arg0@@109 arg1@@49 arg2@@6)) (IMapType U@@39 V@@39))))
 :qid |funType:IMap#Glue|
 :pattern ( (|IMap#Glue| arg0@@109 arg1@@49 arg2@@6))
)))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@29 T@U) ) (! (let ((V@@40 (MapType0TypeInv1 (type b@@55))))
(let ((U@@40 (MapType0TypeInv0 (type a@@76))))
 (=> (and (and (= (type a@@76) (MapType0Type U@@40 boolType)) (= (type b@@55) (MapType0Type U@@40 V@@40))) (= (type t@@29) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)) a@@76))))
 :qid |DafnyPreludebpl.1352:21|
 :skolemid |664|
 :pattern ( (|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)))
)))
(assert (forall ((a@@77 T@U) (b@@56 T@U) (t@@30 T@U) ) (! (let ((V@@41 (MapType0TypeInv1 (type b@@56))))
(let ((U@@41 (MapType0TypeInv0 (type a@@77))))
 (=> (and (and (= (type a@@77) (MapType0Type U@@41 boolType)) (= (type b@@56) (MapType0Type U@@41 V@@41))) (= (type t@@30) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)) b@@56))))
 :qid |DafnyPreludebpl.1355:21|
 :skolemid |665|
 :pattern ( (|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)))
)))
(assert (forall ((a@@78 T@U) (b@@57 T@U) (t0@@15 T@U) (t1@@6 T@U) ) (!  (=> (and (and (and (and (= (type a@@78) (MapType0Type BoxType boolType)) (= (type b@@57) (MapType0Type BoxType BoxType))) (= (type t0@@15) TyType)) (= (type t1@@6) TyType)) (forall ((bx@@25 T@U) ) (!  (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select a@@78 bx@@25))) (and ($IsBox bx@@25 t0@@15) ($IsBox (MapType0Select b@@57 bx@@25) t1@@6)))
 :qid |DafnyPreludebpl.1361:11|
 :skolemid |666|
 :no-pattern (type bx@@25)
 :no-pattern (U_2_int bx@@25)
 :no-pattern (U_2_bool bx@@25)
))) ($Is (|Map#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6)) (TIMap t0@@15 t1@@6)))
 :qid |DafnyPreludebpl.1358:15|
 :skolemid |667|
 :pattern ( (|IMap#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6)))
)))
(assert (forall ((arg0@@110 T@U) (arg1@@50 T@U) (arg2@@7 T@U) ) (! (let ((V@@42 (type arg2@@7)))
(let ((U@@42 (type arg1@@50)))
(= (type (|IMap#Build| arg0@@110 arg1@@50 arg2@@7)) (IMapType U@@42 V@@42))))
 :qid |funType:IMap#Build|
 :pattern ( (|IMap#Build| arg0@@110 arg1@@50 arg2@@7))
)))
(assert (forall ((m@@38 T@U) (u@@16 T@U) (|u'@@0| T@U) (v@@51 T@U) ) (! (let ((V@@43 (type v@@51)))
(let ((U@@43 (type u@@16)))
 (=> (and (= (type m@@38) (IMapType U@@43 V@@43)) (= (type |u'@@0|) U@@43)) (and (=> (= |u'@@0| u@@16) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|) v@@51))) (=> (not (= |u'@@0| u@@16)) (and (= (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@38) |u'@@0|))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@38) |u'@@0|))))))))
 :qid |DafnyPreludebpl.1371:21|
 :skolemid |668|
 :pattern ( (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|))
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|))
)))
(assert (forall ((m@@39 T@U) (|m'@@2| T@U) ) (! (let ((V@@44 (IMapTypeInv1 (type m@@39))))
(let ((U@@44 (IMapTypeInv0 (type m@@39))))
 (=> (and (= (type m@@39) (IMapType U@@44 V@@44)) (= (type |m'@@2|) (IMapType U@@44 V@@44))) (= (|IMap#Equal| m@@39 |m'@@2|)  (and (forall ((u@@17 T@U) ) (!  (=> (= (type u@@17) U@@44) (= (U_2_bool (MapType0Select (|IMap#Domain| m@@39) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))))
 :qid |DafnyPreludebpl.1382:36|
 :skolemid |669|
 :no-pattern (type u@@17)
 :no-pattern (U_2_int u@@17)
 :no-pattern (U_2_bool u@@17)
)) (forall ((u@@18 T@U) ) (!  (=> (and (= (type u@@18) U@@44) (U_2_bool (MapType0Select (|IMap#Domain| m@@39) u@@18))) (= (MapType0Select (|IMap#Elements| m@@39) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18)))
 :qid |DafnyPreludebpl.1383:35|
 :skolemid |670|
 :no-pattern (type u@@18)
 :no-pattern (U_2_int u@@18)
 :no-pattern (U_2_bool u@@18)
)))))))
 :qid |DafnyPreludebpl.1380:21|
 :skolemid |671|
 :pattern ( (|IMap#Equal| m@@39 |m'@@2|))
)))
(assert (forall ((m@@40 T@U) (|m'@@3| T@U) ) (! (let ((V@@45 (IMapTypeInv1 (type m@@40))))
(let ((U@@45 (IMapTypeInv0 (type m@@40))))
 (=> (and (and (= (type m@@40) (IMapType U@@45 V@@45)) (= (type |m'@@3|) (IMapType U@@45 V@@45))) (|IMap#Equal| m@@40 |m'@@3|)) (= m@@40 |m'@@3|))))
 :qid |DafnyPreludebpl.1385:21|
 :skolemid |672|
 :pattern ( (|IMap#Equal| m@@40 |m'@@3|))
)))
(assert (forall ((arg0@@111 T@U) (arg1@@51 T@U) ) (! (let ((V@@46 (IMapTypeInv1 (type arg0@@111))))
(let ((U@@46 (IMapTypeInv0 (type arg0@@111))))
(= (type (|IMap#Merge| arg0@@111 arg1@@51)) (IMapType U@@46 V@@46))))
 :qid |funType:IMap#Merge|
 :pattern ( (|IMap#Merge| arg0@@111 arg1@@51))
)))
(assert (forall ((m@@41 T@U) (n@@27 T@U) ) (! (let ((V@@47 (IMapTypeInv1 (type m@@41))))
(let ((U@@47 (IMapTypeInv0 (type m@@41))))
 (=> (and (= (type m@@41) (IMapType U@@47 V@@47)) (= (type n@@27) (IMapType U@@47 V@@47))) (= (|IMap#Domain| (|IMap#Merge| m@@41 n@@27)) (|Set#Union| (|IMap#Domain| m@@41) (|IMap#Domain| n@@27))))))
 :qid |DafnyPreludebpl.1391:21|
 :skolemid |673|
 :pattern ( (|IMap#Domain| (|IMap#Merge| m@@41 n@@27)))
)))
(assert (forall ((m@@42 T@U) (n@@28 T@U) (u@@19 T@U) ) (! (let ((V@@48 (IMapTypeInv1 (type m@@42))))
(let ((U@@48 (type u@@19)))
 (=> (and (and (= (type m@@42) (IMapType U@@48 V@@48)) (= (type n@@28) (IMapType U@@48 V@@48))) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Merge| m@@42 n@@28)) u@@19))) (and (=> (not (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19))) (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19) (MapType0Select (|IMap#Elements| m@@42) u@@19))) (=> (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19)) (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19) (MapType0Select (|IMap#Elements| n@@28) u@@19)))))))
 :qid |DafnyPreludebpl.1394:21|
 :skolemid |674|
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19))
)))
(assert (forall ((arg0@@112 T@U) (arg1@@52 T@U) ) (! (let ((V@@49 (IMapTypeInv1 (type arg0@@112))))
(let ((U@@49 (IMapTypeInv0 (type arg0@@112))))
(= (type (|IMap#Subtract| arg0@@112 arg1@@52)) (IMapType U@@49 V@@49))))
 :qid |funType:IMap#Subtract|
 :pattern ( (|IMap#Subtract| arg0@@112 arg1@@52))
)))
(assert (forall ((m@@43 T@U) (s@@47 T@U) ) (! (let ((V@@50 (IMapTypeInv1 (type m@@43))))
(let ((U@@50 (IMapTypeInv0 (type m@@43))))
 (=> (and (= (type m@@43) (IMapType U@@50 V@@50)) (= (type s@@47) (MapType0Type U@@50 boolType))) (= (|IMap#Domain| (|IMap#Subtract| m@@43 s@@47)) (|Set#Difference| (|IMap#Domain| m@@43) s@@47)))))
 :qid |DafnyPreludebpl.1401:21|
 :skolemid |675|
 :pattern ( (|IMap#Domain| (|IMap#Subtract| m@@43 s@@47)))
)))
(assert (forall ((m@@44 T@U) (s@@48 T@U) (u@@20 T@U) ) (! (let ((V@@51 (IMapTypeInv1 (type m@@44))))
(let ((U@@51 (type u@@20)))
 (=> (and (and (= (type m@@44) (IMapType U@@51 V@@51)) (= (type s@@48) (MapType0Type U@@51 boolType))) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Subtract| m@@44 s@@48)) u@@20))) (= (MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44 s@@48)) u@@20) (MapType0Select (|IMap#Elements| m@@44) u@@20)))))
 :qid |DafnyPreludebpl.1404:21|
 :skolemid |676|
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44 s@@48)) u@@20))
)))
(assert (forall ((x@@42 Int) (y@@12 Int) ) (! (= (INTERNAL_add_boogie x@@42 y@@12) (+ x@@42 y@@12))
 :qid |DafnyPreludebpl.1413:30|
 :skolemid |677|
 :pattern ( (INTERNAL_add_boogie x@@42 y@@12))
)))
(assert (forall ((x@@43 Int) (y@@13 Int) ) (! (= (INTERNAL_sub_boogie x@@43 y@@13) (- x@@43 y@@13))
 :qid |DafnyPreludebpl.1414:30|
 :skolemid |678|
 :pattern ( (INTERNAL_sub_boogie x@@43 y@@13))
)))
(assert (forall ((x@@44 Int) (y@@14 Int) ) (! (= (INTERNAL_mul_boogie x@@44 y@@14) (* x@@44 y@@14))
 :qid |DafnyPreludebpl.1415:30|
 :skolemid |679|
 :pattern ( (INTERNAL_mul_boogie x@@44 y@@14))
)))
(assert (forall ((x@@45 Int) (y@@15 Int) ) (! (= (INTERNAL_div_boogie x@@45 y@@15) (div x@@45 y@@15))
 :qid |DafnyPreludebpl.1416:30|
 :skolemid |680|
 :pattern ( (INTERNAL_div_boogie x@@45 y@@15))
)))
(assert (forall ((x@@46 Int) (y@@16 Int) ) (! (= (INTERNAL_mod_boogie x@@46 y@@16) (mod x@@46 y@@16))
 :qid |DafnyPreludebpl.1417:30|
 :skolemid |681|
 :pattern ( (INTERNAL_mod_boogie x@@46 y@@16))
)))
(assert (forall ((x@@47 Int) (y@@17 Int) ) (! (= (INTERNAL_lt_boogie x@@47 y@@17) (< x@@47 y@@17))
 :qid |DafnyPreludebpl.1418:51|
 :skolemid |682|
 :pattern ( (INTERNAL_lt_boogie x@@47 y@@17))
)))
(assert (forall ((x@@48 Int) (y@@18 Int) ) (! (= (INTERNAL_le_boogie x@@48 y@@18) (<= x@@48 y@@18))
 :qid |DafnyPreludebpl.1419:51|
 :skolemid |683|
 :pattern ( (INTERNAL_le_boogie x@@48 y@@18))
)))
(assert (forall ((x@@49 Int) (y@@19 Int) ) (! (= (INTERNAL_gt_boogie x@@49 y@@19) (> x@@49 y@@19))
 :qid |DafnyPreludebpl.1420:51|
 :skolemid |684|
 :pattern ( (INTERNAL_gt_boogie x@@49 y@@19))
)))
(assert (forall ((x@@50 Int) (y@@20 Int) ) (! (= (INTERNAL_ge_boogie x@@50 y@@20) (>= x@@50 y@@20))
 :qid |DafnyPreludebpl.1421:51|
 :skolemid |685|
 :pattern ( (INTERNAL_ge_boogie x@@50 y@@20))
)))
(assert (forall ((x@@51 Int) (y@@21 Int) ) (! (= (Mul x@@51 y@@21) (* x@@51 y@@21))
 :qid |DafnyPreludebpl.1423:14|
 :skolemid |686|
 :pattern ( (Mul x@@51 y@@21))
)))
(assert (forall ((x@@52 Int) (y@@22 Int) ) (! (= (Div x@@52 y@@22) (div x@@52 y@@22))
 :qid |DafnyPreludebpl.1424:14|
 :skolemid |687|
 :pattern ( (Div x@@52 y@@22))
)))
(assert (forall ((x@@53 Int) (y@@23 Int) ) (! (= (Mod x@@53 y@@23) (mod x@@53 y@@23))
 :qid |DafnyPreludebpl.1425:14|
 :skolemid |688|
 :pattern ( (Mod x@@53 y@@23))
)))
(assert (forall ((x@@54 Int) (y@@24 Int) ) (! (= (Add x@@54 y@@24) (+ x@@54 y@@24))
 :qid |DafnyPreludebpl.1426:14|
 :skolemid |689|
 :pattern ( (Add x@@54 y@@24))
)))
(assert (forall ((x@@55 Int) (y@@25 Int) ) (! (= (Sub x@@55 y@@25) (- x@@55 y@@25))
 :qid |DafnyPreludebpl.1427:14|
 :skolemid |690|
 :pattern ( (Sub x@@55 y@@25))
)))
(assert (forall ((A@@2 T@U) (B T@U) (a@@79 T@U) (b@@58 T@U) ) (!  (=> (and (and (and (and (= (type A@@2) TyType) (= (type B) TyType)) (= (type a@@79) BoxType)) (= (type b@@58) BoxType)) (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58)) (< (BoxRank a@@79) (BoxRank b@@58)))
 :qid |DafnyPreludebpl.1468:15|
 :skolemid |691|
 :pattern ( (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58) (BoxRank a@@79))
 :pattern ( (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58) (BoxRank b@@58))
)))
(assert (forall ((A@@3 T@U) (B@@0 T@U) (a@@80 T@U) (b@@59 T@U) ) (!  (=> (and (and (and (and (= (type A@@3) TyType) (= (type B@@0) TyType)) (= (type a@@80) BoxType)) (= (type b@@59) (SeqType BoxType))) (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59))) (< (BoxRank a@@80) (|Seq#Rank| b@@59)))
 :qid |DafnyPreludebpl.1473:15|
 :skolemid |692|
 :pattern ( (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59)) (BoxRank a@@80))
 :pattern ( (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59)) (|Seq#Rank| b@@59))
)))
(assert (forall ((A@@4 T@U) (B@@1 T@U) (a@@81 T@U) (b@@60 T@U) ) (!  (=> (and (and (and (and (= (type A@@4) TyType) (= (type B@@1) TyType)) (= (type a@@81) (SeqType BoxType))) (= (type b@@60) BoxType)) (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60)) (< (|Seq#Rank| a@@81) (BoxRank b@@60)))
 :qid |DafnyPreludebpl.1478:15|
 :skolemid |693|
 :pattern ( (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60) (|Seq#Rank| a@@81))
 :pattern ( (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60) (BoxRank b@@60))
)))
(assert (= (type Tclass._System.nat) TyType))
(assert (= (Tag Tclass._System.nat) Tagclass._System.nat))
(assert (forall ((arg0@@113 T@U) ) (! (= (type (TagFamily arg0@@113)) TyTagFamilyType)
 :qid |funType:TagFamily|
 :pattern ( (TagFamily arg0@@113))
)))
(assert (= (TagFamily Tclass._System.nat) tytagFamily$nat))
(assert (forall ((bx@@26 T@U) ) (!  (=> (and (= (type bx@@26) BoxType) ($IsBox bx@@26 Tclass._System.nat)) (and (= ($Box ($Unbox intType bx@@26)) bx@@26) ($Is ($Unbox intType bx@@26) Tclass._System.nat)))
 :qid |unknown.0:0|
 :skolemid |694|
 :pattern ( ($IsBox bx@@26 Tclass._System.nat))
)))
(assert (forall ((|x#0| T@U) ) (!  (=> (= (type |x#0|) intType) (= ($Is |x#0| Tclass._System.nat) (INTERNAL_le_boogie 0 (U_2_int |x#0|))))
 :qid |unknown.0:0|
 :skolemid |695|
 :pattern ( ($Is |x#0| Tclass._System.nat))
)))
(assert (forall ((|x#0@@0| T@U) ($h T@U) ) (!  (=> (and (= (type |x#0@@0|) intType) (= (type $h) (MapType0Type refType MapType1Type))) ($IsAlloc |x#0@@0| Tclass._System.nat $h))
 :qid |unknown.0:0|
 :skolemid |696|
 :pattern ( ($IsAlloc |x#0@@0| Tclass._System.nat $h))
)))
(assert (= (Tag Tclass._System.object?) Tagclass._System.object?))
(assert (= (TagFamily Tclass._System.object?) tytagFamily$object))
(assert (forall ((bx@@27 T@U) ) (!  (=> (and (= (type bx@@27) BoxType) ($IsBox bx@@27 Tclass._System.object?)) (and (= ($Box ($Unbox refType bx@@27)) bx@@27) ($Is ($Unbox refType bx@@27) Tclass._System.object?)))
 :qid |unknown.0:0|
 :skolemid |697|
 :pattern ( ($IsBox bx@@27 Tclass._System.object?))
)))
(assert (forall (($o T@U) ) (!  (=> (= (type $o) refType) ($Is $o Tclass._System.object?))
 :qid |unknown.0:0|
 :skolemid |698|
 :pattern ( ($Is $o Tclass._System.object?))
)))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h@@0 T@U) ) (!  (=> (and (= (type $o@@0) refType) (= (type $h@@0) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@0 Tclass._System.object? $h@@0)  (or (= $o@@0 null) (U_2_bool (MapType1Select (MapType0Select $h@@0 $o@@0) alloc)))))
 :qid |unknown.0:0|
 :skolemid |699|
 :pattern ( ($IsAlloc $o@@0 Tclass._System.object? $h@@0))
)))
(assert (= (type Tclass._System.object) TyType))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (= (TagFamily Tclass._System.object) tytagFamily$object))
(assert (forall ((bx@@28 T@U) ) (!  (=> (and (= (type bx@@28) BoxType) ($IsBox bx@@28 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@28)) bx@@28) ($Is ($Unbox refType bx@@28) Tclass._System.object)))
 :qid |unknown.0:0|
 :skolemid |700|
 :pattern ( ($IsBox bx@@28 Tclass._System.object))
)))
(assert (forall ((|c#0| T@U) ) (!  (=> (= (type |c#0|) refType) (= ($Is |c#0| Tclass._System.object)  (and ($Is |c#0| Tclass._System.object?) (not (= |c#0| null)))))
 :qid |unknown.0:0|
 :skolemid |701|
 :pattern ( ($Is |c#0| Tclass._System.object))
)))
(assert (forall ((|c#0@@0| T@U) ($h@@1 T@U) ) (!  (=> (and (= (type |c#0@@0|) refType) (= (type $h@@1) (MapType0Type refType MapType1Type))) (= ($IsAlloc |c#0@@0| Tclass._System.object $h@@1) ($IsAlloc |c#0@@0| Tclass._System.object? $h@@1)))
 :qid |unknown.0:0|
 :skolemid |702|
 :pattern ( ($IsAlloc |c#0@@0| Tclass._System.object $h@@1))
)))
(assert (forall ((arg0@@114 T@U) ) (! (= (type (Tclass._System.array? arg0@@114)) TyType)
 :qid |funType:Tclass._System.array?|
 :pattern ( (Tclass._System.array? arg0@@114))
)))
(assert (forall ((_System.array$arg T@U) ) (!  (=> (= (type _System.array$arg) TyType) (and (= (Tag (Tclass._System.array? _System.array$arg)) Tagclass._System.array?) (= (TagFamily (Tclass._System.array? _System.array$arg)) tytagFamily$array)))
 :qid |unknown.0:0|
 :skolemid |703|
 :pattern ( (Tclass._System.array? _System.array$arg))
)))
(assert (forall ((arg0@@115 T@U) ) (! (= (type (Tclass._System.array?_0 arg0@@115)) TyType)
 :qid |funType:Tclass._System.array?_0|
 :pattern ( (Tclass._System.array?_0 arg0@@115))
)))
(assert (forall ((_System.array$arg@@0 T@U) ) (!  (=> (= (type _System.array$arg@@0) TyType) (= (Tclass._System.array?_0 (Tclass._System.array? _System.array$arg@@0)) _System.array$arg@@0))
 :qid |unknown.0:0|
 :skolemid |704|
 :pattern ( (Tclass._System.array? _System.array$arg@@0))
)))
(assert (forall ((_System.array$arg@@1 T@U) (bx@@29 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@1) TyType) (= (type bx@@29) BoxType)) ($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1))) (and (= ($Box ($Unbox refType bx@@29)) bx@@29) ($Is ($Unbox refType bx@@29) (Tclass._System.array? _System.array$arg@@1))))
 :qid |unknown.0:0|
 :skolemid |705|
 :pattern ( ($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1)))
)))
(assert (forall ((arg0@@116 T@U) ) (! (= (type (dtype arg0@@116)) TyType)
 :qid |funType:dtype|
 :pattern ( (dtype arg0@@116))
)))
(assert (forall ((_System.array$arg@@2 T@U) ($h@@2 T@U) ($o@@1 T@U) ($i0 Int) ) (!  (=> (and (and (and (= (type _System.array$arg@@2) TyType) (= (type $h@@2) (MapType0Type refType MapType1Type))) (= (type $o@@1) refType)) (and (and ($IsGoodHeap $h@@2) (and (not (= $o@@1 null)) (= (dtype $o@@1) (Tclass._System.array? _System.array$arg@@2)))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1))))) ($IsBox (MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0)) _System.array$arg@@2))
 :qid |unknown.0:0|
 :skolemid |706|
 :pattern ( (MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0)) (Tclass._System.array? _System.array$arg@@2))
)))
(assert (forall ((_System.array$arg@@3 T@U) ($h@@3 T@U) ($o@@2 T@U) ($i0@@0 Int) ) (!  (=> (and (and (= (type _System.array$arg@@3) TyType) (= (type $h@@3) (MapType0Type refType MapType1Type))) (= (type $o@@2) refType)) (=> (and (and (and ($IsGoodHeap $h@@3) (and (not (= $o@@2 null)) (= (dtype $o@@2) (Tclass._System.array? _System.array$arg@@3)))) (and (<= 0 $i0@@0) (< $i0@@0 (_System.array.Length $o@@2)))) (U_2_bool (MapType1Select (MapType0Select $h@@3 $o@@2) alloc))) ($IsAllocBox (MapType1Select (MapType0Select $h@@3 $o@@2) (IndexField $i0@@0)) _System.array$arg@@3 $h@@3)))
 :qid |unknown.0:0|
 :skolemid |707|
 :pattern ( (MapType1Select (MapType0Select $h@@3 $o@@2) (IndexField $i0@@0)) (Tclass._System.array? _System.array$arg@@3))
)))
(assert (forall ((_System.array$arg@@4 T@U) ($o@@3 T@U) ) (!  (=> (and (= (type _System.array$arg@@4) TyType) (= (type $o@@3) refType)) (= ($Is $o@@3 (Tclass._System.array? _System.array$arg@@4))  (or (= $o@@3 null) (= (dtype $o@@3) (Tclass._System.array? _System.array$arg@@4)))))
 :qid |unknown.0:0|
 :skolemid |708|
 :pattern ( ($Is $o@@3 (Tclass._System.array? _System.array$arg@@4)))
)))
(assert (forall ((_System.array$arg@@5 T@U) ($o@@4 T@U) ($h@@4 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@5) TyType) (= (type $o@@4) refType)) (= (type $h@@4) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@4 (Tclass._System.array? _System.array$arg@@5) $h@@4)  (or (= $o@@4 null) (U_2_bool (MapType1Select (MapType0Select $h@@4 $o@@4) alloc)))))
 :qid |unknown.0:0|
 :skolemid |709|
 :pattern ( ($IsAlloc $o@@4 (Tclass._System.array? _System.array$arg@@5) $h@@4))
)))
(assert (forall ((_System.array$arg@@6 T@U) ($o@@5 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@6) TyType) (= (type $o@@5) refType)) (and (not (= $o@@5 null)) (= (dtype $o@@5) (Tclass._System.array? _System.array$arg@@6)))) ($Is (int_2_U (_System.array.Length $o@@5)) TInt))
 :qid |unknown.0:0|
 :skolemid |710|
 :pattern ( (_System.array.Length $o@@5) (Tclass._System.array? _System.array$arg@@6))
)))
(assert (forall ((_System.array$arg@@7 T@U) ($h@@5 T@U) ($o@@6 T@U) ) (!  (=> (and (and (and (= (type _System.array$arg@@7) TyType) (= (type $h@@5) (MapType0Type refType MapType1Type))) (= (type $o@@6) refType)) (and (and ($IsGoodHeap $h@@5) (and (not (= $o@@6 null)) (= (dtype $o@@6) (Tclass._System.array? _System.array$arg@@7)))) (U_2_bool (MapType1Select (MapType0Select $h@@5 $o@@6) alloc)))) ($IsAlloc (int_2_U (_System.array.Length $o@@6)) TInt $h@@5))
 :qid |unknown.0:0|
 :skolemid |711|
 :pattern ( (_System.array.Length $o@@6) (MapType1Select (MapType0Select $h@@5 $o@@6) alloc) (Tclass._System.array? _System.array$arg@@7))
)))
(assert (forall ((arg0@@117 T@U) ) (! (= (type (Tclass._System.array arg0@@117)) TyType)
 :qid |funType:Tclass._System.array|
 :pattern ( (Tclass._System.array arg0@@117))
)))
(assert (forall ((_System.array$arg@@8 T@U) ) (!  (=> (= (type _System.array$arg@@8) TyType) (and (= (Tag (Tclass._System.array _System.array$arg@@8)) Tagclass._System.array) (= (TagFamily (Tclass._System.array _System.array$arg@@8)) tytagFamily$array)))
 :qid |unknown.0:0|
 :skolemid |712|
 :pattern ( (Tclass._System.array _System.array$arg@@8))
)))
(assert (forall ((arg0@@118 T@U) ) (! (= (type (Tclass._System.array_0 arg0@@118)) TyType)
 :qid |funType:Tclass._System.array_0|
 :pattern ( (Tclass._System.array_0 arg0@@118))
)))
(assert (forall ((_System.array$arg@@9 T@U) ) (!  (=> (= (type _System.array$arg@@9) TyType) (= (Tclass._System.array_0 (Tclass._System.array _System.array$arg@@9)) _System.array$arg@@9))
 :qid |unknown.0:0|
 :skolemid |713|
 :pattern ( (Tclass._System.array _System.array$arg@@9))
)))
(assert (forall ((_System.array$arg@@10 T@U) (bx@@30 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@10) TyType) (= (type bx@@30) BoxType)) ($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10))) (and (= ($Box ($Unbox refType bx@@30)) bx@@30) ($Is ($Unbox refType bx@@30) (Tclass._System.array _System.array$arg@@10))))
 :qid |unknown.0:0|
 :skolemid |714|
 :pattern ( ($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10)))
)))
(assert (forall ((_System.array$arg@@11 T@U) (|c#0@@1| T@U) ) (!  (=> (and (= (type _System.array$arg@@11) TyType) (= (type |c#0@@1|) refType)) (= ($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11))  (and ($Is |c#0@@1| (Tclass._System.array? _System.array$arg@@11)) (not (= |c#0@@1| null)))))
 :qid |unknown.0:0|
 :skolemid |715|
 :pattern ( ($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11)))
)))
(assert (forall ((_System.array$arg@@12 T@U) (|c#0@@2| T@U) ($h@@6 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@12) TyType) (= (type |c#0@@2|) refType)) (= (type $h@@6) (MapType0Type refType MapType1Type))) (= ($IsAlloc |c#0@@2| (Tclass._System.array _System.array$arg@@12) $h@@6) ($IsAlloc |c#0@@2| (Tclass._System.array? _System.array$arg@@12) $h@@6)))
 :qid |unknown.0:0|
 :skolemid |716|
 :pattern ( ($IsAlloc |c#0@@2| (Tclass._System.array _System.array$arg@@12) $h@@6))
)))
(assert (forall ((arg0@@119 T@U) (arg1@@53 T@U) ) (! (= (type (Tclass._System.___hFunc1 arg0@@119 arg1@@53)) TyType)
 :qid |funType:Tclass._System.___hFunc1|
 :pattern ( (Tclass._System.___hFunc1 arg0@@119 arg1@@53))
)))
(assert (forall ((|#$T0| T@U) (|#$R| T@U) ) (!  (=> (and (= (type |#$T0|) TyType) (= (type |#$R|) TyType)) (and (= (Tag (Tclass._System.___hFunc1 |#$T0| |#$R|)) Tagclass._System.___hFunc1) (= (TagFamily (Tclass._System.___hFunc1 |#$T0| |#$R|)) |tytagFamily$_#Func1|)))
 :qid |unknown.0:0|
 :skolemid |717|
 :pattern ( (Tclass._System.___hFunc1 |#$T0| |#$R|))
)))
(assert (forall ((arg0@@120 T@U) ) (! (= (type (Tclass._System.___hFunc1_0 arg0@@120)) TyType)
 :qid |funType:Tclass._System.___hFunc1_0|
 :pattern ( (Tclass._System.___hFunc1_0 arg0@@120))
)))
(assert (forall ((|#$T0@@0| T@U) (|#$R@@0| T@U) ) (!  (=> (and (= (type |#$T0@@0|) TyType) (= (type |#$R@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|)) |#$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |718|
 :pattern ( (Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|))
)))
(assert (forall ((arg0@@121 T@U) ) (! (= (type (Tclass._System.___hFunc1_1 arg0@@121)) TyType)
 :qid |funType:Tclass._System.___hFunc1_1|
 :pattern ( (Tclass._System.___hFunc1_1 arg0@@121))
)))
(assert (forall ((|#$T0@@1| T@U) (|#$R@@1| T@U) ) (!  (=> (and (= (type |#$T0@@1|) TyType) (= (type |#$R@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|)) |#$R@@1|))
 :qid |unknown.0:0|
 :skolemid |719|
 :pattern ( (Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|))
)))
(assert (forall ((|#$T0@@2| T@U) (|#$R@@2| T@U) (bx@@31 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@2|) TyType) (= (type |#$R@@2|) TyType)) (= (type bx@@31) BoxType)) ($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@31)) bx@@31) ($Is ($Unbox HandleTypeType bx@@31) (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|))))
 :qid |unknown.0:0|
 :skolemid |720|
 :pattern ( ($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|)))
)))
(assert  (and (and (and (and (and (and (and (and (forall ((arg0@@122 T@T) (arg1@@54 T@T) (arg2@@8 T@T) ) (! (= (Ctor (MapType2Type arg0@@122 arg1@@54 arg2@@8)) 24)
 :qid |ctor:MapType2Type|
)) (forall ((arg0@@123 T@T) (arg1@@55 T@T) (arg2@@9 T@T) ) (! (= (MapType2TypeInv0 (MapType2Type arg0@@123 arg1@@55 arg2@@9)) arg0@@123)
 :qid |typeInv:MapType2TypeInv0|
 :pattern ( (MapType2Type arg0@@123 arg1@@55 arg2@@9))
))) (forall ((arg0@@124 T@T) (arg1@@56 T@T) (arg2@@10 T@T) ) (! (= (MapType2TypeInv1 (MapType2Type arg0@@124 arg1@@56 arg2@@10)) arg1@@56)
 :qid |typeInv:MapType2TypeInv1|
 :pattern ( (MapType2Type arg0@@124 arg1@@56 arg2@@10))
))) (forall ((arg0@@125 T@T) (arg1@@57 T@T) (arg2@@11 T@T) ) (! (= (MapType2TypeInv2 (MapType2Type arg0@@125 arg1@@57 arg2@@11)) arg2@@11)
 :qid |typeInv:MapType2TypeInv2|
 :pattern ( (MapType2Type arg0@@125 arg1@@57 arg2@@11))
))) (forall ((arg0@@126 T@U) (arg1@@58 T@U) (arg2@@12 T@U) ) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@126))))
(= (type (MapType2Select arg0@@126 arg1@@58 arg2@@12)) aVar2))
 :qid |funType:MapType2Select|
 :pattern ( (MapType2Select arg0@@126 arg1@@58 arg2@@12))
))) (forall ((arg0@@127 T@U) (arg1@@59 T@U) (arg2@@13 T@U) (arg3@@1 T@U) ) (! (let ((aVar2@@0 (type arg3@@1)))
(let ((aVar1@@2 (type arg2@@13)))
(let ((aVar0@@0 (type arg1@@59)))
(= (type (MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1)) (MapType2Type aVar0@@0 aVar1@@2 aVar2@@0)))))
 :qid |funType:MapType2Store|
 :pattern ( (MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1))
))) (forall ((m@@45 T@U) (x0@@5 T@U) (x1 T@U) (val@@6 T@U) ) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@45))))
 (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@45 x0@@5 x1 val@@6) x0@@5 x1) val@@6)))
 :qid |mapAx0:MapType2Select|
 :weight 0
))) (and (and (forall ((val@@7 T@U) (m@@46 T@U) (x0@@6 T@U) (x1@@0 T@U) (y0@@3 T@U) (y1 T@U) ) (!  (or (= x0@@6 y0@@3) (= (MapType2Select (MapType2Store m@@46 x0@@6 x1@@0 val@@7) y0@@3 y1) (MapType2Select m@@46 y0@@3 y1)))
 :qid |mapAx1:MapType2Select:0|
 :weight 0
)) (forall ((val@@8 T@U) (m@@47 T@U) (x0@@7 T@U) (x1@@1 T@U) (y0@@4 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType2Select (MapType2Store m@@47 x0@@7 x1@@1 val@@8) y0@@4 y1@@0) (MapType2Select m@@47 y0@@4 y1@@0)))
 :qid |mapAx1:MapType2Select:1|
 :weight 0
))) (forall ((val@@9 T@U) (m@@48 T@U) (x0@@8 T@U) (x1@@2 T@U) (y0@@5 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType2Select (MapType2Store m@@48 x0@@8 x1@@2 val@@9) y0@@5 y1@@1) (MapType2Select m@@48 y0@@5 y1@@1)))
 :qid |mapAx2:MapType2Select|
 :weight 0
)))) (forall ((arg0@@128 T@U) (arg1@@60 T@U) (arg2@@14 T@U) ) (! (= (type (Handle1 arg0@@128 arg1@@60 arg2@@14)) HandleTypeType)
 :qid |funType:Handle1|
 :pattern ( (Handle1 arg0@@128 arg1@@60 arg2@@14))
))))
(assert (forall ((t0@@16 T@U) (t1@@7 T@U) (heap@@1 T@U) (h@@21 T@U) (r@@6 T@U) (rd T@U) (bx0 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@16) TyType) (= (type t1@@7) TyType)) (= (type heap@@1) (MapType0Type refType MapType1Type))) (= (type h@@21) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@6) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0) (MapType2Select h@@21 heap@@1 bx0)))
 :qid |unknown.0:0|
 :skolemid |721|
 :pattern ( (Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0))
)))
(assert (forall ((t0@@17 T@U) (t1@@8 T@U) (heap@@2 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@0 T@U) (bx0@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@17) TyType) (= (type t1@@8) TyType)) (= (type heap@@2) (MapType0Type refType MapType1Type))) (= (type h@@22) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@7) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd@@0) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@7 heap@@2 bx0@@0))) (Requires1 t0@@17 t1@@8 heap@@2 (Handle1 h@@22 r@@7 rd@@0) bx0@@0))
 :qid |unknown.0:0|
 :skolemid |722|
 :pattern ( (Requires1 t0@@17 t1@@8 heap@@2 (Handle1 h@@22 r@@7 rd@@0) bx0@@0))
)))
(assert (forall ((arg0@@129 T@U) (arg1@@61 T@U) (arg2@@15 T@U) (arg3@@2 T@U) (arg4@@0 T@U) ) (! (= (type (Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads1|
 :pattern ( (Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0))
)))
(assert (forall ((t0@@18 T@U) (t1@@9 T@U) (heap@@3 T@U) (h@@23 T@U) (r@@8 T@U) (rd@@1 T@U) (bx0@@1 T@U) (bx@@32 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@18) TyType) (= (type t1@@9) TyType)) (= (type heap@@3) (MapType0Type refType MapType1Type))) (= (type h@@23) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd@@1) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@32) BoxType)) (= (U_2_bool (MapType0Select (Reads1 t0@@18 t1@@9 heap@@3 (Handle1 h@@23 r@@8 rd@@1) bx0@@1) bx@@32)) (U_2_bool (MapType0Select (MapType2Select rd@@1 heap@@3 bx0@@1) bx@@32))))
 :qid |unknown.0:0|
 :skolemid |723|
 :pattern ( (MapType0Select (Reads1 t0@@18 t1@@9 heap@@3 (Handle1 h@@23 r@@8 rd@@1) bx0@@1) bx@@32))
)))
(assert (forall ((t0@@19 T@U) (t1@@10 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U) (bx0@@2 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@19) TyType) (= (type t1@@10) TyType)) (= (type h0@@0) (MapType0Type refType MapType1Type))) (= (type h1@@0) (MapType0Type refType MapType1Type))) (= (type f@@5) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($IsBox bx0@@2 t0@@19) ($Is f@@5 (Tclass._System.___hFunc1 t0@@19 t1@@10)))) (forall ((o@@44 T@U) (fld T@U) ) (! (let ((a@@82 (FieldTypeInv0 (type fld))))
 (=> (and (and (= (type o@@44) refType) (= (type fld) (FieldType a@@82))) (and (not (= o@@44 null)) (U_2_bool (MapType0Select (Reads1 t0@@19 t1@@10 h0@@0 f@@5 bx0@@2) ($Box o@@44))))) (= (MapType1Select (MapType0Select h0@@0 o@@44) fld) (MapType1Select (MapType0Select h1@@0 o@@44) fld))))
 :qid |unknown.0:0|
 :skolemid |724|
 :no-pattern (type o@@44)
 :no-pattern (type fld)
 :no-pattern (U_2_int o@@44)
 :no-pattern (U_2_bool o@@44)
 :no-pattern (U_2_int fld)
 :no-pattern (U_2_bool fld)
)))) (= (Reads1 t0@@19 t1@@10 h0@@0 f@@5 bx0@@2) (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2)))
 :qid |unknown.0:0|
 :skolemid |725|
 :pattern ( ($HeapSucc h0@@0 h1@@0) (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2))
)))
(assert (forall ((t0@@20 T@U) (t1@@11 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U) (bx0@@3 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@20) TyType) (= (type t1@@11) TyType)) (= (type h0@@1) (MapType0Type refType MapType1Type))) (= (type h1@@1) (MapType0Type refType MapType1Type))) (= (type f@@6) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($IsBox bx0@@3 t0@@20) ($Is f@@6 (Tclass._System.___hFunc1 t0@@20 t1@@11)))) (forall ((o@@45 T@U) (fld@@0 T@U) ) (! (let ((a@@83 (FieldTypeInv0 (type fld@@0))))
 (=> (and (and (= (type o@@45) refType) (= (type fld@@0) (FieldType a@@83))) (and (not (= o@@45 null)) (U_2_bool (MapType0Select (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3) ($Box o@@45))))) (= (MapType1Select (MapType0Select h0@@1 o@@45) fld@@0) (MapType1Select (MapType0Select h1@@1 o@@45) fld@@0))))
 :qid |unknown.0:0|
 :skolemid |726|
 :no-pattern (type o@@45)
 :no-pattern (type fld@@0)
 :no-pattern (U_2_int o@@45)
 :no-pattern (U_2_bool o@@45)
 :no-pattern (U_2_int fld@@0)
 :no-pattern (U_2_bool fld@@0)
)))) (= (Reads1 t0@@20 t1@@11 h0@@1 f@@6 bx0@@3) (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3)))
 :qid |unknown.0:0|
 :skolemid |727|
 :pattern ( ($HeapSucc h0@@1 h1@@1) (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3))
)))
(assert (forall ((t0@@21 T@U) (t1@@12 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U) (bx0@@4 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@21) TyType) (= (type t1@@12) TyType)) (= (type h0@@2) (MapType0Type refType MapType1Type))) (= (type h1@@2) (MapType0Type refType MapType1Type))) (= (type f@@7) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($IsBox bx0@@4 t0@@21) ($Is f@@7 (Tclass._System.___hFunc1 t0@@21 t1@@12)))) (forall ((o@@46 T@U) (fld@@1 T@U) ) (! (let ((a@@84 (FieldTypeInv0 (type fld@@1))))
 (=> (and (and (= (type o@@46) refType) (= (type fld@@1) (FieldType a@@84))) (and (not (= o@@46 null)) (U_2_bool (MapType0Select (Reads1 t0@@21 t1@@12 h0@@2 f@@7 bx0@@4) ($Box o@@46))))) (= (MapType1Select (MapType0Select h0@@2 o@@46) fld@@1) (MapType1Select (MapType0Select h1@@2 o@@46) fld@@1))))
 :qid |unknown.0:0|
 :skolemid |728|
 :no-pattern (type o@@46)
 :no-pattern (type fld@@1)
 :no-pattern (U_2_int o@@46)
 :no-pattern (U_2_bool o@@46)
 :no-pattern (U_2_int fld@@1)
 :no-pattern (U_2_bool fld@@1)
)))) (= (Requires1 t0@@21 t1@@12 h0@@2 f@@7 bx0@@4) (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4)))
 :qid |unknown.0:0|
 :skolemid |729|
 :pattern ( ($HeapSucc h0@@2 h1@@2) (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4))
)))
(assert (forall ((t0@@22 T@U) (t1@@13 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U) (bx0@@5 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@13) TyType)) (= (type h0@@3) (MapType0Type refType MapType1Type))) (= (type h1@@3) (MapType0Type refType MapType1Type))) (= (type f@@8) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($IsBox bx0@@5 t0@@22) ($Is f@@8 (Tclass._System.___hFunc1 t0@@22 t1@@13)))) (forall ((o@@47 T@U) (fld@@2 T@U) ) (! (let ((a@@85 (FieldTypeInv0 (type fld@@2))))
 (=> (and (and (= (type o@@47) refType) (= (type fld@@2) (FieldType a@@85))) (and (not (= o@@47 null)) (U_2_bool (MapType0Select (Reads1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5) ($Box o@@47))))) (= (MapType1Select (MapType0Select h0@@3 o@@47) fld@@2) (MapType1Select (MapType0Select h1@@3 o@@47) fld@@2))))
 :qid |unknown.0:0|
 :skolemid |730|
 :no-pattern (type o@@47)
 :no-pattern (type fld@@2)
 :no-pattern (U_2_int o@@47)
 :no-pattern (U_2_bool o@@47)
 :no-pattern (U_2_int fld@@2)
 :no-pattern (U_2_bool fld@@2)
)))) (= (Requires1 t0@@22 t1@@13 h0@@3 f@@8 bx0@@5) (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5)))
 :qid |unknown.0:0|
 :skolemid |731|
 :pattern ( ($HeapSucc h0@@3 h1@@3) (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5))
)))
(assert (forall ((t0@@23 T@U) (t1@@14 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U) (bx0@@6 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@14) TyType)) (= (type h0@@4) (MapType0Type refType MapType1Type))) (= (type h1@@4) (MapType0Type refType MapType1Type))) (= (type f@@9) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($IsBox bx0@@6 t0@@23) ($Is f@@9 (Tclass._System.___hFunc1 t0@@23 t1@@14)))) (forall ((o@@48 T@U) (fld@@3 T@U) ) (! (let ((a@@86 (FieldTypeInv0 (type fld@@3))))
 (=> (and (and (= (type o@@48) refType) (= (type fld@@3) (FieldType a@@86))) (and (not (= o@@48 null)) (U_2_bool (MapType0Select (Reads1 t0@@23 t1@@14 h0@@4 f@@9 bx0@@6) ($Box o@@48))))) (= (MapType1Select (MapType0Select h0@@4 o@@48) fld@@3) (MapType1Select (MapType0Select h1@@4 o@@48) fld@@3))))
 :qid |unknown.0:0|
 :skolemid |732|
 :no-pattern (type o@@48)
 :no-pattern (type fld@@3)
 :no-pattern (U_2_int o@@48)
 :no-pattern (U_2_bool o@@48)
 :no-pattern (U_2_int fld@@3)
 :no-pattern (U_2_bool fld@@3)
)))) (= (Apply1 t0@@23 t1@@14 h0@@4 f@@9 bx0@@6) (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6)))
 :qid |unknown.0:0|
 :skolemid |733|
 :pattern ( ($HeapSucc h0@@4 h1@@4) (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6))
)))
(assert (forall ((t0@@24 T@U) (t1@@15 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U) (bx0@@7 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@15) TyType)) (= (type h0@@5) (MapType0Type refType MapType1Type))) (= (type h1@@5) (MapType0Type refType MapType1Type))) (= (type f@@10) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($IsBox bx0@@7 t0@@24) ($Is f@@10 (Tclass._System.___hFunc1 t0@@24 t1@@15)))) (forall ((o@@49 T@U) (fld@@4 T@U) ) (! (let ((a@@87 (FieldTypeInv0 (type fld@@4))))
 (=> (and (and (= (type o@@49) refType) (= (type fld@@4) (FieldType a@@87))) (and (not (= o@@49 null)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7) ($Box o@@49))))) (= (MapType1Select (MapType0Select h0@@5 o@@49) fld@@4) (MapType1Select (MapType0Select h1@@5 o@@49) fld@@4))))
 :qid |unknown.0:0|
 :skolemid |734|
 :no-pattern (type o@@49)
 :no-pattern (type fld@@4)
 :no-pattern (U_2_int o@@49)
 :no-pattern (U_2_bool o@@49)
 :no-pattern (U_2_int fld@@4)
 :no-pattern (U_2_bool fld@@4)
)))) (= (Apply1 t0@@24 t1@@15 h0@@5 f@@10 bx0@@7) (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7)))
 :qid |unknown.0:0|
 :skolemid |735|
 :pattern ( ($HeapSucc h0@@5 h1@@5) (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7))
)))
(assert (forall ((t0@@25 T@U) (t1@@16 T@U) (heap@@4 T@U) (f@@11 T@U) (bx0@@8 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@16) TyType)) (= (type heap@@4) (MapType0Type refType MapType1Type))) (= (type f@@11) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap heap@@4) (and ($IsBox bx0@@8 t0@@25) ($Is f@@11 (Tclass._System.___hFunc1 t0@@25 t1@@16))))) (= (|Set#Equal| (Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |736|
 :pattern ( (Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8) ($IsGoodHeap heap@@4))
 :pattern ( (Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8))
)))
(assert (forall ((t0@@26 T@U) (t1@@17 T@U) (heap@@5 T@U) (f@@12 T@U) (bx0@@9 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@17) TyType)) (= (type heap@@5) (MapType0Type refType MapType1Type))) (= (type f@@12) HandleTypeType)) (= (type bx0@@9) BoxType)) (and (and ($IsGoodHeap heap@@5) (and ($IsBox bx0@@9 t0@@26) ($Is f@@12 (Tclass._System.___hFunc1 t0@@26 t1@@17)))) (|Set#Equal| (Reads1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) (|Set#Empty| BoxType)))) (= (Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) (Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9)))
 :qid |unknown.0:0|
 :skolemid |737|
 :pattern ( (Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) ($IsGoodHeap heap@@5))
 :pattern ( (Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9))
)))
(assert (forall ((f@@13 T@U) (t0@@27 T@U) (t1@@18 T@U) ) (!  (=> (and (and (= (type f@@13) HandleTypeType) (= (type t0@@27) TyType)) (= (type t1@@18) TyType)) (= ($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)) (forall ((h@@24 T@U) (bx0@@10 T@U) ) (!  (=> (and (= (type h@@24) (MapType0Type refType MapType1Type)) (= (type bx0@@10) BoxType)) (=> (and (and ($IsGoodHeap h@@24) ($IsBox bx0@@10 t0@@27)) (Requires1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10)) ($IsBox (Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10) t1@@18)))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |738|
 :pattern ( (Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10))
))))
 :qid |unknown.0:0|
 :skolemid |739|
 :pattern ( ($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)))
)))
(assert (forall ((f@@14 T@U) (t0@@28 T@U) (t1@@19 T@U) (u0 T@U) (u1 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@14) HandleTypeType) (= (type t0@@28) TyType)) (= (type t1@@19) TyType)) (= (type u0) TyType)) (= (type u1) TyType)) (and (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19)) (forall ((bx@@33 T@U) ) (!  (=> (and (= (type bx@@33) BoxType) ($IsBox bx@@33 u0)) ($IsBox bx@@33 t0@@28))
 :qid |unknown.0:0|
 :skolemid |740|
 :pattern ( ($IsBox bx@@33 u0))
 :pattern ( ($IsBox bx@@33 t0@@28))
))) (forall ((bx@@34 T@U) ) (!  (=> (and (= (type bx@@34) BoxType) ($IsBox bx@@34 t1@@19)) ($IsBox bx@@34 u1))
 :qid |unknown.0:0|
 :skolemid |741|
 :pattern ( ($IsBox bx@@34 t1@@19))
 :pattern ( ($IsBox bx@@34 u1))
)))) ($Is f@@14 (Tclass._System.___hFunc1 u0 u1)))
 :qid |unknown.0:0|
 :skolemid |742|
 :pattern ( ($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19)) ($Is f@@14 (Tclass._System.___hFunc1 u0 u1)))
)))
(assert (forall ((f@@15 T@U) (t0@@29 T@U) (t1@@20 T@U) (h@@25 T@U) ) (!  (=> (and (and (and (and (= (type f@@15) HandleTypeType) (= (type t0@@29) TyType)) (= (type t1@@20) TyType)) (= (type h@@25) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@25)) (= ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25) (forall ((bx0@@11 T@U) ) (!  (=> (= (type bx0@@11) BoxType) (=> (and (and ($IsBox bx0@@11 t0@@29) ($IsAllocBox bx0@@11 t0@@29 h@@25)) (Requires1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11)) (forall ((r@@9 T@U) ) (!  (=> (= (type r@@9) refType) (=> (and (not (= r@@9 null)) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11) ($Box r@@9)))) (U_2_bool (MapType1Select (MapType0Select h@@25 r@@9) alloc))))
 :qid |unknown.0:0|
 :skolemid |743|
 :pattern ( (MapType0Select (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11) ($Box r@@9)))
))))
 :qid |unknown.0:0|
 :skolemid |744|
 :pattern ( (Apply1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
 :pattern ( (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
))))
 :qid |unknown.0:0|
 :skolemid |745|
 :pattern ( ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25))
)))
(assert (forall ((f@@16 T@U) (t0@@30 T@U) (t1@@21 T@U) (h@@26 T@U) ) (!  (=> (and (and (and (and (= (type f@@16) HandleTypeType) (= (type t0@@30) TyType)) (= (type t1@@21) TyType)) (= (type h@@26) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@26) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))) (forall ((bx0@@12 T@U) ) (!  (=> (= (type bx0@@12) BoxType) (=> (and ($IsAllocBox bx0@@12 t0@@30 h@@26) (Requires1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12)) ($IsAllocBox (Apply1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12) t1@@21 h@@26)))
 :qid |unknown.0:0|
 :skolemid |746|
 :pattern ( (Apply1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12))
)))
 :qid |unknown.0:0|
 :skolemid |747|
 :pattern ( ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))
)))
(assert (forall ((arg0@@130 T@U) (arg1@@62 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1|
 :pattern ( (Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62))
)))
(assert (forall ((|#$T0@@3| T@U) (|#$R@@3| T@U) ) (!  (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$R@@3|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|)) Tagclass._System.___hPartialFunc1) (= (TagFamily (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|)) |tytagFamily$_#PartialFunc1|)))
 :qid |unknown.0:0|
 :skolemid |748|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|))
)))
(assert (forall ((arg0@@131 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1_0 arg0@@131)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1_0|
 :pattern ( (Tclass._System.___hPartialFunc1_0 arg0@@131))
)))
(assert (forall ((|#$T0@@4| T@U) (|#$R@@4| T@U) ) (!  (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$R@@4|) TyType)) (= (Tclass._System.___hPartialFunc1_0 (Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|)) |#$T0@@4|))
 :qid |unknown.0:0|
 :skolemid |749|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|))
)))
(assert (forall ((arg0@@132 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1_1 arg0@@132)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1_1|
 :pattern ( (Tclass._System.___hPartialFunc1_1 arg0@@132))
)))
(assert (forall ((|#$T0@@5| T@U) (|#$R@@5| T@U) ) (!  (=> (and (= (type |#$T0@@5|) TyType) (= (type |#$R@@5|) TyType)) (= (Tclass._System.___hPartialFunc1_1 (Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|)) |#$R@@5|))
 :qid |unknown.0:0|
 :skolemid |750|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|))
)))
(assert (forall ((|#$T0@@6| T@U) (|#$R@@6| T@U) (bx@@35 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@6|) TyType) (= (type |#$R@@6|) TyType)) (= (type bx@@35) BoxType)) ($IsBox bx@@35 (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|))) (and (= ($Box ($Unbox HandleTypeType bx@@35)) bx@@35) ($Is ($Unbox HandleTypeType bx@@35) (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|))))
 :qid |unknown.0:0|
 :skolemid |751|
 :pattern ( ($IsBox bx@@35 (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|)))
)))
(assert (forall ((|#$T0@@7| T@U) (|#$R@@7| T@U) (|f#0| T@U) ) (!  (=> (and (and (= (type |#$T0@@7|) TyType) (= (type |#$R@@7|) TyType)) (= (type |f#0|) HandleTypeType)) (= ($Is |f#0| (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|))  (and ($Is |f#0| (Tclass._System.___hFunc1 |#$T0@@7| |#$R@@7|)) (forall ((|x0#0| T@U) ) (!  (=> (and (= (type |x0#0|) BoxType) ($IsBox |x0#0| |#$T0@@7|)) (|Set#Equal| (Reads1 |#$T0@@7| |#$R@@7| $OneHeap |f#0| |x0#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |752|
 :no-pattern (type |x0#0|)
 :no-pattern (U_2_int |x0#0|)
 :no-pattern (U_2_bool |x0#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |753|
 :pattern ( ($Is |f#0| (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|)))
)))
(assert (forall ((|#$T0@@8| T@U) (|#$R@@8| T@U) (|f#0@@0| T@U) ($h@@7 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@8|) TyType) (= (type |#$R@@8|) TyType)) (= (type |f#0@@0|) HandleTypeType)) (= (type $h@@7) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@0| (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|) $h@@7) ($IsAlloc |f#0@@0| (Tclass._System.___hFunc1 |#$T0@@8| |#$R@@8|) $h@@7)))
 :qid |unknown.0:0|
 :skolemid |754|
 :pattern ( ($IsAlloc |f#0@@0| (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|) $h@@7))
)))
(assert (forall ((arg0@@133 T@U) (arg1@@63 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1|
 :pattern ( (Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63))
)))
(assert (forall ((|#$T0@@9| T@U) (|#$R@@9| T@U) ) (!  (=> (and (= (type |#$T0@@9|) TyType) (= (type |#$R@@9|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|)) Tagclass._System.___hTotalFunc1) (= (TagFamily (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|)) |tytagFamily$_#TotalFunc1|)))
 :qid |unknown.0:0|
 :skolemid |755|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|))
)))
(assert (forall ((arg0@@134 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1_0 arg0@@134)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1_0|
 :pattern ( (Tclass._System.___hTotalFunc1_0 arg0@@134))
)))
(assert (forall ((|#$T0@@10| T@U) (|#$R@@10| T@U) ) (!  (=> (and (= (type |#$T0@@10|) TyType) (= (type |#$R@@10|) TyType)) (= (Tclass._System.___hTotalFunc1_0 (Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|)) |#$T0@@10|))
 :qid |unknown.0:0|
 :skolemid |756|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|))
)))
(assert (forall ((arg0@@135 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1_1 arg0@@135)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1_1|
 :pattern ( (Tclass._System.___hTotalFunc1_1 arg0@@135))
)))
(assert (forall ((|#$T0@@11| T@U) (|#$R@@11| T@U) ) (!  (=> (and (= (type |#$T0@@11|) TyType) (= (type |#$R@@11|) TyType)) (= (Tclass._System.___hTotalFunc1_1 (Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|)) |#$R@@11|))
 :qid |unknown.0:0|
 :skolemid |757|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|))
)))
(assert (forall ((|#$T0@@12| T@U) (|#$R@@12| T@U) (bx@@36 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@12|) TyType) (= (type |#$R@@12|) TyType)) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|))) (and (= ($Box ($Unbox HandleTypeType bx@@36)) bx@@36) ($Is ($Unbox HandleTypeType bx@@36) (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|))))
 :qid |unknown.0:0|
 :skolemid |758|
 :pattern ( ($IsBox bx@@36 (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|)))
)))
(assert (forall ((|#$T0@@13| T@U) (|#$R@@13| T@U) (|f#0@@1| T@U) ) (!  (=> (and (and (= (type |#$T0@@13|) TyType) (= (type |#$R@@13|) TyType)) (= (type |f#0@@1|) HandleTypeType)) (= ($Is |f#0@@1| (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|))  (and ($Is |f#0@@1| (Tclass._System.___hPartialFunc1 |#$T0@@13| |#$R@@13|)) (forall ((|x0#0@@0| T@U) ) (!  (=> (and (= (type |x0#0@@0|) BoxType) ($IsBox |x0#0@@0| |#$T0@@13|)) (Requires1 |#$T0@@13| |#$R@@13| $OneHeap |f#0@@1| |x0#0@@0|))
 :qid |unknown.0:0|
 :skolemid |759|
 :no-pattern (type |x0#0@@0|)
 :no-pattern (U_2_int |x0#0@@0|)
 :no-pattern (U_2_bool |x0#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |760|
 :pattern ( ($Is |f#0@@1| (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|)))
)))
(assert (forall ((|#$T0@@14| T@U) (|#$R@@14| T@U) (|f#0@@2| T@U) ($h@@8 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@14|) TyType) (= (type |#$R@@14|) TyType)) (= (type |f#0@@2|) HandleTypeType)) (= (type $h@@8) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@2| (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|) $h@@8) ($IsAlloc |f#0@@2| (Tclass._System.___hPartialFunc1 |#$T0@@14| |#$R@@14|) $h@@8)))
 :qid |unknown.0:0|
 :skolemid |761|
 :pattern ( ($IsAlloc |f#0@@2| (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|) $h@@8))
)))
(assert (forall ((arg0@@136 T@U) ) (! (= (type (Tclass._System.___hFunc0 arg0@@136)) TyType)
 :qid |funType:Tclass._System.___hFunc0|
 :pattern ( (Tclass._System.___hFunc0 arg0@@136))
)))
(assert (forall ((|#$R@@15| T@U) ) (!  (=> (= (type |#$R@@15|) TyType) (and (= (Tag (Tclass._System.___hFunc0 |#$R@@15|)) Tagclass._System.___hFunc0) (= (TagFamily (Tclass._System.___hFunc0 |#$R@@15|)) |tytagFamily$_#Func0|)))
 :qid |unknown.0:0|
 :skolemid |762|
 :pattern ( (Tclass._System.___hFunc0 |#$R@@15|))
)))
(assert (forall ((arg0@@137 T@U) ) (! (= (type (Tclass._System.___hFunc0_0 arg0@@137)) TyType)
 :qid |funType:Tclass._System.___hFunc0_0|
 :pattern ( (Tclass._System.___hFunc0_0 arg0@@137))
)))
(assert (forall ((|#$R@@16| T@U) ) (!  (=> (= (type |#$R@@16|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$R@@16|)) |#$R@@16|))
 :qid |unknown.0:0|
 :skolemid |763|
 :pattern ( (Tclass._System.___hFunc0 |#$R@@16|))
)))
(assert (forall ((|#$R@@17| T@U) (bx@@37 T@U) ) (!  (=> (and (and (= (type |#$R@@17|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$R@@17|))))
 :qid |unknown.0:0|
 :skolemid |764|
 :pattern ( ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|)))
)))
(assert  (and (forall ((arg0@@138 T@U) (arg1@@64 T@U) (arg2@@16 T@U) ) (! (= (type (Apply0 arg0@@138 arg1@@64 arg2@@16)) BoxType)
 :qid |funType:Apply0|
 :pattern ( (Apply0 arg0@@138 arg1@@64 arg2@@16))
)) (forall ((arg0@@139 T@U) (arg1@@65 T@U) (arg2@@17 T@U) ) (! (= (type (Handle0 arg0@@139 arg1@@65 arg2@@17)) HandleTypeType)
 :qid |funType:Handle0|
 :pattern ( (Handle0 arg0@@139 arg1@@65 arg2@@17))
))))
(assert (forall ((t0@@31 T@U) (heap@@6 T@U) (h@@27 T@U) (r@@10 T@U) (rd@@2 T@U) ) (!  (=> (and (and (and (and (= (type t0@@31) TyType) (= (type heap@@6) (MapType0Type refType MapType1Type))) (= (type h@@27) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@10) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@2) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2)) (MapType0Select h@@27 heap@@6)))
 :qid |unknown.0:0|
 :skolemid |765|
 :pattern ( (Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2)))
)))
(assert (forall ((t0@@32 T@U) (heap@@7 T@U) (h@@28 T@U) (r@@11 T@U) (rd@@3 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@32) TyType) (= (type heap@@7) (MapType0Type refType MapType1Type))) (= (type h@@28) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@11) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@3) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@11 heap@@7))) (Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3)))
 :qid |unknown.0:0|
 :skolemid |766|
 :pattern ( (Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3)))
)))
(assert (forall ((arg0@@140 T@U) (arg1@@66 T@U) (arg2@@18 T@U) ) (! (= (type (Reads0 arg0@@140 arg1@@66 arg2@@18)) (MapType0Type BoxType boolType))
 :qid |funType:Reads0|
 :pattern ( (Reads0 arg0@@140 arg1@@66 arg2@@18))
)))
(assert (forall ((t0@@33 T@U) (heap@@8 T@U) (h@@29 T@U) (r@@12 T@U) (rd@@4 T@U) (bx@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@33) TyType) (= (type heap@@8) (MapType0Type refType MapType1Type))) (= (type h@@29) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@12) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@4) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (= (U_2_bool (MapType0Select (Reads0 t0@@33 heap@@8 (Handle0 h@@29 r@@12 rd@@4)) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@4 heap@@8) bx@@38))))
 :qid |unknown.0:0|
 :skolemid |767|
 :pattern ( (MapType0Select (Reads0 t0@@33 heap@@8 (Handle0 h@@29 r@@12 rd@@4)) bx@@38))
)))
(assert (forall ((t0@@34 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@17 T@U) ) (!  (=> (and (and (and (and (= (type t0@@34) TyType) (= (type h0@@6) (MapType0Type refType MapType1Type))) (= (type h1@@6) (MapType0Type refType MapType1Type))) (= (type f@@17) HandleTypeType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) ($Is f@@17 (Tclass._System.___hFunc0 t0@@34))) (forall ((o@@50 T@U) (fld@@5 T@U) ) (! (let ((a@@88 (FieldTypeInv0 (type fld@@5))))
 (=> (and (and (= (type o@@50) refType) (= (type fld@@5) (FieldType a@@88))) (and (not (= o@@50 null)) (U_2_bool (MapType0Select (Reads0 t0@@34 h0@@6 f@@17) ($Box o@@50))))) (= (MapType1Select (MapType0Select h0@@6 o@@50) fld@@5) (MapType1Select (MapType0Select h1@@6 o@@50) fld@@5))))
 :qid |unknown.0:0|
 :skolemid |768|
 :no-pattern (type o@@50)
 :no-pattern (type fld@@5)
 :no-pattern (U_2_int o@@50)
 :no-pattern (U_2_bool o@@50)
 :no-pattern (U_2_int fld@@5)
 :no-pattern (U_2_bool fld@@5)
)))) (= (Reads0 t0@@34 h0@@6 f@@17) (Reads0 t0@@34 h1@@6 f@@17)))
 :qid |unknown.0:0|
 :skolemid |769|
 :pattern ( ($HeapSucc h0@@6 h1@@6) (Reads0 t0@@34 h1@@6 f@@17))
)))
(assert (forall ((t0@@35 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@18 T@U) ) (!  (=> (and (and (and (and (= (type t0@@35) TyType) (= (type h0@@7) (MapType0Type refType MapType1Type))) (= (type h1@@7) (MapType0Type refType MapType1Type))) (= (type f@@18) HandleTypeType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) ($Is f@@18 (Tclass._System.___hFunc0 t0@@35))) (forall ((o@@51 T@U) (fld@@6 T@U) ) (! (let ((a@@89 (FieldTypeInv0 (type fld@@6))))
 (=> (and (and (= (type o@@51) refType) (= (type fld@@6) (FieldType a@@89))) (and (not (= o@@51 null)) (U_2_bool (MapType0Select (Reads0 t0@@35 h1@@7 f@@18) ($Box o@@51))))) (= (MapType1Select (MapType0Select h0@@7 o@@51) fld@@6) (MapType1Select (MapType0Select h1@@7 o@@51) fld@@6))))
 :qid |unknown.0:0|
 :skolemid |770|
 :no-pattern (type o@@51)
 :no-pattern (type fld@@6)
 :no-pattern (U_2_int o@@51)
 :no-pattern (U_2_bool o@@51)
 :no-pattern (U_2_int fld@@6)
 :no-pattern (U_2_bool fld@@6)
)))) (= (Reads0 t0@@35 h0@@7 f@@18) (Reads0 t0@@35 h1@@7 f@@18)))
 :qid |unknown.0:0|
 :skolemid |771|
 :pattern ( ($HeapSucc h0@@7 h1@@7) (Reads0 t0@@35 h1@@7 f@@18))
)))
(assert (forall ((t0@@36 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@19 T@U) ) (!  (=> (and (and (and (and (= (type t0@@36) TyType) (= (type h0@@8) (MapType0Type refType MapType1Type))) (= (type h1@@8) (MapType0Type refType MapType1Type))) (= (type f@@19) HandleTypeType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) ($Is f@@19 (Tclass._System.___hFunc0 t0@@36))) (forall ((o@@52 T@U) (fld@@7 T@U) ) (! (let ((a@@90 (FieldTypeInv0 (type fld@@7))))
 (=> (and (and (= (type o@@52) refType) (= (type fld@@7) (FieldType a@@90))) (and (not (= o@@52 null)) (U_2_bool (MapType0Select (Reads0 t0@@36 h0@@8 f@@19) ($Box o@@52))))) (= (MapType1Select (MapType0Select h0@@8 o@@52) fld@@7) (MapType1Select (MapType0Select h1@@8 o@@52) fld@@7))))
 :qid |unknown.0:0|
 :skolemid |772|
 :no-pattern (type o@@52)
 :no-pattern (type fld@@7)
 :no-pattern (U_2_int o@@52)
 :no-pattern (U_2_bool o@@52)
 :no-pattern (U_2_int fld@@7)
 :no-pattern (U_2_bool fld@@7)
)))) (= (Requires0 t0@@36 h0@@8 f@@19) (Requires0 t0@@36 h1@@8 f@@19)))
 :qid |unknown.0:0|
 :skolemid |773|
 :pattern ( ($HeapSucc h0@@8 h1@@8) (Requires0 t0@@36 h1@@8 f@@19))
)))
(assert (forall ((t0@@37 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@20 T@U) ) (!  (=> (and (and (and (and (= (type t0@@37) TyType) (= (type h0@@9) (MapType0Type refType MapType1Type))) (= (type h1@@9) (MapType0Type refType MapType1Type))) (= (type f@@20) HandleTypeType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) ($Is f@@20 (Tclass._System.___hFunc0 t0@@37))) (forall ((o@@53 T@U) (fld@@8 T@U) ) (! (let ((a@@91 (FieldTypeInv0 (type fld@@8))))
 (=> (and (and (= (type o@@53) refType) (= (type fld@@8) (FieldType a@@91))) (and (not (= o@@53 null)) (U_2_bool (MapType0Select (Reads0 t0@@37 h1@@9 f@@20) ($Box o@@53))))) (= (MapType1Select (MapType0Select h0@@9 o@@53) fld@@8) (MapType1Select (MapType0Select h1@@9 o@@53) fld@@8))))
 :qid |unknown.0:0|
 :skolemid |774|
 :no-pattern (type o@@53)
 :no-pattern (type fld@@8)
 :no-pattern (U_2_int o@@53)
 :no-pattern (U_2_bool o@@53)
 :no-pattern (U_2_int fld@@8)
 :no-pattern (U_2_bool fld@@8)
)))) (= (Requires0 t0@@37 h0@@9 f@@20) (Requires0 t0@@37 h1@@9 f@@20)))
 :qid |unknown.0:0|
 :skolemid |775|
 :pattern ( ($HeapSucc h0@@9 h1@@9) (Requires0 t0@@37 h1@@9 f@@20))
)))
(assert (forall ((t0@@38 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@21 T@U) ) (!  (=> (and (and (and (and (= (type t0@@38) TyType) (= (type h0@@10) (MapType0Type refType MapType1Type))) (= (type h1@@10) (MapType0Type refType MapType1Type))) (= (type f@@21) HandleTypeType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) ($Is f@@21 (Tclass._System.___hFunc0 t0@@38))) (forall ((o@@54 T@U) (fld@@9 T@U) ) (! (let ((a@@92 (FieldTypeInv0 (type fld@@9))))
 (=> (and (and (= (type o@@54) refType) (= (type fld@@9) (FieldType a@@92))) (and (not (= o@@54 null)) (U_2_bool (MapType0Select (Reads0 t0@@38 h0@@10 f@@21) ($Box o@@54))))) (= (MapType1Select (MapType0Select h0@@10 o@@54) fld@@9) (MapType1Select (MapType0Select h1@@10 o@@54) fld@@9))))
 :qid |unknown.0:0|
 :skolemid |776|
 :no-pattern (type o@@54)
 :no-pattern (type fld@@9)
 :no-pattern (U_2_int o@@54)
 :no-pattern (U_2_bool o@@54)
 :no-pattern (U_2_int fld@@9)
 :no-pattern (U_2_bool fld@@9)
)))) (= (Apply0 t0@@38 h0@@10 f@@21) (Apply0 t0@@38 h1@@10 f@@21)))
 :qid |unknown.0:0|
 :skolemid |777|
 :pattern ( ($HeapSucc h0@@10 h1@@10) (Apply0 t0@@38 h1@@10 f@@21))
)))
(assert (forall ((t0@@39 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@22 T@U) ) (!  (=> (and (and (and (and (= (type t0@@39) TyType) (= (type h0@@11) (MapType0Type refType MapType1Type))) (= (type h1@@11) (MapType0Type refType MapType1Type))) (= (type f@@22) HandleTypeType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) ($Is f@@22 (Tclass._System.___hFunc0 t0@@39))) (forall ((o@@55 T@U) (fld@@10 T@U) ) (! (let ((a@@93 (FieldTypeInv0 (type fld@@10))))
 (=> (and (and (= (type o@@55) refType) (= (type fld@@10) (FieldType a@@93))) (and (not (= o@@55 null)) (U_2_bool (MapType0Select (Reads0 t0@@39 h1@@11 f@@22) ($Box o@@55))))) (= (MapType1Select (MapType0Select h0@@11 o@@55) fld@@10) (MapType1Select (MapType0Select h1@@11 o@@55) fld@@10))))
 :qid |unknown.0:0|
 :skolemid |778|
 :no-pattern (type o@@55)
 :no-pattern (type fld@@10)
 :no-pattern (U_2_int o@@55)
 :no-pattern (U_2_bool o@@55)
 :no-pattern (U_2_int fld@@10)
 :no-pattern (U_2_bool fld@@10)
)))) (= (Apply0 t0@@39 h0@@11 f@@22) (Apply0 t0@@39 h1@@11 f@@22)))
 :qid |unknown.0:0|
 :skolemid |779|
 :pattern ( ($HeapSucc h0@@11 h1@@11) (Apply0 t0@@39 h1@@11 f@@22))
)))
(assert (forall ((t0@@40 T@U) (heap@@9 T@U) (f@@23 T@U) ) (!  (=> (and (and (and (= (type t0@@40) TyType) (= (type heap@@9) (MapType0Type refType MapType1Type))) (= (type f@@23) HandleTypeType)) (and ($IsGoodHeap heap@@9) ($Is f@@23 (Tclass._System.___hFunc0 t0@@40)))) (= (|Set#Equal| (Reads0 t0@@40 $OneHeap f@@23) (|Set#Empty| BoxType)) (|Set#Equal| (Reads0 t0@@40 heap@@9 f@@23) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |780|
 :pattern ( (Reads0 t0@@40 $OneHeap f@@23) ($IsGoodHeap heap@@9))
 :pattern ( (Reads0 t0@@40 heap@@9 f@@23))
)))
(assert (forall ((t0@@41 T@U) (heap@@10 T@U) (f@@24 T@U) ) (!  (=> (and (and (and (= (type t0@@41) TyType) (= (type heap@@10) (MapType0Type refType MapType1Type))) (= (type f@@24) HandleTypeType)) (and (and ($IsGoodHeap heap@@10) ($Is f@@24 (Tclass._System.___hFunc0 t0@@41))) (|Set#Equal| (Reads0 t0@@41 $OneHeap f@@24) (|Set#Empty| BoxType)))) (= (Requires0 t0@@41 $OneHeap f@@24) (Requires0 t0@@41 heap@@10 f@@24)))
 :qid |unknown.0:0|
 :skolemid |781|
 :pattern ( (Requires0 t0@@41 $OneHeap f@@24) ($IsGoodHeap heap@@10))
 :pattern ( (Requires0 t0@@41 heap@@10 f@@24))
)))
(assert (forall ((f@@25 T@U) (t0@@42 T@U) ) (!  (=> (and (= (type f@@25) HandleTypeType) (= (type t0@@42) TyType)) (= ($Is f@@25 (Tclass._System.___hFunc0 t0@@42)) (forall ((h@@30 T@U) ) (!  (=> (= (type h@@30) (MapType0Type refType MapType1Type)) (=> (and ($IsGoodHeap h@@30) (Requires0 t0@@42 h@@30 f@@25)) ($IsBox (Apply0 t0@@42 h@@30 f@@25) t0@@42)))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |782|
 :pattern ( (Apply0 t0@@42 h@@30 f@@25))
))))
 :qid |unknown.0:0|
 :skolemid |783|
 :pattern ( ($Is f@@25 (Tclass._System.___hFunc0 t0@@42)))
)))
(assert (forall ((f@@26 T@U) (t0@@43 T@U) (u0@@0 T@U) ) (!  (=> (and (and (and (= (type f@@26) HandleTypeType) (= (type t0@@43) TyType)) (= (type u0@@0) TyType)) (and ($Is f@@26 (Tclass._System.___hFunc0 t0@@43)) (forall ((bx@@39 T@U) ) (!  (=> (and (= (type bx@@39) BoxType) ($IsBox bx@@39 t0@@43)) ($IsBox bx@@39 u0@@0))
 :qid |unknown.0:0|
 :skolemid |784|
 :pattern ( ($IsBox bx@@39 t0@@43))
 :pattern ( ($IsBox bx@@39 u0@@0))
)))) ($Is f@@26 (Tclass._System.___hFunc0 u0@@0)))
 :qid |unknown.0:0|
 :skolemid |785|
 :pattern ( ($Is f@@26 (Tclass._System.___hFunc0 t0@@43)) ($Is f@@26 (Tclass._System.___hFunc0 u0@@0)))
)))
(assert (forall ((f@@27 T@U) (t0@@44 T@U) (h@@31 T@U) ) (!  (=> (and (and (and (= (type f@@27) HandleTypeType) (= (type t0@@44) TyType)) (= (type h@@31) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@31)) (= ($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31)  (=> (Requires0 t0@@44 h@@31 f@@27) (forall ((r@@13 T@U) ) (!  (=> (= (type r@@13) refType) (=> (and (not (= r@@13 null)) (U_2_bool (MapType0Select (Reads0 t0@@44 h@@31 f@@27) ($Box r@@13)))) (U_2_bool (MapType1Select (MapType0Select h@@31 r@@13) alloc))))
 :qid |unknown.0:0|
 :skolemid |786|
 :pattern ( (MapType0Select (Reads0 t0@@44 h@@31 f@@27) ($Box r@@13)))
)))))
 :qid |unknown.0:0|
 :skolemid |787|
 :pattern ( ($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31))
)))
(assert (forall ((f@@28 T@U) (t0@@45 T@U) (h@@32 T@U) ) (!  (=> (and (and (and (and (= (type f@@28) HandleTypeType) (= (type t0@@45) TyType)) (= (type h@@32) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@32) ($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32))) (Requires0 t0@@45 h@@32 f@@28)) ($IsAllocBox (Apply0 t0@@45 h@@32 f@@28) t0@@45 h@@32))
 :qid |unknown.0:0|
 :skolemid |788|
 :pattern ( ($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32))
)))
(assert (forall ((arg0@@141 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0 arg0@@141)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0|
 :pattern ( (Tclass._System.___hPartialFunc0 arg0@@141))
)))
(assert (forall ((|#$R@@18| T@U) ) (!  (=> (= (type |#$R@@18|) TyType) (and (= (Tag (Tclass._System.___hPartialFunc0 |#$R@@18|)) Tagclass._System.___hPartialFunc0) (= (TagFamily (Tclass._System.___hPartialFunc0 |#$R@@18|)) |tytagFamily$_#PartialFunc0|)))
 :qid |unknown.0:0|
 :skolemid |789|
 :pattern ( (Tclass._System.___hPartialFunc0 |#$R@@18|))
)))
(assert (forall ((arg0@@142 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0_0 arg0@@142)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0_0|
 :pattern ( (Tclass._System.___hPartialFunc0_0 arg0@@142))
)))
(assert (forall ((|#$R@@19| T@U) ) (!  (=> (= (type |#$R@@19|) TyType) (= (Tclass._System.___hPartialFunc0_0 (Tclass._System.___hPartialFunc0 |#$R@@19|)) |#$R@@19|))
 :qid |unknown.0:0|
 :skolemid |790|
 :pattern ( (Tclass._System.___hPartialFunc0 |#$R@@19|))
)))
(assert (forall ((|#$R@@20| T@U) (bx@@40 T@U) ) (!  (=> (and (and (= (type |#$R@@20|) TyType) (= (type bx@@40) BoxType)) ($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|))) (and (= ($Box ($Unbox HandleTypeType bx@@40)) bx@@40) ($Is ($Unbox HandleTypeType bx@@40) (Tclass._System.___hPartialFunc0 |#$R@@20|))))
 :qid |unknown.0:0|
 :skolemid |791|
 :pattern ( ($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|)))
)))
(assert (forall ((|#$R@@21| T@U) (|f#0@@3| T@U) ) (!  (=> (and (= (type |#$R@@21|) TyType) (= (type |f#0@@3|) HandleTypeType)) (= ($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|))  (and ($Is |f#0@@3| (Tclass._System.___hFunc0 |#$R@@21|)) (|Set#Equal| (Reads0 |#$R@@21| $OneHeap |f#0@@3|) (|Set#Empty| BoxType)))))
 :qid |unknown.0:0|
 :skolemid |792|
 :pattern ( ($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|)))
)))
(assert (forall ((|#$R@@22| T@U) (|f#0@@4| T@U) ($h@@9 T@U) ) (!  (=> (and (and (= (type |#$R@@22|) TyType) (= (type |f#0@@4|) HandleTypeType)) (= (type $h@@9) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@4| (Tclass._System.___hPartialFunc0 |#$R@@22|) $h@@9) ($IsAlloc |f#0@@4| (Tclass._System.___hFunc0 |#$R@@22|) $h@@9)))
 :qid |unknown.0:0|
 :skolemid |793|
 :pattern ( ($IsAlloc |f#0@@4| (Tclass._System.___hPartialFunc0 |#$R@@22|) $h@@9))
)))
(assert (forall ((arg0@@143 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0 arg0@@143)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0|
 :pattern ( (Tclass._System.___hTotalFunc0 arg0@@143))
)))
(assert (forall ((|#$R@@23| T@U) ) (!  (=> (= (type |#$R@@23|) TyType) (and (= (Tag (Tclass._System.___hTotalFunc0 |#$R@@23|)) Tagclass._System.___hTotalFunc0) (= (TagFamily (Tclass._System.___hTotalFunc0 |#$R@@23|)) |tytagFamily$_#TotalFunc0|)))
 :qid |unknown.0:0|
 :skolemid |794|
 :pattern ( (Tclass._System.___hTotalFunc0 |#$R@@23|))
)))
(assert (forall ((arg0@@144 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0_0 arg0@@144)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0_0|
 :pattern ( (Tclass._System.___hTotalFunc0_0 arg0@@144))
)))
(assert (forall ((|#$R@@24| T@U) ) (!  (=> (= (type |#$R@@24|) TyType) (= (Tclass._System.___hTotalFunc0_0 (Tclass._System.___hTotalFunc0 |#$R@@24|)) |#$R@@24|))
 :qid |unknown.0:0|
 :skolemid |795|
 :pattern ( (Tclass._System.___hTotalFunc0 |#$R@@24|))
)))
(assert (forall ((|#$R@@25| T@U) (bx@@41 T@U) ) (!  (=> (and (and (= (type |#$R@@25|) TyType) (= (type bx@@41) BoxType)) ($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|))) (and (= ($Box ($Unbox HandleTypeType bx@@41)) bx@@41) ($Is ($Unbox HandleTypeType bx@@41) (Tclass._System.___hTotalFunc0 |#$R@@25|))))
 :qid |unknown.0:0|
 :skolemid |796|
 :pattern ( ($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|)))
)))
(assert (forall ((|#$R@@26| T@U) (|f#0@@5| T@U) ) (!  (=> (and (= (type |#$R@@26|) TyType) (= (type |f#0@@5|) HandleTypeType)) (= ($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|))  (and ($Is |f#0@@5| (Tclass._System.___hPartialFunc0 |#$R@@26|)) (Requires0 |#$R@@26| $OneHeap |f#0@@5|))))
 :qid |unknown.0:0|
 :skolemid |797|
 :pattern ( ($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|)))
)))
(assert (forall ((|#$R@@27| T@U) (|f#0@@6| T@U) ($h@@10 T@U) ) (!  (=> (and (and (= (type |#$R@@27|) TyType) (= (type |f#0@@6|) HandleTypeType)) (= (type $h@@10) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@6| (Tclass._System.___hTotalFunc0 |#$R@@27|) $h@@10) ($IsAlloc |f#0@@6| (Tclass._System.___hPartialFunc0 |#$R@@27|) $h@@10)))
 :qid |unknown.0:0|
 :skolemid |798|
 :pattern ( ($IsAlloc |f#0@@6| (Tclass._System.___hTotalFunc0 |#$R@@27|) $h@@10))
)))
(assert (= (type Tclass._System.__default) TyType))
(assert (= (Tag Tclass._System.__default) Tagclass._System.__default))
(assert (= (TagFamily Tclass._System.__default) tytagFamily$_default))
(assert (forall ((bx@@42 T@U) ) (!  (=> (and (= (type bx@@42) BoxType) ($IsBox bx@@42 Tclass._System.__default)) (and (= ($Box ($Unbox refType bx@@42)) bx@@42) ($Is ($Unbox refType bx@@42) Tclass._System.__default)))
 :qid |unknown.0:0|
 :skolemid |799|
 :pattern ( ($IsBox bx@@42 Tclass._System.__default))
)))
(assert (forall (($o@@7 T@U) ) (!  (=> (= (type $o@@7) refType) (= ($Is $o@@7 Tclass._System.__default)  (or (= $o@@7 null) (= (dtype $o@@7) Tclass._System.__default))))
 :qid |unknown.0:0|
 :skolemid |800|
 :pattern ( ($Is $o@@7 Tclass._System.__default))
)))
(assert (forall (($o@@8 T@U) ($h@@11 T@U) ) (!  (=> (and (= (type $o@@8) refType) (= (type $h@@11) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@8 Tclass._System.__default $h@@11)  (or (= $o@@8 null) (U_2_bool (MapType1Select (MapType0Select $h@@11 $o@@8) alloc)))))
 :qid |unknown.0:0|
 :skolemid |801|
 :pattern ( ($IsAlloc $o@@8 Tclass._System.__default $h@@11))
)))
(assert  (=> true (forall ((|#$A| T@U) (|#$B| T@U) (|a#0| T@U) (|b#0| T@U) ) (!  (=> (and (and (and (and (= (type |#$A|) TyType) (= (type |#$B|) TyType)) (= (type |a#0|) BoxType)) (= (type |b#0|) BoxType)) (or (|_System.__default.rank__is__less__than#canCall| |#$A| |#$B| |a#0| |b#0|) (and ($IsBox |a#0| |#$A|) ($IsBox |b#0| |#$B|)))) true)
 :qid |unknown.0:0|
 :skolemid |802|
 :pattern ( (_System.__default.rank__is__less__than |#$A| |#$B| |a#0| |b#0|))
))))
(assert (forall ((|#$A@@0| T@U) (|#$B@@0| T@U) (|a#0@@0| T@U) (|b#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |#$A@@0|) TyType) (= (type |#$B@@0|) TyType)) (= (type |a#0@@0|) BoxType)) (= (type |b#0@@0|) BoxType)) (and ($IsBox |a#0@@0| |#$A@@0|) ($IsBox |b#0@@0| |#$B@@0|))) (= (|_System.__default.rank__is__less__than#requires| |#$A@@0| |#$B@@0| |a#0@@0| |b#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |803|
 :pattern ( (|_System.__default.rank__is__less__than#requires| |#$A@@0| |#$B@@0| |a#0@@0| |b#0@@0|))
)))
(assert (forall ((arg0@@145 T@U) (arg1@@67 T@U) (arg2@@19 T@U) ) (! (= (type (Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19)) TyType)
 :qid |funType:Tclass._System.___hFunc2|
 :pattern ( (Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19))
)))
(assert (forall ((|#$T0@@15| T@U) (|#$T1| T@U) (|#$R@@28| T@U) ) (!  (=> (and (and (= (type |#$T0@@15|) TyType) (= (type |#$T1|) TyType)) (= (type |#$R@@28|) TyType)) (and (= (Tag (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|)) Tagclass._System.___hFunc2) (= (TagFamily (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|)) |tytagFamily$_#Func2|)))
 :qid |unknown.0:0|
 :skolemid |804|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|))
)))
(assert (forall ((arg0@@146 T@U) ) (! (= (type (Tclass._System.___hFunc2_0 arg0@@146)) TyType)
 :qid |funType:Tclass._System.___hFunc2_0|
 :pattern ( (Tclass._System.___hFunc2_0 arg0@@146))
)))
(assert (forall ((|#$T0@@16| T@U) (|#$T1@@0| T@U) (|#$R@@29| T@U) ) (!  (=> (and (and (= (type |#$T0@@16|) TyType) (= (type |#$T1@@0|) TyType)) (= (type |#$R@@29|) TyType)) (= (Tclass._System.___hFunc2_0 (Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|)) |#$T0@@16|))
 :qid |unknown.0:0|
 :skolemid |805|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|))
)))
(assert (forall ((arg0@@147 T@U) ) (! (= (type (Tclass._System.___hFunc2_1 arg0@@147)) TyType)
 :qid |funType:Tclass._System.___hFunc2_1|
 :pattern ( (Tclass._System.___hFunc2_1 arg0@@147))
)))
(assert (forall ((|#$T0@@17| T@U) (|#$T1@@1| T@U) (|#$R@@30| T@U) ) (!  (=> (and (and (= (type |#$T0@@17|) TyType) (= (type |#$T1@@1|) TyType)) (= (type |#$R@@30|) TyType)) (= (Tclass._System.___hFunc2_1 (Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|)) |#$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |806|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|))
)))
(assert (forall ((arg0@@148 T@U) ) (! (= (type (Tclass._System.___hFunc2_2 arg0@@148)) TyType)
 :qid |funType:Tclass._System.___hFunc2_2|
 :pattern ( (Tclass._System.___hFunc2_2 arg0@@148))
)))
(assert (forall ((|#$T0@@18| T@U) (|#$T1@@2| T@U) (|#$R@@31| T@U) ) (!  (=> (and (and (= (type |#$T0@@18|) TyType) (= (type |#$T1@@2|) TyType)) (= (type |#$R@@31|) TyType)) (= (Tclass._System.___hFunc2_2 (Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|)) |#$R@@31|))
 :qid |unknown.0:0|
 :skolemid |807|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|))
)))
(assert (forall ((|#$T0@@19| T@U) (|#$T1@@3| T@U) (|#$R@@32| T@U) (bx@@43 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@19|) TyType) (= (type |#$T1@@3|) TyType)) (= (type |#$R@@32|) TyType)) (= (type bx@@43) BoxType)) ($IsBox bx@@43 (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|))) (and (= ($Box ($Unbox HandleTypeType bx@@43)) bx@@43) ($Is ($Unbox HandleTypeType bx@@43) (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|))))
 :qid |unknown.0:0|
 :skolemid |808|
 :pattern ( ($IsBox bx@@43 (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@149 T@T) (arg1@@68 T@T) (arg2@@20 T@T) (arg3@@3 T@T) ) (! (= (Ctor (MapType3Type arg0@@149 arg1@@68 arg2@@20 arg3@@3)) 25)
 :qid |ctor:MapType3Type|
)) (forall ((arg0@@150 T@T) (arg1@@69 T@T) (arg2@@21 T@T) (arg3@@4 T@T) ) (! (= (MapType3TypeInv0 (MapType3Type arg0@@150 arg1@@69 arg2@@21 arg3@@4)) arg0@@150)
 :qid |typeInv:MapType3TypeInv0|
 :pattern ( (MapType3Type arg0@@150 arg1@@69 arg2@@21 arg3@@4))
))) (forall ((arg0@@151 T@T) (arg1@@70 T@T) (arg2@@22 T@T) (arg3@@5 T@T) ) (! (= (MapType3TypeInv1 (MapType3Type arg0@@151 arg1@@70 arg2@@22 arg3@@5)) arg1@@70)
 :qid |typeInv:MapType3TypeInv1|
 :pattern ( (MapType3Type arg0@@151 arg1@@70 arg2@@22 arg3@@5))
))) (forall ((arg0@@152 T@T) (arg1@@71 T@T) (arg2@@23 T@T) (arg3@@6 T@T) ) (! (= (MapType3TypeInv2 (MapType3Type arg0@@152 arg1@@71 arg2@@23 arg3@@6)) arg2@@23)
 :qid |typeInv:MapType3TypeInv2|
 :pattern ( (MapType3Type arg0@@152 arg1@@71 arg2@@23 arg3@@6))
))) (forall ((arg0@@153 T@T) (arg1@@72 T@T) (arg2@@24 T@T) (arg3@@7 T@T) ) (! (= (MapType3TypeInv3 (MapType3Type arg0@@153 arg1@@72 arg2@@24 arg3@@7)) arg3@@7)
 :qid |typeInv:MapType3TypeInv3|
 :pattern ( (MapType3Type arg0@@153 arg1@@72 arg2@@24 arg3@@7))
))) (forall ((arg0@@154 T@U) (arg1@@73 T@U) (arg2@@25 T@U) (arg3@@8 T@U) ) (! (let ((aVar3 (MapType3TypeInv3 (type arg0@@154))))
(= (type (MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8)) aVar3))
 :qid |funType:MapType3Select|
 :pattern ( (MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8))
))) (forall ((arg0@@155 T@U) (arg1@@74 T@U) (arg2@@26 T@U) (arg3@@9 T@U) (arg4@@1 T@U) ) (! (let ((aVar3@@0 (type arg4@@1)))
(let ((aVar2@@2 (type arg3@@9)))
(let ((aVar1@@3 (type arg2@@26)))
(let ((aVar0@@1 (type arg1@@74)))
(= (type (MapType3Store arg0@@155 arg1@@74 arg2@@26 arg3@@9 arg4@@1)) (MapType3Type aVar0@@1 aVar1@@3 aVar2@@2 aVar3@@0))))))
 :qid |funType:MapType3Store|
 :pattern ( (MapType3Store arg0@@155 arg1@@74 arg2@@26 arg3@@9 arg4@@1))
))) (forall ((m@@49 T@U) (x0@@9 T@U) (x1@@3 T@U) (x2 T@U) (val@@10 T@U) ) (! (let ((aVar3@@1 (MapType3TypeInv3 (type m@@49))))
 (=> (= (type val@@10) aVar3@@1) (= (MapType3Select (MapType3Store m@@49 x0@@9 x1@@3 x2 val@@10) x0@@9 x1@@3 x2) val@@10)))
 :qid |mapAx0:MapType3Select|
 :weight 0
))) (and (and (and (forall ((val@@11 T@U) (m@@50 T@U) (x0@@10 T@U) (x1@@4 T@U) (x2@@0 T@U) (y0@@6 T@U) (y1@@2 T@U) (y2 T@U) ) (!  (or (= x0@@10 y0@@6) (= (MapType3Select (MapType3Store m@@50 x0@@10 x1@@4 x2@@0 val@@11) y0@@6 y1@@2 y2) (MapType3Select m@@50 y0@@6 y1@@2 y2)))
 :qid |mapAx1:MapType3Select:0|
 :weight 0
)) (forall ((val@@12 T@U) (m@@51 T@U) (x0@@11 T@U) (x1@@5 T@U) (x2@@1 T@U) (y0@@7 T@U) (y1@@3 T@U) (y2@@0 T@U) ) (!  (or (= x1@@5 y1@@3) (= (MapType3Select (MapType3Store m@@51 x0@@11 x1@@5 x2@@1 val@@12) y0@@7 y1@@3 y2@@0) (MapType3Select m@@51 y0@@7 y1@@3 y2@@0)))
 :qid |mapAx1:MapType3Select:1|
 :weight 0
))) (forall ((val@@13 T@U) (m@@52 T@U) (x0@@12 T@U) (x1@@6 T@U) (x2@@2 T@U) (y0@@8 T@U) (y1@@4 T@U) (y2@@1 T@U) ) (!  (or (= x2@@2 y2@@1) (= (MapType3Select (MapType3Store m@@52 x0@@12 x1@@6 x2@@2 val@@13) y0@@8 y1@@4 y2@@1) (MapType3Select m@@52 y0@@8 y1@@4 y2@@1)))
 :qid |mapAx1:MapType3Select:2|
 :weight 0
))) (forall ((val@@14 T@U) (m@@53 T@U) (x0@@13 T@U) (x1@@7 T@U) (x2@@3 T@U) (y0@@9 T@U) (y1@@5 T@U) (y2@@2 T@U) ) (!  (or true (= (MapType3Select (MapType3Store m@@53 x0@@13 x1@@7 x2@@3 val@@14) y0@@9 y1@@5 y2@@2) (MapType3Select m@@53 y0@@9 y1@@5 y2@@2)))
 :qid |mapAx2:MapType3Select|
 :weight 0
)))) (forall ((arg0@@156 T@U) (arg1@@75 T@U) (arg2@@27 T@U) (arg3@@10 T@U) (arg4@@2 T@U) (arg5 T@U) (arg6 T@U) ) (! (= (type (Apply2 arg0@@156 arg1@@75 arg2@@27 arg3@@10 arg4@@2 arg5 arg6)) BoxType)
 :qid |funType:Apply2|
 :pattern ( (Apply2 arg0@@156 arg1@@75 arg2@@27 arg3@@10 arg4@@2 arg5 arg6))
))) (forall ((arg0@@157 T@U) (arg1@@76 T@U) (arg2@@28 T@U) ) (! (= (type (Handle2 arg0@@157 arg1@@76 arg2@@28)) HandleTypeType)
 :qid |funType:Handle2|
 :pattern ( (Handle2 arg0@@157 arg1@@76 arg2@@28))
))))
(assert (forall ((t0@@46 T@U) (t1@@22 T@U) (t2 T@U) (heap@@11 T@U) (h@@33 T@U) (r@@14 T@U) (rd@@5 T@U) (bx0@@13 T@U) (bx1 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@46) TyType) (= (type t1@@22) TyType)) (= (type t2) TyType)) (= (type heap@@11) (MapType0Type refType MapType1Type))) (= (type h@@33) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@14) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@5) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@13) BoxType)) (= (type bx1) BoxType)) (= (Apply2 t0@@46 t1@@22 t2 heap@@11 (Handle2 h@@33 r@@14 rd@@5) bx0@@13 bx1) (MapType3Select h@@33 heap@@11 bx0@@13 bx1)))
 :qid |unknown.0:0|
 :skolemid |809|
 :pattern ( (Apply2 t0@@46 t1@@22 t2 heap@@11 (Handle2 h@@33 r@@14 rd@@5) bx0@@13 bx1))
)))
(assert (forall ((t0@@47 T@U) (t1@@23 T@U) (t2@@0 T@U) (heap@@12 T@U) (h@@34 T@U) (r@@15 T@U) (rd@@6 T@U) (bx0@@14 T@U) (bx1@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@47) TyType) (= (type t1@@23) TyType)) (= (type t2@@0) TyType)) (= (type heap@@12) (MapType0Type refType MapType1Type))) (= (type h@@34) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@15) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@6) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@14) BoxType)) (= (type bx1@@0) BoxType)) (U_2_bool (MapType3Select r@@15 heap@@12 bx0@@14 bx1@@0))) (Requires2 t0@@47 t1@@23 t2@@0 heap@@12 (Handle2 h@@34 r@@15 rd@@6) bx0@@14 bx1@@0))
 :qid |unknown.0:0|
 :skolemid |810|
 :pattern ( (Requires2 t0@@47 t1@@23 t2@@0 heap@@12 (Handle2 h@@34 r@@15 rd@@6) bx0@@14 bx1@@0))
)))
(assert (forall ((arg0@@158 T@U) (arg1@@77 T@U) (arg2@@29 T@U) (arg3@@11 T@U) (arg4@@3 T@U) (arg5@@0 T@U) (arg6@@0 T@U) ) (! (= (type (Reads2 arg0@@158 arg1@@77 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads2|
 :pattern ( (Reads2 arg0@@158 arg1@@77 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0))
)))
(assert (forall ((t0@@48 T@U) (t1@@24 T@U) (t2@@1 T@U) (heap@@13 T@U) (h@@35 T@U) (r@@16 T@U) (rd@@7 T@U) (bx0@@15 T@U) (bx1@@1 T@U) (bx@@44 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@48) TyType) (= (type t1@@24) TyType)) (= (type t2@@1) TyType)) (= (type heap@@13) (MapType0Type refType MapType1Type))) (= (type h@@35) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@16) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@7) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@15) BoxType)) (= (type bx1@@1) BoxType)) (= (type bx@@44) BoxType)) (= (U_2_bool (MapType0Select (Reads2 t0@@48 t1@@24 t2@@1 heap@@13 (Handle2 h@@35 r@@16 rd@@7) bx0@@15 bx1@@1) bx@@44)) (U_2_bool (MapType0Select (MapType3Select rd@@7 heap@@13 bx0@@15 bx1@@1) bx@@44))))
 :qid |unknown.0:0|
 :skolemid |811|
 :pattern ( (MapType0Select (Reads2 t0@@48 t1@@24 t2@@1 heap@@13 (Handle2 h@@35 r@@16 rd@@7) bx0@@15 bx1@@1) bx@@44))
)))
(assert (forall ((t0@@49 T@U) (t1@@25 T@U) (t2@@2 T@U) (h0@@12 T@U) (h1@@12 T@U) (f@@29 T@U) (bx0@@16 T@U) (bx1@@2 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@49) TyType) (= (type t1@@25) TyType)) (= (type t2@@2) TyType)) (= (type h0@@12) (MapType0Type refType MapType1Type))) (= (type h1@@12) (MapType0Type refType MapType1Type))) (= (type f@@29) HandleTypeType)) (= (type bx0@@16) BoxType)) (= (type bx1@@2) BoxType)) (and (and (and ($HeapSucc h0@@12 h1@@12) (and ($IsGoodHeap h0@@12) ($IsGoodHeap h1@@12))) (and (and ($IsBox bx0@@16 t0@@49) ($IsBox bx1@@2 t1@@25)) ($Is f@@29 (Tclass._System.___hFunc2 t0@@49 t1@@25 t2@@2)))) (forall ((o@@56 T@U) (fld@@11 T@U) ) (! (let ((a@@94 (FieldTypeInv0 (type fld@@11))))
 (=> (and (and (= (type o@@56) refType) (= (type fld@@11) (FieldType a@@94))) (and (not (= o@@56 null)) (U_2_bool (MapType0Select (Reads2 t0@@49 t1@@25 t2@@2 h0@@12 f@@29 bx0@@16 bx1@@2) ($Box o@@56))))) (= (MapType1Select (MapType0Select h0@@12 o@@56) fld@@11) (MapType1Select (MapType0Select h1@@12 o@@56) fld@@11))))
 :qid |unknown.0:0|
 :skolemid |812|
 :no-pattern (type o@@56)
 :no-pattern (type fld@@11)
 :no-pattern (U_2_int o@@56)
 :no-pattern (U_2_bool o@@56)
 :no-pattern (U_2_int fld@@11)
 :no-pattern (U_2_bool fld@@11)
)))) (= (Reads2 t0@@49 t1@@25 t2@@2 h0@@12 f@@29 bx0@@16 bx1@@2) (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2)))
 :qid |unknown.0:0|
 :skolemid |813|
 :pattern ( ($HeapSucc h0@@12 h1@@12) (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2))
)))
(assert (forall ((t0@@50 T@U) (t1@@26 T@U) (t2@@3 T@U) (h0@@13 T@U) (h1@@13 T@U) (f@@30 T@U) (bx0@@17 T@U) (bx1@@3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@50) TyType) (= (type t1@@26) TyType)) (= (type t2@@3) TyType)) (= (type h0@@13) (MapType0Type refType MapType1Type))) (= (type h1@@13) (MapType0Type refType MapType1Type))) (= (type f@@30) HandleTypeType)) (= (type bx0@@17) BoxType)) (= (type bx1@@3) BoxType)) (and (and (and ($HeapSucc h0@@13 h1@@13) (and ($IsGoodHeap h0@@13) ($IsGoodHeap h1@@13))) (and (and ($IsBox bx0@@17 t0@@50) ($IsBox bx1@@3 t1@@26)) ($Is f@@30 (Tclass._System.___hFunc2 t0@@50 t1@@26 t2@@3)))) (forall ((o@@57 T@U) (fld@@12 T@U) ) (! (let ((a@@95 (FieldTypeInv0 (type fld@@12))))
 (=> (and (and (= (type o@@57) refType) (= (type fld@@12) (FieldType a@@95))) (and (not (= o@@57 null)) (U_2_bool (MapType0Select (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3) ($Box o@@57))))) (= (MapType1Select (MapType0Select h0@@13 o@@57) fld@@12) (MapType1Select (MapType0Select h1@@13 o@@57) fld@@12))))
 :qid |unknown.0:0|
 :skolemid |814|
 :no-pattern (type o@@57)
 :no-pattern (type fld@@12)
 :no-pattern (U_2_int o@@57)
 :no-pattern (U_2_bool o@@57)
 :no-pattern (U_2_int fld@@12)
 :no-pattern (U_2_bool fld@@12)
)))) (= (Reads2 t0@@50 t1@@26 t2@@3 h0@@13 f@@30 bx0@@17 bx1@@3) (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3)))
 :qid |unknown.0:0|
 :skolemid |815|
 :pattern ( ($HeapSucc h0@@13 h1@@13) (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3))
)))
(assert (forall ((t0@@51 T@U) (t1@@27 T@U) (t2@@4 T@U) (h0@@14 T@U) (h1@@14 T@U) (f@@31 T@U) (bx0@@18 T@U) (bx1@@4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@51) TyType) (= (type t1@@27) TyType)) (= (type t2@@4) TyType)) (= (type h0@@14) (MapType0Type refType MapType1Type))) (= (type h1@@14) (MapType0Type refType MapType1Type))) (= (type f@@31) HandleTypeType)) (= (type bx0@@18) BoxType)) (= (type bx1@@4) BoxType)) (and (and (and ($HeapSucc h0@@14 h1@@14) (and ($IsGoodHeap h0@@14) ($IsGoodHeap h1@@14))) (and (and ($IsBox bx0@@18 t0@@51) ($IsBox bx1@@4 t1@@27)) ($Is f@@31 (Tclass._System.___hFunc2 t0@@51 t1@@27 t2@@4)))) (forall ((o@@58 T@U) (fld@@13 T@U) ) (! (let ((a@@96 (FieldTypeInv0 (type fld@@13))))
 (=> (and (and (= (type o@@58) refType) (= (type fld@@13) (FieldType a@@96))) (and (not (= o@@58 null)) (U_2_bool (MapType0Select (Reads2 t0@@51 t1@@27 t2@@4 h0@@14 f@@31 bx0@@18 bx1@@4) ($Box o@@58))))) (= (MapType1Select (MapType0Select h0@@14 o@@58) fld@@13) (MapType1Select (MapType0Select h1@@14 o@@58) fld@@13))))
 :qid |unknown.0:0|
 :skolemid |816|
 :no-pattern (type o@@58)
 :no-pattern (type fld@@13)
 :no-pattern (U_2_int o@@58)
 :no-pattern (U_2_bool o@@58)
 :no-pattern (U_2_int fld@@13)
 :no-pattern (U_2_bool fld@@13)
)))) (= (Requires2 t0@@51 t1@@27 t2@@4 h0@@14 f@@31 bx0@@18 bx1@@4) (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4)))
 :qid |unknown.0:0|
 :skolemid |817|
 :pattern ( ($HeapSucc h0@@14 h1@@14) (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4))
)))
(assert (forall ((t0@@52 T@U) (t1@@28 T@U) (t2@@5 T@U) (h0@@15 T@U) (h1@@15 T@U) (f@@32 T@U) (bx0@@19 T@U) (bx1@@5 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@52) TyType) (= (type t1@@28) TyType)) (= (type t2@@5) TyType)) (= (type h0@@15) (MapType0Type refType MapType1Type))) (= (type h1@@15) (MapType0Type refType MapType1Type))) (= (type f@@32) HandleTypeType)) (= (type bx0@@19) BoxType)) (= (type bx1@@5) BoxType)) (and (and (and ($HeapSucc h0@@15 h1@@15) (and ($IsGoodHeap h0@@15) ($IsGoodHeap h1@@15))) (and (and ($IsBox bx0@@19 t0@@52) ($IsBox bx1@@5 t1@@28)) ($Is f@@32 (Tclass._System.___hFunc2 t0@@52 t1@@28 t2@@5)))) (forall ((o@@59 T@U) (fld@@14 T@U) ) (! (let ((a@@97 (FieldTypeInv0 (type fld@@14))))
 (=> (and (and (= (type o@@59) refType) (= (type fld@@14) (FieldType a@@97))) (and (not (= o@@59 null)) (U_2_bool (MapType0Select (Reads2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5) ($Box o@@59))))) (= (MapType1Select (MapType0Select h0@@15 o@@59) fld@@14) (MapType1Select (MapType0Select h1@@15 o@@59) fld@@14))))
 :qid |unknown.0:0|
 :skolemid |818|
 :no-pattern (type o@@59)
 :no-pattern (type fld@@14)
 :no-pattern (U_2_int o@@59)
 :no-pattern (U_2_bool o@@59)
 :no-pattern (U_2_int fld@@14)
 :no-pattern (U_2_bool fld@@14)
)))) (= (Requires2 t0@@52 t1@@28 t2@@5 h0@@15 f@@32 bx0@@19 bx1@@5) (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5)))
 :qid |unknown.0:0|
 :skolemid |819|
 :pattern ( ($HeapSucc h0@@15 h1@@15) (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5))
)))
(assert (forall ((t0@@53 T@U) (t1@@29 T@U) (t2@@6 T@U) (h0@@16 T@U) (h1@@16 T@U) (f@@33 T@U) (bx0@@20 T@U) (bx1@@6 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@53) TyType) (= (type t1@@29) TyType)) (= (type t2@@6) TyType)) (= (type h0@@16) (MapType0Type refType MapType1Type))) (= (type h1@@16) (MapType0Type refType MapType1Type))) (= (type f@@33) HandleTypeType)) (= (type bx0@@20) BoxType)) (= (type bx1@@6) BoxType)) (and (and (and ($HeapSucc h0@@16 h1@@16) (and ($IsGoodHeap h0@@16) ($IsGoodHeap h1@@16))) (and (and ($IsBox bx0@@20 t0@@53) ($IsBox bx1@@6 t1@@29)) ($Is f@@33 (Tclass._System.___hFunc2 t0@@53 t1@@29 t2@@6)))) (forall ((o@@60 T@U) (fld@@15 T@U) ) (! (let ((a@@98 (FieldTypeInv0 (type fld@@15))))
 (=> (and (and (= (type o@@60) refType) (= (type fld@@15) (FieldType a@@98))) (and (not (= o@@60 null)) (U_2_bool (MapType0Select (Reads2 t0@@53 t1@@29 t2@@6 h0@@16 f@@33 bx0@@20 bx1@@6) ($Box o@@60))))) (= (MapType1Select (MapType0Select h0@@16 o@@60) fld@@15) (MapType1Select (MapType0Select h1@@16 o@@60) fld@@15))))
 :qid |unknown.0:0|
 :skolemid |820|
 :no-pattern (type o@@60)
 :no-pattern (type fld@@15)
 :no-pattern (U_2_int o@@60)
 :no-pattern (U_2_bool o@@60)
 :no-pattern (U_2_int fld@@15)
 :no-pattern (U_2_bool fld@@15)
)))) (= (Apply2 t0@@53 t1@@29 t2@@6 h0@@16 f@@33 bx0@@20 bx1@@6) (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6)))
 :qid |unknown.0:0|
 :skolemid |821|
 :pattern ( ($HeapSucc h0@@16 h1@@16) (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6))
)))
(assert (forall ((t0@@54 T@U) (t1@@30 T@U) (t2@@7 T@U) (h0@@17 T@U) (h1@@17 T@U) (f@@34 T@U) (bx0@@21 T@U) (bx1@@7 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@54) TyType) (= (type t1@@30) TyType)) (= (type t2@@7) TyType)) (= (type h0@@17) (MapType0Type refType MapType1Type))) (= (type h1@@17) (MapType0Type refType MapType1Type))) (= (type f@@34) HandleTypeType)) (= (type bx0@@21) BoxType)) (= (type bx1@@7) BoxType)) (and (and (and ($HeapSucc h0@@17 h1@@17) (and ($IsGoodHeap h0@@17) ($IsGoodHeap h1@@17))) (and (and ($IsBox bx0@@21 t0@@54) ($IsBox bx1@@7 t1@@30)) ($Is f@@34 (Tclass._System.___hFunc2 t0@@54 t1@@30 t2@@7)))) (forall ((o@@61 T@U) (fld@@16 T@U) ) (! (let ((a@@99 (FieldTypeInv0 (type fld@@16))))
 (=> (and (and (= (type o@@61) refType) (= (type fld@@16) (FieldType a@@99))) (and (not (= o@@61 null)) (U_2_bool (MapType0Select (Reads2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7) ($Box o@@61))))) (= (MapType1Select (MapType0Select h0@@17 o@@61) fld@@16) (MapType1Select (MapType0Select h1@@17 o@@61) fld@@16))))
 :qid |unknown.0:0|
 :skolemid |822|
 :no-pattern (type o@@61)
 :no-pattern (type fld@@16)
 :no-pattern (U_2_int o@@61)
 :no-pattern (U_2_bool o@@61)
 :no-pattern (U_2_int fld@@16)
 :no-pattern (U_2_bool fld@@16)
)))) (= (Apply2 t0@@54 t1@@30 t2@@7 h0@@17 f@@34 bx0@@21 bx1@@7) (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7)))
 :qid |unknown.0:0|
 :skolemid |823|
 :pattern ( ($HeapSucc h0@@17 h1@@17) (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7))
)))
(assert (forall ((t0@@55 T@U) (t1@@31 T@U) (t2@@8 T@U) (heap@@14 T@U) (f@@35 T@U) (bx0@@22 T@U) (bx1@@8 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@55) TyType) (= (type t1@@31) TyType)) (= (type t2@@8) TyType)) (= (type heap@@14) (MapType0Type refType MapType1Type))) (= (type f@@35) HandleTypeType)) (= (type bx0@@22) BoxType)) (= (type bx1@@8) BoxType)) (and ($IsGoodHeap heap@@14) (and (and ($IsBox bx0@@22 t0@@55) ($IsBox bx1@@8 t1@@31)) ($Is f@@35 (Tclass._System.___hFunc2 t0@@55 t1@@31 t2@@8))))) (= (|Set#Equal| (Reads2 t0@@55 t1@@31 t2@@8 $OneHeap f@@35 bx0@@22 bx1@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads2 t0@@55 t1@@31 t2@@8 heap@@14 f@@35 bx0@@22 bx1@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |824|
 :pattern ( (Reads2 t0@@55 t1@@31 t2@@8 $OneHeap f@@35 bx0@@22 bx1@@8) ($IsGoodHeap heap@@14))
 :pattern ( (Reads2 t0@@55 t1@@31 t2@@8 heap@@14 f@@35 bx0@@22 bx1@@8))
)))
(assert (forall ((t0@@56 T@U) (t1@@32 T@U) (t2@@9 T@U) (heap@@15 T@U) (f@@36 T@U) (bx0@@23 T@U) (bx1@@9 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@56) TyType) (= (type t1@@32) TyType)) (= (type t2@@9) TyType)) (= (type heap@@15) (MapType0Type refType MapType1Type))) (= (type f@@36) HandleTypeType)) (= (type bx0@@23) BoxType)) (= (type bx1@@9) BoxType)) (and (and ($IsGoodHeap heap@@15) (and (and ($IsBox bx0@@23 t0@@56) ($IsBox bx1@@9 t1@@32)) ($Is f@@36 (Tclass._System.___hFunc2 t0@@56 t1@@32 t2@@9)))) (|Set#Equal| (Reads2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) (|Set#Empty| BoxType)))) (= (Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) (Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9)))
 :qid |unknown.0:0|
 :skolemid |825|
 :pattern ( (Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) ($IsGoodHeap heap@@15))
 :pattern ( (Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9))
)))
(assert (forall ((f@@37 T@U) (t0@@57 T@U) (t1@@33 T@U) (t2@@10 T@U) ) (!  (=> (and (and (and (= (type f@@37) HandleTypeType) (= (type t0@@57) TyType)) (= (type t1@@33) TyType)) (= (type t2@@10) TyType)) (= ($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)) (forall ((h@@36 T@U) (bx0@@24 T@U) (bx1@@10 T@U) ) (!  (=> (and (and (and (= (type h@@36) (MapType0Type refType MapType1Type)) (= (type bx0@@24) BoxType)) (= (type bx1@@10) BoxType)) (and (and ($IsGoodHeap h@@36) (and ($IsBox bx0@@24 t0@@57) ($IsBox bx1@@10 t1@@33))) (Requires2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10))) ($IsBox (Apply2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10) t2@@10))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |826|
 :pattern ( (Apply2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10))
))))
 :qid |unknown.0:0|
 :skolemid |827|
 :pattern ( ($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)))
)))
(assert (forall ((f@@38 T@U) (t0@@58 T@U) (t1@@34 T@U) (t2@@11 T@U) (u0@@1 T@U) (u1@@0 T@U) (u2 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@38) HandleTypeType) (= (type t0@@58) TyType)) (= (type t1@@34) TyType)) (= (type t2@@11) TyType)) (= (type u0@@1) TyType)) (= (type u1@@0) TyType)) (= (type u2) TyType)) (and (and (and ($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11)) (forall ((bx@@45 T@U) ) (!  (=> (and (= (type bx@@45) BoxType) ($IsBox bx@@45 u0@@1)) ($IsBox bx@@45 t0@@58))
 :qid |unknown.0:0|
 :skolemid |828|
 :pattern ( ($IsBox bx@@45 u0@@1))
 :pattern ( ($IsBox bx@@45 t0@@58))
))) (forall ((bx@@46 T@U) ) (!  (=> (and (= (type bx@@46) BoxType) ($IsBox bx@@46 u1@@0)) ($IsBox bx@@46 t1@@34))
 :qid |unknown.0:0|
 :skolemid |829|
 :pattern ( ($IsBox bx@@46 u1@@0))
 :pattern ( ($IsBox bx@@46 t1@@34))
))) (forall ((bx@@47 T@U) ) (!  (=> (and (= (type bx@@47) BoxType) ($IsBox bx@@47 t2@@11)) ($IsBox bx@@47 u2))
 :qid |unknown.0:0|
 :skolemid |830|
 :pattern ( ($IsBox bx@@47 t2@@11))
 :pattern ( ($IsBox bx@@47 u2))
)))) ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2)))
 :qid |unknown.0:0|
 :skolemid |831|
 :pattern ( ($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11)) ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2)))
)))
(assert (forall ((f@@39 T@U) (t0@@59 T@U) (t1@@35 T@U) (t2@@12 T@U) (h@@37 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@39) HandleTypeType) (= (type t0@@59) TyType)) (= (type t1@@35) TyType)) (= (type t2@@12) TyType)) (= (type h@@37) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@37)) (= ($IsAlloc f@@39 (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12) h@@37) (forall ((bx0@@25 T@U) (bx1@@11 T@U) ) (!  (=> (and (= (type bx0@@25) BoxType) (= (type bx1@@11) BoxType)) (=> (and (and (and ($IsBox bx0@@25 t0@@59) ($IsAllocBox bx0@@25 t0@@59 h@@37)) (and ($IsBox bx1@@11 t1@@35) ($IsAllocBox bx1@@11 t1@@35 h@@37))) (Requires2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11)) (forall ((r@@17 T@U) ) (!  (=> (= (type r@@17) refType) (=> (and (not (= r@@17 null)) (U_2_bool (MapType0Select (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11) ($Box r@@17)))) (U_2_bool (MapType1Select (MapType0Select h@@37 r@@17) alloc))))
 :qid |unknown.0:0|
 :skolemid |832|
 :pattern ( (MapType0Select (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11) ($Box r@@17)))
))))
 :qid |unknown.0:0|
 :skolemid |833|
 :pattern ( (Apply2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11))
 :pattern ( (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11))
))))
 :qid |unknown.0:0|
 :skolemid |834|
 :pattern ( ($IsAlloc f@@39 (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12) h@@37))
)))
(assert (forall ((f@@40 T@U) (t0@@60 T@U) (t1@@36 T@U) (t2@@13 T@U) (h@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@40) HandleTypeType) (= (type t0@@60) TyType)) (= (type t1@@36) TyType)) (= (type t2@@13) TyType)) (= (type h@@38) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@38) ($IsAlloc f@@40 (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13) h@@38))) (forall ((bx0@@26 T@U) (bx1@@12 T@U) ) (!  (=> (and (= (type bx0@@26) BoxType) (= (type bx1@@12) BoxType)) (=> (and (and ($IsAllocBox bx0@@26 t0@@60 h@@38) ($IsAllocBox bx1@@12 t1@@36 h@@38)) (Requires2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12)) ($IsAllocBox (Apply2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12) t2@@13 h@@38)))
 :qid |unknown.0:0|
 :skolemid |835|
 :pattern ( (Apply2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12))
)))
 :qid |unknown.0:0|
 :skolemid |836|
 :pattern ( ($IsAlloc f@@40 (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13) h@@38))
)))
(assert (forall ((arg0@@159 T@U) (arg1@@78 T@U) (arg2@@30 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2|
 :pattern ( (Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30))
)))
(assert (forall ((|#$T0@@20| T@U) (|#$T1@@4| T@U) (|#$R@@33| T@U) ) (!  (=> (and (and (= (type |#$T0@@20|) TyType) (= (type |#$T1@@4|) TyType)) (= (type |#$R@@33|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|)) Tagclass._System.___hPartialFunc2) (= (TagFamily (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|)) |tytagFamily$_#PartialFunc2|)))
 :qid |unknown.0:0|
 :skolemid |837|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|))
)))
(assert (forall ((arg0@@160 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_0 arg0@@160)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_0|
 :pattern ( (Tclass._System.___hPartialFunc2_0 arg0@@160))
)))
(assert (forall ((|#$T0@@21| T@U) (|#$T1@@5| T@U) (|#$R@@34| T@U) ) (!  (=> (and (and (= (type |#$T0@@21|) TyType) (= (type |#$T1@@5|) TyType)) (= (type |#$R@@34|) TyType)) (= (Tclass._System.___hPartialFunc2_0 (Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|)) |#$T0@@21|))
 :qid |unknown.0:0|
 :skolemid |838|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|))
)))
(assert (forall ((arg0@@161 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_1 arg0@@161)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_1|
 :pattern ( (Tclass._System.___hPartialFunc2_1 arg0@@161))
)))
(assert (forall ((|#$T0@@22| T@U) (|#$T1@@6| T@U) (|#$R@@35| T@U) ) (!  (=> (and (and (= (type |#$T0@@22|) TyType) (= (type |#$T1@@6|) TyType)) (= (type |#$R@@35|) TyType)) (= (Tclass._System.___hPartialFunc2_1 (Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|)) |#$T1@@6|))
 :qid |unknown.0:0|
 :skolemid |839|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|))
)))
(assert (forall ((arg0@@162 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_2 arg0@@162)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_2|
 :pattern ( (Tclass._System.___hPartialFunc2_2 arg0@@162))
)))
(assert (forall ((|#$T0@@23| T@U) (|#$T1@@7| T@U) (|#$R@@36| T@U) ) (!  (=> (and (and (= (type |#$T0@@23|) TyType) (= (type |#$T1@@7|) TyType)) (= (type |#$R@@36|) TyType)) (= (Tclass._System.___hPartialFunc2_2 (Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|)) |#$R@@36|))
 :qid |unknown.0:0|
 :skolemid |840|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|))
)))
(assert (forall ((|#$T0@@24| T@U) (|#$T1@@8| T@U) (|#$R@@37| T@U) (bx@@48 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@24|) TyType) (= (type |#$T1@@8|) TyType)) (= (type |#$R@@37|) TyType)) (= (type bx@@48) BoxType)) ($IsBox bx@@48 (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|))) (and (= ($Box ($Unbox HandleTypeType bx@@48)) bx@@48) ($Is ($Unbox HandleTypeType bx@@48) (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|))))
 :qid |unknown.0:0|
 :skolemid |841|
 :pattern ( ($IsBox bx@@48 (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|)))
)))
(assert (forall ((|#$T0@@25| T@U) (|#$T1@@9| T@U) (|#$R@@38| T@U) (|f#0@@7| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@25|) TyType) (= (type |#$T1@@9|) TyType)) (= (type |#$R@@38|) TyType)) (= (type |f#0@@7|) HandleTypeType)) (= ($Is |f#0@@7| (Tclass._System.___hPartialFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|))  (and ($Is |f#0@@7| (Tclass._System.___hFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|)) (forall ((|x0#0@@1| T@U) (|x1#0| T@U) ) (!  (=> (and (and (= (type |x0#0@@1|) BoxType) (= (type |x1#0|) BoxType)) (and ($IsBox |x0#0@@1| |#$T0@@25|) ($IsBox |x1#0| |#$T1@@9|))) (|Set#Equal| (Reads2 |#$T0@@25| |#$T1@@9| |#$R@@38| $OneHeap |f#0@@7| |x0#0@@1| |x1#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |842|
 :no-pattern (type |x0#0@@1|)
 :no-pattern (type |x1#0|)
 :no-pattern (U_2_int |x0#0@@1|)
 :no-pattern (U_2_bool |x0#0@@1|)
 :no-pattern (U_2_int |x1#0|)
 :no-pattern (U_2_bool |x1#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |843|
 :pattern ( ($Is |f#0@@7| (Tclass._System.___hPartialFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|)))
)))
(assert (forall ((|#$T0@@26| T@U) (|#$T1@@10| T@U) (|#$R@@39| T@U) (|f#0@@8| T@U) ($h@@12 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@26|) TyType) (= (type |#$T1@@10|) TyType)) (= (type |#$R@@39|) TyType)) (= (type |f#0@@8|) HandleTypeType)) (= (type $h@@12) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@8| (Tclass._System.___hPartialFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12) ($IsAlloc |f#0@@8| (Tclass._System.___hFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12)))
 :qid |unknown.0:0|
 :skolemid |844|
 :pattern ( ($IsAlloc |f#0@@8| (Tclass._System.___hPartialFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12))
)))
(assert (forall ((arg0@@163 T@U) (arg1@@79 T@U) (arg2@@31 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2|
 :pattern ( (Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31))
)))
(assert (forall ((|#$T0@@27| T@U) (|#$T1@@11| T@U) (|#$R@@40| T@U) ) (!  (=> (and (and (= (type |#$T0@@27|) TyType) (= (type |#$T1@@11|) TyType)) (= (type |#$R@@40|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|)) Tagclass._System.___hTotalFunc2) (= (TagFamily (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|)) |tytagFamily$_#TotalFunc2|)))
 :qid |unknown.0:0|
 :skolemid |845|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|))
)))
(assert (forall ((arg0@@164 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_0 arg0@@164)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_0|
 :pattern ( (Tclass._System.___hTotalFunc2_0 arg0@@164))
)))
(assert (forall ((|#$T0@@28| T@U) (|#$T1@@12| T@U) (|#$R@@41| T@U) ) (!  (=> (and (and (= (type |#$T0@@28|) TyType) (= (type |#$T1@@12|) TyType)) (= (type |#$R@@41|) TyType)) (= (Tclass._System.___hTotalFunc2_0 (Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|)) |#$T0@@28|))
 :qid |unknown.0:0|
 :skolemid |846|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|))
)))
(assert (forall ((arg0@@165 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_1 arg0@@165)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_1|
 :pattern ( (Tclass._System.___hTotalFunc2_1 arg0@@165))
)))
(assert (forall ((|#$T0@@29| T@U) (|#$T1@@13| T@U) (|#$R@@42| T@U) ) (!  (=> (and (and (= (type |#$T0@@29|) TyType) (= (type |#$T1@@13|) TyType)) (= (type |#$R@@42|) TyType)) (= (Tclass._System.___hTotalFunc2_1 (Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|)) |#$T1@@13|))
 :qid |unknown.0:0|
 :skolemid |847|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|))
)))
(assert (forall ((arg0@@166 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_2 arg0@@166)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_2|
 :pattern ( (Tclass._System.___hTotalFunc2_2 arg0@@166))
)))
(assert (forall ((|#$T0@@30| T@U) (|#$T1@@14| T@U) (|#$R@@43| T@U) ) (!  (=> (and (and (= (type |#$T0@@30|) TyType) (= (type |#$T1@@14|) TyType)) (= (type |#$R@@43|) TyType)) (= (Tclass._System.___hTotalFunc2_2 (Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|)) |#$R@@43|))
 :qid |unknown.0:0|
 :skolemid |848|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|))
)))
(assert (forall ((|#$T0@@31| T@U) (|#$T1@@15| T@U) (|#$R@@44| T@U) (bx@@49 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@31|) TyType) (= (type |#$T1@@15|) TyType)) (= (type |#$R@@44|) TyType)) (= (type bx@@49) BoxType)) ($IsBox bx@@49 (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|))) (and (= ($Box ($Unbox HandleTypeType bx@@49)) bx@@49) ($Is ($Unbox HandleTypeType bx@@49) (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|))))
 :qid |unknown.0:0|
 :skolemid |849|
 :pattern ( ($IsBox bx@@49 (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|)))
)))
(assert (forall ((|#$T0@@32| T@U) (|#$T1@@16| T@U) (|#$R@@45| T@U) (|f#0@@9| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@32|) TyType) (= (type |#$T1@@16|) TyType)) (= (type |#$R@@45|) TyType)) (= (type |f#0@@9|) HandleTypeType)) (= ($Is |f#0@@9| (Tclass._System.___hTotalFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|))  (and ($Is |f#0@@9| (Tclass._System.___hPartialFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|)) (forall ((|x0#0@@2| T@U) (|x1#0@@0| T@U) ) (!  (=> (and (and (= (type |x0#0@@2|) BoxType) (= (type |x1#0@@0|) BoxType)) (and ($IsBox |x0#0@@2| |#$T0@@32|) ($IsBox |x1#0@@0| |#$T1@@16|))) (Requires2 |#$T0@@32| |#$T1@@16| |#$R@@45| $OneHeap |f#0@@9| |x0#0@@2| |x1#0@@0|))
 :qid |unknown.0:0|
 :skolemid |850|
 :no-pattern (type |x0#0@@2|)
 :no-pattern (type |x1#0@@0|)
 :no-pattern (U_2_int |x0#0@@2|)
 :no-pattern (U_2_bool |x0#0@@2|)
 :no-pattern (U_2_int |x1#0@@0|)
 :no-pattern (U_2_bool |x1#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |851|
 :pattern ( ($Is |f#0@@9| (Tclass._System.___hTotalFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|)))
)))
(assert (forall ((|#$T0@@33| T@U) (|#$T1@@17| T@U) (|#$R@@46| T@U) (|f#0@@10| T@U) ($h@@13 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@33|) TyType) (= (type |#$T1@@17|) TyType)) (= (type |#$R@@46|) TyType)) (= (type |f#0@@10|) HandleTypeType)) (= (type $h@@13) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@10| (Tclass._System.___hTotalFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13) ($IsAlloc |f#0@@10| (Tclass._System.___hPartialFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13)))
 :qid |unknown.0:0|
 :skolemid |852|
 :pattern ( ($IsAlloc |f#0@@10| (Tclass._System.___hTotalFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13))
)))
(assert (forall ((arg0@@167 T@U) ) (! (= (type (DatatypeCtorId arg0@@167)) DtCtorIdType)
 :qid |funType:DatatypeCtorId|
 :pattern ( (DatatypeCtorId arg0@@167))
)))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U) ) (!  (=> (and (= (type |a#0#0#0|) BoxType) (= (type |a#0#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) |##_System._tuple#2._#Make2|))
 :qid |unknown.0:0|
 :skolemid |853|
 :pattern ( (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|))
)))
(assert (forall ((d@@0 T@U) ) (!  (=> (= (type d@@0) DatatypeTypeType) (= (_System.Tuple2.___hMake2_q d@@0) (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|)))
 :qid |unknown.0:0|
 :skolemid |854|
 :pattern ( (_System.Tuple2.___hMake2_q d@@0))
)))
(assert (forall ((d@@1 T@U) ) (!  (=> (and (= (type d@@1) DatatypeTypeType) (_System.Tuple2.___hMake2_q d@@1)) (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U) ) (!  (and (and (= (type |a#1#0#0|) BoxType) (= (type |a#1#1#0|) BoxType)) (= d@@1 (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|)))
 :qid |unknown.0:0|
 :skolemid |855|
 :no-pattern (type |a#1#0#0|)
 :no-pattern (type |a#1#1#0|)
 :no-pattern (U_2_int |a#1#0#0|)
 :no-pattern (U_2_bool |a#1#0#0|)
 :no-pattern (U_2_int |a#1#1#0|)
 :no-pattern (U_2_bool |a#1#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |856|
 :pattern ( (_System.Tuple2.___hMake2_q d@@1))
)))
(assert (forall ((|_System._tuple#2$T0| T@U) (|_System._tuple#2$T1| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0|) TyType) (= (type |_System._tuple#2$T1|) TyType)) (and (= (Tag (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)) Tagclass._System.Tuple2) (= (TagFamily (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)) |tytagFamily$_tuple#2|)))
 :qid |unknown.0:0|
 :skolemid |857|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|))
)))
(assert (forall ((arg0@@168 T@U) ) (! (= (type (Tclass._System.Tuple2_0 arg0@@168)) TyType)
 :qid |funType:Tclass._System.Tuple2_0|
 :pattern ( (Tclass._System.Tuple2_0 arg0@@168))
)))
(assert (forall ((|_System._tuple#2$T0@@0| T@U) (|_System._tuple#2$T1@@0| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0@@0|) TyType) (= (type |_System._tuple#2$T1@@0|) TyType)) (= (Tclass._System.Tuple2_0 (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|)) |_System._tuple#2$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |858|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|))
)))
(assert (forall ((arg0@@169 T@U) ) (! (= (type (Tclass._System.Tuple2_1 arg0@@169)) TyType)
 :qid |funType:Tclass._System.Tuple2_1|
 :pattern ( (Tclass._System.Tuple2_1 arg0@@169))
)))
(assert (forall ((|_System._tuple#2$T0@@1| T@U) (|_System._tuple#2$T1@@1| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0@@1|) TyType) (= (type |_System._tuple#2$T1@@1|) TyType)) (= (Tclass._System.Tuple2_1 (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|)) |_System._tuple#2$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |859|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|))
)))
(assert (forall ((|_System._tuple#2$T0@@2| T@U) (|_System._tuple#2$T1@@2| T@U) (bx@@50 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@2|) TyType) (= (type |_System._tuple#2$T1@@2|) TyType)) (= (type bx@@50) BoxType)) ($IsBox bx@@50 (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@50)) bx@@50) ($Is ($Unbox DatatypeTypeType bx@@50) (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|))))
 :qid |unknown.0:0|
 :skolemid |860|
 :pattern ( ($IsBox bx@@50 (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|)))
)))
(assert (forall ((|_System._tuple#2$T0@@3| T@U) (|_System._tuple#2$T1@@3| T@U) (|a#2#0#0| T@U) (|a#2#1#0| T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@3|) TyType) (= (type |_System._tuple#2$T1@@3|) TyType)) (= (type |a#2#0#0|) BoxType)) (= (type |a#2#1#0|) BoxType)) (= ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|))  (and ($IsBox |a#2#0#0| |_System._tuple#2$T0@@3|) ($IsBox |a#2#1#0| |_System._tuple#2$T1@@3|))))
 :qid |unknown.0:0|
 :skolemid |861|
 :pattern ( ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|)))
)))
(assert (forall ((|_System._tuple#2$T0@@4| T@U) (|_System._tuple#2$T1@@4| T@U) (|a#3#0#0| T@U) (|a#3#1#0| T@U) ($h@@14 T@U) ) (!  (=> (and (and (and (and (and (= (type |_System._tuple#2$T0@@4|) TyType) (= (type |_System._tuple#2$T1@@4|) TyType)) (= (type |a#3#0#0|) BoxType)) (= (type |a#3#1#0|) BoxType)) (= (type $h@@14) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@14)) (= ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|) $h@@14)  (and ($IsAllocBox |a#3#0#0| |_System._tuple#2$T0@@4| $h@@14) ($IsAllocBox |a#3#1#0| |_System._tuple#2$T1@@4| $h@@14))))
 :qid |unknown.0:0|
 :skolemid |862|
 :pattern ( ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|) $h@@14))
)))
(assert (forall ((d@@2 T@U) (|_System._tuple#2$T0@@5| T@U) ($h@@15 T@U) ) (!  (=> (and (and (and (= (type d@@2) DatatypeTypeType) (= (type |_System._tuple#2$T0@@5|) TyType)) (= (type $h@@15) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@15) (and (_System.Tuple2.___hMake2_q d@@2) (exists ((|_System._tuple#2$T1@@5| T@U) ) (!  (and (= (type |_System._tuple#2$T1@@5|) TyType) ($IsAlloc d@@2 (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|) $h@@15))
 :qid |unknown.0:0|
 :skolemid |863|
 :pattern ( ($IsAlloc d@@2 (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|) $h@@15))
))))) ($IsAllocBox (_System.Tuple2._0 d@@2) |_System._tuple#2$T0@@5| $h@@15))
 :qid |unknown.0:0|
 :skolemid |864|
 :pattern ( ($IsAllocBox (_System.Tuple2._0 d@@2) |_System._tuple#2$T0@@5| $h@@15))
)))
(assert (forall ((d@@3 T@U) (|_System._tuple#2$T1@@6| T@U) ($h@@16 T@U) ) (!  (=> (and (and (and (= (type d@@3) DatatypeTypeType) (= (type |_System._tuple#2$T1@@6|) TyType)) (= (type $h@@16) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@16) (and (_System.Tuple2.___hMake2_q d@@3) (exists ((|_System._tuple#2$T0@@6| T@U) ) (!  (and (= (type |_System._tuple#2$T0@@6|) TyType) ($IsAlloc d@@3 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@16))
 :qid |unknown.0:0|
 :skolemid |865|
 :pattern ( ($IsAlloc d@@3 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@16))
))))) ($IsAllocBox (_System.Tuple2._1 d@@3) |_System._tuple#2$T1@@6| $h@@16))
 :qid |unknown.0:0|
 :skolemid |866|
 :pattern ( ($IsAllocBox (_System.Tuple2._1 d@@3) |_System._tuple#2$T1@@6| $h@@16))
)))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U) ) (!  (=> (and (= (type |a#4#0#0|) BoxType) (= (type |a#4#1#0|) BoxType)) (= (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)) (Lit (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|))))
 :qid |unknown.0:0|
 :skolemid |867|
 :pattern ( (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)))
)))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U) ) (!  (=> (and (= (type |a#5#0#0|) BoxType) (= (type |a#5#1#0|) BoxType)) (= (_System.Tuple2._0 (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) |a#5#0#0|))
 :qid |unknown.0:0|
 :skolemid |868|
 :pattern ( (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|))
)))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U) ) (!  (=> (and (= (type |a#6#0#0|) BoxType) (= (type |a#6#1#0|) BoxType)) (< (BoxRank |a#6#0#0|) (DtRank (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))))
 :qid |unknown.0:0|
 :skolemid |869|
 :pattern ( (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))
)))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U) ) (!  (=> (and (= (type |a#7#0#0|) BoxType) (= (type |a#7#1#0|) BoxType)) (= (_System.Tuple2._1 (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) |a#7#1#0|))
 :qid |unknown.0:0|
 :skolemid |870|
 :pattern ( (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|))
)))
(assert (forall ((|a#8#0#0| T@U) (|a#8#1#0| T@U) ) (!  (=> (and (= (type |a#8#0#0|) BoxType) (= (type |a#8#1#0|) BoxType)) (< (BoxRank |a#8#1#0|) (DtRank (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))))
 :qid |unknown.0:0|
 :skolemid |871|
 :pattern ( (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))
)))
(assert (forall ((d@@4 T@U) ) (!  (=> (and (= (type d@@4) DatatypeTypeType) (|$IsA#_System.Tuple2| d@@4)) (_System.Tuple2.___hMake2_q d@@4))
 :qid |unknown.0:0|
 :skolemid |872|
 :pattern ( (|$IsA#_System.Tuple2| d@@4))
)))
(assert (forall ((|_System._tuple#2$T0@@7| T@U) (|_System._tuple#2$T1@@7| T@U) (d@@5 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@7|) TyType) (= (type |_System._tuple#2$T1@@7|) TyType)) (= (type d@@5) DatatypeTypeType)) ($Is d@@5 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|))) (_System.Tuple2.___hMake2_q d@@5))
 :qid |unknown.0:0|
 :skolemid |873|
 :pattern ( (_System.Tuple2.___hMake2_q d@@5) ($Is d@@5 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|)))
)))
(assert (forall ((a@@100 T@U) (b@@61 T@U) ) (!  (=> (and (and (= (type a@@100) DatatypeTypeType) (= (type b@@61) DatatypeTypeType)) true) (= (|_System.Tuple2#Equal| a@@100 b@@61)  (and (= (_System.Tuple2._0 a@@100) (_System.Tuple2._0 b@@61)) (= (_System.Tuple2._1 a@@100) (_System.Tuple2._1 b@@61)))))
 :qid |unknown.0:0|
 :skolemid |874|
 :pattern ( (|_System.Tuple2#Equal| a@@100 b@@61))
)))
(assert (forall ((a@@101 T@U) (b@@62 T@U) ) (!  (=> (and (= (type a@@101) DatatypeTypeType) (= (type b@@62) DatatypeTypeType)) (= (|_System.Tuple2#Equal| a@@101 b@@62) (= a@@101 b@@62)))
 :qid |unknown.0:0|
 :skolemid |875|
 :pattern ( (|_System.Tuple2#Equal| a@@101 b@@62))
)))
(assert (forall ((arg0@@170 T@U) (arg1@@80 T@U) (arg2@@32 T@U) (arg3@@12 T@U) (arg4@@4 T@U) ) (! (= (type (Tclass._System.___hFunc4 arg0@@170 arg1@@80 arg2@@32 arg3@@12 arg4@@4)) TyType)
 :qid |funType:Tclass._System.___hFunc4|
 :pattern ( (Tclass._System.___hFunc4 arg0@@170 arg1@@80 arg2@@32 arg3@@12 arg4@@4))
)))
(assert (forall ((|#$T0@@34| T@U) (|#$T1@@18| T@U) (|#$T2| T@U) (|#$T3| T@U) (|#$R@@47| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@34|) TyType) (= (type |#$T1@@18|) TyType)) (= (type |#$T2|) TyType)) (= (type |#$T3|) TyType)) (= (type |#$R@@47|) TyType)) (and (= (Tag (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|)) Tagclass._System.___hFunc4) (= (TagFamily (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|)) |tytagFamily$_#Func4|)))
 :qid |unknown.0:0|
 :skolemid |876|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|))
)))
(assert (forall ((arg0@@171 T@U) ) (! (= (type (Tclass._System.___hFunc4_0 arg0@@171)) TyType)
 :qid |funType:Tclass._System.___hFunc4_0|
 :pattern ( (Tclass._System.___hFunc4_0 arg0@@171))
)))
(assert (forall ((|#$T0@@35| T@U) (|#$T1@@19| T@U) (|#$T2@@0| T@U) (|#$T3@@0| T@U) (|#$R@@48| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@35|) TyType) (= (type |#$T1@@19|) TyType)) (= (type |#$T2@@0|) TyType)) (= (type |#$T3@@0|) TyType)) (= (type |#$R@@48|) TyType)) (= (Tclass._System.___hFunc4_0 (Tclass._System.___hFunc4 |#$T0@@35| |#$T1@@19| |#$T2@@0| |#$T3@@0| |#$R@@48|)) |#$T0@@35|))
 :qid |unknown.0:0|
 :skolemid |877|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@35| |#$T1@@19| |#$T2@@0| |#$T3@@0| |#$R@@48|))
)))
(assert (forall ((arg0@@172 T@U) ) (! (= (type (Tclass._System.___hFunc4_1 arg0@@172)) TyType)
 :qid |funType:Tclass._System.___hFunc4_1|
 :pattern ( (Tclass._System.___hFunc4_1 arg0@@172))
)))
(assert (forall ((|#$T0@@36| T@U) (|#$T1@@20| T@U) (|#$T2@@1| T@U) (|#$T3@@1| T@U) (|#$R@@49| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@36|) TyType) (= (type |#$T1@@20|) TyType)) (= (type |#$T2@@1|) TyType)) (= (type |#$T3@@1|) TyType)) (= (type |#$R@@49|) TyType)) (= (Tclass._System.___hFunc4_1 (Tclass._System.___hFunc4 |#$T0@@36| |#$T1@@20| |#$T2@@1| |#$T3@@1| |#$R@@49|)) |#$T1@@20|))
 :qid |unknown.0:0|
 :skolemid |878|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@36| |#$T1@@20| |#$T2@@1| |#$T3@@1| |#$R@@49|))
)))
(assert (forall ((arg0@@173 T@U) ) (! (= (type (Tclass._System.___hFunc4_2 arg0@@173)) TyType)
 :qid |funType:Tclass._System.___hFunc4_2|
 :pattern ( (Tclass._System.___hFunc4_2 arg0@@173))
)))
(assert (forall ((|#$T0@@37| T@U) (|#$T1@@21| T@U) (|#$T2@@2| T@U) (|#$T3@@2| T@U) (|#$R@@50| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@37|) TyType) (= (type |#$T1@@21|) TyType)) (= (type |#$T2@@2|) TyType)) (= (type |#$T3@@2|) TyType)) (= (type |#$R@@50|) TyType)) (= (Tclass._System.___hFunc4_2 (Tclass._System.___hFunc4 |#$T0@@37| |#$T1@@21| |#$T2@@2| |#$T3@@2| |#$R@@50|)) |#$T2@@2|))
 :qid |unknown.0:0|
 :skolemid |879|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@37| |#$T1@@21| |#$T2@@2| |#$T3@@2| |#$R@@50|))
)))
(assert (forall ((arg0@@174 T@U) ) (! (= (type (Tclass._System.___hFunc4_3 arg0@@174)) TyType)
 :qid |funType:Tclass._System.___hFunc4_3|
 :pattern ( (Tclass._System.___hFunc4_3 arg0@@174))
)))
(assert (forall ((|#$T0@@38| T@U) (|#$T1@@22| T@U) (|#$T2@@3| T@U) (|#$T3@@3| T@U) (|#$R@@51| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@38|) TyType) (= (type |#$T1@@22|) TyType)) (= (type |#$T2@@3|) TyType)) (= (type |#$T3@@3|) TyType)) (= (type |#$R@@51|) TyType)) (= (Tclass._System.___hFunc4_3 (Tclass._System.___hFunc4 |#$T0@@38| |#$T1@@22| |#$T2@@3| |#$T3@@3| |#$R@@51|)) |#$T3@@3|))
 :qid |unknown.0:0|
 :skolemid |880|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@38| |#$T1@@22| |#$T2@@3| |#$T3@@3| |#$R@@51|))
)))
(assert (forall ((arg0@@175 T@U) ) (! (= (type (Tclass._System.___hFunc4_4 arg0@@175)) TyType)
 :qid |funType:Tclass._System.___hFunc4_4|
 :pattern ( (Tclass._System.___hFunc4_4 arg0@@175))
)))
(assert (forall ((|#$T0@@39| T@U) (|#$T1@@23| T@U) (|#$T2@@4| T@U) (|#$T3@@4| T@U) (|#$R@@52| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@39|) TyType) (= (type |#$T1@@23|) TyType)) (= (type |#$T2@@4|) TyType)) (= (type |#$T3@@4|) TyType)) (= (type |#$R@@52|) TyType)) (= (Tclass._System.___hFunc4_4 (Tclass._System.___hFunc4 |#$T0@@39| |#$T1@@23| |#$T2@@4| |#$T3@@4| |#$R@@52|)) |#$R@@52|))
 :qid |unknown.0:0|
 :skolemid |881|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@39| |#$T1@@23| |#$T2@@4| |#$T3@@4| |#$R@@52|))
)))
(assert (forall ((|#$T0@@40| T@U) (|#$T1@@24| T@U) (|#$T2@@5| T@U) (|#$T3@@5| T@U) (|#$R@@53| T@U) (bx@@51 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@40|) TyType) (= (type |#$T1@@24|) TyType)) (= (type |#$T2@@5|) TyType)) (= (type |#$T3@@5|) TyType)) (= (type |#$R@@53|) TyType)) (= (type bx@@51) BoxType)) ($IsBox bx@@51 (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|))) (and (= ($Box ($Unbox HandleTypeType bx@@51)) bx@@51) ($Is ($Unbox HandleTypeType bx@@51) (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|))))
 :qid |unknown.0:0|
 :skolemid |882|
 :pattern ( ($IsBox bx@@51 (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@176 T@T) (arg1@@81 T@T) (arg2@@33 T@T) (arg3@@13 T@T) (arg4@@5 T@T) (arg5@@1 T@T) ) (! (= (Ctor (MapType4Type arg0@@176 arg1@@81 arg2@@33 arg3@@13 arg4@@5 arg5@@1)) 26)
 :qid |ctor:MapType4Type|
)) (forall ((arg0@@177 T@T) (arg1@@82 T@T) (arg2@@34 T@T) (arg3@@14 T@T) (arg4@@6 T@T) (arg5@@2 T@T) ) (! (= (MapType4TypeInv0 (MapType4Type arg0@@177 arg1@@82 arg2@@34 arg3@@14 arg4@@6 arg5@@2)) arg0@@177)
 :qid |typeInv:MapType4TypeInv0|
 :pattern ( (MapType4Type arg0@@177 arg1@@82 arg2@@34 arg3@@14 arg4@@6 arg5@@2))
))) (forall ((arg0@@178 T@T) (arg1@@83 T@T) (arg2@@35 T@T) (arg3@@15 T@T) (arg4@@7 T@T) (arg5@@3 T@T) ) (! (= (MapType4TypeInv1 (MapType4Type arg0@@178 arg1@@83 arg2@@35 arg3@@15 arg4@@7 arg5@@3)) arg1@@83)
 :qid |typeInv:MapType4TypeInv1|
 :pattern ( (MapType4Type arg0@@178 arg1@@83 arg2@@35 arg3@@15 arg4@@7 arg5@@3))
))) (forall ((arg0@@179 T@T) (arg1@@84 T@T) (arg2@@36 T@T) (arg3@@16 T@T) (arg4@@8 T@T) (arg5@@4 T@T) ) (! (= (MapType4TypeInv2 (MapType4Type arg0@@179 arg1@@84 arg2@@36 arg3@@16 arg4@@8 arg5@@4)) arg2@@36)
 :qid |typeInv:MapType4TypeInv2|
 :pattern ( (MapType4Type arg0@@179 arg1@@84 arg2@@36 arg3@@16 arg4@@8 arg5@@4))
))) (forall ((arg0@@180 T@T) (arg1@@85 T@T) (arg2@@37 T@T) (arg3@@17 T@T) (arg4@@9 T@T) (arg5@@5 T@T) ) (! (= (MapType4TypeInv3 (MapType4Type arg0@@180 arg1@@85 arg2@@37 arg3@@17 arg4@@9 arg5@@5)) arg3@@17)
 :qid |typeInv:MapType4TypeInv3|
 :pattern ( (MapType4Type arg0@@180 arg1@@85 arg2@@37 arg3@@17 arg4@@9 arg5@@5))
))) (forall ((arg0@@181 T@T) (arg1@@86 T@T) (arg2@@38 T@T) (arg3@@18 T@T) (arg4@@10 T@T) (arg5@@6 T@T) ) (! (= (MapType4TypeInv4 (MapType4Type arg0@@181 arg1@@86 arg2@@38 arg3@@18 arg4@@10 arg5@@6)) arg4@@10)
 :qid |typeInv:MapType4TypeInv4|
 :pattern ( (MapType4Type arg0@@181 arg1@@86 arg2@@38 arg3@@18 arg4@@10 arg5@@6))
))) (forall ((arg0@@182 T@T) (arg1@@87 T@T) (arg2@@39 T@T) (arg3@@19 T@T) (arg4@@11 T@T) (arg5@@7 T@T) ) (! (= (MapType4TypeInv5 (MapType4Type arg0@@182 arg1@@87 arg2@@39 arg3@@19 arg4@@11 arg5@@7)) arg5@@7)
 :qid |typeInv:MapType4TypeInv5|
 :pattern ( (MapType4Type arg0@@182 arg1@@87 arg2@@39 arg3@@19 arg4@@11 arg5@@7))
))) (forall ((arg0@@183 T@U) (arg1@@88 T@U) (arg2@@40 T@U) (arg3@@20 T@U) (arg4@@12 T@U) (arg5@@8 T@U) ) (! (let ((aVar5 (MapType4TypeInv5 (type arg0@@183))))
(= (type (MapType4Select arg0@@183 arg1@@88 arg2@@40 arg3@@20 arg4@@12 arg5@@8)) aVar5))
 :qid |funType:MapType4Select|
 :pattern ( (MapType4Select arg0@@183 arg1@@88 arg2@@40 arg3@@20 arg4@@12 arg5@@8))
))) (forall ((arg0@@184 T@U) (arg1@@89 T@U) (arg2@@41 T@U) (arg3@@21 T@U) (arg4@@13 T@U) (arg5@@9 T@U) (arg6@@1 T@U) ) (! (let ((aVar5@@0 (type arg6@@1)))
(let ((aVar4 (type arg5@@9)))
(let ((aVar3@@2 (type arg4@@13)))
(let ((aVar2@@3 (type arg3@@21)))
(let ((aVar1@@4 (type arg2@@41)))
(let ((aVar0@@2 (type arg1@@89)))
(= (type (MapType4Store arg0@@184 arg1@@89 arg2@@41 arg3@@21 arg4@@13 arg5@@9 arg6@@1)) (MapType4Type aVar0@@2 aVar1@@4 aVar2@@3 aVar3@@2 aVar4 aVar5@@0))))))))
 :qid |funType:MapType4Store|
 :pattern ( (MapType4Store arg0@@184 arg1@@89 arg2@@41 arg3@@21 arg4@@13 arg5@@9 arg6@@1))
))) (forall ((m@@54 T@U) (x0@@14 T@U) (x1@@8 T@U) (x2@@4 T@U) (x3 T@U) (x4 T@U) (val@@15 T@U) ) (! (let ((aVar5@@1 (MapType4TypeInv5 (type m@@54))))
 (=> (= (type val@@15) aVar5@@1) (= (MapType4Select (MapType4Store m@@54 x0@@14 x1@@8 x2@@4 x3 x4 val@@15) x0@@14 x1@@8 x2@@4 x3 x4) val@@15)))
 :qid |mapAx0:MapType4Select|
 :weight 0
))) (and (and (and (and (and (forall ((val@@16 T@U) (m@@55 T@U) (x0@@15 T@U) (x1@@9 T@U) (x2@@5 T@U) (x3@@0 T@U) (x4@@0 T@U) (y0@@10 T@U) (y1@@6 T@U) (y2@@3 T@U) (y3 T@U) (y4 T@U) ) (!  (or (= x0@@15 y0@@10) (= (MapType4Select (MapType4Store m@@55 x0@@15 x1@@9 x2@@5 x3@@0 x4@@0 val@@16) y0@@10 y1@@6 y2@@3 y3 y4) (MapType4Select m@@55 y0@@10 y1@@6 y2@@3 y3 y4)))
 :qid |mapAx1:MapType4Select:0|
 :weight 0
)) (forall ((val@@17 T@U) (m@@56 T@U) (x0@@16 T@U) (x1@@10 T@U) (x2@@6 T@U) (x3@@1 T@U) (x4@@1 T@U) (y0@@11 T@U) (y1@@7 T@U) (y2@@4 T@U) (y3@@0 T@U) (y4@@0 T@U) ) (!  (or (= x1@@10 y1@@7) (= (MapType4Select (MapType4Store m@@56 x0@@16 x1@@10 x2@@6 x3@@1 x4@@1 val@@17) y0@@11 y1@@7 y2@@4 y3@@0 y4@@0) (MapType4Select m@@56 y0@@11 y1@@7 y2@@4 y3@@0 y4@@0)))
 :qid |mapAx1:MapType4Select:1|
 :weight 0
))) (forall ((val@@18 T@U) (m@@57 T@U) (x0@@17 T@U) (x1@@11 T@U) (x2@@7 T@U) (x3@@2 T@U) (x4@@2 T@U) (y0@@12 T@U) (y1@@8 T@U) (y2@@5 T@U) (y3@@1 T@U) (y4@@1 T@U) ) (!  (or (= x2@@7 y2@@5) (= (MapType4Select (MapType4Store m@@57 x0@@17 x1@@11 x2@@7 x3@@2 x4@@2 val@@18) y0@@12 y1@@8 y2@@5 y3@@1 y4@@1) (MapType4Select m@@57 y0@@12 y1@@8 y2@@5 y3@@1 y4@@1)))
 :qid |mapAx1:MapType4Select:2|
 :weight 0
))) (forall ((val@@19 T@U) (m@@58 T@U) (x0@@18 T@U) (x1@@12 T@U) (x2@@8 T@U) (x3@@3 T@U) (x4@@3 T@U) (y0@@13 T@U) (y1@@9 T@U) (y2@@6 T@U) (y3@@2 T@U) (y4@@2 T@U) ) (!  (or (= x3@@3 y3@@2) (= (MapType4Select (MapType4Store m@@58 x0@@18 x1@@12 x2@@8 x3@@3 x4@@3 val@@19) y0@@13 y1@@9 y2@@6 y3@@2 y4@@2) (MapType4Select m@@58 y0@@13 y1@@9 y2@@6 y3@@2 y4@@2)))
 :qid |mapAx1:MapType4Select:3|
 :weight 0
))) (forall ((val@@20 T@U) (m@@59 T@U) (x0@@19 T@U) (x1@@13 T@U) (x2@@9 T@U) (x3@@4 T@U) (x4@@4 T@U) (y0@@14 T@U) (y1@@10 T@U) (y2@@7 T@U) (y3@@3 T@U) (y4@@3 T@U) ) (!  (or (= x4@@4 y4@@3) (= (MapType4Select (MapType4Store m@@59 x0@@19 x1@@13 x2@@9 x3@@4 x4@@4 val@@20) y0@@14 y1@@10 y2@@7 y3@@3 y4@@3) (MapType4Select m@@59 y0@@14 y1@@10 y2@@7 y3@@3 y4@@3)))
 :qid |mapAx1:MapType4Select:4|
 :weight 0
))) (forall ((val@@21 T@U) (m@@60 T@U) (x0@@20 T@U) (x1@@14 T@U) (x2@@10 T@U) (x3@@5 T@U) (x4@@5 T@U) (y0@@15 T@U) (y1@@11 T@U) (y2@@8 T@U) (y3@@4 T@U) (y4@@4 T@U) ) (!  (or true (= (MapType4Select (MapType4Store m@@60 x0@@20 x1@@14 x2@@10 x3@@5 x4@@5 val@@21) y0@@15 y1@@11 y2@@8 y3@@4 y4@@4) (MapType4Select m@@60 y0@@15 y1@@11 y2@@8 y3@@4 y4@@4)))
 :qid |mapAx2:MapType4Select|
 :weight 0
)))) (forall ((arg0@@185 T@U) (arg1@@90 T@U) (arg2@@42 T@U) (arg3@@22 T@U) (arg4@@14 T@U) (arg5@@10 T@U) (arg6@@2 T@U) (arg7 T@U) (arg8 T@U) (arg9 T@U) (arg10 T@U) ) (! (= (type (Apply4 arg0@@185 arg1@@90 arg2@@42 arg3@@22 arg4@@14 arg5@@10 arg6@@2 arg7 arg8 arg9 arg10)) BoxType)
 :qid |funType:Apply4|
 :pattern ( (Apply4 arg0@@185 arg1@@90 arg2@@42 arg3@@22 arg4@@14 arg5@@10 arg6@@2 arg7 arg8 arg9 arg10))
))) (forall ((arg0@@186 T@U) (arg1@@91 T@U) (arg2@@43 T@U) ) (! (= (type (Handle4 arg0@@186 arg1@@91 arg2@@43)) HandleTypeType)
 :qid |funType:Handle4|
 :pattern ( (Handle4 arg0@@186 arg1@@91 arg2@@43))
))))
(assert (forall ((t0@@61 T@U) (t1@@37 T@U) (t2@@14 T@U) (t3 T@U) (t4 T@U) (heap@@16 T@U) (h@@39 T@U) (r@@18 T@U) (rd@@8 T@U) (bx0@@27 T@U) (bx1@@13 T@U) (bx2 T@U) (bx3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@61) TyType) (= (type t1@@37) TyType)) (= (type t2@@14) TyType)) (= (type t3) TyType)) (= (type t4) TyType)) (= (type heap@@16) (MapType0Type refType MapType1Type))) (= (type h@@39) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@18) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@8) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@27) BoxType)) (= (type bx1@@13) BoxType)) (= (type bx2) BoxType)) (= (type bx3) BoxType)) (= (Apply4 t0@@61 t1@@37 t2@@14 t3 t4 heap@@16 (Handle4 h@@39 r@@18 rd@@8) bx0@@27 bx1@@13 bx2 bx3) (MapType4Select h@@39 heap@@16 bx0@@27 bx1@@13 bx2 bx3)))
 :qid |unknown.0:0|
 :skolemid |883|
 :pattern ( (Apply4 t0@@61 t1@@37 t2@@14 t3 t4 heap@@16 (Handle4 h@@39 r@@18 rd@@8) bx0@@27 bx1@@13 bx2 bx3))
)))
(assert (forall ((t0@@62 T@U) (t1@@38 T@U) (t2@@15 T@U) (t3@@0 T@U) (t4@@0 T@U) (heap@@17 T@U) (h@@40 T@U) (r@@19 T@U) (rd@@9 T@U) (bx0@@28 T@U) (bx1@@14 T@U) (bx2@@0 T@U) (bx3@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@62) TyType) (= (type t1@@38) TyType)) (= (type t2@@15) TyType)) (= (type t3@@0) TyType)) (= (type t4@@0) TyType)) (= (type heap@@17) (MapType0Type refType MapType1Type))) (= (type h@@40) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@19) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@9) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@28) BoxType)) (= (type bx1@@14) BoxType)) (= (type bx2@@0) BoxType)) (= (type bx3@@0) BoxType)) (U_2_bool (MapType4Select r@@19 heap@@17 bx0@@28 bx1@@14 bx2@@0 bx3@@0))) (Requires4 t0@@62 t1@@38 t2@@15 t3@@0 t4@@0 heap@@17 (Handle4 h@@40 r@@19 rd@@9) bx0@@28 bx1@@14 bx2@@0 bx3@@0))
 :qid |unknown.0:0|
 :skolemid |884|
 :pattern ( (Requires4 t0@@62 t1@@38 t2@@15 t3@@0 t4@@0 heap@@17 (Handle4 h@@40 r@@19 rd@@9) bx0@@28 bx1@@14 bx2@@0 bx3@@0))
)))
(assert (forall ((arg0@@187 T@U) (arg1@@92 T@U) (arg2@@44 T@U) (arg3@@23 T@U) (arg4@@15 T@U) (arg5@@11 T@U) (arg6@@3 T@U) (arg7@@0 T@U) (arg8@@0 T@U) (arg9@@0 T@U) (arg10@@0 T@U) ) (! (= (type (Reads4 arg0@@187 arg1@@92 arg2@@44 arg3@@23 arg4@@15 arg5@@11 arg6@@3 arg7@@0 arg8@@0 arg9@@0 arg10@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads4|
 :pattern ( (Reads4 arg0@@187 arg1@@92 arg2@@44 arg3@@23 arg4@@15 arg5@@11 arg6@@3 arg7@@0 arg8@@0 arg9@@0 arg10@@0))
)))
(assert (forall ((t0@@63 T@U) (t1@@39 T@U) (t2@@16 T@U) (t3@@1 T@U) (t4@@1 T@U) (heap@@18 T@U) (h@@41 T@U) (r@@20 T@U) (rd@@10 T@U) (bx0@@29 T@U) (bx1@@15 T@U) (bx2@@1 T@U) (bx3@@1 T@U) (bx@@52 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@63) TyType) (= (type t1@@39) TyType)) (= (type t2@@16) TyType)) (= (type t3@@1) TyType)) (= (type t4@@1) TyType)) (= (type heap@@18) (MapType0Type refType MapType1Type))) (= (type h@@41) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@20) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@10) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@29) BoxType)) (= (type bx1@@15) BoxType)) (= (type bx2@@1) BoxType)) (= (type bx3@@1) BoxType)) (= (type bx@@52) BoxType)) (= (U_2_bool (MapType0Select (Reads4 t0@@63 t1@@39 t2@@16 t3@@1 t4@@1 heap@@18 (Handle4 h@@41 r@@20 rd@@10) bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52)) (U_2_bool (MapType0Select (MapType4Select rd@@10 heap@@18 bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52))))
 :qid |unknown.0:0|
 :skolemid |885|
 :pattern ( (MapType0Select (Reads4 t0@@63 t1@@39 t2@@16 t3@@1 t4@@1 heap@@18 (Handle4 h@@41 r@@20 rd@@10) bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52))
)))
(assert (forall ((t0@@64 T@U) (t1@@40 T@U) (t2@@17 T@U) (t3@@2 T@U) (t4@@2 T@U) (h0@@18 T@U) (h1@@18 T@U) (f@@41 T@U) (bx0@@30 T@U) (bx1@@16 T@U) (bx2@@2 T@U) (bx3@@2 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@64) TyType) (= (type t1@@40) TyType)) (= (type t2@@17) TyType)) (= (type t3@@2) TyType)) (= (type t4@@2) TyType)) (= (type h0@@18) (MapType0Type refType MapType1Type))) (= (type h1@@18) (MapType0Type refType MapType1Type))) (= (type f@@41) HandleTypeType)) (= (type bx0@@30) BoxType)) (= (type bx1@@16) BoxType)) (= (type bx2@@2) BoxType)) (= (type bx3@@2) BoxType)) (and (and (and ($HeapSucc h0@@18 h1@@18) (and ($IsGoodHeap h0@@18) ($IsGoodHeap h1@@18))) (and (and (and (and ($IsBox bx0@@30 t0@@64) ($IsBox bx1@@16 t1@@40)) ($IsBox bx2@@2 t2@@17)) ($IsBox bx3@@2 t3@@2)) ($Is f@@41 (Tclass._System.___hFunc4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2)))) (forall ((o@@62 T@U) (fld@@17 T@U) ) (! (let ((a@@102 (FieldTypeInv0 (type fld@@17))))
 (=> (and (and (= (type o@@62) refType) (= (type fld@@17) (FieldType a@@102))) (and (not (= o@@62 null)) (U_2_bool (MapType0Select (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h0@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2) ($Box o@@62))))) (= (MapType1Select (MapType0Select h0@@18 o@@62) fld@@17) (MapType1Select (MapType0Select h1@@18 o@@62) fld@@17))))
 :qid |unknown.0:0|
 :skolemid |886|
 :no-pattern (type o@@62)
 :no-pattern (type fld@@17)
 :no-pattern (U_2_int o@@62)
 :no-pattern (U_2_bool o@@62)
 :no-pattern (U_2_int fld@@17)
 :no-pattern (U_2_bool fld@@17)
)))) (= (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h0@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2) (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h1@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2)))
 :qid |unknown.0:0|
 :skolemid |887|
 :pattern ( ($HeapSucc h0@@18 h1@@18) (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h1@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2))
)))
(assert (forall ((t0@@65 T@U) (t1@@41 T@U) (t2@@18 T@U) (t3@@3 T@U) (t4@@3 T@U) (h0@@19 T@U) (h1@@19 T@U) (f@@42 T@U) (bx0@@31 T@U) (bx1@@17 T@U) (bx2@@3 T@U) (bx3@@3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@65) TyType) (= (type t1@@41) TyType)) (= (type t2@@18) TyType)) (= (type t3@@3) TyType)) (= (type t4@@3) TyType)) (= (type h0@@19) (MapType0Type refType MapType1Type))) (= (type h1@@19) (MapType0Type refType MapType1Type))) (= (type f@@42) HandleTypeType)) (= (type bx0@@31) BoxType)) (= (type bx1@@17) BoxType)) (= (type bx2@@3) BoxType)) (= (type bx3@@3) BoxType)) (and (and (and ($HeapSucc h0@@19 h1@@19) (and ($IsGoodHeap h0@@19) ($IsGoodHeap h1@@19))) (and (and (and (and ($IsBox bx0@@31 t0@@65) ($IsBox bx1@@17 t1@@41)) ($IsBox bx2@@3 t2@@18)) ($IsBox bx3@@3 t3@@3)) ($Is f@@42 (Tclass._System.___hFunc4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3)))) (forall ((o@@63 T@U) (fld@@18 T@U) ) (! (let ((a@@103 (FieldTypeInv0 (type fld@@18))))
 (=> (and (and (= (type o@@63) refType) (= (type fld@@18) (FieldType a@@103))) (and (not (= o@@63 null)) (U_2_bool (MapType0Select (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3) ($Box o@@63))))) (= (MapType1Select (MapType0Select h0@@19 o@@63) fld@@18) (MapType1Select (MapType0Select h1@@19 o@@63) fld@@18))))
 :qid |unknown.0:0|
 :skolemid |888|
 :no-pattern (type o@@63)
 :no-pattern (type fld@@18)
 :no-pattern (U_2_int o@@63)
 :no-pattern (U_2_bool o@@63)
 :no-pattern (U_2_int fld@@18)
 :no-pattern (U_2_bool fld@@18)
)))) (= (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h0@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3) (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3)))
 :qid |unknown.0:0|
 :skolemid |889|
 :pattern ( ($HeapSucc h0@@19 h1@@19) (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3))
)))
(assert (forall ((t0@@66 T@U) (t1@@42 T@U) (t2@@19 T@U) (t3@@4 T@U) (t4@@4 T@U) (h0@@20 T@U) (h1@@20 T@U) (f@@43 T@U) (bx0@@32 T@U) (bx1@@18 T@U) (bx2@@4 T@U) (bx3@@4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@66) TyType) (= (type t1@@42) TyType)) (= (type t2@@19) TyType)) (= (type t3@@4) TyType)) (= (type t4@@4) TyType)) (= (type h0@@20) (MapType0Type refType MapType1Type))) (= (type h1@@20) (MapType0Type refType MapType1Type))) (= (type f@@43) HandleTypeType)) (= (type bx0@@32) BoxType)) (= (type bx1@@18) BoxType)) (= (type bx2@@4) BoxType)) (= (type bx3@@4) BoxType)) (and (and (and ($HeapSucc h0@@20 h1@@20) (and ($IsGoodHeap h0@@20) ($IsGoodHeap h1@@20))) (and (and (and (and ($IsBox bx0@@32 t0@@66) ($IsBox bx1@@18 t1@@42)) ($IsBox bx2@@4 t2@@19)) ($IsBox bx3@@4 t3@@4)) ($Is f@@43 (Tclass._System.___hFunc4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4)))) (forall ((o@@64 T@U) (fld@@19 T@U) ) (! (let ((a@@104 (FieldTypeInv0 (type fld@@19))))
 (=> (and (and (= (type o@@64) refType) (= (type fld@@19) (FieldType a@@104))) (and (not (= o@@64 null)) (U_2_bool (MapType0Select (Reads4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h0@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4) ($Box o@@64))))) (= (MapType1Select (MapType0Select h0@@20 o@@64) fld@@19) (MapType1Select (MapType0Select h1@@20 o@@64) fld@@19))))
 :qid |unknown.0:0|
 :skolemid |890|
 :no-pattern (type o@@64)
 :no-pattern (type fld@@19)
 :no-pattern (U_2_int o@@64)
 :no-pattern (U_2_bool o@@64)
 :no-pattern (U_2_int fld@@19)
 :no-pattern (U_2_bool fld@@19)
)))) (= (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h0@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4) (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h1@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4)))
 :qid |unknown.0:0|
 :skolemid |891|
 :pattern ( ($HeapSucc h0@@20 h1@@20) (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h1@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4))
)))
(assert (forall ((t0@@67 T@U) (t1@@43 T@U) (t2@@20 T@U) (t3@@5 T@U) (t4@@5 T@U) (h0@@21 T@U) (h1@@21 T@U) (f@@44 T@U) (bx0@@33 T@U) (bx1@@19 T@U) (bx2@@5 T@U) (bx3@@5 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@67) TyType) (= (type t1@@43) TyType)) (= (type t2@@20) TyType)) (= (type t3@@5) TyType)) (= (type t4@@5) TyType)) (= (type h0@@21) (MapType0Type refType MapType1Type))) (= (type h1@@21) (MapType0Type refType MapType1Type))) (= (type f@@44) HandleTypeType)) (= (type bx0@@33) BoxType)) (= (type bx1@@19) BoxType)) (= (type bx2@@5) BoxType)) (= (type bx3@@5) BoxType)) (and (and (and ($HeapSucc h0@@21 h1@@21) (and ($IsGoodHeap h0@@21) ($IsGoodHeap h1@@21))) (and (and (and (and ($IsBox bx0@@33 t0@@67) ($IsBox bx1@@19 t1@@43)) ($IsBox bx2@@5 t2@@20)) ($IsBox bx3@@5 t3@@5)) ($Is f@@44 (Tclass._System.___hFunc4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5)))) (forall ((o@@65 T@U) (fld@@20 T@U) ) (! (let ((a@@105 (FieldTypeInv0 (type fld@@20))))
 (=> (and (and (= (type o@@65) refType) (= (type fld@@20) (FieldType a@@105))) (and (not (= o@@65 null)) (U_2_bool (MapType0Select (Reads4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5) ($Box o@@65))))) (= (MapType1Select (MapType0Select h0@@21 o@@65) fld@@20) (MapType1Select (MapType0Select h1@@21 o@@65) fld@@20))))
 :qid |unknown.0:0|
 :skolemid |892|
 :no-pattern (type o@@65)
 :no-pattern (type fld@@20)
 :no-pattern (U_2_int o@@65)
 :no-pattern (U_2_bool o@@65)
 :no-pattern (U_2_int fld@@20)
 :no-pattern (U_2_bool fld@@20)
)))) (= (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h0@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5) (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5)))
 :qid |unknown.0:0|
 :skolemid |893|
 :pattern ( ($HeapSucc h0@@21 h1@@21) (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5))
)))
(assert (forall ((t0@@68 T@U) (t1@@44 T@U) (t2@@21 T@U) (t3@@6 T@U) (t4@@6 T@U) (h0@@22 T@U) (h1@@22 T@U) (f@@45 T@U) (bx0@@34 T@U) (bx1@@20 T@U) (bx2@@6 T@U) (bx3@@6 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@68) TyType) (= (type t1@@44) TyType)) (= (type t2@@21) TyType)) (= (type t3@@6) TyType)) (= (type t4@@6) TyType)) (= (type h0@@22) (MapType0Type refType MapType1Type))) (= (type h1@@22) (MapType0Type refType MapType1Type))) (= (type f@@45) HandleTypeType)) (= (type bx0@@34) BoxType)) (= (type bx1@@20) BoxType)) (= (type bx2@@6) BoxType)) (= (type bx3@@6) BoxType)) (and (and (and ($HeapSucc h0@@22 h1@@22) (and ($IsGoodHeap h0@@22) ($IsGoodHeap h1@@22))) (and (and (and (and ($IsBox bx0@@34 t0@@68) ($IsBox bx1@@20 t1@@44)) ($IsBox bx2@@6 t2@@21)) ($IsBox bx3@@6 t3@@6)) ($Is f@@45 (Tclass._System.___hFunc4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6)))) (forall ((o@@66 T@U) (fld@@21 T@U) ) (! (let ((a@@106 (FieldTypeInv0 (type fld@@21))))
 (=> (and (and (= (type o@@66) refType) (= (type fld@@21) (FieldType a@@106))) (and (not (= o@@66 null)) (U_2_bool (MapType0Select (Reads4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h0@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6) ($Box o@@66))))) (= (MapType1Select (MapType0Select h0@@22 o@@66) fld@@21) (MapType1Select (MapType0Select h1@@22 o@@66) fld@@21))))
 :qid |unknown.0:0|
 :skolemid |894|
 :no-pattern (type o@@66)
 :no-pattern (type fld@@21)
 :no-pattern (U_2_int o@@66)
 :no-pattern (U_2_bool o@@66)
 :no-pattern (U_2_int fld@@21)
 :no-pattern (U_2_bool fld@@21)
)))) (= (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h0@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6) (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h1@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6)))
 :qid |unknown.0:0|
 :skolemid |895|
 :pattern ( ($HeapSucc h0@@22 h1@@22) (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h1@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6))
)))
(assert (forall ((t0@@69 T@U) (t1@@45 T@U) (t2@@22 T@U) (t3@@7 T@U) (t4@@7 T@U) (h0@@23 T@U) (h1@@23 T@U) (f@@46 T@U) (bx0@@35 T@U) (bx1@@21 T@U) (bx2@@7 T@U) (bx3@@7 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@69) TyType) (= (type t1@@45) TyType)) (= (type t2@@22) TyType)) (= (type t3@@7) TyType)) (= (type t4@@7) TyType)) (= (type h0@@23) (MapType0Type refType MapType1Type))) (= (type h1@@23) (MapType0Type refType MapType1Type))) (= (type f@@46) HandleTypeType)) (= (type bx0@@35) BoxType)) (= (type bx1@@21) BoxType)) (= (type bx2@@7) BoxType)) (= (type bx3@@7) BoxType)) (and (and (and ($HeapSucc h0@@23 h1@@23) (and ($IsGoodHeap h0@@23) ($IsGoodHeap h1@@23))) (and (and (and (and ($IsBox bx0@@35 t0@@69) ($IsBox bx1@@21 t1@@45)) ($IsBox bx2@@7 t2@@22)) ($IsBox bx3@@7 t3@@7)) ($Is f@@46 (Tclass._System.___hFunc4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7)))) (forall ((o@@67 T@U) (fld@@22 T@U) ) (! (let ((a@@107 (FieldTypeInv0 (type fld@@22))))
 (=> (and (and (= (type o@@67) refType) (= (type fld@@22) (FieldType a@@107))) (and (not (= o@@67 null)) (U_2_bool (MapType0Select (Reads4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7) ($Box o@@67))))) (= (MapType1Select (MapType0Select h0@@23 o@@67) fld@@22) (MapType1Select (MapType0Select h1@@23 o@@67) fld@@22))))
 :qid |unknown.0:0|
 :skolemid |896|
 :no-pattern (type o@@67)
 :no-pattern (type fld@@22)
 :no-pattern (U_2_int o@@67)
 :no-pattern (U_2_bool o@@67)
 :no-pattern (U_2_int fld@@22)
 :no-pattern (U_2_bool fld@@22)
)))) (= (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h0@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7) (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7)))
 :qid |unknown.0:0|
 :skolemid |897|
 :pattern ( ($HeapSucc h0@@23 h1@@23) (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7))
)))
(assert (forall ((t0@@70 T@U) (t1@@46 T@U) (t2@@23 T@U) (t3@@8 T@U) (t4@@8 T@U) (heap@@19 T@U) (f@@47 T@U) (bx0@@36 T@U) (bx1@@22 T@U) (bx2@@8 T@U) (bx3@@8 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@70) TyType) (= (type t1@@46) TyType)) (= (type t2@@23) TyType)) (= (type t3@@8) TyType)) (= (type t4@@8) TyType)) (= (type heap@@19) (MapType0Type refType MapType1Type))) (= (type f@@47) HandleTypeType)) (= (type bx0@@36) BoxType)) (= (type bx1@@22) BoxType)) (= (type bx2@@8) BoxType)) (= (type bx3@@8) BoxType)) (and ($IsGoodHeap heap@@19) (and (and (and (and ($IsBox bx0@@36 t0@@70) ($IsBox bx1@@22 t1@@46)) ($IsBox bx2@@8 t2@@23)) ($IsBox bx3@@8 t3@@8)) ($Is f@@47 (Tclass._System.___hFunc4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8))))) (= (|Set#Equal| (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 $OneHeap f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 heap@@19 f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |898|
 :pattern ( (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 $OneHeap f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) ($IsGoodHeap heap@@19))
 :pattern ( (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 heap@@19 f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8))
)))
(assert (forall ((t0@@71 T@U) (t1@@47 T@U) (t2@@24 T@U) (t3@@9 T@U) (t4@@9 T@U) (heap@@20 T@U) (f@@48 T@U) (bx0@@37 T@U) (bx1@@23 T@U) (bx2@@9 T@U) (bx3@@9 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@71) TyType) (= (type t1@@47) TyType)) (= (type t2@@24) TyType)) (= (type t3@@9) TyType)) (= (type t4@@9) TyType)) (= (type heap@@20) (MapType0Type refType MapType1Type))) (= (type f@@48) HandleTypeType)) (= (type bx0@@37) BoxType)) (= (type bx1@@23) BoxType)) (= (type bx2@@9) BoxType)) (= (type bx3@@9) BoxType)) (and (and ($IsGoodHeap heap@@20) (and (and (and (and ($IsBox bx0@@37 t0@@71) ($IsBox bx1@@23 t1@@47)) ($IsBox bx2@@9 t2@@24)) ($IsBox bx3@@9 t3@@9)) ($Is f@@48 (Tclass._System.___hFunc4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9)))) (|Set#Equal| (Reads4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) (|Set#Empty| BoxType)))) (= (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 heap@@20 f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9)))
 :qid |unknown.0:0|
 :skolemid |899|
 :pattern ( (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) ($IsGoodHeap heap@@20))
 :pattern ( (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 heap@@20 f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9))
)))
(assert (forall ((f@@49 T@U) (t0@@72 T@U) (t1@@48 T@U) (t2@@25 T@U) (t3@@10 T@U) (t4@@10 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@49) HandleTypeType) (= (type t0@@72) TyType)) (= (type t1@@48) TyType)) (= (type t2@@25) TyType)) (= (type t3@@10) TyType)) (= (type t4@@10) TyType)) (= ($Is f@@49 (Tclass._System.___hFunc4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10)) (forall ((h@@42 T@U) (bx0@@38 T@U) (bx1@@24 T@U) (bx2@@10 T@U) (bx3@@10 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@42) (MapType0Type refType MapType1Type)) (= (type bx0@@38) BoxType)) (= (type bx1@@24) BoxType)) (= (type bx2@@10) BoxType)) (= (type bx3@@10) BoxType)) (and (and ($IsGoodHeap h@@42) (and (and (and ($IsBox bx0@@38 t0@@72) ($IsBox bx1@@24 t1@@48)) ($IsBox bx2@@10 t2@@25)) ($IsBox bx3@@10 t3@@10))) (Requires4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10))) ($IsBox (Apply4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10) t4@@10))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |900|
 :pattern ( (Apply4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10))
))))
 :qid |unknown.0:0|
 :skolemid |901|
 :pattern ( ($Is f@@49 (Tclass._System.___hFunc4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10)))
)))
(assert (forall ((f@@50 T@U) (t0@@73 T@U) (t1@@49 T@U) (t2@@26 T@U) (t3@@11 T@U) (t4@@11 T@U) (u0@@2 T@U) (u1@@1 T@U) (u2@@0 T@U) (u3 T@U) (u4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type f@@50) HandleTypeType) (= (type t0@@73) TyType)) (= (type t1@@49) TyType)) (= (type t2@@26) TyType)) (= (type t3@@11) TyType)) (= (type t4@@11) TyType)) (= (type u0@@2) TyType)) (= (type u1@@1) TyType)) (= (type u2@@0) TyType)) (= (type u3) TyType)) (= (type u4) TyType)) (and (and (and (and (and ($Is f@@50 (Tclass._System.___hFunc4 t0@@73 t1@@49 t2@@26 t3@@11 t4@@11)) (forall ((bx@@53 T@U) ) (!  (=> (and (= (type bx@@53) BoxType) ($IsBox bx@@53 u0@@2)) ($IsBox bx@@53 t0@@73))
 :qid |unknown.0:0|
 :skolemid |902|
 :pattern ( ($IsBox bx@@53 u0@@2))
 :pattern ( ($IsBox bx@@53 t0@@73))
))) (forall ((bx@@54 T@U) ) (!  (=> (and (= (type bx@@54) BoxType) ($IsBox bx@@54 u1@@1)) ($IsBox bx@@54 t1@@49))
 :qid |unknown.0:0|
 :skolemid |903|
 :pattern ( ($IsBox bx@@54 u1@@1))
 :pattern ( ($IsBox bx@@54 t1@@49))
))) (forall ((bx@@55 T@U) ) (!  (=> (and (= (type bx@@55) BoxType) ($IsBox bx@@55 u2@@0)) ($IsBox bx@@55 t2@@26))
 :qid |unknown.0:0|
 :skolemid |904|
 :pattern ( ($IsBox bx@@55 u2@@0))
 :pattern ( ($IsBox bx@@55 t2@@26))
))) (forall ((bx@@56 T@U) ) (!  (=> (and (= (type bx@@56) BoxType) ($IsBox bx@@56 u3)) ($IsBox bx@@56 t3@@11))
 :qid |unknown.0:0|
 :skolemid |905|
 :pattern ( ($IsBox bx@@56 u3))
 :pattern ( ($IsBox bx@@56 t3@@11))
))) (forall ((bx@@57 T@U) ) (!  (=> (and (= (type bx@@57) BoxType) ($IsBox bx@@57 t4@@11)) ($IsBox bx@@57 u4))
 :qid |unknown.0:0|
 :skolemid |906|
 :pattern ( ($IsBox bx@@57 t4@@11))
 :pattern ( ($IsBox bx@@57 u4))
)))) ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4)))
 :qid |unknown.0:0|
 :skolemid |907|
 :pattern ( ($Is f@@50 (Tclass._System.___hFunc4 t0@@73 t1@@49 t2@@26 t3@@11 t4@@11)) ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4)))
)))
(assert (forall ((f@@51 T@U) (t0@@74 T@U) (t1@@50 T@U) (t2@@27 T@U) (t3@@12 T@U) (t4@@12 T@U) (h@@43 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@51) HandleTypeType) (= (type t0@@74) TyType)) (= (type t1@@50) TyType)) (= (type t2@@27) TyType)) (= (type t3@@12) TyType)) (= (type t4@@12) TyType)) (= (type h@@43) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@43)) (= ($IsAlloc f@@51 (Tclass._System.___hFunc4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12) h@@43) (forall ((bx0@@39 T@U) (bx1@@25 T@U) (bx2@@11 T@U) (bx3@@11 T@U) ) (!  (=> (and (and (and (= (type bx0@@39) BoxType) (= (type bx1@@25) BoxType)) (= (type bx2@@11) BoxType)) (= (type bx3@@11) BoxType)) (=> (and (and (and (and (and ($IsBox bx0@@39 t0@@74) ($IsAllocBox bx0@@39 t0@@74 h@@43)) (and ($IsBox bx1@@25 t1@@50) ($IsAllocBox bx1@@25 t1@@50 h@@43))) (and ($IsBox bx2@@11 t2@@27) ($IsAllocBox bx2@@11 t2@@27 h@@43))) (and ($IsBox bx3@@11 t3@@12) ($IsAllocBox bx3@@11 t3@@12 h@@43))) (Requires4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11)) (forall ((r@@21 T@U) ) (!  (=> (= (type r@@21) refType) (=> (and (not (= r@@21 null)) (U_2_bool (MapType0Select (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11) ($Box r@@21)))) (U_2_bool (MapType1Select (MapType0Select h@@43 r@@21) alloc))))
 :qid |unknown.0:0|
 :skolemid |908|
 :pattern ( (MapType0Select (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11) ($Box r@@21)))
))))
 :qid |unknown.0:0|
 :skolemid |909|
 :pattern ( (Apply4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11))
 :pattern ( (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11))
))))
 :qid |unknown.0:0|
 :skolemid |910|
 :pattern ( ($IsAlloc f@@51 (Tclass._System.___hFunc4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12) h@@43))
)))
(assert (forall ((f@@52 T@U) (t0@@75 T@U) (t1@@51 T@U) (t2@@28 T@U) (t3@@13 T@U) (t4@@13 T@U) (h@@44 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@52) HandleTypeType) (= (type t0@@75) TyType)) (= (type t1@@51) TyType)) (= (type t2@@28) TyType)) (= (type t3@@13) TyType)) (= (type t4@@13) TyType)) (= (type h@@44) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@44) ($IsAlloc f@@52 (Tclass._System.___hFunc4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13) h@@44))) (forall ((bx0@@40 T@U) (bx1@@26 T@U) (bx2@@12 T@U) (bx3@@12 T@U) ) (!  (=> (and (and (and (= (type bx0@@40) BoxType) (= (type bx1@@26) BoxType)) (= (type bx2@@12) BoxType)) (= (type bx3@@12) BoxType)) (=> (and (and (and (and ($IsAllocBox bx0@@40 t0@@75 h@@44) ($IsAllocBox bx1@@26 t1@@51 h@@44)) ($IsAllocBox bx2@@12 t2@@28 h@@44)) ($IsAllocBox bx3@@12 t3@@13 h@@44)) (Requires4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12)) ($IsAllocBox (Apply4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12) t4@@13 h@@44)))
 :qid |unknown.0:0|
 :skolemid |911|
 :pattern ( (Apply4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12))
)))
 :qid |unknown.0:0|
 :skolemid |912|
 :pattern ( ($IsAlloc f@@52 (Tclass._System.___hFunc4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13) h@@44))
)))
(assert (forall ((arg0@@188 T@U) (arg1@@93 T@U) (arg2@@45 T@U) (arg3@@24 T@U) (arg4@@16 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4 arg0@@188 arg1@@93 arg2@@45 arg3@@24 arg4@@16)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4|
 :pattern ( (Tclass._System.___hPartialFunc4 arg0@@188 arg1@@93 arg2@@45 arg3@@24 arg4@@16))
)))
(assert (forall ((|#$T0@@41| T@U) (|#$T1@@25| T@U) (|#$T2@@6| T@U) (|#$T3@@6| T@U) (|#$R@@54| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@41|) TyType) (= (type |#$T1@@25|) TyType)) (= (type |#$T2@@6|) TyType)) (= (type |#$T3@@6|) TyType)) (= (type |#$R@@54|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|)) Tagclass._System.___hPartialFunc4) (= (TagFamily (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|)) |tytagFamily$_#PartialFunc4|)))
 :qid |unknown.0:0|
 :skolemid |913|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|))
)))
(assert (forall ((arg0@@189 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_0 arg0@@189)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_0|
 :pattern ( (Tclass._System.___hPartialFunc4_0 arg0@@189))
)))
(assert (forall ((|#$T0@@42| T@U) (|#$T1@@26| T@U) (|#$T2@@7| T@U) (|#$T3@@7| T@U) (|#$R@@55| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@42|) TyType) (= (type |#$T1@@26|) TyType)) (= (type |#$T2@@7|) TyType)) (= (type |#$T3@@7|) TyType)) (= (type |#$R@@55|) TyType)) (= (Tclass._System.___hPartialFunc4_0 (Tclass._System.___hPartialFunc4 |#$T0@@42| |#$T1@@26| |#$T2@@7| |#$T3@@7| |#$R@@55|)) |#$T0@@42|))
 :qid |unknown.0:0|
 :skolemid |914|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@42| |#$T1@@26| |#$T2@@7| |#$T3@@7| |#$R@@55|))
)))
(assert (forall ((arg0@@190 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_1 arg0@@190)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_1|
 :pattern ( (Tclass._System.___hPartialFunc4_1 arg0@@190))
)))
(assert (forall ((|#$T0@@43| T@U) (|#$T1@@27| T@U) (|#$T2@@8| T@U) (|#$T3@@8| T@U) (|#$R@@56| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@43|) TyType) (= (type |#$T1@@27|) TyType)) (= (type |#$T2@@8|) TyType)) (= (type |#$T3@@8|) TyType)) (= (type |#$R@@56|) TyType)) (= (Tclass._System.___hPartialFunc4_1 (Tclass._System.___hPartialFunc4 |#$T0@@43| |#$T1@@27| |#$T2@@8| |#$T3@@8| |#$R@@56|)) |#$T1@@27|))
 :qid |unknown.0:0|
 :skolemid |915|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@43| |#$T1@@27| |#$T2@@8| |#$T3@@8| |#$R@@56|))
)))
(assert (forall ((arg0@@191 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_2 arg0@@191)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_2|
 :pattern ( (Tclass._System.___hPartialFunc4_2 arg0@@191))
)))
(assert (forall ((|#$T0@@44| T@U) (|#$T1@@28| T@U) (|#$T2@@9| T@U) (|#$T3@@9| T@U) (|#$R@@57| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@44|) TyType) (= (type |#$T1@@28|) TyType)) (= (type |#$T2@@9|) TyType)) (= (type |#$T3@@9|) TyType)) (= (type |#$R@@57|) TyType)) (= (Tclass._System.___hPartialFunc4_2 (Tclass._System.___hPartialFunc4 |#$T0@@44| |#$T1@@28| |#$T2@@9| |#$T3@@9| |#$R@@57|)) |#$T2@@9|))
 :qid |unknown.0:0|
 :skolemid |916|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@44| |#$T1@@28| |#$T2@@9| |#$T3@@9| |#$R@@57|))
)))
(assert (forall ((arg0@@192 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_3 arg0@@192)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_3|
 :pattern ( (Tclass._System.___hPartialFunc4_3 arg0@@192))
)))
(assert (forall ((|#$T0@@45| T@U) (|#$T1@@29| T@U) (|#$T2@@10| T@U) (|#$T3@@10| T@U) (|#$R@@58| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@45|) TyType) (= (type |#$T1@@29|) TyType)) (= (type |#$T2@@10|) TyType)) (= (type |#$T3@@10|) TyType)) (= (type |#$R@@58|) TyType)) (= (Tclass._System.___hPartialFunc4_3 (Tclass._System.___hPartialFunc4 |#$T0@@45| |#$T1@@29| |#$T2@@10| |#$T3@@10| |#$R@@58|)) |#$T3@@10|))
 :qid |unknown.0:0|
 :skolemid |917|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@45| |#$T1@@29| |#$T2@@10| |#$T3@@10| |#$R@@58|))
)))
(assert (forall ((arg0@@193 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_4 arg0@@193)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_4|
 :pattern ( (Tclass._System.___hPartialFunc4_4 arg0@@193))
)))
(assert (forall ((|#$T0@@46| T@U) (|#$T1@@30| T@U) (|#$T2@@11| T@U) (|#$T3@@11| T@U) (|#$R@@59| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@46|) TyType) (= (type |#$T1@@30|) TyType)) (= (type |#$T2@@11|) TyType)) (= (type |#$T3@@11|) TyType)) (= (type |#$R@@59|) TyType)) (= (Tclass._System.___hPartialFunc4_4 (Tclass._System.___hPartialFunc4 |#$T0@@46| |#$T1@@30| |#$T2@@11| |#$T3@@11| |#$R@@59|)) |#$R@@59|))
 :qid |unknown.0:0|
 :skolemid |918|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@46| |#$T1@@30| |#$T2@@11| |#$T3@@11| |#$R@@59|))
)))
(assert (forall ((|#$T0@@47| T@U) (|#$T1@@31| T@U) (|#$T2@@12| T@U) (|#$T3@@12| T@U) (|#$R@@60| T@U) (bx@@58 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@47|) TyType) (= (type |#$T1@@31|) TyType)) (= (type |#$T2@@12|) TyType)) (= (type |#$T3@@12|) TyType)) (= (type |#$R@@60|) TyType)) (= (type bx@@58) BoxType)) ($IsBox bx@@58 (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|))) (and (= ($Box ($Unbox HandleTypeType bx@@58)) bx@@58) ($Is ($Unbox HandleTypeType bx@@58) (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|))))
 :qid |unknown.0:0|
 :skolemid |919|
 :pattern ( ($IsBox bx@@58 (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|)))
)))
(assert (forall ((|#$T0@@48| T@U) (|#$T1@@32| T@U) (|#$T2@@13| T@U) (|#$T3@@13| T@U) (|#$R@@61| T@U) (|f#0@@11| T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@48|) TyType) (= (type |#$T1@@32|) TyType)) (= (type |#$T2@@13|) TyType)) (= (type |#$T3@@13|) TyType)) (= (type |#$R@@61|) TyType)) (= (type |f#0@@11|) HandleTypeType)) (= ($Is |f#0@@11| (Tclass._System.___hPartialFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|))  (and ($Is |f#0@@11| (Tclass._System.___hFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|)) (forall ((|x0#0@@3| T@U) (|x1#0@@1| T@U) (|x2#0| T@U) (|x3#0| T@U) ) (!  (=> (and (and (and (and (= (type |x0#0@@3|) BoxType) (= (type |x1#0@@1|) BoxType)) (= (type |x2#0|) BoxType)) (= (type |x3#0|) BoxType)) (and (and (and ($IsBox |x0#0@@3| |#$T0@@48|) ($IsBox |x1#0@@1| |#$T1@@32|)) ($IsBox |x2#0| |#$T2@@13|)) ($IsBox |x3#0| |#$T3@@13|))) (|Set#Equal| (Reads4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61| $OneHeap |f#0@@11| |x0#0@@3| |x1#0@@1| |x2#0| |x3#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |920|
 :no-pattern (type |x0#0@@3|)
 :no-pattern (type |x1#0@@1|)
 :no-pattern (type |x2#0|)
 :no-pattern (type |x3#0|)
 :no-pattern (U_2_int |x0#0@@3|)
 :no-pattern (U_2_bool |x0#0@@3|)
 :no-pattern (U_2_int |x1#0@@1|)
 :no-pattern (U_2_bool |x1#0@@1|)
 :no-pattern (U_2_int |x2#0|)
 :no-pattern (U_2_bool |x2#0|)
 :no-pattern (U_2_int |x3#0|)
 :no-pattern (U_2_bool |x3#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |921|
 :pattern ( ($Is |f#0@@11| (Tclass._System.___hPartialFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|)))
)))
(assert (forall ((|#$T0@@49| T@U) (|#$T1@@33| T@U) (|#$T2@@14| T@U) (|#$T3@@14| T@U) (|#$R@@62| T@U) (|f#0@@12| T@U) ($h@@17 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@49|) TyType) (= (type |#$T1@@33|) TyType)) (= (type |#$T2@@14|) TyType)) (= (type |#$T3@@14|) TyType)) (= (type |#$R@@62|) TyType)) (= (type |f#0@@12|) HandleTypeType)) (= (type $h@@17) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@12| (Tclass._System.___hPartialFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17) ($IsAlloc |f#0@@12| (Tclass._System.___hFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17)))
 :qid |unknown.0:0|
 :skolemid |922|
 :pattern ( ($IsAlloc |f#0@@12| (Tclass._System.___hPartialFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17))
)))
(assert (forall ((arg0@@194 T@U) (arg1@@94 T@U) (arg2@@46 T@U) (arg3@@25 T@U) (arg4@@17 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4 arg0@@194 arg1@@94 arg2@@46 arg3@@25 arg4@@17)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4|
 :pattern ( (Tclass._System.___hTotalFunc4 arg0@@194 arg1@@94 arg2@@46 arg3@@25 arg4@@17))
)))
(assert (forall ((|#$T0@@50| T@U) (|#$T1@@34| T@U) (|#$T2@@15| T@U) (|#$T3@@15| T@U) (|#$R@@63| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@50|) TyType) (= (type |#$T1@@34|) TyType)) (= (type |#$T2@@15|) TyType)) (= (type |#$T3@@15|) TyType)) (= (type |#$R@@63|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|)) Tagclass._System.___hTotalFunc4) (= (TagFamily (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|)) |tytagFamily$_#TotalFunc4|)))
 :qid |unknown.0:0|
 :skolemid |923|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|))
)))
(assert (forall ((arg0@@195 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_0 arg0@@195)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_0|
 :pattern ( (Tclass._System.___hTotalFunc4_0 arg0@@195))
)))
(assert (forall ((|#$T0@@51| T@U) (|#$T1@@35| T@U) (|#$T2@@16| T@U) (|#$T3@@16| T@U) (|#$R@@64| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@51|) TyType) (= (type |#$T1@@35|) TyType)) (= (type |#$T2@@16|) TyType)) (= (type |#$T3@@16|) TyType)) (= (type |#$R@@64|) TyType)) (= (Tclass._System.___hTotalFunc4_0 (Tclass._System.___hTotalFunc4 |#$T0@@51| |#$T1@@35| |#$T2@@16| |#$T3@@16| |#$R@@64|)) |#$T0@@51|))
 :qid |unknown.0:0|
 :skolemid |924|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@51| |#$T1@@35| |#$T2@@16| |#$T3@@16| |#$R@@64|))
)))
(assert (forall ((arg0@@196 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_1 arg0@@196)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_1|
 :pattern ( (Tclass._System.___hTotalFunc4_1 arg0@@196))
)))
(assert (forall ((|#$T0@@52| T@U) (|#$T1@@36| T@U) (|#$T2@@17| T@U) (|#$T3@@17| T@U) (|#$R@@65| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@52|) TyType) (= (type |#$T1@@36|) TyType)) (= (type |#$T2@@17|) TyType)) (= (type |#$T3@@17|) TyType)) (= (type |#$R@@65|) TyType)) (= (Tclass._System.___hTotalFunc4_1 (Tclass._System.___hTotalFunc4 |#$T0@@52| |#$T1@@36| |#$T2@@17| |#$T3@@17| |#$R@@65|)) |#$T1@@36|))
 :qid |unknown.0:0|
 :skolemid |925|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@52| |#$T1@@36| |#$T2@@17| |#$T3@@17| |#$R@@65|))
)))
(assert (forall ((arg0@@197 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_2 arg0@@197)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_2|
 :pattern ( (Tclass._System.___hTotalFunc4_2 arg0@@197))
)))
(assert (forall ((|#$T0@@53| T@U) (|#$T1@@37| T@U) (|#$T2@@18| T@U) (|#$T3@@18| T@U) (|#$R@@66| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@53|) TyType) (= (type |#$T1@@37|) TyType)) (= (type |#$T2@@18|) TyType)) (= (type |#$T3@@18|) TyType)) (= (type |#$R@@66|) TyType)) (= (Tclass._System.___hTotalFunc4_2 (Tclass._System.___hTotalFunc4 |#$T0@@53| |#$T1@@37| |#$T2@@18| |#$T3@@18| |#$R@@66|)) |#$T2@@18|))
 :qid |unknown.0:0|
 :skolemid |926|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@53| |#$T1@@37| |#$T2@@18| |#$T3@@18| |#$R@@66|))
)))
(assert (forall ((arg0@@198 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_3 arg0@@198)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_3|
 :pattern ( (Tclass._System.___hTotalFunc4_3 arg0@@198))
)))
(assert (forall ((|#$T0@@54| T@U) (|#$T1@@38| T@U) (|#$T2@@19| T@U) (|#$T3@@19| T@U) (|#$R@@67| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@54|) TyType) (= (type |#$T1@@38|) TyType)) (= (type |#$T2@@19|) TyType)) (= (type |#$T3@@19|) TyType)) (= (type |#$R@@67|) TyType)) (= (Tclass._System.___hTotalFunc4_3 (Tclass._System.___hTotalFunc4 |#$T0@@54| |#$T1@@38| |#$T2@@19| |#$T3@@19| |#$R@@67|)) |#$T3@@19|))
 :qid |unknown.0:0|
 :skolemid |927|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@54| |#$T1@@38| |#$T2@@19| |#$T3@@19| |#$R@@67|))
)))
(assert (forall ((arg0@@199 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_4 arg0@@199)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_4|
 :pattern ( (Tclass._System.___hTotalFunc4_4 arg0@@199))
)))
(assert (forall ((|#$T0@@55| T@U) (|#$T1@@39| T@U) (|#$T2@@20| T@U) (|#$T3@@20| T@U) (|#$R@@68| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@55|) TyType) (= (type |#$T1@@39|) TyType)) (= (type |#$T2@@20|) TyType)) (= (type |#$T3@@20|) TyType)) (= (type |#$R@@68|) TyType)) (= (Tclass._System.___hTotalFunc4_4 (Tclass._System.___hTotalFunc4 |#$T0@@55| |#$T1@@39| |#$T2@@20| |#$T3@@20| |#$R@@68|)) |#$R@@68|))
 :qid |unknown.0:0|
 :skolemid |928|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@55| |#$T1@@39| |#$T2@@20| |#$T3@@20| |#$R@@68|))
)))
(assert (forall ((|#$T0@@56| T@U) (|#$T1@@40| T@U) (|#$T2@@21| T@U) (|#$T3@@21| T@U) (|#$R@@69| T@U) (bx@@59 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@56|) TyType) (= (type |#$T1@@40|) TyType)) (= (type |#$T2@@21|) TyType)) (= (type |#$T3@@21|) TyType)) (= (type |#$R@@69|) TyType)) (= (type bx@@59) BoxType)) ($IsBox bx@@59 (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|))) (and (= ($Box ($Unbox HandleTypeType bx@@59)) bx@@59) ($Is ($Unbox HandleTypeType bx@@59) (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|))))
 :qid |unknown.0:0|
 :skolemid |929|
 :pattern ( ($IsBox bx@@59 (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|)))
)))
(assert (forall ((|#$T0@@57| T@U) (|#$T1@@41| T@U) (|#$T2@@22| T@U) (|#$T3@@22| T@U) (|#$R@@70| T@U) (|f#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@57|) TyType) (= (type |#$T1@@41|) TyType)) (= (type |#$T2@@22|) TyType)) (= (type |#$T3@@22|) TyType)) (= (type |#$R@@70|) TyType)) (= (type |f#0@@13|) HandleTypeType)) (= ($Is |f#0@@13| (Tclass._System.___hTotalFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|))  (and ($Is |f#0@@13| (Tclass._System.___hPartialFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|)) (forall ((|x0#0@@4| T@U) (|x1#0@@2| T@U) (|x2#0@@0| T@U) (|x3#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |x0#0@@4|) BoxType) (= (type |x1#0@@2|) BoxType)) (= (type |x2#0@@0|) BoxType)) (= (type |x3#0@@0|) BoxType)) (and (and (and ($IsBox |x0#0@@4| |#$T0@@57|) ($IsBox |x1#0@@2| |#$T1@@41|)) ($IsBox |x2#0@@0| |#$T2@@22|)) ($IsBox |x3#0@@0| |#$T3@@22|))) (Requires4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70| $OneHeap |f#0@@13| |x0#0@@4| |x1#0@@2| |x2#0@@0| |x3#0@@0|))
 :qid |unknown.0:0|
 :skolemid |930|
 :no-pattern (type |x0#0@@4|)
 :no-pattern (type |x1#0@@2|)
 :no-pattern (type |x2#0@@0|)
 :no-pattern (type |x3#0@@0|)
 :no-pattern (U_2_int |x0#0@@4|)
 :no-pattern (U_2_bool |x0#0@@4|)
 :no-pattern (U_2_int |x1#0@@2|)
 :no-pattern (U_2_bool |x1#0@@2|)
 :no-pattern (U_2_int |x2#0@@0|)
 :no-pattern (U_2_bool |x2#0@@0|)
 :no-pattern (U_2_int |x3#0@@0|)
 :no-pattern (U_2_bool |x3#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |931|
 :pattern ( ($Is |f#0@@13| (Tclass._System.___hTotalFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|)))
)))
(assert (forall ((|#$T0@@58| T@U) (|#$T1@@42| T@U) (|#$T2@@23| T@U) (|#$T3@@23| T@U) (|#$R@@71| T@U) (|f#0@@14| T@U) ($h@@18 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@58|) TyType) (= (type |#$T1@@42|) TyType)) (= (type |#$T2@@23|) TyType)) (= (type |#$T3@@23|) TyType)) (= (type |#$R@@71|) TyType)) (= (type |f#0@@14|) HandleTypeType)) (= (type $h@@18) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@14| (Tclass._System.___hTotalFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18) ($IsAlloc |f#0@@14| (Tclass._System.___hPartialFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18)))
 :qid |unknown.0:0|
 :skolemid |932|
 :pattern ( ($IsAlloc |f#0@@14| (Tclass._System.___hTotalFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18))
)))
(assert (forall ((arg0@@200 T@U) (arg1@@95 T@U) (arg2@@47 T@U) (arg3@@26 T@U) ) (! (= (type (Tclass._System.___hFunc3 arg0@@200 arg1@@95 arg2@@47 arg3@@26)) TyType)
 :qid |funType:Tclass._System.___hFunc3|
 :pattern ( (Tclass._System.___hFunc3 arg0@@200 arg1@@95 arg2@@47 arg3@@26))
)))
(assert (forall ((|#$T0@@59| T@U) (|#$T1@@43| T@U) (|#$T2@@24| T@U) (|#$R@@72| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@59|) TyType) (= (type |#$T1@@43|) TyType)) (= (type |#$T2@@24|) TyType)) (= (type |#$R@@72|) TyType)) (and (= (Tag (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|)) Tagclass._System.___hFunc3) (= (TagFamily (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|)) |tytagFamily$_#Func3|)))
 :qid |unknown.0:0|
 :skolemid |933|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|))
)))
(assert (forall ((arg0@@201 T@U) ) (! (= (type (Tclass._System.___hFunc3_0 arg0@@201)) TyType)
 :qid |funType:Tclass._System.___hFunc3_0|
 :pattern ( (Tclass._System.___hFunc3_0 arg0@@201))
)))
(assert (forall ((|#$T0@@60| T@U) (|#$T1@@44| T@U) (|#$T2@@25| T@U) (|#$R@@73| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@60|) TyType) (= (type |#$T1@@44|) TyType)) (= (type |#$T2@@25|) TyType)) (= (type |#$R@@73|) TyType)) (= (Tclass._System.___hFunc3_0 (Tclass._System.___hFunc3 |#$T0@@60| |#$T1@@44| |#$T2@@25| |#$R@@73|)) |#$T0@@60|))
 :qid |unknown.0:0|
 :skolemid |934|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@60| |#$T1@@44| |#$T2@@25| |#$R@@73|))
)))
(assert (forall ((arg0@@202 T@U) ) (! (= (type (Tclass._System.___hFunc3_1 arg0@@202)) TyType)
 :qid |funType:Tclass._System.___hFunc3_1|
 :pattern ( (Tclass._System.___hFunc3_1 arg0@@202))
)))
(assert (forall ((|#$T0@@61| T@U) (|#$T1@@45| T@U) (|#$T2@@26| T@U) (|#$R@@74| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@61|) TyType) (= (type |#$T1@@45|) TyType)) (= (type |#$T2@@26|) TyType)) (= (type |#$R@@74|) TyType)) (= (Tclass._System.___hFunc3_1 (Tclass._System.___hFunc3 |#$T0@@61| |#$T1@@45| |#$T2@@26| |#$R@@74|)) |#$T1@@45|))
 :qid |unknown.0:0|
 :skolemid |935|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@61| |#$T1@@45| |#$T2@@26| |#$R@@74|))
)))
(assert (forall ((arg0@@203 T@U) ) (! (= (type (Tclass._System.___hFunc3_2 arg0@@203)) TyType)
 :qid |funType:Tclass._System.___hFunc3_2|
 :pattern ( (Tclass._System.___hFunc3_2 arg0@@203))
)))
(assert (forall ((|#$T0@@62| T@U) (|#$T1@@46| T@U) (|#$T2@@27| T@U) (|#$R@@75| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@62|) TyType) (= (type |#$T1@@46|) TyType)) (= (type |#$T2@@27|) TyType)) (= (type |#$R@@75|) TyType)) (= (Tclass._System.___hFunc3_2 (Tclass._System.___hFunc3 |#$T0@@62| |#$T1@@46| |#$T2@@27| |#$R@@75|)) |#$T2@@27|))
 :qid |unknown.0:0|
 :skolemid |936|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@62| |#$T1@@46| |#$T2@@27| |#$R@@75|))
)))
(assert (forall ((arg0@@204 T@U) ) (! (= (type (Tclass._System.___hFunc3_3 arg0@@204)) TyType)
 :qid |funType:Tclass._System.___hFunc3_3|
 :pattern ( (Tclass._System.___hFunc3_3 arg0@@204))
)))
(assert (forall ((|#$T0@@63| T@U) (|#$T1@@47| T@U) (|#$T2@@28| T@U) (|#$R@@76| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@63|) TyType) (= (type |#$T1@@47|) TyType)) (= (type |#$T2@@28|) TyType)) (= (type |#$R@@76|) TyType)) (= (Tclass._System.___hFunc3_3 (Tclass._System.___hFunc3 |#$T0@@63| |#$T1@@47| |#$T2@@28| |#$R@@76|)) |#$R@@76|))
 :qid |unknown.0:0|
 :skolemid |937|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@63| |#$T1@@47| |#$T2@@28| |#$R@@76|))
)))
(assert (forall ((|#$T0@@64| T@U) (|#$T1@@48| T@U) (|#$T2@@29| T@U) (|#$R@@77| T@U) (bx@@60 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@64|) TyType) (= (type |#$T1@@48|) TyType)) (= (type |#$T2@@29|) TyType)) (= (type |#$R@@77|) TyType)) (= (type bx@@60) BoxType)) ($IsBox bx@@60 (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|))) (and (= ($Box ($Unbox HandleTypeType bx@@60)) bx@@60) ($Is ($Unbox HandleTypeType bx@@60) (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|))))
 :qid |unknown.0:0|
 :skolemid |938|
 :pattern ( ($IsBox bx@@60 (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@205 T@T) (arg1@@96 T@T) (arg2@@48 T@T) (arg3@@27 T@T) (arg4@@18 T@T) ) (! (= (Ctor (MapType5Type arg0@@205 arg1@@96 arg2@@48 arg3@@27 arg4@@18)) 27)
 :qid |ctor:MapType5Type|
)) (forall ((arg0@@206 T@T) (arg1@@97 T@T) (arg2@@49 T@T) (arg3@@28 T@T) (arg4@@19 T@T) ) (! (= (MapType5TypeInv0 (MapType5Type arg0@@206 arg1@@97 arg2@@49 arg3@@28 arg4@@19)) arg0@@206)
 :qid |typeInv:MapType5TypeInv0|
 :pattern ( (MapType5Type arg0@@206 arg1@@97 arg2@@49 arg3@@28 arg4@@19))
))) (forall ((arg0@@207 T@T) (arg1@@98 T@T) (arg2@@50 T@T) (arg3@@29 T@T) (arg4@@20 T@T) ) (! (= (MapType5TypeInv1 (MapType5Type arg0@@207 arg1@@98 arg2@@50 arg3@@29 arg4@@20)) arg1@@98)
 :qid |typeInv:MapType5TypeInv1|
 :pattern ( (MapType5Type arg0@@207 arg1@@98 arg2@@50 arg3@@29 arg4@@20))
))) (forall ((arg0@@208 T@T) (arg1@@99 T@T) (arg2@@51 T@T) (arg3@@30 T@T) (arg4@@21 T@T) ) (! (= (MapType5TypeInv2 (MapType5Type arg0@@208 arg1@@99 arg2@@51 arg3@@30 arg4@@21)) arg2@@51)
 :qid |typeInv:MapType5TypeInv2|
 :pattern ( (MapType5Type arg0@@208 arg1@@99 arg2@@51 arg3@@30 arg4@@21))
))) (forall ((arg0@@209 T@T) (arg1@@100 T@T) (arg2@@52 T@T) (arg3@@31 T@T) (arg4@@22 T@T) ) (! (= (MapType5TypeInv3 (MapType5Type arg0@@209 arg1@@100 arg2@@52 arg3@@31 arg4@@22)) arg3@@31)
 :qid |typeInv:MapType5TypeInv3|
 :pattern ( (MapType5Type arg0@@209 arg1@@100 arg2@@52 arg3@@31 arg4@@22))
))) (forall ((arg0@@210 T@T) (arg1@@101 T@T) (arg2@@53 T@T) (arg3@@32 T@T) (arg4@@23 T@T) ) (! (= (MapType5TypeInv4 (MapType5Type arg0@@210 arg1@@101 arg2@@53 arg3@@32 arg4@@23)) arg4@@23)
 :qid |typeInv:MapType5TypeInv4|
 :pattern ( (MapType5Type arg0@@210 arg1@@101 arg2@@53 arg3@@32 arg4@@23))
))) (forall ((arg0@@211 T@U) (arg1@@102 T@U) (arg2@@54 T@U) (arg3@@33 T@U) (arg4@@24 T@U) ) (! (let ((aVar4@@0 (MapType5TypeInv4 (type arg0@@211))))
(= (type (MapType5Select arg0@@211 arg1@@102 arg2@@54 arg3@@33 arg4@@24)) aVar4@@0))
 :qid |funType:MapType5Select|
 :pattern ( (MapType5Select arg0@@211 arg1@@102 arg2@@54 arg3@@33 arg4@@24))
))) (forall ((arg0@@212 T@U) (arg1@@103 T@U) (arg2@@55 T@U) (arg3@@34 T@U) (arg4@@25 T@U) (arg5@@12 T@U) ) (! (let ((aVar4@@1 (type arg5@@12)))
(let ((aVar3@@3 (type arg4@@25)))
(let ((aVar2@@4 (type arg3@@34)))
(let ((aVar1@@5 (type arg2@@55)))
(let ((aVar0@@3 (type arg1@@103)))
(= (type (MapType5Store arg0@@212 arg1@@103 arg2@@55 arg3@@34 arg4@@25 arg5@@12)) (MapType5Type aVar0@@3 aVar1@@5 aVar2@@4 aVar3@@3 aVar4@@1)))))))
 :qid |funType:MapType5Store|
 :pattern ( (MapType5Store arg0@@212 arg1@@103 arg2@@55 arg3@@34 arg4@@25 arg5@@12))
))) (forall ((m@@61 T@U) (x0@@21 T@U) (x1@@15 T@U) (x2@@11 T@U) (x3@@6 T@U) (val@@22 T@U) ) (! (let ((aVar4@@2 (MapType5TypeInv4 (type m@@61))))
 (=> (= (type val@@22) aVar4@@2) (= (MapType5Select (MapType5Store m@@61 x0@@21 x1@@15 x2@@11 x3@@6 val@@22) x0@@21 x1@@15 x2@@11 x3@@6) val@@22)))
 :qid |mapAx0:MapType5Select|
 :weight 0
))) (and (and (and (and (forall ((val@@23 T@U) (m@@62 T@U) (x0@@22 T@U) (x1@@16 T@U) (x2@@12 T@U) (x3@@7 T@U) (y0@@16 T@U) (y1@@12 T@U) (y2@@9 T@U) (y3@@5 T@U) ) (!  (or (= x0@@22 y0@@16) (= (MapType5Select (MapType5Store m@@62 x0@@22 x1@@16 x2@@12 x3@@7 val@@23) y0@@16 y1@@12 y2@@9 y3@@5) (MapType5Select m@@62 y0@@16 y1@@12 y2@@9 y3@@5)))
 :qid |mapAx1:MapType5Select:0|
 :weight 0
)) (forall ((val@@24 T@U) (m@@63 T@U) (x0@@23 T@U) (x1@@17 T@U) (x2@@13 T@U) (x3@@8 T@U) (y0@@17 T@U) (y1@@13 T@U) (y2@@10 T@U) (y3@@6 T@U) ) (!  (or (= x1@@17 y1@@13) (= (MapType5Select (MapType5Store m@@63 x0@@23 x1@@17 x2@@13 x3@@8 val@@24) y0@@17 y1@@13 y2@@10 y3@@6) (MapType5Select m@@63 y0@@17 y1@@13 y2@@10 y3@@6)))
 :qid |mapAx1:MapType5Select:1|
 :weight 0
))) (forall ((val@@25 T@U) (m@@64 T@U) (x0@@24 T@U) (x1@@18 T@U) (x2@@14 T@U) (x3@@9 T@U) (y0@@18 T@U) (y1@@14 T@U) (y2@@11 T@U) (y3@@7 T@U) ) (!  (or (= x2@@14 y2@@11) (= (MapType5Select (MapType5Store m@@64 x0@@24 x1@@18 x2@@14 x3@@9 val@@25) y0@@18 y1@@14 y2@@11 y3@@7) (MapType5Select m@@64 y0@@18 y1@@14 y2@@11 y3@@7)))
 :qid |mapAx1:MapType5Select:2|
 :weight 0
))) (forall ((val@@26 T@U) (m@@65 T@U) (x0@@25 T@U) (x1@@19 T@U) (x2@@15 T@U) (x3@@10 T@U) (y0@@19 T@U) (y1@@15 T@U) (y2@@12 T@U) (y3@@8 T@U) ) (!  (or (= x3@@10 y3@@8) (= (MapType5Select (MapType5Store m@@65 x0@@25 x1@@19 x2@@15 x3@@10 val@@26) y0@@19 y1@@15 y2@@12 y3@@8) (MapType5Select m@@65 y0@@19 y1@@15 y2@@12 y3@@8)))
 :qid |mapAx1:MapType5Select:3|
 :weight 0
))) (forall ((val@@27 T@U) (m@@66 T@U) (x0@@26 T@U) (x1@@20 T@U) (x2@@16 T@U) (x3@@11 T@U) (y0@@20 T@U) (y1@@16 T@U) (y2@@13 T@U) (y3@@9 T@U) ) (!  (or true (= (MapType5Select (MapType5Store m@@66 x0@@26 x1@@20 x2@@16 x3@@11 val@@27) y0@@20 y1@@16 y2@@13 y3@@9) (MapType5Select m@@66 y0@@20 y1@@16 y2@@13 y3@@9)))
 :qid |mapAx2:MapType5Select|
 :weight 0
)))) (forall ((arg0@@213 T@U) (arg1@@104 T@U) (arg2@@56 T@U) (arg3@@35 T@U) (arg4@@26 T@U) (arg5@@13 T@U) (arg6@@4 T@U) (arg7@@1 T@U) (arg8@@1 T@U) ) (! (= (type (Apply3 arg0@@213 arg1@@104 arg2@@56 arg3@@35 arg4@@26 arg5@@13 arg6@@4 arg7@@1 arg8@@1)) BoxType)
 :qid |funType:Apply3|
 :pattern ( (Apply3 arg0@@213 arg1@@104 arg2@@56 arg3@@35 arg4@@26 arg5@@13 arg6@@4 arg7@@1 arg8@@1))
))) (forall ((arg0@@214 T@U) (arg1@@105 T@U) (arg2@@57 T@U) ) (! (= (type (Handle3 arg0@@214 arg1@@105 arg2@@57)) HandleTypeType)
 :qid |funType:Handle3|
 :pattern ( (Handle3 arg0@@214 arg1@@105 arg2@@57))
))))
(assert (forall ((t0@@76 T@U) (t1@@52 T@U) (t2@@29 T@U) (t3@@14 T@U) (heap@@21 T@U) (h@@45 T@U) (r@@22 T@U) (rd@@11 T@U) (bx0@@41 T@U) (bx1@@27 T@U) (bx2@@13 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@76) TyType) (= (type t1@@52) TyType)) (= (type t2@@29) TyType)) (= (type t3@@14) TyType)) (= (type heap@@21) (MapType0Type refType MapType1Type))) (= (type h@@45) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@22) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@11) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@41) BoxType)) (= (type bx1@@27) BoxType)) (= (type bx2@@13) BoxType)) (= (Apply3 t0@@76 t1@@52 t2@@29 t3@@14 heap@@21 (Handle3 h@@45 r@@22 rd@@11) bx0@@41 bx1@@27 bx2@@13) (MapType5Select h@@45 heap@@21 bx0@@41 bx1@@27 bx2@@13)))
 :qid |unknown.0:0|
 :skolemid |939|
 :pattern ( (Apply3 t0@@76 t1@@52 t2@@29 t3@@14 heap@@21 (Handle3 h@@45 r@@22 rd@@11) bx0@@41 bx1@@27 bx2@@13))
)))
(assert (forall ((t0@@77 T@U) (t1@@53 T@U) (t2@@30 T@U) (t3@@15 T@U) (heap@@22 T@U) (h@@46 T@U) (r@@23 T@U) (rd@@12 T@U) (bx0@@42 T@U) (bx1@@28 T@U) (bx2@@14 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@77) TyType) (= (type t1@@53) TyType)) (= (type t2@@30) TyType)) (= (type t3@@15) TyType)) (= (type heap@@22) (MapType0Type refType MapType1Type))) (= (type h@@46) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@23) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@12) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@42) BoxType)) (= (type bx1@@28) BoxType)) (= (type bx2@@14) BoxType)) (U_2_bool (MapType5Select r@@23 heap@@22 bx0@@42 bx1@@28 bx2@@14))) (Requires3 t0@@77 t1@@53 t2@@30 t3@@15 heap@@22 (Handle3 h@@46 r@@23 rd@@12) bx0@@42 bx1@@28 bx2@@14))
 :qid |unknown.0:0|
 :skolemid |940|
 :pattern ( (Requires3 t0@@77 t1@@53 t2@@30 t3@@15 heap@@22 (Handle3 h@@46 r@@23 rd@@12) bx0@@42 bx1@@28 bx2@@14))
)))
(assert (forall ((arg0@@215 T@U) (arg1@@106 T@U) (arg2@@58 T@U) (arg3@@36 T@U) (arg4@@27 T@U) (arg5@@14 T@U) (arg6@@5 T@U) (arg7@@2 T@U) (arg8@@2 T@U) ) (! (= (type (Reads3 arg0@@215 arg1@@106 arg2@@58 arg3@@36 arg4@@27 arg5@@14 arg6@@5 arg7@@2 arg8@@2)) (MapType0Type BoxType boolType))
 :qid |funType:Reads3|
 :pattern ( (Reads3 arg0@@215 arg1@@106 arg2@@58 arg3@@36 arg4@@27 arg5@@14 arg6@@5 arg7@@2 arg8@@2))
)))
(assert (forall ((t0@@78 T@U) (t1@@54 T@U) (t2@@31 T@U) (t3@@16 T@U) (heap@@23 T@U) (h@@47 T@U) (r@@24 T@U) (rd@@13 T@U) (bx0@@43 T@U) (bx1@@29 T@U) (bx2@@15 T@U) (bx@@61 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@78) TyType) (= (type t1@@54) TyType)) (= (type t2@@31) TyType)) (= (type t3@@16) TyType)) (= (type heap@@23) (MapType0Type refType MapType1Type))) (= (type h@@47) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@24) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@13) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@43) BoxType)) (= (type bx1@@29) BoxType)) (= (type bx2@@15) BoxType)) (= (type bx@@61) BoxType)) (= (U_2_bool (MapType0Select (Reads3 t0@@78 t1@@54 t2@@31 t3@@16 heap@@23 (Handle3 h@@47 r@@24 rd@@13) bx0@@43 bx1@@29 bx2@@15) bx@@61)) (U_2_bool (MapType0Select (MapType5Select rd@@13 heap@@23 bx0@@43 bx1@@29 bx2@@15) bx@@61))))
 :qid |unknown.0:0|
 :skolemid |941|
 :pattern ( (MapType0Select (Reads3 t0@@78 t1@@54 t2@@31 t3@@16 heap@@23 (Handle3 h@@47 r@@24 rd@@13) bx0@@43 bx1@@29 bx2@@15) bx@@61))
)))
(assert (forall ((t0@@79 T@U) (t1@@55 T@U) (t2@@32 T@U) (t3@@17 T@U) (h0@@24 T@U) (h1@@24 T@U) (f@@53 T@U) (bx0@@44 T@U) (bx1@@30 T@U) (bx2@@16 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@79) TyType) (= (type t1@@55) TyType)) (= (type t2@@32) TyType)) (= (type t3@@17) TyType)) (= (type h0@@24) (MapType0Type refType MapType1Type))) (= (type h1@@24) (MapType0Type refType MapType1Type))) (= (type f@@53) HandleTypeType)) (= (type bx0@@44) BoxType)) (= (type bx1@@30) BoxType)) (= (type bx2@@16) BoxType)) (and (and (and ($HeapSucc h0@@24 h1@@24) (and ($IsGoodHeap h0@@24) ($IsGoodHeap h1@@24))) (and (and (and ($IsBox bx0@@44 t0@@79) ($IsBox bx1@@30 t1@@55)) ($IsBox bx2@@16 t2@@32)) ($Is f@@53 (Tclass._System.___hFunc3 t0@@79 t1@@55 t2@@32 t3@@17)))) (forall ((o@@68 T@U) (fld@@23 T@U) ) (! (let ((a@@108 (FieldTypeInv0 (type fld@@23))))
 (=> (and (and (= (type o@@68) refType) (= (type fld@@23) (FieldType a@@108))) (and (not (= o@@68 null)) (U_2_bool (MapType0Select (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h0@@24 f@@53 bx0@@44 bx1@@30 bx2@@16) ($Box o@@68))))) (= (MapType1Select (MapType0Select h0@@24 o@@68) fld@@23) (MapType1Select (MapType0Select h1@@24 o@@68) fld@@23))))
 :qid |unknown.0:0|
 :skolemid |942|
 :no-pattern (type o@@68)
 :no-pattern (type fld@@23)
 :no-pattern (U_2_int o@@68)
 :no-pattern (U_2_bool o@@68)
 :no-pattern (U_2_int fld@@23)
 :no-pattern (U_2_bool fld@@23)
)))) (= (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h0@@24 f@@53 bx0@@44 bx1@@30 bx2@@16) (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h1@@24 f@@53 bx0@@44 bx1@@30 bx2@@16)))
 :qid |unknown.0:0|
 :skolemid |943|
 :pattern ( ($HeapSucc h0@@24 h1@@24) (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h1@@24 f@@53 bx0@@44 bx1@@30 bx2@@16))
)))
(assert (forall ((t0@@80 T@U) (t1@@56 T@U) (t2@@33 T@U) (t3@@18 T@U) (h0@@25 T@U) (h1@@25 T@U) (f@@54 T@U) (bx0@@45 T@U) (bx1@@31 T@U) (bx2@@17 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@80) TyType) (= (type t1@@56) TyType)) (= (type t2@@33) TyType)) (= (type t3@@18) TyType)) (= (type h0@@25) (MapType0Type refType MapType1Type))) (= (type h1@@25) (MapType0Type refType MapType1Type))) (= (type f@@54) HandleTypeType)) (= (type bx0@@45) BoxType)) (= (type bx1@@31) BoxType)) (= (type bx2@@17) BoxType)) (and (and (and ($HeapSucc h0@@25 h1@@25) (and ($IsGoodHeap h0@@25) ($IsGoodHeap h1@@25))) (and (and (and ($IsBox bx0@@45 t0@@80) ($IsBox bx1@@31 t1@@56)) ($IsBox bx2@@17 t2@@33)) ($Is f@@54 (Tclass._System.___hFunc3 t0@@80 t1@@56 t2@@33 t3@@18)))) (forall ((o@@69 T@U) (fld@@24 T@U) ) (! (let ((a@@109 (FieldTypeInv0 (type fld@@24))))
 (=> (and (and (= (type o@@69) refType) (= (type fld@@24) (FieldType a@@109))) (and (not (= o@@69 null)) (U_2_bool (MapType0Select (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17) ($Box o@@69))))) (= (MapType1Select (MapType0Select h0@@25 o@@69) fld@@24) (MapType1Select (MapType0Select h1@@25 o@@69) fld@@24))))
 :qid |unknown.0:0|
 :skolemid |944|
 :no-pattern (type o@@69)
 :no-pattern (type fld@@24)
 :no-pattern (U_2_int o@@69)
 :no-pattern (U_2_bool o@@69)
 :no-pattern (U_2_int fld@@24)
 :no-pattern (U_2_bool fld@@24)
)))) (= (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h0@@25 f@@54 bx0@@45 bx1@@31 bx2@@17) (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17)))
 :qid |unknown.0:0|
 :skolemid |945|
 :pattern ( ($HeapSucc h0@@25 h1@@25) (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17))
)))
(assert (forall ((t0@@81 T@U) (t1@@57 T@U) (t2@@34 T@U) (t3@@19 T@U) (h0@@26 T@U) (h1@@26 T@U) (f@@55 T@U) (bx0@@46 T@U) (bx1@@32 T@U) (bx2@@18 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@81) TyType) (= (type t1@@57) TyType)) (= (type t2@@34) TyType)) (= (type t3@@19) TyType)) (= (type h0@@26) (MapType0Type refType MapType1Type))) (= (type h1@@26) (MapType0Type refType MapType1Type))) (= (type f@@55) HandleTypeType)) (= (type bx0@@46) BoxType)) (= (type bx1@@32) BoxType)) (= (type bx2@@18) BoxType)) (and (and (and ($HeapSucc h0@@26 h1@@26) (and ($IsGoodHeap h0@@26) ($IsGoodHeap h1@@26))) (and (and (and ($IsBox bx0@@46 t0@@81) ($IsBox bx1@@32 t1@@57)) ($IsBox bx2@@18 t2@@34)) ($Is f@@55 (Tclass._System.___hFunc3 t0@@81 t1@@57 t2@@34 t3@@19)))) (forall ((o@@70 T@U) (fld@@25 T@U) ) (! (let ((a@@110 (FieldTypeInv0 (type fld@@25))))
 (=> (and (and (= (type o@@70) refType) (= (type fld@@25) (FieldType a@@110))) (and (not (= o@@70 null)) (U_2_bool (MapType0Select (Reads3 t0@@81 t1@@57 t2@@34 t3@@19 h0@@26 f@@55 bx0@@46 bx1@@32 bx2@@18) ($Box o@@70))))) (= (MapType1Select (MapType0Select h0@@26 o@@70) fld@@25) (MapType1Select (MapType0Select h1@@26 o@@70) fld@@25))))
 :qid |unknown.0:0|
 :skolemid |946|
 :no-pattern (type o@@70)
 :no-pattern (type fld@@25)
 :no-pattern (U_2_int o@@70)
 :no-pattern (U_2_bool o@@70)
 :no-pattern (U_2_int fld@@25)
 :no-pattern (U_2_bool fld@@25)
)))) (= (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h0@@26 f@@55 bx0@@46 bx1@@32 bx2@@18) (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h1@@26 f@@55 bx0@@46 bx1@@32 bx2@@18)))
 :qid |unknown.0:0|
 :skolemid |947|
 :pattern ( ($HeapSucc h0@@26 h1@@26) (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h1@@26 f@@55 bx0@@46 bx1@@32 bx2@@18))
)))
(assert (forall ((t0@@82 T@U) (t1@@58 T@U) (t2@@35 T@U) (t3@@20 T@U) (h0@@27 T@U) (h1@@27 T@U) (f@@56 T@U) (bx0@@47 T@U) (bx1@@33 T@U) (bx2@@19 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@82) TyType) (= (type t1@@58) TyType)) (= (type t2@@35) TyType)) (= (type t3@@20) TyType)) (= (type h0@@27) (MapType0Type refType MapType1Type))) (= (type h1@@27) (MapType0Type refType MapType1Type))) (= (type f@@56) HandleTypeType)) (= (type bx0@@47) BoxType)) (= (type bx1@@33) BoxType)) (= (type bx2@@19) BoxType)) (and (and (and ($HeapSucc h0@@27 h1@@27) (and ($IsGoodHeap h0@@27) ($IsGoodHeap h1@@27))) (and (and (and ($IsBox bx0@@47 t0@@82) ($IsBox bx1@@33 t1@@58)) ($IsBox bx2@@19 t2@@35)) ($Is f@@56 (Tclass._System.___hFunc3 t0@@82 t1@@58 t2@@35 t3@@20)))) (forall ((o@@71 T@U) (fld@@26 T@U) ) (! (let ((a@@111 (FieldTypeInv0 (type fld@@26))))
 (=> (and (and (= (type o@@71) refType) (= (type fld@@26) (FieldType a@@111))) (and (not (= o@@71 null)) (U_2_bool (MapType0Select (Reads3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19) ($Box o@@71))))) (= (MapType1Select (MapType0Select h0@@27 o@@71) fld@@26) (MapType1Select (MapType0Select h1@@27 o@@71) fld@@26))))
 :qid |unknown.0:0|
 :skolemid |948|
 :no-pattern (type o@@71)
 :no-pattern (type fld@@26)
 :no-pattern (U_2_int o@@71)
 :no-pattern (U_2_bool o@@71)
 :no-pattern (U_2_int fld@@26)
 :no-pattern (U_2_bool fld@@26)
)))) (= (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h0@@27 f@@56 bx0@@47 bx1@@33 bx2@@19) (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19)))
 :qid |unknown.0:0|
 :skolemid |949|
 :pattern ( ($HeapSucc h0@@27 h1@@27) (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19))
)))
(assert (forall ((t0@@83 T@U) (t1@@59 T@U) (t2@@36 T@U) (t3@@21 T@U) (h0@@28 T@U) (h1@@28 T@U) (f@@57 T@U) (bx0@@48 T@U) (bx1@@34 T@U) (bx2@@20 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@83) TyType) (= (type t1@@59) TyType)) (= (type t2@@36) TyType)) (= (type t3@@21) TyType)) (= (type h0@@28) (MapType0Type refType MapType1Type))) (= (type h1@@28) (MapType0Type refType MapType1Type))) (= (type f@@57) HandleTypeType)) (= (type bx0@@48) BoxType)) (= (type bx1@@34) BoxType)) (= (type bx2@@20) BoxType)) (and (and (and ($HeapSucc h0@@28 h1@@28) (and ($IsGoodHeap h0@@28) ($IsGoodHeap h1@@28))) (and (and (and ($IsBox bx0@@48 t0@@83) ($IsBox bx1@@34 t1@@59)) ($IsBox bx2@@20 t2@@36)) ($Is f@@57 (Tclass._System.___hFunc3 t0@@83 t1@@59 t2@@36 t3@@21)))) (forall ((o@@72 T@U) (fld@@27 T@U) ) (! (let ((a@@112 (FieldTypeInv0 (type fld@@27))))
 (=> (and (and (= (type o@@72) refType) (= (type fld@@27) (FieldType a@@112))) (and (not (= o@@72 null)) (U_2_bool (MapType0Select (Reads3 t0@@83 t1@@59 t2@@36 t3@@21 h0@@28 f@@57 bx0@@48 bx1@@34 bx2@@20) ($Box o@@72))))) (= (MapType1Select (MapType0Select h0@@28 o@@72) fld@@27) (MapType1Select (MapType0Select h1@@28 o@@72) fld@@27))))
 :qid |unknown.0:0|
 :skolemid |950|
 :no-pattern (type o@@72)
 :no-pattern (type fld@@27)
 :no-pattern (U_2_int o@@72)
 :no-pattern (U_2_bool o@@72)
 :no-pattern (U_2_int fld@@27)
 :no-pattern (U_2_bool fld@@27)
)))) (= (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h0@@28 f@@57 bx0@@48 bx1@@34 bx2@@20) (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h1@@28 f@@57 bx0@@48 bx1@@34 bx2@@20)))
 :qid |unknown.0:0|
 :skolemid |951|
 :pattern ( ($HeapSucc h0@@28 h1@@28) (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h1@@28 f@@57 bx0@@48 bx1@@34 bx2@@20))
)))
(assert (forall ((t0@@84 T@U) (t1@@60 T@U) (t2@@37 T@U) (t3@@22 T@U) (h0@@29 T@U) (h1@@29 T@U) (f@@58 T@U) (bx0@@49 T@U) (bx1@@35 T@U) (bx2@@21 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@84) TyType) (= (type t1@@60) TyType)) (= (type t2@@37) TyType)) (= (type t3@@22) TyType)) (= (type h0@@29) (MapType0Type refType MapType1Type))) (= (type h1@@29) (MapType0Type refType MapType1Type))) (= (type f@@58) HandleTypeType)) (= (type bx0@@49) BoxType)) (= (type bx1@@35) BoxType)) (= (type bx2@@21) BoxType)) (and (and (and ($HeapSucc h0@@29 h1@@29) (and ($IsGoodHeap h0@@29) ($IsGoodHeap h1@@29))) (and (and (and ($IsBox bx0@@49 t0@@84) ($IsBox bx1@@35 t1@@60)) ($IsBox bx2@@21 t2@@37)) ($Is f@@58 (Tclass._System.___hFunc3 t0@@84 t1@@60 t2@@37 t3@@22)))) (forall ((o@@73 T@U) (fld@@28 T@U) ) (! (let ((a@@113 (FieldTypeInv0 (type fld@@28))))
 (=> (and (and (= (type o@@73) refType) (= (type fld@@28) (FieldType a@@113))) (and (not (= o@@73 null)) (U_2_bool (MapType0Select (Reads3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21) ($Box o@@73))))) (= (MapType1Select (MapType0Select h0@@29 o@@73) fld@@28) (MapType1Select (MapType0Select h1@@29 o@@73) fld@@28))))
 :qid |unknown.0:0|
 :skolemid |952|
 :no-pattern (type o@@73)
 :no-pattern (type fld@@28)
 :no-pattern (U_2_int o@@73)
 :no-pattern (U_2_bool o@@73)
 :no-pattern (U_2_int fld@@28)
 :no-pattern (U_2_bool fld@@28)
)))) (= (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h0@@29 f@@58 bx0@@49 bx1@@35 bx2@@21) (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21)))
 :qid |unknown.0:0|
 :skolemid |953|
 :pattern ( ($HeapSucc h0@@29 h1@@29) (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21))
)))
(assert (forall ((t0@@85 T@U) (t1@@61 T@U) (t2@@38 T@U) (t3@@23 T@U) (heap@@24 T@U) (f@@59 T@U) (bx0@@50 T@U) (bx1@@36 T@U) (bx2@@22 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@85) TyType) (= (type t1@@61) TyType)) (= (type t2@@38) TyType)) (= (type t3@@23) TyType)) (= (type heap@@24) (MapType0Type refType MapType1Type))) (= (type f@@59) HandleTypeType)) (= (type bx0@@50) BoxType)) (= (type bx1@@36) BoxType)) (= (type bx2@@22) BoxType)) (and ($IsGoodHeap heap@@24) (and (and (and ($IsBox bx0@@50 t0@@85) ($IsBox bx1@@36 t1@@61)) ($IsBox bx2@@22 t2@@38)) ($Is f@@59 (Tclass._System.___hFunc3 t0@@85 t1@@61 t2@@38 t3@@23))))) (= (|Set#Equal| (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 $OneHeap f@@59 bx0@@50 bx1@@36 bx2@@22) (|Set#Empty| BoxType)) (|Set#Equal| (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 heap@@24 f@@59 bx0@@50 bx1@@36 bx2@@22) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |954|
 :pattern ( (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 $OneHeap f@@59 bx0@@50 bx1@@36 bx2@@22) ($IsGoodHeap heap@@24))
 :pattern ( (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 heap@@24 f@@59 bx0@@50 bx1@@36 bx2@@22))
)))
(assert (forall ((t0@@86 T@U) (t1@@62 T@U) (t2@@39 T@U) (t3@@24 T@U) (heap@@25 T@U) (f@@60 T@U) (bx0@@51 T@U) (bx1@@37 T@U) (bx2@@23 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@86) TyType) (= (type t1@@62) TyType)) (= (type t2@@39) TyType)) (= (type t3@@24) TyType)) (= (type heap@@25) (MapType0Type refType MapType1Type))) (= (type f@@60) HandleTypeType)) (= (type bx0@@51) BoxType)) (= (type bx1@@37) BoxType)) (= (type bx2@@23) BoxType)) (and (and ($IsGoodHeap heap@@25) (and (and (and ($IsBox bx0@@51 t0@@86) ($IsBox bx1@@37 t1@@62)) ($IsBox bx2@@23 t2@@39)) ($Is f@@60 (Tclass._System.___hFunc3 t0@@86 t1@@62 t2@@39 t3@@24)))) (|Set#Equal| (Reads3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) (|Set#Empty| BoxType)))) (= (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 heap@@25 f@@60 bx0@@51 bx1@@37 bx2@@23)))
 :qid |unknown.0:0|
 :skolemid |955|
 :pattern ( (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) ($IsGoodHeap heap@@25))
 :pattern ( (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 heap@@25 f@@60 bx0@@51 bx1@@37 bx2@@23))
)))
(assert (forall ((f@@61 T@U) (t0@@87 T@U) (t1@@63 T@U) (t2@@40 T@U) (t3@@25 T@U) ) (!  (=> (and (and (and (and (= (type f@@61) HandleTypeType) (= (type t0@@87) TyType)) (= (type t1@@63) TyType)) (= (type t2@@40) TyType)) (= (type t3@@25) TyType)) (= ($Is f@@61 (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25)) (forall ((h@@48 T@U) (bx0@@52 T@U) (bx1@@38 T@U) (bx2@@24 T@U) ) (!  (=> (and (and (and (and (= (type h@@48) (MapType0Type refType MapType1Type)) (= (type bx0@@52) BoxType)) (= (type bx1@@38) BoxType)) (= (type bx2@@24) BoxType)) (and (and ($IsGoodHeap h@@48) (and (and ($IsBox bx0@@52 t0@@87) ($IsBox bx1@@38 t1@@63)) ($IsBox bx2@@24 t2@@40))) (Requires3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24))) ($IsBox (Apply3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24) t3@@25))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |956|
 :pattern ( (Apply3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24))
))))
 :qid |unknown.0:0|
 :skolemid |957|
 :pattern ( ($Is f@@61 (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25)))
)))
(assert (forall ((f@@62 T@U) (t0@@88 T@U) (t1@@64 T@U) (t2@@41 T@U) (t3@@26 T@U) (u0@@3 T@U) (u1@@2 T@U) (u2@@1 T@U) (u3@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type f@@62) HandleTypeType) (= (type t0@@88) TyType)) (= (type t1@@64) TyType)) (= (type t2@@41) TyType)) (= (type t3@@26) TyType)) (= (type u0@@3) TyType)) (= (type u1@@2) TyType)) (= (type u2@@1) TyType)) (= (type u3@@0) TyType)) (and (and (and (and ($Is f@@62 (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26)) (forall ((bx@@62 T@U) ) (!  (=> (and (= (type bx@@62) BoxType) ($IsBox bx@@62 u0@@3)) ($IsBox bx@@62 t0@@88))
 :qid |unknown.0:0|
 :skolemid |958|
 :pattern ( ($IsBox bx@@62 u0@@3))
 :pattern ( ($IsBox bx@@62 t0@@88))
))) (forall ((bx@@63 T@U) ) (!  (=> (and (= (type bx@@63) BoxType) ($IsBox bx@@63 u1@@2)) ($IsBox bx@@63 t1@@64))
 :qid |unknown.0:0|
 :skolemid |959|
 :pattern ( ($IsBox bx@@63 u1@@2))
 :pattern ( ($IsBox bx@@63 t1@@64))
))) (forall ((bx@@64 T@U) ) (!  (=> (and (= (type bx@@64) BoxType) ($IsBox bx@@64 u2@@1)) ($IsBox bx@@64 t2@@41))
 :qid |unknown.0:0|
 :skolemid |960|
 :pattern ( ($IsBox bx@@64 u2@@1))
 :pattern ( ($IsBox bx@@64 t2@@41))
))) (forall ((bx@@65 T@U) ) (!  (=> (and (= (type bx@@65) BoxType) ($IsBox bx@@65 t3@@26)) ($IsBox bx@@65 u3@@0))
 :qid |unknown.0:0|
 :skolemid |961|
 :pattern ( ($IsBox bx@@65 t3@@26))
 :pattern ( ($IsBox bx@@65 u3@@0))
)))) ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0)))
 :qid |unknown.0:0|
 :skolemid |962|
 :pattern ( ($Is f@@62 (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26)) ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0)))
)))
(assert (forall ((f@@63 T@U) (t0@@89 T@U) (t1@@65 T@U) (t2@@42 T@U) (t3@@27 T@U) (h@@49 T@U) ) (!  (=> (and (and (and (and (and (and (= (type f@@63) HandleTypeType) (= (type t0@@89) TyType)) (= (type t1@@65) TyType)) (= (type t2@@42) TyType)) (= (type t3@@27) TyType)) (= (type h@@49) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@49)) (= ($IsAlloc f@@63 (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27) h@@49) (forall ((bx0@@53 T@U) (bx1@@39 T@U) (bx2@@25 T@U) ) (!  (=> (and (and (= (type bx0@@53) BoxType) (= (type bx1@@39) BoxType)) (= (type bx2@@25) BoxType)) (=> (and (and (and (and ($IsBox bx0@@53 t0@@89) ($IsAllocBox bx0@@53 t0@@89 h@@49)) (and ($IsBox bx1@@39 t1@@65) ($IsAllocBox bx1@@39 t1@@65 h@@49))) (and ($IsBox bx2@@25 t2@@42) ($IsAllocBox bx2@@25 t2@@42 h@@49))) (Requires3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25)) (forall ((r@@25 T@U) ) (!  (=> (= (type r@@25) refType) (=> (and (not (= r@@25 null)) (U_2_bool (MapType0Select (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25) ($Box r@@25)))) (U_2_bool (MapType1Select (MapType0Select h@@49 r@@25) alloc))))
 :qid |unknown.0:0|
 :skolemid |963|
 :pattern ( (MapType0Select (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25) ($Box r@@25)))
))))
 :qid |unknown.0:0|
 :skolemid |964|
 :pattern ( (Apply3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25))
 :pattern ( (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25))
))))
 :qid |unknown.0:0|
 :skolemid |965|
 :pattern ( ($IsAlloc f@@63 (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27) h@@49))
)))
(assert (forall ((f@@64 T@U) (t0@@90 T@U) (t1@@66 T@U) (t2@@43 T@U) (t3@@28 T@U) (h@@50 T@U) ) (!  (=> (and (and (and (and (and (and (= (type f@@64) HandleTypeType) (= (type t0@@90) TyType)) (= (type t1@@66) TyType)) (= (type t2@@43) TyType)) (= (type t3@@28) TyType)) (= (type h@@50) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@50) ($IsAlloc f@@64 (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28) h@@50))) (forall ((bx0@@54 T@U) (bx1@@40 T@U) (bx2@@26 T@U) ) (!  (=> (and (and (= (type bx0@@54) BoxType) (= (type bx1@@40) BoxType)) (= (type bx2@@26) BoxType)) (=> (and (and (and ($IsAllocBox bx0@@54 t0@@90 h@@50) ($IsAllocBox bx1@@40 t1@@66 h@@50)) ($IsAllocBox bx2@@26 t2@@43 h@@50)) (Requires3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26)) ($IsAllocBox (Apply3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26) t3@@28 h@@50)))
 :qid |unknown.0:0|
 :skolemid |966|
 :pattern ( (Apply3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26))
)))
 :qid |unknown.0:0|
 :skolemid |967|
 :pattern ( ($IsAlloc f@@64 (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28) h@@50))
)))
(assert (forall ((arg0@@216 T@U) (arg1@@107 T@U) (arg2@@59 T@U) (arg3@@37 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3 arg0@@216 arg1@@107 arg2@@59 arg3@@37)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3|
 :pattern ( (Tclass._System.___hPartialFunc3 arg0@@216 arg1@@107 arg2@@59 arg3@@37))
)))
(assert (forall ((|#$T0@@65| T@U) (|#$T1@@49| T@U) (|#$T2@@30| T@U) (|#$R@@78| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@65|) TyType) (= (type |#$T1@@49|) TyType)) (= (type |#$T2@@30|) TyType)) (= (type |#$R@@78|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|)) Tagclass._System.___hPartialFunc3) (= (TagFamily (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|)) |tytagFamily$_#PartialFunc3|)))
 :qid |unknown.0:0|
 :skolemid |968|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|))
)))
(assert (forall ((arg0@@217 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_0 arg0@@217)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_0|
 :pattern ( (Tclass._System.___hPartialFunc3_0 arg0@@217))
)))
(assert (forall ((|#$T0@@66| T@U) (|#$T1@@50| T@U) (|#$T2@@31| T@U) (|#$R@@79| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@66|) TyType) (= (type |#$T1@@50|) TyType)) (= (type |#$T2@@31|) TyType)) (= (type |#$R@@79|) TyType)) (= (Tclass._System.___hPartialFunc3_0 (Tclass._System.___hPartialFunc3 |#$T0@@66| |#$T1@@50| |#$T2@@31| |#$R@@79|)) |#$T0@@66|))
 :qid |unknown.0:0|
 :skolemid |969|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@66| |#$T1@@50| |#$T2@@31| |#$R@@79|))
)))
(assert (forall ((arg0@@218 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_1 arg0@@218)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_1|
 :pattern ( (Tclass._System.___hPartialFunc3_1 arg0@@218))
)))
(assert (forall ((|#$T0@@67| T@U) (|#$T1@@51| T@U) (|#$T2@@32| T@U) (|#$R@@80| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@67|) TyType) (= (type |#$T1@@51|) TyType)) (= (type |#$T2@@32|) TyType)) (= (type |#$R@@80|) TyType)) (= (Tclass._System.___hPartialFunc3_1 (Tclass._System.___hPartialFunc3 |#$T0@@67| |#$T1@@51| |#$T2@@32| |#$R@@80|)) |#$T1@@51|))
 :qid |unknown.0:0|
 :skolemid |970|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@67| |#$T1@@51| |#$T2@@32| |#$R@@80|))
)))
(assert (forall ((arg0@@219 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_2 arg0@@219)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_2|
 :pattern ( (Tclass._System.___hPartialFunc3_2 arg0@@219))
)))
(assert (forall ((|#$T0@@68| T@U) (|#$T1@@52| T@U) (|#$T2@@33| T@U) (|#$R@@81| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@68|) TyType) (= (type |#$T1@@52|) TyType)) (= (type |#$T2@@33|) TyType)) (= (type |#$R@@81|) TyType)) (= (Tclass._System.___hPartialFunc3_2 (Tclass._System.___hPartialFunc3 |#$T0@@68| |#$T1@@52| |#$T2@@33| |#$R@@81|)) |#$T2@@33|))
 :qid |unknown.0:0|
 :skolemid |971|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@68| |#$T1@@52| |#$T2@@33| |#$R@@81|))
)))
(assert (forall ((arg0@@220 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_3 arg0@@220)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_3|
 :pattern ( (Tclass._System.___hPartialFunc3_3 arg0@@220))
)))
(assert (forall ((|#$T0@@69| T@U) (|#$T1@@53| T@U) (|#$T2@@34| T@U) (|#$R@@82| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@69|) TyType) (= (type |#$T1@@53|) TyType)) (= (type |#$T2@@34|) TyType)) (= (type |#$R@@82|) TyType)) (= (Tclass._System.___hPartialFunc3_3 (Tclass._System.___hPartialFunc3 |#$T0@@69| |#$T1@@53| |#$T2@@34| |#$R@@82|)) |#$R@@82|))
 :qid |unknown.0:0|
 :skolemid |972|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@69| |#$T1@@53| |#$T2@@34| |#$R@@82|))
)))
(assert (forall ((|#$T0@@70| T@U) (|#$T1@@54| T@U) (|#$T2@@35| T@U) (|#$R@@83| T@U) (bx@@66 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@70|) TyType) (= (type |#$T1@@54|) TyType)) (= (type |#$T2@@35|) TyType)) (= (type |#$R@@83|) TyType)) (= (type bx@@66) BoxType)) ($IsBox bx@@66 (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|))) (and (= ($Box ($Unbox HandleTypeType bx@@66)) bx@@66) ($Is ($Unbox HandleTypeType bx@@66) (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|))))
 :qid |unknown.0:0|
 :skolemid |973|
 :pattern ( ($IsBox bx@@66 (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|)))
)))
(assert (forall ((|#$T0@@71| T@U) (|#$T1@@55| T@U) (|#$T2@@36| T@U) (|#$R@@84| T@U) (|f#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@71|) TyType) (= (type |#$T1@@55|) TyType)) (= (type |#$T2@@36|) TyType)) (= (type |#$R@@84|) TyType)) (= (type |f#0@@15|) HandleTypeType)) (= ($Is |f#0@@15| (Tclass._System.___hPartialFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|))  (and ($Is |f#0@@15| (Tclass._System.___hFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|)) (forall ((|x0#0@@5| T@U) (|x1#0@@3| T@U) (|x2#0@@1| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@5|) BoxType) (= (type |x1#0@@3|) BoxType)) (= (type |x2#0@@1|) BoxType)) (and (and ($IsBox |x0#0@@5| |#$T0@@71|) ($IsBox |x1#0@@3| |#$T1@@55|)) ($IsBox |x2#0@@1| |#$T2@@36|))) (|Set#Equal| (Reads3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84| $OneHeap |f#0@@15| |x0#0@@5| |x1#0@@3| |x2#0@@1|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |974|
 :no-pattern (type |x0#0@@5|)
 :no-pattern (type |x1#0@@3|)
 :no-pattern (type |x2#0@@1|)
 :no-pattern (U_2_int |x0#0@@5|)
 :no-pattern (U_2_bool |x0#0@@5|)
 :no-pattern (U_2_int |x1#0@@3|)
 :no-pattern (U_2_bool |x1#0@@3|)
 :no-pattern (U_2_int |x2#0@@1|)
 :no-pattern (U_2_bool |x2#0@@1|)
)))))
 :qid |unknown.0:0|
 :skolemid |975|
 :pattern ( ($Is |f#0@@15| (Tclass._System.___hPartialFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|)))
)))
(assert (forall ((|#$T0@@72| T@U) (|#$T1@@56| T@U) (|#$T2@@37| T@U) (|#$R@@85| T@U) (|f#0@@16| T@U) ($h@@19 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@72|) TyType) (= (type |#$T1@@56|) TyType)) (= (type |#$T2@@37|) TyType)) (= (type |#$R@@85|) TyType)) (= (type |f#0@@16|) HandleTypeType)) (= (type $h@@19) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@16| (Tclass._System.___hPartialFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19) ($IsAlloc |f#0@@16| (Tclass._System.___hFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19)))
 :qid |unknown.0:0|
 :skolemid |976|
 :pattern ( ($IsAlloc |f#0@@16| (Tclass._System.___hPartialFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19))
)))
(assert (forall ((arg0@@221 T@U) (arg1@@108 T@U) (arg2@@60 T@U) (arg3@@38 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3 arg0@@221 arg1@@108 arg2@@60 arg3@@38)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3|
 :pattern ( (Tclass._System.___hTotalFunc3 arg0@@221 arg1@@108 arg2@@60 arg3@@38))
)))
(assert (forall ((|#$T0@@73| T@U) (|#$T1@@57| T@U) (|#$T2@@38| T@U) (|#$R@@86| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@73|) TyType) (= (type |#$T1@@57|) TyType)) (= (type |#$T2@@38|) TyType)) (= (type |#$R@@86|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|)) Tagclass._System.___hTotalFunc3) (= (TagFamily (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|)) |tytagFamily$_#TotalFunc3|)))
 :qid |unknown.0:0|
 :skolemid |977|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|))
)))
(assert (forall ((arg0@@222 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_0 arg0@@222)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_0|
 :pattern ( (Tclass._System.___hTotalFunc3_0 arg0@@222))
)))
(assert (forall ((|#$T0@@74| T@U) (|#$T1@@58| T@U) (|#$T2@@39| T@U) (|#$R@@87| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@74|) TyType) (= (type |#$T1@@58|) TyType)) (= (type |#$T2@@39|) TyType)) (= (type |#$R@@87|) TyType)) (= (Tclass._System.___hTotalFunc3_0 (Tclass._System.___hTotalFunc3 |#$T0@@74| |#$T1@@58| |#$T2@@39| |#$R@@87|)) |#$T0@@74|))
 :qid |unknown.0:0|
 :skolemid |978|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@74| |#$T1@@58| |#$T2@@39| |#$R@@87|))
)))
(assert (forall ((arg0@@223 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_1 arg0@@223)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_1|
 :pattern ( (Tclass._System.___hTotalFunc3_1 arg0@@223))
)))
(assert (forall ((|#$T0@@75| T@U) (|#$T1@@59| T@U) (|#$T2@@40| T@U) (|#$R@@88| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@75|) TyType) (= (type |#$T1@@59|) TyType)) (= (type |#$T2@@40|) TyType)) (= (type |#$R@@88|) TyType)) (= (Tclass._System.___hTotalFunc3_1 (Tclass._System.___hTotalFunc3 |#$T0@@75| |#$T1@@59| |#$T2@@40| |#$R@@88|)) |#$T1@@59|))
 :qid |unknown.0:0|
 :skolemid |979|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@75| |#$T1@@59| |#$T2@@40| |#$R@@88|))
)))
(assert (forall ((arg0@@224 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_2 arg0@@224)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_2|
 :pattern ( (Tclass._System.___hTotalFunc3_2 arg0@@224))
)))
(assert (forall ((|#$T0@@76| T@U) (|#$T1@@60| T@U) (|#$T2@@41| T@U) (|#$R@@89| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@76|) TyType) (= (type |#$T1@@60|) TyType)) (= (type |#$T2@@41|) TyType)) (= (type |#$R@@89|) TyType)) (= (Tclass._System.___hTotalFunc3_2 (Tclass._System.___hTotalFunc3 |#$T0@@76| |#$T1@@60| |#$T2@@41| |#$R@@89|)) |#$T2@@41|))
 :qid |unknown.0:0|
 :skolemid |980|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@76| |#$T1@@60| |#$T2@@41| |#$R@@89|))
)))
(assert (forall ((arg0@@225 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_3 arg0@@225)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_3|
 :pattern ( (Tclass._System.___hTotalFunc3_3 arg0@@225))
)))
(assert (forall ((|#$T0@@77| T@U) (|#$T1@@61| T@U) (|#$T2@@42| T@U) (|#$R@@90| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@77|) TyType) (= (type |#$T1@@61|) TyType)) (= (type |#$T2@@42|) TyType)) (= (type |#$R@@90|) TyType)) (= (Tclass._System.___hTotalFunc3_3 (Tclass._System.___hTotalFunc3 |#$T0@@77| |#$T1@@61| |#$T2@@42| |#$R@@90|)) |#$R@@90|))
 :qid |unknown.0:0|
 :skolemid |981|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@77| |#$T1@@61| |#$T2@@42| |#$R@@90|))
)))
(assert (forall ((|#$T0@@78| T@U) (|#$T1@@62| T@U) (|#$T2@@43| T@U) (|#$R@@91| T@U) (bx@@67 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@78|) TyType) (= (type |#$T1@@62|) TyType)) (= (type |#$T2@@43|) TyType)) (= (type |#$R@@91|) TyType)) (= (type bx@@67) BoxType)) ($IsBox bx@@67 (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|))) (and (= ($Box ($Unbox HandleTypeType bx@@67)) bx@@67) ($Is ($Unbox HandleTypeType bx@@67) (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|))))
 :qid |unknown.0:0|
 :skolemid |982|
 :pattern ( ($IsBox bx@@67 (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|)))
)))
(assert (forall ((|#$T0@@79| T@U) (|#$T1@@63| T@U) (|#$T2@@44| T@U) (|#$R@@92| T@U) (|f#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@79|) TyType) (= (type |#$T1@@63|) TyType)) (= (type |#$T2@@44|) TyType)) (= (type |#$R@@92|) TyType)) (= (type |f#0@@17|) HandleTypeType)) (= ($Is |f#0@@17| (Tclass._System.___hTotalFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|))  (and ($Is |f#0@@17| (Tclass._System.___hPartialFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|)) (forall ((|x0#0@@6| T@U) (|x1#0@@4| T@U) (|x2#0@@2| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@6|) BoxType) (= (type |x1#0@@4|) BoxType)) (= (type |x2#0@@2|) BoxType)) (and (and ($IsBox |x0#0@@6| |#$T0@@79|) ($IsBox |x1#0@@4| |#$T1@@63|)) ($IsBox |x2#0@@2| |#$T2@@44|))) (Requires3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92| $OneHeap |f#0@@17| |x0#0@@6| |x1#0@@4| |x2#0@@2|))
 :qid |unknown.0:0|
 :skolemid |983|
 :no-pattern (type |x0#0@@6|)
 :no-pattern (type |x1#0@@4|)
 :no-pattern (type |x2#0@@2|)
 :no-pattern (U_2_int |x0#0@@6|)
 :no-pattern (U_2_bool |x0#0@@6|)
 :no-pattern (U_2_int |x1#0@@4|)
 :no-pattern (U_2_bool |x1#0@@4|)
 :no-pattern (U_2_int |x2#0@@2|)
 :no-pattern (U_2_bool |x2#0@@2|)
)))))
 :qid |unknown.0:0|
 :skolemid |984|
 :pattern ( ($Is |f#0@@17| (Tclass._System.___hTotalFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|)))
)))
(assert (forall ((|#$T0@@80| T@U) (|#$T1@@64| T@U) (|#$T2@@45| T@U) (|#$R@@93| T@U) (|f#0@@18| T@U) ($h@@20 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@80|) TyType) (= (type |#$T1@@64|) TyType)) (= (type |#$T2@@45|) TyType)) (= (type |#$R@@93|) TyType)) (= (type |f#0@@18|) HandleTypeType)) (= (type $h@@20) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@18| (Tclass._System.___hTotalFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20) ($IsAlloc |f#0@@18| (Tclass._System.___hPartialFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20)))
 :qid |unknown.0:0|
 :skolemid |985|
 :pattern ( ($IsAlloc |f#0@@18| (Tclass._System.___hTotalFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20))
)))
(assert (forall ((arg0@@226 T@U) (arg1@@109 T@U) (arg2@@61 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO|
 :pattern ( (Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61))
)))
(assert (forall ((|#$T0@@81| T@U) (|#$T1@@65| T@U) (|#$R@@94| T@U) ) (!  (=> (and (and (= (type |#$T0@@81|) TyType) (= (type |#$T1@@65|) TyType)) (= (type |#$R@@94|) TyType)) (and (= (Tag (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|)) Tagclass._System.___hFunc2OSO) (= (TagFamily (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|)) |tytagFamily$_#Func2OSO|)))
 :qid |unknown.0:0|
 :skolemid |986|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|))
)))
(assert (forall ((arg0@@227 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_0 arg0@@227)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_0|
 :pattern ( (Tclass._System.___hFunc2OSO_0 arg0@@227))
)))
(assert (forall ((|#$T0@@82| T@U) (|#$T1@@66| T@U) (|#$R@@95| T@U) ) (!  (=> (and (and (= (type |#$T0@@82|) TyType) (= (type |#$T1@@66|) TyType)) (= (type |#$R@@95|) TyType)) (= (Tclass._System.___hFunc2OSO_0 (Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|)) |#$T0@@82|))
 :qid |unknown.0:0|
 :skolemid |987|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|))
)))
(assert (forall ((arg0@@228 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_1 arg0@@228)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_1|
 :pattern ( (Tclass._System.___hFunc2OSO_1 arg0@@228))
)))
(assert (forall ((|#$T0@@83| T@U) (|#$T1@@67| T@U) (|#$R@@96| T@U) ) (!  (=> (and (and (= (type |#$T0@@83|) TyType) (= (type |#$T1@@67|) TyType)) (= (type |#$R@@96|) TyType)) (= (Tclass._System.___hFunc2OSO_1 (Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|)) |#$T1@@67|))
 :qid |unknown.0:0|
 :skolemid |988|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|))
)))
(assert (forall ((arg0@@229 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_2 arg0@@229)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_2|
 :pattern ( (Tclass._System.___hFunc2OSO_2 arg0@@229))
)))
(assert (forall ((|#$T0@@84| T@U) (|#$T1@@68| T@U) (|#$R@@97| T@U) ) (!  (=> (and (and (= (type |#$T0@@84|) TyType) (= (type |#$T1@@68|) TyType)) (= (type |#$R@@97|) TyType)) (= (Tclass._System.___hFunc2OSO_2 (Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|)) |#$R@@97|))
 :qid |unknown.0:0|
 :skolemid |989|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|))
)))
(assert (forall ((|#$T0@@85| T@U) (|#$T1@@69| T@U) (|#$R@@98| T@U) (bx@@68 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@85|) TyType) (= (type |#$T1@@69|) TyType)) (= (type |#$R@@98|) TyType)) (= (type bx@@68) BoxType)) ($IsBox bx@@68 (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|))) (and (= ($Box ($Unbox HandleTypeType bx@@68)) bx@@68) ($Is ($Unbox HandleTypeType bx@@68) (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|))))
 :qid |unknown.0:0|
 :skolemid |990|
 :pattern ( ($IsBox bx@@68 (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|)))
)))
(assert (forall ((arg0@@230 T@U) (arg1@@110 T@U) (arg2@@62 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO|
 :pattern ( (Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62))
)))
(assert (forall ((|#$T0@@86| T@U) (|#$T1@@70| T@U) (|#$R@@99| T@U) ) (!  (=> (and (and (= (type |#$T0@@86|) TyType) (= (type |#$T1@@70|) TyType)) (= (type |#$R@@99|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|)) Tagclass._System.___hPartialFunc2OSO) (= (TagFamily (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|)) |tytagFamily$_#PartialFunc2OSO|)))
 :qid |unknown.0:0|
 :skolemid |991|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|))
)))
(assert (forall ((arg0@@231 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_0 arg0@@231)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_0|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_0 arg0@@231))
)))
(assert (forall ((|#$T0@@87| T@U) (|#$T1@@71| T@U) (|#$R@@100| T@U) ) (!  (=> (and (and (= (type |#$T0@@87|) TyType) (= (type |#$T1@@71|) TyType)) (= (type |#$R@@100|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_0 (Tclass._System.___hPartialFunc2OSO |#$T0@@87| |#$T1@@71| |#$R@@100|)) |#$T0@@87|))
 :qid |unknown.0:0|
 :skolemid |992|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@87| |#$T1@@71| |#$R@@100|))
)))
(assert (forall ((arg0@@232 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_1 arg0@@232)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_1|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_1 arg0@@232))
)))
(assert (forall ((|#$T0@@88| T@U) (|#$T1@@72| T@U) (|#$R@@101| T@U) ) (!  (=> (and (and (= (type |#$T0@@88|) TyType) (= (type |#$T1@@72|) TyType)) (= (type |#$R@@101|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_1 (Tclass._System.___hPartialFunc2OSO |#$T0@@88| |#$T1@@72| |#$R@@101|)) |#$T1@@72|))
 :qid |unknown.0:0|
 :skolemid |993|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@88| |#$T1@@72| |#$R@@101|))
)))
(assert (forall ((arg0@@233 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_2 arg0@@233)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_2|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_2 arg0@@233))
)))
(assert (forall ((|#$T0@@89| T@U) (|#$T1@@73| T@U) (|#$R@@102| T@U) ) (!  (=> (and (and (= (type |#$T0@@89|) TyType) (= (type |#$T1@@73|) TyType)) (= (type |#$R@@102|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_2 (Tclass._System.___hPartialFunc2OSO |#$T0@@89| |#$T1@@73| |#$R@@102|)) |#$R@@102|))
 :qid |unknown.0:0|
 :skolemid |994|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@89| |#$T1@@73| |#$R@@102|))
)))
(assert (forall ((|#$T0@@90| T@U) (|#$T1@@74| T@U) (|#$R@@103| T@U) (bx@@69 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@90|) TyType) (= (type |#$T1@@74|) TyType)) (= (type |#$R@@103|) TyType)) (= (type bx@@69) BoxType)) ($IsBox bx@@69 (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|))) (and (= ($Box ($Unbox HandleTypeType bx@@69)) bx@@69) ($Is ($Unbox HandleTypeType bx@@69) (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|))))
 :qid |unknown.0:0|
 :skolemid |995|
 :pattern ( ($IsBox bx@@69 (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|)))
)))
(assert (forall ((|#$T0@@91| T@U) (|#$T1@@75| T@U) (|#$R@@104| T@U) (|f#0@@19| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@91|) TyType) (= (type |#$T1@@75|) TyType)) (= (type |#$R@@104|) TyType)) (= (type |f#0@@19|) HandleTypeType)) (= ($Is |f#0@@19| (Tclass._System.___hPartialFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|))  (and ($Is |f#0@@19| (Tclass._System.___hFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|)) (forall ((|x0#0@@7| T@U) (|x1#0@@5| T@U) ) (!  (=> (and (and (= (type |x0#0@@7|) BoxType) (= (type |x1#0@@5|) BoxType)) (and ($IsBox |x0#0@@7| |#$T0@@91|) ($IsBox |x1#0@@5| |#$T1@@75|))) (|Set#Equal| (Reads2 |#$T0@@91| |#$T1@@75| |#$R@@104| $OneHeap |f#0@@19| |x0#0@@7| |x1#0@@5|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |996|
 :no-pattern (type |x0#0@@7|)
 :no-pattern (type |x1#0@@5|)
 :no-pattern (U_2_int |x0#0@@7|)
 :no-pattern (U_2_bool |x0#0@@7|)
 :no-pattern (U_2_int |x1#0@@5|)
 :no-pattern (U_2_bool |x1#0@@5|)
)))))
 :qid |unknown.0:0|
 :skolemid |997|
 :pattern ( ($Is |f#0@@19| (Tclass._System.___hPartialFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|)))
)))
(assert (forall ((|#$T0@@92| T@U) (|#$T1@@76| T@U) (|#$R@@105| T@U) (|f#0@@20| T@U) ($h@@21 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@92|) TyType) (= (type |#$T1@@76|) TyType)) (= (type |#$R@@105|) TyType)) (= (type |f#0@@20|) HandleTypeType)) (= (type $h@@21) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@20| (Tclass._System.___hPartialFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21) ($IsAlloc |f#0@@20| (Tclass._System.___hFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21)))
 :qid |unknown.0:0|
 :skolemid |998|
 :pattern ( ($IsAlloc |f#0@@20| (Tclass._System.___hPartialFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21))
)))
(assert (forall ((arg0@@234 T@U) (arg1@@111 T@U) (arg2@@63 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO|
 :pattern ( (Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63))
)))
(assert (forall ((|#$T0@@93| T@U) (|#$T1@@77| T@U) (|#$R@@106| T@U) ) (!  (=> (and (and (= (type |#$T0@@93|) TyType) (= (type |#$T1@@77|) TyType)) (= (type |#$R@@106|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|)) Tagclass._System.___hTotalFunc2OSO) (= (TagFamily (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|)) |tytagFamily$_#TotalFunc2OSO|)))
 :qid |unknown.0:0|
 :skolemid |999|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|))
)))
(assert (forall ((arg0@@235 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_0 arg0@@235)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_0|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_0 arg0@@235))
)))
(assert (forall ((|#$T0@@94| T@U) (|#$T1@@78| T@U) (|#$R@@107| T@U) ) (!  (=> (and (and (= (type |#$T0@@94|) TyType) (= (type |#$T1@@78|) TyType)) (= (type |#$R@@107|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_0 (Tclass._System.___hTotalFunc2OSO |#$T0@@94| |#$T1@@78| |#$R@@107|)) |#$T0@@94|))
 :qid |unknown.0:0|
 :skolemid |1000|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@94| |#$T1@@78| |#$R@@107|))
)))
(assert (forall ((arg0@@236 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_1 arg0@@236)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_1|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_1 arg0@@236))
)))
(assert (forall ((|#$T0@@95| T@U) (|#$T1@@79| T@U) (|#$R@@108| T@U) ) (!  (=> (and (and (= (type |#$T0@@95|) TyType) (= (type |#$T1@@79|) TyType)) (= (type |#$R@@108|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_1 (Tclass._System.___hTotalFunc2OSO |#$T0@@95| |#$T1@@79| |#$R@@108|)) |#$T1@@79|))
 :qid |unknown.0:0|
 :skolemid |1001|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@95| |#$T1@@79| |#$R@@108|))
)))
(assert (forall ((arg0@@237 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_2 arg0@@237)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_2|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_2 arg0@@237))
)))
(assert (forall ((|#$T0@@96| T@U) (|#$T1@@80| T@U) (|#$R@@109| T@U) ) (!  (=> (and (and (= (type |#$T0@@96|) TyType) (= (type |#$T1@@80|) TyType)) (= (type |#$R@@109|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_2 (Tclass._System.___hTotalFunc2OSO |#$T0@@96| |#$T1@@80| |#$R@@109|)) |#$R@@109|))
 :qid |unknown.0:0|
 :skolemid |1002|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@96| |#$T1@@80| |#$R@@109|))
)))
(assert (forall ((|#$T0@@97| T@U) (|#$T1@@81| T@U) (|#$R@@110| T@U) (bx@@70 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@97|) TyType) (= (type |#$T1@@81|) TyType)) (= (type |#$R@@110|) TyType)) (= (type bx@@70) BoxType)) ($IsBox bx@@70 (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|))) (and (= ($Box ($Unbox HandleTypeType bx@@70)) bx@@70) ($Is ($Unbox HandleTypeType bx@@70) (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|))))
 :qid |unknown.0:0|
 :skolemid |1003|
 :pattern ( ($IsBox bx@@70 (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|)))
)))
(assert (forall ((|#$T0@@98| T@U) (|#$T1@@82| T@U) (|#$R@@111| T@U) (|f#0@@21| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@98|) TyType) (= (type |#$T1@@82|) TyType)) (= (type |#$R@@111|) TyType)) (= (type |f#0@@21|) HandleTypeType)) (= ($Is |f#0@@21| (Tclass._System.___hTotalFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|))  (and ($Is |f#0@@21| (Tclass._System.___hPartialFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|)) (forall ((|x0#0@@8| T@U) (|x1#0@@6| T@U) ) (!  (=> (and (and (= (type |x0#0@@8|) BoxType) (= (type |x1#0@@6|) BoxType)) (and ($IsBox |x0#0@@8| |#$T0@@98|) ($IsBox |x1#0@@6| |#$T1@@82|))) (Requires2 |#$T0@@98| |#$T1@@82| |#$R@@111| $OneHeap |f#0@@21| |x0#0@@8| |x1#0@@6|))
 :qid |unknown.0:0|
 :skolemid |1004|
 :no-pattern (type |x0#0@@8|)
 :no-pattern (type |x1#0@@6|)
 :no-pattern (U_2_int |x0#0@@8|)
 :no-pattern (U_2_bool |x0#0@@8|)
 :no-pattern (U_2_int |x1#0@@6|)
 :no-pattern (U_2_bool |x1#0@@6|)
)))))
 :qid |unknown.0:0|
 :skolemid |1005|
 :pattern ( ($Is |f#0@@21| (Tclass._System.___hTotalFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|)))
)))
(assert (forall ((|#$T0@@99| T@U) (|#$T1@@83| T@U) (|#$R@@112| T@U) (|f#0@@22| T@U) ($h@@22 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@99|) TyType) (= (type |#$T1@@83|) TyType)) (= (type |#$R@@112|) TyType)) (= (type |f#0@@22|) HandleTypeType)) (= (type $h@@22) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@22| (Tclass._System.___hTotalFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22) ($IsAlloc |f#0@@22| (Tclass._System.___hPartialFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22)))
 :qid |unknown.0:0|
 :skolemid |1006|
 :pattern ( ($IsAlloc |f#0@@22| (Tclass._System.___hTotalFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22))
)))
(assert (forall ((arg0@@238 T@U) (arg1@@112 T@U) (arg2@@64 T@U) (arg3@@39 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO arg0@@238 arg1@@112 arg2@@64 arg3@@39)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO|
 :pattern ( (Tclass._System.___hFunc3LLOO arg0@@238 arg1@@112 arg2@@64 arg3@@39))
)))
(assert (forall ((|#$T0@@100| T@U) (|#$T1@@84| T@U) (|#$T2@@46| T@U) (|#$R@@113| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@100|) TyType) (= (type |#$T1@@84|) TyType)) (= (type |#$T2@@46|) TyType)) (= (type |#$R@@113|) TyType)) (and (= (Tag (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|)) Tagclass._System.___hFunc3LLOO) (= (TagFamily (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|)) |tytagFamily$_#Func3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1007|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|))
)))
(assert (forall ((arg0@@239 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_0 arg0@@239)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_0|
 :pattern ( (Tclass._System.___hFunc3LLOO_0 arg0@@239))
)))
(assert (forall ((|#$T0@@101| T@U) (|#$T1@@85| T@U) (|#$T2@@47| T@U) (|#$R@@114| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@101|) TyType) (= (type |#$T1@@85|) TyType)) (= (type |#$T2@@47|) TyType)) (= (type |#$R@@114|) TyType)) (= (Tclass._System.___hFunc3LLOO_0 (Tclass._System.___hFunc3LLOO |#$T0@@101| |#$T1@@85| |#$T2@@47| |#$R@@114|)) |#$T0@@101|))
 :qid |unknown.0:0|
 :skolemid |1008|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@101| |#$T1@@85| |#$T2@@47| |#$R@@114|))
)))
(assert (forall ((arg0@@240 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_1 arg0@@240)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_1|
 :pattern ( (Tclass._System.___hFunc3LLOO_1 arg0@@240))
)))
(assert (forall ((|#$T0@@102| T@U) (|#$T1@@86| T@U) (|#$T2@@48| T@U) (|#$R@@115| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@102|) TyType) (= (type |#$T1@@86|) TyType)) (= (type |#$T2@@48|) TyType)) (= (type |#$R@@115|) TyType)) (= (Tclass._System.___hFunc3LLOO_1 (Tclass._System.___hFunc3LLOO |#$T0@@102| |#$T1@@86| |#$T2@@48| |#$R@@115|)) |#$T1@@86|))
 :qid |unknown.0:0|
 :skolemid |1009|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@102| |#$T1@@86| |#$T2@@48| |#$R@@115|))
)))
(assert (forall ((arg0@@241 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_2 arg0@@241)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_2|
 :pattern ( (Tclass._System.___hFunc3LLOO_2 arg0@@241))
)))
(assert (forall ((|#$T0@@103| T@U) (|#$T1@@87| T@U) (|#$T2@@49| T@U) (|#$R@@116| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@103|) TyType) (= (type |#$T1@@87|) TyType)) (= (type |#$T2@@49|) TyType)) (= (type |#$R@@116|) TyType)) (= (Tclass._System.___hFunc3LLOO_2 (Tclass._System.___hFunc3LLOO |#$T0@@103| |#$T1@@87| |#$T2@@49| |#$R@@116|)) |#$T2@@49|))
 :qid |unknown.0:0|
 :skolemid |1010|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@103| |#$T1@@87| |#$T2@@49| |#$R@@116|))
)))
(assert (forall ((arg0@@242 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_3 arg0@@242)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_3|
 :pattern ( (Tclass._System.___hFunc3LLOO_3 arg0@@242))
)))
(assert (forall ((|#$T0@@104| T@U) (|#$T1@@88| T@U) (|#$T2@@50| T@U) (|#$R@@117| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@104|) TyType) (= (type |#$T1@@88|) TyType)) (= (type |#$T2@@50|) TyType)) (= (type |#$R@@117|) TyType)) (= (Tclass._System.___hFunc3LLOO_3 (Tclass._System.___hFunc3LLOO |#$T0@@104| |#$T1@@88| |#$T2@@50| |#$R@@117|)) |#$R@@117|))
 :qid |unknown.0:0|
 :skolemid |1011|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@104| |#$T1@@88| |#$T2@@50| |#$R@@117|))
)))
(assert (forall ((|#$T0@@105| T@U) (|#$T1@@89| T@U) (|#$T2@@51| T@U) (|#$R@@118| T@U) (bx@@71 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@105|) TyType) (= (type |#$T1@@89|) TyType)) (= (type |#$T2@@51|) TyType)) (= (type |#$R@@118|) TyType)) (= (type bx@@71) BoxType)) ($IsBox bx@@71 (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|))) (and (= ($Box ($Unbox HandleTypeType bx@@71)) bx@@71) ($Is ($Unbox HandleTypeType bx@@71) (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|))))
 :qid |unknown.0:0|
 :skolemid |1012|
 :pattern ( ($IsBox bx@@71 (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|)))
)))
(assert (forall ((arg0@@243 T@U) (arg1@@113 T@U) (arg2@@65 T@U) (arg3@@40 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO arg0@@243 arg1@@113 arg2@@65 arg3@@40)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO arg0@@243 arg1@@113 arg2@@65 arg3@@40))
)))
(assert (forall ((|#$T0@@106| T@U) (|#$T1@@90| T@U) (|#$T2@@52| T@U) (|#$R@@119| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@106|) TyType) (= (type |#$T1@@90|) TyType)) (= (type |#$T2@@52|) TyType)) (= (type |#$R@@119|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|)) Tagclass._System.___hPartialFunc3LLOO) (= (TagFamily (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|)) |tytagFamily$_#PartialFunc3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1013|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|))
)))
(assert (forall ((arg0@@244 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_0 arg0@@244)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_0|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_0 arg0@@244))
)))
(assert (forall ((|#$T0@@107| T@U) (|#$T1@@91| T@U) (|#$T2@@53| T@U) (|#$R@@120| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@107|) TyType) (= (type |#$T1@@91|) TyType)) (= (type |#$T2@@53|) TyType)) (= (type |#$R@@120|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_0 (Tclass._System.___hPartialFunc3LLOO |#$T0@@107| |#$T1@@91| |#$T2@@53| |#$R@@120|)) |#$T0@@107|))
 :qid |unknown.0:0|
 :skolemid |1014|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@107| |#$T1@@91| |#$T2@@53| |#$R@@120|))
)))
(assert (forall ((arg0@@245 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_1 arg0@@245)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_1|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_1 arg0@@245))
)))
(assert (forall ((|#$T0@@108| T@U) (|#$T1@@92| T@U) (|#$T2@@54| T@U) (|#$R@@121| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@108|) TyType) (= (type |#$T1@@92|) TyType)) (= (type |#$T2@@54|) TyType)) (= (type |#$R@@121|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_1 (Tclass._System.___hPartialFunc3LLOO |#$T0@@108| |#$T1@@92| |#$T2@@54| |#$R@@121|)) |#$T1@@92|))
 :qid |unknown.0:0|
 :skolemid |1015|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@108| |#$T1@@92| |#$T2@@54| |#$R@@121|))
)))
(assert (forall ((arg0@@246 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_2 arg0@@246)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_2|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_2 arg0@@246))
)))
(assert (forall ((|#$T0@@109| T@U) (|#$T1@@93| T@U) (|#$T2@@55| T@U) (|#$R@@122| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@109|) TyType) (= (type |#$T1@@93|) TyType)) (= (type |#$T2@@55|) TyType)) (= (type |#$R@@122|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_2 (Tclass._System.___hPartialFunc3LLOO |#$T0@@109| |#$T1@@93| |#$T2@@55| |#$R@@122|)) |#$T2@@55|))
 :qid |unknown.0:0|
 :skolemid |1016|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@109| |#$T1@@93| |#$T2@@55| |#$R@@122|))
)))
(assert (forall ((arg0@@247 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_3 arg0@@247)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_3|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_3 arg0@@247))
)))
(assert (forall ((|#$T0@@110| T@U) (|#$T1@@94| T@U) (|#$T2@@56| T@U) (|#$R@@123| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@110|) TyType) (= (type |#$T1@@94|) TyType)) (= (type |#$T2@@56|) TyType)) (= (type |#$R@@123|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_3 (Tclass._System.___hPartialFunc3LLOO |#$T0@@110| |#$T1@@94| |#$T2@@56| |#$R@@123|)) |#$R@@123|))
 :qid |unknown.0:0|
 :skolemid |1017|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@110| |#$T1@@94| |#$T2@@56| |#$R@@123|))
)))
(assert (forall ((|#$T0@@111| T@U) (|#$T1@@95| T@U) (|#$T2@@57| T@U) (|#$R@@124| T@U) (bx@@72 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@111|) TyType) (= (type |#$T1@@95|) TyType)) (= (type |#$T2@@57|) TyType)) (= (type |#$R@@124|) TyType)) (= (type bx@@72) BoxType)) ($IsBox bx@@72 (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|))) (and (= ($Box ($Unbox HandleTypeType bx@@72)) bx@@72) ($Is ($Unbox HandleTypeType bx@@72) (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|))))
 :qid |unknown.0:0|
 :skolemid |1018|
 :pattern ( ($IsBox bx@@72 (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|)))
)))
(assert (forall ((|#$T0@@112| T@U) (|#$T1@@96| T@U) (|#$T2@@58| T@U) (|#$R@@125| T@U) (|f#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@112|) TyType) (= (type |#$T1@@96|) TyType)) (= (type |#$T2@@58|) TyType)) (= (type |#$R@@125|) TyType)) (= (type |f#0@@23|) HandleTypeType)) (= ($Is |f#0@@23| (Tclass._System.___hPartialFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|))  (and ($Is |f#0@@23| (Tclass._System.___hFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|)) (forall ((|x0#0@@9| T@U) (|x1#0@@7| T@U) (|x2#0@@3| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@9|) BoxType) (= (type |x1#0@@7|) BoxType)) (= (type |x2#0@@3|) BoxType)) (and (and ($IsBox |x0#0@@9| |#$T0@@112|) ($IsBox |x1#0@@7| |#$T1@@96|)) ($IsBox |x2#0@@3| |#$T2@@58|))) (|Set#Equal| (Reads3 |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125| $OneHeap |f#0@@23| |x0#0@@9| |x1#0@@7| |x2#0@@3|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1019|
 :no-pattern (type |x0#0@@9|)
 :no-pattern (type |x1#0@@7|)
 :no-pattern (type |x2#0@@3|)
 :no-pattern (U_2_int |x0#0@@9|)
 :no-pattern (U_2_bool |x0#0@@9|)
 :no-pattern (U_2_int |x1#0@@7|)
 :no-pattern (U_2_bool |x1#0@@7|)
 :no-pattern (U_2_int |x2#0@@3|)
 :no-pattern (U_2_bool |x2#0@@3|)
)))))
 :qid |unknown.0:0|
 :skolemid |1020|
 :pattern ( ($Is |f#0@@23| (Tclass._System.___hPartialFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|)))
)))
(assert (forall ((|#$T0@@113| T@U) (|#$T1@@97| T@U) (|#$T2@@59| T@U) (|#$R@@126| T@U) (|f#0@@24| T@U) ($h@@23 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@113|) TyType) (= (type |#$T1@@97|) TyType)) (= (type |#$T2@@59|) TyType)) (= (type |#$R@@126|) TyType)) (= (type |f#0@@24|) HandleTypeType)) (= (type $h@@23) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@24| (Tclass._System.___hPartialFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23) ($IsAlloc |f#0@@24| (Tclass._System.___hFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23)))
 :qid |unknown.0:0|
 :skolemid |1021|
 :pattern ( ($IsAlloc |f#0@@24| (Tclass._System.___hPartialFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23))
)))
(assert (forall ((arg0@@248 T@U) (arg1@@114 T@U) (arg2@@66 T@U) (arg3@@41 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO arg0@@248 arg1@@114 arg2@@66 arg3@@41)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO arg0@@248 arg1@@114 arg2@@66 arg3@@41))
)))
(assert (forall ((|#$T0@@114| T@U) (|#$T1@@98| T@U) (|#$T2@@60| T@U) (|#$R@@127| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@114|) TyType) (= (type |#$T1@@98|) TyType)) (= (type |#$T2@@60|) TyType)) (= (type |#$R@@127|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|)) Tagclass._System.___hTotalFunc3LLOO) (= (TagFamily (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|)) |tytagFamily$_#TotalFunc3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1022|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|))
)))
(assert (forall ((arg0@@249 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_0 arg0@@249)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_0|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_0 arg0@@249))
)))
(assert (forall ((|#$T0@@115| T@U) (|#$T1@@99| T@U) (|#$T2@@61| T@U) (|#$R@@128| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@115|) TyType) (= (type |#$T1@@99|) TyType)) (= (type |#$T2@@61|) TyType)) (= (type |#$R@@128|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_0 (Tclass._System.___hTotalFunc3LLOO |#$T0@@115| |#$T1@@99| |#$T2@@61| |#$R@@128|)) |#$T0@@115|))
 :qid |unknown.0:0|
 :skolemid |1023|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@115| |#$T1@@99| |#$T2@@61| |#$R@@128|))
)))
(assert (forall ((arg0@@250 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_1 arg0@@250)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_1|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_1 arg0@@250))
)))
(assert (forall ((|#$T0@@116| T@U) (|#$T1@@100| T@U) (|#$T2@@62| T@U) (|#$R@@129| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@116|) TyType) (= (type |#$T1@@100|) TyType)) (= (type |#$T2@@62|) TyType)) (= (type |#$R@@129|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_1 (Tclass._System.___hTotalFunc3LLOO |#$T0@@116| |#$T1@@100| |#$T2@@62| |#$R@@129|)) |#$T1@@100|))
 :qid |unknown.0:0|
 :skolemid |1024|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@116| |#$T1@@100| |#$T2@@62| |#$R@@129|))
)))
(assert (forall ((arg0@@251 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_2 arg0@@251)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_2|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_2 arg0@@251))
)))
(assert (forall ((|#$T0@@117| T@U) (|#$T1@@101| T@U) (|#$T2@@63| T@U) (|#$R@@130| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@117|) TyType) (= (type |#$T1@@101|) TyType)) (= (type |#$T2@@63|) TyType)) (= (type |#$R@@130|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_2 (Tclass._System.___hTotalFunc3LLOO |#$T0@@117| |#$T1@@101| |#$T2@@63| |#$R@@130|)) |#$T2@@63|))
 :qid |unknown.0:0|
 :skolemid |1025|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@117| |#$T1@@101| |#$T2@@63| |#$R@@130|))
)))
(assert (forall ((arg0@@252 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_3 arg0@@252)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_3|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_3 arg0@@252))
)))
(assert (forall ((|#$T0@@118| T@U) (|#$T1@@102| T@U) (|#$T2@@64| T@U) (|#$R@@131| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@118|) TyType) (= (type |#$T1@@102|) TyType)) (= (type |#$T2@@64|) TyType)) (= (type |#$R@@131|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_3 (Tclass._System.___hTotalFunc3LLOO |#$T0@@118| |#$T1@@102| |#$T2@@64| |#$R@@131|)) |#$R@@131|))
 :qid |unknown.0:0|
 :skolemid |1026|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@118| |#$T1@@102| |#$T2@@64| |#$R@@131|))
)))
(assert (forall ((|#$T0@@119| T@U) (|#$T1@@103| T@U) (|#$T2@@65| T@U) (|#$R@@132| T@U) (bx@@73 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@119|) TyType) (= (type |#$T1@@103|) TyType)) (= (type |#$T2@@65|) TyType)) (= (type |#$R@@132|) TyType)) (= (type bx@@73) BoxType)) ($IsBox bx@@73 (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|))) (and (= ($Box ($Unbox HandleTypeType bx@@73)) bx@@73) ($Is ($Unbox HandleTypeType bx@@73) (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|))))
 :qid |unknown.0:0|
 :skolemid |1027|
 :pattern ( ($IsBox bx@@73 (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|)))
)))
(assert (forall ((|#$T0@@120| T@U) (|#$T1@@104| T@U) (|#$T2@@66| T@U) (|#$R@@133| T@U) (|f#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@120|) TyType) (= (type |#$T1@@104|) TyType)) (= (type |#$T2@@66|) TyType)) (= (type |#$R@@133|) TyType)) (= (type |f#0@@25|) HandleTypeType)) (= ($Is |f#0@@25| (Tclass._System.___hTotalFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|))  (and ($Is |f#0@@25| (Tclass._System.___hPartialFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|)) (forall ((|x0#0@@10| T@U) (|x1#0@@8| T@U) (|x2#0@@4| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@10|) BoxType) (= (type |x1#0@@8|) BoxType)) (= (type |x2#0@@4|) BoxType)) (and (and ($IsBox |x0#0@@10| |#$T0@@120|) ($IsBox |x1#0@@8| |#$T1@@104|)) ($IsBox |x2#0@@4| |#$T2@@66|))) (Requires3 |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133| $OneHeap |f#0@@25| |x0#0@@10| |x1#0@@8| |x2#0@@4|))
 :qid |unknown.0:0|
 :skolemid |1028|
 :no-pattern (type |x0#0@@10|)
 :no-pattern (type |x1#0@@8|)
 :no-pattern (type |x2#0@@4|)
 :no-pattern (U_2_int |x0#0@@10|)
 :no-pattern (U_2_bool |x0#0@@10|)
 :no-pattern (U_2_int |x1#0@@8|)
 :no-pattern (U_2_bool |x1#0@@8|)
 :no-pattern (U_2_int |x2#0@@4|)
 :no-pattern (U_2_bool |x2#0@@4|)
)))))
 :qid |unknown.0:0|
 :skolemid |1029|
 :pattern ( ($Is |f#0@@25| (Tclass._System.___hTotalFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|)))
)))
(assert (forall ((|#$T0@@121| T@U) (|#$T1@@105| T@U) (|#$T2@@67| T@U) (|#$R@@134| T@U) (|f#0@@26| T@U) ($h@@24 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@121|) TyType) (= (type |#$T1@@105|) TyType)) (= (type |#$T2@@67|) TyType)) (= (type |#$R@@134|) TyType)) (= (type |f#0@@26|) HandleTypeType)) (= (type $h@@24) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@26| (Tclass._System.___hTotalFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24) ($IsAlloc |f#0@@26| (Tclass._System.___hPartialFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24)))
 :qid |unknown.0:0|
 :skolemid |1030|
 :pattern ( ($IsAlloc |f#0@@26| (Tclass._System.___hTotalFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24))
)))
(assert (forall ((arg0@@253 T@U) (arg1@@115 T@U) ) (! (= (type (Tclass._System.___hFunc1OS arg0@@253 arg1@@115)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS|
 :pattern ( (Tclass._System.___hFunc1OS arg0@@253 arg1@@115))
)))
(assert (forall ((|#$T0@@122| T@U) (|#$R@@135| T@U) ) (!  (=> (and (= (type |#$T0@@122|) TyType) (= (type |#$R@@135|) TyType)) (and (= (Tag (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|)) Tagclass._System.___hFunc1OS) (= (TagFamily (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|)) |tytagFamily$_#Func1OS|)))
 :qid |unknown.0:0|
 :skolemid |1031|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|))
)))
(assert (forall ((arg0@@254 T@U) ) (! (= (type (Tclass._System.___hFunc1OS_0 arg0@@254)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS_0|
 :pattern ( (Tclass._System.___hFunc1OS_0 arg0@@254))
)))
(assert (forall ((|#$T0@@123| T@U) (|#$R@@136| T@U) ) (!  (=> (and (= (type |#$T0@@123|) TyType) (= (type |#$R@@136|) TyType)) (= (Tclass._System.___hFunc1OS_0 (Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|)) |#$T0@@123|))
 :qid |unknown.0:0|
 :skolemid |1032|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|))
)))
(assert (forall ((arg0@@255 T@U) ) (! (= (type (Tclass._System.___hFunc1OS_1 arg0@@255)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS_1|
 :pattern ( (Tclass._System.___hFunc1OS_1 arg0@@255))
)))
(assert (forall ((|#$T0@@124| T@U) (|#$R@@137| T@U) ) (!  (=> (and (= (type |#$T0@@124|) TyType) (= (type |#$R@@137|) TyType)) (= (Tclass._System.___hFunc1OS_1 (Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|)) |#$R@@137|))
 :qid |unknown.0:0|
 :skolemid |1033|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|))
)))
(assert (forall ((|#$T0@@125| T@U) (|#$R@@138| T@U) (bx@@74 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@125|) TyType) (= (type |#$R@@138|) TyType)) (= (type bx@@74) BoxType)) ($IsBox bx@@74 (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|))) (and (= ($Box ($Unbox HandleTypeType bx@@74)) bx@@74) ($Is ($Unbox HandleTypeType bx@@74) (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|))))
 :qid |unknown.0:0|
 :skolemid |1034|
 :pattern ( ($IsBox bx@@74 (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|)))
)))
(assert (forall ((arg0@@256 T@U) (arg1@@116 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS|
 :pattern ( (Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116))
)))
(assert (forall ((|#$T0@@126| T@U) (|#$R@@139| T@U) ) (!  (=> (and (= (type |#$T0@@126|) TyType) (= (type |#$R@@139|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|)) Tagclass._System.___hPartialFunc1OS) (= (TagFamily (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|)) |tytagFamily$_#PartialFunc1OS|)))
 :qid |unknown.0:0|
 :skolemid |1035|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|))
)))
(assert (forall ((arg0@@257 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS_0 arg0@@257)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS_0|
 :pattern ( (Tclass._System.___hPartialFunc1OS_0 arg0@@257))
)))
(assert (forall ((|#$T0@@127| T@U) (|#$R@@140| T@U) ) (!  (=> (and (= (type |#$T0@@127|) TyType) (= (type |#$R@@140|) TyType)) (= (Tclass._System.___hPartialFunc1OS_0 (Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|)) |#$T0@@127|))
 :qid |unknown.0:0|
 :skolemid |1036|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|))
)))
(assert (forall ((arg0@@258 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS_1 arg0@@258)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS_1|
 :pattern ( (Tclass._System.___hPartialFunc1OS_1 arg0@@258))
)))
(assert (forall ((|#$T0@@128| T@U) (|#$R@@141| T@U) ) (!  (=> (and (= (type |#$T0@@128|) TyType) (= (type |#$R@@141|) TyType)) (= (Tclass._System.___hPartialFunc1OS_1 (Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|)) |#$R@@141|))
 :qid |unknown.0:0|
 :skolemid |1037|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|))
)))
(assert (forall ((|#$T0@@129| T@U) (|#$R@@142| T@U) (bx@@75 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@129|) TyType) (= (type |#$R@@142|) TyType)) (= (type bx@@75) BoxType)) ($IsBox bx@@75 (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|))) (and (= ($Box ($Unbox HandleTypeType bx@@75)) bx@@75) ($Is ($Unbox HandleTypeType bx@@75) (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|))))
 :qid |unknown.0:0|
 :skolemid |1038|
 :pattern ( ($IsBox bx@@75 (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|)))
)))
(assert (forall ((|#$T0@@130| T@U) (|#$R@@143| T@U) (|f#0@@27| T@U) ) (!  (=> (and (and (= (type |#$T0@@130|) TyType) (= (type |#$R@@143|) TyType)) (= (type |f#0@@27|) HandleTypeType)) (= ($Is |f#0@@27| (Tclass._System.___hPartialFunc1OS |#$T0@@130| |#$R@@143|))  (and ($Is |f#0@@27| (Tclass._System.___hFunc1OS |#$T0@@130| |#$R@@143|)) (forall ((|x0#0@@11| T@U) ) (!  (=> (and (= (type |x0#0@@11|) BoxType) ($IsBox |x0#0@@11| |#$T0@@130|)) (|Set#Equal| (Reads1 |#$T0@@130| |#$R@@143| $OneHeap |f#0@@27| |x0#0@@11|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1039|
 :no-pattern (type |x0#0@@11|)
 :no-pattern (U_2_int |x0#0@@11|)
 :no-pattern (U_2_bool |x0#0@@11|)
)))))
 :qid |unknown.0:0|
 :skolemid |1040|
 :pattern ( ($Is |f#0@@27| (Tclass._System.___hPartialFunc1OS |#$T0@@130| |#$R@@143|)))
)))
(assert (forall ((|#$T0@@131| T@U) (|#$R@@144| T@U) (|f#0@@28| T@U) ($h@@25 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@131|) TyType) (= (type |#$R@@144|) TyType)) (= (type |f#0@@28|) HandleTypeType)) (= (type $h@@25) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@28| (Tclass._System.___hPartialFunc1OS |#$T0@@131| |#$R@@144|) $h@@25) ($IsAlloc |f#0@@28| (Tclass._System.___hFunc1OS |#$T0@@131| |#$R@@144|) $h@@25)))
 :qid |unknown.0:0|
 :skolemid |1041|
 :pattern ( ($IsAlloc |f#0@@28| (Tclass._System.___hPartialFunc1OS |#$T0@@131| |#$R@@144|) $h@@25))
)))
(assert (forall ((arg0@@259 T@U) (arg1@@117 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS|
 :pattern ( (Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117))
)))
(assert (forall ((|#$T0@@132| T@U) (|#$R@@145| T@U) ) (!  (=> (and (= (type |#$T0@@132|) TyType) (= (type |#$R@@145|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|)) Tagclass._System.___hTotalFunc1OS) (= (TagFamily (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|)) |tytagFamily$_#TotalFunc1OS|)))
 :qid |unknown.0:0|
 :skolemid |1042|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|))
)))
(assert (forall ((arg0@@260 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS_0 arg0@@260)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS_0|
 :pattern ( (Tclass._System.___hTotalFunc1OS_0 arg0@@260))
)))
(assert (forall ((|#$T0@@133| T@U) (|#$R@@146| T@U) ) (!  (=> (and (= (type |#$T0@@133|) TyType) (= (type |#$R@@146|) TyType)) (= (Tclass._System.___hTotalFunc1OS_0 (Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|)) |#$T0@@133|))
 :qid |unknown.0:0|
 :skolemid |1043|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|))
)))
(assert (forall ((arg0@@261 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS_1 arg0@@261)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS_1|
 :pattern ( (Tclass._System.___hTotalFunc1OS_1 arg0@@261))
)))
(assert (forall ((|#$T0@@134| T@U) (|#$R@@147| T@U) ) (!  (=> (and (= (type |#$T0@@134|) TyType) (= (type |#$R@@147|) TyType)) (= (Tclass._System.___hTotalFunc1OS_1 (Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|)) |#$R@@147|))
 :qid |unknown.0:0|
 :skolemid |1044|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|))
)))
(assert (forall ((|#$T0@@135| T@U) (|#$R@@148| T@U) (bx@@76 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@135|) TyType) (= (type |#$R@@148|) TyType)) (= (type bx@@76) BoxType)) ($IsBox bx@@76 (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|))) (and (= ($Box ($Unbox HandleTypeType bx@@76)) bx@@76) ($Is ($Unbox HandleTypeType bx@@76) (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|))))
 :qid |unknown.0:0|
 :skolemid |1045|
 :pattern ( ($IsBox bx@@76 (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|)))
)))
(assert (forall ((|#$T0@@136| T@U) (|#$R@@149| T@U) (|f#0@@29| T@U) ) (!  (=> (and (and (= (type |#$T0@@136|) TyType) (= (type |#$R@@149|) TyType)) (= (type |f#0@@29|) HandleTypeType)) (= ($Is |f#0@@29| (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|))  (and ($Is |f#0@@29| (Tclass._System.___hPartialFunc1OS |#$T0@@136| |#$R@@149|)) (forall ((|x0#0@@12| T@U) ) (!  (=> (and (= (type |x0#0@@12|) BoxType) ($IsBox |x0#0@@12| |#$T0@@136|)) (Requires1 |#$T0@@136| |#$R@@149| $OneHeap |f#0@@29| |x0#0@@12|))
 :qid |unknown.0:0|
 :skolemid |1046|
 :no-pattern (type |x0#0@@12|)
 :no-pattern (U_2_int |x0#0@@12|)
 :no-pattern (U_2_bool |x0#0@@12|)
)))))
 :qid |unknown.0:0|
 :skolemid |1047|
 :pattern ( ($Is |f#0@@29| (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|)))
)))
(assert (forall ((|#$T0@@137| T@U) (|#$R@@150| T@U) (|f#0@@30| T@U) ($h@@26 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@137|) TyType) (= (type |#$R@@150|) TyType)) (= (type |f#0@@30|) HandleTypeType)) (= (type $h@@26) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@30| (Tclass._System.___hTotalFunc1OS |#$T0@@137| |#$R@@150|) $h@@26) ($IsAlloc |f#0@@30| (Tclass._System.___hPartialFunc1OS |#$T0@@137| |#$R@@150|) $h@@26)))
 :qid |unknown.0:0|
 :skolemid |1048|
 :pattern ( ($IsAlloc |f#0@@30| (Tclass._System.___hTotalFunc1OS |#$T0@@137| |#$R@@150|) $h@@26))
)))
(assert (forall ((arg0@@262 T@U) ) (! (= (type (Tclass._System.___hFunc0L arg0@@262)) TyType)
 :qid |funType:Tclass._System.___hFunc0L|
 :pattern ( (Tclass._System.___hFunc0L arg0@@262))
)))
(assert (forall ((|#$R@@151| T@U) ) (!  (=> (= (type |#$R@@151|) TyType) (and (= (Tag (Tclass._System.___hFunc0L |#$R@@151|)) Tagclass._System.___hFunc0L) (= (TagFamily (Tclass._System.___hFunc0L |#$R@@151|)) |tytagFamily$_#Func0L|)))
 :qid |unknown.0:0|
 :skolemid |1049|
 :pattern ( (Tclass._System.___hFunc0L |#$R@@151|))
)))
(assert (forall ((arg0@@263 T@U) ) (! (= (type (Tclass._System.___hFunc0L_0 arg0@@263)) TyType)
 :qid |funType:Tclass._System.___hFunc0L_0|
 :pattern ( (Tclass._System.___hFunc0L_0 arg0@@263))
)))
(assert (forall ((|#$R@@152| T@U) ) (!  (=> (= (type |#$R@@152|) TyType) (= (Tclass._System.___hFunc0L_0 (Tclass._System.___hFunc0L |#$R@@152|)) |#$R@@152|))
 :qid |unknown.0:0|
 :skolemid |1050|
 :pattern ( (Tclass._System.___hFunc0L |#$R@@152|))
)))
(assert (forall ((|#$R@@153| T@U) (bx@@77 T@U) ) (!  (=> (and (and (= (type |#$R@@153|) TyType) (= (type bx@@77) BoxType)) ($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|))) (and (= ($Box ($Unbox HandleTypeType bx@@77)) bx@@77) ($Is ($Unbox HandleTypeType bx@@77) (Tclass._System.___hFunc0L |#$R@@153|))))
 :qid |unknown.0:0|
 :skolemid |1051|
 :pattern ( ($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|)))
)))
(assert (forall ((arg0@@264 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0L arg0@@264)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0L|
 :pattern ( (Tclass._System.___hPartialFunc0L arg0@@264))
)))
(assert (forall ((|#$R@@154| T@U) ) (!  (=> (= (type |#$R@@154|) TyType) (and (= (Tag (Tclass._System.___hPartialFunc0L |#$R@@154|)) Tagclass._System.___hPartialFunc0L) (= (TagFamily (Tclass._System.___hPartialFunc0L |#$R@@154|)) |tytagFamily$_#PartialFunc0L|)))
 :qid |unknown.0:0|
 :skolemid |1052|
 :pattern ( (Tclass._System.___hPartialFunc0L |#$R@@154|))
)))
(assert (forall ((arg0@@265 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0L_0 arg0@@265)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0L_0|
 :pattern ( (Tclass._System.___hPartialFunc0L_0 arg0@@265))
)))
(assert (forall ((|#$R@@155| T@U) ) (!  (=> (= (type |#$R@@155|) TyType) (= (Tclass._System.___hPartialFunc0L_0 (Tclass._System.___hPartialFunc0L |#$R@@155|)) |#$R@@155|))
 :qid |unknown.0:0|
 :skolemid |1053|
 :pattern ( (Tclass._System.___hPartialFunc0L |#$R@@155|))
)))
(assert (forall ((|#$R@@156| T@U) (bx@@78 T@U) ) (!  (=> (and (and (= (type |#$R@@156|) TyType) (= (type bx@@78) BoxType)) ($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|))) (and (= ($Box ($Unbox HandleTypeType bx@@78)) bx@@78) ($Is ($Unbox HandleTypeType bx@@78) (Tclass._System.___hPartialFunc0L |#$R@@156|))))
 :qid |unknown.0:0|
 :skolemid |1054|
 :pattern ( ($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|)))
)))
(assert (forall ((|#$R@@157| T@U) (|f#0@@31| T@U) ) (!  (=> (and (= (type |#$R@@157|) TyType) (= (type |f#0@@31|) HandleTypeType)) (= ($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|))  (and ($Is |f#0@@31| (Tclass._System.___hFunc0L |#$R@@157|)) (|Set#Equal| (Reads0 |#$R@@157| $OneHeap |f#0@@31|) (|Set#Empty| BoxType)))))
 :qid |unknown.0:0|
 :skolemid |1055|
 :pattern ( ($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|)))
)))
(assert (forall ((|#$R@@158| T@U) (|f#0@@32| T@U) ($h@@27 T@U) ) (!  (=> (and (and (= (type |#$R@@158|) TyType) (= (type |f#0@@32|) HandleTypeType)) (= (type $h@@27) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@32| (Tclass._System.___hPartialFunc0L |#$R@@158|) $h@@27) ($IsAlloc |f#0@@32| (Tclass._System.___hFunc0L |#$R@@158|) $h@@27)))
 :qid |unknown.0:0|
 :skolemid |1056|
 :pattern ( ($IsAlloc |f#0@@32| (Tclass._System.___hPartialFunc0L |#$R@@158|) $h@@27))
)))
(assert (forall ((arg0@@266 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0L arg0@@266)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0L|
 :pattern ( (Tclass._System.___hTotalFunc0L arg0@@266))
)))
(assert (forall ((|#$R@@159| T@U) ) (!  (=> (= (type |#$R@@159|) TyType) (and (= (Tag (Tclass._System.___hTotalFunc0L |#$R@@159|)) Tagclass._System.___hTotalFunc0L) (= (TagFamily (Tclass._System.___hTotalFunc0L |#$R@@159|)) |tytagFamily$_#TotalFunc0L|)))
 :qid |unknown.0:0|
 :skolemid |1057|
 :pattern ( (Tclass._System.___hTotalFunc0L |#$R@@159|))
)))
(assert (forall ((arg0@@267 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0L_0 arg0@@267)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0L_0|
 :pattern ( (Tclass._System.___hTotalFunc0L_0 arg0@@267))
)))
(assert (forall ((|#$R@@160| T@U) ) (!  (=> (= (type |#$R@@160|) TyType) (= (Tclass._System.___hTotalFunc0L_0 (Tclass._System.___hTotalFunc0L |#$R@@160|)) |#$R@@160|))
 :qid |unknown.0:0|
 :skolemid |1058|
 :pattern ( (Tclass._System.___hTotalFunc0L |#$R@@160|))
)))
(assert (forall ((|#$R@@161| T@U) (bx@@79 T@U) ) (!  (=> (and (and (= (type |#$R@@161|) TyType) (= (type bx@@79) BoxType)) ($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|))) (and (= ($Box ($Unbox HandleTypeType bx@@79)) bx@@79) ($Is ($Unbox HandleTypeType bx@@79) (Tclass._System.___hTotalFunc0L |#$R@@161|))))
 :qid |unknown.0:0|
 :skolemid |1059|
 :pattern ( ($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|)))
)))
(assert (forall ((|#$R@@162| T@U) (|f#0@@33| T@U) ) (!  (=> (and (= (type |#$R@@162|) TyType) (= (type |f#0@@33|) HandleTypeType)) (= ($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|))  (and ($Is |f#0@@33| (Tclass._System.___hPartialFunc0L |#$R@@162|)) (Requires0 |#$R@@162| $OneHeap |f#0@@33|))))
 :qid |unknown.0:0|
 :skolemid |1060|
 :pattern ( ($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|)))
)))
(assert (forall ((|#$R@@163| T@U) (|f#0@@34| T@U) ($h@@28 T@U) ) (!  (=> (and (and (= (type |#$R@@163|) TyType) (= (type |f#0@@34|) HandleTypeType)) (= (type $h@@28) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@34| (Tclass._System.___hTotalFunc0L |#$R@@163|) $h@@28) ($IsAlloc |f#0@@34| (Tclass._System.___hPartialFunc0L |#$R@@163|) $h@@28)))
 :qid |unknown.0:0|
 :skolemid |1061|
 :pattern ( ($IsAlloc |f#0@@34| (Tclass._System.___hTotalFunc0L |#$R@@163|) $h@@28))
)))
(assert (forall ((arg0@@268 T@U) (arg1@@118 T@U) (arg2@@67 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO|
 :pattern ( (Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67))
)))
(assert (forall ((|#$T0@@138| T@U) (|#$T1@@106| T@U) (|#$R@@164| T@U) ) (!  (=> (and (and (= (type |#$T0@@138|) TyType) (= (type |#$T1@@106|) TyType)) (= (type |#$R@@164|) TyType)) (and (= (Tag (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|)) Tagclass._System.___hFunc2LOO) (= (TagFamily (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|)) |tytagFamily$_#Func2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1062|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|))
)))
(assert (forall ((arg0@@269 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_0 arg0@@269)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_0|
 :pattern ( (Tclass._System.___hFunc2LOO_0 arg0@@269))
)))
(assert (forall ((|#$T0@@139| T@U) (|#$T1@@107| T@U) (|#$R@@165| T@U) ) (!  (=> (and (and (= (type |#$T0@@139|) TyType) (= (type |#$T1@@107|) TyType)) (= (type |#$R@@165|) TyType)) (= (Tclass._System.___hFunc2LOO_0 (Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|)) |#$T0@@139|))
 :qid |unknown.0:0|
 :skolemid |1063|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|))
)))
(assert (forall ((arg0@@270 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_1 arg0@@270)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_1|
 :pattern ( (Tclass._System.___hFunc2LOO_1 arg0@@270))
)))
(assert (forall ((|#$T0@@140| T@U) (|#$T1@@108| T@U) (|#$R@@166| T@U) ) (!  (=> (and (and (= (type |#$T0@@140|) TyType) (= (type |#$T1@@108|) TyType)) (= (type |#$R@@166|) TyType)) (= (Tclass._System.___hFunc2LOO_1 (Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|)) |#$T1@@108|))
 :qid |unknown.0:0|
 :skolemid |1064|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|))
)))
(assert (forall ((arg0@@271 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_2 arg0@@271)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_2|
 :pattern ( (Tclass._System.___hFunc2LOO_2 arg0@@271))
)))
(assert (forall ((|#$T0@@141| T@U) (|#$T1@@109| T@U) (|#$R@@167| T@U) ) (!  (=> (and (and (= (type |#$T0@@141|) TyType) (= (type |#$T1@@109|) TyType)) (= (type |#$R@@167|) TyType)) (= (Tclass._System.___hFunc2LOO_2 (Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|)) |#$R@@167|))
 :qid |unknown.0:0|
 :skolemid |1065|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|))
)))
(assert (forall ((|#$T0@@142| T@U) (|#$T1@@110| T@U) (|#$R@@168| T@U) (bx@@80 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@142|) TyType) (= (type |#$T1@@110|) TyType)) (= (type |#$R@@168|) TyType)) (= (type bx@@80) BoxType)) ($IsBox bx@@80 (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|))) (and (= ($Box ($Unbox HandleTypeType bx@@80)) bx@@80) ($Is ($Unbox HandleTypeType bx@@80) (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|))))
 :qid |unknown.0:0|
 :skolemid |1066|
 :pattern ( ($IsBox bx@@80 (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|)))
)))
(assert (forall ((arg0@@272 T@U) (arg1@@119 T@U) (arg2@@68 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO|
 :pattern ( (Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68))
)))
(assert (forall ((|#$T0@@143| T@U) (|#$T1@@111| T@U) (|#$R@@169| T@U) ) (!  (=> (and (and (= (type |#$T0@@143|) TyType) (= (type |#$T1@@111|) TyType)) (= (type |#$R@@169|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|)) Tagclass._System.___hPartialFunc2LOO) (= (TagFamily (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|)) |tytagFamily$_#PartialFunc2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1067|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|))
)))
(assert (forall ((arg0@@273 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_0 arg0@@273)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_0|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_0 arg0@@273))
)))
(assert (forall ((|#$T0@@144| T@U) (|#$T1@@112| T@U) (|#$R@@170| T@U) ) (!  (=> (and (and (= (type |#$T0@@144|) TyType) (= (type |#$T1@@112|) TyType)) (= (type |#$R@@170|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_0 (Tclass._System.___hPartialFunc2LOO |#$T0@@144| |#$T1@@112| |#$R@@170|)) |#$T0@@144|))
 :qid |unknown.0:0|
 :skolemid |1068|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@144| |#$T1@@112| |#$R@@170|))
)))
(assert (forall ((arg0@@274 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_1 arg0@@274)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_1|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_1 arg0@@274))
)))
(assert (forall ((|#$T0@@145| T@U) (|#$T1@@113| T@U) (|#$R@@171| T@U) ) (!  (=> (and (and (= (type |#$T0@@145|) TyType) (= (type |#$T1@@113|) TyType)) (= (type |#$R@@171|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_1 (Tclass._System.___hPartialFunc2LOO |#$T0@@145| |#$T1@@113| |#$R@@171|)) |#$T1@@113|))
 :qid |unknown.0:0|
 :skolemid |1069|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@145| |#$T1@@113| |#$R@@171|))
)))
(assert (forall ((arg0@@275 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_2 arg0@@275)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_2|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_2 arg0@@275))
)))
(assert (forall ((|#$T0@@146| T@U) (|#$T1@@114| T@U) (|#$R@@172| T@U) ) (!  (=> (and (and (= (type |#$T0@@146|) TyType) (= (type |#$T1@@114|) TyType)) (= (type |#$R@@172|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_2 (Tclass._System.___hPartialFunc2LOO |#$T0@@146| |#$T1@@114| |#$R@@172|)) |#$R@@172|))
 :qid |unknown.0:0|
 :skolemid |1070|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@146| |#$T1@@114| |#$R@@172|))
)))
(assert (forall ((|#$T0@@147| T@U) (|#$T1@@115| T@U) (|#$R@@173| T@U) (bx@@81 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@147|) TyType) (= (type |#$T1@@115|) TyType)) (= (type |#$R@@173|) TyType)) (= (type bx@@81) BoxType)) ($IsBox bx@@81 (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|))) (and (= ($Box ($Unbox HandleTypeType bx@@81)) bx@@81) ($Is ($Unbox HandleTypeType bx@@81) (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|))))
 :qid |unknown.0:0|
 :skolemid |1071|
 :pattern ( ($IsBox bx@@81 (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|)))
)))
(assert (forall ((|#$T0@@148| T@U) (|#$T1@@116| T@U) (|#$R@@174| T@U) (|f#0@@35| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@148|) TyType) (= (type |#$T1@@116|) TyType)) (= (type |#$R@@174|) TyType)) (= (type |f#0@@35|) HandleTypeType)) (= ($Is |f#0@@35| (Tclass._System.___hPartialFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|))  (and ($Is |f#0@@35| (Tclass._System.___hFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|)) (forall ((|x0#0@@13| T@U) (|x1#0@@9| T@U) ) (!  (=> (and (and (= (type |x0#0@@13|) BoxType) (= (type |x1#0@@9|) BoxType)) (and ($IsBox |x0#0@@13| |#$T0@@148|) ($IsBox |x1#0@@9| |#$T1@@116|))) (|Set#Equal| (Reads2 |#$T0@@148| |#$T1@@116| |#$R@@174| $OneHeap |f#0@@35| |x0#0@@13| |x1#0@@9|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1072|
 :no-pattern (type |x0#0@@13|)
 :no-pattern (type |x1#0@@9|)
 :no-pattern (U_2_int |x0#0@@13|)
 :no-pattern (U_2_bool |x0#0@@13|)
 :no-pattern (U_2_int |x1#0@@9|)
 :no-pattern (U_2_bool |x1#0@@9|)
)))))
 :qid |unknown.0:0|
 :skolemid |1073|
 :pattern ( ($Is |f#0@@35| (Tclass._System.___hPartialFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|)))
)))
(assert (forall ((|#$T0@@149| T@U) (|#$T1@@117| T@U) (|#$R@@175| T@U) (|f#0@@36| T@U) ($h@@29 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@149|) TyType) (= (type |#$T1@@117|) TyType)) (= (type |#$R@@175|) TyType)) (= (type |f#0@@36|) HandleTypeType)) (= (type $h@@29) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@36| (Tclass._System.___hPartialFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29) ($IsAlloc |f#0@@36| (Tclass._System.___hFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29)))
 :qid |unknown.0:0|
 :skolemid |1074|
 :pattern ( ($IsAlloc |f#0@@36| (Tclass._System.___hPartialFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29))
)))
(assert (forall ((arg0@@276 T@U) (arg1@@120 T@U) (arg2@@69 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO|
 :pattern ( (Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69))
)))
(assert (forall ((|#$T0@@150| T@U) (|#$T1@@118| T@U) (|#$R@@176| T@U) ) (!  (=> (and (and (= (type |#$T0@@150|) TyType) (= (type |#$T1@@118|) TyType)) (= (type |#$R@@176|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|)) Tagclass._System.___hTotalFunc2LOO) (= (TagFamily (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|)) |tytagFamily$_#TotalFunc2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1075|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|))
)))
(assert (forall ((arg0@@277 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_0 arg0@@277)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_0|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_0 arg0@@277))
)))
(assert (forall ((|#$T0@@151| T@U) (|#$T1@@119| T@U) (|#$R@@177| T@U) ) (!  (=> (and (and (= (type |#$T0@@151|) TyType) (= (type |#$T1@@119|) TyType)) (= (type |#$R@@177|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_0 (Tclass._System.___hTotalFunc2LOO |#$T0@@151| |#$T1@@119| |#$R@@177|)) |#$T0@@151|))
 :qid |unknown.0:0|
 :skolemid |1076|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@151| |#$T1@@119| |#$R@@177|))
)))
(assert (forall ((arg0@@278 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_1 arg0@@278)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_1|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_1 arg0@@278))
)))
(assert (forall ((|#$T0@@152| T@U) (|#$T1@@120| T@U) (|#$R@@178| T@U) ) (!  (=> (and (and (= (type |#$T0@@152|) TyType) (= (type |#$T1@@120|) TyType)) (= (type |#$R@@178|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_1 (Tclass._System.___hTotalFunc2LOO |#$T0@@152| |#$T1@@120| |#$R@@178|)) |#$T1@@120|))
 :qid |unknown.0:0|
 :skolemid |1077|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@152| |#$T1@@120| |#$R@@178|))
)))
(assert (forall ((arg0@@279 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_2 arg0@@279)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_2|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_2 arg0@@279))
)))
(assert (forall ((|#$T0@@153| T@U) (|#$T1@@121| T@U) (|#$R@@179| T@U) ) (!  (=> (and (and (= (type |#$T0@@153|) TyType) (= (type |#$T1@@121|) TyType)) (= (type |#$R@@179|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_2 (Tclass._System.___hTotalFunc2LOO |#$T0@@153| |#$T1@@121| |#$R@@179|)) |#$R@@179|))
 :qid |unknown.0:0|
 :skolemid |1078|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@153| |#$T1@@121| |#$R@@179|))
)))
(assert (forall ((|#$T0@@154| T@U) (|#$T1@@122| T@U) (|#$R@@180| T@U) (bx@@82 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@154|) TyType) (= (type |#$T1@@122|) TyType)) (= (type |#$R@@180|) TyType)) (= (type bx@@82) BoxType)) ($IsBox bx@@82 (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|))) (and (= ($Box ($Unbox HandleTypeType bx@@82)) bx@@82) ($Is ($Unbox HandleTypeType bx@@82) (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|))))
 :qid |unknown.0:0|
 :skolemid |1079|
 :pattern ( ($IsBox bx@@82 (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|)))
)))
(assert (forall ((|#$T0@@155| T@U) (|#$T1@@123| T@U) (|#$R@@181| T@U) (|f#0@@37| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@155|) TyType) (= (type |#$T1@@123|) TyType)) (= (type |#$R@@181|) TyType)) (= (type |f#0@@37|) HandleTypeType)) (= ($Is |f#0@@37| (Tclass._System.___hTotalFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|))  (and ($Is |f#0@@37| (Tclass._System.___hPartialFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|)) (forall ((|x0#0@@14| T@U) (|x1#0@@10| T@U) ) (!  (=> (and (and (= (type |x0#0@@14|) BoxType) (= (type |x1#0@@10|) BoxType)) (and ($IsBox |x0#0@@14| |#$T0@@155|) ($IsBox |x1#0@@10| |#$T1@@123|))) (Requires2 |#$T0@@155| |#$T1@@123| |#$R@@181| $OneHeap |f#0@@37| |x0#0@@14| |x1#0@@10|))
 :qid |unknown.0:0|
 :skolemid |1080|
 :no-pattern (type |x0#0@@14|)
 :no-pattern (type |x1#0@@10|)
 :no-pattern (U_2_int |x0#0@@14|)
 :no-pattern (U_2_bool |x0#0@@14|)
 :no-pattern (U_2_int |x1#0@@10|)
 :no-pattern (U_2_bool |x1#0@@10|)
)))))
 :qid |unknown.0:0|
 :skolemid |1081|
 :pattern ( ($Is |f#0@@37| (Tclass._System.___hTotalFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|)))
)))
(assert (forall ((|#$T0@@156| T@U) (|#$T1@@124| T@U) (|#$R@@182| T@U) (|f#0@@38| T@U) ($h@@30 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@156|) TyType) (= (type |#$T1@@124|) TyType)) (= (type |#$R@@182|) TyType)) (= (type |f#0@@38|) HandleTypeType)) (= (type $h@@30) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@38| (Tclass._System.___hTotalFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30) ($IsAlloc |f#0@@38| (Tclass._System.___hPartialFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30)))
 :qid |unknown.0:0|
 :skolemid |1082|
 :pattern ( ($IsAlloc |f#0@@38| (Tclass._System.___hTotalFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30))
)))
(assert (= (type |#_System._tuple#0._#Make0|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#_System._tuple#0._#Make0|) |##_System._tuple#0._#Make0|))
(assert (forall ((d@@6 T@U) ) (!  (=> (= (type d@@6) DatatypeTypeType) (= (_System.Tuple0.___hMake0_q d@@6) (= (DatatypeCtorId d@@6) |##_System._tuple#0._#Make0|)))
 :qid |unknown.0:0|
 :skolemid |1083|
 :pattern ( (_System.Tuple0.___hMake0_q d@@6))
)))
(assert (forall ((d@@7 T@U) ) (!  (=> (and (= (type d@@7) DatatypeTypeType) (_System.Tuple0.___hMake0_q d@@7)) (= d@@7 |#_System._tuple#0._#Make0|))
 :qid |unknown.0:0|
 :skolemid |1084|
 :pattern ( (_System.Tuple0.___hMake0_q d@@7))
)))
(assert (= (type Tclass._System.Tuple0) TyType))
(assert (= (Tag Tclass._System.Tuple0) Tagclass._System.Tuple0))
(assert (= (TagFamily Tclass._System.Tuple0) |tytagFamily$_tuple#0|))
(assert (forall ((bx@@83 T@U) ) (!  (=> (and (= (type bx@@83) BoxType) ($IsBox bx@@83 Tclass._System.Tuple0)) (and (= ($Box ($Unbox DatatypeTypeType bx@@83)) bx@@83) ($Is ($Unbox DatatypeTypeType bx@@83) Tclass._System.Tuple0)))
 :qid |unknown.0:0|
 :skolemid |1085|
 :pattern ( ($IsBox bx@@83 Tclass._System.Tuple0))
)))
(assert ($Is |#_System._tuple#0._#Make0| Tclass._System.Tuple0))
(assert (forall (($h@@31 T@U) ) (!  (=> (and (= (type $h@@31) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@31)) ($IsAlloc |#_System._tuple#0._#Make0| Tclass._System.Tuple0 $h@@31))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |1086|
 :pattern ( ($IsAlloc |#_System._tuple#0._#Make0| Tclass._System.Tuple0 $h@@31))
)))
(assert (= |#_System._tuple#0._#Make0| (Lit |#_System._tuple#0._#Make0|)))
(assert (forall ((d@@8 T@U) ) (!  (=> (and (= (type d@@8) DatatypeTypeType) (|$IsA#_System.Tuple0| d@@8)) (_System.Tuple0.___hMake0_q d@@8))
 :qid |unknown.0:0|
 :skolemid |1087|
 :pattern ( (|$IsA#_System.Tuple0| d@@8))
)))
(assert (forall ((d@@9 T@U) ) (!  (=> (and (= (type d@@9) DatatypeTypeType) ($Is d@@9 Tclass._System.Tuple0)) (_System.Tuple0.___hMake0_q d@@9))
 :qid |unknown.0:0|
 :skolemid |1088|
 :pattern ( (_System.Tuple0.___hMake0_q d@@9) ($Is d@@9 Tclass._System.Tuple0))
)))
(assert (forall ((a@@114 T@U) (b@@63 T@U) ) (!  (=> (and (and (= (type a@@114) DatatypeTypeType) (= (type b@@63) DatatypeTypeType)) true) (= (|_System.Tuple0#Equal| a@@114 b@@63) true))
 :qid |unknown.0:0|
 :skolemid |1089|
 :pattern ( (|_System.Tuple0#Equal| a@@114 b@@63))
)))
(assert (forall ((a@@115 T@U) (b@@64 T@U) ) (!  (=> (and (= (type a@@115) DatatypeTypeType) (= (type b@@64) DatatypeTypeType)) (= (|_System.Tuple0#Equal| a@@115 b@@64) (= a@@115 b@@64)))
 :qid |unknown.0:0|
 :skolemid |1090|
 :pattern ( (|_System.Tuple0#Equal| a@@115 b@@64))
)))
(assert (forall ((arg0@@280 T@U) (arg1@@121 T@U) ) (! (= (type (Tclass._System.___hFunc1OL arg0@@280 arg1@@121)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL|
 :pattern ( (Tclass._System.___hFunc1OL arg0@@280 arg1@@121))
)))
(assert (forall ((|#$T0@@157| T@U) (|#$R@@183| T@U) ) (!  (=> (and (= (type |#$T0@@157|) TyType) (= (type |#$R@@183|) TyType)) (and (= (Tag (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|)) Tagclass._System.___hFunc1OL) (= (TagFamily (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|)) |tytagFamily$_#Func1OL|)))
 :qid |unknown.0:0|
 :skolemid |1091|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|))
)))
(assert (forall ((arg0@@281 T@U) ) (! (= (type (Tclass._System.___hFunc1OL_0 arg0@@281)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL_0|
 :pattern ( (Tclass._System.___hFunc1OL_0 arg0@@281))
)))
(assert (forall ((|#$T0@@158| T@U) (|#$R@@184| T@U) ) (!  (=> (and (= (type |#$T0@@158|) TyType) (= (type |#$R@@184|) TyType)) (= (Tclass._System.___hFunc1OL_0 (Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|)) |#$T0@@158|))
 :qid |unknown.0:0|
 :skolemid |1092|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|))
)))
(assert (forall ((arg0@@282 T@U) ) (! (= (type (Tclass._System.___hFunc1OL_1 arg0@@282)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL_1|
 :pattern ( (Tclass._System.___hFunc1OL_1 arg0@@282))
)))
(assert (forall ((|#$T0@@159| T@U) (|#$R@@185| T@U) ) (!  (=> (and (= (type |#$T0@@159|) TyType) (= (type |#$R@@185|) TyType)) (= (Tclass._System.___hFunc1OL_1 (Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|)) |#$R@@185|))
 :qid |unknown.0:0|
 :skolemid |1093|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|))
)))
(assert (forall ((|#$T0@@160| T@U) (|#$R@@186| T@U) (bx@@84 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@160|) TyType) (= (type |#$R@@186|) TyType)) (= (type bx@@84) BoxType)) ($IsBox bx@@84 (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|))) (and (= ($Box ($Unbox HandleTypeType bx@@84)) bx@@84) ($Is ($Unbox HandleTypeType bx@@84) (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|))))
 :qid |unknown.0:0|
 :skolemid |1094|
 :pattern ( ($IsBox bx@@84 (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|)))
)))
(assert (forall ((arg0@@283 T@U) (arg1@@122 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL|
 :pattern ( (Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122))
)))
(assert (forall ((|#$T0@@161| T@U) (|#$R@@187| T@U) ) (!  (=> (and (= (type |#$T0@@161|) TyType) (= (type |#$R@@187|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|)) Tagclass._System.___hPartialFunc1OL) (= (TagFamily (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|)) |tytagFamily$_#PartialFunc1OL|)))
 :qid |unknown.0:0|
 :skolemid |1095|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|))
)))
(assert (forall ((arg0@@284 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL_0 arg0@@284)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL_0|
 :pattern ( (Tclass._System.___hPartialFunc1OL_0 arg0@@284))
)))
(assert (forall ((|#$T0@@162| T@U) (|#$R@@188| T@U) ) (!  (=> (and (= (type |#$T0@@162|) TyType) (= (type |#$R@@188|) TyType)) (= (Tclass._System.___hPartialFunc1OL_0 (Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|)) |#$T0@@162|))
 :qid |unknown.0:0|
 :skolemid |1096|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|))
)))
(assert (forall ((arg0@@285 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL_1 arg0@@285)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL_1|
 :pattern ( (Tclass._System.___hPartialFunc1OL_1 arg0@@285))
)))
(assert (forall ((|#$T0@@163| T@U) (|#$R@@189| T@U) ) (!  (=> (and (= (type |#$T0@@163|) TyType) (= (type |#$R@@189|) TyType)) (= (Tclass._System.___hPartialFunc1OL_1 (Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|)) |#$R@@189|))
 :qid |unknown.0:0|
 :skolemid |1097|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|))
)))
(assert (forall ((|#$T0@@164| T@U) (|#$R@@190| T@U) (bx@@85 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@164|) TyType) (= (type |#$R@@190|) TyType)) (= (type bx@@85) BoxType)) ($IsBox bx@@85 (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|))) (and (= ($Box ($Unbox HandleTypeType bx@@85)) bx@@85) ($Is ($Unbox HandleTypeType bx@@85) (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|))))
 :qid |unknown.0:0|
 :skolemid |1098|
 :pattern ( ($IsBox bx@@85 (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|)))
)))
(assert (forall ((|#$T0@@165| T@U) (|#$R@@191| T@U) (|f#0@@39| T@U) ) (!  (=> (and (and (= (type |#$T0@@165|) TyType) (= (type |#$R@@191|) TyType)) (= (type |f#0@@39|) HandleTypeType)) (= ($Is |f#0@@39| (Tclass._System.___hPartialFunc1OL |#$T0@@165| |#$R@@191|))  (and ($Is |f#0@@39| (Tclass._System.___hFunc1OL |#$T0@@165| |#$R@@191|)) (forall ((|x0#0@@15| T@U) ) (!  (=> (and (= (type |x0#0@@15|) BoxType) ($IsBox |x0#0@@15| |#$T0@@165|)) (|Set#Equal| (Reads1 |#$T0@@165| |#$R@@191| $OneHeap |f#0@@39| |x0#0@@15|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1099|
 :no-pattern (type |x0#0@@15|)
 :no-pattern (U_2_int |x0#0@@15|)
 :no-pattern (U_2_bool |x0#0@@15|)
)))))
 :qid |unknown.0:0|
 :skolemid |1100|
 :pattern ( ($Is |f#0@@39| (Tclass._System.___hPartialFunc1OL |#$T0@@165| |#$R@@191|)))
)))
(assert (forall ((|#$T0@@166| T@U) (|#$R@@192| T@U) (|f#0@@40| T@U) ($h@@32 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@166|) TyType) (= (type |#$R@@192|) TyType)) (= (type |f#0@@40|) HandleTypeType)) (= (type $h@@32) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@40| (Tclass._System.___hPartialFunc1OL |#$T0@@166| |#$R@@192|) $h@@32) ($IsAlloc |f#0@@40| (Tclass._System.___hFunc1OL |#$T0@@166| |#$R@@192|) $h@@32)))
 :qid |unknown.0:0|
 :skolemid |1101|
 :pattern ( ($IsAlloc |f#0@@40| (Tclass._System.___hPartialFunc1OL |#$T0@@166| |#$R@@192|) $h@@32))
)))
(assert (forall ((arg0@@286 T@U) (arg1@@123 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL|
 :pattern ( (Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123))
)))
(assert (forall ((|#$T0@@167| T@U) (|#$R@@193| T@U) ) (!  (=> (and (= (type |#$T0@@167|) TyType) (= (type |#$R@@193|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|)) Tagclass._System.___hTotalFunc1OL) (= (TagFamily (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|)) |tytagFamily$_#TotalFunc1OL|)))
 :qid |unknown.0:0|
 :skolemid |1102|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|))
)))
(assert (forall ((arg0@@287 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL_0 arg0@@287)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL_0|
 :pattern ( (Tclass._System.___hTotalFunc1OL_0 arg0@@287))
)))
(assert (forall ((|#$T0@@168| T@U) (|#$R@@194| T@U) ) (!  (=> (and (= (type |#$T0@@168|) TyType) (= (type |#$R@@194|) TyType)) (= (Tclass._System.___hTotalFunc1OL_0 (Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|)) |#$T0@@168|))
 :qid |unknown.0:0|
 :skolemid |1103|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|))
)))
(assert (forall ((arg0@@288 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL_1 arg0@@288)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL_1|
 :pattern ( (Tclass._System.___hTotalFunc1OL_1 arg0@@288))
)))
(assert (forall ((|#$T0@@169| T@U) (|#$R@@195| T@U) ) (!  (=> (and (= (type |#$T0@@169|) TyType) (= (type |#$R@@195|) TyType)) (= (Tclass._System.___hTotalFunc1OL_1 (Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|)) |#$R@@195|))
 :qid |unknown.0:0|
 :skolemid |1104|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|))
)))
(assert (forall ((|#$T0@@170| T@U) (|#$R@@196| T@U) (bx@@86 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@170|) TyType) (= (type |#$R@@196|) TyType)) (= (type bx@@86) BoxType)) ($IsBox bx@@86 (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|))) (and (= ($Box ($Unbox HandleTypeType bx@@86)) bx@@86) ($Is ($Unbox HandleTypeType bx@@86) (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|))))
 :qid |unknown.0:0|
 :skolemid |1105|
 :pattern ( ($IsBox bx@@86 (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|)))
)))
(assert (forall ((|#$T0@@171| T@U) (|#$R@@197| T@U) (|f#0@@41| T@U) ) (!  (=> (and (and (= (type |#$T0@@171|) TyType) (= (type |#$R@@197|) TyType)) (= (type |f#0@@41|) HandleTypeType)) (= ($Is |f#0@@41| (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|))  (and ($Is |f#0@@41| (Tclass._System.___hPartialFunc1OL |#$T0@@171| |#$R@@197|)) (forall ((|x0#0@@16| T@U) ) (!  (=> (and (= (type |x0#0@@16|) BoxType) ($IsBox |x0#0@@16| |#$T0@@171|)) (Requires1 |#$T0@@171| |#$R@@197| $OneHeap |f#0@@41| |x0#0@@16|))
 :qid |unknown.0:0|
 :skolemid |1106|
 :no-pattern (type |x0#0@@16|)
 :no-pattern (U_2_int |x0#0@@16|)
 :no-pattern (U_2_bool |x0#0@@16|)
)))))
 :qid |unknown.0:0|
 :skolemid |1107|
 :pattern ( ($Is |f#0@@41| (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|)))
)))
(assert (forall ((|#$T0@@172| T@U) (|#$R@@198| T@U) (|f#0@@42| T@U) ($h@@33 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@172|) TyType) (= (type |#$R@@198|) TyType)) (= (type |f#0@@42|) HandleTypeType)) (= (type $h@@33) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@42| (Tclass._System.___hTotalFunc1OL |#$T0@@172| |#$R@@198|) $h@@33) ($IsAlloc |f#0@@42| (Tclass._System.___hPartialFunc1OL |#$T0@@172| |#$R@@198|) $h@@33)))
 :qid |unknown.0:0|
 :skolemid |1108|
 :pattern ( ($IsAlloc |f#0@@42| (Tclass._System.___hTotalFunc1OL |#$T0@@172| |#$R@@198|) $h@@33))
)))
(assert (forall ((arg0@@289 T@U) (arg1@@124 T@U) ) (! (= (type (Tclass._System.___hFunc1LO arg0@@289 arg1@@124)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO|
 :pattern ( (Tclass._System.___hFunc1LO arg0@@289 arg1@@124))
)))
(assert (forall ((|#$T0@@173| T@U) (|#$R@@199| T@U) ) (!  (=> (and (= (type |#$T0@@173|) TyType) (= (type |#$R@@199|) TyType)) (and (= (Tag (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|)) Tagclass._System.___hFunc1LO) (= (TagFamily (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|)) |tytagFamily$_#Func1LO|)))
 :qid |unknown.0:0|
 :skolemid |1109|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|))
)))
(assert (forall ((arg0@@290 T@U) ) (! (= (type (Tclass._System.___hFunc1LO_0 arg0@@290)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO_0|
 :pattern ( (Tclass._System.___hFunc1LO_0 arg0@@290))
)))
(assert (forall ((|#$T0@@174| T@U) (|#$R@@200| T@U) ) (!  (=> (and (= (type |#$T0@@174|) TyType) (= (type |#$R@@200|) TyType)) (= (Tclass._System.___hFunc1LO_0 (Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|)) |#$T0@@174|))
 :qid |unknown.0:0|
 :skolemid |1110|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|))
)))
(assert (forall ((arg0@@291 T@U) ) (! (= (type (Tclass._System.___hFunc1LO_1 arg0@@291)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO_1|
 :pattern ( (Tclass._System.___hFunc1LO_1 arg0@@291))
)))
(assert (forall ((|#$T0@@175| T@U) (|#$R@@201| T@U) ) (!  (=> (and (= (type |#$T0@@175|) TyType) (= (type |#$R@@201|) TyType)) (= (Tclass._System.___hFunc1LO_1 (Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|)) |#$R@@201|))
 :qid |unknown.0:0|
 :skolemid |1111|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|))
)))
(assert (forall ((|#$T0@@176| T@U) (|#$R@@202| T@U) (bx@@87 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@176|) TyType) (= (type |#$R@@202|) TyType)) (= (type bx@@87) BoxType)) ($IsBox bx@@87 (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|))) (and (= ($Box ($Unbox HandleTypeType bx@@87)) bx@@87) ($Is ($Unbox HandleTypeType bx@@87) (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|))))
 :qid |unknown.0:0|
 :skolemid |1112|
 :pattern ( ($IsBox bx@@87 (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|)))
)))
(assert (forall ((arg0@@292 T@U) (arg1@@125 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO|
 :pattern ( (Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125))
)))
(assert (forall ((|#$T0@@177| T@U) (|#$R@@203| T@U) ) (!  (=> (and (= (type |#$T0@@177|) TyType) (= (type |#$R@@203|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|)) Tagclass._System.___hPartialFunc1LO) (= (TagFamily (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|)) |tytagFamily$_#PartialFunc1LO|)))
 :qid |unknown.0:0|
 :skolemid |1113|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|))
)))
(assert (forall ((arg0@@293 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO_0 arg0@@293)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO_0|
 :pattern ( (Tclass._System.___hPartialFunc1LO_0 arg0@@293))
)))
(assert (forall ((|#$T0@@178| T@U) (|#$R@@204| T@U) ) (!  (=> (and (= (type |#$T0@@178|) TyType) (= (type |#$R@@204|) TyType)) (= (Tclass._System.___hPartialFunc1LO_0 (Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|)) |#$T0@@178|))
 :qid |unknown.0:0|
 :skolemid |1114|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|))
)))
(assert (forall ((arg0@@294 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO_1 arg0@@294)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO_1|
 :pattern ( (Tclass._System.___hPartialFunc1LO_1 arg0@@294))
)))
(assert (forall ((|#$T0@@179| T@U) (|#$R@@205| T@U) ) (!  (=> (and (= (type |#$T0@@179|) TyType) (= (type |#$R@@205|) TyType)) (= (Tclass._System.___hPartialFunc1LO_1 (Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|)) |#$R@@205|))
 :qid |unknown.0:0|
 :skolemid |1115|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|))
)))
(assert (forall ((|#$T0@@180| T@U) (|#$R@@206| T@U) (bx@@88 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@180|) TyType) (= (type |#$R@@206|) TyType)) (= (type bx@@88) BoxType)) ($IsBox bx@@88 (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|))) (and (= ($Box ($Unbox HandleTypeType bx@@88)) bx@@88) ($Is ($Unbox HandleTypeType bx@@88) (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|))))
 :qid |unknown.0:0|
 :skolemid |1116|
 :pattern ( ($IsBox bx@@88 (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|)))
)))
(assert (forall ((|#$T0@@181| T@U) (|#$R@@207| T@U) (|f#0@@43| T@U) ) (!  (=> (and (and (= (type |#$T0@@181|) TyType) (= (type |#$R@@207|) TyType)) (= (type |f#0@@43|) HandleTypeType)) (= ($Is |f#0@@43| (Tclass._System.___hPartialFunc1LO |#$T0@@181| |#$R@@207|))  (and ($Is |f#0@@43| (Tclass._System.___hFunc1LO |#$T0@@181| |#$R@@207|)) (forall ((|x0#0@@17| T@U) ) (!  (=> (and (= (type |x0#0@@17|) BoxType) ($IsBox |x0#0@@17| |#$T0@@181|)) (|Set#Equal| (Reads1 |#$T0@@181| |#$R@@207| $OneHeap |f#0@@43| |x0#0@@17|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1117|
 :no-pattern (type |x0#0@@17|)
 :no-pattern (U_2_int |x0#0@@17|)
 :no-pattern (U_2_bool |x0#0@@17|)
)))))
 :qid |unknown.0:0|
 :skolemid |1118|
 :pattern ( ($Is |f#0@@43| (Tclass._System.___hPartialFunc1LO |#$T0@@181| |#$R@@207|)))
)))
(assert (forall ((|#$T0@@182| T@U) (|#$R@@208| T@U) (|f#0@@44| T@U) ($h@@34 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@182|) TyType) (= (type |#$R@@208|) TyType)) (= (type |f#0@@44|) HandleTypeType)) (= (type $h@@34) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@44| (Tclass._System.___hPartialFunc1LO |#$T0@@182| |#$R@@208|) $h@@34) ($IsAlloc |f#0@@44| (Tclass._System.___hFunc1LO |#$T0@@182| |#$R@@208|) $h@@34)))
 :qid |unknown.0:0|
 :skolemid |1119|
 :pattern ( ($IsAlloc |f#0@@44| (Tclass._System.___hPartialFunc1LO |#$T0@@182| |#$R@@208|) $h@@34))
)))
(assert (forall ((arg0@@295 T@U) (arg1@@126 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO|
 :pattern ( (Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126))
)))
(assert (forall ((|#$T0@@183| T@U) (|#$R@@209| T@U) ) (!  (=> (and (= (type |#$T0@@183|) TyType) (= (type |#$R@@209|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|)) Tagclass._System.___hTotalFunc1LO) (= (TagFamily (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|)) |tytagFamily$_#TotalFunc1LO|)))
 :qid |unknown.0:0|
 :skolemid |1120|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|))
)))
(assert (forall ((arg0@@296 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO_0 arg0@@296)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO_0|
 :pattern ( (Tclass._System.___hTotalFunc1LO_0 arg0@@296))
)))
(assert (forall ((|#$T0@@184| T@U) (|#$R@@210| T@U) ) (!  (=> (and (= (type |#$T0@@184|) TyType) (= (type |#$R@@210|) TyType)) (= (Tclass._System.___hTotalFunc1LO_0 (Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|)) |#$T0@@184|))
 :qid |unknown.0:0|
 :skolemid |1121|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|))
)))
(assert (forall ((arg0@@297 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO_1 arg0@@297)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO_1|
 :pattern ( (Tclass._System.___hTotalFunc1LO_1 arg0@@297))
)))
(assert (forall ((|#$T0@@185| T@U) (|#$R@@211| T@U) ) (!  (=> (and (= (type |#$T0@@185|) TyType) (= (type |#$R@@211|) TyType)) (= (Tclass._System.___hTotalFunc1LO_1 (Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|)) |#$R@@211|))
 :qid |unknown.0:0|
 :skolemid |1122|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|))
)))
(assert (forall ((|#$T0@@186| T@U) (|#$R@@212| T@U) (bx@@89 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@186|) TyType) (= (type |#$R@@212|) TyType)) (= (type bx@@89) BoxType)) ($IsBox bx@@89 (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|))) (and (= ($Box ($Unbox HandleTypeType bx@@89)) bx@@89) ($Is ($Unbox HandleTypeType bx@@89) (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|))))
 :qid |unknown.0:0|
 :skolemid |1123|
 :pattern ( ($IsBox bx@@89 (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|)))
)))
(assert (forall ((|#$T0@@187| T@U) (|#$R@@213| T@U) (|f#0@@45| T@U) ) (!  (=> (and (and (= (type |#$T0@@187|) TyType) (= (type |#$R@@213|) TyType)) (= (type |f#0@@45|) HandleTypeType)) (= ($Is |f#0@@45| (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|))  (and ($Is |f#0@@45| (Tclass._System.___hPartialFunc1LO |#$T0@@187| |#$R@@213|)) (forall ((|x0#0@@18| T@U) ) (!  (=> (and (= (type |x0#0@@18|) BoxType) ($IsBox |x0#0@@18| |#$T0@@187|)) (Requires1 |#$T0@@187| |#$R@@213| $OneHeap |f#0@@45| |x0#0@@18|))
 :qid |unknown.0:0|
 :skolemid |1124|
 :no-pattern (type |x0#0@@18|)
 :no-pattern (U_2_int |x0#0@@18|)
 :no-pattern (U_2_bool |x0#0@@18|)
)))))
 :qid |unknown.0:0|
 :skolemid |1125|
 :pattern ( ($Is |f#0@@45| (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|)))
)))
(assert (forall ((|#$T0@@188| T@U) (|#$R@@214| T@U) (|f#0@@46| T@U) ($h@@35 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@188|) TyType) (= (type |#$R@@214|) TyType)) (= (type |f#0@@46|) HandleTypeType)) (= (type $h@@35) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@46| (Tclass._System.___hTotalFunc1LO |#$T0@@188| |#$R@@214|) $h@@35) ($IsAlloc |f#0@@46| (Tclass._System.___hPartialFunc1LO |#$T0@@188| |#$R@@214|) $h@@35)))
 :qid |unknown.0:0|
 :skolemid |1126|
 :pattern ( ($IsAlloc |f#0@@46| (Tclass._System.___hTotalFunc1LO |#$T0@@188| |#$R@@214|) $h@@35))
)))
(assert (forall ((arg0@@298 T@U) (arg1@@127 T@U) ) (! (= (type (|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127)) DatatypeTypeType)
 :qid |funType:#_System._tuple#2OLL._#Make2|
 :pattern ( (|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127))
)))
(assert (forall ((|a#14#0#0| T@U) (|a#14#1#0| T@U) ) (!  (=> (and (= (type |a#14#0#0|) BoxType) (= (type |a#14#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2OLL._#Make2| |a#14#0#0| |a#14#1#0|)) |##_System._tuple#2OLL._#Make2|))
 :qid |unknown.0:0|
 :skolemid |1127|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#14#0#0| |a#14#1#0|))
)))
(assert (forall ((d@@10 T@U) ) (!  (=> (= (type d@@10) DatatypeTypeType) (= (_System.Tuple2OLL.___hMake2_q d@@10) (= (DatatypeCtorId d@@10) |##_System._tuple#2OLL._#Make2|)))
 :qid |unknown.0:0|
 :skolemid |1128|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@10))
)))
(assert (forall ((d@@11 T@U) ) (!  (=> (and (= (type d@@11) DatatypeTypeType) (_System.Tuple2OLL.___hMake2_q d@@11)) (exists ((|a#15#0#0| T@U) (|a#15#1#0| T@U) ) (!  (and (and (= (type |a#15#0#0|) BoxType) (= (type |a#15#1#0|) BoxType)) (= d@@11 (|#_System._tuple#2OLL._#Make2| |a#15#0#0| |a#15#1#0|)))
 :qid |unknown.0:0|
 :skolemid |1129|
 :no-pattern (type |a#15#0#0|)
 :no-pattern (type |a#15#1#0|)
 :no-pattern (U_2_int |a#15#0#0|)
 :no-pattern (U_2_bool |a#15#0#0|)
 :no-pattern (U_2_int |a#15#1#0|)
 :no-pattern (U_2_bool |a#15#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1130|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@11))
)))
(assert (forall ((arg0@@299 T@U) (arg1@@128 T@U) ) (! (= (type (Tclass._System.Tuple2OLL arg0@@299 arg1@@128)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL|
 :pattern ( (Tclass._System.Tuple2OLL arg0@@299 arg1@@128))
)))
(assert (forall ((|_System._tuple#2OLL$T0| T@U) (|_System._tuple#2OLL$T1| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0|) TyType) (= (type |_System._tuple#2OLL$T1|) TyType)) (and (= (Tag (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|)) Tagclass._System.Tuple2OLL) (= (TagFamily (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|)) |tytagFamily$_tuple#2OLL|)))
 :qid |unknown.0:0|
 :skolemid |1131|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|))
)))
(assert (forall ((arg0@@300 T@U) ) (! (= (type (Tclass._System.Tuple2OLL_0 arg0@@300)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL_0|
 :pattern ( (Tclass._System.Tuple2OLL_0 arg0@@300))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@0| T@U) (|_System._tuple#2OLL$T1@@0| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0@@0|) TyType) (= (type |_System._tuple#2OLL$T1@@0|) TyType)) (= (Tclass._System.Tuple2OLL_0 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@0| |_System._tuple#2OLL$T1@@0|)) |_System._tuple#2OLL$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |1132|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@0| |_System._tuple#2OLL$T1@@0|))
)))
(assert (forall ((arg0@@301 T@U) ) (! (= (type (Tclass._System.Tuple2OLL_1 arg0@@301)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL_1|
 :pattern ( (Tclass._System.Tuple2OLL_1 arg0@@301))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@1| T@U) (|_System._tuple#2OLL$T1@@1| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0@@1|) TyType) (= (type |_System._tuple#2OLL$T1@@1|) TyType)) (= (Tclass._System.Tuple2OLL_1 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@1| |_System._tuple#2OLL$T1@@1|)) |_System._tuple#2OLL$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |1133|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@1| |_System._tuple#2OLL$T1@@1|))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@2| T@U) (|_System._tuple#2OLL$T1@@2| T@U) (bx@@90 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@2|) TyType) (= (type |_System._tuple#2OLL$T1@@2|) TyType)) (= (type bx@@90) BoxType)) ($IsBox bx@@90 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@90)) bx@@90) ($Is ($Unbox DatatypeTypeType bx@@90) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|))))
 :qid |unknown.0:0|
 :skolemid |1134|
 :pattern ( ($IsBox bx@@90 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|)))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@3| T@U) (|_System._tuple#2OLL$T1@@3| T@U) (|a#16#0#0| T@U) (|a#16#1#0| T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@3|) TyType) (= (type |_System._tuple#2OLL$T1@@3|) TyType)) (= (type |a#16#0#0|) BoxType)) (= (type |a#16#1#0|) BoxType)) (= ($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@3| |_System._tuple#2OLL$T1@@3|))  (and ($IsBox |a#16#0#0| |_System._tuple#2OLL$T0@@3|) ($IsBox |a#16#1#0| |_System._tuple#2OLL$T1@@3|))))
 :qid |unknown.0:0|
 :skolemid |1135|
 :pattern ( ($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@3| |_System._tuple#2OLL$T1@@3|)))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@4| T@U) (|_System._tuple#2OLL$T1@@4| T@U) (|a#17#0#0| T@U) (|a#17#1#0| T@U) ($h@@36 T@U) ) (!  (=> (and (and (and (and (and (= (type |_System._tuple#2OLL$T0@@4|) TyType) (= (type |_System._tuple#2OLL$T1@@4|) TyType)) (= (type |a#17#0#0|) BoxType)) (= (type |a#17#1#0|) BoxType)) (= (type $h@@36) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@36)) (= ($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@4| |_System._tuple#2OLL$T1@@4|) $h@@36)  (and ($IsAllocBox |a#17#0#0| |_System._tuple#2OLL$T0@@4| $h@@36) ($IsAllocBox |a#17#1#0| |_System._tuple#2OLL$T1@@4| $h@@36))))
 :qid |unknown.0:0|
 :skolemid |1136|
 :pattern ( ($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@4| |_System._tuple#2OLL$T1@@4|) $h@@36))
)))
(assert (forall ((arg0@@302 T@U) ) (! (= (type (_System.Tuple2OLL._0 arg0@@302)) BoxType)
 :qid |funType:_System.Tuple2OLL._0|
 :pattern ( (_System.Tuple2OLL._0 arg0@@302))
)))
(assert (forall ((d@@12 T@U) (|_System._tuple#2OLL$T0@@5| T@U) ($h@@37 T@U) ) (!  (=> (and (and (and (= (type d@@12) DatatypeTypeType) (= (type |_System._tuple#2OLL$T0@@5|) TyType)) (= (type $h@@37) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@37) (and (_System.Tuple2OLL.___hMake2_q d@@12) (exists ((|_System._tuple#2OLL$T1@@5| T@U) ) (!  (and (= (type |_System._tuple#2OLL$T1@@5|) TyType) ($IsAlloc d@@12 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@5| |_System._tuple#2OLL$T1@@5|) $h@@37))
 :qid |unknown.0:0|
 :skolemid |1137|
 :pattern ( ($IsAlloc d@@12 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@5| |_System._tuple#2OLL$T1@@5|) $h@@37))
))))) ($IsAllocBox (_System.Tuple2OLL._0 d@@12) |_System._tuple#2OLL$T0@@5| $h@@37))
 :qid |unknown.0:0|
 :skolemid |1138|
 :pattern ( ($IsAllocBox (_System.Tuple2OLL._0 d@@12) |_System._tuple#2OLL$T0@@5| $h@@37))
)))
(assert (forall ((arg0@@303 T@U) ) (! (= (type (_System.Tuple2OLL._1 arg0@@303)) BoxType)
 :qid |funType:_System.Tuple2OLL._1|
 :pattern ( (_System.Tuple2OLL._1 arg0@@303))
)))
(assert (forall ((d@@13 T@U) (|_System._tuple#2OLL$T1@@6| T@U) ($h@@38 T@U) ) (!  (=> (and (and (and (= (type d@@13) DatatypeTypeType) (= (type |_System._tuple#2OLL$T1@@6|) TyType)) (= (type $h@@38) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@38) (and (_System.Tuple2OLL.___hMake2_q d@@13) (exists ((|_System._tuple#2OLL$T0@@6| T@U) ) (!  (and (= (type |_System._tuple#2OLL$T0@@6|) TyType) ($IsAlloc d@@13 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@6| |_System._tuple#2OLL$T1@@6|) $h@@38))
 :qid |unknown.0:0|
 :skolemid |1139|
 :pattern ( ($IsAlloc d@@13 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@6| |_System._tuple#2OLL$T1@@6|) $h@@38))
))))) ($IsAllocBox (_System.Tuple2OLL._1 d@@13) |_System._tuple#2OLL$T1@@6| $h@@38))
 :qid |unknown.0:0|
 :skolemid |1140|
 :pattern ( ($IsAllocBox (_System.Tuple2OLL._1 d@@13) |_System._tuple#2OLL$T1@@6| $h@@38))
)))
(assert (forall ((|a#18#0#0| T@U) (|a#18#1#0| T@U) ) (!  (=> (and (= (type |a#18#0#0|) BoxType) (= (type |a#18#1#0|) BoxType)) (= (|#_System._tuple#2OLL._#Make2| (Lit |a#18#0#0|) (Lit |a#18#1#0|)) (Lit (|#_System._tuple#2OLL._#Make2| |a#18#0#0| |a#18#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1141|
 :pattern ( (|#_System._tuple#2OLL._#Make2| (Lit |a#18#0#0|) (Lit |a#18#1#0|)))
)))
(assert (forall ((|a#19#0#0| T@U) (|a#19#1#0| T@U) ) (!  (=> (and (= (type |a#19#0#0|) BoxType) (= (type |a#19#1#0|) BoxType)) (= (_System.Tuple2OLL._0 (|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|)) |a#19#0#0|))
 :qid |unknown.0:0|
 :skolemid |1142|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|))
)))
(assert (forall ((|a#20#0#0| T@U) (|a#20#1#0| T@U) ) (!  (=> (and (= (type |a#20#0#0|) BoxType) (= (type |a#20#1#0|) BoxType)) (< (BoxRank |a#20#0#0|) (DtRank (|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1143|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))
)))
(assert (forall ((|a#21#0#0| T@U) (|a#21#1#0| T@U) ) (!  (=> (and (= (type |a#21#0#0|) BoxType) (= (type |a#21#1#0|) BoxType)) (= (_System.Tuple2OLL._1 (|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|)) |a#21#1#0|))
 :qid |unknown.0:0|
 :skolemid |1144|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|))
)))
(assert (forall ((|a#22#0#0| T@U) (|a#22#1#0| T@U) ) (!  (=> (and (= (type |a#22#0#0|) BoxType) (= (type |a#22#1#0|) BoxType)) (< (BoxRank |a#22#1#0|) (DtRank (|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1145|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))
)))
(assert (forall ((d@@14 T@U) ) (!  (=> (and (= (type d@@14) DatatypeTypeType) (|$IsA#_System.Tuple2OLL| d@@14)) (_System.Tuple2OLL.___hMake2_q d@@14))
 :qid |unknown.0:0|
 :skolemid |1146|
 :pattern ( (|$IsA#_System.Tuple2OLL| d@@14))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@7| T@U) (|_System._tuple#2OLL$T1@@7| T@U) (d@@15 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@7|) TyType) (= (type |_System._tuple#2OLL$T1@@7|) TyType)) (= (type d@@15) DatatypeTypeType)) ($Is d@@15 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@7| |_System._tuple#2OLL$T1@@7|))) (_System.Tuple2OLL.___hMake2_q d@@15))
 :qid |unknown.0:0|
 :skolemid |1147|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@15) ($Is d@@15 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@7| |_System._tuple#2OLL$T1@@7|)))
)))
(assert (forall ((a@@116 T@U) (b@@65 T@U) ) (!  (=> (and (and (= (type a@@116) DatatypeTypeType) (= (type b@@65) DatatypeTypeType)) true) (= (|_System.Tuple2OLL#Equal| a@@116 b@@65)  (and (= (_System.Tuple2OLL._0 a@@116) (_System.Tuple2OLL._0 b@@65)) (= (_System.Tuple2OLL._1 a@@116) (_System.Tuple2OLL._1 b@@65)))))
 :qid |unknown.0:0|
 :skolemid |1148|
 :pattern ( (|_System.Tuple2OLL#Equal| a@@116 b@@65))
)))
(assert (forall ((a@@117 T@U) (b@@66 T@U) ) (!  (=> (and (= (type a@@117) DatatypeTypeType) (= (type b@@66) DatatypeTypeType)) (= (|_System.Tuple2OLL#Equal| a@@117 b@@66) (= a@@117 b@@66)))
 :qid |unknown.0:0|
 :skolemid |1149|
 :pattern ( (|_System.Tuple2OLL#Equal| a@@117 b@@66))
)))
(assert (forall ((arg0@@304 T@U) (arg1@@129 T@U) (arg2@@70 T@U) (arg3@@42 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL arg0@@304 arg1@@129 arg2@@70 arg3@@42)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL|
 :pattern ( (Tclass._System.___hFunc3LLOL arg0@@304 arg1@@129 arg2@@70 arg3@@42))
)))
(assert (forall ((|#$T0@@189| T@U) (|#$T1@@125| T@U) (|#$T2@@68| T@U) (|#$R@@215| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@189|) TyType) (= (type |#$T1@@125|) TyType)) (= (type |#$T2@@68|) TyType)) (= (type |#$R@@215|) TyType)) (and (= (Tag (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|)) Tagclass._System.___hFunc3LLOL) (= (TagFamily (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|)) |tytagFamily$_#Func3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1150|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|))
)))
(assert (forall ((arg0@@305 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_0 arg0@@305)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_0|
 :pattern ( (Tclass._System.___hFunc3LLOL_0 arg0@@305))
)))
(assert (forall ((|#$T0@@190| T@U) (|#$T1@@126| T@U) (|#$T2@@69| T@U) (|#$R@@216| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@190|) TyType) (= (type |#$T1@@126|) TyType)) (= (type |#$T2@@69|) TyType)) (= (type |#$R@@216|) TyType)) (= (Tclass._System.___hFunc3LLOL_0 (Tclass._System.___hFunc3LLOL |#$T0@@190| |#$T1@@126| |#$T2@@69| |#$R@@216|)) |#$T0@@190|))
 :qid |unknown.0:0|
 :skolemid |1151|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@190| |#$T1@@126| |#$T2@@69| |#$R@@216|))
)))
(assert (forall ((arg0@@306 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_1 arg0@@306)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_1|
 :pattern ( (Tclass._System.___hFunc3LLOL_1 arg0@@306))
)))
(assert (forall ((|#$T0@@191| T@U) (|#$T1@@127| T@U) (|#$T2@@70| T@U) (|#$R@@217| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@191|) TyType) (= (type |#$T1@@127|) TyType)) (= (type |#$T2@@70|) TyType)) (= (type |#$R@@217|) TyType)) (= (Tclass._System.___hFunc3LLOL_1 (Tclass._System.___hFunc3LLOL |#$T0@@191| |#$T1@@127| |#$T2@@70| |#$R@@217|)) |#$T1@@127|))
 :qid |unknown.0:0|
 :skolemid |1152|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@191| |#$T1@@127| |#$T2@@70| |#$R@@217|))
)))
(assert (forall ((arg0@@307 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_2 arg0@@307)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_2|
 :pattern ( (Tclass._System.___hFunc3LLOL_2 arg0@@307))
)))
(assert (forall ((|#$T0@@192| T@U) (|#$T1@@128| T@U) (|#$T2@@71| T@U) (|#$R@@218| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@192|) TyType) (= (type |#$T1@@128|) TyType)) (= (type |#$T2@@71|) TyType)) (= (type |#$R@@218|) TyType)) (= (Tclass._System.___hFunc3LLOL_2 (Tclass._System.___hFunc3LLOL |#$T0@@192| |#$T1@@128| |#$T2@@71| |#$R@@218|)) |#$T2@@71|))
 :qid |unknown.0:0|
 :skolemid |1153|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@192| |#$T1@@128| |#$T2@@71| |#$R@@218|))
)))
(assert (forall ((arg0@@308 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_3 arg0@@308)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_3|
 :pattern ( (Tclass._System.___hFunc3LLOL_3 arg0@@308))
)))
(assert (forall ((|#$T0@@193| T@U) (|#$T1@@129| T@U) (|#$T2@@72| T@U) (|#$R@@219| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@193|) TyType) (= (type |#$T1@@129|) TyType)) (= (type |#$T2@@72|) TyType)) (= (type |#$R@@219|) TyType)) (= (Tclass._System.___hFunc3LLOL_3 (Tclass._System.___hFunc3LLOL |#$T0@@193| |#$T1@@129| |#$T2@@72| |#$R@@219|)) |#$R@@219|))
 :qid |unknown.0:0|
 :skolemid |1154|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@193| |#$T1@@129| |#$T2@@72| |#$R@@219|))
)))
(assert (forall ((|#$T0@@194| T@U) (|#$T1@@130| T@U) (|#$T2@@73| T@U) (|#$R@@220| T@U) (bx@@91 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@194|) TyType) (= (type |#$T1@@130|) TyType)) (= (type |#$T2@@73|) TyType)) (= (type |#$R@@220|) TyType)) (= (type bx@@91) BoxType)) ($IsBox bx@@91 (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|))) (and (= ($Box ($Unbox HandleTypeType bx@@91)) bx@@91) ($Is ($Unbox HandleTypeType bx@@91) (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|))))
 :qid |unknown.0:0|
 :skolemid |1155|
 :pattern ( ($IsBox bx@@91 (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|)))
)))
(assert (forall ((arg0@@309 T@U) (arg1@@130 T@U) (arg2@@71 T@U) (arg3@@43 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL arg0@@309 arg1@@130 arg2@@71 arg3@@43)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL arg0@@309 arg1@@130 arg2@@71 arg3@@43))
)))
(assert (forall ((|#$T0@@195| T@U) (|#$T1@@131| T@U) (|#$T2@@74| T@U) (|#$R@@221| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@195|) TyType) (= (type |#$T1@@131|) TyType)) (= (type |#$T2@@74|) TyType)) (= (type |#$R@@221|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|)) Tagclass._System.___hPartialFunc3LLOL) (= (TagFamily (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|)) |tytagFamily$_#PartialFunc3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1156|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|))
)))
(assert (forall ((arg0@@310 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_0 arg0@@310)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_0|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_0 arg0@@310))
)))
(assert (forall ((|#$T0@@196| T@U) (|#$T1@@132| T@U) (|#$T2@@75| T@U) (|#$R@@222| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@196|) TyType) (= (type |#$T1@@132|) TyType)) (= (type |#$T2@@75|) TyType)) (= (type |#$R@@222|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_0 (Tclass._System.___hPartialFunc3LLOL |#$T0@@196| |#$T1@@132| |#$T2@@75| |#$R@@222|)) |#$T0@@196|))
 :qid |unknown.0:0|
 :skolemid |1157|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@196| |#$T1@@132| |#$T2@@75| |#$R@@222|))
)))
(assert (forall ((arg0@@311 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_1 arg0@@311)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_1|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_1 arg0@@311))
)))
(assert (forall ((|#$T0@@197| T@U) (|#$T1@@133| T@U) (|#$T2@@76| T@U) (|#$R@@223| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@197|) TyType) (= (type |#$T1@@133|) TyType)) (= (type |#$T2@@76|) TyType)) (= (type |#$R@@223|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_1 (Tclass._System.___hPartialFunc3LLOL |#$T0@@197| |#$T1@@133| |#$T2@@76| |#$R@@223|)) |#$T1@@133|))
 :qid |unknown.0:0|
 :skolemid |1158|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@197| |#$T1@@133| |#$T2@@76| |#$R@@223|))
)))
(assert (forall ((arg0@@312 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_2 arg0@@312)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_2|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_2 arg0@@312))
)))
(assert (forall ((|#$T0@@198| T@U) (|#$T1@@134| T@U) (|#$T2@@77| T@U) (|#$R@@224| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@198|) TyType) (= (type |#$T1@@134|) TyType)) (= (type |#$T2@@77|) TyType)) (= (type |#$R@@224|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_2 (Tclass._System.___hPartialFunc3LLOL |#$T0@@198| |#$T1@@134| |#$T2@@77| |#$R@@224|)) |#$T2@@77|))
 :qid |unknown.0:0|
 :skolemid |1159|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@198| |#$T1@@134| |#$T2@@77| |#$R@@224|))
)))
(assert (forall ((arg0@@313 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_3 arg0@@313)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_3|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_3 arg0@@313))
)))
(assert (forall ((|#$T0@@199| T@U) (|#$T1@@135| T@U) (|#$T2@@78| T@U) (|#$R@@225| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@199|) TyType) (= (type |#$T1@@135|) TyType)) (= (type |#$T2@@78|) TyType)) (= (type |#$R@@225|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_3 (Tclass._System.___hPartialFunc3LLOL |#$T0@@199| |#$T1@@135| |#$T2@@78| |#$R@@225|)) |#$R@@225|))
 :qid |unknown.0:0|
 :skolemid |1160|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@199| |#$T1@@135| |#$T2@@78| |#$R@@225|))
)))
(assert (forall ((|#$T0@@200| T@U) (|#$T1@@136| T@U) (|#$T2@@79| T@U) (|#$R@@226| T@U) (bx@@92 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@200|) TyType) (= (type |#$T1@@136|) TyType)) (= (type |#$T2@@79|) TyType)) (= (type |#$R@@226|) TyType)) (= (type bx@@92) BoxType)) ($IsBox bx@@92 (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|))) (and (= ($Box ($Unbox HandleTypeType bx@@92)) bx@@92) ($Is ($Unbox HandleTypeType bx@@92) (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|))))
 :qid |unknown.0:0|
 :skolemid |1161|
 :pattern ( ($IsBox bx@@92 (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|)))
)))
(assert (forall ((|#$T0@@201| T@U) (|#$T1@@137| T@U) (|#$T2@@80| T@U) (|#$R@@227| T@U) (|f#0@@47| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@201|) TyType) (= (type |#$T1@@137|) TyType)) (= (type |#$T2@@80|) TyType)) (= (type |#$R@@227|) TyType)) (= (type |f#0@@47|) HandleTypeType)) (= ($Is |f#0@@47| (Tclass._System.___hPartialFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|))  (and ($Is |f#0@@47| (Tclass._System.___hFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|)) (forall ((|x0#0@@19| T@U) (|x1#0@@11| T@U) (|x2#0@@5| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@19|) BoxType) (= (type |x1#0@@11|) BoxType)) (= (type |x2#0@@5|) BoxType)) (and (and ($IsBox |x0#0@@19| |#$T0@@201|) ($IsBox |x1#0@@11| |#$T1@@137|)) ($IsBox |x2#0@@5| |#$T2@@80|))) (|Set#Equal| (Reads3 |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227| $OneHeap |f#0@@47| |x0#0@@19| |x1#0@@11| |x2#0@@5|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1162|
 :no-pattern (type |x0#0@@19|)
 :no-pattern (type |x1#0@@11|)
 :no-pattern (type |x2#0@@5|)
 :no-pattern (U_2_int |x0#0@@19|)
 :no-pattern (U_2_bool |x0#0@@19|)
 :no-pattern (U_2_int |x1#0@@11|)
 :no-pattern (U_2_bool |x1#0@@11|)
 :no-pattern (U_2_int |x2#0@@5|)
 :no-pattern (U_2_bool |x2#0@@5|)
)))))
 :qid |unknown.0:0|
 :skolemid |1163|
 :pattern ( ($Is |f#0@@47| (Tclass._System.___hPartialFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|)))
)))
(assert (forall ((|#$T0@@202| T@U) (|#$T1@@138| T@U) (|#$T2@@81| T@U) (|#$R@@228| T@U) (|f#0@@48| T@U) ($h@@39 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@202|) TyType) (= (type |#$T1@@138|) TyType)) (= (type |#$T2@@81|) TyType)) (= (type |#$R@@228|) TyType)) (= (type |f#0@@48|) HandleTypeType)) (= (type $h@@39) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@48| (Tclass._System.___hPartialFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39) ($IsAlloc |f#0@@48| (Tclass._System.___hFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39)))
 :qid |unknown.0:0|
 :skolemid |1164|
 :pattern ( ($IsAlloc |f#0@@48| (Tclass._System.___hPartialFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39))
)))
(assert (forall ((arg0@@314 T@U) (arg1@@131 T@U) (arg2@@72 T@U) (arg3@@44 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL arg0@@314 arg1@@131 arg2@@72 arg3@@44)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL arg0@@314 arg1@@131 arg2@@72 arg3@@44))
)))
(assert (forall ((|#$T0@@203| T@U) (|#$T1@@139| T@U) (|#$T2@@82| T@U) (|#$R@@229| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@203|) TyType) (= (type |#$T1@@139|) TyType)) (= (type |#$T2@@82|) TyType)) (= (type |#$R@@229|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|)) Tagclass._System.___hTotalFunc3LLOL) (= (TagFamily (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|)) |tytagFamily$_#TotalFunc3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1165|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|))
)))
(assert (forall ((arg0@@315 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_0 arg0@@315)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_0|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_0 arg0@@315))
)))
(assert (forall ((|#$T0@@204| T@U) (|#$T1@@140| T@U) (|#$T2@@83| T@U) (|#$R@@230| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@204|) TyType) (= (type |#$T1@@140|) TyType)) (= (type |#$T2@@83|) TyType)) (= (type |#$R@@230|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_0 (Tclass._System.___hTotalFunc3LLOL |#$T0@@204| |#$T1@@140| |#$T2@@83| |#$R@@230|)) |#$T0@@204|))
 :qid |unknown.0:0|
 :skolemid |1166|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@204| |#$T1@@140| |#$T2@@83| |#$R@@230|))
)))
(assert (forall ((arg0@@316 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_1 arg0@@316)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_1|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_1 arg0@@316))
)))
(assert (forall ((|#$T0@@205| T@U) (|#$T1@@141| T@U) (|#$T2@@84| T@U) (|#$R@@231| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@205|) TyType) (= (type |#$T1@@141|) TyType)) (= (type |#$T2@@84|) TyType)) (= (type |#$R@@231|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_1 (Tclass._System.___hTotalFunc3LLOL |#$T0@@205| |#$T1@@141| |#$T2@@84| |#$R@@231|)) |#$T1@@141|))
 :qid |unknown.0:0|
 :skolemid |1167|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@205| |#$T1@@141| |#$T2@@84| |#$R@@231|))
)))
(assert (forall ((arg0@@317 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_2 arg0@@317)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_2|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_2 arg0@@317))
)))
(assert (forall ((|#$T0@@206| T@U) (|#$T1@@142| T@U) (|#$T2@@85| T@U) (|#$R@@232| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@206|) TyType) (= (type |#$T1@@142|) TyType)) (= (type |#$T2@@85|) TyType)) (= (type |#$R@@232|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_2 (Tclass._System.___hTotalFunc3LLOL |#$T0@@206| |#$T1@@142| |#$T2@@85| |#$R@@232|)) |#$T2@@85|))
 :qid |unknown.0:0|
 :skolemid |1168|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@206| |#$T1@@142| |#$T2@@85| |#$R@@232|))
)))
(assert (forall ((arg0@@318 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_3 arg0@@318)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_3|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_3 arg0@@318))
)))
(assert (forall ((|#$T0@@207| T@U) (|#$T1@@143| T@U) (|#$T2@@86| T@U) (|#$R@@233| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@207|) TyType) (= (type |#$T1@@143|) TyType)) (= (type |#$T2@@86|) TyType)) (= (type |#$R@@233|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_3 (Tclass._System.___hTotalFunc3LLOL |#$T0@@207| |#$T1@@143| |#$T2@@86| |#$R@@233|)) |#$R@@233|))
 :qid |unknown.0:0|
 :skolemid |1169|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@207| |#$T1@@143| |#$T2@@86| |#$R@@233|))
)))
(assert (forall ((|#$T0@@208| T@U) (|#$T1@@144| T@U) (|#$T2@@87| T@U) (|#$R@@234| T@U) (bx@@93 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@208|) TyType) (= (type |#$T1@@144|) TyType)) (= (type |#$T2@@87|) TyType)) (= (type |#$R@@234|) TyType)) (= (type bx@@93) BoxType)) ($IsBox bx@@93 (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|))) (and (= ($Box ($Unbox HandleTypeType bx@@93)) bx@@93) ($Is ($Unbox HandleTypeType bx@@93) (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|))))
 :qid |unknown.0:0|
 :skolemid |1170|
 :pattern ( ($IsBox bx@@93 (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|)))
)))
(assert (forall ((|#$T0@@209| T@U) (|#$T1@@145| T@U) (|#$T2@@88| T@U) (|#$R@@235| T@U) (|f#0@@49| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@209|) TyType) (= (type |#$T1@@145|) TyType)) (= (type |#$T2@@88|) TyType)) (= (type |#$R@@235|) TyType)) (= (type |f#0@@49|) HandleTypeType)) (= ($Is |f#0@@49| (Tclass._System.___hTotalFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|))  (and ($Is |f#0@@49| (Tclass._System.___hPartialFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|)) (forall ((|x0#0@@20| T@U) (|x1#0@@12| T@U) (|x2#0@@6| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@20|) BoxType) (= (type |x1#0@@12|) BoxType)) (= (type |x2#0@@6|) BoxType)) (and (and ($IsBox |x0#0@@20| |#$T0@@209|) ($IsBox |x1#0@@12| |#$T1@@145|)) ($IsBox |x2#0@@6| |#$T2@@88|))) (Requires3 |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235| $OneHeap |f#0@@49| |x0#0@@20| |x1#0@@12| |x2#0@@6|))
 :qid |unknown.0:0|
 :skolemid |1171|
 :no-pattern (type |x0#0@@20|)
 :no-pattern (type |x1#0@@12|)
 :no-pattern (type |x2#0@@6|)
 :no-pattern (U_2_int |x0#0@@20|)
 :no-pattern (U_2_bool |x0#0@@20|)
 :no-pattern (U_2_int |x1#0@@12|)
 :no-pattern (U_2_bool |x1#0@@12|)
 :no-pattern (U_2_int |x2#0@@6|)
 :no-pattern (U_2_bool |x2#0@@6|)
)))))
 :qid |unknown.0:0|
 :skolemid |1172|
 :pattern ( ($Is |f#0@@49| (Tclass._System.___hTotalFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|)))
)))
(assert (forall ((|#$T0@@210| T@U) (|#$T1@@146| T@U) (|#$T2@@89| T@U) (|#$R@@236| T@U) (|f#0@@50| T@U) ($h@@40 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@210|) TyType) (= (type |#$T1@@146|) TyType)) (= (type |#$T2@@89|) TyType)) (= (type |#$R@@236|) TyType)) (= (type |f#0@@50|) HandleTypeType)) (= (type $h@@40) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@50| (Tclass._System.___hTotalFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40) ($IsAlloc |f#0@@50| (Tclass._System.___hPartialFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40)))
 :qid |unknown.0:0|
 :skolemid |1173|
 :pattern ( ($IsAlloc |f#0@@50| (Tclass._System.___hTotalFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40))
)))
(assert (forall ((arg0@@319 T@U) (arg1@@132 T@U) (arg2@@73 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO|
 :pattern ( (Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73))
)))
(assert (forall ((|#$T0@@211| T@U) (|#$T1@@147| T@U) (|#$R@@237| T@U) ) (!  (=> (and (and (= (type |#$T0@@211|) TyType) (= (type |#$T1@@147|) TyType)) (= (type |#$R@@237|) TyType)) (and (= (Tag (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|)) Tagclass._System.___hFunc2SSO) (= (TagFamily (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|)) |tytagFamily$_#Func2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1174|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|))
)))
(assert (forall ((arg0@@320 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_0 arg0@@320)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_0|
 :pattern ( (Tclass._System.___hFunc2SSO_0 arg0@@320))
)))
(assert (forall ((|#$T0@@212| T@U) (|#$T1@@148| T@U) (|#$R@@238| T@U) ) (!  (=> (and (and (= (type |#$T0@@212|) TyType) (= (type |#$T1@@148|) TyType)) (= (type |#$R@@238|) TyType)) (= (Tclass._System.___hFunc2SSO_0 (Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|)) |#$T0@@212|))
 :qid |unknown.0:0|
 :skolemid |1175|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|))
)))
(assert (forall ((arg0@@321 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_1 arg0@@321)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_1|
 :pattern ( (Tclass._System.___hFunc2SSO_1 arg0@@321))
)))
(assert (forall ((|#$T0@@213| T@U) (|#$T1@@149| T@U) (|#$R@@239| T@U) ) (!  (=> (and (and (= (type |#$T0@@213|) TyType) (= (type |#$T1@@149|) TyType)) (= (type |#$R@@239|) TyType)) (= (Tclass._System.___hFunc2SSO_1 (Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|)) |#$T1@@149|))
 :qid |unknown.0:0|
 :skolemid |1176|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|))
)))
(assert (forall ((arg0@@322 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_2 arg0@@322)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_2|
 :pattern ( (Tclass._System.___hFunc2SSO_2 arg0@@322))
)))
(assert (forall ((|#$T0@@214| T@U) (|#$T1@@150| T@U) (|#$R@@240| T@U) ) (!  (=> (and (and (= (type |#$T0@@214|) TyType) (= (type |#$T1@@150|) TyType)) (= (type |#$R@@240|) TyType)) (= (Tclass._System.___hFunc2SSO_2 (Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|)) |#$R@@240|))
 :qid |unknown.0:0|
 :skolemid |1177|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|))
)))
(assert (forall ((|#$T0@@215| T@U) (|#$T1@@151| T@U) (|#$R@@241| T@U) (bx@@94 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@215|) TyType) (= (type |#$T1@@151|) TyType)) (= (type |#$R@@241|) TyType)) (= (type bx@@94) BoxType)) ($IsBox bx@@94 (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|))) (and (= ($Box ($Unbox HandleTypeType bx@@94)) bx@@94) ($Is ($Unbox HandleTypeType bx@@94) (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|))))
 :qid |unknown.0:0|
 :skolemid |1178|
 :pattern ( ($IsBox bx@@94 (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|)))
)))
(assert (forall ((arg0@@323 T@U) (arg1@@133 T@U) (arg2@@74 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO|
 :pattern ( (Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74))
)))
(assert (forall ((|#$T0@@216| T@U) (|#$T1@@152| T@U) (|#$R@@242| T@U) ) (!  (=> (and (and (= (type |#$T0@@216|) TyType) (= (type |#$T1@@152|) TyType)) (= (type |#$R@@242|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|)) Tagclass._System.___hPartialFunc2SSO) (= (TagFamily (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|)) |tytagFamily$_#PartialFunc2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1179|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|))
)))
(assert (forall ((arg0@@324 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_0 arg0@@324)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_0|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_0 arg0@@324))
)))
(assert (forall ((|#$T0@@217| T@U) (|#$T1@@153| T@U) (|#$R@@243| T@U) ) (!  (=> (and (and (= (type |#$T0@@217|) TyType) (= (type |#$T1@@153|) TyType)) (= (type |#$R@@243|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_0 (Tclass._System.___hPartialFunc2SSO |#$T0@@217| |#$T1@@153| |#$R@@243|)) |#$T0@@217|))
 :qid |unknown.0:0|
 :skolemid |1180|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@217| |#$T1@@153| |#$R@@243|))
)))
(assert (forall ((arg0@@325 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_1 arg0@@325)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_1|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_1 arg0@@325))
)))
(assert (forall ((|#$T0@@218| T@U) (|#$T1@@154| T@U) (|#$R@@244| T@U) ) (!  (=> (and (and (= (type |#$T0@@218|) TyType) (= (type |#$T1@@154|) TyType)) (= (type |#$R@@244|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_1 (Tclass._System.___hPartialFunc2SSO |#$T0@@218| |#$T1@@154| |#$R@@244|)) |#$T1@@154|))
 :qid |unknown.0:0|
 :skolemid |1181|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@218| |#$T1@@154| |#$R@@244|))
)))
(assert (forall ((arg0@@326 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_2 arg0@@326)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_2|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_2 arg0@@326))
)))
(assert (forall ((|#$T0@@219| T@U) (|#$T1@@155| T@U) (|#$R@@245| T@U) ) (!  (=> (and (and (= (type |#$T0@@219|) TyType) (= (type |#$T1@@155|) TyType)) (= (type |#$R@@245|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_2 (Tclass._System.___hPartialFunc2SSO |#$T0@@219| |#$T1@@155| |#$R@@245|)) |#$R@@245|))
 :qid |unknown.0:0|
 :skolemid |1182|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@219| |#$T1@@155| |#$R@@245|))
)))
(assert (forall ((|#$T0@@220| T@U) (|#$T1@@156| T@U) (|#$R@@246| T@U) (bx@@95 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@220|) TyType) (= (type |#$T1@@156|) TyType)) (= (type |#$R@@246|) TyType)) (= (type bx@@95) BoxType)) ($IsBox bx@@95 (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|))) (and (= ($Box ($Unbox HandleTypeType bx@@95)) bx@@95) ($Is ($Unbox HandleTypeType bx@@95) (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|))))
 :qid |unknown.0:0|
 :skolemid |1183|
 :pattern ( ($IsBox bx@@95 (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|)))
)))
(assert (forall ((|#$T0@@221| T@U) (|#$T1@@157| T@U) (|#$R@@247| T@U) (|f#0@@51| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@221|) TyType) (= (type |#$T1@@157|) TyType)) (= (type |#$R@@247|) TyType)) (= (type |f#0@@51|) HandleTypeType)) (= ($Is |f#0@@51| (Tclass._System.___hPartialFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|))  (and ($Is |f#0@@51| (Tclass._System.___hFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|)) (forall ((|x0#0@@21| T@U) (|x1#0@@13| T@U) ) (!  (=> (and (and (= (type |x0#0@@21|) BoxType) (= (type |x1#0@@13|) BoxType)) (and ($IsBox |x0#0@@21| |#$T0@@221|) ($IsBox |x1#0@@13| |#$T1@@157|))) (|Set#Equal| (Reads2 |#$T0@@221| |#$T1@@157| |#$R@@247| $OneHeap |f#0@@51| |x0#0@@21| |x1#0@@13|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1184|
 :no-pattern (type |x0#0@@21|)
 :no-pattern (type |x1#0@@13|)
 :no-pattern (U_2_int |x0#0@@21|)
 :no-pattern (U_2_bool |x0#0@@21|)
 :no-pattern (U_2_int |x1#0@@13|)
 :no-pattern (U_2_bool |x1#0@@13|)
)))))
 :qid |unknown.0:0|
 :skolemid |1185|
 :pattern ( ($Is |f#0@@51| (Tclass._System.___hPartialFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|)))
)))
(assert (forall ((|#$T0@@222| T@U) (|#$T1@@158| T@U) (|#$R@@248| T@U) (|f#0@@52| T@U) ($h@@41 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@222|) TyType) (= (type |#$T1@@158|) TyType)) (= (type |#$R@@248|) TyType)) (= (type |f#0@@52|) HandleTypeType)) (= (type $h@@41) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@52| (Tclass._System.___hPartialFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41) ($IsAlloc |f#0@@52| (Tclass._System.___hFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41)))
 :qid |unknown.0:0|
 :skolemid |1186|
 :pattern ( ($IsAlloc |f#0@@52| (Tclass._System.___hPartialFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41))
)))
(assert (forall ((arg0@@327 T@U) (arg1@@134 T@U) (arg2@@75 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO|
 :pattern ( (Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75))
)))
(assert (forall ((|#$T0@@223| T@U) (|#$T1@@159| T@U) (|#$R@@249| T@U) ) (!  (=> (and (and (= (type |#$T0@@223|) TyType) (= (type |#$T1@@159|) TyType)) (= (type |#$R@@249|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|)) Tagclass._System.___hTotalFunc2SSO) (= (TagFamily (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|)) |tytagFamily$_#TotalFunc2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1187|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|))
)))
(assert (forall ((arg0@@328 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_0 arg0@@328)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_0|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_0 arg0@@328))
)))
(assert (forall ((|#$T0@@224| T@U) (|#$T1@@160| T@U) (|#$R@@250| T@U) ) (!  (=> (and (and (= (type |#$T0@@224|) TyType) (= (type |#$T1@@160|) TyType)) (= (type |#$R@@250|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_0 (Tclass._System.___hTotalFunc2SSO |#$T0@@224| |#$T1@@160| |#$R@@250|)) |#$T0@@224|))
 :qid |unknown.0:0|
 :skolemid |1188|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@224| |#$T1@@160| |#$R@@250|))
)))
(assert (forall ((arg0@@329 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_1 arg0@@329)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_1|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_1 arg0@@329))
)))
(assert (forall ((|#$T0@@225| T@U) (|#$T1@@161| T@U) (|#$R@@251| T@U) ) (!  (=> (and (and (= (type |#$T0@@225|) TyType) (= (type |#$T1@@161|) TyType)) (= (type |#$R@@251|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_1 (Tclass._System.___hTotalFunc2SSO |#$T0@@225| |#$T1@@161| |#$R@@251|)) |#$T1@@161|))
 :qid |unknown.0:0|
 :skolemid |1189|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@225| |#$T1@@161| |#$R@@251|))
)))
(assert (forall ((arg0@@330 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_2 arg0@@330)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_2|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_2 arg0@@330))
)))
(assert (forall ((|#$T0@@226| T@U) (|#$T1@@162| T@U) (|#$R@@252| T@U) ) (!  (=> (and (and (= (type |#$T0@@226|) TyType) (= (type |#$T1@@162|) TyType)) (= (type |#$R@@252|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_2 (Tclass._System.___hTotalFunc2SSO |#$T0@@226| |#$T1@@162| |#$R@@252|)) |#$R@@252|))
 :qid |unknown.0:0|
 :skolemid |1190|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@226| |#$T1@@162| |#$R@@252|))
)))
(assert (forall ((|#$T0@@227| T@U) (|#$T1@@163| T@U) (|#$R@@253| T@U) (bx@@96 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@227|) TyType) (= (type |#$T1@@163|) TyType)) (= (type |#$R@@253|) TyType)) (= (type bx@@96) BoxType)) ($IsBox bx@@96 (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|))) (and (= ($Box ($Unbox HandleTypeType bx@@96)) bx@@96) ($Is ($Unbox HandleTypeType bx@@96) (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|))))
 :qid |unknown.0:0|
 :skolemid |1191|
 :pattern ( ($IsBox bx@@96 (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|)))
)))
(assert (forall ((|#$T0@@228| T@U) (|#$T1@@164| T@U) (|#$R@@254| T@U) (|f#0@@53| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@228|) TyType) (= (type |#$T1@@164|) TyType)) (= (type |#$R@@254|) TyType)) (= (type |f#0@@53|) HandleTypeType)) (= ($Is |f#0@@53| (Tclass._System.___hTotalFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|))  (and ($Is |f#0@@53| (Tclass._System.___hPartialFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|)) (forall ((|x0#0@@22| T@U) (|x1#0@@14| T@U) ) (!  (=> (and (and (= (type |x0#0@@22|) BoxType) (= (type |x1#0@@14|) BoxType)) (and ($IsBox |x0#0@@22| |#$T0@@228|) ($IsBox |x1#0@@14| |#$T1@@164|))) (Requires2 |#$T0@@228| |#$T1@@164| |#$R@@254| $OneHeap |f#0@@53| |x0#0@@22| |x1#0@@14|))
 :qid |unknown.0:0|
 :skolemid |1192|
 :no-pattern (type |x0#0@@22|)
 :no-pattern (type |x1#0@@14|)
 :no-pattern (U_2_int |x0#0@@22|)
 :no-pattern (U_2_bool |x0#0@@22|)
 :no-pattern (U_2_int |x1#0@@14|)
 :no-pattern (U_2_bool |x1#0@@14|)
)))))
 :qid |unknown.0:0|
 :skolemid |1193|
 :pattern ( ($Is |f#0@@53| (Tclass._System.___hTotalFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|)))
)))
(assert (forall ((|#$T0@@229| T@U) (|#$T1@@165| T@U) (|#$R@@255| T@U) (|f#0@@54| T@U) ($h@@42 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@229|) TyType) (= (type |#$T1@@165|) TyType)) (= (type |#$R@@255|) TyType)) (= (type |f#0@@54|) HandleTypeType)) (= (type $h@@42) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@54| (Tclass._System.___hTotalFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42) ($IsAlloc |f#0@@54| (Tclass._System.___hPartialFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42)))
 :qid |unknown.0:0|
 :skolemid |1194|
 :pattern ( ($IsAlloc |f#0@@54| (Tclass._System.___hTotalFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42))
)))
(assert (forall ((arg0@@331 T@U) (arg1@@135 T@U) (arg2@@76 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO|
 :pattern ( (Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76))
)))
(assert (forall ((|#$T0@@230| T@U) (|#$T1@@166| T@U) (|#$R@@256| T@U) ) (!  (=> (and (and (= (type |#$T0@@230|) TyType) (= (type |#$T1@@166|) TyType)) (= (type |#$R@@256|) TyType)) (and (= (Tag (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|)) Tagclass._System.___hFunc2LLO) (= (TagFamily (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|)) |tytagFamily$_#Func2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1195|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|))
)))
(assert (forall ((arg0@@332 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_0 arg0@@332)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_0|
 :pattern ( (Tclass._System.___hFunc2LLO_0 arg0@@332))
)))
(assert (forall ((|#$T0@@231| T@U) (|#$T1@@167| T@U) (|#$R@@257| T@U) ) (!  (=> (and (and (= (type |#$T0@@231|) TyType) (= (type |#$T1@@167|) TyType)) (= (type |#$R@@257|) TyType)) (= (Tclass._System.___hFunc2LLO_0 (Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|)) |#$T0@@231|))
 :qid |unknown.0:0|
 :skolemid |1196|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|))
)))
(assert (forall ((arg0@@333 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_1 arg0@@333)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_1|
 :pattern ( (Tclass._System.___hFunc2LLO_1 arg0@@333))
)))
(assert (forall ((|#$T0@@232| T@U) (|#$T1@@168| T@U) (|#$R@@258| T@U) ) (!  (=> (and (and (= (type |#$T0@@232|) TyType) (= (type |#$T1@@168|) TyType)) (= (type |#$R@@258|) TyType)) (= (Tclass._System.___hFunc2LLO_1 (Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|)) |#$T1@@168|))
 :qid |unknown.0:0|
 :skolemid |1197|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|))
)))
(assert (forall ((arg0@@334 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_2 arg0@@334)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_2|
 :pattern ( (Tclass._System.___hFunc2LLO_2 arg0@@334))
)))
(assert (forall ((|#$T0@@233| T@U) (|#$T1@@169| T@U) (|#$R@@259| T@U) ) (!  (=> (and (and (= (type |#$T0@@233|) TyType) (= (type |#$T1@@169|) TyType)) (= (type |#$R@@259|) TyType)) (= (Tclass._System.___hFunc2LLO_2 (Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|)) |#$R@@259|))
 :qid |unknown.0:0|
 :skolemid |1198|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|))
)))
(assert (forall ((|#$T0@@234| T@U) (|#$T1@@170| T@U) (|#$R@@260| T@U) (bx@@97 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@234|) TyType) (= (type |#$T1@@170|) TyType)) (= (type |#$R@@260|) TyType)) (= (type bx@@97) BoxType)) ($IsBox bx@@97 (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|))) (and (= ($Box ($Unbox HandleTypeType bx@@97)) bx@@97) ($Is ($Unbox HandleTypeType bx@@97) (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|))))
 :qid |unknown.0:0|
 :skolemid |1199|
 :pattern ( ($IsBox bx@@97 (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|)))
)))
(assert (forall ((arg0@@335 T@U) (arg1@@136 T@U) (arg2@@77 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO|
 :pattern ( (Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77))
)))
(assert (forall ((|#$T0@@235| T@U) (|#$T1@@171| T@U) (|#$R@@261| T@U) ) (!  (=> (and (and (= (type |#$T0@@235|) TyType) (= (type |#$T1@@171|) TyType)) (= (type |#$R@@261|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|)) Tagclass._System.___hPartialFunc2LLO) (= (TagFamily (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|)) |tytagFamily$_#PartialFunc2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1200|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|))
)))
(assert (forall ((arg0@@336 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_0 arg0@@336)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_0|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_0 arg0@@336))
)))
(assert (forall ((|#$T0@@236| T@U) (|#$T1@@172| T@U) (|#$R@@262| T@U) ) (!  (=> (and (and (= (type |#$T0@@236|) TyType) (= (type |#$T1@@172|) TyType)) (= (type |#$R@@262|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_0 (Tclass._System.___hPartialFunc2LLO |#$T0@@236| |#$T1@@172| |#$R@@262|)) |#$T0@@236|))
 :qid |unknown.0:0|
 :skolemid |1201|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@236| |#$T1@@172| |#$R@@262|))
)))
(assert (forall ((arg0@@337 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_1 arg0@@337)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_1|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_1 arg0@@337))
)))
(assert (forall ((|#$T0@@237| T@U) (|#$T1@@173| T@U) (|#$R@@263| T@U) ) (!  (=> (and (and (= (type |#$T0@@237|) TyType) (= (type |#$T1@@173|) TyType)) (= (type |#$R@@263|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_1 (Tclass._System.___hPartialFunc2LLO |#$T0@@237| |#$T1@@173| |#$R@@263|)) |#$T1@@173|))
 :qid |unknown.0:0|
 :skolemid |1202|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@237| |#$T1@@173| |#$R@@263|))
)))
(assert (forall ((arg0@@338 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_2 arg0@@338)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_2|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_2 arg0@@338))
)))
(assert (forall ((|#$T0@@238| T@U) (|#$T1@@174| T@U) (|#$R@@264| T@U) ) (!  (=> (and (and (= (type |#$T0@@238|) TyType) (= (type |#$T1@@174|) TyType)) (= (type |#$R@@264|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_2 (Tclass._System.___hPartialFunc2LLO |#$T0@@238| |#$T1@@174| |#$R@@264|)) |#$R@@264|))
 :qid |unknown.0:0|
 :skolemid |1203|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@238| |#$T1@@174| |#$R@@264|))
)))
(assert (forall ((|#$T0@@239| T@U) (|#$T1@@175| T@U) (|#$R@@265| T@U) (bx@@98 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@239|) TyType) (= (type |#$T1@@175|) TyType)) (= (type |#$R@@265|) TyType)) (= (type bx@@98) BoxType)) ($IsBox bx@@98 (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|))) (and (= ($Box ($Unbox HandleTypeType bx@@98)) bx@@98) ($Is ($Unbox HandleTypeType bx@@98) (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|))))
 :qid |unknown.0:0|
 :skolemid |1204|
 :pattern ( ($IsBox bx@@98 (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|)))
)))
(assert (forall ((|#$T0@@240| T@U) (|#$T1@@176| T@U) (|#$R@@266| T@U) (|f#0@@55| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@240|) TyType) (= (type |#$T1@@176|) TyType)) (= (type |#$R@@266|) TyType)) (= (type |f#0@@55|) HandleTypeType)) (= ($Is |f#0@@55| (Tclass._System.___hPartialFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|))  (and ($Is |f#0@@55| (Tclass._System.___hFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|)) (forall ((|x0#0@@23| T@U) (|x1#0@@15| T@U) ) (!  (=> (and (and (= (type |x0#0@@23|) BoxType) (= (type |x1#0@@15|) BoxType)) (and ($IsBox |x0#0@@23| |#$T0@@240|) ($IsBox |x1#0@@15| |#$T1@@176|))) (|Set#Equal| (Reads2 |#$T0@@240| |#$T1@@176| |#$R@@266| $OneHeap |f#0@@55| |x0#0@@23| |x1#0@@15|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1205|
 :no-pattern (type |x0#0@@23|)
 :no-pattern (type |x1#0@@15|)
 :no-pattern (U_2_int |x0#0@@23|)
 :no-pattern (U_2_bool |x0#0@@23|)
 :no-pattern (U_2_int |x1#0@@15|)
 :no-pattern (U_2_bool |x1#0@@15|)
)))))
 :qid |unknown.0:0|
 :skolemid |1206|
 :pattern ( ($Is |f#0@@55| (Tclass._System.___hPartialFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|)))
)))
(assert (forall ((|#$T0@@241| T@U) (|#$T1@@177| T@U) (|#$R@@267| T@U) (|f#0@@56| T@U) ($h@@43 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@241|) TyType) (= (type |#$T1@@177|) TyType)) (= (type |#$R@@267|) TyType)) (= (type |f#0@@56|) HandleTypeType)) (= (type $h@@43) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@56| (Tclass._System.___hPartialFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43) ($IsAlloc |f#0@@56| (Tclass._System.___hFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43)))
 :qid |unknown.0:0|
 :skolemid |1207|
 :pattern ( ($IsAlloc |f#0@@56| (Tclass._System.___hPartialFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43))
)))
(assert (forall ((arg0@@339 T@U) (arg1@@137 T@U) (arg2@@78 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO|
 :pattern ( (Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78))
)))
(assert (forall ((|#$T0@@242| T@U) (|#$T1@@178| T@U) (|#$R@@268| T@U) ) (!  (=> (and (and (= (type |#$T0@@242|) TyType) (= (type |#$T1@@178|) TyType)) (= (type |#$R@@268|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|)) Tagclass._System.___hTotalFunc2LLO) (= (TagFamily (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|)) |tytagFamily$_#TotalFunc2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1208|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|))
)))
(assert (forall ((arg0@@340 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_0 arg0@@340)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_0|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_0 arg0@@340))
)))
(assert (forall ((|#$T0@@243| T@U) (|#$T1@@179| T@U) (|#$R@@269| T@U) ) (!  (=> (and (and (= (type |#$T0@@243|) TyType) (= (type |#$T1@@179|) TyType)) (= (type |#$R@@269|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_0 (Tclass._System.___hTotalFunc2LLO |#$T0@@243| |#$T1@@179| |#$R@@269|)) |#$T0@@243|))
 :qid |unknown.0:0|
 :skolemid |1209|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@243| |#$T1@@179| |#$R@@269|))
)))
(assert (forall ((arg0@@341 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_1 arg0@@341)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_1|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_1 arg0@@341))
)))
(assert (forall ((|#$T0@@244| T@U) (|#$T1@@180| T@U) (|#$R@@270| T@U) ) (!  (=> (and (and (= (type |#$T0@@244|) TyType) (= (type |#$T1@@180|) TyType)) (= (type |#$R@@270|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_1 (Tclass._System.___hTotalFunc2LLO |#$T0@@244| |#$T1@@180| |#$R@@270|)) |#$T1@@180|))
 :qid |unknown.0:0|
 :skolemid |1210|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@244| |#$T1@@180| |#$R@@270|))
)))
(assert (forall ((arg0@@342 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_2 arg0@@342)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_2|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_2 arg0@@342))
)))
(assert (forall ((|#$T0@@245| T@U) (|#$T1@@181| T@U) (|#$R@@271| T@U) ) (!  (=> (and (and (= (type |#$T0@@245|) TyType) (= (type |#$T1@@181|) TyType)) (= (type |#$R@@271|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_2 (Tclass._System.___hTotalFunc2LLO |#$T0@@245| |#$T1@@181| |#$R@@271|)) |#$R@@271|))
 :qid |unknown.0:0|
 :skolemid |1211|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@245| |#$T1@@181| |#$R@@271|))
)))
(assert (forall ((|#$T0@@246| T@U) (|#$T1@@182| T@U) (|#$R@@272| T@U) (bx@@99 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@246|) TyType) (= (type |#$T1@@182|) TyType)) (= (type |#$R@@272|) TyType)) (= (type bx@@99) BoxType)) ($IsBox bx@@99 (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|))) (and (= ($Box ($Unbox HandleTypeType bx@@99)) bx@@99) ($Is ($Unbox HandleTypeType bx@@99) (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|))))
 :qid |unknown.0:0|
 :skolemid |1212|
 :pattern ( ($IsBox bx@@99 (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|)))
)))
(assert (forall ((|#$T0@@247| T@U) (|#$T1@@183| T@U) (|#$R@@273| T@U) (|f#0@@57| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@247|) TyType) (= (type |#$T1@@183|) TyType)) (= (type |#$R@@273|) TyType)) (= (type |f#0@@57|) HandleTypeType)) (= ($Is |f#0@@57| (Tclass._System.___hTotalFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|))  (and ($Is |f#0@@57| (Tclass._System.___hPartialFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|)) (forall ((|x0#0@@24| T@U) (|x1#0@@16| T@U) ) (!  (=> (and (and (= (type |x0#0@@24|) BoxType) (= (type |x1#0@@16|) BoxType)) (and ($IsBox |x0#0@@24| |#$T0@@247|) ($IsBox |x1#0@@16| |#$T1@@183|))) (Requires2 |#$T0@@247| |#$T1@@183| |#$R@@273| $OneHeap |f#0@@57| |x0#0@@24| |x1#0@@16|))
 :qid |unknown.0:0|
 :skolemid |1213|
 :no-pattern (type |x0#0@@24|)
 :no-pattern (type |x1#0@@16|)
 :no-pattern (U_2_int |x0#0@@24|)
 :no-pattern (U_2_bool |x0#0@@24|)
 :no-pattern (U_2_int |x1#0@@16|)
 :no-pattern (U_2_bool |x1#0@@16|)
)))))
 :qid |unknown.0:0|
 :skolemid |1214|
 :pattern ( ($Is |f#0@@57| (Tclass._System.___hTotalFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|)))
)))
(assert (forall ((|#$T0@@248| T@U) (|#$T1@@184| T@U) (|#$R@@274| T@U) (|f#0@@58| T@U) ($h@@44 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@248|) TyType) (= (type |#$T1@@184|) TyType)) (= (type |#$R@@274|) TyType)) (= (type |f#0@@58|) HandleTypeType)) (= (type $h@@44) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@58| (Tclass._System.___hTotalFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44) ($IsAlloc |f#0@@58| (Tclass._System.___hPartialFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44)))
 :qid |unknown.0:0|
 :skolemid |1215|
 :pattern ( ($IsAlloc |f#0@@58| (Tclass._System.___hTotalFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44))
)))
(assert (forall ((arg0@@343 T@U) (arg1@@138 T@U) ) (! (= (type (Tclass._System.___hFunc1SS arg0@@343 arg1@@138)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS|
 :pattern ( (Tclass._System.___hFunc1SS arg0@@343 arg1@@138))
)))
(assert (forall ((|#$T0@@249| T@U) (|#$R@@275| T@U) ) (!  (=> (and (= (type |#$T0@@249|) TyType) (= (type |#$R@@275|) TyType)) (and (= (Tag (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|)) Tagclass._System.___hFunc1SS) (= (TagFamily (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|)) |tytagFamily$_#Func1SS|)))
 :qid |unknown.0:0|
 :skolemid |1216|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|))
)))
(assert (forall ((arg0@@344 T@U) ) (! (= (type (Tclass._System.___hFunc1SS_0 arg0@@344)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS_0|
 :pattern ( (Tclass._System.___hFunc1SS_0 arg0@@344))
)))
(assert (forall ((|#$T0@@250| T@U) (|#$R@@276| T@U) ) (!  (=> (and (= (type |#$T0@@250|) TyType) (= (type |#$R@@276|) TyType)) (= (Tclass._System.___hFunc1SS_0 (Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|)) |#$T0@@250|))
 :qid |unknown.0:0|
 :skolemid |1217|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|))
)))
(assert (forall ((arg0@@345 T@U) ) (! (= (type (Tclass._System.___hFunc1SS_1 arg0@@345)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS_1|
 :pattern ( (Tclass._System.___hFunc1SS_1 arg0@@345))
)))
(assert (forall ((|#$T0@@251| T@U) (|#$R@@277| T@U) ) (!  (=> (and (= (type |#$T0@@251|) TyType) (= (type |#$R@@277|) TyType)) (= (Tclass._System.___hFunc1SS_1 (Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|)) |#$R@@277|))
 :qid |unknown.0:0|
 :skolemid |1218|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|))
)))
(assert (forall ((|#$T0@@252| T@U) (|#$R@@278| T@U) (bx@@100 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@252|) TyType) (= (type |#$R@@278|) TyType)) (= (type bx@@100) BoxType)) ($IsBox bx@@100 (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|))) (and (= ($Box ($Unbox HandleTypeType bx@@100)) bx@@100) ($Is ($Unbox HandleTypeType bx@@100) (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|))))
 :qid |unknown.0:0|
 :skolemid |1219|
 :pattern ( ($IsBox bx@@100 (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|)))
)))
(assert (forall ((arg0@@346 T@U) (arg1@@139 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS|
 :pattern ( (Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139))
)))
(assert (forall ((|#$T0@@253| T@U) (|#$R@@279| T@U) ) (!  (=> (and (= (type |#$T0@@253|) TyType) (= (type |#$R@@279|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|)) Tagclass._System.___hPartialFunc1SS) (= (TagFamily (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|)) |tytagFamily$_#PartialFunc1SS|)))
 :qid |unknown.0:0|
 :skolemid |1220|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|))
)))
(assert (forall ((arg0@@347 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS_0 arg0@@347)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS_0|
 :pattern ( (Tclass._System.___hPartialFunc1SS_0 arg0@@347))
)))
(assert (forall ((|#$T0@@254| T@U) (|#$R@@280| T@U) ) (!  (=> (and (= (type |#$T0@@254|) TyType) (= (type |#$R@@280|) TyType)) (= (Tclass._System.___hPartialFunc1SS_0 (Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|)) |#$T0@@254|))
 :qid |unknown.0:0|
 :skolemid |1221|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|))
)))
(assert (forall ((arg0@@348 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS_1 arg0@@348)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS_1|
 :pattern ( (Tclass._System.___hPartialFunc1SS_1 arg0@@348))
)))
(assert (forall ((|#$T0@@255| T@U) (|#$R@@281| T@U) ) (!  (=> (and (= (type |#$T0@@255|) TyType) (= (type |#$R@@281|) TyType)) (= (Tclass._System.___hPartialFunc1SS_1 (Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|)) |#$R@@281|))
 :qid |unknown.0:0|
 :skolemid |1222|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|))
)))
(assert (forall ((|#$T0@@256| T@U) (|#$R@@282| T@U) (bx@@101 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@256|) TyType) (= (type |#$R@@282|) TyType)) (= (type bx@@101) BoxType)) ($IsBox bx@@101 (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|))) (and (= ($Box ($Unbox HandleTypeType bx@@101)) bx@@101) ($Is ($Unbox HandleTypeType bx@@101) (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|))))
 :qid |unknown.0:0|
 :skolemid |1223|
 :pattern ( ($IsBox bx@@101 (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|)))
)))
(assert (forall ((|#$T0@@257| T@U) (|#$R@@283| T@U) (|f#0@@59| T@U) ) (!  (=> (and (and (= (type |#$T0@@257|) TyType) (= (type |#$R@@283|) TyType)) (= (type |f#0@@59|) HandleTypeType)) (= ($Is |f#0@@59| (Tclass._System.___hPartialFunc1SS |#$T0@@257| |#$R@@283|))  (and ($Is |f#0@@59| (Tclass._System.___hFunc1SS |#$T0@@257| |#$R@@283|)) (forall ((|x0#0@@25| T@U) ) (!  (=> (and (= (type |x0#0@@25|) BoxType) ($IsBox |x0#0@@25| |#$T0@@257|)) (|Set#Equal| (Reads1 |#$T0@@257| |#$R@@283| $OneHeap |f#0@@59| |x0#0@@25|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1224|
 :no-pattern (type |x0#0@@25|)
 :no-pattern (U_2_int |x0#0@@25|)
 :no-pattern (U_2_bool |x0#0@@25|)
)))))
 :qid |unknown.0:0|
 :skolemid |1225|
 :pattern ( ($Is |f#0@@59| (Tclass._System.___hPartialFunc1SS |#$T0@@257| |#$R@@283|)))
)))
(assert (forall ((|#$T0@@258| T@U) (|#$R@@284| T@U) (|f#0@@60| T@U) ($h@@45 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@258|) TyType) (= (type |#$R@@284|) TyType)) (= (type |f#0@@60|) HandleTypeType)) (= (type $h@@45) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@60| (Tclass._System.___hPartialFunc1SS |#$T0@@258| |#$R@@284|) $h@@45) ($IsAlloc |f#0@@60| (Tclass._System.___hFunc1SS |#$T0@@258| |#$R@@284|) $h@@45)))
 :qid |unknown.0:0|
 :skolemid |1226|
 :pattern ( ($IsAlloc |f#0@@60| (Tclass._System.___hPartialFunc1SS |#$T0@@258| |#$R@@284|) $h@@45))
)))
(assert (forall ((arg0@@349 T@U) (arg1@@140 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS|
 :pattern ( (Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140))
)))
(assert (forall ((|#$T0@@259| T@U) (|#$R@@285| T@U) ) (!  (=> (and (= (type |#$T0@@259|) TyType) (= (type |#$R@@285|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|)) Tagclass._System.___hTotalFunc1SS) (= (TagFamily (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|)) |tytagFamily$_#TotalFunc1SS|)))
 :qid |unknown.0:0|
 :skolemid |1227|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|))
)))
(assert (forall ((arg0@@350 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS_0 arg0@@350)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS_0|
 :pattern ( (Tclass._System.___hTotalFunc1SS_0 arg0@@350))
)))
(assert (forall ((|#$T0@@260| T@U) (|#$R@@286| T@U) ) (!  (=> (and (= (type |#$T0@@260|) TyType) (= (type |#$R@@286|) TyType)) (= (Tclass._System.___hTotalFunc1SS_0 (Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|)) |#$T0@@260|))
 :qid |unknown.0:0|
 :skolemid |1228|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|))
)))
(assert (forall ((arg0@@351 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS_1 arg0@@351)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS_1|
 :pattern ( (Tclass._System.___hTotalFunc1SS_1 arg0@@351))
)))
(assert (forall ((|#$T0@@261| T@U) (|#$R@@287| T@U) ) (!  (=> (and (= (type |#$T0@@261|) TyType) (= (type |#$R@@287|) TyType)) (= (Tclass._System.___hTotalFunc1SS_1 (Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|)) |#$R@@287|))
 :qid |unknown.0:0|
 :skolemid |1229|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|))
)))
(assert (forall ((|#$T0@@262| T@U) (|#$R@@288| T@U) (bx@@102 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@262|) TyType) (= (type |#$R@@288|) TyType)) (= (type bx@@102) BoxType)) ($IsBox bx@@102 (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|))) (and (= ($Box ($Unbox HandleTypeType bx@@102)) bx@@102) ($Is ($Unbox HandleTypeType bx@@102) (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|))))
 :qid |unknown.0:0|
 :skolemid |1230|
 :pattern ( ($IsBox bx@@102 (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|)))
)))
(assert (forall ((|#$T0@@263| T@U) (|#$R@@289| T@U) (|f#0@@61| T@U) ) (!  (=> (and (and (= (type |#$T0@@263|) TyType) (= (type |#$R@@289|) TyType)) (= (type |f#0@@61|) HandleTypeType)) (= ($Is |f#0@@61| (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|))  (and ($Is |f#0@@61| (Tclass._System.___hPartialFunc1SS |#$T0@@263| |#$R@@289|)) (forall ((|x0#0@@26| T@U) ) (!  (=> (and (= (type |x0#0@@26|) BoxType) ($IsBox |x0#0@@26| |#$T0@@263|)) (Requires1 |#$T0@@263| |#$R@@289| $OneHeap |f#0@@61| |x0#0@@26|))
 :qid |unknown.0:0|
 :skolemid |1231|
 :no-pattern (type |x0#0@@26|)
 :no-pattern (U_2_int |x0#0@@26|)
 :no-pattern (U_2_bool |x0#0@@26|)
)))))
 :qid |unknown.0:0|
 :skolemid |1232|
 :pattern ( ($Is |f#0@@61| (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|)))
)))
(assert (forall ((|#$T0@@264| T@U) (|#$R@@290| T@U) (|f#0@@62| T@U) ($h@@46 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@264|) TyType) (= (type |#$R@@290|) TyType)) (= (type |f#0@@62|) HandleTypeType)) (= (type $h@@46) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@62| (Tclass._System.___hTotalFunc1SS |#$T0@@264| |#$R@@290|) $h@@46) ($IsAlloc |f#0@@62| (Tclass._System.___hPartialFunc1SS |#$T0@@264| |#$R@@290|) $h@@46)))
 :qid |unknown.0:0|
 :skolemid |1233|
 :pattern ( ($IsAlloc |f#0@@62| (Tclass._System.___hTotalFunc1SS |#$T0@@264| |#$R@@290|) $h@@46))
)))
(assert (forall ((arg0@@352 T@U) (arg1@@141 T@U) ) (! (= (type (Tclass._System.___hFunc1LL arg0@@352 arg1@@141)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL|
 :pattern ( (Tclass._System.___hFunc1LL arg0@@352 arg1@@141))
)))
(assert (forall ((|#$T0@@265| T@U) (|#$R@@291| T@U) ) (!  (=> (and (= (type |#$T0@@265|) TyType) (= (type |#$R@@291|) TyType)) (and (= (Tag (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|)) Tagclass._System.___hFunc1LL) (= (TagFamily (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|)) |tytagFamily$_#Func1LL|)))
 :qid |unknown.0:0|
 :skolemid |1234|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|))
)))
(assert (forall ((arg0@@353 T@U) ) (! (= (type (Tclass._System.___hFunc1LL_0 arg0@@353)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL_0|
 :pattern ( (Tclass._System.___hFunc1LL_0 arg0@@353))
)))
(assert (forall ((|#$T0@@266| T@U) (|#$R@@292| T@U) ) (!  (=> (and (= (type |#$T0@@266|) TyType) (= (type |#$R@@292|) TyType)) (= (Tclass._System.___hFunc1LL_0 (Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|)) |#$T0@@266|))
 :qid |unknown.0:0|
 :skolemid |1235|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|))
)))
(assert (forall ((arg0@@354 T@U) ) (! (= (type (Tclass._System.___hFunc1LL_1 arg0@@354)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL_1|
 :pattern ( (Tclass._System.___hFunc1LL_1 arg0@@354))
)))
(assert (forall ((|#$T0@@267| T@U) (|#$R@@293| T@U) ) (!  (=> (and (= (type |#$T0@@267|) TyType) (= (type |#$R@@293|) TyType)) (= (Tclass._System.___hFunc1LL_1 (Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|)) |#$R@@293|))
 :qid |unknown.0:0|
 :skolemid |1236|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|))
)))
(assert (forall ((|#$T0@@268| T@U) (|#$R@@294| T@U) (bx@@103 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@268|) TyType) (= (type |#$R@@294|) TyType)) (= (type bx@@103) BoxType)) ($IsBox bx@@103 (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|))) (and (= ($Box ($Unbox HandleTypeType bx@@103)) bx@@103) ($Is ($Unbox HandleTypeType bx@@103) (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|))))
 :qid |unknown.0:0|
 :skolemid |1237|
 :pattern ( ($IsBox bx@@103 (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|)))
)))
(assert (forall ((arg0@@355 T@U) (arg1@@142 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL|
 :pattern ( (Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142))
)))
(assert (forall ((|#$T0@@269| T@U) (|#$R@@295| T@U) ) (!  (=> (and (= (type |#$T0@@269|) TyType) (= (type |#$R@@295|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|)) Tagclass._System.___hPartialFunc1LL) (= (TagFamily (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|)) |tytagFamily$_#PartialFunc1LL|)))
 :qid |unknown.0:0|
 :skolemid |1238|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|))
)))
(assert (forall ((arg0@@356 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL_0 arg0@@356)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL_0|
 :pattern ( (Tclass._System.___hPartialFunc1LL_0 arg0@@356))
)))
(assert (forall ((|#$T0@@270| T@U) (|#$R@@296| T@U) ) (!  (=> (and (= (type |#$T0@@270|) TyType) (= (type |#$R@@296|) TyType)) (= (Tclass._System.___hPartialFunc1LL_0 (Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|)) |#$T0@@270|))
 :qid |unknown.0:0|
 :skolemid |1239|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|))
)))
(assert (forall ((arg0@@357 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL_1 arg0@@357)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL_1|
 :pattern ( (Tclass._System.___hPartialFunc1LL_1 arg0@@357))
)))
(assert (forall ((|#$T0@@271| T@U) (|#$R@@297| T@U) ) (!  (=> (and (= (type |#$T0@@271|) TyType) (= (type |#$R@@297|) TyType)) (= (Tclass._System.___hPartialFunc1LL_1 (Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|)) |#$R@@297|))
 :qid |unknown.0:0|
 :skolemid |1240|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|))
)))
(assert (forall ((|#$T0@@272| T@U) (|#$R@@298| T@U) (bx@@104 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@272|) TyType) (= (type |#$R@@298|) TyType)) (= (type bx@@104) BoxType)) ($IsBox bx@@104 (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|))) (and (= ($Box ($Unbox HandleTypeType bx@@104)) bx@@104) ($Is ($Unbox HandleTypeType bx@@104) (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|))))
 :qid |unknown.0:0|
 :skolemid |1241|
 :pattern ( ($IsBox bx@@104 (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|)))
)))
(assert (forall ((|#$T0@@273| T@U) (|#$R@@299| T@U) (|f#0@@63| T@U) ) (!  (=> (and (and (= (type |#$T0@@273|) TyType) (= (type |#$R@@299|) TyType)) (= (type |f#0@@63|) HandleTypeType)) (= ($Is |f#0@@63| (Tclass._System.___hPartialFunc1LL |#$T0@@273| |#$R@@299|))  (and ($Is |f#0@@63| (Tclass._System.___hFunc1LL |#$T0@@273| |#$R@@299|)) (forall ((|x0#0@@27| T@U) ) (!  (=> (and (= (type |x0#0@@27|) BoxType) ($IsBox |x0#0@@27| |#$T0@@273|)) (|Set#Equal| (Reads1 |#$T0@@273| |#$R@@299| $OneHeap |f#0@@63| |x0#0@@27|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1242|
 :no-pattern (type |x0#0@@27|)
 :no-pattern (U_2_int |x0#0@@27|)
 :no-pattern (U_2_bool |x0#0@@27|)
)))))
 :qid |unknown.0:0|
 :skolemid |1243|
 :pattern ( ($Is |f#0@@63| (Tclass._System.___hPartialFunc1LL |#$T0@@273| |#$R@@299|)))
)))
(assert (forall ((|#$T0@@274| T@U) (|#$R@@300| T@U) (|f#0@@64| T@U) ($h@@47 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@274|) TyType) (= (type |#$R@@300|) TyType)) (= (type |f#0@@64|) HandleTypeType)) (= (type $h@@47) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@64| (Tclass._System.___hPartialFunc1LL |#$T0@@274| |#$R@@300|) $h@@47) ($IsAlloc |f#0@@64| (Tclass._System.___hFunc1LL |#$T0@@274| |#$R@@300|) $h@@47)))
 :qid |unknown.0:0|
 :skolemid |1244|
 :pattern ( ($IsAlloc |f#0@@64| (Tclass._System.___hPartialFunc1LL |#$T0@@274| |#$R@@300|) $h@@47))
)))
(assert (forall ((arg0@@358 T@U) (arg1@@143 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL|
 :pattern ( (Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143))
)))
(assert (forall ((|#$T0@@275| T@U) (|#$R@@301| T@U) ) (!  (=> (and (= (type |#$T0@@275|) TyType) (= (type |#$R@@301|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|)) Tagclass._System.___hTotalFunc1LL) (= (TagFamily (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|)) |tytagFamily$_#TotalFunc1LL|)))
 :qid |unknown.0:0|
 :skolemid |1245|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|))
)))
(assert (forall ((arg0@@359 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL_0 arg0@@359)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL_0|
 :pattern ( (Tclass._System.___hTotalFunc1LL_0 arg0@@359))
)))
(assert (forall ((|#$T0@@276| T@U) (|#$R@@302| T@U) ) (!  (=> (and (= (type |#$T0@@276|) TyType) (= (type |#$R@@302|) TyType)) (= (Tclass._System.___hTotalFunc1LL_0 (Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|)) |#$T0@@276|))
 :qid |unknown.0:0|
 :skolemid |1246|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|))
)))
(assert (forall ((arg0@@360 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL_1 arg0@@360)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL_1|
 :pattern ( (Tclass._System.___hTotalFunc1LL_1 arg0@@360))
)))
(assert (forall ((|#$T0@@277| T@U) (|#$R@@303| T@U) ) (!  (=> (and (= (type |#$T0@@277|) TyType) (= (type |#$R@@303|) TyType)) (= (Tclass._System.___hTotalFunc1LL_1 (Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|)) |#$R@@303|))
 :qid |unknown.0:0|
 :skolemid |1247|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|))
)))
(assert (forall ((|#$T0@@278| T@U) (|#$R@@304| T@U) (bx@@105 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@278|) TyType) (= (type |#$R@@304|) TyType)) (= (type bx@@105) BoxType)) ($IsBox bx@@105 (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|))) (and (= ($Box ($Unbox HandleTypeType bx@@105)) bx@@105) ($Is ($Unbox HandleTypeType bx@@105) (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|))))
 :qid |unknown.0:0|
 :skolemid |1248|
 :pattern ( ($IsBox bx@@105 (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|)))
)))
(assert (forall ((|#$T0@@279| T@U) (|#$R@@305| T@U) (|f#0@@65| T@U) ) (!  (=> (and (and (= (type |#$T0@@279|) TyType) (= (type |#$R@@305|) TyType)) (= (type |f#0@@65|) HandleTypeType)) (= ($Is |f#0@@65| (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|))  (and ($Is |f#0@@65| (Tclass._System.___hPartialFunc1LL |#$T0@@279| |#$R@@305|)) (forall ((|x0#0@@28| T@U) ) (!  (=> (and (= (type |x0#0@@28|) BoxType) ($IsBox |x0#0@@28| |#$T0@@279|)) (Requires1 |#$T0@@279| |#$R@@305| $OneHeap |f#0@@65| |x0#0@@28|))
 :qid |unknown.0:0|
 :skolemid |1249|
 :no-pattern (type |x0#0@@28|)
 :no-pattern (U_2_int |x0#0@@28|)
 :no-pattern (U_2_bool |x0#0@@28|)
)))))
 :qid |unknown.0:0|
 :skolemid |1250|
 :pattern ( ($Is |f#0@@65| (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|)))
)))
(assert (forall ((|#$T0@@280| T@U) (|#$R@@306| T@U) (|f#0@@66| T@U) ($h@@48 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@280|) TyType) (= (type |#$R@@306|) TyType)) (= (type |f#0@@66|) HandleTypeType)) (= (type $h@@48) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@66| (Tclass._System.___hTotalFunc1LL |#$T0@@280| |#$R@@306|) $h@@48) ($IsAlloc |f#0@@66| (Tclass._System.___hPartialFunc1LL |#$T0@@280| |#$R@@306|) $h@@48)))
 :qid |unknown.0:0|
 :skolemid |1251|
 :pattern ( ($IsAlloc |f#0@@66| (Tclass._System.___hTotalFunc1LL |#$T0@@280| |#$R@@306|) $h@@48))
)))
(assert (= (type Tclass.PivotBetreeRefinement.__default) TyType))
(assert (= (Tag Tclass.PivotBetreeRefinement.__default) Tagclass.PivotBetreeRefinement.__default))
(assert (= (TagFamily Tclass.PivotBetreeRefinement.__default) tytagFamily$_default))
(assert (forall ((bx@@106 T@U) ) (!  (=> (and (= (type bx@@106) BoxType) ($IsBox bx@@106 Tclass.PivotBetreeRefinement.__default)) (and (= ($Box ($Unbox refType bx@@106)) bx@@106) ($Is ($Unbox refType bx@@106) Tclass.PivotBetreeRefinement.__default)))
 :qid |unknown.0:0|
 :skolemid |1252|
 :pattern ( ($IsBox bx@@106 Tclass.PivotBetreeRefinement.__default))
)))
(assert (forall (($o@@9 T@U) ) (!  (=> (= (type $o@@9) refType) (= ($Is $o@@9 Tclass.PivotBetreeRefinement.__default)  (or (= $o@@9 null) (= (dtype $o@@9) Tclass.PivotBetreeRefinement.__default))))
 :qid |unknown.0:0|
 :skolemid |1253|
 :pattern ( ($Is $o@@9 Tclass.PivotBetreeRefinement.__default))
)))
(assert (forall (($o@@10 T@U) ($h@@49 T@U) ) (!  (=> (and (= (type $o@@10) refType) (= (type $h@@49) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@10 Tclass.PivotBetreeRefinement.__default $h@@49)  (or (= $o@@10 null) (U_2_bool (MapType1Select (MapType0Select $h@@49 $o@@10) alloc)))))
 :qid |unknown.0:0|
 :skolemid |1254|
 :pattern ( ($IsAlloc $o@@10 Tclass.PivotBetreeRefinement.__default $h@@49))
)))
(assert (forall ((arg0@@361 T@U) (arg1@@144 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IChildren arg0@@361 arg1@@144)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IChildren|
 :pattern ( (PivotBetreeRefinement.__default.IChildren arg0@@361 arg1@@144))
)))
(assert (forall (($ly T@U) (|node#0| T@U) ) (!  (=> (and (= (type $ly) LayerTypeType) (= (type |node#0|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.IChildren ($LS $ly) |node#0|) (PivotBetreeRefinement.__default.IChildren $ly |node#0|)))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :skolemid |1255|
 :pattern ( (PivotBetreeRefinement.__default.IChildren ($LS $ly) |node#0|))
)))
(assert  (and (forall ((arg0@@362 T@U) ) (! (= (type (AsFuelBottom arg0@@362)) LayerTypeType)
 :qid |funType:AsFuelBottom|
 :pattern ( (AsFuelBottom arg0@@362))
)) (= (type $LZ) LayerTypeType)))
(assert (forall (($ly@@0 T@U) (|node#0@@0| T@U) ) (!  (=> (and (= (type $ly@@0) LayerTypeType) (= (type |node#0@@0|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.IChildren $ly@@0 |node#0@@0|) (PivotBetreeRefinement.__default.IChildren $LZ |node#0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :skolemid |1256|
 :pattern ( (PivotBetreeRefinement.__default.IChildren (AsFuelBottom $ly@@0) |node#0@@0|))
)))
(assert (= (type Tclass.PivotBetree.BetreeNode) TyType))
(assert (= (Tag Tclass.PivotBetree.BetreeNode) Tagclass.PivotBetree.BetreeNode))
(assert (= (TagFamily Tclass.PivotBetree.BetreeNode) tytagFamily$BetreeNode))
(assert (forall ((bx@@107 T@U) ) (!  (=> (and (= (type bx@@107) BoxType) ($IsBox bx@@107 Tclass.PivotBetree.BetreeNode)) (and (= ($Box ($Unbox DatatypeTypeType bx@@107)) bx@@107) ($Is ($Unbox DatatypeTypeType bx@@107) Tclass.PivotBetree.BetreeNode)))
 :qid |unknown.0:0|
 :skolemid |1257|
 :pattern ( ($IsBox bx@@107 Tclass.PivotBetree.BetreeNode))
)))
(assert (= (type Tclass.PagedBetree.ChildMap) TyType))
(assert (= (Tag Tclass.PagedBetree.ChildMap) Tagclass.PagedBetree.ChildMap))
(assert (= (TagFamily Tclass.PagedBetree.ChildMap) tytagFamily$ChildMap))
(assert (forall ((bx@@108 T@U) ) (!  (=> (and (= (type bx@@108) BoxType) ($IsBox bx@@108 Tclass.PagedBetree.ChildMap)) (and (= ($Box ($Unbox DatatypeTypeType bx@@108)) bx@@108) ($Is ($Unbox DatatypeTypeType bx@@108) Tclass.PagedBetree.ChildMap)))
 :qid |unknown.0:0|
 :skolemid |1258|
 :pattern ( ($IsBox bx@@108 Tclass.PagedBetree.ChildMap))
)))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@1 T@U) (|node#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type |node#0@@1|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.IChildren#canCall| |node#0@@1|) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@1| Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@1|) (PivotBetree.BetreeNode.BetreeNode_q |node#0@@1|)))))) ($Is (PivotBetreeRefinement.__default.IChildren $ly@@1 |node#0@@1|) Tclass.PagedBetree.ChildMap))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :skolemid |1259|
 :pattern ( (PivotBetreeRefinement.__default.IChildren $ly@@1 |node#0@@1|))
))))
(assert (forall (($ly@@2 T@U) (|node#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type |node#0@@2|) DatatypeTypeType)) ($Is |node#0@@2| Tclass.PivotBetree.BetreeNode)) (= (|PivotBetreeRefinement.__default.IChildren#requires| $ly@@2 |node#0@@2|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@2|) (PivotBetree.BetreeNode.BetreeNode_q |node#0@@2|))))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :skolemid |1260|
 :pattern ( (|PivotBetreeRefinement.__default.IChildren#requires| $ly@@2 |node#0@@2|))
)))
(assert (= (type Tclass.KeyType.Key) TyType))
(assert (= (Tag Tclass.KeyType.Key) Tagclass.KeyType.Key))
(assert (= (TagFamily Tclass.KeyType.Key) tytagFamily$Key))
(assert (forall ((bx@@109 T@U) ) (!  (=> (and (= (type bx@@109) BoxType) ($IsBox bx@@109 Tclass.KeyType.Key)) (and (= ($Box ($Unbox (SeqType BoxType) bx@@109)) bx@@109) ($Is ($Unbox (SeqType BoxType) bx@@109) Tclass.KeyType.Key)))
 :qid |unknown.0:0|
 :skolemid |1261|
 :pattern ( ($IsBox bx@@109 Tclass.KeyType.Key))
)))
(assert (= (type Tclass.PagedBetree.BetreeNode) TyType))
(assert (= (Tag Tclass.PagedBetree.BetreeNode) Tagclass.PagedBetree.BetreeNode))
(assert (= (TagFamily Tclass.PagedBetree.BetreeNode) tytagFamily$BetreeNode))
(assert (forall ((bx@@110 T@U) ) (!  (=> (and (= (type bx@@110) BoxType) ($IsBox bx@@110 Tclass.PagedBetree.BetreeNode)) (and (= ($Box ($Unbox DatatypeTypeType bx@@110)) bx@@110) ($Is ($Unbox DatatypeTypeType bx@@110) Tclass.PagedBetree.BetreeNode)))
 :qid |unknown.0:0|
 :skolemid |1262|
 :pattern ( ($IsBox bx@@110 Tclass.PagedBetree.BetreeNode))
)))
(assert  (and (and (and (and (and (forall ((arg0@@363 T@U) (arg1@@145 T@U) ) (! (= (type (PivotBetree.BetreeNode.Child arg0@@363 arg1@@145)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Child|
 :pattern ( (PivotBetree.BetreeNode.Child arg0@@363 arg1@@145))
)) (forall ((arg0@@364 T@U) ) (! (= (type (PivotBetree.BetreeNode.KeySet arg0@@364)) (MapType0Type BoxType boolType))
 :qid |funType:PivotBetree.BetreeNode.KeySet|
 :pattern ( (PivotBetree.BetreeNode.KeySet arg0@@364))
))) (forall ((arg0@@365 T@U) ) (! (= (type (|#PagedBetree.ChildMap.ChildMap| arg0@@365)) DatatypeTypeType)
 :qid |funType:#PagedBetree.ChildMap.ChildMap|
 :pattern ( (|#PagedBetree.ChildMap.ChildMap| arg0@@365))
))) (forall ((arg0@@366 T@U) ) (! (= (type (|lambda#0| arg0@@366)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#0|
 :pattern ( (|lambda#0| arg0@@366))
))) (forall ((arg0@@367 T@U) (arg1@@146 T@U) (arg2@@79 T@U) (arg3@@45 T@U) ) (! (= (type (|lambda#1| arg0@@367 arg1@@146 arg2@@79 arg3@@45)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#1|
 :pattern ( (|lambda#1| arg0@@367 arg1@@146 arg2@@79 arg3@@45))
))) (= (type |#PagedBetree.BetreeNode.Nil|) DatatypeTypeType)))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@3 T@U) (|node#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type |node#0@@3|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.IChildren#canCall| |node#0@@3|) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@3| Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@3|) (PivotBetree.BetreeNode.BetreeNode_q |node#0@@3|)))))) (and (forall ((|key#0| T@U) ) (!  (=> (and (= (type |key#0|) (SeqType BoxType)) ($Is |key#0| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0|) (=> (Buffers.__default.AnyKey |key#0|) (and (|PivotBetree.BetreeNode.KeySet#canCall| |node#0@@3|) (=> (U_2_bool (MapType0Select (PivotBetree.BetreeNode.KeySet |node#0@@3|) ($Box |key#0|))) (and (|PivotBetree.BetreeNode.Child#canCall| |node#0@@3| |key#0|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.BetreeNode.Child |node#0@@3| |key#0|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.32:31|
 :skolemid |1263|
 :pattern ( (PivotBetree.BetreeNode.Child |node#0@@3| |key#0|))
 :pattern ( (MapType0Select (PivotBetree.BetreeNode.KeySet |node#0@@3|) ($Box |key#0|)))
 :pattern ( (Buffers.__default.AnyKey |key#0|))
)) (= (PivotBetreeRefinement.__default.IChildren ($LS $ly@@3) |node#0@@3|) (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#1| (PivotBetree.BetreeNode.KeySet |node#0@@3|) $ly@@3 |node#0@@3| |#PagedBetree.BetreeNode.Nil|) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :skolemid |1264|
 :pattern ( (PivotBetreeRefinement.__default.IChildren ($LS $ly@@3) |node#0@@3|))
))))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@4 T@U) (|node#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type |node#0@@4|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.IChildren#canCall| (Lit |node#0@@4|)) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@4| Tclass.PivotBetree.BetreeNode) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@4|))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |node#0@@4|)))))))))) (and (forall ((|key#0@@0| T@U) ) (!  (=> (and (= (type |key#0@@0|) (SeqType BoxType)) ($Is |key#0@@0| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@0|) (=> (Buffers.__default.AnyKey |key#0@@0|) (and (|PivotBetree.BetreeNode.KeySet#canCall| (Lit |node#0@@4|)) (=> (U_2_bool (MapType0Select (Lit (PivotBetree.BetreeNode.KeySet (Lit |node#0@@4|))) ($Box |key#0@@0|))) (and (|PivotBetree.BetreeNode.Child#canCall| (Lit |node#0@@4|) |key#0@@0|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.BetreeNode.Child (Lit |node#0@@4|) |key#0@@0|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.32:31|
 :skolemid |1265|
 :pattern ( (PivotBetree.BetreeNode.Child |node#0@@4| |key#0@@0|))
 :pattern ( (MapType0Select (PivotBetree.BetreeNode.KeySet |node#0@@4|) ($Box |key#0@@0|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@0|))
)) (= (PivotBetreeRefinement.__default.IChildren ($LS $ly@@4) (Lit |node#0@@4|)) (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#1| (Lit (PivotBetree.BetreeNode.KeySet (Lit |node#0@@4|))) ($LS $ly@@4) (Lit |node#0@@4|) |#PagedBetree.BetreeNode.Nil|) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))))
 :qid |PivotBetreeRefinementbroken1idfy.27:12|
 :weight 3
 :skolemid |1266|
 :pattern ( (PivotBetreeRefinement.__default.IChildren ($LS $ly@@4) (Lit |node#0@@4|)))
))))
(assert (forall ((arg0@@368 T@U) (arg1@@147 T@U) ) (! (= (type (PivotBetreeRefinement.__default.INode arg0@@368 arg1@@147)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.INode|
 :pattern ( (PivotBetreeRefinement.__default.INode arg0@@368 arg1@@147))
)))
(assert (forall (($ly@@5 T@U) (|node#0@@5| T@U) ) (!  (=> (and (= (type $ly@@5) LayerTypeType) (= (type |node#0@@5|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.INode ($LS $ly@@5) |node#0@@5|) (PivotBetreeRefinement.__default.INode $ly@@5 |node#0@@5|)))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :skolemid |1297|
 :pattern ( (PivotBetreeRefinement.__default.INode ($LS $ly@@5) |node#0@@5|))
)))
(assert (forall (($ly@@6 T@U) (|node#0@@6| T@U) ) (!  (=> (and (= (type $ly@@6) LayerTypeType) (= (type |node#0@@6|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.INode $ly@@6 |node#0@@6|) (PivotBetreeRefinement.__default.INode $LZ |node#0@@6|)))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :skolemid |1298|
 :pattern ( (PivotBetreeRefinement.__default.INode (AsFuelBottom $ly@@6) |node#0@@6|))
)))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@7 T@U) (|node#0@@7| T@U) ) (!  (=> (and (and (= (type $ly@@7) LayerTypeType) (= (type |node#0@@7|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.INode#canCall| |node#0@@7|) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@7| Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@7|))))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PivotBetreeRefinement.__default.INode $ly@@7 |node#0@@7|)) ($Is (PivotBetreeRefinement.__default.INode $ly@@7 |node#0@@7|) Tclass.PagedBetree.BetreeNode)))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :skolemid |1299|
 :pattern ( (PivotBetreeRefinement.__default.INode $ly@@7 |node#0@@7|))
))))
(assert (forall (($ly@@8 T@U) (|node#0@@8| T@U) ) (!  (=> (and (and (= (type $ly@@8) LayerTypeType) (= (type |node#0@@8|) DatatypeTypeType)) ($Is |node#0@@8| Tclass.PivotBetree.BetreeNode)) (= (|PivotBetreeRefinement.__default.INode#requires| $ly@@8 |node#0@@8|) (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@8|)))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :skolemid |1300|
 :pattern ( (|PivotBetreeRefinement.__default.INode#requires| $ly@@8 |node#0@@8|))
)))
(assert  (and (forall ((arg0@@369 T@U) (arg1@@148 T@U) ) (! (= (type (|#PagedBetree.BetreeNode.BetreeNode| arg0@@369 arg1@@148)) DatatypeTypeType)
 :qid |funType:#PagedBetree.BetreeNode.BetreeNode|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| arg0@@369 arg1@@148))
)) (forall ((arg0@@370 T@U) ) (! (= (type (PivotBetree.BetreeNode.buffers arg0@@370)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.buffers|
 :pattern ( (PivotBetree.BetreeNode.buffers arg0@@370))
))))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@9 T@U) (|node#0@@9| T@U) ) (!  (=> (and (and (= (type $ly@@9) LayerTypeType) (= (type |node#0@@9|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.INode#canCall| |node#0@@9|) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@9| Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@9|))))) (and (=> (not (PivotBetree.BetreeNode.Nil_q |node#0@@9|)) (|PivotBetreeRefinement.__default.IChildren#canCall| |node#0@@9|)) (= (PivotBetreeRefinement.__default.INode ($LS $ly@@9) |node#0@@9|) (ite (PivotBetree.BetreeNode.Nil_q |node#0@@9|) |#PagedBetree.BetreeNode.Nil| (|#PagedBetree.BetreeNode.BetreeNode| (PivotBetree.BetreeNode.buffers |node#0@@9|) (PivotBetreeRefinement.__default.IChildren $ly@@9 |node#0@@9|))))))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :skolemid |1301|
 :pattern ( (PivotBetreeRefinement.__default.INode ($LS $ly@@9) |node#0@@9|))
))))
(assert  (=> (<= 3 $FunctionContextHeight) (forall (($ly@@10 T@U) (|node#0@@10| T@U) ) (!  (=> (and (and (= (type $ly@@10) LayerTypeType) (= (type |node#0@@10|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.INode#canCall| (Lit |node#0@@10|)) (and (not (= 3 $FunctionContextHeight)) (and ($Is |node#0@@10| Tclass.PivotBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@10|))))))))) (and (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit |node#0@@10|)))))) (|PivotBetreeRefinement.__default.IChildren#canCall| (Lit |node#0@@10|))) (= (PivotBetreeRefinement.__default.INode ($LS $ly@@10) (Lit |node#0@@10|)) (ite (PivotBetree.BetreeNode.Nil_q (Lit |node#0@@10|)) |#PagedBetree.BetreeNode.Nil| (|#PagedBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit |node#0@@10|))) (Lit (PivotBetreeRefinement.__default.IChildren ($LS $ly@@10) (Lit |node#0@@10|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.37:12|
 :weight 3
 :skolemid |1302|
 :pattern ( (PivotBetreeRefinement.__default.INode ($LS $ly@@10) (Lit |node#0@@10|)))
))))
(assert (forall ((arg0@@371 T@U) ) (! (= (type (Tclass.StampedMod.Stamped arg0@@371)) TyType)
 :qid |funType:Tclass.StampedMod.Stamped|
 :pattern ( (Tclass.StampedMod.Stamped arg0@@371))
)))
(assert (forall ((StampedMod.Stamped$T T@U) ) (!  (=> (= (type StampedMod.Stamped$T) TyType) (and (= (Tag (Tclass.StampedMod.Stamped StampedMod.Stamped$T)) Tagclass.StampedMod.Stamped) (= (TagFamily (Tclass.StampedMod.Stamped StampedMod.Stamped$T)) tytagFamily$Stamped)))
 :qid |unknown.0:0|
 :skolemid |1311|
 :pattern ( (Tclass.StampedMod.Stamped StampedMod.Stamped$T))
)))
(assert (forall ((arg0@@372 T@U) ) (! (= (type (Tclass.StampedMod.Stamped_0 arg0@@372)) TyType)
 :qid |funType:Tclass.StampedMod.Stamped_0|
 :pattern ( (Tclass.StampedMod.Stamped_0 arg0@@372))
)))
(assert (forall ((StampedMod.Stamped$T@@0 T@U) ) (!  (=> (= (type StampedMod.Stamped$T@@0) TyType) (= (Tclass.StampedMod.Stamped_0 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0)) StampedMod.Stamped$T@@0))
 :qid |unknown.0:0|
 :skolemid |1312|
 :pattern ( (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0))
)))
(assert (forall ((StampedMod.Stamped$T@@1 T@U) (bx@@111 T@U) ) (!  (=> (and (and (= (type StampedMod.Stamped$T@@1) TyType) (= (type bx@@111) BoxType)) ($IsBox bx@@111 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1))) (and (= ($Box ($Unbox DatatypeTypeType bx@@111)) bx@@111) ($Is ($Unbox DatatypeTypeType bx@@111) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1))))
 :qid |unknown.0:0|
 :skolemid |1313|
 :pattern ( ($IsBox bx@@111 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1)))
)))
(assert  (and (forall ((arg0@@373 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IStampedBetree arg0@@373)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IStampedBetree|
 :pattern ( (PivotBetreeRefinement.__default.IStampedBetree arg0@@373))
)) (forall ((arg0@@374 T@U) ) (! (= (type (StampedMod.Stamped.value arg0@@374)) BoxType)
 :qid |funType:StampedMod.Stamped.value|
 :pattern ( (StampedMod.Stamped.value arg0@@374))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall ((|stampedBetree#0| T@U) ) (!  (=> (and (= (type |stampedBetree#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#0|) (and (not (= 6 $FunctionContextHeight)) (and ($Is |stampedBetree#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0|))))))) ($Is (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#0|) (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))
 :qid |PivotBetreeRefinementbroken1idfy.47:27|
 :skolemid |1314|
 :pattern ( (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#0|))
))))
(assert (forall ((|stampedBetree#0@@0| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@0|) DatatypeTypeType) ($Is |stampedBetree#0@@0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))) (= (|PivotBetreeRefinement.__default.IStampedBetree#requires| |stampedBetree#0@@0|) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@0|)))))
 :qid |PivotBetreeRefinementbroken1idfy.47:27|
 :skolemid |1315|
 :pattern ( (|PivotBetreeRefinement.__default.IStampedBetree#requires| |stampedBetree#0@@0|))
)))
(assert (forall ((arg0@@375 T@U) (arg1@@149 Int) ) (! (= (type (|#StampedMod.Stamped.Stamped| arg0@@375 arg1@@149)) DatatypeTypeType)
 :qid |funType:#StampedMod.Stamped.Stamped|
 :pattern ( (|#StampedMod.Stamped.Stamped| arg0@@375 arg1@@149))
)))
(assert  (=> (<= 6 $FunctionContextHeight) (forall ((|stampedBetree#0@@1| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@1|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#0@@1|) (and (not (= 6 $FunctionContextHeight)) (and ($Is |stampedBetree#0@@1| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|))))))) (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@1|) (|PivotBetreeRefinement.__default.INode#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|)))) (StampedMod.Stamped.Stamped_q |stampedBetree#0@@1|)) (= (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@1|) (|#StampedMod.Stamped.Stamped| ($Box (PivotBetreeRefinement.__default.INode ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|)))) (StampedMod.Stamped.seqEnd |stampedBetree#0@@1|)))))
 :qid |PivotBetreeRefinementbroken1idfy.47:27|
 :skolemid |1316|
 :pattern ( (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@1|))
))))
(assert  (=> (<= 6 $FunctionContextHeight) (forall ((|stampedBetree#0@@2| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@2|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStampedBetree#canCall| (Lit |stampedBetree#0@@2|)) (and (not (= 6 $FunctionContextHeight)) (and ($Is |stampedBetree#0@@2| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|)))))))))))) (and (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@2|)) (|PivotBetreeRefinement.__default.INode#canCall| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|)))))) (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@2|))) (= (PivotBetreeRefinement.__default.IStampedBetree (Lit |stampedBetree#0@@2|)) (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetreeRefinement.__default.INode ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|))))))) (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@2|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.47:27|
 :weight 3
 :skolemid |1317|
 :pattern ( (PivotBetreeRefinement.__default.IStampedBetree (Lit |stampedBetree#0@@2|)))
))))
(assert (= (type Tclass.PivotBetree.TransitionLabel) TyType))
(assert (= (Tag Tclass.PivotBetree.TransitionLabel) Tagclass.PivotBetree.TransitionLabel))
(assert (= (TagFamily Tclass.PivotBetree.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@112 T@U) ) (!  (=> (and (= (type bx@@112) BoxType) ($IsBox bx@@112 Tclass.PivotBetree.TransitionLabel)) (and (= ($Box ($Unbox DatatypeTypeType bx@@112)) bx@@112) ($Is ($Unbox DatatypeTypeType bx@@112) Tclass.PivotBetree.TransitionLabel)))
 :qid |unknown.0:0|
 :skolemid |1326|
 :pattern ( ($IsBox bx@@112 Tclass.PivotBetree.TransitionLabel))
)))
(assert (= (type Tclass.PagedBetree.TransitionLabel) TyType))
(assert (= (Tag Tclass.PagedBetree.TransitionLabel) Tagclass.PagedBetree.TransitionLabel))
(assert (= (TagFamily Tclass.PagedBetree.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@113 T@U) ) (!  (=> (and (= (type bx@@113) BoxType) ($IsBox bx@@113 Tclass.PagedBetree.TransitionLabel)) (and (= ($Box ($Unbox DatatypeTypeType bx@@113)) bx@@113) ($Is ($Unbox DatatypeTypeType bx@@113) Tclass.PagedBetree.TransitionLabel)))
 :qid |unknown.0:0|
 :skolemid |1327|
 :pattern ( ($IsBox bx@@113 Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((arg0@@376 T@U) ) (! (= (type (PivotBetreeRefinement.__default.ILbl arg0@@376)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.ILbl|
 :pattern ( (PivotBetreeRefinement.__default.ILbl arg0@@376))
)))
(assert  (=> (<= 9 $FunctionContextHeight) (forall ((|lbl#0| T@U) ) (!  (=> (and (= (type |lbl#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.ILbl#canCall| |lbl#0|) (and (not (= 9 $FunctionContextHeight)) ($Is |lbl#0| Tclass.PivotBetree.TransitionLabel)))) ($Is (PivotBetreeRefinement.__default.ILbl |lbl#0|) Tclass.PagedBetree.TransitionLabel))
 :qid |PivotBetreeRefinementbroken1idfy.53:17|
 :skolemid |1328|
 :pattern ( (PivotBetreeRefinement.__default.ILbl |lbl#0|))
))))
(assert (forall ((|lbl#0@@0| T@U) ) (!  (=> (and (= (type |lbl#0@@0|) DatatypeTypeType) ($Is |lbl#0@@0| Tclass.PivotBetree.TransitionLabel)) (= (|PivotBetreeRefinement.__default.ILbl#requires| |lbl#0@@0|) true))
 :qid |PivotBetreeRefinementbroken1idfy.53:17|
 :skolemid |1329|
 :pattern ( (|PivotBetreeRefinement.__default.ILbl#requires| |lbl#0@@0|))
)))
(assert  (and (and (and (and (and (and (and (and (and (forall ((arg0@@377 T@U) ) (! (= (type (PivotBetree.TransitionLabel.stampedBetree arg0@@377)) DatatypeTypeType)
 :qid |funType:PivotBetree.TransitionLabel.stampedBetree|
 :pattern ( (PivotBetree.TransitionLabel.stampedBetree arg0@@377))
)) (forall ((arg0@@378 T@U) ) (! (= (type (PivotBetree.TransitionLabel.value arg0@@378)) (SeqType BoxType))
 :qid |funType:PivotBetree.TransitionLabel.value|
 :pattern ( (PivotBetree.TransitionLabel.value arg0@@378))
))) (forall ((arg0@@379 T@U) ) (! (= (type (PivotBetree.TransitionLabel.key arg0@@379)) (SeqType BoxType))
 :qid |funType:PivotBetree.TransitionLabel.key|
 :pattern ( (PivotBetree.TransitionLabel.key arg0@@379))
))) (forall ((arg0@@380 Int) (arg1@@150 T@U) (arg2@@80 T@U) ) (! (= (type (|#PagedBetree.TransitionLabel.QueryLabel| arg0@@380 arg1@@150 arg2@@80)) DatatypeTypeType)
 :qid |funType:#PagedBetree.TransitionLabel.QueryLabel|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| arg0@@380 arg1@@150 arg2@@80))
))) (forall ((arg0@@381 T@U) ) (! (= (type (PivotBetree.TransitionLabel.puts arg0@@381)) DatatypeTypeType)
 :qid |funType:PivotBetree.TransitionLabel.puts|
 :pattern ( (PivotBetree.TransitionLabel.puts arg0@@381))
))) (forall ((arg0@@382 T@U) ) (! (= (type (|#PagedBetree.TransitionLabel.PutLabel| arg0@@382)) DatatypeTypeType)
 :qid |funType:#PagedBetree.TransitionLabel.PutLabel|
 :pattern ( (|#PagedBetree.TransitionLabel.PutLabel| arg0@@382))
))) (forall ((arg0@@383 Int) ) (! (= (type (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| arg0@@383)) DatatypeTypeType)
 :qid |funType:#PagedBetree.TransitionLabel.QueryEndLsnLabel|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| arg0@@383))
))) (forall ((arg0@@384 T@U) ) (! (= (type (|#PagedBetree.TransitionLabel.FreezeAsLabel| arg0@@384)) DatatypeTypeType)
 :qid |funType:#PagedBetree.TransitionLabel.FreezeAsLabel|
 :pattern ( (|#PagedBetree.TransitionLabel.FreezeAsLabel| arg0@@384))
))) (= (type PagedBetree.__default.EmptyImage) DatatypeTypeType)) (= (type |#PagedBetree.TransitionLabel.InternalLabel|) DatatypeTypeType)))
(assert  (=> (<= 9 $FunctionContextHeight) (forall ((|lbl#0@@1| T@U) ) (!  (=> (and (= (type |lbl#0@@1|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.ILbl#canCall| |lbl#0@@1|) (and (not (= 9 $FunctionContextHeight)) ($Is |lbl#0@@1| Tclass.PivotBetree.TransitionLabel)))) (and (=> (not (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@1|)) (=> (not (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@1|)) (=> (not (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@1|)) (=> (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@1|) (let ((|stampedBetree#1| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@1|)))
 (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#1|) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1|)))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1|))) (|PivotBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#1|))) (=> (not (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1|)))) |PagedBetree.__default.EmptyImage#canCall|))))))) (= (PivotBetreeRefinement.__default.ILbl |lbl#0@@1|) (ite (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@1|) (let ((|value#0| (PivotBetree.TransitionLabel.value |lbl#0@@1|)))
(let ((|key#0@@1| (PivotBetree.TransitionLabel.key |lbl#0@@1|)))
(let ((|endLsn#0| (PivotBetree.TransitionLabel.endLsn |lbl#0@@1|)))
(|#PagedBetree.TransitionLabel.QueryLabel| |endLsn#0| |key#0@@1| |value#0|)))) (ite (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@1|) (let ((|puts#0| (PivotBetree.TransitionLabel.puts |lbl#0@@1|)))
(|#PagedBetree.TransitionLabel.PutLabel| |puts#0|)) (ite (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@1|) (let ((|endLsn#1| (PivotBetree.TransitionLabel.endLsn |lbl#0@@1|)))
(|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |endLsn#1|)) (ite (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@1|) (let ((|stampedBetree#0@@3| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@1|)))
(|#PagedBetree.TransitionLabel.FreezeAsLabel| (ite (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@3|))) (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@3|) PagedBetree.__default.EmptyImage))) |#PagedBetree.TransitionLabel.InternalLabel|)))))))
 :qid |PivotBetreeRefinementbroken1idfy.53:17|
 :skolemid |1330|
 :pattern ( (PivotBetreeRefinement.__default.ILbl |lbl#0@@1|))
))))
(assert  (=> (<= 9 $FunctionContextHeight) (forall ((|lbl#0@@2| T@U) ) (!  (=> (and (= (type |lbl#0@@2|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.ILbl#canCall| (Lit |lbl#0@@2|)) (and (not (= 9 $FunctionContextHeight)) ($Is |lbl#0@@2| Tclass.PivotBetree.TransitionLabel)))) (and (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@2|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@2|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@2|)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@2|))))) (let ((|stampedBetree#3| (Lit (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@2|)))))
 (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#3|) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3|)))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3|))) (|PivotBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#3|))) (=> (not (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3|)))) |PagedBetree.__default.EmptyImage#canCall|))))))) (= (PivotBetreeRefinement.__default.ILbl (Lit |lbl#0@@2|)) (ite (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@2|)) (let ((|value#2| (Lit (PivotBetree.TransitionLabel.value (Lit |lbl#0@@2|)))))
(let ((|key#2| (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|)))))
(let ((|endLsn#4| (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@2|)))))
(Lit (|#PagedBetree.TransitionLabel.QueryLabel| |endLsn#4| |key#2| |value#2|))))) (ite (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@2|)) (let ((|puts#2| (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@2|)))))
(Lit (|#PagedBetree.TransitionLabel.PutLabel| |puts#2|))) (ite (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@2|)) (let ((|endLsn#5| (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@2|)))))
(Lit (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |endLsn#5|))) (ite (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@2|)) (let ((|stampedBetree#2| (Lit (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@2|)))))
(|#PagedBetree.TransitionLabel.FreezeAsLabel| (ite (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#2|)))) (PivotBetreeRefinement.__default.IStampedBetree |stampedBetree#2|) PagedBetree.__default.EmptyImage))) |#PagedBetree.TransitionLabel.InternalLabel|)))))))
 :qid |PivotBetreeRefinementbroken1idfy.53:17|
 :weight 3
 :skolemid |1331|
 :pattern ( (PivotBetreeRefinement.__default.ILbl (Lit |lbl#0@@2|)))
))))
(assert (= (type Tclass.MsgHistoryMod.MsgHistory) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.MsgHistory) Tagclass.MsgHistoryMod.MsgHistory))
(assert (= (TagFamily Tclass.MsgHistoryMod.MsgHistory) tytagFamily$MsgHistory))
(assert (forall ((bx@@114 T@U) ) (!  (=> (and (= (type bx@@114) BoxType) ($IsBox bx@@114 Tclass.MsgHistoryMod.MsgHistory)) (and (= ($Box ($Unbox DatatypeTypeType bx@@114)) bx@@114) ($Is ($Unbox DatatypeTypeType bx@@114) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |unknown.0:0|
 :skolemid |1341|
 :pattern ( ($IsBox bx@@114 Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (= (type Tclass.ValueType.Value) TyType))
(assert (= (Tag Tclass.ValueType.Value) Tagclass.ValueType.Value))
(assert (= (TagFamily Tclass.ValueType.Value) tytagFamily$Value))
(assert (forall ((bx@@115 T@U) ) (!  (=> (and (= (type bx@@115) BoxType) ($IsBox bx@@115 Tclass.ValueType.Value)) (and (= ($Box ($Unbox (SeqType BoxType) bx@@115)) bx@@115) ($Is ($Unbox (SeqType BoxType) bx@@115) Tclass.ValueType.Value)))
 :qid |unknown.0:0|
 :skolemid |1342|
 :pattern ( ($IsBox bx@@115 Tclass.ValueType.Value))
)))
(assert (= (type Tclass.NativeTypes.byte) TyType))
(assert (= (Tag Tclass.NativeTypes.byte) Tagclass.NativeTypes.byte))
(assert (= (TagFamily Tclass.NativeTypes.byte) tytagFamily$byte))
(assert (forall ((bx@@116 T@U) ) (!  (=> (and (= (type bx@@116) BoxType) ($IsBox bx@@116 Tclass.NativeTypes.byte)) (and (= ($Box ($Unbox intType bx@@116)) bx@@116) ($Is ($Unbox intType bx@@116) Tclass.NativeTypes.byte)))
 :qid |unknown.0:0|
 :skolemid |1343|
 :pattern ( ($IsBox bx@@116 Tclass.NativeTypes.byte))
)))
(assert (= (type Tclass.PivotBetree.Variables) TyType))
(assert (= (Tag Tclass.PivotBetree.Variables) Tagclass.PivotBetree.Variables))
(assert (= (TagFamily Tclass.PivotBetree.Variables) tytagFamily$Variables))
(assert (forall ((bx@@117 T@U) ) (!  (=> (and (= (type bx@@117) BoxType) ($IsBox bx@@117 Tclass.PivotBetree.Variables)) (and (= ($Box ($Unbox DatatypeTypeType bx@@117)) bx@@117) ($Is ($Unbox DatatypeTypeType bx@@117) Tclass.PivotBetree.Variables)))
 :qid |unknown.0:0|
 :skolemid |1344|
 :pattern ( ($IsBox bx@@117 Tclass.PivotBetree.Variables))
)))
(assert (= (type Tclass.PagedBetree.Variables) TyType))
(assert (= (Tag Tclass.PagedBetree.Variables) Tagclass.PagedBetree.Variables))
(assert (= (TagFamily Tclass.PagedBetree.Variables) tytagFamily$Variables))
(assert (forall ((bx@@118 T@U) ) (!  (=> (and (= (type bx@@118) BoxType) ($IsBox bx@@118 Tclass.PagedBetree.Variables)) (and (= ($Box ($Unbox DatatypeTypeType bx@@118)) bx@@118) ($Is ($Unbox DatatypeTypeType bx@@118) Tclass.PagedBetree.Variables)))
 :qid |unknown.0:0|
 :skolemid |1345|
 :pattern ( ($IsBox bx@@118 Tclass.PagedBetree.Variables))
)))
(assert (forall ((arg0@@385 T@U) ) (! (= (type (PivotBetreeRefinement.__default.I arg0@@385)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.I|
 :pattern ( (PivotBetreeRefinement.__default.I arg0@@385))
)))
(assert  (=> (<= 12 $FunctionContextHeight) (forall ((|v#0| T@U) ) (!  (=> (and (= (type |v#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.I#canCall| |v#0|) (and (not (= 12 $FunctionContextHeight)) (and ($Is |v#0| Tclass.PivotBetree.Variables) (PivotBetree.Variables.WF |v#0|))))) ($Is (PivotBetreeRefinement.__default.I |v#0|) Tclass.PagedBetree.Variables))
 :qid |PivotBetreeRefinementbroken1idfy.66:14|
 :skolemid |1346|
 :pattern ( (PivotBetreeRefinement.__default.I |v#0|))
))))
(assert (forall ((|v#0@@0| T@U) ) (!  (=> (and (= (type |v#0@@0|) DatatypeTypeType) ($Is |v#0@@0| Tclass.PivotBetree.Variables)) (= (|PivotBetreeRefinement.__default.I#requires| |v#0@@0|) (PivotBetree.Variables.WF |v#0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.66:14|
 :skolemid |1347|
 :pattern ( (|PivotBetreeRefinement.__default.I#requires| |v#0@@0|))
)))
(assert  (and (and (forall ((arg0@@386 T@U) ) (! (= (type (PivotBetree.Variables.root arg0@@386)) DatatypeTypeType)
 :qid |funType:PivotBetree.Variables.root|
 :pattern ( (PivotBetree.Variables.root arg0@@386))
)) (forall ((arg0@@387 T@U) (arg1@@151 T@U) ) (! (= (type (|#PagedBetree.Variables.Variables| arg0@@387 arg1@@151)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Variables.Variables|
 :pattern ( (|#PagedBetree.Variables.Variables| arg0@@387 arg1@@151))
))) (forall ((arg0@@388 T@U) ) (! (= (type (PivotBetree.Variables.memtable arg0@@388)) DatatypeTypeType)
 :qid |funType:PivotBetree.Variables.memtable|
 :pattern ( (PivotBetree.Variables.memtable arg0@@388))
))))
(assert  (=> (<= 12 $FunctionContextHeight) (forall ((|v#0@@1| T@U) ) (!  (=> (and (= (type |v#0@@1|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.I#canCall| |v#0@@1|) (and (not (= 12 $FunctionContextHeight)) (and ($Is |v#0@@1| Tclass.PivotBetree.Variables) (PivotBetree.Variables.WF |v#0@@1|))))) (and (and (PivotBetree.Variables.Variables_q |v#0@@1|) (and (PivotBetree.Variables.Variables_q |v#0@@1|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.Variables.root |v#0@@1|)))) (= (PivotBetreeRefinement.__default.I |v#0@@1|) (|#PagedBetree.Variables.Variables| (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetreeRefinement.__default.INode ($LS $LZ) (PivotBetree.Variables.root |v#0@@1|))))))
 :qid |PivotBetreeRefinementbroken1idfy.66:14|
 :skolemid |1348|
 :pattern ( (PivotBetreeRefinement.__default.I |v#0@@1|))
))))
(assert  (=> (<= 12 $FunctionContextHeight) (forall ((|v#0@@2| T@U) ) (!  (=> (and (= (type |v#0@@2|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.I#canCall| (Lit |v#0@@2|)) (and (not (= 12 $FunctionContextHeight)) (and ($Is |v#0@@2| Tclass.PivotBetree.Variables) (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@2|))))))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@2|)) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@2|)) (|PivotBetreeRefinement.__default.INode#canCall| (Lit (PivotBetree.Variables.root (Lit |v#0@@2|)))))) (= (PivotBetreeRefinement.__default.I (Lit |v#0@@2|)) (Lit (|#PagedBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetreeRefinement.__default.INode ($LS $LZ) (Lit (PivotBetree.Variables.root (Lit |v#0@@2|))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.66:14|
 :weight 3
 :skolemid |1349|
 :pattern ( (PivotBetreeRefinement.__default.I (Lit |v#0@@2|)))
))))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((|v#0@@3| T@U) ) (!  (=> (and (= (type |v#0@@3|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.Inv#canCall| |v#0@@3|) (and (not (= 13 $FunctionContextHeight)) ($Is |v#0@@3| Tclass.PivotBetree.Variables)))) true)
 :qid |PivotBetreeRefinementbroken1idfy.72:17|
 :skolemid |1358|
 :pattern ( (PivotBetreeRefinement.__default.Inv |v#0@@3|))
))))
(assert (forall ((|v#0@@4| T@U) ) (!  (=> (and (= (type |v#0@@4|) DatatypeTypeType) ($Is |v#0@@4| Tclass.PivotBetree.Variables)) (= (|PivotBetreeRefinement.__default.Inv#requires| |v#0@@4|) true))
 :qid |PivotBetreeRefinementbroken1idfy.72:17|
 :skolemid |1359|
 :pattern ( (|PivotBetreeRefinement.__default.Inv#requires| |v#0@@4|))
)))
(assert  (and (forall ((arg0@@389 T@U) ) (! (= (type (PivotBetree.BetreeNode.MyDomain arg0@@389)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.MyDomain|
 :pattern ( (PivotBetree.BetreeNode.MyDomain arg0@@389))
)) (= (type DomainMod.__default.TotalDomain) DatatypeTypeType)))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((|v#0@@5| T@U) ) (!  (=> (and (= (type |v#0@@5|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.Inv#canCall| |v#0@@5|) (and (not (= 13 $FunctionContextHeight)) ($Is |v#0@@5| Tclass.PivotBetree.Variables)))) (and (and (|PivotBetree.Variables.WF#canCall| |v#0@@5|) (=> (PivotBetree.Variables.WF |v#0@@5|) (and (PivotBetree.Variables.Variables_q |v#0@@5|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v#0@@5|)) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Variables.root |v#0@@5|))) (|$IsA#DomainMod.Domain| (Lit DomainMod.__default.TotalDomain))) (and (and (PivotBetree.Variables.Variables_q |v#0@@5|) (|PivotBetree.BetreeNode.MyDomain#canCall| (PivotBetree.Variables.root |v#0@@5|))) |DomainMod.__default.TotalDomain#canCall|)))))) (= (PivotBetreeRefinement.__default.Inv |v#0@@5|)  (and (PivotBetree.Variables.WF |v#0@@5|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v#0@@5|)) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Variables.root |v#0@@5|)) DomainMod.__default.TotalDomain))))))
 :qid |PivotBetreeRefinementbroken1idfy.72:17|
 :skolemid |1360|
 :pattern ( (PivotBetreeRefinement.__default.Inv |v#0@@5|))
))))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((|v#0@@6| T@U) ) (!  (=> (and (= (type |v#0@@6|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.Inv#canCall| (Lit |v#0@@6|)) (and (not (= 13 $FunctionContextHeight)) ($Is |v#0@@6| Tclass.PivotBetree.Variables)))) (and (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@6|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@6|))))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@6|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit (PivotBetree.Variables.root (Lit |v#0@@6|))))))) (and (and (|$IsA#DomainMod.Domain| (Lit (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Variables.root (Lit |v#0@@6|)))))) (|$IsA#DomainMod.Domain| (Lit DomainMod.__default.TotalDomain))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@6|)) (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit (PivotBetree.Variables.root (Lit |v#0@@6|))))) |DomainMod.__default.TotalDomain#canCall|)))))) (= (PivotBetreeRefinement.__default.Inv (Lit |v#0@@6|))  (and (PivotBetree.Variables.WF (Lit |v#0@@6|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit (PivotBetree.Variables.root (Lit |v#0@@6|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Variables.root (Lit |v#0@@6|)))) DomainMod.__default.TotalDomain))))))
 :qid |PivotBetreeRefinementbroken1idfy.72:17|
 :weight 3
 :skolemid |1361|
 :pattern ( (PivotBetreeRefinement.__default.Inv (Lit |v#0@@6|)))
))))
(assert (= (type Tclass.PivotBetree.Step) TyType))
(assert (= (Tag Tclass.PivotBetree.Step) Tagclass.PivotBetree.Step))
(assert (= (TagFamily Tclass.PivotBetree.Step) tytagFamily$Step))
(assert (forall ((bx@@119 T@U) ) (!  (=> (and (= (type bx@@119) BoxType) ($IsBox bx@@119 Tclass.PivotBetree.Step)) (and (= ($Box ($Unbox DatatypeTypeType bx@@119)) bx@@119) ($Is ($Unbox DatatypeTypeType bx@@119) Tclass.PivotBetree.Step)))
 :qid |unknown.0:0|
 :skolemid |1407|
 :pattern ( ($IsBox bx@@119 Tclass.PivotBetree.Step))
)))
(assert (= (type Tclass.PivotBetree.Path) TyType))
(assert (= (Tag Tclass.PivotBetree.Path) Tagclass.PivotBetree.Path))
(assert (= (TagFamily Tclass.PivotBetree.Path) tytagFamily$Path))
(assert (forall ((bx@@120 T@U) ) (!  (=> (and (= (type bx@@120) BoxType) ($IsBox bx@@120 Tclass.PivotBetree.Path)) (and (= ($Box ($Unbox DatatypeTypeType bx@@120)) bx@@120) ($Is ($Unbox DatatypeTypeType bx@@120) Tclass.PivotBetree.Path)))
 :qid |unknown.0:0|
 :skolemid |1413|
 :pattern ( ($IsBox bx@@120 Tclass.PivotBetree.Path))
)))
(assert (= (type Tclass.SplitRequestMod.SplitRequest) TyType))
(assert (= (Tag Tclass.SplitRequestMod.SplitRequest) Tagclass.SplitRequestMod.SplitRequest))
(assert (= (TagFamily Tclass.SplitRequestMod.SplitRequest) tytagFamily$SplitRequest))
(assert (forall ((bx@@121 T@U) ) (!  (=> (and (= (type bx@@121) BoxType) ($IsBox bx@@121 Tclass.SplitRequestMod.SplitRequest)) (and (= ($Box ($Unbox DatatypeTypeType bx@@121)) bx@@121) ($Is ($Unbox DatatypeTypeType bx@@121) Tclass.SplitRequestMod.SplitRequest)))
 :qid |unknown.0:0|
 :skolemid |1428|
 :pattern ( ($IsBox bx@@121 Tclass.SplitRequestMod.SplitRequest))
)))
(assert  (and (forall ((arg0@@390 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitParentDefn#Handle| arg0@@390)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParentDefn#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitParentDefn#Handle| arg0@@390))
)) (forall ((arg0@@391 T@U) (arg1@@152 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitParentDefn arg0@@391 arg1@@152)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParentDefn|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn arg0@@391 arg1@@152))
))))
(assert (forall (($self T@U) ($heap T@U) (|$fh$0x#0| T@U) ) (!  (=> (and (and (= (type $self) DatatypeTypeType) (= (type $heap) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0|) BoxType)) (= (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self) |$fh$0x#0|) ($Box (PivotBetree.BetreeNode.SplitParentDefn $self ($Unbox DatatypeTypeType |$fh$0x#0|)))))
 :qid |unknown.0:0|
 :skolemid |1429|
 :pattern ( (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self) |$fh$0x#0|))
)))
(assert (forall (($self@@0 T@U) ($heap@@0 T@U) (|$fh$0x#0@@0| T@U) ) (!  (=> (and (and (= (type $self@@0) DatatypeTypeType) (= (type $heap@@0) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@0|) BoxType)) (= (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@0 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@0) |$fh$0x#0@@0|) (|PivotBetree.BetreeNode.SplitParentDefn#requires| $self@@0 ($Unbox DatatypeTypeType |$fh$0x#0@@0|))))
 :qid |unknown.0:0|
 :skolemid |1430|
 :pattern ( (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@0 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@0) |$fh$0x#0@@0|))
)))
(assert (forall (($bx T@U) ($self@@1 T@U) ($heap@@1 T@U) (|$fh$0x#0@@1| T@U) ) (!  (=> (and (and (and (= (type $bx) BoxType) (= (type $self@@1) DatatypeTypeType)) (= (type $heap@@1) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@1 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@1) |$fh$0x#0@@1|) $bx)) false))
 :qid |unknown.0:0|
 :skolemid |1431|
 :pattern ( (MapType0Select (Reads1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@1 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@1) |$fh$0x#0@@1|) $bx))
)))
(assert (forall (($self@@2 T@U) ($heap@@2 T@U) (|$fh$0x#0@@2| T@U) ) (!  (=> (and (and (= (type $self@@2) DatatypeTypeType) (= (type $heap@@2) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@2|) DatatypeTypeType)) (= (PivotBetree.BetreeNode.SplitParentDefn $self@@2 |$fh$0x#0@@2|) ($Unbox DatatypeTypeType (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@2 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@2) ($Box |$fh$0x#0@@2|)))))
 :qid |unknown.0:0|
 :skolemid |1432|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn $self@@2 |$fh$0x#0@@2|) ($IsGoodHeap $heap@@2))
)))
(assert (= (type Tclass.Buffers.BufferStack) TyType))
(assert (= (Tag Tclass.Buffers.BufferStack) Tagclass.Buffers.BufferStack))
(assert (= (TagFamily Tclass.Buffers.BufferStack) tytagFamily$BufferStack))
(assert (forall ((bx@@122 T@U) ) (!  (=> (and (= (type bx@@122) BoxType) ($IsBox bx@@122 Tclass.Buffers.BufferStack)) (and (= ($Box ($Unbox DatatypeTypeType bx@@122)) bx@@122) ($Is ($Unbox DatatypeTypeType bx@@122) Tclass.Buffers.BufferStack)))
 :qid |unknown.0:0|
 :skolemid |1472|
 :pattern ( ($IsBox bx@@122 Tclass.Buffers.BufferStack))
)))
(assert (forall ((arg0@@392 T@U) (arg1@@153 T@U) ) (! (= (type (PivotBetreeRefinement.__default.Routing arg0@@392 arg1@@153)) (SeqType BoxType))
 :qid |funType:PivotBetreeRefinement.__default.Routing|
 :pattern ( (PivotBetreeRefinement.__default.Routing arg0@@392 arg1@@153))
)))
(assert (forall (($ly@@11 T@U) (|path#0| T@U) ) (!  (=> (and (= (type $ly@@11) LayerTypeType) (= (type |path#0|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.Routing ($LS $ly@@11) |path#0|) (PivotBetreeRefinement.__default.Routing $ly@@11 |path#0|)))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :skolemid |1476|
 :pattern ( (PivotBetreeRefinement.__default.Routing ($LS $ly@@11) |path#0|))
)))
(assert (forall (($ly@@12 T@U) (|path#0@@0| T@U) ) (!  (=> (and (= (type $ly@@12) LayerTypeType) (= (type |path#0@@0|) DatatypeTypeType)) (= (PivotBetreeRefinement.__default.Routing $ly@@12 |path#0@@0|) (PivotBetreeRefinement.__default.Routing $LZ |path#0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :skolemid |1477|
 :pattern ( (PivotBetreeRefinement.__default.Routing (AsFuelBottom $ly@@12) |path#0@@0|))
)))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@13 T@U) (|path#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@13) LayerTypeType) (= (type |path#0@@1|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.Routing#canCall| |path#0@@1|) (and (not (= 19 $FunctionContextHeight)) (and ($Is |path#0@@1| Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@1|))))) ($Is (PivotBetreeRefinement.__default.Routing $ly@@13 |path#0@@1|) (TSeq (TISet Tclass.KeyType.Key))))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :skolemid |1478|
 :pattern ( (PivotBetreeRefinement.__default.Routing $ly@@13 |path#0@@1|))
))))
(assert (forall (($ly@@14 T@U) (|path#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@14) LayerTypeType) (= (type |path#0@@2|) DatatypeTypeType)) ($Is |path#0@@2| Tclass.PivotBetree.Path)) (= (|PivotBetreeRefinement.__default.Routing#requires| $ly@@14 |path#0@@2|) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@2|)))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :skolemid |1479|
 :pattern ( (|PivotBetreeRefinement.__default.Routing#requires| $ly@@14 |path#0@@2|))
)))
(assert  (and (and (and (and (forall ((arg0@@393 T@U) ) (! (= (type (PivotBetree.BetreeNode.pivotTable arg0@@393)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.pivotTable|
 :pattern ( (PivotBetree.BetreeNode.pivotTable arg0@@393))
)) (forall ((arg0@@394 T@U) ) (! (= (type (PivotBetree.Path.node arg0@@394)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.node|
 :pattern ( (PivotBetree.Path.node arg0@@394))
))) (forall ((arg0@@395 T@U) ) (! (= (type (PivotBetree.Path.key arg0@@395)) (SeqType BoxType))
 :qid |funType:PivotBetree.Path.key|
 :pattern ( (PivotBetree.Path.key arg0@@395))
))) (forall ((arg0@@396 T@U) ) (! (= (type (PivotBetree.Path.Subpath arg0@@396)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Subpath|
 :pattern ( (PivotBetree.Path.Subpath arg0@@396))
))) (forall ((arg0@@397 T@U) (arg1@@154 Int) ) (! (= (type (BoundedPivotsLib.__default.PivotTableBucketKeySet arg0@@397 arg1@@154)) (MapType0Type BoxType boolType))
 :qid |funType:BoundedPivotsLib.__default.PivotTableBucketKeySet|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet arg0@@397 arg1@@154))
))))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@15 T@U) (|path#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@15) LayerTypeType) (= (type |path#0@@3|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.Routing#canCall| |path#0@@3|) (and (not (= 19 $FunctionContextHeight)) (and ($Is |path#0@@3| Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@3|))))) (and (and (PivotBetree.Path.Path_q |path#0@@3|) (=> (not (= (PivotBetree.Path.depth |path#0@@3|) (LitInt 0))) (and (and (and (PivotBetree.Path.Path_q |path#0@@3|) (and (and (PivotBetree.Path.Path_q |path#0@@3|) (PivotBetree.Path.Path_q |path#0@@3|)) (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path#0@@3|)) (PivotBetree.Path.key |path#0@@3|)))) (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path#0@@3|)) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path#0@@3|)) (PivotBetree.Path.key |path#0@@3|)))) (and (|PivotBetree.Path.Subpath#canCall| |path#0@@3|) (|PivotBetreeRefinement.__default.Routing#canCall| (PivotBetree.Path.Subpath |path#0@@3|)))))) (= (PivotBetreeRefinement.__default.Routing ($LS $ly@@15) |path#0@@3|) (ite (= (PivotBetree.Path.depth |path#0@@3|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|keys#0| (BoundedPivotsLib.__default.PivotTableBucketKeySet (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path#0@@3|)) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path#0@@3|)) (PivotBetree.Path.key |path#0@@3|)))))
(|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |keys#0|)) (PivotBetreeRefinement.__default.Routing $ly@@15 (PivotBetree.Path.Subpath |path#0@@3|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :skolemid |1480|
 :pattern ( (PivotBetreeRefinement.__default.Routing ($LS $ly@@15) |path#0@@3|))
))))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@16 T@U) (|path#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@16) LayerTypeType) (= (type |path#0@@4|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.Routing#canCall| (Lit |path#0@@4|)) (and (not (= 19 $FunctionContextHeight)) (and ($Is |path#0@@4| Tclass.PivotBetree.Path) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit |path#0@@4|))))))))) (and (and (PivotBetree.Path.Path_q (Lit |path#0@@4|)) (=> (not (= (LitInt (PivotBetree.Path.depth (Lit |path#0@@4|))) (LitInt 0))) (and (and (and (PivotBetree.Path.Path_q (Lit |path#0@@4|)) (and (and (PivotBetree.Path.Path_q (Lit |path#0@@4|)) (PivotBetree.Path.Path_q (Lit |path#0@@4|))) (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit |path#0@@4|))))) (Lit (PivotBetree.Path.key (Lit |path#0@@4|)))))) (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit |path#0@@4|))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit |path#0@@4|))))) (Lit (PivotBetree.Path.key (Lit |path#0@@4|))))))) (and (|PivotBetree.Path.Subpath#canCall| (Lit |path#0@@4|)) (|PivotBetreeRefinement.__default.Routing#canCall| (Lit (PivotBetree.Path.Subpath (Lit |path#0@@4|)))))))) (= (PivotBetreeRefinement.__default.Routing ($LS $ly@@16) (Lit |path#0@@4|)) (ite (= (LitInt (PivotBetree.Path.depth (Lit |path#0@@4|))) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|keys#1| (Lit (BoundedPivotsLib.__default.PivotTableBucketKeySet (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit |path#0@@4|))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit |path#0@@4|))))) (Lit (PivotBetree.Path.key (Lit |path#0@@4|)))))))))
(|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |keys#1|)) (PivotBetreeRefinement.__default.Routing ($LS $ly@@16) (Lit (PivotBetree.Path.Subpath (Lit |path#0@@4|))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.110:12|
 :weight 3
 :skolemid |1481|
 :pattern ( (PivotBetreeRefinement.__default.Routing ($LS $ly@@16) (Lit |path#0@@4|)))
))))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order.Element) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order.Element) Tagclass.Upperbounded__Lexicographic__Byte__Order.Element))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order.Element) tytagFamily$Element))
(assert (forall ((bx@@123 T@U) ) (!  (=> (and (= (type bx@@123) BoxType) ($IsBox bx@@123 Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (= ($Box ($Unbox DatatypeTypeType bx@@123)) bx@@123) ($Is ($Unbox DatatypeTypeType bx@@123) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |unknown.0:0|
 :skolemid |1483|
 :pattern ( ($IsBox bx@@123 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (= (type Tclass.PagedBetree.Path) TyType))
(assert (= (Tag Tclass.PagedBetree.Path) Tagclass.PagedBetree.Path))
(assert (= (TagFamily Tclass.PagedBetree.Path) tytagFamily$Path))
(assert (forall ((bx@@124 T@U) ) (!  (=> (and (= (type bx@@124) BoxType) ($IsBox bx@@124 Tclass.PagedBetree.Path)) (and (= ($Box ($Unbox DatatypeTypeType bx@@124)) bx@@124) ($Is ($Unbox DatatypeTypeType bx@@124) Tclass.PagedBetree.Path)))
 :qid |unknown.0:0|
 :skolemid |1516|
 :pattern ( ($IsBox bx@@124 Tclass.PagedBetree.Path))
)))
(assert (forall ((arg0@@398 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IPath arg0@@398)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IPath|
 :pattern ( (PivotBetreeRefinement.__default.IPath arg0@@398))
)))
(assert  (=> (<= 21 $FunctionContextHeight) (forall ((|path#0@@5| T@U) ) (!  (=> (and (= (type |path#0@@5|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IPath#canCall| |path#0@@5|) (and (not (= 21 $FunctionContextHeight)) (and ($Is |path#0@@5| Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@5|))))) ($Is (PivotBetreeRefinement.__default.IPath |path#0@@5|) Tclass.PagedBetree.Path))
 :qid |PivotBetreeRefinementbroken1idfy.121:18|
 :skolemid |1517|
 :pattern ( (PivotBetreeRefinement.__default.IPath |path#0@@5|))
))))
(assert (forall ((|path#0@@6| T@U) ) (!  (=> (and (= (type |path#0@@6|) DatatypeTypeType) ($Is |path#0@@6| Tclass.PivotBetree.Path)) (= (|PivotBetreeRefinement.__default.IPath#requires| |path#0@@6|) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@6|)))
 :qid |PivotBetreeRefinementbroken1idfy.121:18|
 :skolemid |1518|
 :pattern ( (|PivotBetreeRefinement.__default.IPath#requires| |path#0@@6|))
)))
(assert (forall ((arg0@@399 T@U) (arg1@@155 T@U) (arg2@@81 T@U) ) (! (= (type (|#PagedBetree.Path.Path| arg0@@399 arg1@@155 arg2@@81)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Path.Path|
 :pattern ( (|#PagedBetree.Path.Path| arg0@@399 arg1@@155 arg2@@81))
)))
(assert  (=> (<= 21 $FunctionContextHeight) (forall ((|path#0@@7| T@U) ) (!  (=> (and (= (type |path#0@@7|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IPath#canCall| |path#0@@7|) (and (not (= 21 $FunctionContextHeight)) (and ($Is |path#0@@7| Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) |path#0@@7|))))) (and (and (and (and (PivotBetree.Path.Path_q |path#0@@7|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.Path.node |path#0@@7|))) (PivotBetree.Path.Path_q |path#0@@7|)) (|PivotBetreeRefinement.__default.Routing#canCall| |path#0@@7|)) (= (PivotBetreeRefinement.__default.IPath |path#0@@7|) (|#PagedBetree.Path.Path| (PivotBetreeRefinement.__default.INode ($LS $LZ) (PivotBetree.Path.node |path#0@@7|)) (PivotBetree.Path.key |path#0@@7|) (PivotBetreeRefinement.__default.Routing ($LS $LZ) |path#0@@7|)))))
 :qid |PivotBetreeRefinementbroken1idfy.121:18|
 :skolemid |1519|
 :pattern ( (PivotBetreeRefinement.__default.IPath |path#0@@7|))
))))
(assert  (=> (<= 21 $FunctionContextHeight) (forall ((|path#0@@8| T@U) ) (!  (=> (and (= (type |path#0@@8|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IPath#canCall| (Lit |path#0@@8|)) (and (not (= 21 $FunctionContextHeight)) (and ($Is |path#0@@8| Tclass.PivotBetree.Path) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit |path#0@@8|))))))))) (and (and (and (and (PivotBetree.Path.Path_q (Lit |path#0@@8|)) (|PivotBetreeRefinement.__default.INode#canCall| (Lit (PivotBetree.Path.node (Lit |path#0@@8|))))) (PivotBetree.Path.Path_q (Lit |path#0@@8|))) (|PivotBetreeRefinement.__default.Routing#canCall| (Lit |path#0@@8|))) (= (PivotBetreeRefinement.__default.IPath (Lit |path#0@@8|)) (Lit (|#PagedBetree.Path.Path| (Lit (PivotBetreeRefinement.__default.INode ($LS $LZ) (Lit (PivotBetree.Path.node (Lit |path#0@@8|))))) (Lit (PivotBetree.Path.key (Lit |path#0@@8|))) (Lit (PivotBetreeRefinement.__default.Routing ($LS $LZ) (Lit |path#0@@8|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.121:18|
 :weight 3
 :skolemid |1520|
 :pattern ( (PivotBetreeRefinement.__default.IPath (Lit |path#0@@8|)))
))))
(assert (= (type Tclass.PivotBetree.QueryReceiptLine) TyType))
(assert (= (Tag Tclass.PivotBetree.QueryReceiptLine) Tagclass.PivotBetree.QueryReceiptLine))
(assert (= (TagFamily Tclass.PivotBetree.QueryReceiptLine) tytagFamily$QueryReceiptLine))
(assert (forall ((bx@@125 T@U) ) (!  (=> (and (= (type bx@@125) BoxType) ($IsBox bx@@125 Tclass.PivotBetree.QueryReceiptLine)) (and (= ($Box ($Unbox DatatypeTypeType bx@@125)) bx@@125) ($Is ($Unbox DatatypeTypeType bx@@125) Tclass.PivotBetree.QueryReceiptLine)))
 :qid |unknown.0:0|
 :skolemid |1733|
 :pattern ( ($IsBox bx@@125 Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (= (type Tclass.PagedBetree.QueryReceiptLine) TyType))
(assert (= (Tag Tclass.PagedBetree.QueryReceiptLine) Tagclass.PagedBetree.QueryReceiptLine))
(assert (= (TagFamily Tclass.PagedBetree.QueryReceiptLine) tytagFamily$QueryReceiptLine))
(assert (forall ((bx@@126 T@U) ) (!  (=> (and (= (type bx@@126) BoxType) ($IsBox bx@@126 Tclass.PagedBetree.QueryReceiptLine)) (and (= ($Box ($Unbox DatatypeTypeType bx@@126)) bx@@126) ($Is ($Unbox DatatypeTypeType bx@@126) Tclass.PagedBetree.QueryReceiptLine)))
 :qid |unknown.0:0|
 :skolemid |1734|
 :pattern ( ($IsBox bx@@126 Tclass.PagedBetree.QueryReceiptLine))
)))
(assert (forall ((arg0@@400 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IReceiptLine arg0@@400)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IReceiptLine|
 :pattern ( (PivotBetreeRefinement.__default.IReceiptLine arg0@@400))
)))
(assert  (=> (<= 27 $FunctionContextHeight) (forall ((|line#0| T@U) ) (!  (=> (and (= (type |line#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IReceiptLine#canCall| |line#0|) (and (not (= 27 $FunctionContextHeight)) (and ($Is |line#0| Tclass.PivotBetree.QueryReceiptLine) (PivotBetree.QueryReceiptLine.WF |line#0|))))) ($Is (PivotBetreeRefinement.__default.IReceiptLine |line#0|) Tclass.PagedBetree.QueryReceiptLine))
 :qid |PivotBetreeRefinementbroken1idfy.150:25|
 :skolemid |1735|
 :pattern ( (PivotBetreeRefinement.__default.IReceiptLine |line#0|))
))))
(assert (forall ((|line#0@@0| T@U) ) (!  (=> (and (= (type |line#0@@0|) DatatypeTypeType) ($Is |line#0@@0| Tclass.PivotBetree.QueryReceiptLine)) (= (|PivotBetreeRefinement.__default.IReceiptLine#requires| |line#0@@0|) (PivotBetree.QueryReceiptLine.WF |line#0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.150:25|
 :skolemid |1736|
 :pattern ( (|PivotBetreeRefinement.__default.IReceiptLine#requires| |line#0@@0|))
)))
(assert  (and (and (forall ((arg0@@401 T@U) ) (! (= (type (PivotBetree.QueryReceiptLine.node arg0@@401)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceiptLine.node|
 :pattern ( (PivotBetree.QueryReceiptLine.node arg0@@401))
)) (forall ((arg0@@402 T@U) (arg1@@156 T@U) ) (! (= (type (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| arg0@@402 arg1@@156)) DatatypeTypeType)
 :qid |funType:#PagedBetree.QueryReceiptLine.QueryReceiptLine|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| arg0@@402 arg1@@156))
))) (forall ((arg0@@403 T@U) ) (! (= (type (PivotBetree.QueryReceiptLine.result arg0@@403)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceiptLine.result|
 :pattern ( (PivotBetree.QueryReceiptLine.result arg0@@403))
))))
(assert  (=> (<= 27 $FunctionContextHeight) (forall ((|line#0@@1| T@U) ) (!  (=> (and (= (type |line#0@@1|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IReceiptLine#canCall| |line#0@@1|) (and (not (= 27 $FunctionContextHeight)) (and ($Is |line#0@@1| Tclass.PivotBetree.QueryReceiptLine) (PivotBetree.QueryReceiptLine.WF |line#0@@1|))))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q |line#0@@1|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.QueryReceiptLine.node |line#0@@1|))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q |line#0@@1|)) (= (PivotBetreeRefinement.__default.IReceiptLine |line#0@@1|) (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (PivotBetreeRefinement.__default.INode ($LS $LZ) (PivotBetree.QueryReceiptLine.node |line#0@@1|)) (PivotBetree.QueryReceiptLine.result |line#0@@1|)))))
 :qid |PivotBetreeRefinementbroken1idfy.150:25|
 :skolemid |1737|
 :pattern ( (PivotBetreeRefinement.__default.IReceiptLine |line#0@@1|))
))))
(assert  (=> (<= 27 $FunctionContextHeight) (forall ((|line#0@@2| T@U) ) (!  (=> (and (= (type |line#0@@2|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IReceiptLine#canCall| (Lit |line#0@@2|)) (and (not (= 27 $FunctionContextHeight)) (and ($Is |line#0@@2| Tclass.PivotBetree.QueryReceiptLine) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceiptLine.WF (Lit |line#0@@2|))))))))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit |line#0@@2|)) (|PivotBetreeRefinement.__default.INode#canCall| (Lit (PivotBetree.QueryReceiptLine.node (Lit |line#0@@2|))))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit |line#0@@2|))) (= (PivotBetreeRefinement.__default.IReceiptLine (Lit |line#0@@2|)) (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit (PivotBetreeRefinement.__default.INode ($LS $LZ) (Lit (PivotBetree.QueryReceiptLine.node (Lit |line#0@@2|))))) (Lit (PivotBetree.QueryReceiptLine.result (Lit |line#0@@2|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.150:25|
 :weight 3
 :skolemid |1738|
 :pattern ( (PivotBetreeRefinement.__default.IReceiptLine (Lit |line#0@@2|)))
))))
(assert (= (type Tclass.PivotBetree.QueryReceipt) TyType))
(assert (= (Tag Tclass.PivotBetree.QueryReceipt) Tagclass.PivotBetree.QueryReceipt))
(assert (= (TagFamily Tclass.PivotBetree.QueryReceipt) tytagFamily$QueryReceipt))
(assert (forall ((bx@@127 T@U) ) (!  (=> (and (= (type bx@@127) BoxType) ($IsBox bx@@127 Tclass.PivotBetree.QueryReceipt)) (and (= ($Box ($Unbox DatatypeTypeType bx@@127)) bx@@127) ($Is ($Unbox DatatypeTypeType bx@@127) Tclass.PivotBetree.QueryReceipt)))
 :qid |unknown.0:0|
 :skolemid |1747|
 :pattern ( ($IsBox bx@@127 Tclass.PivotBetree.QueryReceipt))
)))
(assert (= (type Tclass.PagedBetree.QueryReceipt) TyType))
(assert (= (Tag Tclass.PagedBetree.QueryReceipt) Tagclass.PagedBetree.QueryReceipt))
(assert (= (TagFamily Tclass.PagedBetree.QueryReceipt) tytagFamily$QueryReceipt))
(assert (forall ((bx@@128 T@U) ) (!  (=> (and (= (type bx@@128) BoxType) ($IsBox bx@@128 Tclass.PagedBetree.QueryReceipt)) (and (= ($Box ($Unbox DatatypeTypeType bx@@128)) bx@@128) ($Is ($Unbox DatatypeTypeType bx@@128) Tclass.PagedBetree.QueryReceipt)))
 :qid |unknown.0:0|
 :skolemid |1748|
 :pattern ( ($IsBox bx@@128 Tclass.PagedBetree.QueryReceipt))
)))
(assert (forall ((arg0@@404 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IReceipt arg0@@404)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IReceipt|
 :pattern ( (PivotBetreeRefinement.__default.IReceipt arg0@@404))
)))
(assert  (=> (<= 30 $FunctionContextHeight) (forall ((|receipt#0| T@U) ) (!  (=> (and (= (type |receipt#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IReceipt#canCall| |receipt#0|) (and (not (= 30 $FunctionContextHeight)) (and ($Is |receipt#0| Tclass.PivotBetree.QueryReceipt) (PivotBetree.QueryReceipt.Valid |receipt#0|))))) ($Is (PivotBetreeRefinement.__default.IReceipt |receipt#0|) Tclass.PagedBetree.QueryReceipt))
 :qid |PivotBetreeRefinementbroken1idfy.156:21|
 :skolemid |1749|
 :pattern ( (PivotBetreeRefinement.__default.IReceipt |receipt#0|))
))))
(assert (forall (($Heap T@U) (|receipt#0@@0| T@U) ) (!  (=> (and (and (= (type $Heap) (MapType0Type refType MapType1Type)) (= (type |receipt#0@@0|) DatatypeTypeType)) (and ($IsGoodHeap $Heap) ($Is |receipt#0@@0| Tclass.PivotBetree.QueryReceipt))) (= (|PivotBetreeRefinement.__default.IReceipt#requires| |receipt#0@@0|) (PivotBetree.QueryReceipt.Valid |receipt#0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.156:12|
 :skolemid |1750|
 :pattern ( (|PivotBetreeRefinement.__default.IReceipt#requires| |receipt#0@@0|) ($IsGoodHeap $Heap))
)))
(assert  (and (and (and (and (and (and (and (and (forall ((arg0@@405 T@U) ) (! (= (type (PivotBetree.QueryReceipt.root arg0@@405)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.root|
 :pattern ( (PivotBetree.QueryReceipt.root arg0@@405))
)) (forall ((arg0@@406 T@U) ) (! (= (type (PivotBetree.QueryReceipt.lines arg0@@406)) (SeqType BoxType))
 :qid |funType:PivotBetree.QueryReceipt.lines|
 :pattern ( (PivotBetree.QueryReceipt.lines arg0@@406))
))) (forall ((arg0@@407 T@U) (arg1@@157 T@U) (arg2@@82 T@U) ) (! (= (type (|#PagedBetree.QueryReceipt.QueryReceipt| arg0@@407 arg1@@157 arg2@@82)) DatatypeTypeType)
 :qid |funType:#PagedBetree.QueryReceipt.QueryReceipt|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| arg0@@407 arg1@@157 arg2@@82))
))) (forall ((arg0@@408 T@U) ) (! (= (type (PivotBetree.QueryReceipt.key arg0@@408)) (SeqType BoxType))
 :qid |funType:PivotBetree.QueryReceipt.key|
 :pattern ( (PivotBetree.QueryReceipt.key arg0@@408))
))) (forall ((arg0@@409 T@U) ) (! (= (type (|lambda#35| arg0@@409)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#35|
 :pattern ( (|lambda#35| arg0@@409))
))) (forall ((arg0@@410 T@U) ) (! (= (type (|lambda#31| arg0@@410)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#31|
 :pattern ( (|lambda#31| arg0@@410))
))) (forall ((arg0@@411 T@U) (arg1@@158 Int) (arg2@@83 Int) ) (! (= (type (|lambda#32| arg0@@411 arg1@@158 arg2@@83)) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))
 :qid |funType:lambda#32|
 :pattern ( (|lambda#32| arg0@@411 arg1@@158 arg2@@83))
))) (forall ((arg0@@412 T@U) ) (! (= (type (|lambda#34| arg0@@412)) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#34|
 :pattern ( (|lambda#34| arg0@@412))
))) (forall ((arg0@@413 Bool) ) (! (= (type (|lambda#33| arg0@@413)) (MapType0Type refType boolType))
 :qid |funType:lambda#33|
 :pattern ( (|lambda#33| arg0@@413))
))))
(assert  (=> (<= 30 $FunctionContextHeight) (forall (($Heap@@0 T@U) (|receipt#0@@1| T@U) ) (!  (=> (and (and (= (type $Heap@@0) (MapType0Type refType MapType1Type)) (= (type |receipt#0@@1|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.IReceipt#canCall| |receipt#0@@1|) (and (not (= 30 $FunctionContextHeight)) (and (and ($IsGoodHeap $Heap@@0) ($Is |receipt#0@@1| Tclass.PivotBetree.QueryReceipt)) (PivotBetree.QueryReceipt.Valid |receipt#0@@1|))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q |receipt#0@@1|) (and (PivotBetree.QueryReceipt.QueryReceipt_q |receipt#0@@1|) (|PivotBetreeRefinement.__default.INode#canCall| (PivotBetree.QueryReceipt.root |receipt#0@@1|)))) (and (PivotBetree.QueryReceipt.QueryReceipt_q |receipt#0@@1|) (forall ((|$l#1#i#0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0|) (PivotBetree.QueryReceipt.QueryReceipt_q |receipt#0@@1|)) (=> (and (INTERNAL_le_boogie 0 |$l#1#i#0|) (INTERNAL_lt_boogie |$l#1#i#0| (|Seq#Length| (PivotBetree.QueryReceipt.lines |receipt#0@@1|)))) (and (PivotBetree.QueryReceipt.QueryReceipt_q |receipt#0@@1|) (|PivotBetreeRefinement.__default.IReceiptLine#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines |receipt#0@@1|) |$l#1#i#0|))))))
 :qid |unknown.0:0|
 :skolemid |1751|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0| (|Seq#Length| (PivotBetree.QueryReceipt.lines |receipt#0@@1|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
)))) (= (PivotBetreeRefinement.__default.IReceipt |receipt#0@@1|) (|#PagedBetree.QueryReceipt.QueryReceipt| (PivotBetree.QueryReceipt.key |receipt#0@@1|) (PivotBetreeRefinement.__default.INode ($LS $LZ) (PivotBetree.QueryReceipt.root |receipt#0@@1|)) (|Seq#Create| Tclass.PagedBetree.QueryReceiptLine $Heap@@0 (|Seq#Length| (PivotBetree.QueryReceipt.lines |receipt#0@@1|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#31| (PivotBetree.QueryReceipt.lines |receipt#0@@1|)) (|lambda#32| TInt 0 (|Seq#Length| (PivotBetree.QueryReceipt.lines |receipt#0@@1|))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))))
 :qid |PivotBetreeRefinementbroken1idfy.156:12|
 :skolemid |1752|
 :pattern ( (PivotBetreeRefinement.__default.IReceipt |receipt#0@@1|) ($IsGoodHeap $Heap@@0))
))))
(assert  (=> (<= 30 $FunctionContextHeight) (forall (($Heap@@1 T@U) (|receipt#0@@2| T@U) ) (!  (=> (and (and (= (type $Heap@@1) (MapType0Type refType MapType1Type)) (= (type |receipt#0@@2|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.IReceipt#canCall| (Lit |receipt#0@@2|)) (and (not (= 30 $FunctionContextHeight)) (and (and ($IsGoodHeap $Heap@@1) ($Is |receipt#0@@2| Tclass.PivotBetree.QueryReceipt)) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Valid (Lit |receipt#0@@2|))))))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@2|)) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@2|)) (|PivotBetreeRefinement.__default.INode#canCall| (Lit (PivotBetree.QueryReceipt.root (Lit |receipt#0@@2|)))))) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@2|)) (forall ((|$l#3#i#0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0|) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@2|))) (=> (and (INTERNAL_le_boogie 0 |$l#3#i#0|) (INTERNAL_lt_boogie |$l#3#i#0| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|)))))) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@2|)) (|PivotBetreeRefinement.__default.IReceiptLine#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|))) |$l#3#i#0|))))))
 :qid |unknown.0:0|
 :skolemid |1753|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|)))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
)))) (= (PivotBetreeRefinement.__default.IReceipt (Lit |receipt#0@@2|)) (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit (PivotBetree.QueryReceipt.key (Lit |receipt#0@@2|))) (Lit (PivotBetreeRefinement.__default.INode ($LS $LZ) (Lit (PivotBetree.QueryReceipt.root (Lit |receipt#0@@2|))))) (|Seq#Create| Tclass.PagedBetree.QueryReceiptLine $Heap@@1 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|)))) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#31| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|)))) (|lambda#32| TInt 0 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit |receipt#0@@2|))))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))))
 :qid |PivotBetreeRefinementbroken1idfy.156:12|
 :weight 3
 :skolemid |1754|
 :pattern ( (PivotBetreeRefinement.__default.IReceipt (Lit |receipt#0@@2|)) ($IsGoodHeap $Heap@@1))
))))
(assert  (and (forall ((arg0@@414 T@U) ) (! (= (type (PivotBetreeRefinement.__default.SplitChildKeys arg0@@414)) (MapType0Type BoxType boolType))
 :qid |funType:PivotBetreeRefinement.__default.SplitChildKeys|
 :pattern ( (PivotBetreeRefinement.__default.SplitChildKeys arg0@@414))
)) (forall ((arg0@@415 T@U) ) (! (= (type (PivotBetree.Step.path arg0@@415)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.path|
 :pattern ( (PivotBetree.Step.path arg0@@415))
))))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|step#0| T@U) ) (!  (=> (and (= (type |step#0|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| |step#0|) (and (not (= 32 $FunctionContextHeight)) (and ($Is |step#0| Tclass.PivotBetree.Step) (and (and (PivotBetree.Step.WF |step#0|) (PivotBetree.Step.InternalSplitStep_q |step#0|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0|))))))) ($Is (PivotBetreeRefinement.__default.SplitChildKeys |step#0|) (TISet Tclass.KeyType.Key)))
 :qid |PivotBetreeRefinementbroken1idfy.163:27|
 :skolemid |1774|
 :pattern ( (PivotBetreeRefinement.__default.SplitChildKeys |step#0|))
))))
(assert (forall ((|step#0@@0| T@U) ) (!  (=> (and (= (type |step#0@@0|) DatatypeTypeType) ($Is |step#0@@0| Tclass.PivotBetree.Step)) (= (|PivotBetreeRefinement.__default.SplitChildKeys#requires| |step#0@@0|)  (and (and (PivotBetree.Step.WF |step#0@@0|) (PivotBetree.Step.InternalSplitStep_q |step#0@@0|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@0|)))))
 :qid |PivotBetreeRefinementbroken1idfy.163:27|
 :skolemid |1775|
 :pattern ( (|PivotBetreeRefinement.__default.SplitChildKeys#requires| |step#0@@0|))
)))
(assert  (and (and (and (forall ((arg0@@416 T@U) ) (! (= (type (PivotBetree.Step.request arg0@@416)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.request|
 :pattern ( (PivotBetree.Step.request arg0@@416))
)) (forall ((arg0@@417 T@U) (arg1@@159 T@U) ) (! (= (type (PivotBetree.Path.Target arg0@@417 arg1@@159)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Target|
 :pattern ( (PivotBetree.Path.Target arg0@@417 arg1@@159))
))) (forall ((arg0@@418 T@U) (arg1@@160 Int) ) (! (= (type (PivotBetree.BetreeNode.DomainRoutedToChild arg0@@418 arg1@@160)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.DomainRoutedToChild|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild arg0@@418 arg1@@160))
))) (forall ((arg0@@419 T@U) ) (! (= (type (DomainMod.Domain.KeySet arg0@@419)) (MapType0Type BoxType boolType))
 :qid |funType:DomainMod.Domain.KeySet|
 :pattern ( (DomainMod.Domain.KeySet arg0@@419))
))))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|step#0@@1| T@U) ) (!  (=> (and (= (type |step#0@@1|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| |step#0@@1|) (and (not (= 32 $FunctionContextHeight)) (and ($Is |step#0@@1| Tclass.PivotBetree.Step) (and (and (PivotBetree.Step.WF |step#0@@1|) (PivotBetree.Step.InternalSplitStep_q |step#0@@1|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@1|))))))) (and (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@1|)) (or (SplitRequestMod.SplitRequest.SplitLeaf_q (PivotBetree.Step.request |step#0@@1|)) (SplitRequestMod.SplitRequest.SplitIndex_q (PivotBetree.Step.request |step#0@@1|)))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@1|)) (SplitRequestMod.SplitRequest.childIdx (PivotBetree.Step.request |step#0@@1|)))) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@1|)) (SplitRequestMod.SplitRequest.childIdx (PivotBetree.Step.request |step#0@@1|))))) (= (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@1|) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@1|)) (SplitRequestMod.SplitRequest.childIdx (PivotBetree.Step.request |step#0@@1|)))))))
 :qid |PivotBetreeRefinementbroken1idfy.163:27|
 :skolemid |1776|
 :pattern ( (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@1|))
))))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|step#0@@2| T@U) ) (!  (=> (and (= (type |step#0@@2|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| (Lit |step#0@@2|)) (and (not (= 32 $FunctionContextHeight)) (and ($Is |step#0@@2| Tclass.PivotBetree.Step) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@2|))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@2|)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@2|)))))))))))) (and (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@2|)))) (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit (PivotBetree.Step.request (Lit |step#0@@2|)))) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit (PivotBetree.Step.request (Lit |step#0@@2|)))))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@2|))))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit (PivotBetree.Step.request (Lit |step#0@@2|))))))) (|DomainMod.Domain.KeySet#canCall| (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@2|))))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit (PivotBetree.Step.request (Lit |step#0@@2|))))))))) (= (PivotBetreeRefinement.__default.SplitChildKeys (Lit |step#0@@2|)) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@2|))))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit (PivotBetree.Step.request (Lit |step#0@@2|))))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.163:27|
 :weight 3
 :skolemid |1777|
 :pattern ( (PivotBetreeRefinement.__default.SplitChildKeys (Lit |step#0@@2|)))
))))
(assert (= (type Tclass.DomainMod.Domain) TyType))
(assert (= (Tag Tclass.DomainMod.Domain) Tagclass.DomainMod.Domain))
(assert (= (TagFamily Tclass.DomainMod.Domain) tytagFamily$Domain))
(assert (forall ((bx@@129 T@U) ) (!  (=> (and (= (type bx@@129) BoxType) ($IsBox bx@@129 Tclass.DomainMod.Domain)) (and (= ($Box ($Unbox DatatypeTypeType bx@@129)) bx@@129) ($Is ($Unbox DatatypeTypeType bx@@129) Tclass.DomainMod.Domain)))
 :qid |unknown.0:0|
 :skolemid |1802|
 :pattern ( ($IsBox bx@@129 Tclass.DomainMod.Domain))
)))
(assert (forall ((arg0@@420 T@U) ) (! (= (type (PivotBetreeRefinement.__default.SplitLeftKeys arg0@@420)) (MapType0Type BoxType boolType))
 :qid |funType:PivotBetreeRefinement.__default.SplitLeftKeys|
 :pattern ( (PivotBetreeRefinement.__default.SplitLeftKeys arg0@@420))
)))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((|step#0@@3| T@U) ) (!  (=> (and (= (type |step#0@@3|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitLeftKeys#canCall| |step#0@@3|) (and (not (= 33 $FunctionContextHeight)) (and ($Is |step#0@@3| Tclass.PivotBetree.Step) (and (and (and (PivotBetree.Step.WF |step#0@@3|) (PivotBetree.Step.InternalSplitStep_q |step#0@@3|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@3|))) (PivotBetree.BetreeNode.CanSplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@3|)) (PivotBetree.Step.request |step#0@@3|))))))) ($Is (PivotBetreeRefinement.__default.SplitLeftKeys |step#0@@3|) (TISet Tclass.KeyType.Key)))
 :qid |PivotBetreeRefinementbroken1idfy.171:26|
 :skolemid |1804|
 :pattern ( (PivotBetreeRefinement.__default.SplitLeftKeys |step#0@@3|))
))))
(assert (forall ((|step#0@@4| T@U) ) (!  (=> (and (= (type |step#0@@4|) DatatypeTypeType) ($Is |step#0@@4| Tclass.PivotBetree.Step)) (= (|PivotBetreeRefinement.__default.SplitLeftKeys#requires| |step#0@@4|)  (and (and (and (PivotBetree.Step.WF |step#0@@4|) (PivotBetree.Step.InternalSplitStep_q |step#0@@4|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@4|))) (PivotBetree.BetreeNode.CanSplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@4|)) (PivotBetree.Step.request |step#0@@4|)))))
 :qid |PivotBetreeRefinementbroken1idfy.171:26|
 :skolemid |1805|
 :pattern ( (|PivotBetreeRefinement.__default.SplitLeftKeys#requires| |step#0@@4|))
)))
(assert  (and (and (forall ((arg0@@421 T@U) ) (! (= (type (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| arg0@@421)) DatatypeTypeType)
 :qid |funType:#Upperbounded_Lexicographic_Byte_Order.Element.Element|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| arg0@@421))
)) (forall ((arg0@@422 T@U) ) (! (= (type (PivotBetree.Step.SplitKey arg0@@422)) (SeqType BoxType))
 :qid |funType:PivotBetree.Step.SplitKey|
 :pattern ( (PivotBetree.Step.SplitKey arg0@@422))
))) (forall ((arg0@@423 T@U) (arg1@@161 T@U) (arg2@@84 T@U) ) (! (= (type (|lambda#56| arg0@@423 arg1@@161 arg2@@84)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#56|
 :pattern ( (|lambda#56| arg0@@423 arg1@@161 arg2@@84))
))))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((|step#0@@5| T@U) ) (!  (=> (and (= (type |step#0@@5|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitLeftKeys#canCall| |step#0@@5|) (and (not (= 33 $FunctionContextHeight)) (and ($Is |step#0@@5| Tclass.PivotBetree.Step) (and (and (and (PivotBetree.Step.WF |step#0@@5|) (PivotBetree.Step.InternalSplitStep_q |step#0@@5|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@5|))) (PivotBetree.BetreeNode.CanSplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Step.request |step#0@@5|))))))) (and (forall ((|key#0@@2| T@U) ) (!  (=> (and (= (type |key#0@@2|) (SeqType BoxType)) ($Is |key#0@@2| Tclass.KeyType.Key)) (and (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| |step#0@@5|) (=> (U_2_bool (MapType0Select (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@5|) ($Box |key#0@@2|))) (and (|PivotBetree.Step.SplitKey#canCall| |step#0@@5|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@2|) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (PivotBetree.Step.SplitKey |step#0@@5|)))))))
 :qid |PivotBetreeRefinementbroken1idfy.177:10|
 :skolemid |1806|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@2|))
 :pattern ( (MapType0Select (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@5|) ($Box |key#0@@2|)))
)) (= (PivotBetreeRefinement.__default.SplitLeftKeys |step#0@@5|) (|lambda#56| Tclass.KeyType.Key (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@5|) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (PivotBetree.Step.SplitKey |step#0@@5|))))))
 :qid |PivotBetreeRefinementbroken1idfy.171:26|
 :skolemid |1807|
 :pattern ( (PivotBetreeRefinement.__default.SplitLeftKeys |step#0@@5|))
))))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((|step#0@@6| T@U) ) (!  (=> (and (= (type |step#0@@6|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.SplitLeftKeys#canCall| (Lit |step#0@@6|)) (and (not (= 33 $FunctionContextHeight)) (and ($Is |step#0@@6| Tclass.PivotBetree.Step) (and (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@6|))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@6|)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanSplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@6|)))))))))))) (and (forall ((|key#1| T@U) ) (!  (=> (and (= (type |key#1|) (SeqType BoxType)) ($Is |key#1| Tclass.KeyType.Key)) (and (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| (Lit |step#0@@6|)) (=> (U_2_bool (MapType0Select (Lit (PivotBetreeRefinement.__default.SplitChildKeys (Lit |step#0@@6|))) ($Box |key#1|))) (and (|PivotBetree.Step.SplitKey#canCall| (Lit |step#0@@6|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#1|) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (PivotBetree.Step.SplitKey (Lit |step#0@@6|))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.177:10|
 :skolemid |1808|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#1|))
 :pattern ( (MapType0Select (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@6|) ($Box |key#1|)))
)) (= (PivotBetreeRefinement.__default.SplitLeftKeys (Lit |step#0@@6|)) (|lambda#56| Tclass.KeyType.Key (Lit (PivotBetreeRefinement.__default.SplitChildKeys (Lit |step#0@@6|))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (PivotBetree.Step.SplitKey (Lit |step#0@@6|)))))))))
 :qid |PivotBetreeRefinementbroken1idfy.171:26|
 :weight 3
 :skolemid |1809|
 :pattern ( (PivotBetreeRefinement.__default.SplitLeftKeys (Lit |step#0@@6|)))
))))
(assert (= (type Tclass.PagedBetree.Step) TyType))
(assert (= (Tag Tclass.PagedBetree.Step) Tagclass.PagedBetree.Step))
(assert (= (TagFamily Tclass.PagedBetree.Step) tytagFamily$Step))
(assert (forall ((bx@@130 T@U) ) (!  (=> (and (= (type bx@@130) BoxType) ($IsBox bx@@130 Tclass.PagedBetree.Step)) (and (= ($Box ($Unbox DatatypeTypeType bx@@130)) bx@@130) ($Is ($Unbox DatatypeTypeType bx@@130) Tclass.PagedBetree.Step)))
 :qid |unknown.0:0|
 :skolemid |1846|
 :pattern ( ($IsBox bx@@130 Tclass.PagedBetree.Step))
)))
(assert (forall ((arg0@@424 T@U) ) (! (= (type (PivotBetreeRefinement.__default.IStep arg0@@424)) DatatypeTypeType)
 :qid |funType:PivotBetreeRefinement.__default.IStep|
 :pattern ( (PivotBetreeRefinement.__default.IStep arg0@@424))
)))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((|step#0@@7| T@U) ) (!  (=> (and (= (type |step#0@@7|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStep#canCall| |step#0@@7|) (and (not (= 36 $FunctionContextHeight)) (and ($Is |step#0@@7| Tclass.PivotBetree.Step) (PivotBetree.Step.WF |step#0@@7|))))) (and (PagedBetree.Step.WF (PivotBetreeRefinement.__default.IStep |step#0@@7|)) ($Is (PivotBetreeRefinement.__default.IStep |step#0@@7|) Tclass.PagedBetree.Step)))
 :qid |PivotBetreeRefinementbroken1idfy.180:18|
 :skolemid |1847|
 :pattern ( (PivotBetreeRefinement.__default.IStep |step#0@@7|))
))))
(assert (forall ((|step#0@@8| T@U) ) (!  (=> (and (= (type |step#0@@8|) DatatypeTypeType) ($Is |step#0@@8| Tclass.PivotBetree.Step)) (= (|PivotBetreeRefinement.__default.IStep#requires| |step#0@@8|) (PivotBetree.Step.WF |step#0@@8|)))
 :qid |PivotBetreeRefinementbroken1idfy.180:18|
 :skolemid |1848|
 :pattern ( (|PivotBetreeRefinement.__default.IStep#requires| |step#0@@8|))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@425 T@U) ) (! (= (type (PivotBetree.Step.receipt arg0@@425)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.receipt|
 :pattern ( (PivotBetree.Step.receipt arg0@@425))
)) (forall ((arg0@@426 T@U) ) (! (= (type (|#PagedBetree.Step.QueryStep| arg0@@426)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Step.QueryStep|
 :pattern ( (|#PagedBetree.Step.QueryStep| arg0@@426))
))) (= (type |#PagedBetree.Step.PutStep|) DatatypeTypeType)) (= (type |#PagedBetree.Step.QueryEndLsnStep|) DatatypeTypeType)) (= (type |#PagedBetree.Step.FreezeAsStep|) DatatypeTypeType)) (= (type |#PagedBetree.Step.InternalGrowStep|) DatatypeTypeType)) (forall ((arg0@@427 T@U) (arg1@@162 T@U) (arg2@@85 T@U) ) (! (= (type (|#PagedBetree.Step.InternalSplitStep| arg0@@427 arg1@@162 arg2@@85)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Step.InternalSplitStep|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| arg0@@427 arg1@@162 arg2@@85))
))) (= (type |#PagedBetree.Step.InternalFlushMemtableStep|) DatatypeTypeType)) (forall ((arg0@@428 T@U) (arg1@@163 T@U) ) (! (= (type (|#PagedBetree.Step.InternalFlushStep| arg0@@428 arg1@@163)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Step.InternalFlushStep|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| arg0@@428 arg1@@163))
))) (forall ((arg0@@429 T@U) ) (! (= (type (PivotBetree.Step.compactedBuffers arg0@@429)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.compactedBuffers|
 :pattern ( (PivotBetree.Step.compactedBuffers arg0@@429))
))) (forall ((arg0@@430 T@U) (arg1@@164 T@U) ) (! (= (type (|#PagedBetree.Step.InternalCompactStep| arg0@@430 arg1@@164)) DatatypeTypeType)
 :qid |funType:#PagedBetree.Step.InternalCompactStep|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| arg0@@430 arg1@@164))
))) (= (type |#PagedBetree.Step.InternalNoOpStep|) DatatypeTypeType)))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((|step#0@@9| T@U) ) (!  (=> (and (= (type |step#0@@9|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStep#canCall| |step#0@@9|) (and (not (= 36 $FunctionContextHeight)) (and ($Is |step#0@@9| Tclass.PivotBetree.Step) (PivotBetree.Step.WF |step#0@@9|))))) (and (and (=> (PivotBetree.Step.QueryStep_q |step#0@@9|) (let ((|receipt#1| (PivotBetree.Step.receipt |step#0@@9|)))
(|PivotBetreeRefinement.__default.IReceipt#canCall| |receipt#1|))) (=> (not (PivotBetree.Step.QueryStep_q |step#0@@9|)) (=> (not (PivotBetree.Step.PutStep_q |step#0@@9|)) (=> (not (PivotBetree.Step.QueryEndLsnStep_q |step#0@@9|)) (=> (not (PivotBetree.Step.FreezeAsStep_q |step#0@@9|)) (=> (not (PivotBetree.Step.InternalGrowStep_q |step#0@@9|)) (and (=> (PivotBetree.Step.InternalSplitStep_q |step#0@@9|) (let ((|path#3| (PivotBetree.Step.path |step#0@@9|)))
 (and (|PivotBetreeRefinement.__default.SplitLeftKeys#canCall| |step#0@@9|) (and (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| |step#0@@9|) (|PivotBetreeRefinement.__default.IPath#canCall| |path#3|))))) (=> (not (PivotBetree.Step.InternalSplitStep_q |step#0@@9|)) (=> (not (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@9|)) (and (=> (PivotBetree.Step.InternalFlushStep_q |step#0@@9|) (let ((|childIdx#1| (PivotBetree.Step.childIdx |step#0@@9|)))
(let ((|path#4| (PivotBetree.Step.path |step#0@@9|)))
 (and (|PivotBetreeRefinement.__default.IPath#canCall| |path#4|) (and (and (|PivotBetree.Path.Target#canCall| |path#4|) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#4|) |childIdx#1|)) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS $LZ) |path#4|) |childIdx#1|))))))) (=> (not (PivotBetree.Step.InternalFlushStep_q |step#0@@9|)) (=> (PivotBetree.Step.InternalCompactStep_q |step#0@@9|) (let ((|path#5| (PivotBetree.Step.path |step#0@@9|)))
(|PivotBetreeRefinement.__default.IPath#canCall| |path#5|)))))))))))))) (= (PivotBetreeRefinement.__default.IStep |step#0@@9|) (ite (PivotBetree.Step.QueryStep_q |step#0@@9|) (let ((|receipt#0@@3| (PivotBetree.Step.receipt |step#0@@9|)))
(|#PagedBetree.Step.QueryStep| (PivotBetreeRefinement.__default.IReceipt |receipt#0@@3|))) (ite (PivotBetree.Step.PutStep_q |step#0@@9|) |#PagedBetree.Step.PutStep| (ite (PivotBetree.Step.QueryEndLsnStep_q |step#0@@9|) |#PagedBetree.Step.QueryEndLsnStep| (ite (PivotBetree.Step.FreezeAsStep_q |step#0@@9|) |#PagedBetree.Step.FreezeAsStep| (ite (PivotBetree.Step.InternalGrowStep_q |step#0@@9|) |#PagedBetree.Step.InternalGrowStep| (ite (PivotBetree.Step.InternalSplitStep_q |step#0@@9|) (let ((|path#0@@9| (PivotBetree.Step.path |step#0@@9|)))
(let ((|leftKeys#0| (PivotBetreeRefinement.__default.SplitLeftKeys |step#0@@9|)))
(let ((|rightKeys#0| (|ISet#Difference| (PivotBetreeRefinement.__default.SplitChildKeys |step#0@@9|) |leftKeys#0|)))
(|#PagedBetree.Step.InternalSplitStep| (PivotBetreeRefinement.__default.IPath |path#0@@9|) |leftKeys#0| |rightKeys#0|)))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@9|) |#PagedBetree.Step.InternalFlushMemtableStep| (ite (PivotBetree.Step.InternalFlushStep_q |step#0@@9|) (let ((|childIdx#0| (PivotBetree.Step.childIdx |step#0@@9|)))
(let ((|path#1| (PivotBetree.Step.path |step#0@@9|)))
(|#PagedBetree.Step.InternalFlushStep| (PivotBetreeRefinement.__default.IPath |path#1|) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS $LZ) |path#1|) |childIdx#0|))))) (ite (PivotBetree.Step.InternalCompactStep_q |step#0@@9|) (let ((|compactedBuffers#0| (PivotBetree.Step.compactedBuffers |step#0@@9|)))
(let ((|path#2| (PivotBetree.Step.path |step#0@@9|)))
(let ((|out#0| (|#PagedBetree.Step.InternalCompactStep| (PivotBetreeRefinement.__default.IPath |path#2|) |compactedBuffers#0|)))
|out#0|))) |#PagedBetree.Step.InternalNoOpStep|))))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.180:18|
 :skolemid |1849|
 :pattern ( (PivotBetreeRefinement.__default.IStep |step#0@@9|))
))))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((|step#0@@10| T@U) ) (!  (=> (and (= (type |step#0@@10|) DatatypeTypeType) (or (|PivotBetreeRefinement.__default.IStep#canCall| (Lit |step#0@@10|)) (and (not (= 36 $FunctionContextHeight)) (and ($Is |step#0@@10| Tclass.PivotBetree.Step) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@10|))))))))) (and (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@10|))))) (let ((|receipt#3| (Lit (PivotBetree.Step.receipt (Lit |step#0@@10|)))))
(|PivotBetreeRefinement.__default.IReceipt#canCall| |receipt#3|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@10|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit |step#0@@10|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@10|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@10|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@10|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@10|))))) (let ((|path#9| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
 (and (|PivotBetreeRefinement.__default.SplitLeftKeys#canCall| (Lit |step#0@@10|)) (and (|PivotBetreeRefinement.__default.SplitChildKeys#canCall| (Lit |step#0@@10|)) (|PivotBetreeRefinement.__default.IPath#canCall| |path#9|))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@10|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@10|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@10|))))) (let ((|childIdx#3| (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|)))))
(let ((|path#10| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
 (and (|PivotBetreeRefinement.__default.IPath#canCall| |path#10|) (and (and (|PivotBetree.Path.Target#canCall| |path#10|) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#10|) |childIdx#3|)) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS $LZ) |path#10|) |childIdx#3|))))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@10|)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@10|))))) (let ((|path#11| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
(|PivotBetreeRefinement.__default.IPath#canCall| |path#11|)))))))))))))) (= (PivotBetreeRefinement.__default.IStep (Lit |step#0@@10|)) (ite (PivotBetree.Step.QueryStep_q (Lit |step#0@@10|)) (let ((|receipt#2| (Lit (PivotBetree.Step.receipt (Lit |step#0@@10|)))))
(Lit (|#PagedBetree.Step.QueryStep| (Lit (PivotBetreeRefinement.__default.IReceipt |receipt#2|))))) (ite (PivotBetree.Step.PutStep_q (Lit |step#0@@10|)) |#PagedBetree.Step.PutStep| (ite (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@10|)) |#PagedBetree.Step.QueryEndLsnStep| (ite (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@10|)) |#PagedBetree.Step.FreezeAsStep| (ite (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@10|)) |#PagedBetree.Step.InternalGrowStep| (ite (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@10|)) (let ((|path#6| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
(let ((|leftKeys#2| (Lit (PivotBetreeRefinement.__default.SplitLeftKeys (Lit |step#0@@10|)))))
(let ((|rightKeys#2| (|ISet#Difference| (PivotBetreeRefinement.__default.SplitChildKeys (Lit |step#0@@10|)) |leftKeys#2|)))
(|#PagedBetree.Step.InternalSplitStep| (Lit (PivotBetreeRefinement.__default.IPath |path#6|)) |leftKeys#2| |rightKeys#2|)))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@10|)) |#PagedBetree.Step.InternalFlushMemtableStep| (ite (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@10|)) (let ((|childIdx#2| (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|)))))
(let ((|path#7| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
(Lit (|#PagedBetree.Step.InternalFlushStep| (Lit (PivotBetreeRefinement.__default.IPath |path#7|)) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit (PivotBetree.Path.Target ($LS $LZ) |path#7|)) |childIdx#2|)))))))) (ite (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@10|)) (let ((|compactedBuffers#2| (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@10|)))))
(let ((|path#8| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))
(let ((|out#2| (Lit (|#PagedBetree.Step.InternalCompactStep| (Lit (PivotBetreeRefinement.__default.IPath |path#8|)) |compactedBuffers#2|))))
|out#2|))) |#PagedBetree.Step.InternalNoOpStep|))))))))))))
 :qid |PivotBetreeRefinementbroken1idfy.180:18|
 :weight 3
 :skolemid |1850|
 :pattern ( (PivotBetreeRefinement.__default.IStep (Lit |step#0@@10|)))
))))
(assert  (and (forall ((arg0@@431 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitLeaf#Handle| arg0@@431)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitLeaf#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitLeaf#Handle| arg0@@431))
)) (forall ((arg0@@432 T@U) (arg1@@165 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitLeaf arg0@@432 arg1@@165)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitLeaf|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf arg0@@432 arg1@@165))
))))
(assert (forall (($self@@3 T@U) ($heap@@3 T@U) (|$fh$0x#0@@3| T@U) ) (!  (=> (and (and (= (type $self@@3) DatatypeTypeType) (= (type $heap@@3) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@3|) BoxType)) (= (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@3 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@3) |$fh$0x#0@@3|) ($Box (PivotBetree.BetreeNode.SplitLeaf $self@@3 ($Unbox (SeqType BoxType) |$fh$0x#0@@3|)))))
 :qid |unknown.0:0|
 :skolemid |1928|
 :pattern ( (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@3 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@3) |$fh$0x#0@@3|))
)))
(assert (forall (($self@@4 T@U) ($heap@@4 T@U) (|$fh$0x#0@@4| T@U) ) (!  (=> (and (and (= (type $self@@4) DatatypeTypeType) (= (type $heap@@4) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@4|) BoxType)) (= (Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@4 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@4) |$fh$0x#0@@4|) (|PivotBetree.BetreeNode.SplitLeaf#requires| $self@@4 ($Unbox (SeqType BoxType) |$fh$0x#0@@4|))))
 :qid |unknown.0:0|
 :skolemid |1929|
 :pattern ( (Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@4 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@4) |$fh$0x#0@@4|))
)))
(assert (forall (($bx@@0 T@U) ($self@@5 T@U) ($heap@@5 T@U) (|$fh$0x#0@@5| T@U) ) (!  (=> (and (and (and (= (type $bx@@0) BoxType) (= (type $self@@5) DatatypeTypeType)) (= (type $heap@@5) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@5 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@5) |$fh$0x#0@@5|) $bx@@0)) false))
 :qid |unknown.0:0|
 :skolemid |1930|
 :pattern ( (MapType0Select (Reads1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@5 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@5) |$fh$0x#0@@5|) $bx@@0))
)))
(assert (forall (($self@@6 T@U) ($heap@@6 T@U) (|$fh$0x#0@@6| T@U) ) (!  (=> (and (and (= (type $self@@6) DatatypeTypeType) (= (type $heap@@6) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@6|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.SplitLeaf $self@@6 |$fh$0x#0@@6|) ($Unbox DatatypeTypeType (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@6 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@6) ($Box |$fh$0x#0@@6|)))))
 :qid |unknown.0:0|
 :skolemid |1931|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf $self@@6 |$fh$0x#0@@6|) ($IsGoodHeap $heap@@6))
)))
(assert  (and (forall ((arg0@@433 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitIndex#Handle| arg0@@433)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitIndex#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitIndex#Handle| arg0@@433))
)) (forall ((arg0@@434 T@U) (arg1@@166 Int) ) (! (= (type (PivotBetree.BetreeNode.SplitIndex arg0@@434 arg1@@166)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitIndex|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex arg0@@434 arg1@@166))
))))
(assert (forall (($self@@7 T@U) ($heap@@7 T@U) (|$fh$0x#0@@7| T@U) ) (!  (=> (and (and (= (type $self@@7) DatatypeTypeType) (= (type $heap@@7) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@7|) BoxType)) (= (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@7 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@7) |$fh$0x#0@@7|) ($Box (PivotBetree.BetreeNode.SplitIndex $self@@7 (U_2_int ($Unbox intType |$fh$0x#0@@7|))))))
 :qid |unknown.0:0|
 :skolemid |1932|
 :pattern ( (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@7 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@7) |$fh$0x#0@@7|))
)))
(assert (forall (($self@@8 T@U) ($heap@@8 T@U) (|$fh$0x#0@@8| T@U) ) (!  (=> (and (and (= (type $self@@8) DatatypeTypeType) (= (type $heap@@8) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@8|) BoxType)) (= (Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@8 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@8) |$fh$0x#0@@8|) (|PivotBetree.BetreeNode.SplitIndex#requires| $self@@8 (U_2_int ($Unbox intType |$fh$0x#0@@8|)))))
 :qid |unknown.0:0|
 :skolemid |1933|
 :pattern ( (Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@8 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@8) |$fh$0x#0@@8|))
)))
(assert (forall (($bx@@1 T@U) ($self@@9 T@U) ($heap@@9 T@U) (|$fh$0x#0@@9| T@U) ) (!  (=> (and (and (and (= (type $bx@@1) BoxType) (= (type $self@@9) DatatypeTypeType)) (= (type $heap@@9) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@9|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@9 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@9) |$fh$0x#0@@9|) $bx@@1)) false))
 :qid |unknown.0:0|
 :skolemid |1934|
 :pattern ( (MapType0Select (Reads1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@9 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@9) |$fh$0x#0@@9|) $bx@@1))
)))
(assert (forall (($self@@10 T@U) ($heap@@10 T@U) (|$fh$0x#0@@10| Int) ) (!  (=> (and (= (type $self@@10) DatatypeTypeType) (= (type $heap@@10) (MapType0Type refType MapType1Type))) (= (PivotBetree.BetreeNode.SplitIndex $self@@10 |$fh$0x#0@@10|) ($Unbox DatatypeTypeType (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@10 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@10) ($Box (int_2_U |$fh$0x#0@@10|))))))
 :qid |unknown.0:0|
 :skolemid |1935|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex $self@@10 |$fh$0x#0@@10|) ($IsGoodHeap $heap@@10))
)))
(assert  (=> (<= 56 $FunctionContextHeight) (forall ((|node#0@@11| T@U) (|other#0| T@U) ) (!  (=> (and (and (= (type |node#0@@11|) DatatypeTypeType) (= (type |other#0|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.EquivalentBufferCompaction#canCall| |node#0@@11| |other#0|) (and (not (= 56 $FunctionContextHeight)) (and ($Is |node#0@@11| Tclass.PivotBetree.BetreeNode) ($Is |other#0| Tclass.PivotBetree.BetreeNode))))) true)
 :qid |PivotBetreeRefinementbroken1idfy.538:40|
 :skolemid |4061|
 :pattern ( (PivotBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@11| |other#0|))
))))
(assert (forall ((|node#0@@12| T@U) (|other#0@@0| T@U) ) (!  (=> (and (and (= (type |node#0@@12|) DatatypeTypeType) (= (type |other#0@@0|) DatatypeTypeType)) (and ($Is |node#0@@12| Tclass.PivotBetree.BetreeNode) ($Is |other#0@@0| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetreeRefinement.__default.EquivalentBufferCompaction#requires| |node#0@@12| |other#0@@0|) true))
 :qid |PivotBetreeRefinementbroken1idfy.538:40|
 :skolemid |4062|
 :pattern ( (|PivotBetreeRefinement.__default.EquivalentBufferCompaction#requires| |node#0@@12| |other#0@@0|))
)))
(assert (forall ((arg0@@435 T@U) ) (! (= (type (PivotBetree.BetreeNode.children arg0@@435)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.children|
 :pattern ( (PivotBetree.BetreeNode.children arg0@@435))
)))
(assert  (=> (<= 56 $FunctionContextHeight) (forall ((|node#0@@13| T@U) (|other#0@@1| T@U) ) (!  (=> (and (and (= (type |node#0@@13|) DatatypeTypeType) (= (type |other#0@@1|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.EquivalentBufferCompaction#canCall| |node#0@@13| |other#0@@1|) (and (not (= 56 $FunctionContextHeight)) (and ($Is |node#0@@13| Tclass.PivotBetree.BetreeNode) ($Is |other#0@@1| Tclass.PivotBetree.BetreeNode))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| |node#0@@13|) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@13|) (and (|PivotBetree.BetreeNode.WF#canCall| |other#0@@1|) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) |other#0@@1|) (=> (PivotBetree.BetreeNode.BetreeNode_q |node#0@@13|) (=> (PivotBetree.BetreeNode.BetreeNode_q |other#0@@1|) (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers |node#0@@13|) (PivotBetree.BetreeNode.buffers |other#0@@1|)))))))) (= (PivotBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@13| |other#0@@1|)  (and (and (and (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) |node#0@@13|) (PivotBetree.BetreeNode.WF ($LS $LZ) |other#0@@1|)) (PivotBetree.BetreeNode.BetreeNode_q |node#0@@13|)) (PivotBetree.BetreeNode.BetreeNode_q |other#0@@1|)) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |node#0@@13|) (PivotBetree.BetreeNode.buffers |other#0@@1|))) (|Seq#Equal| (PivotBetree.BetreeNode.pivotTable |node#0@@13|) (PivotBetree.BetreeNode.pivotTable |other#0@@1|))) (|Seq#Equal| (PivotBetree.BetreeNode.children |node#0@@13|) (PivotBetree.BetreeNode.children |other#0@@1|))))))
 :qid |PivotBetreeRefinementbroken1idfy.538:40|
 :skolemid |4063|
 :pattern ( (PivotBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@13| |other#0@@1|))
))))
(assert  (=> (<= 56 $FunctionContextHeight) (forall ((|node#0@@14| T@U) (|other#0@@2| T@U) ) (!  (=> (and (and (= (type |node#0@@14|) DatatypeTypeType) (= (type |other#0@@2|) DatatypeTypeType)) (or (|PivotBetreeRefinement.__default.EquivalentBufferCompaction#canCall| (Lit |node#0@@14|) (Lit |other#0@@2|)) (and (not (= 56 $FunctionContextHeight)) (and ($Is |node#0@@14| Tclass.PivotBetree.BetreeNode) ($Is |other#0@@2| Tclass.PivotBetree.BetreeNode))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit |node#0@@14|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@14|))))) (and (|PivotBetree.BetreeNode.WF#canCall| (Lit |other#0@@2|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |other#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |node#0@@14|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |other#0@@2|))))) (|Buffers.BufferStack.Equivalent#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit |node#0@@14|))) (Lit (PivotBetree.BetreeNode.buffers (Lit |other#0@@2|)))))))))) (= (PivotBetreeRefinement.__default.EquivalentBufferCompaction (Lit |node#0@@14|) (Lit |other#0@@2|))  (and (and (and (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@14|)) (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |other#0@@2|))) (PivotBetree.BetreeNode.BetreeNode_q (Lit |node#0@@14|))) (PivotBetree.BetreeNode.BetreeNode_q (Lit |other#0@@2|))) (Buffers.BufferStack.Equivalent (Lit (PivotBetree.BetreeNode.buffers (Lit |node#0@@14|))) (Lit (PivotBetree.BetreeNode.buffers (Lit |other#0@@2|))))) (|Seq#Equal| (PivotBetree.BetreeNode.pivotTable (Lit |node#0@@14|)) (PivotBetree.BetreeNode.pivotTable (Lit |other#0@@2|)))) (|Seq#Equal| (PivotBetree.BetreeNode.children (Lit |node#0@@14|)) (PivotBetree.BetreeNode.children (Lit |other#0@@2|)))))))
 :qid |PivotBetreeRefinementbroken1idfy.538:40|
 :weight 3
 :skolemid |4064|
 :pattern ( (PivotBetreeRefinement.__default.EquivalentBufferCompaction (Lit |node#0@@14|) (Lit |other#0@@2|)))
))))
(assert (= (type Tclass.MemtableMod.Memtable) TyType))
(assert (= (Tag Tclass.MemtableMod.Memtable) Tagclass.MemtableMod.Memtable))
(assert (= (TagFamily Tclass.MemtableMod.Memtable) tytagFamily$Memtable))
(assert (forall ((bx@@131 T@U) ) (!  (=> (and (= (type bx@@131) BoxType) ($IsBox bx@@131 Tclass.MemtableMod.Memtable)) (and (= ($Box ($Unbox DatatypeTypeType bx@@131)) bx@@131) ($Is ($Unbox DatatypeTypeType bx@@131) Tclass.MemtableMod.Memtable)))
 :qid |unknown.0:0|
 :skolemid |4214|
 :pattern ( ($IsBox bx@@131 Tclass.MemtableMod.Memtable))
)))
(assert (= (type |#Options.Option.None|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#Options.Option.None|) |##Options.Option.None|))
(assert (forall ((d@@16 T@U) ) (!  (=> (= (type d@@16) DatatypeTypeType) (= (Options.Option.None_q d@@16) (= (DatatypeCtorId d@@16) |##Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |4427|
 :pattern ( (Options.Option.None_q d@@16))
)))
(assert (forall ((d@@17 T@U) ) (!  (=> (and (= (type d@@17) DatatypeTypeType) (Options.Option.None_q d@@17)) (= d@@17 |#Options.Option.None|))
 :qid |unknown.0:0|
 :skolemid |4428|
 :pattern ( (Options.Option.None_q d@@17))
)))
(assert (forall ((arg0@@436 T@U) ) (! (= (type (Tclass.Options.Option arg0@@436)) TyType)
 :qid |funType:Tclass.Options.Option|
 :pattern ( (Tclass.Options.Option arg0@@436))
)))
(assert (forall ((Options.Option$V T@U) ) (!  (=> (= (type Options.Option$V) TyType) (and (= (Tag (Tclass.Options.Option Options.Option$V)) Tagclass.Options.Option) (= (TagFamily (Tclass.Options.Option Options.Option$V)) tytagFamily$Option)))
 :qid |unknown.0:0|
 :skolemid |4429|
 :pattern ( (Tclass.Options.Option Options.Option$V))
)))
(assert (forall ((arg0@@437 T@U) ) (! (= (type (Tclass.Options.Option_0 arg0@@437)) TyType)
 :qid |funType:Tclass.Options.Option_0|
 :pattern ( (Tclass.Options.Option_0 arg0@@437))
)))
(assert (forall ((Options.Option$V@@0 T@U) ) (!  (=> (= (type Options.Option$V@@0) TyType) (= (Tclass.Options.Option_0 (Tclass.Options.Option Options.Option$V@@0)) Options.Option$V@@0))
 :qid |unknown.0:0|
 :skolemid |4430|
 :pattern ( (Tclass.Options.Option Options.Option$V@@0))
)))
(assert (forall ((Options.Option$V@@1 T@U) (bx@@132 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@1) TyType) (= (type bx@@132) BoxType)) ($IsBox bx@@132 (Tclass.Options.Option Options.Option$V@@1))) (and (= ($Box ($Unbox DatatypeTypeType bx@@132)) bx@@132) ($Is ($Unbox DatatypeTypeType bx@@132) (Tclass.Options.Option Options.Option$V@@1))))
 :qid |unknown.0:0|
 :skolemid |4431|
 :pattern ( ($IsBox bx@@132 (Tclass.Options.Option Options.Option$V@@1)))
)))
(assert (forall ((Options.Option$V@@2 T@U) ) (!  (=> (= (type Options.Option$V@@2) TyType) ($Is |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@2)))
 :qid |unknown.0:0|
 :skolemid |4432|
 :pattern ( ($Is |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@2)))
)))
(assert (forall ((Options.Option$V@@3 T@U) ($h@@50 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@3) TyType) (= (type $h@@50) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@50)) ($IsAlloc |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@3) $h@@50))
 :qid |unknown.0:0|
 :skolemid |4433|
 :pattern ( ($IsAlloc |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@3) $h@@50))
)))
(assert (= |#Options.Option.None| (Lit |#Options.Option.None|)))
(assert (forall ((arg0@@438 T@U) ) (! (= (type (|#Options.Option.Some| arg0@@438)) DatatypeTypeType)
 :qid |funType:#Options.Option.Some|
 :pattern ( (|#Options.Option.Some| arg0@@438))
)))
(assert (forall ((|a#5#0#0@@0| T@U) ) (!  (=> (= (type |a#5#0#0@@0|) BoxType) (= (DatatypeCtorId (|#Options.Option.Some| |a#5#0#0@@0|)) |##Options.Option.Some|))
 :qid |Optionsdfy.5:36|
 :skolemid |4434|
 :pattern ( (|#Options.Option.Some| |a#5#0#0@@0|))
)))
(assert (forall ((d@@18 T@U) ) (!  (=> (= (type d@@18) DatatypeTypeType) (= (Options.Option.Some_q d@@18) (= (DatatypeCtorId d@@18) |##Options.Option.Some|)))
 :qid |unknown.0:0|
 :skolemid |4435|
 :pattern ( (Options.Option.Some_q d@@18))
)))
(assert (forall ((d@@19 T@U) ) (!  (=> (and (= (type d@@19) DatatypeTypeType) (Options.Option.Some_q d@@19)) (exists ((|a#6#0#0@@0| T@U) ) (!  (and (= (type |a#6#0#0@@0|) BoxType) (= d@@19 (|#Options.Option.Some| |a#6#0#0@@0|)))
 :qid |Optionsdfy.5:36|
 :skolemid |4436|
 :no-pattern (type |a#6#0#0@@0|)
 :no-pattern (U_2_int |a#6#0#0@@0|)
 :no-pattern (U_2_bool |a#6#0#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |4437|
 :pattern ( (Options.Option.Some_q d@@19))
)))
(assert (forall ((Options.Option$V@@4 T@U) (|a#7#0#0@@0| T@U) ) (!  (=> (and (= (type Options.Option$V@@4) TyType) (= (type |a#7#0#0@@0|) BoxType)) (= ($Is (|#Options.Option.Some| |a#7#0#0@@0|) (Tclass.Options.Option Options.Option$V@@4)) ($IsBox |a#7#0#0@@0| Options.Option$V@@4)))
 :qid |unknown.0:0|
 :skolemid |4438|
 :pattern ( ($Is (|#Options.Option.Some| |a#7#0#0@@0|) (Tclass.Options.Option Options.Option$V@@4)))
)))
(assert (forall ((Options.Option$V@@5 T@U) (|a#8#0#0@@0| T@U) ($h@@51 T@U) ) (!  (=> (and (and (and (= (type Options.Option$V@@5) TyType) (= (type |a#8#0#0@@0|) BoxType)) (= (type $h@@51) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@51)) (= ($IsAlloc (|#Options.Option.Some| |a#8#0#0@@0|) (Tclass.Options.Option Options.Option$V@@5) $h@@51) ($IsAllocBox |a#8#0#0@@0| Options.Option$V@@5 $h@@51)))
 :qid |unknown.0:0|
 :skolemid |4439|
 :pattern ( ($IsAlloc (|#Options.Option.Some| |a#8#0#0@@0|) (Tclass.Options.Option Options.Option$V@@5) $h@@51))
)))
(assert (forall ((arg0@@439 T@U) ) (! (= (type (Options.Option.value arg0@@439)) BoxType)
 :qid |funType:Options.Option.value|
 :pattern ( (Options.Option.value arg0@@439))
)))
(assert (forall ((d@@20 T@U) (Options.Option$V@@6 T@U) ($h@@52 T@U) ) (!  (=> (and (and (and (= (type d@@20) DatatypeTypeType) (= (type Options.Option$V@@6) TyType)) (= (type $h@@52) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@52) (and (Options.Option.Some_q d@@20) ($IsAlloc d@@20 (Tclass.Options.Option Options.Option$V@@6) $h@@52)))) ($IsAllocBox (Options.Option.value d@@20) Options.Option$V@@6 $h@@52))
 :qid |unknown.0:0|
 :skolemid |4440|
 :pattern ( ($IsAllocBox (Options.Option.value d@@20) Options.Option$V@@6 $h@@52))
)))
(assert (forall ((|a#9#0#0| T@U) ) (!  (=> (= (type |a#9#0#0|) BoxType) (= (|#Options.Option.Some| (Lit |a#9#0#0|)) (Lit (|#Options.Option.Some| |a#9#0#0|))))
 :qid |Optionsdfy.5:36|
 :skolemid |4441|
 :pattern ( (|#Options.Option.Some| (Lit |a#9#0#0|)))
)))
(assert (forall ((|a#10#0#0| T@U) ) (!  (=> (= (type |a#10#0#0|) BoxType) (= (Options.Option.value (|#Options.Option.Some| |a#10#0#0|)) |a#10#0#0|))
 :qid |Optionsdfy.5:36|
 :skolemid |4442|
 :pattern ( (|#Options.Option.Some| |a#10#0#0|))
)))
(assert (forall ((|a#11#0#0| T@U) ) (!  (=> (= (type |a#11#0#0|) BoxType) (< (BoxRank |a#11#0#0|) (DtRank (|#Options.Option.Some| |a#11#0#0|))))
 :qid |Optionsdfy.5:36|
 :skolemid |4443|
 :pattern ( (|#Options.Option.Some| |a#11#0#0|))
)))
(assert (forall ((d@@21 T@U) ) (!  (=> (and (= (type d@@21) DatatypeTypeType) (|$IsA#Options.Option| d@@21)) (or (Options.Option.None_q d@@21) (Options.Option.Some_q d@@21)))
 :qid |unknown.0:0|
 :skolemid |4444|
 :pattern ( (|$IsA#Options.Option| d@@21))
)))
(assert (forall ((Options.Option$V@@7 T@U) (d@@22 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@7) TyType) (= (type d@@22) DatatypeTypeType)) ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7))) (or (Options.Option.None_q d@@22) (Options.Option.Some_q d@@22)))
 :qid |unknown.0:0|
 :skolemid |4445|
 :pattern ( (Options.Option.Some_q d@@22) ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7)))
 :pattern ( (Options.Option.None_q d@@22) ($Is d@@22 (Tclass.Options.Option Options.Option$V@@7)))
)))
(assert (forall ((a@@118 T@U) (b@@67 T@U) ) (!  (=> (and (and (= (type a@@118) DatatypeTypeType) (= (type b@@67) DatatypeTypeType)) (and (Options.Option.None_q a@@118) (Options.Option.None_q b@@67))) (= (|Options.Option#Equal| a@@118 b@@67) true))
 :qid |unknown.0:0|
 :skolemid |4446|
 :pattern ( (|Options.Option#Equal| a@@118 b@@67) (Options.Option.None_q a@@118))
 :pattern ( (|Options.Option#Equal| a@@118 b@@67) (Options.Option.None_q b@@67))
)))
(assert (forall ((a@@119 T@U) (b@@68 T@U) ) (!  (=> (and (and (= (type a@@119) DatatypeTypeType) (= (type b@@68) DatatypeTypeType)) (and (Options.Option.Some_q a@@119) (Options.Option.Some_q b@@68))) (= (|Options.Option#Equal| a@@119 b@@68) (= (Options.Option.value a@@119) (Options.Option.value b@@68))))
 :qid |unknown.0:0|
 :skolemid |4447|
 :pattern ( (|Options.Option#Equal| a@@119 b@@68) (Options.Option.Some_q a@@119))
 :pattern ( (|Options.Option#Equal| a@@119 b@@68) (Options.Option.Some_q b@@68))
)))
(assert (forall ((a@@120 T@U) (b@@69 T@U) ) (!  (=> (and (= (type a@@120) DatatypeTypeType) (= (type b@@69) DatatypeTypeType)) (= (|Options.Option#Equal| a@@120 b@@69) (= a@@120 b@@69)))
 :qid |unknown.0:0|
 :skolemid |4448|
 :pattern ( (|Options.Option#Equal| a@@120 b@@69))
)))
(assert (= (type Tclass.Options.__default) TyType))
(assert (= (Tag Tclass.Options.__default) Tagclass.Options.__default))
(assert (= (TagFamily Tclass.Options.__default) tytagFamily$_default))
(assert (forall ((bx@@133 T@U) ) (!  (=> (and (= (type bx@@133) BoxType) ($IsBox bx@@133 Tclass.Options.__default)) (and (= ($Box ($Unbox refType bx@@133)) bx@@133) ($Is ($Unbox refType bx@@133) Tclass.Options.__default)))
 :qid |unknown.0:0|
 :skolemid |4449|
 :pattern ( ($IsBox bx@@133 Tclass.Options.__default))
)))
(assert (forall (($o@@11 T@U) ) (!  (=> (= (type $o@@11) refType) (= ($Is $o@@11 Tclass.Options.__default)  (or (= $o@@11 null) (= (dtype $o@@11) Tclass.Options.__default))))
 :qid |unknown.0:0|
 :skolemid |4450|
 :pattern ( ($Is $o@@11 Tclass.Options.__default))
)))
(assert (forall (($o@@12 T@U) ($h@@53 T@U) ) (!  (=> (and (= (type $o@@12) refType) (= (type $h@@53) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@12 Tclass.Options.__default $h@@53)  (or (= $o@@12 null) (U_2_bool (MapType1Select (MapType0Select $h@@53 $o@@12) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4451|
 :pattern ( ($IsAlloc $o@@12 Tclass.Options.__default $h@@53))
)))
(assert (forall ((arg0@@440 T@U) (arg1@@167 T@U) (arg2@@86 T@U) (arg3@@46 T@U) (arg4@@28 T@U) ) (! (= (type (Options.__default.MapOption arg0@@440 arg1@@167 arg2@@86 arg3@@46 arg4@@28)) DatatypeTypeType)
 :qid |funType:Options.__default.MapOption|
 :pattern ( (Options.__default.MapOption arg0@@440 arg1@@167 arg2@@86 arg3@@46 arg4@@28))
)))
(assert (forall ((Options._default.MapOption$V0 T@U) (Options._default.MapOption$V1 T@U) ($h0 T@U) ($h1 T@U) (|opt#0| T@U) (|f#0@@67| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Options._default.MapOption$V0) TyType) (= (type Options._default.MapOption$V1) TyType)) (= (type $h0) (MapType0Type refType MapType1Type))) (= (type $h1) (MapType0Type refType MapType1Type))) (= (type |opt#0|) DatatypeTypeType)) (= (type |f#0@@67|) HandleTypeType)) (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |opt#0| |f#0@@67|) (and ($Is |opt#0| (Tclass.Options.Option Options._default.MapOption$V0)) ($Is |f#0@@67| (Tclass._System.___hFunc1 Options._default.MapOption$V0 Options._default.MapOption$V1))))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1)))) (forall (($o@@13 T@U) ($f T@U) ) (! (let ((alpha@@6 (FieldTypeInv0 (type $f))))
 (=> (and (and (= (type $o@@13) refType) (= (type $f) (FieldType alpha@@6))) (and (not (= $o@@13 null)) (U_2_bool (MapType0Select (ite (Options.Option.Some_q |opt#0|) (Reads1 Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |f#0@@67| (Options.Option.value |opt#0|)) (|Set#Empty| BoxType)) ($Box $o@@13))))) (= (MapType1Select (MapType0Select $h0 $o@@13) $f) (MapType1Select (MapType0Select $h1 $o@@13) $f))))
 :qid |unknown.0:0|
 :skolemid |4452|
 :no-pattern (type $o@@13)
 :no-pattern (type $f)
 :no-pattern (U_2_int $o@@13)
 :no-pattern (U_2_bool $o@@13)
 :no-pattern (U_2_int $f)
 :no-pattern (U_2_bool $f)
))) (= (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |opt#0| |f#0@@67|) (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h1 |opt#0| |f#0@@67|)))
 :qid |unknown.0:0|
 :skolemid |4453|
 :pattern ( ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h1 |opt#0| |f#0@@67|))
)))
(assert  (=> true (forall ((Options._default.MapOption$V0@@0 T@U) (Options._default.MapOption$V1@@0 T@U) ($Heap@@2 T@U) (|opt#0@@0| T@U) (|f#0@@68| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@0) TyType) (= (type Options._default.MapOption$V1@@0) TyType)) (= (type $Heap@@2) (MapType0Type refType MapType1Type))) (= (type |opt#0@@0|) DatatypeTypeType)) (= (type |f#0@@68|) HandleTypeType)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|) (and (and (and ($IsGoodHeap $Heap@@2) ($Is |opt#0@@0| (Tclass.Options.Option Options._default.MapOption$V0@@0))) ($Is |f#0@@68| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0))) (=> (Options.Option.Some_q |opt#0@@0|) (Requires1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |f#0@@68| (Options.Option.value |opt#0@@0|)))))) (and (and (= (Options.Option.Some_q |opt#0@@0|) (Options.Option.Some_q (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|))) (=> (Options.Option.Some_q (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|)) (= (Options.Option.value (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|)) (Apply1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |f#0@@68| (Options.Option.value |opt#0@@0|))))) ($Is (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|) (Tclass.Options.Option Options._default.MapOption$V1@@0))))
 :qid |unknown.0:0|
 :skolemid |4454|
 :pattern ( (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@2 |opt#0@@0| |f#0@@68|))
))))
(assert (forall ((Options._default.MapOption$V0@@1 T@U) (Options._default.MapOption$V1@@1 T@U) ($Heap@@3 T@U) (|opt#0@@1| T@U) (|f#0@@69| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@1) TyType) (= (type Options._default.MapOption$V1@@1) TyType)) (= (type $Heap@@3) (MapType0Type refType MapType1Type))) (= (type |opt#0@@1|) DatatypeTypeType)) (= (type |f#0@@69|) HandleTypeType)) (and (and ($IsGoodHeap $Heap@@3) ($Is |opt#0@@1| (Tclass.Options.Option Options._default.MapOption$V0@@1))) ($Is |f#0@@69| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1)))) (= (|Options.__default.MapOption#requires| Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@3 |opt#0@@1| |f#0@@69|)  (=> (Options.Option.Some_q |opt#0@@1|) (Requires1 Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@3 |f#0@@69| (Options.Option.value |opt#0@@1|)))))
 :qid |unknown.0:0|
 :skolemid |4455|
 :pattern ( (|Options.__default.MapOption#requires| Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@3 |opt#0@@1| |f#0@@69|) ($IsGoodHeap $Heap@@3))
)))
(assert  (=> true (forall ((Options._default.MapOption$V0@@2 T@U) (Options._default.MapOption$V1@@2 T@U) ($Heap@@4 T@U) (|opt#0@@2| T@U) (|f#0@@70| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@2) TyType) (= (type Options._default.MapOption$V1@@2) TyType)) (= (type $Heap@@4) (MapType0Type refType MapType1Type))) (= (type |opt#0@@2|) DatatypeTypeType)) (= (type |f#0@@70|) HandleTypeType)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@4 |opt#0@@2| |f#0@@70|) (and (and (and ($IsGoodHeap $Heap@@4) ($Is |opt#0@@2| (Tclass.Options.Option Options._default.MapOption$V0@@2))) ($Is |f#0@@70| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2))) (=> (Options.Option.Some_q |opt#0@@2|) (Requires1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@4 |f#0@@70| (Options.Option.value |opt#0@@2|)))))) (= (Options.__default.MapOption Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@4 |opt#0@@2| |f#0@@70|) (ite (Options.Option.None_q |opt#0@@2|) |#Options.Option.None| (let ((|v#0@@7| (Options.Option.value |opt#0@@2|)))
(|#Options.Option.Some| (Apply1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@4 |f#0@@70| |v#0@@7|))))))
 :qid |unknown.0:0|
 :skolemid |4456|
 :pattern ( (Options.__default.MapOption Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@4 |opt#0@@2| |f#0@@70|) ($IsGoodHeap $Heap@@4))
))))
(assert (forall ((arg0@@441 T@U) (arg1@@168 T@U) (arg2@@87 T@U) (arg3@@47 T@U) (arg4@@29 T@U) ) (! (= (type (Options.__default.FlatMapOption arg0@@441 arg1@@168 arg2@@87 arg3@@47 arg4@@29)) DatatypeTypeType)
 :qid |funType:Options.__default.FlatMapOption|
 :pattern ( (Options.__default.FlatMapOption arg0@@441 arg1@@168 arg2@@87 arg3@@47 arg4@@29))
)))
(assert (forall ((Options._default.FlatMapOption$V0 T@U) (Options._default.FlatMapOption$V1 T@U) ($h0@@0 T@U) ($h1@@0 T@U) (|opt#0@@3| T@U) (|f#0@@71| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Options._default.FlatMapOption$V0) TyType) (= (type Options._default.FlatMapOption$V1) TyType)) (= (type $h0@@0) (MapType0Type refType MapType1Type))) (= (type $h1@@0) (MapType0Type refType MapType1Type))) (= (type |opt#0@@3|) DatatypeTypeType)) (= (type |f#0@@71|) HandleTypeType)) (and (and (and ($IsGoodHeap $h0@@0) ($IsGoodHeap $h1@@0)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h0@@0 |opt#0@@3| |f#0@@71|) (and ($Is |opt#0@@3| (Tclass.Options.Option Options._default.FlatMapOption$V0)) ($Is |f#0@@71| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0 (Tclass.Options.Option Options._default.FlatMapOption$V1)))))) (and ($IsHeapAnchor $h0@@0) ($HeapSucc $h0@@0 $h1@@0)))) (forall (($o@@14 T@U) ($f@@0 T@U) ) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0))))
 (=> (and (and (= (type $o@@14) refType) (= (type $f@@0) (FieldType alpha@@7))) (and (not (= $o@@14 null)) (U_2_bool (MapType0Select (ite (Options.Option.Some_q |opt#0@@3|) (Reads1 Options._default.FlatMapOption$V0 (Tclass.Options.Option Options._default.FlatMapOption$V1) $h0@@0 |f#0@@71| (Options.Option.value |opt#0@@3|)) (|Set#Empty| BoxType)) ($Box $o@@14))))) (= (MapType1Select (MapType0Select $h0@@0 $o@@14) $f@@0) (MapType1Select (MapType0Select $h1@@0 $o@@14) $f@@0))))
 :qid |unknown.0:0|
 :skolemid |4457|
 :no-pattern (type $o@@14)
 :no-pattern (type $f@@0)
 :no-pattern (U_2_int $o@@14)
 :no-pattern (U_2_bool $o@@14)
 :no-pattern (U_2_int $f@@0)
 :no-pattern (U_2_bool $f@@0)
))) (= (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h0@@0 |opt#0@@3| |f#0@@71|) (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h1@@0 |opt#0@@3| |f#0@@71|)))
 :qid |unknown.0:0|
 :skolemid |4458|
 :pattern ( ($IsHeapAnchor $h0@@0) ($HeapSucc $h0@@0 $h1@@0) (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h1@@0 |opt#0@@3| |f#0@@71|))
)))
(assert  (=> true (forall ((Options._default.FlatMapOption$V0@@0 T@U) (Options._default.FlatMapOption$V1@@0 T@U) ($Heap@@5 T@U) (|opt#0@@4| T@U) (|f#0@@72| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@0) TyType) (= (type Options._default.FlatMapOption$V1@@0) TyType)) (= (type $Heap@@5) (MapType0Type refType MapType1Type))) (= (type |opt#0@@4|) DatatypeTypeType)) (= (type |f#0@@72|) HandleTypeType)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@5 |opt#0@@4| |f#0@@72|) (and (and (and ($IsGoodHeap $Heap@@5) ($Is |opt#0@@4| (Tclass.Options.Option Options._default.FlatMapOption$V0@@0))) ($Is |f#0@@72| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0)))) (=> (Options.Option.Some_q |opt#0@@4|) (Requires1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@5 |f#0@@72| (Options.Option.value |opt#0@@4|)))))) (and (and (=> (and (Options.Option.Some_q |opt#0@@4|) (Options.Option.Some_q ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@5 |f#0@@72| (Options.Option.value |opt#0@@4|))))) (Options.Option.Some_q (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@5 |opt#0@@4| |f#0@@72|))) (=> (and (Options.Option.Some_q |opt#0@@4|) (Options.Option.Some_q ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@5 |f#0@@72| (Options.Option.value |opt#0@@4|))))) (= (Options.Option.value (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@5 |opt#0@@4| |f#0@@72|)) (Options.Option.value ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@5 |f#0@@72| (Options.Option.value |opt#0@@4|))))))) ($Is (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@5 |opt#0@@4| |f#0@@72|) (Tclass.Options.Option Options._default.FlatMapOption$V1@@0))))
 :qid |unknown.0:0|
 :skolemid |4459|
 :pattern ( (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@5 |opt#0@@4| |f#0@@72|))
))))
(assert (forall ((Options._default.FlatMapOption$V0@@1 T@U) (Options._default.FlatMapOption$V1@@1 T@U) ($Heap@@6 T@U) (|opt#0@@5| T@U) (|f#0@@73| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@1) TyType) (= (type Options._default.FlatMapOption$V1@@1) TyType)) (= (type $Heap@@6) (MapType0Type refType MapType1Type))) (= (type |opt#0@@5|) DatatypeTypeType)) (= (type |f#0@@73|) HandleTypeType)) (and (and ($IsGoodHeap $Heap@@6) ($Is |opt#0@@5| (Tclass.Options.Option Options._default.FlatMapOption$V0@@1))) ($Is |f#0@@73| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@1 (Tclass.Options.Option Options._default.FlatMapOption$V1@@1))))) (= (|Options.__default.FlatMapOption#requires| Options._default.FlatMapOption$V0@@1 Options._default.FlatMapOption$V1@@1 $Heap@@6 |opt#0@@5| |f#0@@73|)  (=> (Options.Option.Some_q |opt#0@@5|) (Requires1 Options._default.FlatMapOption$V0@@1 (Tclass.Options.Option Options._default.FlatMapOption$V1@@1) $Heap@@6 |f#0@@73| (Options.Option.value |opt#0@@5|)))))
 :qid |unknown.0:0|
 :skolemid |4460|
 :pattern ( (|Options.__default.FlatMapOption#requires| Options._default.FlatMapOption$V0@@1 Options._default.FlatMapOption$V1@@1 $Heap@@6 |opt#0@@5| |f#0@@73|) ($IsGoodHeap $Heap@@6))
)))
(assert  (=> true (forall ((Options._default.FlatMapOption$V0@@2 T@U) (Options._default.FlatMapOption$V1@@2 T@U) ($Heap@@7 T@U) (|opt#0@@6| T@U) (|f#0@@74| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@2) TyType) (= (type Options._default.FlatMapOption$V1@@2) TyType)) (= (type $Heap@@7) (MapType0Type refType MapType1Type))) (= (type |opt#0@@6|) DatatypeTypeType)) (= (type |f#0@@74|) HandleTypeType)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@7 |opt#0@@6| |f#0@@74|) (and (and (and ($IsGoodHeap $Heap@@7) ($Is |opt#0@@6| (Tclass.Options.Option Options._default.FlatMapOption$V0@@2))) ($Is |f#0@@74| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2)))) (=> (Options.Option.Some_q |opt#0@@6|) (Requires1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2) $Heap@@7 |f#0@@74| (Options.Option.value |opt#0@@6|)))))) (= (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@7 |opt#0@@6| |f#0@@74|) (ite (Options.Option.None_q |opt#0@@6|) |#Options.Option.None| (let ((|v#0@@8| (Options.Option.value |opt#0@@6|)))
($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2) $Heap@@7 |f#0@@74| |v#0@@8|))))))
 :qid |unknown.0:0|
 :skolemid |4461|
 :pattern ( (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@7 |opt#0@@6| |f#0@@74|) ($IsGoodHeap $Heap@@7))
))))
(assert (= (type Tclass.NativeTypes.sbyte) TyType))
(assert (= (Tag Tclass.NativeTypes.sbyte) Tagclass.NativeTypes.sbyte))
(assert (= (TagFamily Tclass.NativeTypes.sbyte) tytagFamily$sbyte))
(assert (forall ((bx@@134 T@U) ) (!  (=> (and (= (type bx@@134) BoxType) ($IsBox bx@@134 Tclass.NativeTypes.sbyte)) (and (= ($Box ($Unbox intType bx@@134)) bx@@134) ($Is ($Unbox intType bx@@134) Tclass.NativeTypes.sbyte)))
 :qid |unknown.0:0|
 :skolemid |4462|
 :pattern ( ($IsBox bx@@134 Tclass.NativeTypes.sbyte))
)))
(assert (forall ((|i#0| T@U) ) (!  (=> (= (type |i#0|) intType) (= ($Is |i#0| Tclass.NativeTypes.sbyte)  (and (INTERNAL_le_boogie (- 0 128) (U_2_int |i#0|)) (INTERNAL_lt_boogie (U_2_int |i#0|) 128))))
 :qid |unknown.0:0|
 :skolemid |4463|
 :pattern ( ($Is |i#0| Tclass.NativeTypes.sbyte))
)))
(assert (forall ((|i#0@@0| T@U) ($h@@54 T@U) ) (!  (=> (and (= (type |i#0@@0|) intType) (= (type $h@@54) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@0| Tclass.NativeTypes.sbyte $h@@54))
 :qid |unknown.0:0|
 :skolemid |4464|
 :pattern ( ($IsAlloc |i#0@@0| Tclass.NativeTypes.sbyte $h@@54))
)))
(assert (forall ((|i#0@@1| T@U) ) (!  (=> (= (type |i#0@@1|) intType) (= ($Is |i#0@@1| Tclass.NativeTypes.byte)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@1|)) (INTERNAL_lt_boogie (U_2_int |i#0@@1|) 256))))
 :qid |unknown.0:0|
 :skolemid |4465|
 :pattern ( ($Is |i#0@@1| Tclass.NativeTypes.byte))
)))
(assert (forall ((|i#0@@2| T@U) ($h@@55 T@U) ) (!  (=> (and (= (type |i#0@@2|) intType) (= (type $h@@55) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@2| Tclass.NativeTypes.byte $h@@55))
 :qid |unknown.0:0|
 :skolemid |4466|
 :pattern ( ($IsAlloc |i#0@@2| Tclass.NativeTypes.byte $h@@55))
)))
(assert (= (type Tclass.NativeTypes.int16) TyType))
(assert (= (Tag Tclass.NativeTypes.int16) Tagclass.NativeTypes.int16))
(assert (= (TagFamily Tclass.NativeTypes.int16) tytagFamily$int16))
(assert (forall ((bx@@135 T@U) ) (!  (=> (and (= (type bx@@135) BoxType) ($IsBox bx@@135 Tclass.NativeTypes.int16)) (and (= ($Box ($Unbox intType bx@@135)) bx@@135) ($Is ($Unbox intType bx@@135) Tclass.NativeTypes.int16)))
 :qid |unknown.0:0|
 :skolemid |4467|
 :pattern ( ($IsBox bx@@135 Tclass.NativeTypes.int16))
)))
(assert (forall ((|i#0@@3| T@U) ) (!  (=> (= (type |i#0@@3|) intType) (= ($Is |i#0@@3| Tclass.NativeTypes.int16)  (and (INTERNAL_le_boogie (- 0 32768) (U_2_int |i#0@@3|)) (INTERNAL_lt_boogie (U_2_int |i#0@@3|) 32768))))
 :qid |unknown.0:0|
 :skolemid |4468|
 :pattern ( ($Is |i#0@@3| Tclass.NativeTypes.int16))
)))
(assert (forall ((|i#0@@4| T@U) ($h@@56 T@U) ) (!  (=> (and (= (type |i#0@@4|) intType) (= (type $h@@56) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@4| Tclass.NativeTypes.int16 $h@@56))
 :qid |unknown.0:0|
 :skolemid |4469|
 :pattern ( ($IsAlloc |i#0@@4| Tclass.NativeTypes.int16 $h@@56))
)))
(assert (= (type Tclass.NativeTypes.uint16) TyType))
(assert (= (Tag Tclass.NativeTypes.uint16) Tagclass.NativeTypes.uint16))
(assert (= (TagFamily Tclass.NativeTypes.uint16) tytagFamily$uint16))
(assert (forall ((bx@@136 T@U) ) (!  (=> (and (= (type bx@@136) BoxType) ($IsBox bx@@136 Tclass.NativeTypes.uint16)) (and (= ($Box ($Unbox intType bx@@136)) bx@@136) ($Is ($Unbox intType bx@@136) Tclass.NativeTypes.uint16)))
 :qid |unknown.0:0|
 :skolemid |4470|
 :pattern ( ($IsBox bx@@136 Tclass.NativeTypes.uint16))
)))
(assert (forall ((|i#0@@5| T@U) ) (!  (=> (= (type |i#0@@5|) intType) (= ($Is |i#0@@5| Tclass.NativeTypes.uint16)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@5|)) (INTERNAL_lt_boogie (U_2_int |i#0@@5|) 65536))))
 :qid |unknown.0:0|
 :skolemid |4471|
 :pattern ( ($Is |i#0@@5| Tclass.NativeTypes.uint16))
)))
(assert (forall ((|i#0@@6| T@U) ($h@@57 T@U) ) (!  (=> (and (= (type |i#0@@6|) intType) (= (type $h@@57) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@6| Tclass.NativeTypes.uint16 $h@@57))
 :qid |unknown.0:0|
 :skolemid |4472|
 :pattern ( ($IsAlloc |i#0@@6| Tclass.NativeTypes.uint16 $h@@57))
)))
(assert (= (type Tclass.NativeTypes.int32) TyType))
(assert (= (Tag Tclass.NativeTypes.int32) Tagclass.NativeTypes.int32))
(assert (= (TagFamily Tclass.NativeTypes.int32) tytagFamily$int32))
(assert (forall ((bx@@137 T@U) ) (!  (=> (and (= (type bx@@137) BoxType) ($IsBox bx@@137 Tclass.NativeTypes.int32)) (and (= ($Box ($Unbox intType bx@@137)) bx@@137) ($Is ($Unbox intType bx@@137) Tclass.NativeTypes.int32)))
 :qid |unknown.0:0|
 :skolemid |4473|
 :pattern ( ($IsBox bx@@137 Tclass.NativeTypes.int32))
)))
(assert (forall ((|i#0@@7| T@U) ) (!  (=> (= (type |i#0@@7|) intType) (= ($Is |i#0@@7| Tclass.NativeTypes.int32)  (and (INTERNAL_le_boogie (- 0 2147483648) (U_2_int |i#0@@7|)) (INTERNAL_lt_boogie (U_2_int |i#0@@7|) 2147483648))))
 :qid |unknown.0:0|
 :skolemid |4474|
 :pattern ( ($Is |i#0@@7| Tclass.NativeTypes.int32))
)))
(assert (forall ((|i#0@@8| T@U) ($h@@58 T@U) ) (!  (=> (and (= (type |i#0@@8|) intType) (= (type $h@@58) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@8| Tclass.NativeTypes.int32 $h@@58))
 :qid |unknown.0:0|
 :skolemid |4475|
 :pattern ( ($IsAlloc |i#0@@8| Tclass.NativeTypes.int32 $h@@58))
)))
(assert (= (type Tclass.NativeTypes.uint32) TyType))
(assert (= (Tag Tclass.NativeTypes.uint32) Tagclass.NativeTypes.uint32))
(assert (= (TagFamily Tclass.NativeTypes.uint32) tytagFamily$uint32))
(assert (forall ((bx@@138 T@U) ) (!  (=> (and (= (type bx@@138) BoxType) ($IsBox bx@@138 Tclass.NativeTypes.uint32)) (and (= ($Box ($Unbox intType bx@@138)) bx@@138) ($Is ($Unbox intType bx@@138) Tclass.NativeTypes.uint32)))
 :qid |unknown.0:0|
 :skolemid |4476|
 :pattern ( ($IsBox bx@@138 Tclass.NativeTypes.uint32))
)))
(assert (forall ((|i#0@@9| T@U) ) (!  (=> (= (type |i#0@@9|) intType) (= ($Is |i#0@@9| Tclass.NativeTypes.uint32)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@9|)) (INTERNAL_lt_boogie (U_2_int |i#0@@9|) 4294967296))))
 :qid |unknown.0:0|
 :skolemid |4477|
 :pattern ( ($Is |i#0@@9| Tclass.NativeTypes.uint32))
)))
(assert (forall ((|i#0@@10| T@U) ($h@@59 T@U) ) (!  (=> (and (= (type |i#0@@10|) intType) (= (type $h@@59) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@10| Tclass.NativeTypes.uint32 $h@@59))
 :qid |unknown.0:0|
 :skolemid |4478|
 :pattern ( ($IsAlloc |i#0@@10| Tclass.NativeTypes.uint32 $h@@59))
)))
(assert (= (type Tclass.NativeTypes.int64) TyType))
(assert (= (Tag Tclass.NativeTypes.int64) Tagclass.NativeTypes.int64))
(assert (= (TagFamily Tclass.NativeTypes.int64) tytagFamily$int64))
(assert (forall ((bx@@139 T@U) ) (!  (=> (and (= (type bx@@139) BoxType) ($IsBox bx@@139 Tclass.NativeTypes.int64)) (and (= ($Box ($Unbox intType bx@@139)) bx@@139) ($Is ($Unbox intType bx@@139) Tclass.NativeTypes.int64)))
 :qid |unknown.0:0|
 :skolemid |4479|
 :pattern ( ($IsBox bx@@139 Tclass.NativeTypes.int64))
)))
(assert (forall ((|i#0@@11| T@U) ) (!  (=> (= (type |i#0@@11|) intType) (= ($Is |i#0@@11| Tclass.NativeTypes.int64)  (and (INTERNAL_le_boogie (- 0 9223372036854775808) (U_2_int |i#0@@11|)) (INTERNAL_lt_boogie (U_2_int |i#0@@11|) 9223372036854775808))))
 :qid |unknown.0:0|
 :skolemid |4480|
 :pattern ( ($Is |i#0@@11| Tclass.NativeTypes.int64))
)))
(assert (forall ((|i#0@@12| T@U) ($h@@60 T@U) ) (!  (=> (and (= (type |i#0@@12|) intType) (= (type $h@@60) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@12| Tclass.NativeTypes.int64 $h@@60))
 :qid |unknown.0:0|
 :skolemid |4481|
 :pattern ( ($IsAlloc |i#0@@12| Tclass.NativeTypes.int64 $h@@60))
)))
(assert (= (type Tclass.NativeTypes.uint64) TyType))
(assert (= (Tag Tclass.NativeTypes.uint64) Tagclass.NativeTypes.uint64))
(assert (= (TagFamily Tclass.NativeTypes.uint64) tytagFamily$uint64))
(assert (forall ((bx@@140 T@U) ) (!  (=> (and (= (type bx@@140) BoxType) ($IsBox bx@@140 Tclass.NativeTypes.uint64)) (and (= ($Box ($Unbox intType bx@@140)) bx@@140) ($Is ($Unbox intType bx@@140) Tclass.NativeTypes.uint64)))
 :qid |unknown.0:0|
 :skolemid |4482|
 :pattern ( ($IsBox bx@@140 Tclass.NativeTypes.uint64))
)))
(assert (forall ((|i#0@@13| T@U) ) (!  (=> (= (type |i#0@@13|) intType) (= ($Is |i#0@@13| Tclass.NativeTypes.uint64)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@13|)) (INTERNAL_lt_boogie (U_2_int |i#0@@13|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |4483|
 :pattern ( ($Is |i#0@@13| Tclass.NativeTypes.uint64))
)))
(assert (forall ((|i#0@@14| T@U) ($h@@61 T@U) ) (!  (=> (and (= (type |i#0@@14|) intType) (= (type $h@@61) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@14| Tclass.NativeTypes.uint64 $h@@61))
 :qid |unknown.0:0|
 :skolemid |4484|
 :pattern ( ($IsAlloc |i#0@@14| Tclass.NativeTypes.uint64 $h@@61))
)))
(assert (= (type Tclass.NativeTypes.nat8) TyType))
(assert (= (Tag Tclass.NativeTypes.nat8) Tagclass.NativeTypes.nat8))
(assert (= (TagFamily Tclass.NativeTypes.nat8) tytagFamily$nat8))
(assert (forall ((bx@@141 T@U) ) (!  (=> (and (= (type bx@@141) BoxType) ($IsBox bx@@141 Tclass.NativeTypes.nat8)) (and (= ($Box ($Unbox intType bx@@141)) bx@@141) ($Is ($Unbox intType bx@@141) Tclass.NativeTypes.nat8)))
 :qid |unknown.0:0|
 :skolemid |4485|
 :pattern ( ($IsBox bx@@141 Tclass.NativeTypes.nat8))
)))
(assert (forall ((|i#0@@15| T@U) ) (!  (=> (= (type |i#0@@15|) intType) (= ($Is |i#0@@15| Tclass.NativeTypes.nat8)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@15|)) (INTERNAL_lt_boogie (U_2_int |i#0@@15|) 128))))
 :qid |unknown.0:0|
 :skolemid |4486|
 :pattern ( ($Is |i#0@@15| Tclass.NativeTypes.nat8))
)))
(assert (forall ((|i#0@@16| T@U) ($h@@62 T@U) ) (!  (=> (and (= (type |i#0@@16|) intType) (= (type $h@@62) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@16| Tclass.NativeTypes.nat8 $h@@62))
 :qid |unknown.0:0|
 :skolemid |4487|
 :pattern ( ($IsAlloc |i#0@@16| Tclass.NativeTypes.nat8 $h@@62))
)))
(assert (= (type Tclass.NativeTypes.nat16) TyType))
(assert (= (Tag Tclass.NativeTypes.nat16) Tagclass.NativeTypes.nat16))
(assert (= (TagFamily Tclass.NativeTypes.nat16) tytagFamily$nat16))
(assert (forall ((bx@@142 T@U) ) (!  (=> (and (= (type bx@@142) BoxType) ($IsBox bx@@142 Tclass.NativeTypes.nat16)) (and (= ($Box ($Unbox intType bx@@142)) bx@@142) ($Is ($Unbox intType bx@@142) Tclass.NativeTypes.nat16)))
 :qid |unknown.0:0|
 :skolemid |4488|
 :pattern ( ($IsBox bx@@142 Tclass.NativeTypes.nat16))
)))
(assert (forall ((|i#0@@17| T@U) ) (!  (=> (= (type |i#0@@17|) intType) (= ($Is |i#0@@17| Tclass.NativeTypes.nat16)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@17|)) (INTERNAL_lt_boogie (U_2_int |i#0@@17|) 32768))))
 :qid |unknown.0:0|
 :skolemid |4489|
 :pattern ( ($Is |i#0@@17| Tclass.NativeTypes.nat16))
)))
(assert (forall ((|i#0@@18| T@U) ($h@@63 T@U) ) (!  (=> (and (= (type |i#0@@18|) intType) (= (type $h@@63) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@18| Tclass.NativeTypes.nat16 $h@@63))
 :qid |unknown.0:0|
 :skolemid |4490|
 :pattern ( ($IsAlloc |i#0@@18| Tclass.NativeTypes.nat16 $h@@63))
)))
(assert (= (type Tclass.NativeTypes.nat32) TyType))
(assert (= (Tag Tclass.NativeTypes.nat32) Tagclass.NativeTypes.nat32))
(assert (= (TagFamily Tclass.NativeTypes.nat32) tytagFamily$nat32))
(assert (forall ((bx@@143 T@U) ) (!  (=> (and (= (type bx@@143) BoxType) ($IsBox bx@@143 Tclass.NativeTypes.nat32)) (and (= ($Box ($Unbox intType bx@@143)) bx@@143) ($Is ($Unbox intType bx@@143) Tclass.NativeTypes.nat32)))
 :qid |unknown.0:0|
 :skolemid |4491|
 :pattern ( ($IsBox bx@@143 Tclass.NativeTypes.nat32))
)))
(assert (forall ((|i#0@@19| T@U) ) (!  (=> (= (type |i#0@@19|) intType) (= ($Is |i#0@@19| Tclass.NativeTypes.nat32)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@19|)) (INTERNAL_lt_boogie (U_2_int |i#0@@19|) 2147483648))))
 :qid |unknown.0:0|
 :skolemid |4492|
 :pattern ( ($Is |i#0@@19| Tclass.NativeTypes.nat32))
)))
(assert (forall ((|i#0@@20| T@U) ($h@@64 T@U) ) (!  (=> (and (= (type |i#0@@20|) intType) (= (type $h@@64) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@20| Tclass.NativeTypes.nat32 $h@@64))
 :qid |unknown.0:0|
 :skolemid |4493|
 :pattern ( ($IsAlloc |i#0@@20| Tclass.NativeTypes.nat32 $h@@64))
)))
(assert (= (type Tclass.NativeTypes.nat64) TyType))
(assert (= (Tag Tclass.NativeTypes.nat64) Tagclass.NativeTypes.nat64))
(assert (= (TagFamily Tclass.NativeTypes.nat64) tytagFamily$nat64))
(assert (forall ((bx@@144 T@U) ) (!  (=> (and (= (type bx@@144) BoxType) ($IsBox bx@@144 Tclass.NativeTypes.nat64)) (and (= ($Box ($Unbox intType bx@@144)) bx@@144) ($Is ($Unbox intType bx@@144) Tclass.NativeTypes.nat64)))
 :qid |unknown.0:0|
 :skolemid |4494|
 :pattern ( ($IsBox bx@@144 Tclass.NativeTypes.nat64))
)))
(assert (forall ((|i#0@@21| T@U) ) (!  (=> (= (type |i#0@@21|) intType) (= ($Is |i#0@@21| Tclass.NativeTypes.nat64)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@21|)) (INTERNAL_lt_boogie (U_2_int |i#0@@21|) 9223372036854775808))))
 :qid |unknown.0:0|
 :skolemid |4495|
 :pattern ( ($Is |i#0@@21| Tclass.NativeTypes.nat64))
)))
(assert (forall ((|i#0@@22| T@U) ($h@@65 T@U) ) (!  (=> (and (= (type |i#0@@22|) intType) (= (type $h@@65) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@22| Tclass.NativeTypes.nat64 $h@@65))
 :qid |unknown.0:0|
 :skolemid |4496|
 :pattern ( ($IsAlloc |i#0@@22| Tclass.NativeTypes.nat64 $h@@65))
)))
(assert (= (type Tclass.NativeTypes.uint128) TyType))
(assert (= (Tag Tclass.NativeTypes.uint128) Tagclass.NativeTypes.uint128))
(assert (= (TagFamily Tclass.NativeTypes.uint128) tytagFamily$uint128))
(assert (forall ((bx@@145 T@U) ) (!  (=> (and (= (type bx@@145) BoxType) ($IsBox bx@@145 Tclass.NativeTypes.uint128)) (and (= ($Box ($Unbox intType bx@@145)) bx@@145) ($Is ($Unbox intType bx@@145) Tclass.NativeTypes.uint128)))
 :qid |unknown.0:0|
 :skolemid |4497|
 :pattern ( ($IsBox bx@@145 Tclass.NativeTypes.uint128))
)))
(assert (forall ((|i#0@@23| T@U) ) (!  (=> (= (type |i#0@@23|) intType) (= ($Is |i#0@@23| Tclass.NativeTypes.uint128)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@23|)) (INTERNAL_lt_boogie (U_2_int |i#0@@23|) 340282366920938463463374607431768211456))))
 :qid |unknown.0:0|
 :skolemid |4498|
 :pattern ( ($Is |i#0@@23| Tclass.NativeTypes.uint128))
)))
(assert (forall ((|i#0@@24| T@U) ($h@@66 T@U) ) (!  (=> (and (= (type |i#0@@24|) intType) (= (type $h@@66) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@24| Tclass.NativeTypes.uint128 $h@@66))
 :qid |unknown.0:0|
 :skolemid |4499|
 :pattern ( ($IsAlloc |i#0@@24| Tclass.NativeTypes.uint128 $h@@66))
)))
(assert (= (type Tclass.NativeTypes.__default) TyType))
(assert (= (Tag Tclass.NativeTypes.__default) Tagclass.NativeTypes.__default))
(assert (= (TagFamily Tclass.NativeTypes.__default) tytagFamily$_default))
(assert (forall ((bx@@146 T@U) ) (!  (=> (and (= (type bx@@146) BoxType) ($IsBox bx@@146 Tclass.NativeTypes.__default)) (and (= ($Box ($Unbox refType bx@@146)) bx@@146) ($Is ($Unbox refType bx@@146) Tclass.NativeTypes.__default)))
 :qid |unknown.0:0|
 :skolemid |4500|
 :pattern ( ($IsBox bx@@146 Tclass.NativeTypes.__default))
)))
(assert (forall (($o@@15 T@U) ) (!  (=> (= (type $o@@15) refType) (= ($Is $o@@15 Tclass.NativeTypes.__default)  (or (= $o@@15 null) (= (dtype $o@@15) Tclass.NativeTypes.__default))))
 :qid |unknown.0:0|
 :skolemid |4501|
 :pattern ( ($Is $o@@15 Tclass.NativeTypes.__default))
)))
(assert (forall (($o@@16 T@U) ($h@@67 T@U) ) (!  (=> (and (= (type $o@@16) refType) (= (type $h@@67) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@67)  (or (= $o@@16 null) (U_2_bool (MapType1Select (MapType0Select $h@@67 $o@@16) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4502|
 :pattern ( ($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@67))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint64Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint64Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint64Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint32Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint32Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint32Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint16Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint16Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint16Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert  (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint64UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert  (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint32UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint8UpperBound) (INTERNAL_lt_boogie NativeTypes.__default.Uint8UpperBound 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint8UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert (forall ((|s#0| T@U) ) (!  (=> (= (type |s#0|) (SeqType BoxType)) (= ($Is |s#0| Tclass.KeyType.Key)  (and ($Is |s#0| (TSeq Tclass.NativeTypes.byte)) (INTERNAL_le_boogie (|Seq#Length| |s#0|) 1024))))
 :qid |unknown.0:0|
 :skolemid |4503|
 :pattern ( ($Is |s#0| Tclass.KeyType.Key))
)))
(assert (forall ((|s#0@@0| T@U) ($h@@68 T@U) ) (!  (=> (and (= (type |s#0@@0|) (SeqType BoxType)) (= (type $h@@68) (MapType0Type refType MapType1Type))) (= ($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@68) ($IsAlloc |s#0@@0| (TSeq Tclass.NativeTypes.byte) $h@@68)))
 :qid |unknown.0:0|
 :skolemid |4504|
 :pattern ( ($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@68))
)))
(assert (= (type Tclass.KeyType.__default) TyType))
(assert (= (Tag Tclass.KeyType.__default) Tagclass.KeyType.__default))
(assert (= (TagFamily Tclass.KeyType.__default) tytagFamily$_default))
(assert (forall ((bx@@147 T@U) ) (!  (=> (and (= (type bx@@147) BoxType) ($IsBox bx@@147 Tclass.KeyType.__default)) (and (= ($Box ($Unbox refType bx@@147)) bx@@147) ($Is ($Unbox refType bx@@147) Tclass.KeyType.__default)))
 :qid |unknown.0:0|
 :skolemid |4505|
 :pattern ( ($IsBox bx@@147 Tclass.KeyType.__default))
)))
(assert (forall (($o@@17 T@U) ) (!  (=> (= (type $o@@17) refType) (= ($Is $o@@17 Tclass.KeyType.__default)  (or (= $o@@17 null) (= (dtype $o@@17) Tclass.KeyType.__default))))
 :qid |unknown.0:0|
 :skolemid |4506|
 :pattern ( ($Is $o@@17 Tclass.KeyType.__default))
)))
(assert (forall (($o@@18 T@U) ($h@@69 T@U) ) (!  (=> (and (= (type $o@@18) refType) (= (type $h@@69) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@18 Tclass.KeyType.__default $h@@69)  (or (= $o@@18 null) (U_2_bool (MapType1Select (MapType0Select $h@@69 $o@@18) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4507|
 :pattern ( ($IsAlloc $o@@18 Tclass.KeyType.__default $h@@69))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 KeyType.__default.MaxLen) (INTERNAL_lt_boogie KeyType.__default.MaxLen 18446744073709551616)))))
(assert (= |KeyType.__default.MaxLen#requires| true))
(assert  (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert  (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert (forall ((|s#0@@1| T@U) ) (!  (=> (= (type |s#0@@1|) (SeqType BoxType)) (= ($Is |s#0@@1| Tclass.ValueType.Value)  (and ($Is |s#0@@1| (TSeq Tclass.NativeTypes.byte)) (INTERNAL_le_boogie (|Seq#Length| |s#0@@1|) 1024))))
 :qid |unknown.0:0|
 :skolemid |4508|
 :pattern ( ($Is |s#0@@1| Tclass.ValueType.Value))
)))
(assert (forall ((|s#0@@2| T@U) ($h@@70 T@U) ) (!  (=> (and (= (type |s#0@@2|) (SeqType BoxType)) (= (type $h@@70) (MapType0Type refType MapType1Type))) (= ($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@70) ($IsAlloc |s#0@@2| (TSeq Tclass.NativeTypes.byte) $h@@70)))
 :qid |unknown.0:0|
 :skolemid |4509|
 :pattern ( ($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@70))
)))
(assert (= (type Tclass.ValueType.__default) TyType))
(assert (= (Tag Tclass.ValueType.__default) Tagclass.ValueType.__default))
(assert (= (TagFamily Tclass.ValueType.__default) tytagFamily$_default))
(assert (forall (($o@@19 T@U) ) (!  (=> (= (type $o@@19) refType) (= ($Is $o@@19 Tclass.ValueType.__default)  (or (= $o@@19 null) (= (dtype $o@@19) Tclass.ValueType.__default))))
 :qid |unknown.0:0|
 :skolemid |4510|
 :pattern ( ($Is $o@@19 Tclass.ValueType.__default))
)))
(assert (forall (($o@@20 T@U) ($h@@71 T@U) ) (!  (=> (and (= (type $o@@20) refType) (= (type $h@@71) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@20 Tclass.ValueType.__default $h@@71)  (or (= $o@@20 null) (U_2_bool (MapType1Select (MapType0Select $h@@71 $o@@20) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4511|
 :pattern ( ($IsAlloc $o@@20 Tclass.ValueType.__default $h@@71))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 ValueType.__default.MaxLen) (INTERNAL_lt_boogie ValueType.__default.MaxLen 18446744073709551616)))))
(assert (= |ValueType.__default.MaxLen#requires| true))
(assert  (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert  (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert (= (type ValueType.__default.DefaultValue) (SeqType BoxType)))
(assert  (=> true (=> true ($Is ValueType.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueType.__default.DefaultValue#requires| true))
(assert  (=> true (=> true (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (=> true (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (forall ((|v#0@@9| T@U) ) (!  (=> (and (= (type |v#0@@9|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| |v#0@@9|) ($Is |v#0@@9| Tclass.ValueType.Value))) (INTERNAL_le_boogie 0 (ValueType.__default.Len |v#0@@9|)))
 :qid |KeyTypesdfy.20:15|
 :skolemid |4512|
 :pattern ( (ValueType.__default.Len |v#0@@9|))
))))
(assert (forall ((|v#0@@10| T@U) ) (!  (=> (and (= (type |v#0@@10|) (SeqType BoxType)) ($Is |v#0@@10| Tclass.ValueType.Value)) (= (|ValueType.__default.Len#requires| |v#0@@10|) true))
 :qid |KeyTypesdfy.20:15|
 :skolemid |4513|
 :pattern ( (|ValueType.__default.Len#requires| |v#0@@10|))
)))
(assert  (=> true (forall ((|v#0@@11| T@U) ) (!  (=> (and (= (type |v#0@@11|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| |v#0@@11|) ($Is |v#0@@11| Tclass.ValueType.Value))) (= (ValueType.__default.Len |v#0@@11|) (|Seq#Length| |v#0@@11|)))
 :qid |KeyTypesdfy.20:15|
 :skolemid |4514|
 :pattern ( (ValueType.__default.Len |v#0@@11|))
))))
(assert  (=> true (forall ((|v#0@@12| T@U) ) (!  (=> (and (= (type |v#0@@12|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| (Lit |v#0@@12|)) ($Is |v#0@@12| Tclass.ValueType.Value))) (= (ValueType.__default.Len (Lit |v#0@@12|)) (|Seq#Length| (Lit |v#0@@12|))))
 :qid |KeyTypesdfy.20:15|
 :weight 3
 :skolemid |4515|
 :pattern ( (ValueType.__default.Len (Lit |v#0@@12|)))
))))
(assert  (=> true (forall ((|s#0@@3| T@U) ) (!  (=> (and (= (type |s#0@@3|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| |s#0@@3|) ($Is |s#0@@3| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |KeyTypesdfy.22:36|
 :skolemid |4516|
 :pattern ( (ValueType.__default.ValidMessageBytestring |s#0@@3|))
))))
(assert (forall ((|s#0@@4| T@U) ) (!  (=> (and (= (type |s#0@@4|) (SeqType BoxType)) ($Is |s#0@@4| (TSeq Tclass.NativeTypes.byte))) (= (|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|) true))
 :qid |KeyTypesdfy.22:36|
 :skolemid |4517|
 :pattern ( (|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|))
)))
(assert  (=> true (forall ((|s#0@@5| T@U) ) (!  (=> (and (= (type |s#0@@5|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| |s#0@@5|) ($Is |s#0@@5| (TSeq Tclass.NativeTypes.byte)))) (and |ValueType.__default.MaxLen#canCall| (= (ValueType.__default.ValidMessageBytestring |s#0@@5|) (INTERNAL_le_boogie (|Seq#Length| |s#0@@5|) ValueType.__default.MaxLen))))
 :qid |KeyTypesdfy.22:36|
 :skolemid |4518|
 :pattern ( (ValueType.__default.ValidMessageBytestring |s#0@@5|))
))))
(assert  (=> true (forall ((|s#0@@6| T@U) ) (!  (=> (and (= (type |s#0@@6|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| (Lit |s#0@@6|)) ($Is |s#0@@6| (TSeq Tclass.NativeTypes.byte)))) (and |ValueType.__default.MaxLen#canCall| (= (ValueType.__default.ValidMessageBytestring (Lit |s#0@@6|)) (INTERNAL_le_boogie (|Seq#Length| (Lit |s#0@@6|)) ValueType.__default.MaxLen))))
 :qid |KeyTypesdfy.22:36|
 :weight 3
 :skolemid |4519|
 :pattern ( (ValueType.__default.ValidMessageBytestring (Lit |s#0@@6|)))
))))
(assert  (=> true (forall ((|strs#0| T@U) ) (!  (=> (and (= (type |strs#0|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| |strs#0|) ($Is |strs#0| (TSeq (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |KeyTypesdfy.27:37|
 :skolemid |4520|
 :pattern ( (ValueType.__default.ValidMessageBytestrings |strs#0|))
))))
(assert (forall ((|strs#0@@0| T@U) ) (!  (=> (and (= (type |strs#0@@0|) (SeqType BoxType)) ($Is |strs#0@@0| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|ValueType.__default.ValidMessageBytestrings#requires| |strs#0@@0|) true))
 :qid |KeyTypesdfy.27:37|
 :skolemid |4521|
 :pattern ( (|ValueType.__default.ValidMessageBytestrings#requires| |strs#0@@0|))
)))
(assert  (=> true (forall ((|strs#0@@1| T@U) ) (!  (=> (and (= (type |strs#0@@1|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| |strs#0@@1|) ($Is |strs#0@@1| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@25| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@25|) (INTERNAL_lt_boogie |i#0@@25| (|Seq#Length| |strs#0@@1|))) (|ValueType.__default.ValidMessageBytestring#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@25|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |4523|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@25|)))
)) (= (ValueType.__default.ValidMessageBytestrings |strs#0@@1|) (forall ((|i#0@@26| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@26|) (INTERNAL_lt_boogie |i#0@@26| (|Seq#Length| |strs#0@@1|))) (ValueType.__default.ValidMessageBytestring ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@26|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |4522|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@26|)))
)))))
 :qid |KeyTypesdfy.27:37|
 :skolemid |4524|
 :pattern ( (ValueType.__default.ValidMessageBytestrings |strs#0@@1|))
))))
(assert  (=> true (forall ((|strs#0@@2| T@U) ) (!  (=> (and (= (type |strs#0@@2|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| (Lit |strs#0@@2|)) ($Is |strs#0@@2| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1|) (INTERNAL_lt_boogie |i#1| (|Seq#Length| (Lit |strs#0@@2|)))) (|ValueType.__default.ValidMessageBytestring#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |strs#0@@2|) |i#1|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |4526|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@2| |i#1|)))
)) (= (ValueType.__default.ValidMessageBytestrings (Lit |strs#0@@2|)) (forall ((|i#1@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@0|) (INTERNAL_lt_boogie |i#1@@0| (|Seq#Length| (Lit |strs#0@@2|)))) (ValueType.__default.ValidMessageBytestring ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |strs#0@@2|) |i#1@@0|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |4525|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@2| |i#1@@0|)))
)))))
 :qid |KeyTypesdfy.27:37|
 :weight 3
 :skolemid |4527|
 :pattern ( (ValueType.__default.ValidMessageBytestrings (Lit |strs#0@@2|)))
))))
(assert (= (type Tclass.LinearMaybe.__default) TyType))
(assert (= (Tag Tclass.LinearMaybe.__default) Tagclass.LinearMaybe.__default))
(assert (= (TagFamily Tclass.LinearMaybe.__default) tytagFamily$_default))
(assert (forall ((bx@@148 T@U) ) (!  (=> (and (= (type bx@@148) BoxType) ($IsBox bx@@148 Tclass.LinearMaybe.__default)) (and (= ($Box ($Unbox refType bx@@148)) bx@@148) ($Is ($Unbox refType bx@@148) Tclass.LinearMaybe.__default)))
 :qid |unknown.0:0|
 :skolemid |4528|
 :pattern ( ($IsBox bx@@148 Tclass.LinearMaybe.__default))
)))
(assert (forall (($o@@21 T@U) ) (!  (=> (= (type $o@@21) refType) (= ($Is $o@@21 Tclass.LinearMaybe.__default)  (or (= $o@@21 null) (= (dtype $o@@21) Tclass.LinearMaybe.__default))))
 :qid |unknown.0:0|
 :skolemid |4529|
 :pattern ( ($Is $o@@21 Tclass.LinearMaybe.__default))
)))
(assert (forall (($o@@22 T@U) ($h@@72 T@U) ) (!  (=> (and (= (type $o@@22) refType) (= (type $h@@72) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@72)  (or (= $o@@22 null) (U_2_bool (MapType1Select (MapType0Select $h@@72 $o@@22) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4530|
 :pattern ( ($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@72))
)))
(assert (forall ((arg0@@442 T@U) ) (! (= (type (|#$maybe| arg0@@442)) TyType)
 :qid |funType:#$maybe|
 :pattern ( (|#$maybe| arg0@@442))
)))
(assert  (=> true (forall ((LinearMaybe._default.has$A T@U) (|m#0| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.has$A) TyType) (= (type |m#0|) BoxType)) (or (|LinearMaybe.__default.has#canCall| LinearMaybe._default.has$A |m#0|) ($IsBox |m#0| (|#$maybe| LinearMaybe._default.has$A)))) true)
 :qid |unknown.0:0|
 :skolemid |4531|
 :pattern ( (LinearMaybe.__default.has LinearMaybe._default.has$A |m#0|))
))))
(assert (forall ((LinearMaybe._default.has$A@@0 T@U) (|m#0@@0| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.has$A@@0) TyType) (= (type |m#0@@0|) BoxType)) ($IsBox |m#0@@0| (|#$maybe| LinearMaybe._default.has$A@@0))) (= (|LinearMaybe.__default.has#requires| LinearMaybe._default.has$A@@0 |m#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |4532|
 :pattern ( (|LinearMaybe.__default.has#requires| LinearMaybe._default.has$A@@0 |m#0@@0|))
)))
(assert (forall ((arg0@@443 T@U) (arg1@@169 T@U) ) (! (= (type (LinearMaybe.__default.read arg0@@443 arg1@@169)) BoxType)
 :qid |funType:LinearMaybe.__default.read|
 :pattern ( (LinearMaybe.__default.read arg0@@443 arg1@@169))
)))
(assert  (=> true (forall ((LinearMaybe._default.read$A T@U) (|m#0@@1| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.read$A) TyType) (= (type |m#0@@1|) BoxType)) (or (|LinearMaybe.__default.read#canCall| LinearMaybe._default.read$A |m#0@@1|) ($IsBox |m#0@@1| (|#$maybe| LinearMaybe._default.read$A)))) ($IsBox (LinearMaybe.__default.read LinearMaybe._default.read$A |m#0@@1|) LinearMaybe._default.read$A))
 :qid |unknown.0:0|
 :skolemid |4533|
 :pattern ( (LinearMaybe.__default.read LinearMaybe._default.read$A |m#0@@1|))
))))
(assert (forall ((LinearMaybe._default.read$A@@0 T@U) (|m#0@@2| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.read$A@@0) TyType) (= (type |m#0@@2|) BoxType)) ($IsBox |m#0@@2| (|#$maybe| LinearMaybe._default.read$A@@0))) (= (|LinearMaybe.__default.read#requires| LinearMaybe._default.read$A@@0 |m#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |4534|
 :pattern ( (|LinearMaybe.__default.read#requires| LinearMaybe._default.read$A@@0 |m#0@@2|))
)))
(assert (forall ((arg0@@444 T@U) (arg1@@170 T@U) ) (! (= (type (LinearMaybe.__default.peek arg0@@444 arg1@@170)) BoxType)
 :qid |funType:LinearMaybe.__default.peek|
 :pattern ( (LinearMaybe.__default.peek arg0@@444 arg1@@170))
)))
(assert  (=> true (forall ((LinearMaybe._default.peek$A T@U) (|m#0@@3| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.peek$A) TyType) (= (type |m#0@@3|) BoxType)) (or (|LinearMaybe.__default.peek#canCall| LinearMaybe._default.peek$A |m#0@@3|) (and ($IsBox |m#0@@3| (|#$maybe| LinearMaybe._default.peek$A)) (LinearMaybe.__default.has LinearMaybe._default.peek$A |m#0@@3|)))) (and (= (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|) (LinearMaybe.__default.read LinearMaybe._default.peek$A |m#0@@3|)) ($IsBox (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|) LinearMaybe._default.peek$A)))
 :qid |unknown.0:0|
 :skolemid |4535|
 :pattern ( (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|))
))))
(assert (forall ((LinearMaybe._default.peek$A@@0 T@U) (|m#0@@4| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.peek$A@@0) TyType) (= (type |m#0@@4|) BoxType)) ($IsBox |m#0@@4| (|#$maybe| LinearMaybe._default.peek$A@@0))) (= (|LinearMaybe.__default.peek#requires| LinearMaybe._default.peek$A@@0 |m#0@@4|) (LinearMaybe.__default.has LinearMaybe._default.peek$A@@0 |m#0@@4|)))
 :qid |unknown.0:0|
 :skolemid |4536|
 :pattern ( (|LinearMaybe.__default.peek#requires| LinearMaybe._default.peek$A@@0 |m#0@@4|))
)))
(assert (forall ((arg0@@445 T@U) (arg1@@171 T@U) ) (! (= (type (LinearMaybe.__default.unwrap arg0@@445 arg1@@171)) BoxType)
 :qid |funType:LinearMaybe.__default.unwrap|
 :pattern ( (LinearMaybe.__default.unwrap arg0@@445 arg1@@171))
)))
(assert  (=> true (forall ((LinearMaybe._default.unwrap$A T@U) (|m#0@@5| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.unwrap$A) TyType) (= (type |m#0@@5|) BoxType)) (or (|LinearMaybe.__default.unwrap#canCall| LinearMaybe._default.unwrap$A |m#0@@5|) (and ($IsBox |m#0@@5| (|#$maybe| LinearMaybe._default.unwrap$A)) (LinearMaybe.__default.has LinearMaybe._default.unwrap$A |m#0@@5|)))) (and (= (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|) (LinearMaybe.__default.read LinearMaybe._default.unwrap$A |m#0@@5|)) ($IsBox (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|) LinearMaybe._default.unwrap$A)))
 :qid |unknown.0:0|
 :skolemid |4537|
 :pattern ( (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|))
))))
(assert (forall ((LinearMaybe._default.unwrap$A@@0 T@U) (|m#0@@6| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.unwrap$A@@0) TyType) (= (type |m#0@@6|) BoxType)) ($IsBox |m#0@@6| (|#$maybe| LinearMaybe._default.unwrap$A@@0))) (= (|LinearMaybe.__default.unwrap#requires| LinearMaybe._default.unwrap$A@@0 |m#0@@6|) (LinearMaybe.__default.has LinearMaybe._default.unwrap$A@@0 |m#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |4538|
 :pattern ( (|LinearMaybe.__default.unwrap#requires| LinearMaybe._default.unwrap$A@@0 |m#0@@6|))
)))
(assert (forall ((arg0@@446 T@U) (arg1@@172 T@U) (arg2@@88 T@U) ) (! (= (type (LinearMaybe.__default.give arg0@@446 arg1@@172 arg2@@88)) BoxType)
 :qid |funType:LinearMaybe.__default.give|
 :pattern ( (LinearMaybe.__default.give arg0@@446 arg1@@172 arg2@@88))
)))
(assert (forall ((LinearMaybe._default.give$A T@U) ($ly@@17 T@U) (|a#0@@1| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.give$A) TyType) (= (type $ly@@17) LayerTypeType)) (= (type |a#0@@1|) BoxType)) (= (LinearMaybe.__default.give LinearMaybe._default.give$A ($LS $ly@@17) |a#0@@1|) (LinearMaybe.__default.give LinearMaybe._default.give$A $ly@@17 |a#0@@1|)))
 :qid |unknown.0:0|
 :skolemid |4539|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A ($LS $ly@@17) |a#0@@1|))
)))
(assert (forall ((LinearMaybe._default.give$A@@0 T@U) ($ly@@18 T@U) (|a#0@@2| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.give$A@@0) TyType) (= (type $ly@@18) LayerTypeType)) (= (type |a#0@@2|) BoxType)) (= (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 $ly@@18 |a#0@@2|) (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 $LZ |a#0@@2|)))
 :qid |unknown.0:0|
 :skolemid |4540|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 (AsFuelBottom $ly@@18) |a#0@@2|))
)))
(assert  (=> true (forall ((LinearMaybe._default.give$A@@1 T@U) ($ly@@19 T@U) (|a#0@@3| T@U) ) (!  (=> (and (and (and (= (type LinearMaybe._default.give$A@@1) TyType) (= (type $ly@@19) LayerTypeType)) (= (type |a#0@@3|) BoxType)) (or (|LinearMaybe.__default.give#canCall| LinearMaybe._default.give$A@@1 |a#0@@3|) ($IsBox |a#0@@3| LinearMaybe._default.give$A@@1))) (and (and (and (LinearMaybe.__default.has LinearMaybe._default.give$A@@1 (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 |a#0@@3|)) (= (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 |a#0@@3|)) |a#0@@3|)) (forall ((|x#0@@1| T@U) ) (!  (=> (= (type |x#0@@1|) BoxType) (=> (and ($IsBox |x#0@@1| (|#$maybe| LinearMaybe._default.give$A@@1)) (and (LinearMaybe.__default.has LinearMaybe._default.give$A@@1 |x#0@@1|) (= |a#0@@3| (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 |x#0@@1|)))) (= (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 |a#0@@3|) |x#0@@1|)))
 :qid |LinearMaybesdfy.25:20|
 :skolemid |4541|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 |x#0@@1|)))
))) ($IsBox (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 |a#0@@3|) (|#$maybe| LinearMaybe._default.give$A@@1))))
 :qid |unknown.0:0|
 :skolemid |4542|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@19 |a#0@@3|))
))))
(assert (forall ((LinearMaybe._default.give$A@@2 T@U) ($ly@@20 T@U) (|a#0@@4| T@U) ) (!  (=> (and (and (and (= (type LinearMaybe._default.give$A@@2) TyType) (= (type $ly@@20) LayerTypeType)) (= (type |a#0@@4|) BoxType)) ($IsBox |a#0@@4| LinearMaybe._default.give$A@@2)) (= (|LinearMaybe.__default.give#requires| LinearMaybe._default.give$A@@2 $ly@@20 |a#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |4543|
 :pattern ( (|LinearMaybe.__default.give#requires| LinearMaybe._default.give$A@@2 $ly@@20 |a#0@@4|))
)))
(assert (forall ((arg0@@447 T@U) ) (! (= (type (LinearMaybe.__default.empty arg0@@447)) BoxType)
 :qid |funType:LinearMaybe.__default.empty|
 :pattern ( (LinearMaybe.__default.empty arg0@@447))
)))
(assert  (=> true (forall ((LinearMaybe._default.empty$A T@U) ) (!  (=> (and (= (type LinearMaybe._default.empty$A) TyType) true) (and (not (LinearMaybe.__default.has LinearMaybe._default.empty$A (LinearMaybe.__default.empty LinearMaybe._default.empty$A))) ($IsBox (LinearMaybe.__default.empty LinearMaybe._default.empty$A) (|#$maybe| LinearMaybe._default.empty$A))))
 :qid |unknown.0:0|
 :skolemid |4544|
 :pattern ( (LinearMaybe.__default.empty LinearMaybe._default.empty$A))
))))
(assert (forall ((LinearMaybe._default.empty$A@@0 T@U) ) (!  (=> (= (type LinearMaybe._default.empty$A@@0) TyType) (= (|LinearMaybe.__default.empty#requires| LinearMaybe._default.empty$A@@0) true))
 :qid |unknown.0:0|
 :skolemid |4545|
 :pattern ( (|LinearMaybe.__default.empty#requires| LinearMaybe._default.empty$A@@0))
)))
(assert (forall ((arg0@@448 T@U) (arg1@@173 T@U) ) (! (= (type (LinearMaybe.__default.discard arg0@@448 arg1@@173)) DatatypeTypeType)
 :qid |funType:LinearMaybe.__default.discard|
 :pattern ( (LinearMaybe.__default.discard arg0@@448 arg1@@173))
)))
(assert  (=> true (forall ((LinearMaybe._default.discard$A T@U) (|m#0@@7| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.discard$A) TyType) (= (type |m#0@@7|) BoxType)) (or (|LinearMaybe.__default.discard#canCall| LinearMaybe._default.discard$A |m#0@@7|) (and ($IsBox |m#0@@7| (|#$maybe| LinearMaybe._default.discard$A)) (not (LinearMaybe.__default.has LinearMaybe._default.discard$A |m#0@@7|))))) ($Is (LinearMaybe.__default.discard LinearMaybe._default.discard$A |m#0@@7|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |4546|
 :pattern ( (LinearMaybe.__default.discard LinearMaybe._default.discard$A |m#0@@7|))
))))
(assert (forall ((LinearMaybe._default.discard$A@@0 T@U) (|m#0@@8| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.discard$A@@0) TyType) (= (type |m#0@@8|) BoxType)) ($IsBox |m#0@@8| (|#$maybe| LinearMaybe._default.discard$A@@0))) (= (|LinearMaybe.__default.discard#requires| LinearMaybe._default.discard$A@@0 |m#0@@8|)  (not (LinearMaybe.__default.has LinearMaybe._default.discard$A@@0 |m#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |4547|
 :pattern ( (|LinearMaybe.__default.discard#requires| LinearMaybe._default.discard$A@@0 |m#0@@8|))
)))
(assert (forall ((arg0@@449 T@U) (arg1@@174 Bool) (arg2@@89 T@U) ) (! (= (type (LinearMaybe.__default.imagine arg0@@449 arg1@@174 arg2@@89)) BoxType)
 :qid |funType:LinearMaybe.__default.imagine|
 :pattern ( (LinearMaybe.__default.imagine arg0@@449 arg1@@174 arg2@@89))
)))
(assert  (=> true (forall ((LinearMaybe._default.imagine$A T@U) (|h#0| Bool) (|a#0@@5| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.imagine$A) TyType) (= (type |a#0@@5|) BoxType)) (or (|LinearMaybe.__default.imagine#canCall| LinearMaybe._default.imagine$A |h#0| |a#0@@5|) ($IsBox |a#0@@5| LinearMaybe._default.imagine$A))) (and (and (= (LinearMaybe.__default.has LinearMaybe._default.imagine$A (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|)) |h#0|) (= (LinearMaybe.__default.read LinearMaybe._default.imagine$A (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|)) |a#0@@5|)) ($IsBox (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|) (|#$maybe| LinearMaybe._default.imagine$A))))
 :qid |unknown.0:0|
 :skolemid |4548|
 :pattern ( (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|))
))))
(assert (forall ((LinearMaybe._default.imagine$A@@0 T@U) (|h#0@@0| Bool) (|a#0@@6| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.imagine$A@@0) TyType) (= (type |a#0@@6|) BoxType)) ($IsBox |a#0@@6| LinearMaybe._default.imagine$A@@0)) (= (|LinearMaybe.__default.imagine#requires| LinearMaybe._default.imagine$A@@0 |h#0@@0| |a#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |4549|
 :pattern ( (|LinearMaybe.__default.imagine#requires| LinearMaybe._default.imagine$A@@0 |h#0@@0| |a#0@@6|))
)))
(assert (= (type Tclass.LinearExtern.__default) TyType))
(assert (= (Tag Tclass.LinearExtern.__default) Tagclass.LinearExtern.__default))
(assert (= (TagFamily Tclass.LinearExtern.__default) tytagFamily$_default))
(assert (forall ((bx@@149 T@U) ) (!  (=> (and (= (type bx@@149) BoxType) ($IsBox bx@@149 Tclass.LinearExtern.__default)) (and (= ($Box ($Unbox refType bx@@149)) bx@@149) ($Is ($Unbox refType bx@@149) Tclass.LinearExtern.__default)))
 :qid |unknown.0:0|
 :skolemid |4550|
 :pattern ( ($IsBox bx@@149 Tclass.LinearExtern.__default))
)))
(assert (forall (($o@@23 T@U) ) (!  (=> (= (type $o@@23) refType) (= ($Is $o@@23 Tclass.LinearExtern.__default)  (or (= $o@@23 null) (= (dtype $o@@23) Tclass.LinearExtern.__default))))
 :qid |unknown.0:0|
 :skolemid |4551|
 :pattern ( ($Is $o@@23 Tclass.LinearExtern.__default))
)))
(assert (forall (($o@@24 T@U) ($h@@73 T@U) ) (!  (=> (and (= (type $o@@24) refType) (= (type $h@@73) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@73)  (or (= $o@@24 null) (U_2_bool (MapType1Select (MapType0Select $h@@73 $o@@24) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4552|
 :pattern ( ($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@73))
)))
(assert (forall ((arg0@@450 T@U) (arg1@@175 T@U) (arg2@@90 Int) ) (! (= (type (LinearExtern.__default.seq_get arg0@@450 arg1@@175 arg2@@90)) BoxType)
 :qid |funType:LinearExtern.__default.seq_get|
 :pattern ( (LinearExtern.__default.seq_get arg0@@450 arg1@@175 arg2@@90))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_get$A T@U) (|s#0@@7| T@U) (|i#0@@27| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_get$A) TyType) (= (type |s#0@@7|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_get#canCall| LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@27|) (and (and ($Is |s#0@@7| (TSeq LinearSequence_s._default.seq_get$A)) (and (INTERNAL_le_boogie 0 |i#0@@27|) (INTERNAL_lt_boogie |i#0@@27| 18446744073709551616))) (INTERNAL_lt_boogie |i#0@@27| (|Seq#Length| |s#0@@7|))))) (and (= (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@27|) (|Seq#Index| |s#0@@7| |i#0@@27|)) ($IsBox (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@27|) LinearSequence_s._default.seq_get$A)))
 :qid |unknown.0:0|
 :skolemid |4553|
 :pattern ( (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@27|))
))))
(assert (forall ((LinearSequence_s._default.seq_get$A@@0 T@U) (|s#0@@8| T@U) (|i#0@@28| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_get$A@@0) TyType) (= (type |s#0@@8|) (SeqType BoxType))) (and ($Is |s#0@@8| (TSeq LinearSequence_s._default.seq_get$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@28|) (INTERNAL_lt_boogie |i#0@@28| 18446744073709551616)))) (= (|LinearExtern.__default.seq_get#requires| LinearSequence_s._default.seq_get$A@@0 |s#0@@8| |i#0@@28|) (INTERNAL_lt_boogie |i#0@@28| (|Seq#Length| |s#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |4554|
 :pattern ( (|LinearExtern.__default.seq_get#requires| LinearSequence_s._default.seq_get$A@@0 |s#0@@8| |i#0@@28|))
)))
(assert (forall ((arg0@@451 T@U) (arg1@@176 T@U) (arg2@@91 Int) (arg3@@48 T@U) ) (! (= (type (LinearExtern.__default.seq_set arg0@@451 arg1@@176 arg2@@91 arg3@@48)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_set|
 :pattern ( (LinearExtern.__default.seq_set arg0@@451 arg1@@176 arg2@@91 arg3@@48))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_set$A T@U) (|s1#0| T@U) (|i#0@@29| Int) (|a#0@@7| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.seq_set$A) TyType) (= (type |s1#0|) (SeqType BoxType))) (= (type |a#0@@7|) BoxType)) (or (|LinearExtern.__default.seq_set#canCall| LinearSequence_s._default.seq_set$A |s1#0| |i#0@@29| |a#0@@7|) (and (and (and ($Is |s1#0| (TSeq LinearSequence_s._default.seq_set$A)) (and (INTERNAL_le_boogie 0 |i#0@@29|) (INTERNAL_lt_boogie |i#0@@29| 18446744073709551616))) ($IsBox |a#0@@7| LinearSequence_s._default.seq_set$A)) (INTERNAL_lt_boogie |i#0@@29| (|Seq#Length| |s1#0|))))) (and (|Seq#Equal| (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@29| |a#0@@7|) (|Seq#Update| |s1#0| |i#0@@29| |a#0@@7|)) ($Is (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@29| |a#0@@7|) (TSeq LinearSequence_s._default.seq_set$A))))
 :qid |unknown.0:0|
 :skolemid |4555|
 :pattern ( (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@29| |a#0@@7|))
))))
(assert (forall ((LinearSequence_s._default.seq_set$A@@0 T@U) (|s1#0@@0| T@U) (|i#0@@30| Int) (|a#0@@8| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.seq_set$A@@0) TyType) (= (type |s1#0@@0|) (SeqType BoxType))) (= (type |a#0@@8|) BoxType)) (and (and ($Is |s1#0@@0| (TSeq LinearSequence_s._default.seq_set$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@30|) (INTERNAL_lt_boogie |i#0@@30| 18446744073709551616))) ($IsBox |a#0@@8| LinearSequence_s._default.seq_set$A@@0))) (= (|LinearExtern.__default.seq_set#requires| LinearSequence_s._default.seq_set$A@@0 |s1#0@@0| |i#0@@30| |a#0@@8|) (INTERNAL_lt_boogie |i#0@@30| (|Seq#Length| |s1#0@@0|))))
 :qid |unknown.0:0|
 :skolemid |4556|
 :pattern ( (|LinearExtern.__default.seq_set#requires| LinearSequence_s._default.seq_set$A@@0 |s1#0@@0| |i#0@@30| |a#0@@8|))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_length$A T@U) (|s#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_length$A) TyType) (= (type |s#0@@9|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_length#canCall| LinearSequence_s._default.seq_length$A |s#0@@9|) (and ($Is |s#0@@9| (TSeq LinearSequence_s._default.seq_length$A)) (INTERNAL_le_boogie (|Seq#Length| |s#0@@9|) 18446744073709551615)))) (and (= (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|) (|Seq#Length| |s#0@@9|)) (and (INTERNAL_le_boogie 0 (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|)) (INTERNAL_lt_boogie (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |4557|
 :pattern ( (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|))
))))
(assert (forall ((LinearSequence_s._default.seq_length$A@@0 T@U) (|s#0@@10| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_length$A@@0) TyType) (= (type |s#0@@10|) (SeqType BoxType))) ($Is |s#0@@10| (TSeq LinearSequence_s._default.seq_length$A@@0))) (= (|LinearExtern.__default.seq_length#requires| LinearSequence_s._default.seq_length$A@@0 |s#0@@10|) (INTERNAL_le_boogie (|Seq#Length| |s#0@@10|) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |4558|
 :pattern ( (|LinearExtern.__default.seq_length#requires| LinearSequence_s._default.seq_length$A@@0 |s#0@@10|))
)))
(assert (forall ((arg0@@452 T@U) ) (! (= (type (LinearExtern.__default.seq_empty arg0@@452)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_empty|
 :pattern ( (LinearExtern.__default.seq_empty arg0@@452))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_empty$A T@U) ) (!  (=> (and (= (type LinearSequence_s._default.seq_empty$A) TyType) true) (and (= (|Seq#Length| (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A)) (LitInt 0)) ($Is (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A) (TSeq LinearSequence_s._default.seq_empty$A))))
 :qid |unknown.0:0|
 :skolemid |4559|
 :pattern ( (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A))
))))
(assert (forall ((LinearSequence_s._default.seq_empty$A@@0 T@U) ) (!  (=> (= (type LinearSequence_s._default.seq_empty$A@@0) TyType) (= (|LinearExtern.__default.seq_empty#requires| LinearSequence_s._default.seq_empty$A@@0) true))
 :qid |unknown.0:0|
 :skolemid |4560|
 :pattern ( (|LinearExtern.__default.seq_empty#requires| LinearSequence_s._default.seq_empty$A@@0))
)))
(assert (forall ((arg0@@453 T@U) (arg1@@177 Int) (arg2@@92 T@U) ) (! (= (type (LinearExtern.__default.seq_alloc arg0@@453 arg1@@177 arg2@@92)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_alloc|
 :pattern ( (LinearExtern.__default.seq_alloc arg0@@453 arg1@@177 arg2@@92))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_alloc$A T@U) (|length#0| Int) (|a#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_alloc$A) TyType) (= (type |a#0@@9|) BoxType)) (or (|LinearExtern.__default.seq_alloc#canCall| LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) (and (and (INTERNAL_le_boogie 0 |length#0|) (INTERNAL_lt_boogie |length#0| 18446744073709551616)) ($IsBox |a#0@@9| LinearSequence_s._default.seq_alloc$A)))) (and (and (= (|Seq#Length| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|)) |length#0|) (forall ((|i#0@@31| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@31|) (INTERNAL_lt_boogie |i#0@@31| (|Seq#Length| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|)))) (= (|Seq#Index| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) |i#0@@31|) |a#0@@9|)))
 :qid |LinearSequencesdfy.32:20|
 :skolemid |4561|
 :pattern ( (|Seq#Index| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) |i#0@@31|))
))) ($Is (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) (TSeq LinearSequence_s._default.seq_alloc$A))))
 :qid |unknown.0:0|
 :skolemid |4562|
 :pattern ( (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|))
))))
(assert (forall ((LinearSequence_s._default.seq_alloc$A@@0 T@U) (|length#0@@0| Int) (|a#0@@10| T@U) ) (!  (=> (and (= (type LinearSequence_s._default.seq_alloc$A@@0) TyType) (= (type |a#0@@10|) BoxType)) (=> (and (and (INTERNAL_le_boogie 0 |length#0@@0|) (INTERNAL_lt_boogie |length#0@@0| 18446744073709551616)) ($IsBox |a#0@@10| LinearSequence_s._default.seq_alloc$A@@0)) (= (|LinearExtern.__default.seq_alloc#requires| LinearSequence_s._default.seq_alloc$A@@0 |length#0@@0| |a#0@@10|) true)))
 :qid |unknown.0:0|
 :skolemid |4563|
 :pattern ( (|LinearExtern.__default.seq_alloc#requires| LinearSequence_s._default.seq_alloc$A@@0 |length#0@@0| |a#0@@10|))
)))
(assert (forall ((arg0@@454 T@U) (arg1@@178 T@U) ) (! (= (type (LinearExtern.__default.seq_free arg0@@454 arg1@@178)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.seq_free|
 :pattern ( (LinearExtern.__default.seq_free arg0@@454 arg1@@178))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_free$A T@U) (|s#0@@11| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_free$A) TyType) (= (type |s#0@@11|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_free#canCall| LinearSequence_s._default.seq_free$A |s#0@@11|) ($Is |s#0@@11| (TSeq LinearSequence_s._default.seq_free$A)))) ($Is (LinearExtern.__default.seq_free LinearSequence_s._default.seq_free$A |s#0@@11|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |4564|
 :pattern ( (LinearExtern.__default.seq_free LinearSequence_s._default.seq_free$A |s#0@@11|))
))))
(assert (forall ((LinearSequence_s._default.seq_free$A@@0 T@U) (|s#0@@12| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_free$A@@0) TyType) (= (type |s#0@@12|) (SeqType BoxType))) ($Is |s#0@@12| (TSeq LinearSequence_s._default.seq_free$A@@0))) (= (|LinearExtern.__default.seq_free#requires| LinearSequence_s._default.seq_free$A@@0 |s#0@@12|) true))
 :qid |unknown.0:0|
 :skolemid |4565|
 :pattern ( (|LinearExtern.__default.seq_free#requires| LinearSequence_s._default.seq_free$A@@0 |s#0@@12|))
)))
(assert (forall ((arg0@@455 T@U) (arg1@@179 T@U) ) (! (= (type (LinearExtern.__default.seq_unleash arg0@@455 arg1@@179)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_unleash|
 :pattern ( (LinearExtern.__default.seq_unleash arg0@@455 arg1@@179))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_unleash$A T@U) (|s1#0@@1| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_unleash$A) TyType) (= (type |s1#0@@1|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_unleash#canCall| LinearSequence_s._default.seq_unleash$A |s1#0@@1|) ($Is |s1#0@@1| (TSeq LinearSequence_s._default.seq_unleash$A)))) (and (|Seq#Equal| |s1#0@@1| (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|)) ($Is (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|) (TSeq LinearSequence_s._default.seq_unleash$A))))
 :qid |unknown.0:0|
 :skolemid |4566|
 :pattern ( (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.seq_unleash$A@@0 T@U) (|s1#0@@2| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_unleash$A@@0) TyType) (= (type |s1#0@@2|) (SeqType BoxType))) ($Is |s1#0@@2| (TSeq LinearSequence_s._default.seq_unleash$A@@0))) (= (|LinearExtern.__default.seq_unleash#requires| LinearSequence_s._default.seq_unleash$A@@0 |s1#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |4567|
 :pattern ( (|LinearExtern.__default.seq_unleash#requires| LinearSequence_s._default.seq_unleash$A@@0 |s1#0@@2|))
)))
(assert  (and (forall ((arg0@@456 T@U) (arg1@@180 T@U) ) (! (= (type (LinearExtern.__default.lseqs__raw arg0@@456 arg1@@180)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.lseqs__raw|
 :pattern ( (LinearExtern.__default.lseqs__raw arg0@@456 arg1@@180))
)) (forall ((arg0@@457 T@U) ) (! (= (type (|#$lseq| arg0@@457)) TyType)
 :qid |funType:#$lseq|
 :pattern ( (|#$lseq| arg0@@457))
))))
(assert  (=> true (forall ((LinearSequence_s._default.lseqs_raw$A T@U) (|l#0| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseqs_raw$A) TyType) (= (type |l#0|) BoxType)) (or (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseqs_raw$A |l#0|) ($IsBox |l#0| (|#$lseq| LinearSequence_s._default.lseqs_raw$A)))) (and (_System.__default.rank__is__less__than (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A)) (|#$lseq| LinearSequence_s._default.lseqs_raw$A) ($Box (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|)) |l#0|) ($Is (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|) (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A)))))
 :qid |unknown.0:0|
 :skolemid |4568|
 :pattern ( (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|))
))))
(assert (forall ((LinearSequence_s._default.lseqs_raw$A@@0 T@U) (|l#0@@0| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseqs_raw$A@@0) TyType) (= (type |l#0@@0|) BoxType)) ($IsBox |l#0@@0| (|#$lseq| LinearSequence_s._default.lseqs_raw$A@@0))) (= (|LinearExtern.__default.lseqs__raw#requires| LinearSequence_s._default.lseqs_raw$A@@0 |l#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |4569|
 :pattern ( (|LinearExtern.__default.lseqs__raw#requires| LinearSequence_s._default.lseqs_raw$A@@0 |l#0@@0|))
)))
(assert (forall ((arg0@@458 T@U) (arg1@@181 T@U) ) (! (= (type (LinearExtern.__default.lseq__has arg0@@458 arg1@@181)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.lseq__has|
 :pattern ( (LinearExtern.__default.lseq__has arg0@@458 arg1@@181))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A T@U) (|l#0@@1| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_has$A) TyType) (= (type |l#0@@1|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A |l#0@@1|) ($IsBox |l#0@@1| (|#$lseq| LinearSequence_s._default.lseq_has$A)))) (and (= (|Seq#Length| (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|)) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A |l#0@@1|))) ($Is (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|) (TSeq TBool))))
 :qid |unknown.0:0|
 :skolemid |4570|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.lseq_has$A@@0 T@U) ($Heap@@8 T@U) (|l#0@@2| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@0) TyType) (= (type $Heap@@8) (MapType0Type refType MapType1Type))) (= (type |l#0@@2|) BoxType)) (and ($IsGoodHeap $Heap@@8) ($IsBox |l#0@@2| (|#$lseq| LinearSequence_s._default.lseq_has$A@@0)))) (= (|LinearExtern.__default.lseq__has#requires| LinearSequence_s._default.lseq_has$A@@0 |l#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |4571|
 :pattern ( (|LinearExtern.__default.lseq__has#requires| LinearSequence_s._default.lseq_has$A@@0 |l#0@@2|) ($IsGoodHeap $Heap@@8))
)))
(assert (forall ((arg0@@459 T@U) (arg1@@182 T@U) ) (! (= (type (|lambda#139| arg0@@459 arg1@@182)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#139|
 :pattern ( (|lambda#139| arg0@@459 arg1@@182))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A@@1 T@U) ($Heap@@9 T@U) (|l#0@@3| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@1) TyType) (= (type $Heap@@9) (MapType0Type refType MapType1Type))) (= (type |l#0@@3|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (and ($IsGoodHeap $Heap@@9) ($IsBox |l#0@@3| (|#$lseq| LinearSequence_s._default.lseq_has$A@@1))))) (and (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (forall ((|$l#1#i#0@@0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@0|) (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (=> (and (INTERNAL_le_boogie 0 |$l#1#i#0@@0|) (INTERNAL_lt_boogie |$l#1#i#0@@0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)))) (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (|LinearMaybe.__default.has#canCall| LinearSequence_s._default.lseq_has$A@@1 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) |$l#1#i#0@@0|)))))
 :qid |unknown.0:0|
 :skolemid |4572|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0@@0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@0|)
))) (= (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (|Seq#Create| TBool $Heap@@9 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#139| LinearSequence_s._default.lseq_has$A@@1 (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (|lambda#32| TInt 0 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :skolemid |4573|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) ($IsGoodHeap $Heap@@9))
))))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A@@2 T@U) ($Heap@@10 T@U) (|l#0@@4| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@2) TyType) (= (type $Heap@@10) (MapType0Type refType MapType1Type))) (= (type |l#0@@4|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (and ($IsGoodHeap $Heap@@10) ($IsBox |l#0@@4| (|#$lseq| LinearSequence_s._default.lseq_has$A@@2))))) (and (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (forall ((|$l#3#i#0@@0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@0|) (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (=> (and (INTERNAL_le_boogie 0 |$l#3#i#0@@0|) (INTERNAL_lt_boogie |$l#3#i#0@@0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))))) (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (|LinearMaybe.__default.has#canCall| LinearSequence_s._default.lseq_has$A@@2 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) |$l#3#i#0@@0|)))))
 :qid |unknown.0:0|
 :skolemid |4574|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0@@0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@0|)
))) (= (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (|Seq#Create| TBool $Heap@@10 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#139| LinearSequence_s._default.lseq_has$A@@2 (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (|lambda#32| TInt 0 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4575|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) ($IsGoodHeap $Heap@@10))
))))
(assert (forall ((arg0@@460 T@U) (arg1@@183 T@U) ) (! (= (type (LinearExtern.__default.imagine__lseq__raw arg0@@460 arg1@@183)) BoxType)
 :qid |funType:LinearExtern.__default.imagine__lseq__raw|
 :pattern ( (LinearExtern.__default.imagine__lseq__raw arg0@@460 arg1@@183))
)))
(assert  (=> true (forall ((LinearSequence_s._default.imagine_lseq_raw$A T@U) (|s#0@@13| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.imagine_lseq_raw$A) TyType) (= (type |s#0@@13|) (SeqType BoxType))) (or (|LinearExtern.__default.imagine__lseq__raw#canCall| LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|) ($Is |s#0@@13| (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A))))) (and (|Seq#Equal| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.imagine_lseq_raw$A (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|)) |s#0@@13|) ($IsBox (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|) (|#$lseq| LinearSequence_s._default.imagine_lseq_raw$A))))
 :qid |unknown.0:0|
 :skolemid |4576|
 :pattern ( (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|))
))))
(assert (forall ((LinearSequence_s._default.imagine_lseq_raw$A@@0 T@U) (|s#0@@14| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.imagine_lseq_raw$A@@0) TyType) (= (type |s#0@@14|) (SeqType BoxType))) ($Is |s#0@@14| (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A@@0)))) (= (|LinearExtern.__default.imagine__lseq__raw#requires| LinearSequence_s._default.imagine_lseq_raw$A@@0 |s#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |4577|
 :pattern ( (|LinearExtern.__default.imagine__lseq__raw#requires| LinearSequence_s._default.imagine_lseq_raw$A@@0 |s#0@@14|))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_length_raw$A T@U) (|s#0@@15| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_length_raw$A) TyType) (= (type |s#0@@15|) BoxType)) (or (|LinearExtern.__default.lseq_length_raw#canCall| LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) (and ($IsBox |s#0@@15| (|#$lseq| LinearSequence_s._default.lseq_length_raw$A)) (INTERNAL_le_boogie (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|)) 18446744073709551615)))) (and (= (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|))) (and (INTERNAL_le_boogie 0 (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|)) (INTERNAL_lt_boogie (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |4578|
 :pattern ( (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|))
))))
(assert (forall ((LinearSequence_s._default.lseq_length_raw$A@@0 T@U) (|s#0@@16| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_length_raw$A@@0) TyType) (= (type |s#0@@16|) BoxType)) ($IsBox |s#0@@16| (|#$lseq| LinearSequence_s._default.lseq_length_raw$A@@0))) (= (|LinearExtern.__default.lseq_length_raw#requires| LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|) (INTERNAL_le_boogie (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|)) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |4579|
 :pattern ( (|LinearExtern.__default.lseq_length_raw#requires| LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|))
)))
(assert (forall ((arg0@@461 T@U) (arg1@@184 Int) ) (! (= (type (LinearExtern.__default.lseq_alloc_raw arg0@@461 arg1@@184)) BoxType)
 :qid |funType:LinearExtern.__default.lseq_alloc_raw|
 :pattern ( (LinearExtern.__default.lseq_alloc_raw arg0@@461 arg1@@184))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_alloc_raw$A T@U) (|length#0@@1| Int) ) (!  (=> (and (= (type LinearSequence_s._default.lseq_alloc_raw$A) TyType) (or (|LinearExtern.__default.lseq_alloc_raw#canCall| LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|) (and (INTERNAL_le_boogie 0 |length#0@@1|) (INTERNAL_lt_boogie |length#0@@1| 18446744073709551616)))) (and (and (= (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|))) |length#0@@1|) (forall ((|i#0@@32| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@32|) (INTERNAL_lt_boogie |i#0@@32| |length#0@@1|)) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_alloc_raw$A (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|)) |i#0@@32|))))
 :qid |LinearSequencesdfy.92:22|
 :skolemid |4580|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|)) |i#0@@32|))
))) ($IsBox (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|) (|#$lseq| LinearSequence_s._default.lseq_alloc_raw$A))))
 :qid |unknown.0:0|
 :skolemid |4581|
 :pattern ( (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.lseq_alloc_raw$A@@0 T@U) (|length#0@@2| Int) ) (!  (=> (= (type LinearSequence_s._default.lseq_alloc_raw$A@@0) TyType) (=> (and (INTERNAL_le_boogie 0 |length#0@@2|) (INTERNAL_lt_boogie |length#0@@2| 18446744073709551616)) (= (|LinearExtern.__default.lseq_alloc_raw#requires| LinearSequence_s._default.lseq_alloc_raw$A@@0 |length#0@@2|) true)))
 :qid |unknown.0:0|
 :skolemid |4582|
 :pattern ( (|LinearExtern.__default.lseq_alloc_raw#requires| LinearSequence_s._default.lseq_alloc_raw$A@@0 |length#0@@2|))
)))
(assert (forall ((arg0@@462 T@U) (arg1@@185 T@U) ) (! (= (type (LinearExtern.__default.lseq_free_raw arg0@@462 arg1@@185)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.lseq_free_raw|
 :pattern ( (LinearExtern.__default.lseq_free_raw arg0@@462 arg1@@185))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_free_raw$A T@U) (|s#0@@17| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_free_raw$A) TyType) (= (type |s#0@@17|) BoxType)) (or (|LinearExtern.__default.lseq_free_raw#canCall| LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) (and ($IsBox |s#0@@17| (|#$lseq| LinearSequence_s._default.lseq_free_raw$A)) (forall ((|i#0@@33| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@33|) (INTERNAL_lt_boogie |i#0@@33| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|)))) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_free_raw$A (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) |i#0@@33|))))
 :qid |LinearSequencesdfy.95:23|
 :skolemid |4583|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) |i#0@@33|))
))))) ($Is (LinearExtern.__default.lseq_free_raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |4584|
 :pattern ( (LinearExtern.__default.lseq_free_raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|))
))))
(assert (forall ((LinearSequence_s._default.lseq_free_raw$A@@0 T@U) (|s#0@@18| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_free_raw$A@@0) TyType) (= (type |s#0@@18|) BoxType)) ($IsBox |s#0@@18| (|#$lseq| LinearSequence_s._default.lseq_free_raw$A@@0))) (= (|LinearExtern.__default.lseq_free_raw#requires| LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) (forall ((|i#1@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@1|) (INTERNAL_lt_boogie |i#1@@1| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|)))) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_free_raw$A@@0 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) |i#1@@1|))))
 :qid |LinearSequencesdfy.95:23|
 :skolemid |4585|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) |i#1@@1|))
))))
 :qid |unknown.0:0|
 :skolemid |4586|
 :pattern ( (|LinearExtern.__default.lseq_free_raw#requires| LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|))
)))
(assert (forall ((arg0@@463 T@U) (arg1@@186 T@U) (arg2@@93 Int) (arg3@@49 T@U) ) (! (= (type (LinearExtern.__default.lseq_swap_raw_fun arg0@@463 arg1@@186 arg2@@93 arg3@@49)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.lseq_swap_raw_fun|
 :pattern ( (LinearExtern.__default.lseq_swap_raw_fun arg0@@463 arg1@@186 arg2@@93 arg3@@49))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A T@U) (|s1#0@@3| T@U) (|i#0@@34| Int) (|a1#0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A) TyType) (= (type |s1#0@@3|) BoxType)) (= (type |a1#0|) BoxType)) (or (|LinearExtern.__default.lseq_swap_raw_fun#canCall| LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@34| |a1#0|) (and (and (and ($IsBox |s1#0@@3| (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A)) (and (INTERNAL_le_boogie 0 |i#0@@34|) (INTERNAL_lt_boogie |i#0@@34| 18446744073709551616))) ($IsBox |a1#0| (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A))) (INTERNAL_lt_boogie |i#0@@34| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|)))))) (and (and (= (_System.Tuple2OLL._1 (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@34| |a1#0|)) (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|) |i#0@@34|)) (|Seq#Equal| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A (_System.Tuple2OLL._0 (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@34| |a1#0|))) (|Seq#Update| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|) |i#0@@34| |a1#0|))) ($Is (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@34| |a1#0|) (Tclass._System.Tuple2OLL (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A) (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A)))))
 :qid |unknown.0:0|
 :skolemid |4587|
 :pattern ( (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@34| |a1#0|))
))))
(assert (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A@@0 T@U) (|s1#0@@4| T@U) (|i#0@@35| Int) (|a1#0@@0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A@@0) TyType) (= (type |s1#0@@4|) BoxType)) (= (type |a1#0@@0|) BoxType)) (and (and ($IsBox |s1#0@@4| (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@35|) (INTERNAL_lt_boogie |i#0@@35| 18446744073709551616))) ($IsBox |a1#0@@0| (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A@@0)))) (= (|LinearExtern.__default.lseq_swap_raw_fun#requires| LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4| |i#0@@35| |a1#0@@0|) (INTERNAL_lt_boogie |i#0@@35| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4|)))))
 :qid |unknown.0:0|
 :skolemid |4588|
 :pattern ( (|LinearExtern.__default.lseq_swap_raw_fun#requires| LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4| |i#0@@35| |a1#0@@0|))
)))
(assert (forall ((arg0@@464 T@U) (arg1@@187 T@U) (arg2@@94 Int) ) (! (= (type (LinearExtern.__default.lseq_share_raw arg0@@464 arg1@@187 arg2@@94)) BoxType)
 :qid |funType:LinearExtern.__default.lseq_share_raw|
 :pattern ( (LinearExtern.__default.lseq_share_raw arg0@@464 arg1@@187 arg2@@94))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_share_raw$A T@U) (|s#0@@19| T@U) (|i#0@@36| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_share_raw$A) TyType) (= (type |s#0@@19|) BoxType)) (or (|LinearExtern.__default.lseq_share_raw#canCall| LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@36|) (and (and ($IsBox |s#0@@19| (|#$lseq| LinearSequence_s._default.lseq_share_raw$A)) (and (INTERNAL_le_boogie 0 |i#0@@36|) (INTERNAL_lt_boogie |i#0@@36| 18446744073709551616))) (INTERNAL_lt_boogie |i#0@@36| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19|)))))) (and (= (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@36|) (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19|) |i#0@@36|)) ($IsBox (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@36|) (|#$maybe| LinearSequence_s._default.lseq_share_raw$A))))
 :qid |unknown.0:0|
 :skolemid |4589|
 :pattern ( (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@36|))
))))
(assert (forall ((LinearSequence_s._default.lseq_share_raw$A@@0 T@U) (|s#0@@20| T@U) (|i#0@@37| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_share_raw$A@@0) TyType) (= (type |s#0@@20|) BoxType)) (and ($IsBox |s#0@@20| (|#$lseq| LinearSequence_s._default.lseq_share_raw$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@37|) (INTERNAL_lt_boogie |i#0@@37| 18446744073709551616)))) (= (|LinearExtern.__default.lseq_share_raw#requires| LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20| |i#0@@37|) (INTERNAL_lt_boogie |i#0@@37| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20|)))))
 :qid |unknown.0:0|
 :skolemid |4590|
 :pattern ( (|LinearExtern.__default.lseq_share_raw#requires| LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20| |i#0@@37|))
)))
(assert (= (type |#ValueMessage.Delta.NoDelta|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#ValueMessage.Delta.NoDelta|) |##ValueMessage.Delta.NoDelta|))
(assert (forall ((d@@23 T@U) ) (!  (=> (= (type d@@23) DatatypeTypeType) (= (ValueMessage.Delta.NoDelta_q d@@23) (= (DatatypeCtorId d@@23) |##ValueMessage.Delta.NoDelta|)))
 :qid |unknown.0:0|
 :skolemid |4591|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@23))
)))
(assert (forall ((d@@24 T@U) ) (!  (=> (and (= (type d@@24) DatatypeTypeType) (ValueMessage.Delta.NoDelta_q d@@24)) (= d@@24 |#ValueMessage.Delta.NoDelta|))
 :qid |unknown.0:0|
 :skolemid |4592|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@24))
)))
(assert (= (type Tclass.ValueMessage.Delta) TyType))
(assert (= (Tag Tclass.ValueMessage.Delta) Tagclass.ValueMessage.Delta))
(assert (= (TagFamily Tclass.ValueMessage.Delta) tytagFamily$Delta))
(assert (forall ((bx@@150 T@U) ) (!  (=> (and (= (type bx@@150) BoxType) ($IsBox bx@@150 Tclass.ValueMessage.Delta)) (and (= ($Box ($Unbox DatatypeTypeType bx@@150)) bx@@150) ($Is ($Unbox DatatypeTypeType bx@@150) Tclass.ValueMessage.Delta)))
 :qid |unknown.0:0|
 :skolemid |4593|
 :pattern ( ($IsBox bx@@150 Tclass.ValueMessage.Delta))
)))
(assert ($Is |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta))
(assert (forall (($h@@74 T@U) ) (!  (=> (and (= (type $h@@74) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@74)) ($IsAlloc |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta $h@@74))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |4594|
 :pattern ( ($IsAlloc |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta $h@@74))
)))
(assert (= |#ValueMessage.Delta.NoDelta| (Lit |#ValueMessage.Delta.NoDelta|)))
(assert (forall ((d@@25 T@U) ) (!  (=> (and (= (type d@@25) DatatypeTypeType) (|$IsA#ValueMessage.Delta| d@@25)) (ValueMessage.Delta.NoDelta_q d@@25))
 :qid |unknown.0:0|
 :skolemid |4595|
 :pattern ( (|$IsA#ValueMessage.Delta| d@@25))
)))
(assert (forall ((d@@26 T@U) ) (!  (=> (and (= (type d@@26) DatatypeTypeType) ($Is d@@26 Tclass.ValueMessage.Delta)) (ValueMessage.Delta.NoDelta_q d@@26))
 :qid |unknown.0:0|
 :skolemid |4596|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@26) ($Is d@@26 Tclass.ValueMessage.Delta))
)))
(assert (forall ((a@@121 T@U) (b@@70 T@U) ) (!  (=> (and (and (= (type a@@121) DatatypeTypeType) (= (type b@@70) DatatypeTypeType)) true) (= (|ValueMessage.Delta#Equal| a@@121 b@@70) true))
 :qid |unknown.0:0|
 :skolemid |4597|
 :pattern ( (|ValueMessage.Delta#Equal| a@@121 b@@70))
)))
(assert (forall ((a@@122 T@U) (b@@71 T@U) ) (!  (=> (and (= (type a@@122) DatatypeTypeType) (= (type b@@71) DatatypeTypeType)) (= (|ValueMessage.Delta#Equal| a@@122 b@@71) (= a@@122 b@@71)))
 :qid |unknown.0:0|
 :skolemid |4598|
 :pattern ( (|ValueMessage.Delta#Equal| a@@122 b@@71))
)))
(assert (= (type Tclass.ValueMessage.__default) TyType))
(assert (= (Tag Tclass.ValueMessage.__default) Tagclass.ValueMessage.__default))
(assert (= (TagFamily Tclass.ValueMessage.__default) tytagFamily$_default))
(assert (forall ((bx@@151 T@U) ) (!  (=> (and (= (type bx@@151) BoxType) ($IsBox bx@@151 Tclass.ValueMessage.__default)) (and (= ($Box ($Unbox refType bx@@151)) bx@@151) ($Is ($Unbox refType bx@@151) Tclass.ValueMessage.__default)))
 :qid |unknown.0:0|
 :skolemid |4599|
 :pattern ( ($IsBox bx@@151 Tclass.ValueMessage.__default))
)))
(assert (forall (($o@@25 T@U) ) (!  (=> (= (type $o@@25) refType) (= ($Is $o@@25 Tclass.ValueMessage.__default)  (or (= $o@@25 null) (= (dtype $o@@25) Tclass.ValueMessage.__default))))
 :qid |unknown.0:0|
 :skolemid |4600|
 :pattern ( ($Is $o@@25 Tclass.ValueMessage.__default))
)))
(assert (forall (($o@@26 T@U) ($h@@75 T@U) ) (!  (=> (and (= (type $o@@26) refType) (= (type $h@@75) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@75)  (or (= $o@@26 null) (U_2_bool (MapType1Select (MapType0Select $h@@75 $o@@26) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4601|
 :pattern ( ($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@75))
)))
(assert (= (type ValueMessage.__default.NopDelta) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.NopDelta Tclass.ValueMessage.Delta))))
(assert (= |ValueMessage.__default.NopDelta#requires| true))
(assert  (=> true (=> true (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert  (=> true (=> true (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert (= (type ValueMessage.__default.DefaultValue) (SeqType BoxType)))
(assert  (=> true (=> true ($Is ValueMessage.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueMessage.__default.DefaultValue#requires| true))
(assert  (=> true (=> true (and |ValueType.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultValue (Lit ValueType.__default.DefaultValue))))))
(assert  (=> true (=> true (and |ValueType.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultValue (Lit ValueType.__default.DefaultValue))))))
(assert (forall ((arg0@@465 T@U) (arg1@@188 T@U) ) (! (= (type (ValueMessage.__default.CombineDeltas arg0@@465 arg1@@188)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.CombineDeltas|
 :pattern ( (ValueMessage.__default.CombineDeltas arg0@@465 arg1@@188))
)))
(assert  (=> true (forall ((|newdelta#0| T@U) (|olddelta#0| T@U) ) (!  (=> (and (and (= (type |newdelta#0|) DatatypeTypeType) (= (type |olddelta#0|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| |newdelta#0| |olddelta#0|) (and ($Is |newdelta#0| Tclass.ValueMessage.Delta) ($Is |olddelta#0| Tclass.ValueMessage.Delta)))) (and (and (=> (|ValueMessage.Delta#Equal| |newdelta#0| ValueMessage.__default.NopDelta) (|ValueMessage.Delta#Equal| (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) |olddelta#0|)) (=> (|ValueMessage.Delta#Equal| |olddelta#0| ValueMessage.__default.NopDelta) (|ValueMessage.Delta#Equal| (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) |newdelta#0|))) ($Is (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) Tclass.ValueMessage.Delta)))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |4602|
 :pattern ( (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|))
))))
(assert (forall ((|newdelta#0@@0| T@U) (|olddelta#0@@0| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@0|) DatatypeTypeType) (= (type |olddelta#0@@0|) DatatypeTypeType)) (and ($Is |newdelta#0@@0| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@0| Tclass.ValueMessage.Delta))) (= (|ValueMessage.__default.CombineDeltas#requires| |newdelta#0@@0| |olddelta#0@@0|) true))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |4603|
 :pattern ( (|ValueMessage.__default.CombineDeltas#requires| |newdelta#0@@0| |olddelta#0@@0|))
)))
(assert  (=> true (forall ((|newdelta#0@@1| T@U) (|olddelta#0@@1| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@1|) DatatypeTypeType) (= (type |olddelta#0@@1|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| |newdelta#0@@1| |olddelta#0@@1|) (and ($Is |newdelta#0@@1| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@1| Tclass.ValueMessage.Delta)))) (= (ValueMessage.__default.CombineDeltas |newdelta#0@@1| |olddelta#0@@1|) (Lit |#ValueMessage.Delta.NoDelta|)))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |4604|
 :pattern ( (ValueMessage.__default.CombineDeltas |newdelta#0@@1| |olddelta#0@@1|))
))))
(assert  (=> true (forall ((|newdelta#0@@2| T@U) (|olddelta#0@@2| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@2|) DatatypeTypeType) (= (type |olddelta#0@@2|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)) (and ($Is |newdelta#0@@2| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@2| Tclass.ValueMessage.Delta)))) (= (ValueMessage.__default.CombineDeltas (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)) (Lit |#ValueMessage.Delta.NoDelta|)))
 :qid |MessagesdfyValueMessage.20:33|
 :weight 3
 :skolemid |4605|
 :pattern ( (ValueMessage.__default.CombineDeltas (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)))
))))
(assert (forall ((arg0@@466 T@U) (arg1@@189 T@U) ) (! (= (type (ValueMessage.__default.ApplyDelta arg0@@466 arg1@@189)) (SeqType BoxType))
 :qid |funType:ValueMessage.__default.ApplyDelta|
 :pattern ( (ValueMessage.__default.ApplyDelta arg0@@466 arg1@@189))
)))
(assert  (=> true (forall ((|delta#0| T@U) (|value#0@@0| T@U) ) (!  (=> (and (and (= (type |delta#0|) DatatypeTypeType) (= (type |value#0@@0|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| |delta#0| |value#0@@0|) (and ($Is |delta#0| Tclass.ValueMessage.Delta) ($Is |value#0@@0| Tclass.ValueType.Value)))) (and (=> (|ValueMessage.Delta#Equal| |delta#0| ValueMessage.__default.NopDelta) (|Seq#Equal| (ValueMessage.__default.ApplyDelta |delta#0| |value#0@@0|) |value#0@@0|)) ($Is (ValueMessage.__default.ApplyDelta |delta#0| |value#0@@0|) Tclass.ValueType.Value)))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |4606|
 :pattern ( (ValueMessage.__default.ApplyDelta |delta#0| |value#0@@0|))
))))
(assert (forall ((|delta#0@@0| T@U) (|value#0@@1| T@U) ) (!  (=> (and (and (= (type |delta#0@@0|) DatatypeTypeType) (= (type |value#0@@1|) (SeqType BoxType))) (and ($Is |delta#0@@0| Tclass.ValueMessage.Delta) ($Is |value#0@@1| Tclass.ValueType.Value))) (= (|ValueMessage.__default.ApplyDelta#requires| |delta#0@@0| |value#0@@1|) true))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |4607|
 :pattern ( (|ValueMessage.__default.ApplyDelta#requires| |delta#0@@0| |value#0@@1|))
)))
(assert  (=> true (forall ((|delta#0@@1| T@U) (|value#0@@2| T@U) ) (!  (=> (and (and (= (type |delta#0@@1|) DatatypeTypeType) (= (type |value#0@@2|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| |delta#0@@1| |value#0@@2|) (and ($Is |delta#0@@1| Tclass.ValueMessage.Delta) ($Is |value#0@@2| Tclass.ValueType.Value)))) (= (ValueMessage.__default.ApplyDelta |delta#0@@1| |value#0@@2|) |value#0@@2|))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |4608|
 :pattern ( (ValueMessage.__default.ApplyDelta |delta#0@@1| |value#0@@2|))
))))
(assert  (=> true (forall ((|delta#0@@2| T@U) (|value#0@@3| T@U) ) (!  (=> (and (and (= (type |delta#0@@2|) DatatypeTypeType) (= (type |value#0@@3|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| (Lit |delta#0@@2|) (Lit |value#0@@3|)) (and ($Is |delta#0@@2| Tclass.ValueMessage.Delta) ($Is |value#0@@3| Tclass.ValueType.Value)))) (= (ValueMessage.__default.ApplyDelta (Lit |delta#0@@2|) (Lit |value#0@@3|)) (Lit |value#0@@3|)))
 :qid |MessagesdfyValueMessage.24:30|
 :weight 3
 :skolemid |4609|
 :pattern ( (ValueMessage.__default.ApplyDelta (Lit |delta#0@@2|) (Lit |value#0@@3|)))
))))
(assert (= (type Tclass.ValueMessage.Message) TyType))
(assert (= (Tag Tclass.ValueMessage.Message) Tagclass.ValueMessage.Message))
(assert (= (TagFamily Tclass.ValueMessage.Message) tytagFamily$Message))
(assert (forall ((bx@@152 T@U) ) (!  (=> (and (= (type bx@@152) BoxType) ($IsBox bx@@152 Tclass.ValueMessage.Message)) (and (= ($Box ($Unbox DatatypeTypeType bx@@152)) bx@@152) ($Is ($Unbox DatatypeTypeType bx@@152) Tclass.ValueMessage.Message)))
 :qid |unknown.0:0|
 :skolemid |4610|
 :pattern ( ($IsBox bx@@152 Tclass.ValueMessage.Message))
)))
(assert (forall ((arg0@@467 T@U) ) (! (= (type (ValueMessage.__default.MakeValueMessage arg0@@467)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.MakeValueMessage|
 :pattern ( (ValueMessage.__default.MakeValueMessage arg0@@467))
)))
(assert  (=> true (forall ((|value#0@@4| T@U) ) (!  (=> (and (= (type |value#0@@4|) (SeqType BoxType)) (or (|ValueMessage.__default.MakeValueMessage#canCall| |value#0@@4|) ($Is |value#0@@4| Tclass.ValueType.Value))) ($Is (ValueMessage.__default.MakeValueMessage |value#0@@4|) Tclass.ValueMessage.Message))
 :qid |Messagesdfy.90:29|
 :skolemid |4611|
 :pattern ( (ValueMessage.__default.MakeValueMessage |value#0@@4|))
))))
(assert (forall ((|value#0@@5| T@U) ) (!  (=> (and (= (type |value#0@@5|) (SeqType BoxType)) ($Is |value#0@@5| Tclass.ValueType.Value)) (= (|ValueMessage.__default.MakeValueMessage#requires| |value#0@@5|) true))
 :qid |Messagesdfy.90:29|
 :skolemid |4612|
 :pattern ( (|ValueMessage.__default.MakeValueMessage#requires| |value#0@@5|))
)))
(assert  (=> true (forall ((|msg#0| T@U) ) (!  (=> (and (= (type |msg#0|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| |msg#0|) ($Is |msg#0| Tclass.ValueMessage.Message))) true)
 :qid |Messagesdfy.100:30|
 :skolemid |4613|
 :pattern ( (ValueMessage.__default.EncodableMessage |msg#0|))
))))
(assert (forall ((|msg#0@@0| T@U) ) (!  (=> (and (= (type |msg#0@@0|) DatatypeTypeType) ($Is |msg#0@@0| Tclass.ValueMessage.Message)) (= (|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|) true))
 :qid |Messagesdfy.100:30|
 :skolemid |4614|
 :pattern ( (|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|))
)))
(assert  (=> true (forall ((|msg#0@@1| T@U) ) (!  (=> (and (= (type |msg#0@@1|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| |msg#0@@1|) ($Is |msg#0@@1| Tclass.ValueMessage.Message))) (= (ValueMessage.__default.EncodableMessage |msg#0@@1|)  (and true (ValueMessage.Message.Define_q |msg#0@@1|))))
 :qid |Messagesdfy.100:30|
 :skolemid |4615|
 :pattern ( (ValueMessage.__default.EncodableMessage |msg#0@@1|))
))))
(assert  (=> true (forall ((|msg#0@@2| T@U) ) (!  (=> (and (= (type |msg#0@@2|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| (Lit |msg#0@@2|)) ($Is |msg#0@@2| Tclass.ValueMessage.Message))) (= (ValueMessage.__default.EncodableMessage (Lit |msg#0@@2|)) (U_2_bool (Lit (bool_2_U  (and true (ValueMessage.Message.Define_q (Lit |msg#0@@2|))))))))
 :qid |Messagesdfy.100:30|
 :weight 3
 :skolemid |4616|
 :pattern ( (ValueMessage.__default.EncodableMessage (Lit |msg#0@@2|)))
))))
(assert (forall ((arg0@@468 T@U) ) (! (= (type (ValueMessage.__default.EvaluateMessage arg0@@468)) (SeqType BoxType))
 :qid |funType:ValueMessage.__default.EvaluateMessage|
 :pattern ( (ValueMessage.__default.EvaluateMessage arg0@@468))
)))
(assert  (=> true (forall ((|m#0@@9| T@U) ) (!  (=> (and (= (type |m#0@@9|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| |m#0@@9|) (and ($Is |m#0@@9| Tclass.ValueMessage.Message) (ValueMessage.Message.Define_q |m#0@@9|)))) ($Is (ValueMessage.__default.EvaluateMessage |m#0@@9|) Tclass.ValueType.Value))
 :qid |Messagesdfy.105:28|
 :skolemid |4617|
 :pattern ( (ValueMessage.__default.EvaluateMessage |m#0@@9|))
))))
(assert (forall ((|m#0@@10| T@U) ) (!  (=> (and (= (type |m#0@@10|) DatatypeTypeType) ($Is |m#0@@10| Tclass.ValueMessage.Message)) (= (|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|) (ValueMessage.Message.Define_q |m#0@@10|)))
 :qid |Messagesdfy.105:28|
 :skolemid |4618|
 :pattern ( (|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|))
)))
(assert (forall ((arg0@@469 T@U) ) (! (= (type (ValueMessage.Message.value arg0@@469)) (SeqType BoxType))
 :qid |funType:ValueMessage.Message.value|
 :pattern ( (ValueMessage.Message.value arg0@@469))
)))
(assert  (=> true (forall ((|m#0@@11| T@U) ) (!  (=> (and (= (type |m#0@@11|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| |m#0@@11|) (and ($Is |m#0@@11| Tclass.ValueMessage.Message) (ValueMessage.Message.Define_q |m#0@@11|)))) (= (ValueMessage.__default.EvaluateMessage |m#0@@11|) (ValueMessage.Message.value |m#0@@11|)))
 :qid |Messagesdfy.105:28|
 :skolemid |4619|
 :pattern ( (ValueMessage.__default.EvaluateMessage |m#0@@11|))
))))
(assert  (=> true (forall ((|m#0@@12| T@U) ) (!  (=> (and (= (type |m#0@@12|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| (Lit |m#0@@12|)) (and ($Is |m#0@@12| Tclass.ValueMessage.Message) (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit |m#0@@12|)))))))) (= (ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|)) (Lit (ValueMessage.Message.value (Lit |m#0@@12|)))))
 :qid |Messagesdfy.105:28|
 :weight 3
 :skolemid |4620|
 :pattern ( (ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|)))
))))
(assert (forall ((arg0@@470 T@U) (arg1@@190 T@U) ) (! (= (type (ValueMessage.__default.Merge arg0@@470 arg1@@190)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.Merge|
 :pattern ( (ValueMessage.__default.Merge arg0@@470 arg1@@190))
)))
(assert  (=> true (forall ((|newmessage#0| T@U) (|oldmessage#0| T@U) ) (!  (=> (and (and (= (type |newmessage#0|) DatatypeTypeType) (= (type |oldmessage#0|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| |newmessage#0| |oldmessage#0|) (and ($Is |newmessage#0| Tclass.ValueMessage.Message) ($Is |oldmessage#0| Tclass.ValueMessage.Message)))) ($Is (ValueMessage.__default.Merge |newmessage#0| |oldmessage#0|) Tclass.ValueMessage.Message))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |4621|
 :pattern ( (ValueMessage.__default.Merge |newmessage#0| |oldmessage#0|))
))))
(assert (forall ((|newmessage#0@@0| T@U) (|oldmessage#0@@0| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@0|) DatatypeTypeType) (= (type |oldmessage#0@@0|) DatatypeTypeType)) (and ($Is |newmessage#0@@0| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@0| Tclass.ValueMessage.Message))) (= (|ValueMessage.__default.Merge#requires| |newmessage#0@@0| |oldmessage#0@@0|) true))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |4622|
 :pattern ( (|ValueMessage.__default.Merge#requires| |newmessage#0@@0| |oldmessage#0@@0|))
)))
(assert  (and (and (forall ((arg0@@471 T@U) ) (! (= (type (ValueMessage.Message.delta arg0@@471)) DatatypeTypeType)
 :qid |funType:ValueMessage.Message.delta|
 :pattern ( (ValueMessage.Message.delta arg0@@471))
)) (forall ((arg0@@472 T@U) ) (! (= (type (|#ValueMessage.Message.Define| arg0@@472)) DatatypeTypeType)
 :qid |funType:#ValueMessage.Message.Define|
 :pattern ( (|#ValueMessage.Message.Define| arg0@@472))
))) (forall ((arg0@@473 T@U) ) (! (= (type (|#ValueMessage.Message.Update| arg0@@473)) DatatypeTypeType)
 :qid |funType:#ValueMessage.Message.Update|
 :pattern ( (|#ValueMessage.Message.Update| arg0@@473))
))))
(assert  (=> true (forall ((|newmessage#0@@1| T@U) (|oldmessage#0@@1| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@1|) DatatypeTypeType) (= (type |oldmessage#0@@1|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| |newmessage#0@@1| |oldmessage#0@@1|) (and ($Is |newmessage#0@@1| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@1| Tclass.ValueMessage.Message)))) (and (and (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (=> (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (=> (not (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))) (and (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (=> (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|value#1| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
 (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|delta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|ValueMessage.__default.ApplyDelta#canCall| |delta#1| |value#1|))))))) (=> (not (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))) (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|olddelta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
 (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|newdelta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|ValueMessage.__default.CombineDeltas#canCall| |newdelta#1| |olddelta#1|))))))))) (= (ValueMessage.__default.Merge |newmessage#0@@1| |oldmessage#0@@1|) (ite (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (let ((|newvalue#0| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Define| |newvalue#0|)) (ite (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (let ((|value#0@@6| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(let ((|delta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Define| (ValueMessage.__default.ApplyDelta |delta#0@@3| |value#0@@6|)))) (let ((|olddelta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(let ((|newdelta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Update| (ValueMessage.__default.CombineDeltas |newdelta#0@@3| |olddelta#0@@3|)))))))))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |4623|
 :pattern ( (ValueMessage.__default.Merge |newmessage#0@@1| |oldmessage#0@@1|))
))))
(assert  (=> true (forall ((|newmessage#0@@2| T@U) (|oldmessage#0@@2| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@2|) DatatypeTypeType) (= (type |oldmessage#0@@2|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)) (and ($Is |newmessage#0@@2| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@2| Tclass.ValueMessage.Message)))) (and (and (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))))))) (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))) (=> (not (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))) (and (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))))))) (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|value#3| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
 (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|delta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(|ValueMessage.__default.ApplyDelta#canCall| |delta#3| |value#3|))))))) (=> (not (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))) (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|olddelta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
 (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|newdelta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(|ValueMessage.__default.CombineDeltas#canCall| |newdelta#3| |olddelta#3|))))))))) (= (ValueMessage.__default.Merge (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)) (ite (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))) (let ((|newvalue#2| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Define| |newvalue#2|))) (ite (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))) (let ((|value#2@@0| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(let ((|delta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Define| (Lit (ValueMessage.__default.ApplyDelta |delta#2| |value#2@@0|)))))) (let ((|olddelta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(let ((|newdelta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Update| (Lit (ValueMessage.__default.CombineDeltas |newdelta#2| |olddelta#2|)))))))))))
 :qid |MessagesdfyValueMessage.27:25|
 :weight 3
 :skolemid |4624|
 :pattern ( (ValueMessage.__default.Merge (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)))
))))
(assert (= (type ValueMessage.__default.IdentityMessage) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.IdentityMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.IdentityMessage#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| (= ValueMessage.__default.IdentityMessage (Lit (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))))
(assert  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| (= ValueMessage.__default.IdentityMessage (Lit (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))))
(assert (= (type ValueMessage.__default.DefaultMessage) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.DefaultMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.DefaultMessage#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultMessage (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultMessage (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))
(assert (forall ((|a#0#0#0@@0| T@U) ) (!  (=> (= (type |a#0#0#0@@0|) (SeqType BoxType)) (= (DatatypeCtorId (|#ValueMessage.Message.Define| |a#0#0#0@@0|)) |##ValueMessage.Message.Define|))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4625|
 :pattern ( (|#ValueMessage.Message.Define| |a#0#0#0@@0|))
)))
(assert (forall ((d@@27 T@U) ) (!  (=> (= (type d@@27) DatatypeTypeType) (= (ValueMessage.Message.Define_q d@@27) (= (DatatypeCtorId d@@27) |##ValueMessage.Message.Define|)))
 :qid |unknown.0:0|
 :skolemid |4626|
 :pattern ( (ValueMessage.Message.Define_q d@@27))
)))
(assert (forall ((d@@28 T@U) ) (!  (=> (and (= (type d@@28) DatatypeTypeType) (ValueMessage.Message.Define_q d@@28)) (exists ((|a#1#0#0@@0| T@U) ) (!  (and (= (type |a#1#0#0@@0|) (SeqType BoxType)) (= d@@28 (|#ValueMessage.Message.Define| |a#1#0#0@@0|)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4627|
 :no-pattern (type |a#1#0#0@@0|)
 :no-pattern (U_2_int |a#1#0#0@@0|)
 :no-pattern (U_2_bool |a#1#0#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |4628|
 :pattern ( (ValueMessage.Message.Define_q d@@28))
)))
(assert (forall ((|a#2#0#0@@0| T@U) ) (!  (=> (= (type |a#2#0#0@@0|) (SeqType BoxType)) (= ($Is (|#ValueMessage.Message.Define| |a#2#0#0@@0|) Tclass.ValueMessage.Message) ($Is |a#2#0#0@@0| Tclass.ValueType.Value)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4629|
 :pattern ( ($Is (|#ValueMessage.Message.Define| |a#2#0#0@@0|) Tclass.ValueMessage.Message))
)))
(assert (forall ((|a#3#0#0@@0| T@U) ($h@@76 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@0|) (SeqType BoxType)) (= (type $h@@76) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@76)) (= ($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@0|) Tclass.ValueMessage.Message $h@@76) ($IsAlloc |a#3#0#0@@0| Tclass.ValueType.Value $h@@76)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4630|
 :pattern ( ($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@0|) Tclass.ValueMessage.Message $h@@76))
)))
(assert (forall ((d@@29 T@U) ($h@@77 T@U) ) (!  (=> (and (and (= (type d@@29) DatatypeTypeType) (= (type $h@@77) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@77) (and (ValueMessage.Message.Define_q d@@29) ($IsAlloc d@@29 Tclass.ValueMessage.Message $h@@77)))) ($IsAlloc (ValueMessage.Message.value d@@29) Tclass.ValueType.Value $h@@77))
 :qid |unknown.0:0|
 :skolemid |4631|
 :pattern ( ($IsAlloc (ValueMessage.Message.value d@@29) Tclass.ValueType.Value $h@@77))
)))
(assert (forall ((|a#4#0#0@@0| T@U) ) (!  (=> (= (type |a#4#0#0@@0|) (SeqType BoxType)) (= (|#ValueMessage.Message.Define| (Lit |a#4#0#0@@0|)) (Lit (|#ValueMessage.Message.Define| |a#4#0#0@@0|))))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4632|
 :pattern ( (|#ValueMessage.Message.Define| (Lit |a#4#0#0@@0|)))
)))
(assert (forall ((|a#5#0#0@@1| T@U) ) (!  (=> (= (type |a#5#0#0@@1|) (SeqType BoxType)) (= (ValueMessage.Message.value (|#ValueMessage.Message.Define| |a#5#0#0@@1|)) |a#5#0#0@@1|))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |4633|
 :pattern ( (|#ValueMessage.Message.Define| |a#5#0#0@@1|))
)))
(assert (forall ((|a#6#0#0@@1| T@U) ) (!  (=> (= (type |a#6#0#0@@1|) DatatypeTypeType) (= (DatatypeCtorId (|#ValueMessage.Message.Update| |a#6#0#0@@1|)) |##ValueMessage.Message.Update|))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4634|
 :pattern ( (|#ValueMessage.Message.Update| |a#6#0#0@@1|))
)))
(assert (forall ((d@@30 T@U) ) (!  (=> (= (type d@@30) DatatypeTypeType) (= (ValueMessage.Message.Update_q d@@30) (= (DatatypeCtorId d@@30) |##ValueMessage.Message.Update|)))
 :qid |unknown.0:0|
 :skolemid |4635|
 :pattern ( (ValueMessage.Message.Update_q d@@30))
)))
(assert (forall ((d@@31 T@U) ) (!  (=> (and (= (type d@@31) DatatypeTypeType) (ValueMessage.Message.Update_q d@@31)) (exists ((|a#7#0#0@@1| T@U) ) (!  (and (= (type |a#7#0#0@@1|) DatatypeTypeType) (= d@@31 (|#ValueMessage.Message.Update| |a#7#0#0@@1|)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4636|
 :no-pattern (type |a#7#0#0@@1|)
 :no-pattern (U_2_int |a#7#0#0@@1|)
 :no-pattern (U_2_bool |a#7#0#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |4637|
 :pattern ( (ValueMessage.Message.Update_q d@@31))
)))
(assert (forall ((|a#8#0#0@@1| T@U) ) (!  (=> (= (type |a#8#0#0@@1|) DatatypeTypeType) (= ($Is (|#ValueMessage.Message.Update| |a#8#0#0@@1|) Tclass.ValueMessage.Message) ($Is |a#8#0#0@@1| Tclass.ValueMessage.Delta)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4638|
 :pattern ( ($Is (|#ValueMessage.Message.Update| |a#8#0#0@@1|) Tclass.ValueMessage.Message))
)))
(assert (forall ((|a#9#0#0@@0| T@U) ($h@@78 T@U) ) (!  (=> (and (and (= (type |a#9#0#0@@0|) DatatypeTypeType) (= (type $h@@78) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@78)) (= ($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@0|) Tclass.ValueMessage.Message $h@@78) ($IsAlloc |a#9#0#0@@0| Tclass.ValueMessage.Delta $h@@78)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4639|
 :pattern ( ($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@0|) Tclass.ValueMessage.Message $h@@78))
)))
(assert (forall ((d@@32 T@U) ($h@@79 T@U) ) (!  (=> (and (and (= (type d@@32) DatatypeTypeType) (= (type $h@@79) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@79) (and (ValueMessage.Message.Update_q d@@32) ($IsAlloc d@@32 Tclass.ValueMessage.Message $h@@79)))) ($IsAlloc (ValueMessage.Message.delta d@@32) Tclass.ValueMessage.Delta $h@@79))
 :qid |unknown.0:0|
 :skolemid |4640|
 :pattern ( ($IsAlloc (ValueMessage.Message.delta d@@32) Tclass.ValueMessage.Delta $h@@79))
)))
(assert (forall ((|a#10#0#0@@0| T@U) ) (!  (=> (= (type |a#10#0#0@@0|) DatatypeTypeType) (= (|#ValueMessage.Message.Update| (Lit |a#10#0#0@@0|)) (Lit (|#ValueMessage.Message.Update| |a#10#0#0@@0|))))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4641|
 :pattern ( (|#ValueMessage.Message.Update| (Lit |a#10#0#0@@0|)))
)))
(assert (forall ((|a#11#0#0@@0| T@U) ) (!  (=> (= (type |a#11#0#0@@0|) DatatypeTypeType) (= (ValueMessage.Message.delta (|#ValueMessage.Message.Update| |a#11#0#0@@0|)) |a#11#0#0@@0|))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4642|
 :pattern ( (|#ValueMessage.Message.Update| |a#11#0#0@@0|))
)))
(assert (forall ((|a#12#0#0| T@U) ) (!  (=> (= (type |a#12#0#0|) DatatypeTypeType) (< (DtRank |a#12#0#0|) (DtRank (|#ValueMessage.Message.Update| |a#12#0#0|))))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |4643|
 :pattern ( (|#ValueMessage.Message.Update| |a#12#0#0|))
)))
(assert (forall ((d@@33 T@U) ) (!  (=> (and (= (type d@@33) DatatypeTypeType) (|$IsA#ValueMessage.Message| d@@33)) (or (ValueMessage.Message.Define_q d@@33) (ValueMessage.Message.Update_q d@@33)))
 :qid |unknown.0:0|
 :skolemid |4644|
 :pattern ( (|$IsA#ValueMessage.Message| d@@33))
)))
(assert (forall ((d@@34 T@U) ) (!  (=> (and (= (type d@@34) DatatypeTypeType) ($Is d@@34 Tclass.ValueMessage.Message)) (or (ValueMessage.Message.Define_q d@@34) (ValueMessage.Message.Update_q d@@34)))
 :qid |unknown.0:0|
 :skolemid |4645|
 :pattern ( (ValueMessage.Message.Update_q d@@34) ($Is d@@34 Tclass.ValueMessage.Message))
 :pattern ( (ValueMessage.Message.Define_q d@@34) ($Is d@@34 Tclass.ValueMessage.Message))
)))
(assert (forall ((a@@123 T@U) (b@@72 T@U) ) (!  (=> (and (and (= (type a@@123) DatatypeTypeType) (= (type b@@72) DatatypeTypeType)) (and (ValueMessage.Message.Define_q a@@123) (ValueMessage.Message.Define_q b@@72))) (= (|ValueMessage.Message#Equal| a@@123 b@@72) (|Seq#Equal| (ValueMessage.Message.value a@@123) (ValueMessage.Message.value b@@72))))
 :qid |unknown.0:0|
 :skolemid |4646|
 :pattern ( (|ValueMessage.Message#Equal| a@@123 b@@72) (ValueMessage.Message.Define_q a@@123))
 :pattern ( (|ValueMessage.Message#Equal| a@@123 b@@72) (ValueMessage.Message.Define_q b@@72))
)))
(assert (forall ((a@@124 T@U) (b@@73 T@U) ) (!  (=> (and (and (= (type a@@124) DatatypeTypeType) (= (type b@@73) DatatypeTypeType)) (and (ValueMessage.Message.Update_q a@@124) (ValueMessage.Message.Update_q b@@73))) (= (|ValueMessage.Message#Equal| a@@124 b@@73) (|ValueMessage.Delta#Equal| (ValueMessage.Message.delta a@@124) (ValueMessage.Message.delta b@@73))))
 :qid |unknown.0:0|
 :skolemid |4647|
 :pattern ( (|ValueMessage.Message#Equal| a@@124 b@@73) (ValueMessage.Message.Update_q a@@124))
 :pattern ( (|ValueMessage.Message#Equal| a@@124 b@@73) (ValueMessage.Message.Update_q b@@73))
)))
(assert (forall ((a@@125 T@U) (b@@74 T@U) ) (!  (=> (and (= (type a@@125) DatatypeTypeType) (= (type b@@74) DatatypeTypeType)) (= (|ValueMessage.Message#Equal| a@@125 b@@74) (= a@@125 b@@74)))
 :qid |unknown.0:0|
 :skolemid |4648|
 :pattern ( (|ValueMessage.Message#Equal| a@@125 b@@74))
)))
(assert (= (type Tclass.TotalKMMapMod.__default) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.__default) Tagclass.TotalKMMapMod.__default))
(assert (= (TagFamily Tclass.TotalKMMapMod.__default) tytagFamily$_default))
(assert (forall ((bx@@153 T@U) ) (!  (=> (and (= (type bx@@153) BoxType) ($IsBox bx@@153 Tclass.TotalKMMapMod.__default)) (and (= ($Box ($Unbox refType bx@@153)) bx@@153) ($Is ($Unbox refType bx@@153) Tclass.TotalKMMapMod.__default)))
 :qid |unknown.0:0|
 :skolemid |4649|
 :pattern ( ($IsBox bx@@153 Tclass.TotalKMMapMod.__default))
)))
(assert (forall (($o@@27 T@U) ) (!  (=> (= (type $o@@27) refType) (= ($Is $o@@27 Tclass.TotalKMMapMod.__default)  (or (= $o@@27 null) (= (dtype $o@@27) Tclass.TotalKMMapMod.__default))))
 :qid |unknown.0:0|
 :skolemid |4650|
 :pattern ( ($Is $o@@27 Tclass.TotalKMMapMod.__default))
)))
(assert (forall (($o@@28 T@U) ($h@@80 T@U) ) (!  (=> (and (= (type $o@@28) refType) (= (type $h@@80) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@80)  (or (= $o@@28 null) (U_2_bool (MapType1Select (MapType0Select $h@@80 $o@@28) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4651|
 :pattern ( ($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@80))
)))
(assert  (=> true (forall ((|v#0@@13| T@U) ) (!  (=> (and (= (type |v#0@@13|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| |v#0@@13|) ($Is |v#0@@13| Tclass.ValueMessage.Message))) true)
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |4652|
 :pattern ( (TotalKMMapMod.__default.TerminalValue |v#0@@13|))
))))
(assert (forall ((|v#0@@14| T@U) ) (!  (=> (and (= (type |v#0@@14|) DatatypeTypeType) ($Is |v#0@@14| Tclass.ValueMessage.Message)) (= (|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@14|) true))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |4653|
 :pattern ( (|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@14|))
)))
(assert  (=> true (forall ((|v#0@@15| T@U) ) (!  (=> (and (= (type |v#0@@15|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| |v#0@@15|) ($Is |v#0@@15| Tclass.ValueMessage.Message))) (= (TotalKMMapMod.__default.TerminalValue |v#0@@15|) (ValueMessage.Message.Define_q |v#0@@15|)))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |4654|
 :pattern ( (TotalKMMapMod.__default.TerminalValue |v#0@@15|))
))))
(assert  (=> true (forall ((|v#0@@16| T@U) ) (!  (=> (and (= (type |v#0@@16|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| (Lit |v#0@@16|)) ($Is |v#0@@16| Tclass.ValueMessage.Message))) (= (TotalKMMapMod.__default.TerminalValue (Lit |v#0@@16|)) (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit |v#0@@16|)))))))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :weight 3
 :skolemid |4655|
 :pattern ( (TotalKMMapMod.__default.TerminalValue (Lit |v#0@@16|)))
))))
(assert (= (type TotalKMMapMod.__default.DefaultV) DatatypeTypeType))
(assert  (=> true (=> true (and (U_2_bool (Lit (bool_2_U (TotalKMMapMod.__default.TerminalValue (Lit TotalKMMapMod.__default.DefaultV))))) ($Is TotalKMMapMod.__default.DefaultV Tclass.ValueMessage.Message)))))
(assert (= |TotalKMMapMod.__default.DefaultV#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultMessage#canCall| (= TotalKMMapMod.__default.DefaultV (Lit ValueMessage.__default.DefaultMessage))))))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultMessage#canCall| (= TotalKMMapMod.__default.DefaultV (Lit ValueMessage.__default.DefaultMessage))))))
(assert  (=> true (forall ((|k#0| T@U) ) (!  (=> (and (= (type |k#0|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| |k#0|) ($Is |k#0| Tclass.KeyType.Key))) true)
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |4656|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0|))
))))
(assert (forall ((|k#0@@0| T@U) ) (!  (=> (and (= (type |k#0@@0|) (SeqType BoxType)) ($Is |k#0@@0| Tclass.KeyType.Key)) (= (|TotalKMMapMod.__default.AnyKey#requires| |k#0@@0|) true))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |4657|
 :pattern ( (|TotalKMMapMod.__default.AnyKey#requires| |k#0@@0|))
)))
(assert  (=> true (forall ((|k#0@@1| T@U) ) (!  (=> (and (= (type |k#0@@1|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@1|) ($Is |k#0@@1| Tclass.KeyType.Key))) (= (TotalKMMapMod.__default.AnyKey |k#0@@1|) (U_2_bool (Lit (bool_2_U true)))))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |4658|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@1|))
))))
(assert  (=> true (forall ((|k#0@@2| T@U) ) (!  (=> (and (= (type |k#0@@2|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| (Lit |k#0@@2|)) ($Is |k#0@@2| Tclass.KeyType.Key))) (= (TotalKMMapMod.__default.AnyKey (Lit |k#0@@2|)) (U_2_bool (Lit (bool_2_U true)))))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :weight 3
 :skolemid |4659|
 :pattern ( (TotalKMMapMod.__default.AnyKey (Lit |k#0@@2|)))
))))
(assert  (=> true (forall ((|kvm#0| T@U) (|k#0@@3| T@U) ) (!  (=> (and (and (= (type |kvm#0|) (IMapType BoxType BoxType)) (= (type |k#0@@3|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0| |k#0@@3|) (and ($Is |kvm#0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@3| Tclass.KeyType.Key)))) true)
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |4660|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0| |k#0@@3|))
))))
(assert (forall ((|kvm#0@@0| T@U) (|k#0@@4| T@U) ) (!  (=> (and (and (= (type |kvm#0@@0|) (IMapType BoxType BoxType)) (= (type |k#0@@4|) (SeqType BoxType))) (and ($Is |kvm#0@@0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@4| Tclass.KeyType.Key))) (= (|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@4|) true))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |4661|
 :pattern ( (|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@4|))
)))
(assert  (=> true (forall ((|kvm#0@@1| T@U) (|k#0@@5| T@U) ) (!  (=> (and (and (= (type |kvm#0@@1|) (IMapType BoxType BoxType)) (= (type |k#0@@5|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@1| |k#0@@5|) (and ($Is |kvm#0@@1| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@5| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|) ($Box |k#0@@5|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@1|) ($Box |k#0@@5|))))) (= (TotalKMMapMod.__default.Defined |kvm#0@@1| |k#0@@5|)  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|) ($Box |k#0@@5|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@1|) ($Box |k#0@@5|))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |4662|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@1| |k#0@@5|))
))))
(assert  (=> true (forall ((|kvm#0@@2| T@U) (|k#0@@6| T@U) ) (!  (=> (and (and (= (type |kvm#0@@2|) (IMapType BoxType BoxType)) (= (type |k#0@@6|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@2| (Lit |k#0@@6|)) (and ($Is |kvm#0@@2| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@6| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|) ($Box |k#0@@6|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@2|) ($Box (Lit |k#0@@6|)))))) (= (TotalKMMapMod.__default.Defined |kvm#0@@2| (Lit |k#0@@6|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|) ($Box |k#0@@6|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@2|) ($Box (Lit |k#0@@6|)))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :weight 3
 :skolemid |4663|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@2| (Lit |k#0@@6|)))
))))
(assert  (=> true (forall ((|kvm#0@@3| T@U) (|k#0@@7| T@U) ) (!  (=> (and (and (= (type |kvm#0@@3|) (IMapType BoxType BoxType)) (= (type |k#0@@7|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| (Lit |kvm#0@@3|) (Lit |k#0@@7|)) (and ($Is |kvm#0@@3| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@7| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|) ($Box |k#0@@7|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit |kvm#0@@3|)) ($Box (Lit |k#0@@7|)))))) (= (TotalKMMapMod.__default.Defined (Lit |kvm#0@@3|) (Lit |k#0@@7|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|) ($Box |k#0@@7|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit |kvm#0@@3|)) ($Box (Lit |k#0@@7|)))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :weight 3
 :skolemid |4664|
 :pattern ( (TotalKMMapMod.__default.Defined (Lit |kvm#0@@3|) (Lit |k#0@@7|)))
))))
(assert  (=> true (forall ((|kvm#0@@4| T@U) ) (!  (=> (and (= (type |kvm#0@@4|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| |kvm#0@@4|) ($Is |kvm#0@@4| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) true)
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |4665|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@4|))
))))
(assert (forall ((|kvm#0@@5| T@U) ) (!  (=> (and (= (type |kvm#0@@5|) (IMapType BoxType BoxType)) ($Is |kvm#0@@5| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))) (= (|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|) true))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |4666|
 :pattern ( (|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|))
)))
(assert  (=> true (forall ((|kvm#0@@6| T@U) ) (!  (=> (and (= (type |kvm#0@@6|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| |kvm#0@@6|) ($Is |kvm#0@@6| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) (and (forall ((|k#0@@8| T@U) ) (!  (=> (and (= (type |k#0@@8|) (SeqType BoxType)) ($Is |k#0@@8| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@8|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@8|) (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@6| |k#0@@8|))))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |4668|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@8|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@8|))
)) (= (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@6|) (forall ((|k#0@@9| T@U) ) (!  (=> (= (type |k#0@@9|) (SeqType BoxType)) (=> (and ($Is |k#0@@9| Tclass.KeyType.Key) (TotalKMMapMod.__default.AnyKey |k#0@@9|)) (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@9|)))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |4667|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@9|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@9|))
)))))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |4669|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@6|))
))))
(assert  (=> true (forall ((|kvm#0@@7| T@U) ) (!  (=> (and (= (type |kvm#0@@7|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| (Lit |kvm#0@@7|)) ($Is |kvm#0@@7| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) (and (forall ((|k#1| T@U) ) (!  (=> (and (= (type |k#1|) (SeqType BoxType)) ($Is |k#1| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#1|) (=> (TotalKMMapMod.__default.AnyKey |k#1|) (|TotalKMMapMod.__default.Defined#canCall| (Lit |kvm#0@@7|) |k#1|))))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |4671|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@7| |k#1|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#1|))
)) (= (TotalKMMapMod.__default.TotalMapIsFull (Lit |kvm#0@@7|)) (forall ((|k#1@@0| T@U) ) (!  (=> (= (type |k#1@@0|) (SeqType BoxType)) (=> (and ($Is |k#1@@0| Tclass.KeyType.Key) (TotalKMMapMod.__default.AnyKey |k#1@@0|)) (TotalKMMapMod.__default.Defined (Lit |kvm#0@@7|) |k#1@@0|)))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |4670|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@7| |k#1@@0|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#1@@0|))
)))))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :weight 3
 :skolemid |4672|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull (Lit |kvm#0@@7|)))
))))
(assert (= (type TotalKMMapMod.__default.EmptyTotalMap) (IMapType BoxType BoxType)))
(assert  (=> true (=> true (and (U_2_bool (Lit (bool_2_U (TotalKMMapMod.__default.TotalMapIsFull (Lit TotalKMMapMod.__default.EmptyTotalMap))))) ($Is TotalKMMapMod.__default.EmptyTotalMap (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
(assert (= |TotalKMMapMod.__default.EmptyTotalMap#requires| true))
(assert  (and (forall ((arg0@@474 T@U) ) (! (= (type (|lambda#149| arg0@@474)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#149|
 :pattern ( (|lambda#149| arg0@@474))
)) (forall ((arg0@@475 T@U) ) (! (= (type (|lambda#150| arg0@@475)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#150|
 :pattern ( (|lambda#150| arg0@@475))
))))
(assert  (=> true (=> true (and (forall ((|k#0@@10| T@U) ) (!  (=> (and (= (type |k#0@@10|) (SeqType BoxType)) ($Is |k#0@@10| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@10|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@10|) |TotalKMMapMod.__default.DefaultV#canCall|)))
 :qid |TotalMapsdfyTotalKMMapMod.28:10|
 :skolemid |4673|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@10|))
)) (= TotalKMMapMod.__default.EmptyTotalMap (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#150| ($Box (Lit TotalKMMapMod.__default.DefaultV))) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))))
(assert  (=> true (=> true (and (forall ((|k#0@@11| T@U) ) (!  (=> (and (= (type |k#0@@11|) (SeqType BoxType)) ($Is |k#0@@11| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@11|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@11|) |TotalKMMapMod.__default.DefaultV#canCall|)))
 :qid |TotalMapsdfyTotalKMMapMod.28:10|
 :skolemid |4674|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@11|))
)) (= TotalKMMapMod.__default.EmptyTotalMap (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#150| ($Box (Lit TotalKMMapMod.__default.DefaultV))) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))))
(assert (= (type TotalKMMapMod.__default.Witness) (IMapType BoxType BoxType)))
(assert  (=> true (=> true (and (|IMap#Equal| TotalKMMapMod.__default.Witness TotalKMMapMod.__default.EmptyTotalMap) ($Is TotalKMMapMod.__default.Witness (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
(assert (= |TotalKMMapMod.__default.Witness#requires| true))
(assert (= (type Tclass.TotalKMMapMod.TotalMap) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.TotalMap) Tagclass.TotalKMMapMod.TotalMap))
(assert (= (TagFamily Tclass.TotalKMMapMod.TotalMap) tytagFamily$TotalMap))
(assert (forall ((bx@@154 T@U) ) (!  (=> (and (= (type bx@@154) BoxType) ($IsBox bx@@154 Tclass.TotalKMMapMod.TotalMap)) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@154)) bx@@154) ($Is ($Unbox (IMapType BoxType BoxType) bx@@154) Tclass.TotalKMMapMod.TotalMap)))
 :qid |unknown.0:0|
 :skolemid |4675|
 :pattern ( ($IsBox bx@@154 Tclass.TotalKMMapMod.TotalMap))
)))
(assert (forall ((|ikv#0| T@U) ) (!  (=> (= (type |ikv#0|) (IMapType BoxType BoxType)) (= ($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap)  (and ($Is |ikv#0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) (TotalKMMapMod.__default.TotalMapIsFull |ikv#0|))))
 :qid |unknown.0:0|
 :skolemid |4676|
 :pattern ( ($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap))
)))
(assert (forall ((|ikv#0@@0| T@U) ($h@@81 T@U) ) (!  (=> (and (= (type |ikv#0@@0|) (IMapType BoxType BoxType)) (= (type $h@@81) (MapType0Type refType MapType1Type))) (= ($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@81) ($IsAlloc |ikv#0@@0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@81)))
 :qid |unknown.0:0|
 :skolemid |4677|
 :pattern ( ($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@81))
)))
(assert (= (type Tclass.LSNMod.__default) TyType))
(assert (= (Tag Tclass.LSNMod.__default) Tagclass.LSNMod.__default))
(assert (= (TagFamily Tclass.LSNMod.__default) tytagFamily$_default))
(assert (forall ((bx@@155 T@U) ) (!  (=> (and (= (type bx@@155) BoxType) ($IsBox bx@@155 Tclass.LSNMod.__default)) (and (= ($Box ($Unbox refType bx@@155)) bx@@155) ($Is ($Unbox refType bx@@155) Tclass.LSNMod.__default)))
 :qid |unknown.0:0|
 :skolemid |4678|
 :pattern ( ($IsBox bx@@155 Tclass.LSNMod.__default))
)))
(assert (forall (($o@@29 T@U) ) (!  (=> (= (type $o@@29) refType) (= ($Is $o@@29 Tclass.LSNMod.__default)  (or (= $o@@29 null) (= (dtype $o@@29) Tclass.LSNMod.__default))))
 :qid |unknown.0:0|
 :skolemid |4679|
 :pattern ( ($Is $o@@29 Tclass.LSNMod.__default))
)))
(assert (forall (($o@@30 T@U) ($h@@82 T@U) ) (!  (=> (and (= (type $o@@30) refType) (= (type $h@@82) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@82)  (or (= $o@@30 null) (U_2_bool (MapType1Select (MapType0Select $h@@82 $o@@30) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4680|
 :pattern ( ($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@82))
)))
(assert (forall ((|a#0#0#0@@1| T@U) (|a#0#1#0@@0| Int) ) (!  (=> (= (type |a#0#0#0@@1|) BoxType) (= (DatatypeCtorId (|#StampedMod.Stamped.Stamped| |a#0#0#0@@1| |a#0#1#0@@0|)) |##StampedMod.Stamped.Stamped|))
 :qid |StampedMapidfy.18:33|
 :skolemid |4681|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#0#0#0@@1| |a#0#1#0@@0|))
)))
(assert (forall ((d@@35 T@U) ) (!  (=> (= (type d@@35) DatatypeTypeType) (= (StampedMod.Stamped.Stamped_q d@@35) (= (DatatypeCtorId d@@35) |##StampedMod.Stamped.Stamped|)))
 :qid |unknown.0:0|
 :skolemid |4682|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@35))
)))
(assert (forall ((d@@36 T@U) ) (!  (=> (and (= (type d@@36) DatatypeTypeType) (StampedMod.Stamped.Stamped_q d@@36)) (exists ((|a#1#0#0@@1| T@U) (|a#1#1#0@@0| Int) ) (!  (and (= (type |a#1#0#0@@1|) BoxType) (= d@@36 (|#StampedMod.Stamped.Stamped| |a#1#0#0@@1| |a#1#1#0@@0|)))
 :qid |StampedMapidfy.18:33|
 :skolemid |4683|
 :no-pattern (type |a#1#0#0@@1|)
 :no-pattern (U_2_int |a#1#0#0@@1|)
 :no-pattern (U_2_bool |a#1#0#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |4684|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@36))
)))
(assert (forall ((StampedMod.Stamped$T@@2 T@U) (|a#2#0#0@@1| T@U) (|a#2#1#0@@0| Int) ) (!  (=> (and (= (type StampedMod.Stamped$T@@2) TyType) (= (type |a#2#0#0@@1|) BoxType)) (= ($Is (|#StampedMod.Stamped.Stamped| |a#2#0#0@@1| |a#2#1#0@@0|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2))  (and ($IsBox |a#2#0#0@@1| StampedMod.Stamped$T@@2) ($Is (int_2_U |a#2#1#0@@0|) Tclass._System.nat))))
 :qid |unknown.0:0|
 :skolemid |4685|
 :pattern ( ($Is (|#StampedMod.Stamped.Stamped| |a#2#0#0@@1| |a#2#1#0@@0|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2)))
)))
(assert (forall ((StampedMod.Stamped$T@@3 T@U) (|a#3#0#0@@1| T@U) (|a#3#1#0@@0| Int) ($h@@83 T@U) ) (!  (=> (and (and (and (= (type StampedMod.Stamped$T@@3) TyType) (= (type |a#3#0#0@@1|) BoxType)) (= (type $h@@83) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@83)) (= ($IsAlloc (|#StampedMod.Stamped.Stamped| |a#3#0#0@@1| |a#3#1#0@@0|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3) $h@@83)  (and ($IsAllocBox |a#3#0#0@@1| StampedMod.Stamped$T@@3 $h@@83) ($IsAlloc (int_2_U |a#3#1#0@@0|) Tclass._System.nat $h@@83))))
 :qid |unknown.0:0|
 :skolemid |4686|
 :pattern ( ($IsAlloc (|#StampedMod.Stamped.Stamped| |a#3#0#0@@1| |a#3#1#0@@0|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3) $h@@83))
)))
(assert (forall ((d@@37 T@U) (StampedMod.Stamped$T@@4 T@U) ($h@@84 T@U) ) (!  (=> (and (and (and (= (type d@@37) DatatypeTypeType) (= (type StampedMod.Stamped$T@@4) TyType)) (= (type $h@@84) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@84) (and (StampedMod.Stamped.Stamped_q d@@37) ($IsAlloc d@@37 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@4) $h@@84)))) ($IsAllocBox (StampedMod.Stamped.value d@@37) StampedMod.Stamped$T@@4 $h@@84))
 :qid |unknown.0:0|
 :skolemid |4687|
 :pattern ( ($IsAllocBox (StampedMod.Stamped.value d@@37) StampedMod.Stamped$T@@4 $h@@84))
)))
(assert (forall ((d@@38 T@U) ($h@@85 T@U) ) (!  (=> (and (and (= (type d@@38) DatatypeTypeType) (= (type $h@@85) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@85) (and (StampedMod.Stamped.Stamped_q d@@38) (exists ((StampedMod.Stamped$T@@5 T@U) ) (!  (and (= (type StampedMod.Stamped$T@@5) TyType) ($IsAlloc d@@38 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@5) $h@@85))
 :qid |unknown.0:0|
 :skolemid |4688|
 :pattern ( ($IsAlloc d@@38 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@5) $h@@85))
))))) ($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@38)) Tclass._System.nat $h@@85))
 :qid |unknown.0:0|
 :skolemid |4689|
 :pattern ( ($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@38)) Tclass._System.nat $h@@85))
)))
(assert (forall ((|a#4#0#0@@1| T@U) (|a#4#1#0@@0| Int) ) (!  (=> (= (type |a#4#0#0@@1|) BoxType) (= (|#StampedMod.Stamped.Stamped| (Lit |a#4#0#0@@1|) (LitInt |a#4#1#0@@0|)) (Lit (|#StampedMod.Stamped.Stamped| |a#4#0#0@@1| |a#4#1#0@@0|))))
 :qid |StampedMapidfy.18:33|
 :skolemid |4690|
 :pattern ( (|#StampedMod.Stamped.Stamped| (Lit |a#4#0#0@@1|) (LitInt |a#4#1#0@@0|)))
)))
(assert (forall ((|a#5#0#0@@2| T@U) (|a#5#1#0@@0| Int) ) (!  (=> (= (type |a#5#0#0@@2|) BoxType) (= (StampedMod.Stamped.value (|#StampedMod.Stamped.Stamped| |a#5#0#0@@2| |a#5#1#0@@0|)) |a#5#0#0@@2|))
 :qid |StampedMapidfy.18:33|
 :skolemid |4691|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#5#0#0@@2| |a#5#1#0@@0|))
)))
(assert (forall ((|a#6#0#0@@2| T@U) (|a#6#1#0@@0| Int) ) (!  (=> (= (type |a#6#0#0@@2|) BoxType) (< (BoxRank |a#6#0#0@@2|) (DtRank (|#StampedMod.Stamped.Stamped| |a#6#0#0@@2| |a#6#1#0@@0|))))
 :qid |StampedMapidfy.18:33|
 :skolemid |4692|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#6#0#0@@2| |a#6#1#0@@0|))
)))
(assert (forall ((|a#7#0#0@@2| T@U) (|a#7#1#0@@0| Int) ) (!  (=> (= (type |a#7#0#0@@2|) BoxType) (= (StampedMod.Stamped.seqEnd (|#StampedMod.Stamped.Stamped| |a#7#0#0@@2| |a#7#1#0@@0|)) |a#7#1#0@@0|))
 :qid |StampedMapidfy.18:33|
 :skolemid |4693|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#7#0#0@@2| |a#7#1#0@@0|))
)))
(assert (forall ((d@@39 T@U) ) (!  (=> (and (= (type d@@39) DatatypeTypeType) (|$IsA#StampedMod.Stamped| d@@39)) (StampedMod.Stamped.Stamped_q d@@39))
 :qid |unknown.0:0|
 :skolemid |4694|
 :pattern ( (|$IsA#StampedMod.Stamped| d@@39))
)))
(assert (forall ((StampedMod.Stamped$T@@6 T@U) (d@@40 T@U) ) (!  (=> (and (and (= (type StampedMod.Stamped$T@@6) TyType) (= (type d@@40) DatatypeTypeType)) ($Is d@@40 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6))) (StampedMod.Stamped.Stamped_q d@@40))
 :qid |unknown.0:0|
 :skolemid |4695|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@40) ($Is d@@40 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6)))
)))
(assert (forall ((a@@126 T@U) (b@@75 T@U) ) (!  (=> (and (and (= (type a@@126) DatatypeTypeType) (= (type b@@75) DatatypeTypeType)) true) (= (|StampedMod.Stamped#Equal| a@@126 b@@75)  (and (= (StampedMod.Stamped.value a@@126) (StampedMod.Stamped.value b@@75)) (= (StampedMod.Stamped.seqEnd a@@126) (StampedMod.Stamped.seqEnd b@@75)))))
 :qid |unknown.0:0|
 :skolemid |4696|
 :pattern ( (|StampedMod.Stamped#Equal| a@@126 b@@75))
)))
(assert (forall ((a@@127 T@U) (b@@76 T@U) ) (!  (=> (and (= (type a@@127) DatatypeTypeType) (= (type b@@76) DatatypeTypeType)) (= (|StampedMod.Stamped#Equal| a@@127 b@@76) (= a@@127 b@@76)))
 :qid |unknown.0:0|
 :skolemid |4697|
 :pattern ( (|StampedMod.Stamped#Equal| a@@127 b@@76))
)))
(assert (= (type Tclass.StampedMod.__default) TyType))
(assert (= (Tag Tclass.StampedMod.__default) Tagclass.StampedMod.__default))
(assert (= (TagFamily Tclass.StampedMod.__default) tytagFamily$_default))
(assert (forall ((bx@@156 T@U) ) (!  (=> (and (= (type bx@@156) BoxType) ($IsBox bx@@156 Tclass.StampedMod.__default)) (and (= ($Box ($Unbox refType bx@@156)) bx@@156) ($Is ($Unbox refType bx@@156) Tclass.StampedMod.__default)))
 :qid |unknown.0:0|
 :skolemid |4698|
 :pattern ( ($IsBox bx@@156 Tclass.StampedMod.__default))
)))
(assert (forall (($o@@31 T@U) ) (!  (=> (= (type $o@@31) refType) (= ($Is $o@@31 Tclass.StampedMod.__default)  (or (= $o@@31 null) (= (dtype $o@@31) Tclass.StampedMod.__default))))
 :qid |unknown.0:0|
 :skolemid |4699|
 :pattern ( ($Is $o@@31 Tclass.StampedMod.__default))
)))
(assert (forall (($o@@32 T@U) ($h@@86 T@U) ) (!  (=> (and (= (type $o@@32) refType) (= (type $h@@86) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@86)  (or (= $o@@32 null) (U_2_bool (MapType1Select (MapType0Select $h@@86 $o@@32) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4700|
 :pattern ( ($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@86))
)))
(assert (= (type StampedMod.__default.Empty) DatatypeTypeType))
(assert  (=> true (=> true ($Is StampedMod.__default.Empty (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))))
(assert (= |StampedMod.__default.Empty#requires| true))
(assert  (=> true (=> true (and |TotalKMMapMod.__default.EmptyTotalMap#canCall| (= StampedMod.__default.Empty (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap)) (LitInt 0))))))))
(assert  (=> true (=> true (and |TotalKMMapMod.__default.EmptyTotalMap#canCall| (= StampedMod.__default.Empty (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap)) (LitInt 0))))))))
(assert (= (type Tclass.SequencesLite.__default) TyType))
(assert (= (Tag Tclass.SequencesLite.__default) Tagclass.SequencesLite.__default))
(assert (= (TagFamily Tclass.SequencesLite.__default) tytagFamily$_default))
(assert (forall ((bx@@157 T@U) ) (!  (=> (and (= (type bx@@157) BoxType) ($IsBox bx@@157 Tclass.SequencesLite.__default)) (and (= ($Box ($Unbox refType bx@@157)) bx@@157) ($Is ($Unbox refType bx@@157) Tclass.SequencesLite.__default)))
 :qid |unknown.0:0|
 :skolemid |4701|
 :pattern ( ($IsBox bx@@157 Tclass.SequencesLite.__default))
)))
(assert (forall (($o@@33 T@U) ) (!  (=> (= (type $o@@33) refType) (= ($Is $o@@33 Tclass.SequencesLite.__default)  (or (= $o@@33 null) (= (dtype $o@@33) Tclass.SequencesLite.__default))))
 :qid |unknown.0:0|
 :skolemid |4702|
 :pattern ( ($Is $o@@33 Tclass.SequencesLite.__default))
)))
(assert (forall (($o@@34 T@U) ($h@@87 T@U) ) (!  (=> (and (= (type $o@@34) refType) (= (type $h@@87) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@87)  (or (= $o@@34 null) (U_2_bool (MapType1Select (MapType0Select $h@@87 $o@@34) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4703|
 :pattern ( ($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@87))
)))
(assert (forall ((arg0@@476 T@U) (arg1@@191 T@U) ) (! (= (type (SequencesLite.__default.Last arg0@@476 arg1@@191)) BoxType)
 :qid |funType:SequencesLite.__default.Last|
 :pattern ( (SequencesLite.__default.Last arg0@@476 arg1@@191))
)))
(assert  (=> true (forall ((SequencesLite._default.Last$E T@U) (|run#0| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E) TyType) (= (type |run#0|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E |run#0|) (and ($Is |run#0| (TSeq SequencesLite._default.Last$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0|) 0)))) ($IsBox (SequencesLite.__default.Last SequencesLite._default.Last$E |run#0|) SequencesLite._default.Last$E))
 :qid |unknown.0:0|
 :skolemid |4704|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E |run#0|))
))))
(assert (forall ((SequencesLite._default.Last$E@@0 T@U) (|run#0@@0| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@0) TyType) (= (type |run#0@@0|) (SeqType BoxType))) ($Is |run#0@@0| (TSeq SequencesLite._default.Last$E@@0))) (= (|SequencesLite.__default.Last#requires| SequencesLite._default.Last$E@@0 |run#0@@0|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@0|) 0)))
 :qid |unknown.0:0|
 :skolemid |4705|
 :pattern ( (|SequencesLite.__default.Last#requires| SequencesLite._default.Last$E@@0 |run#0@@0|))
)))
(assert  (=> true (forall ((SequencesLite._default.Last$E@@1 T@U) (|run#0@@1| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@1) TyType) (= (type |run#0@@1|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E@@1 |run#0@@1|) (and ($Is |run#0@@1| (TSeq SequencesLite._default.Last$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@1|) 0)))) (= (SequencesLite.__default.Last SequencesLite._default.Last$E@@1 |run#0@@1|) (|Seq#Index| |run#0@@1| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@1|) 1))))
 :qid |unknown.0:0|
 :skolemid |4706|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E@@1 |run#0@@1|))
))))
(assert  (=> true (forall ((SequencesLite._default.Last$E@@2 T@U) (|run#0@@2| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@2) TyType) (= (type |run#0@@2|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)) (and ($Is |run#0@@2| (TSeq SequencesLite._default.Last$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@2|)) 0)))) (= (SequencesLite.__default.Last SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)) (|Seq#Index| (Lit |run#0@@2|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@2|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4707|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)))
))))
(assert (forall ((arg0@@477 T@U) (arg1@@192 T@U) ) (! (= (type (SequencesLite.__default.DropLast arg0@@477 arg1@@192)) (SeqType BoxType))
 :qid |funType:SequencesLite.__default.DropLast|
 :pattern ( (SequencesLite.__default.DropLast arg0@@477 arg1@@192))
)))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E T@U) (|run#0@@3| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E) TyType) (= (type |run#0@@3|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E |run#0@@3|) (and ($Is |run#0@@3| (TSeq SequencesLite._default.DropLast$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@3|) 0)))) ($Is (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E |run#0@@3|) (TSeq SequencesLite._default.DropLast$E)))
 :qid |unknown.0:0|
 :skolemid |4708|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E |run#0@@3|))
))))
(assert (forall ((SequencesLite._default.DropLast$E@@0 T@U) (|run#0@@4| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@0) TyType) (= (type |run#0@@4|) (SeqType BoxType))) ($Is |run#0@@4| (TSeq SequencesLite._default.DropLast$E@@0))) (= (|SequencesLite.__default.DropLast#requires| SequencesLite._default.DropLast$E@@0 |run#0@@4|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@4|) 0)))
 :qid |unknown.0:0|
 :skolemid |4709|
 :pattern ( (|SequencesLite.__default.DropLast#requires| SequencesLite._default.DropLast$E@@0 |run#0@@4|))
)))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E@@1 T@U) (|run#0@@5| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@1) TyType) (= (type |run#0@@5|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E@@1 |run#0@@5|) (and ($Is |run#0@@5| (TSeq SequencesLite._default.DropLast$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@5|) 0)))) (= (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@1 |run#0@@5|) (|Seq#Take| |run#0@@5| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@5|) 1))))
 :qid |unknown.0:0|
 :skolemid |4710|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@1 |run#0@@5|))
))))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E@@2 T@U) (|run#0@@6| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@2) TyType) (= (type |run#0@@6|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)) (and ($Is |run#0@@6| (TSeq SequencesLite._default.DropLast$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@6|)) 0)))) (= (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)) (|Seq#Take| (Lit |run#0@@6|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@6|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4711|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)))
))))
(assert (= (type Tclass.Mathematics.__default) TyType))
(assert (= (Tag Tclass.Mathematics.__default) Tagclass.Mathematics.__default))
(assert (= (TagFamily Tclass.Mathematics.__default) tytagFamily$_default))
(assert (forall ((bx@@158 T@U) ) (!  (=> (and (= (type bx@@158) BoxType) ($IsBox bx@@158 Tclass.Mathematics.__default)) (and (= ($Box ($Unbox refType bx@@158)) bx@@158) ($Is ($Unbox refType bx@@158) Tclass.Mathematics.__default)))
 :qid |unknown.0:0|
 :skolemid |4712|
 :pattern ( ($IsBox bx@@158 Tclass.Mathematics.__default))
)))
(assert (forall (($o@@35 T@U) ) (!  (=> (= (type $o@@35) refType) (= ($Is $o@@35 Tclass.Mathematics.__default)  (or (= $o@@35 null) (= (dtype $o@@35) Tclass.Mathematics.__default))))
 :qid |unknown.0:0|
 :skolemid |4713|
 :pattern ( ($Is $o@@35 Tclass.Mathematics.__default))
)))
(assert (forall (($o@@36 T@U) ($h@@88 T@U) ) (!  (=> (and (= (type $o@@36) refType) (= (type $h@@88) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@88)  (or (= $o@@36 null) (U_2_bool (MapType1Select (MapType0Select $h@@88 $o@@36) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4714|
 :pattern ( ($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@88))
)))
(assert  (=> true (forall ((|a#0@@11| Int) (|b#0@@1| Int) ) (!  (=> true true)
 :qid |mathematicsidfy.6:15|
 :skolemid |4715|
 :pattern ( (Mathematics.__default.min |a#0@@11| |b#0@@1|))
))))
(assert (forall ((|a#0@@12| Int) (|b#0@@2| Int) ) (! (= (|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|) true)
 :qid |mathematicsidfy.6:15|
 :skolemid |4716|
 :pattern ( (|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|))
)))
(assert  (=> true (forall ((|a#0@@13| Int) (|b#0@@3| Int) ) (!  (=> true (= (Mathematics.__default.min |a#0@@13| |b#0@@3|) (ite (INTERNAL_lt_boogie |a#0@@13| |b#0@@3|) |a#0@@13| |b#0@@3|)))
 :qid |mathematicsidfy.6:15|
 :skolemid |4717|
 :pattern ( (Mathematics.__default.min |a#0@@13| |b#0@@3|))
))))
(assert  (=> true (forall ((|a#0@@14| Int) (|b#0@@4| Int) ) (!  (=> true (= (Mathematics.__default.min (LitInt |a#0@@14|) (LitInt |b#0@@4|)) (ite (INTERNAL_lt_boogie |a#0@@14| |b#0@@4|) |a#0@@14| |b#0@@4|)))
 :qid |mathematicsidfy.6:15|
 :weight 3
 :skolemid |4718|
 :pattern ( (Mathematics.__default.min (LitInt |a#0@@14|) (LitInt |b#0@@4|)))
))))
(assert  (=> true (forall ((|a#0@@15| Int) (|b#0@@5| Int) ) (!  (=> true true)
 :qid |mathematicsidfy.14:15|
 :skolemid |4719|
 :pattern ( (Mathematics.__default.max |a#0@@15| |b#0@@5|))
))))
(assert (forall ((|a#0@@16| Int) (|b#0@@6| Int) ) (! (= (|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|) true)
 :qid |mathematicsidfy.14:15|
 :skolemid |4720|
 :pattern ( (|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|))
)))
(assert  (=> true (forall ((|a#0@@17| Int) (|b#0@@7| Int) ) (!  (=> true (= (Mathematics.__default.max |a#0@@17| |b#0@@7|) (ite (INTERNAL_lt_boogie |a#0@@17| |b#0@@7|) |b#0@@7| |a#0@@17|)))
 :qid |mathematicsidfy.14:15|
 :skolemid |4721|
 :pattern ( (Mathematics.__default.max |a#0@@17| |b#0@@7|))
))))
(assert  (=> true (forall ((|a#0@@18| Int) (|b#0@@8| Int) ) (!  (=> true (= (Mathematics.__default.max (LitInt |a#0@@18|) (LitInt |b#0@@8|)) (ite (INTERNAL_lt_boogie |a#0@@18| |b#0@@8|) |b#0@@8| |a#0@@18|)))
 :qid |mathematicsidfy.14:15|
 :weight 3
 :skolemid |4722|
 :pattern ( (Mathematics.__default.max (LitInt |a#0@@18|) (LitInt |b#0@@8|)))
))))
(assert (forall ((arg0@@478 T@U) (arg1@@193 T@U) ) (! (= (type (Mathematics.__default.Set arg0@@478 arg1@@193)) (MapType0Type BoxType boolType))
 :qid |funType:Mathematics.__default.Set|
 :pattern ( (Mathematics.__default.Set arg0@@478 arg1@@193))
)))
(assert  (=> true (forall ((Mathematics._default.Set$T T@U) (|ms#0| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T) TyType) (= (type |ms#0|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T |ms#0|) ($Is |ms#0| (TMultiSet Mathematics._default.Set$T)))) ($Is (Mathematics.__default.Set Mathematics._default.Set$T |ms#0|) (TSet Mathematics._default.Set$T)))
 :qid |unknown.0:0|
 :skolemid |4723|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T |ms#0|))
))))
(assert (forall ((Mathematics._default.Set$T@@0 T@U) (|ms#0@@0| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@0) TyType) (= (type |ms#0@@0|) (MapType0Type BoxType intType))) ($Is |ms#0@@0| (TMultiSet Mathematics._default.Set$T@@0))) (= (|Mathematics.__default.Set#requires| Mathematics._default.Set$T@@0 |ms#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |4724|
 :pattern ( (|Mathematics.__default.Set#requires| Mathematics._default.Set$T@@0 |ms#0@@0|))
)))
(assert (forall ((arg0@@479 T@U) (arg1@@194 T@U) (arg2@@95 Int) ) (! (= (type (|lambda#153| arg0@@479 arg1@@194 arg2@@95)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#153|
 :pattern ( (|lambda#153| arg0@@479 arg1@@194 arg2@@95))
)))
(assert  (=> true (forall ((Mathematics._default.Set$T@@1 T@U) (|ms#0@@1| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@1) TyType) (= (type |ms#0@@1|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T@@1 |ms#0@@1|) ($Is |ms#0@@1| (TMultiSet Mathematics._default.Set$T@@1)))) (= (Mathematics.__default.Set Mathematics._default.Set$T@@1 |ms#0@@1|) (|lambda#153| Mathematics._default.Set$T@@1 |ms#0@@1| 0)))
 :qid |unknown.0:0|
 :skolemid |4725|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T@@1 |ms#0@@1|))
))))
(assert  (=> true (forall ((Mathematics._default.Set$T@@2 T@U) (|ms#0@@2| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@2) TyType) (= (type |ms#0@@2|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)) ($Is |ms#0@@2| (TMultiSet Mathematics._default.Set$T@@2)))) (= (Mathematics.__default.Set Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)) (|lambda#153| Mathematics._default.Set$T@@2 (Lit |ms#0@@2|) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4726|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)))
))))
(assert (forall ((arg0@@480 T@U) (arg1@@195 T@U) ) (! (= (type (Mathematics.__default.ISet arg0@@480 arg1@@195)) (MapType0Type BoxType boolType))
 :qid |funType:Mathematics.__default.ISet|
 :pattern ( (Mathematics.__default.ISet arg0@@480 arg1@@195))
)))
(assert  (=> true (forall ((Mathematics._default.ISet$T T@U) (|ms#0@@3| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T) TyType) (= (type |ms#0@@3|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T |ms#0@@3|) ($Is |ms#0@@3| (TSet Mathematics._default.ISet$T)))) ($Is (Mathematics.__default.ISet Mathematics._default.ISet$T |ms#0@@3|) (TISet Mathematics._default.ISet$T)))
 :qid |unknown.0:0|
 :skolemid |4727|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T |ms#0@@3|))
))))
(assert (forall ((Mathematics._default.ISet$T@@0 T@U) (|ms#0@@4| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@0) TyType) (= (type |ms#0@@4|) (MapType0Type BoxType boolType))) ($Is |ms#0@@4| (TSet Mathematics._default.ISet$T@@0))) (= (|Mathematics.__default.ISet#requires| Mathematics._default.ISet$T@@0 |ms#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |4728|
 :pattern ( (|Mathematics.__default.ISet#requires| Mathematics._default.ISet$T@@0 |ms#0@@4|))
)))
(assert (forall ((arg0@@481 T@U) (arg1@@196 T@U) ) (! (= (type (|lambda#155| arg0@@481 arg1@@196)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#155|
 :pattern ( (|lambda#155| arg0@@481 arg1@@196))
)))
(assert  (=> true (forall ((Mathematics._default.ISet$T@@1 T@U) (|ms#0@@5| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@1) TyType) (= (type |ms#0@@5|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T@@1 |ms#0@@5|) ($Is |ms#0@@5| (TSet Mathematics._default.ISet$T@@1)))) (= (Mathematics.__default.ISet Mathematics._default.ISet$T@@1 |ms#0@@5|) (|lambda#155| Mathematics._default.ISet$T@@1 |ms#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |4729|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T@@1 |ms#0@@5|))
))))
(assert  (=> true (forall ((Mathematics._default.ISet$T@@2 T@U) (|ms#0@@6| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@2) TyType) (= (type |ms#0@@6|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)) ($Is |ms#0@@6| (TSet Mathematics._default.ISet$T@@2)))) (= (Mathematics.__default.ISet Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)) (|lambda#155| Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4730|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)))
))))
(assert (= (type Tclass.LinearSequence__i.__default) TyType))
(assert (= (Tag Tclass.LinearSequence__i.__default) Tagclass.LinearSequence__i.__default))
(assert (= (TagFamily Tclass.LinearSequence__i.__default) tytagFamily$_default))
(assert (forall (($o@@37 T@U) ) (!  (=> (= (type $o@@37) refType) (= ($Is $o@@37 Tclass.LinearSequence__i.__default)  (or (= $o@@37 null) (= (dtype $o@@37) Tclass.LinearSequence__i.__default))))
 :qid |unknown.0:0|
 :skolemid |4731|
 :pattern ( ($Is $o@@37 Tclass.LinearSequence__i.__default))
)))
(assert (forall (($o@@38 T@U) ($h@@89 T@U) ) (!  (=> (and (= (type $o@@38) refType) (= (type $h@@89) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@89)  (or (= $o@@38 null) (U_2_bool (MapType1Select (MapType0Select $h@@89 $o@@38) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4732|
 :pattern ( ($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@89))
)))
(assert (forall ((arg0@@482 T@U) (arg1@@197 Int) (arg2@@96 T@U) ) (! (= (type (LinearSequence__i.__default.seq__alloc__init arg0@@482 arg1@@197 arg2@@96)) (SeqType BoxType))
 :qid |funType:LinearSequence__i.__default.seq__alloc__init|
 :pattern ( (LinearSequence__i.__default.seq__alloc__init arg0@@482 arg1@@197 arg2@@96))
)))
(assert  (=> true (forall ((LinearSequence_i._default.seq_alloc_init$A T@U) (|length#0@@3| Int) (|a#0@@19| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.seq_alloc_init$A) TyType) (= (type |a#0@@19|) BoxType)) (or (|LinearSequence__i.__default.seq__alloc__init#canCall| LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) (and (and (INTERNAL_le_boogie 0 |length#0@@3|) (INTERNAL_lt_boogie |length#0@@3| 18446744073709551616)) ($IsBox |a#0@@19| LinearSequence_i._default.seq_alloc_init$A)))) (and (and (= (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|)) |length#0@@3|) (forall ((|i#0@@38| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@38|) (INTERNAL_lt_boogie |i#0@@38| (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|)))) (= (|Seq#Index| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) |i#0@@38|) |a#0@@19|))
 :qid |LinearSequenceidfy.22:22|
 :skolemid |4733|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) |i#0@@38|))
))) ($Is (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) (TSeq LinearSequence_i._default.seq_alloc_init$A))))
 :qid |unknown.0:0|
 :skolemid |4734|
 :pattern ( (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|))
))))
(assert (forall ((LinearSequence_i._default.seq_alloc_init$A@@0 T@U) (|length#0@@4| Int) (|a#0@@20| T@U) ) (!  (=> (and (= (type LinearSequence_i._default.seq_alloc_init$A@@0) TyType) (= (type |a#0@@20|) BoxType)) (=> (and (and (INTERNAL_le_boogie 0 |length#0@@4|) (INTERNAL_lt_boogie |length#0@@4| 18446744073709551616)) ($IsBox |a#0@@20| LinearSequence_i._default.seq_alloc_init$A@@0)) (= (|LinearSequence__i.__default.seq__alloc__init#requires| LinearSequence_i._default.seq_alloc_init$A@@0 |length#0@@4| |a#0@@20|) true)))
 :qid |unknown.0:0|
 :skolemid |4735|
 :pattern ( (|LinearSequence__i.__default.seq__alloc__init#requires| LinearSequence_i._default.seq_alloc_init$A@@0 |length#0@@4| |a#0@@20|))
)))
(assert (forall ((arg0@@483 T@U) (arg1@@198 T@U) ) (! (= (type (LinearSequence__i.__default.lseqs arg0@@483 arg1@@198)) (SeqType BoxType))
 :qid |funType:LinearSequence__i.__default.lseqs|
 :pattern ( (LinearSequence__i.__default.lseqs arg0@@483 arg1@@198))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseqs$A T@U) (|l#0@@5| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseqs$A) TyType) (= (type |l#0@@5|) BoxType)) (or (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseqs$A |l#0@@5|) ($IsBox |l#0@@5| (|#$lseq| LinearSequence_i._default.lseqs$A)))) (and (and (_System.__default.rank__is__less__than (TSeq LinearSequence_i._default.lseqs$A) (|#$lseq| LinearSequence_i._default.lseqs$A) ($Box (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|)) |l#0@@5|) (= (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|)) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_i._default.lseqs$A |l#0@@5|)))) ($Is (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|) (TSeq LinearSequence_i._default.lseqs$A))))
 :qid |unknown.0:0|
 :skolemid |4736|
 :pattern ( (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|))
))))
(assert (forall ((LinearSequence_i._default.lseqs$A@@0 T@U) (|l#0@@6| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseqs$A@@0) TyType) (= (type |l#0@@6|) BoxType)) ($IsBox |l#0@@6| (|#$lseq| LinearSequence_i._default.lseqs$A@@0))) (= (|LinearSequence__i.__default.lseqs#requires| LinearSequence_i._default.lseqs$A@@0 |l#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |4737|
 :pattern ( (|LinearSequence__i.__default.lseqs#requires| LinearSequence_i._default.lseqs$A@@0 |l#0@@6|))
)))
(assert (forall ((arg0@@484 T@U) (arg1@@199 T@U) ) (! (= (type (LinearSequence__i.__default.imagine__lseq arg0@@484 arg1@@199)) BoxType)
 :qid |funType:LinearSequence__i.__default.imagine__lseq|
 :pattern ( (LinearSequence__i.__default.imagine__lseq arg0@@484 arg1@@199))
)))
(assert  (=> true (forall ((LinearSequence_i._default.imagine_lseq$A T@U) (|s#0@@21| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.imagine_lseq$A) TyType) (= (type |s#0@@21|) (SeqType BoxType))) (or (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.imagine_lseq$A |s#0@@21|) ($Is |s#0@@21| (TSeq LinearSequence_i._default.imagine_lseq$A)))) (and (and (|Seq#Equal| (LinearSequence__i.__default.lseqs LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |s#0@@21|) (forall ((|i#0@@39| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@39|) (INTERNAL_lt_boogie |i#0@@39| (|Seq#Length| |s#0@@21|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |i#0@@39|)))))
 :qid |LinearSequenceidfy.38:20|
 :skolemid |4738|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |i#0@@39|)))
))) ($IsBox (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|) (|#$lseq| LinearSequence_i._default.imagine_lseq$A))))
 :qid |unknown.0:0|
 :skolemid |4739|
 :pattern ( (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|))
))))
(assert (forall ((LinearSequence_i._default.imagine_lseq$A@@0 T@U) (|s#0@@22| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.imagine_lseq$A@@0) TyType) (= (type |s#0@@22|) (SeqType BoxType))) ($Is |s#0@@22| (TSeq LinearSequence_i._default.imagine_lseq$A@@0))) (= (|LinearSequence__i.__default.imagine__lseq#requires| LinearSequence_i._default.imagine_lseq$A@@0 |s#0@@22|) true))
 :qid |unknown.0:0|
 :skolemid |4740|
 :pattern ( (|LinearSequence__i.__default.imagine__lseq#requires| LinearSequence_i._default.imagine_lseq$A@@0 |s#0@@22|))
)))
(assert (forall ((arg0@@485 T@U) (arg1@@200 T@U) ) (! (= (type (LinearSequence__i.__default.linLast arg0@@485 arg1@@200)) BoxType)
 :qid |funType:LinearSequence__i.__default.linLast|
 :pattern ( (LinearSequence__i.__default.linLast arg0@@485 arg1@@200))
)))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A T@U) (|l#0@@7| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A) TyType) (= (type |l#0@@7|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A |l#0@@7|) (and ($IsBox |l#0@@7| (|#$lseq| LinearSequence_i._default.linLast$A)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A |l#0@@7|))))) ($IsBox (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A |l#0@@7|) LinearSequence_i._default.linLast$A))
 :qid |unknown.0:0|
 :skolemid |4742|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A |l#0@@7|))
))))
(assert (forall ((LinearSequence_i._default.linLast$A@@0 T@U) (|l#0@@8| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@0) TyType) (= (type |l#0@@8|) BoxType)) ($IsBox |l#0@@8| (|#$lseq| LinearSequence_i._default.linLast$A@@0))) (= (|LinearSequence__i.__default.linLast#requires| LinearSequence_i._default.linLast$A@@0 |l#0@@8|) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@0 |l#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |4743|
 :pattern ( (|LinearSequence__i.__default.linLast#requires| LinearSequence_i._default.linLast$A@@0 |l#0@@8|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A@@1 T@U) (|l#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@1) TyType) (= (type |l#0@@9|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (and ($IsBox |l#0@@9| (|#$lseq| LinearSequence_i._default.linLast$A@@1)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@1 |l#0@@9|))))) (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|)) (= (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@1 |l#0@@9|) 1)))))
 :qid |unknown.0:0|
 :skolemid |4744|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@1 |l#0@@9|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A@@2 T@U) (|l#0@@10| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@2) TyType) (= (type |l#0@@10|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (and ($IsBox |l#0@@10| (|#$lseq| LinearSequence_i._default.linLast$A@@2)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|))))))))) (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|))) (= (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4745|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)))
))))
(assert (forall ((arg0@@486 T@U) (arg1@@201 T@U) ) (! (= (type (LinearSequence__i.__default.ldroplast arg0@@486 arg1@@201)) BoxType)
 :qid |funType:LinearSequence__i.__default.ldroplast|
 :pattern ( (LinearSequence__i.__default.ldroplast arg0@@486 arg1@@201))
)))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A T@U) (|l#0@@11| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A) TyType) (= (type |l#0@@11|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A |l#0@@11|) (and ($IsBox |l#0@@11| (|#$lseq| LinearSequence_i._default.ldroplast$A)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A |l#0@@11|))))) (and (and (= (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A |l#0@@11|) (INTERNAL_add_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) 1)) (forall ((|i#0@@40| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@40|) (INTERNAL_lt_boogie |i#0@@40| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)))) (= (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) |i#0@@40|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A |l#0@@11|) |i#0@@40|))))
 :qid |LinearSequenceidfy.59:20|
 :skolemid |4746|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A |l#0@@11|) |i#0@@40|))
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) |i#0@@40|))
))) ($IsBox (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|) (|#$lseq| LinearSequence_i._default.ldroplast$A))))
 :qid |unknown.0:0|
 :skolemid |4747|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|))
))))
(assert (forall ((LinearSequence_i._default.ldroplast$A@@0 T@U) (|l#0@@12| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@0) TyType) (= (type |l#0@@12|) BoxType)) ($IsBox |l#0@@12| (|#$lseq| LinearSequence_i._default.ldroplast$A@@0))) (= (|LinearSequence__i.__default.ldroplast#requires| LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|))))
 :qid |unknown.0:0|
 :skolemid |4748|
 :pattern ( (|LinearSequence__i.__default.ldroplast#requires| LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A@@1 T@U) (|l#0@@13| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@1) TyType) (= (type |l#0@@13|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (and ($IsBox |l#0@@13| (|#$lseq| LinearSequence_i._default.ldroplast$A@@1)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|))))) (and (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|)) (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.ldroplast$A@@1 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) 1)))) (= (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.ldroplast$A@@1 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) 1))))))
 :qid |unknown.0:0|
 :skolemid |4749|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A@@2 T@U) (|l#0@@14| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@2) TyType) (= (type |l#0@@14|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (and ($IsBox |l#0@@14| (|#$lseq| LinearSequence_i._default.ldroplast$A@@2)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|))))))))) (and (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|))) (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.ldroplast$A@@2 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) 1))))) (= (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.ldroplast$A@@2 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) 1)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4750|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A T@U) (|l#0@@15| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A) TyType) (= (type |l#0@@15|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A |l#0@@15|) ($IsBox |l#0@@15| (|#$lseq| LinearSequence_i._default.lseq_has_all$A)))) true)
 :qid |unknown.0:0|
 :skolemid |4751|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A |l#0@@15|))
))))
(assert (forall ((LinearSequence_i._default.lseq_has_all$A@@0 T@U) (|l#0@@16| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@0) TyType) (= (type |l#0@@16|) BoxType)) ($IsBox |l#0@@16| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@0))) (= (|LinearSequence__i.__default.lseq__has__all#requires| LinearSequence_i._default.lseq_has_all$A@@0 |l#0@@16|) true))
 :qid |unknown.0:0|
 :skolemid |4752|
 :pattern ( (|LinearSequence__i.__default.lseq__has__all#requires| LinearSequence_i._default.lseq_has_all$A@@0 |l#0@@16|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A@@1 T@U) (|l#0@@17| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@1) TyType) (= (type |l#0@@17|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) ($IsBox |l#0@@17| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@1)))) (and (forall ((|i#0@@41| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@41|) (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) (=> (INTERNAL_lt_boogie |i#0@@41| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|)) (|LinearExtern.__default.lseq__has#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |4754|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@41|)))
)) (= (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) (forall ((|i#0@@42| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@42|) (INTERNAL_lt_boogie |i#0@@42| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@42|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |4753|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@42|)))
)))))
 :qid |unknown.0:0|
 :skolemid |4755|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A@@2 T@U) (|l#0@@18| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@2) TyType) (= (type |l#0@@18|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) ($IsBox |l#0@@18| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@2)))) (and (forall ((|i#1@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@2|) (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) (=> (INTERNAL_lt_boogie |i#1@@2| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|))) (|LinearExtern.__default.lseq__has#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |4757|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 |l#0@@18|) |i#1@@2|)))
)) (= (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) (forall ((|i#1@@3| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@3|) (INTERNAL_lt_boogie |i#1@@3| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|))) |i#1@@3|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |4756|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 |l#0@@18|) |i#1@@3|)))
)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4758|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length_as_uint64$A T@U) (|s#0@@23| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A) TyType) (= (type |s#0@@23|) BoxType)) (or (|LinearSequence__i.__default.lseq__length__as__uint64#canCall| LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) (and ($IsBox |s#0@@23| (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A)) (INTERNAL_le_boogie (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|)) 18446744073709551615)))) (and (= (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|))) (and (INTERNAL_le_boogie 0 (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|)) (INTERNAL_lt_boogie (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |4759|
 :pattern ( (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|))
))))
(assert (forall ((LinearSequence_i._default.lseq_length_as_uint64$A@@0 T@U) (|s#0@@24| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A@@0) TyType) (= (type |s#0@@24|) BoxType)) ($IsBox |s#0@@24| (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A@@0))) (= (|LinearSequence__i.__default.lseq__length__as__uint64#requires| LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|) (INTERNAL_le_boogie (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|)) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |4760|
 :pattern ( (|LinearSequence__i.__default.lseq__length__as__uint64#requires| LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A T@U) (|s#0@@25| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A) TyType) (= (type |s#0@@25|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A |s#0@@25|) ($IsBox |s#0@@25| (|#$lseq| LinearSequence_i._default.lseq_length$A)))) (INTERNAL_le_boogie 0 (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A |s#0@@25|)))
 :qid |unknown.0:0|
 :skolemid |4762|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A |s#0@@25|))
))))
(assert (forall ((LinearSequence_i._default.lseq_length$A@@0 T@U) (|s#0@@26| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@0) TyType) (= (type |s#0@@26|) BoxType)) ($IsBox |s#0@@26| (|#$lseq| LinearSequence_i._default.lseq_length$A@@0))) (= (|LinearSequence__i.__default.lseq__length#requires| LinearSequence_i._default.lseq_length$A@@0 |s#0@@26|) true))
 :qid |unknown.0:0|
 :skolemid |4763|
 :pattern ( (|LinearSequence__i.__default.lseq__length#requires| LinearSequence_i._default.lseq_length$A@@0 |s#0@@26|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A@@1 T@U) (|s#0@@27| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@1) TyType) (= (type |s#0@@27|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) ($IsBox |s#0@@27| (|#$lseq| LinearSequence_i._default.lseq_length$A@@1)))) (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) (= (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|)))))
 :qid |unknown.0:0|
 :skolemid |4764|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A@@2 T@U) (|s#0@@28| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@2) TyType) (= (type |s#0@@28|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) ($IsBox |s#0@@28| (|#$lseq| LinearSequence_i._default.lseq_length$A@@2)))) (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) (= (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4765|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A| T@U) (|s#0@@29| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A|) TyType) (= (type |s#0@@29|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|) ($IsBox |s#0@@29| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A|)))) (INTERNAL_le_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |4766|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|))
))))
(assert (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@0| T@U) (|s#0@@30| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@0|) TyType) (= (type |s#0@@30|) BoxType)) ($IsBox |s#0@@30| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@0|))) (= (|LinearSequence__i.__default.operator_kcardinality_qlseq#requires| |LinearSequence_i._default.operator'cardinality?lseq$A@@0| |s#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |4767|
 :pattern ( (|LinearSequence__i.__default.operator_kcardinality_qlseq#requires| |LinearSequence_i._default.operator'cardinality?lseq$A@@0| |s#0@@30|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@1| T@U) (|s#0@@31| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@1|) TyType) (= (type |s#0@@31|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) ($IsBox |s#0@@31| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@1|)))) (and (|LinearSequence__i.__default.lseq__length#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) (= (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) (LinearSequence__i.__default.lseq__length |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|))))
 :qid |unknown.0:0|
 :skolemid |4768|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@2| T@U) (|s#0@@32| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@2|) TyType) (= (type |s#0@@32|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) ($IsBox |s#0@@32| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@2|)))) (and (|LinearSequence__i.__default.lseq__length#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) (= (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) (LitInt (LinearSequence__i.__default.lseq__length |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4769|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)))
))))
(assert (forall ((arg0@@487 T@U) (arg1@@202 T@U) (arg2@@97 Int) ) (! (= (type (LinearSequence__i.__default.operator_ksubscript_qlseq arg0@@487 arg1@@202 arg2@@97)) BoxType)
 :qid |funType:LinearSequence__i.__default.operator_ksubscript_qlseq|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq arg0@@487 arg1@@202 arg2@@97))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A| T@U) (|s#0@@33| T@U) (|i#0@@43| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A|) TyType) (= (type |s#0@@33|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@43|) (and (and ($IsBox |s#0@@33| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A|)) (INTERNAL_le_boogie 0 |i#0@@43|)) (INTERNAL_lt_boogie |i#0@@43| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33|))))) ($IsBox (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@43|) |LinearSequence_i._default.operator'subscript?lseq$A|))
 :qid |unknown.0:0|
 :skolemid |4770|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@43|))
))))
(assert (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@0| T@U) (|s#0@@34| T@U) (|i#0@@44| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@0|) TyType) (= (type |s#0@@34|) BoxType)) (and ($IsBox |s#0@@34| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@0|)) (INTERNAL_le_boogie 0 |i#0@@44|))) (= (|LinearSequence__i.__default.operator_ksubscript_qlseq#requires| |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34| |i#0@@44|) (INTERNAL_lt_boogie |i#0@@44| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34|))))
 :qid |unknown.0:0|
 :skolemid |4771|
 :pattern ( (|LinearSequence__i.__default.operator_ksubscript_qlseq#requires| |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34| |i#0@@44|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@1| T@U) (|s#0@@35| T@U) (|i#0@@45| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@1|) TyType) (= (type |s#0@@35|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@45|) (and (and ($IsBox |s#0@@35| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@1|)) (INTERNAL_le_boogie 0 |i#0@@45|)) (INTERNAL_lt_boogie |i#0@@45| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@45|) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|) |i#0@@45|))))
 :qid |unknown.0:0|
 :skolemid |4772|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@45|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@2| T@U) (|s#0@@36| T@U) (|i#0@@46| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@2|) TyType) (= (type |s#0@@36|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@46|)) (and (and ($IsBox |s#0@@36| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@2|)) (INTERNAL_le_boogie 0 |i#0@@46|)) (INTERNAL_lt_boogie |i#0@@46| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@46|)) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|) (LitInt |i#0@@46|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4773|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@46|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@3| T@U) (|s#0@@37| T@U) (|i#0@@47| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@3|) TyType) (= (type |s#0@@37|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@47|)) (and (and ($IsBox |s#0@@37| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@3|)) (INTERNAL_le_boogie 0 |i#0@@47|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie |i#0@@47| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|))))))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|)) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@47|)) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|)) (LitInt |i#0@@47|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4774|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@47|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A| T@U) (|s#0@@38| T@U) (|i#0@@48| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A|) TyType) (= (type |s#0@@38|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38| |i#0@@48|) (and (and ($IsBox |s#0@@38| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A|)) (INTERNAL_le_boogie 0 |i#0@@48|)) (INTERNAL_lt_boogie |i#0@@48| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38|))))) true)
 :qid |unknown.0:0|
 :skolemid |4775|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38| |i#0@@48|))
))))
(assert (forall ((|LinearSequence_i._default.operator'in?lseq$A@@0| T@U) (|s#0@@39| T@U) (|i#0@@49| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@0|) TyType) (= (type |s#0@@39|) BoxType)) (and ($IsBox |s#0@@39| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@0|)) (INTERNAL_le_boogie 0 |i#0@@49|))) (= (|LinearSequence__i.__default.operator_kin_qlseq#requires| |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39| |i#0@@49|) (INTERNAL_lt_boogie |i#0@@49| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39|))))
 :qid |unknown.0:0|
 :skolemid |4776|
 :pattern ( (|LinearSequence__i.__default.operator_kin_qlseq#requires| |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39| |i#0@@49|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@1| T@U) (|s#0@@40| T@U) (|i#0@@50| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@1|) TyType) (= (type |s#0@@40|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@50|) (and (and ($IsBox |s#0@@40| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@1|)) (INTERNAL_le_boogie 0 |i#0@@50|)) (INTERNAL_lt_boogie |i#0@@50| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@50|) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|) |i#0@@50|))))))
 :qid |unknown.0:0|
 :skolemid |4777|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@50|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@2| T@U) (|s#0@@41| T@U) (|i#0@@51| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@2|) TyType) (= (type |s#0@@41|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@51|)) (and (and ($IsBox |s#0@@41| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@2|)) (INTERNAL_le_boogie 0 |i#0@@51|)) (INTERNAL_lt_boogie |i#0@@51| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@51|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|) (LitInt |i#0@@51|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4778|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@51|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@3| T@U) (|s#0@@42| T@U) (|i#0@@52| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@3|) TyType) (= (type |s#0@@42|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@52|)) (and (and ($IsBox |s#0@@42| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@3|)) (INTERNAL_le_boogie 0 |i#0@@52|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie |i#0@@52| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|))))))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|)) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@52|)) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|))) (LitInt |i#0@@52|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4779|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@52|)))
))))
(assert (forall ((arg0@@488 T@U) (arg1@@203 T@U) (arg2@@98 T@U) ) (! (= (type (LinearSequence__i.__default.lseq__add arg0@@488 arg1@@203 arg2@@98)) BoxType)
 :qid |funType:LinearSequence__i.__default.lseq__add|
 :pattern ( (LinearSequence__i.__default.lseq__add arg0@@488 arg1@@203 arg2@@98))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_add$A T@U) (|l#0@@19| T@U) (|r#0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_i._default.lseq_add$A) TyType) (= (type |l#0@@19|) BoxType)) (= (type |r#0|) BoxType)) (or (|LinearSequence__i.__default.lseq__add#canCall| LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|) (and ($IsBox |l#0@@19| (|#$lseq| LinearSequence_i._default.lseq_add$A)) ($IsBox |r#0| (|#$lseq| LinearSequence_i._default.lseq_add$A))))) ($IsBox (LinearSequence__i.__default.lseq__add LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|) (|#$lseq| LinearSequence_i._default.lseq_add$A)))
 :qid |unknown.0:0|
 :skolemid |4780|
 :pattern ( (LinearSequence__i.__default.lseq__add LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|))
))))
(assert (forall ((LinearSequence_i._default.lseq_add$A@@0 T@U) (|l#0@@20| T@U) (|r#0@@0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_i._default.lseq_add$A@@0) TyType) (= (type |l#0@@20|) BoxType)) (= (type |r#0@@0|) BoxType)) (and ($IsBox |l#0@@20| (|#$lseq| LinearSequence_i._default.lseq_add$A@@0)) ($IsBox |r#0@@0| (|#$lseq| LinearSequence_i._default.lseq_add$A@@0)))) (= (|LinearSequence__i.__default.lseq__add#requires| LinearSequence_i._default.lseq_add$A@@0 |l#0@@20| |r#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |4781|
 :pattern ( (|LinearSequence__i.__default.lseq__add#requires| LinearSequence_i._default.lseq_add$A@@0 |l#0@@20| |r#0@@0|))
)))
(assert (forall ((arg0@@489 T@U) (arg1@@204 T@U) (arg2@@99 Int) ) (! (= (type (LinearSequence__i.__default.lseq__peek arg0@@489 arg1@@204 arg2@@99)) BoxType)
 :qid |funType:LinearSequence__i.__default.lseq__peek|
 :pattern ( (LinearSequence__i.__default.lseq__peek arg0@@489 arg1@@204 arg2@@99))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_peek$A T@U) (|s#0@@43| T@U) (|i#0@@53| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_peek$A) TyType) (= (type |s#0@@43|) BoxType)) (or (|LinearSequence__i.__default.lseq__peek#canCall| LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@53|) (and (and ($IsBox |s#0@@43| (|#$lseq| LinearSequence_i._default.lseq_peek$A)) (and (INTERNAL_le_boogie 0 |i#0@@53|) (INTERNAL_lt_boogie |i#0@@53| 18446744073709551616))) (and (INTERNAL_lt_boogie |i#0@@53| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_peek$A |s#0@@43|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_peek$A |s#0@@43|) |i#0@@53|))))))) (and (= (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@53|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_peek$A |s#0@@43|) |i#0@@53|)) ($IsBox (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@53|) LinearSequence_i._default.lseq_peek$A)))
 :qid |unknown.0:0|
 :skolemid |4782|
 :pattern ( (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@53|))
))))
(assert (forall ((LinearSequence_i._default.lseq_peek$A@@0 T@U) (|s#0@@44| T@U) (|i#0@@54| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_peek$A@@0) TyType) (= (type |s#0@@44|) BoxType)) (and ($IsBox |s#0@@44| (|#$lseq| LinearSequence_i._default.lseq_peek$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@54|) (INTERNAL_lt_boogie |i#0@@54| 18446744073709551616)))) (= (|LinearSequence__i.__default.lseq__peek#requires| LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44| |i#0@@54|)  (and (INTERNAL_lt_boogie |i#0@@54| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44|) |i#0@@54|))))))
 :qid |unknown.0:0|
 :skolemid |4783|
 :pattern ( (|LinearSequence__i.__default.lseq__peek#requires| LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44| |i#0@@54|))
)))
(assert (forall ((arg0@@490 T@U) (arg1@@205 T@U) ) (! (= (type (LinearSequence__i.__default.lseq__free__fun arg0@@490 arg1@@205)) DatatypeTypeType)
 :qid |funType:LinearSequence__i.__default.lseq__free__fun|
 :pattern ( (LinearSequence__i.__default.lseq__free__fun arg0@@490 arg1@@205))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_free_fun$A T@U) (|s#0@@45| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_free_fun$A) TyType) (= (type |s#0@@45|) BoxType)) (or (|LinearSequence__i.__default.lseq__free__fun#canCall| LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) (and ($IsBox |s#0@@45| (|#$lseq| LinearSequence_i._default.lseq_free_fun$A)) (forall ((|i#0@@55| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@55|) (INTERNAL_lt_boogie |i#0@@55| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_free_fun$A |s#0@@45|))) (not (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) |i#0@@55|)))))
 :qid |LinearSequenceidfy.147:23|
 :skolemid |4789|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) |i#0@@55|)))
))))) ($Is (LinearSequence__i.__default.lseq__free__fun LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |4790|
 :pattern ( (LinearSequence__i.__default.lseq__free__fun LinearSequence_i._default.lseq_free_fun$A |s#0@@45|))
))))
(assert (forall ((LinearSequence_i._default.lseq_free_fun$A@@0 T@U) (|s#0@@46| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_free_fun$A@@0) TyType) (= (type |s#0@@46|) BoxType)) ($IsBox |s#0@@46| (|#$lseq| LinearSequence_i._default.lseq_free_fun$A@@0))) (= (|LinearSequence__i.__default.lseq__free__fun#requires| LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) (forall ((|i#1@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@4|) (INTERNAL_lt_boogie |i#1@@4| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|))) (not (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) |i#1@@4|)))))
 :qid |LinearSequenceidfy.147:23|
 :skolemid |4791|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) |i#1@@4|)))
))))
 :qid |unknown.0:0|
 :skolemid |4792|
 :pattern ( (|LinearSequence__i.__default.lseq__free__fun#requires| LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|))
)))
(assert (forall ((arg0@@491 T@U) (arg1@@206 T@U) (arg2@@100 Int) ) (! (= (type (LinearSequence__i.__default.lseq__take__fun arg0@@491 arg1@@206 arg2@@100)) DatatypeTypeType)
 :qid |funType:LinearSequence__i.__default.lseq__take__fun|
 :pattern ( (LinearSequence__i.__default.lseq__take__fun arg0@@491 arg1@@206 arg2@@100))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_take_fun$A T@U) (|s1#0@@5| T@U) (|i#0@@56| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_take_fun$A) TyType) (= (type |s1#0@@5|) BoxType)) (or (|LinearSequence__i.__default.lseq__take__fun#canCall| LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|) (and (and ($IsBox |s1#0@@5| (|#$lseq| LinearSequence_i._default.lseq_take_fun$A)) (and (INTERNAL_le_boogie 0 |i#0@@56|) (INTERNAL_lt_boogie |i#0@@56| 18446744073709551616))) (and (INTERNAL_lt_boogie |i#0@@56| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@56|))))))) (and (and (and (= (_System.Tuple2OLL._1 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|)) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@56|)) (|Seq#Equal| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|))) (|Seq#Update| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@56| ($Box (Lit (bool_2_U false)))))) (forall ((|j#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |j#0|) (and (INTERNAL_lt_boogie |j#0| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|)) (not (= |j#0| |i#0@@56|)))) (= (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|))) |j#0|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |j#0|)))
 :qid |LinearSequenceidfy.200:22|
 :skolemid |4801|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |j#0|))
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|))) |j#0|))
))) ($Is (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|) (Tclass._System.Tuple2OLL (|#$lseq| LinearSequence_i._default.lseq_take_fun$A) LinearSequence_i._default.lseq_take_fun$A))))
 :qid |unknown.0:0|
 :skolemid |4802|
 :pattern ( (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@56|))
))))
(assert (forall ((LinearSequence_i._default.lseq_take_fun$A@@0 T@U) (|s1#0@@6| T@U) (|i#0@@57| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_take_fun$A@@0) TyType) (= (type |s1#0@@6|) BoxType)) (and ($IsBox |s1#0@@6| (|#$lseq| LinearSequence_i._default.lseq_take_fun$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@57|) (INTERNAL_lt_boogie |i#0@@57| 18446744073709551616)))) (= (|LinearSequence__i.__default.lseq__take__fun#requires| LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6| |i#0@@57|)  (and (INTERNAL_lt_boogie |i#0@@57| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6|) |i#0@@57|))))))
 :qid |unknown.0:0|
 :skolemid |4803|
 :pattern ( (|LinearSequence__i.__default.lseq__take__fun#requires| LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6| |i#0@@57|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A T@U) (|s#0@@47| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A) TyType) (= (type |s#0@@47|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A |s#0@@47|) ($IsBox |s#0@@47| (|#$lseq| LinearSequence_i._default.lseq_full$A)))) true)
 :qid |unknown.0:0|
 :skolemid |4806|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A |s#0@@47|))
))))
(assert (forall ((LinearSequence_i._default.lseq_full$A@@0 T@U) (|s#0@@48| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@0) TyType) (= (type |s#0@@48|) BoxType)) ($IsBox |s#0@@48| (|#$lseq| LinearSequence_i._default.lseq_full$A@@0))) (= (|LinearSequence__i.__default.lseq__full#requires| LinearSequence_i._default.lseq_full$A@@0 |s#0@@48|) true))
 :qid |unknown.0:0|
 :skolemid |4807|
 :pattern ( (|LinearSequence__i.__default.lseq__full#requires| LinearSequence_i._default.lseq_full$A@@0 |s#0@@48|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A@@1 T@U) (|s#0@@49| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@1) TyType) (= (type |s#0@@49|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) ($IsBox |s#0@@49| (|#$lseq| LinearSequence_i._default.lseq_full$A@@1)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@58| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@58|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|)) (=> (and (INTERNAL_le_boogie 0 |i#0@@58|) (INTERNAL_lt_boogie |i#0@@58| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))) (|LinearSequence__i.__default.operator_kin_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49| |i#0@@58|)))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |4809|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@58|)))
))) (= (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|)  (and true (forall ((|i#0@@59| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@59|) (INTERNAL_lt_boogie |i#0@@59| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@59|))))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |4808|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@59|)))
))))))
 :qid |unknown.0:0|
 :skolemid |4810|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A@@2 T@U) (|s#0@@50| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@2) TyType) (= (type |s#0@@50|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)) ($IsBox |s#0@@50| (|#$lseq| LinearSequence_i._default.lseq_full$A@@2)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@5| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#1@@5|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))) (=> (and (INTERNAL_le_boogie 0 |i#1@@5|) (INTERNAL_lt_boogie |i#1@@5| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))) (|LinearSequence__i.__default.operator_kin_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|) |i#1@@5|)))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |4812|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 |s#0@@50|) |i#1@@5|)))
))) (= (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))  (and true (forall ((|i#1@@6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@6|) (INTERNAL_lt_boogie |i#1@@6| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))) |i#1@@6|))))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |4811|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 |s#0@@50|) |i#1@@6|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4813|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))
))))
(assert (= (type Tclass.Sequences.__default) TyType))
(assert (= (Tag Tclass.Sequences.__default) Tagclass.Sequences.__default))
(assert (= (TagFamily Tclass.Sequences.__default) tytagFamily$_default))
(assert (forall ((bx@@159 T@U) ) (!  (=> (and (= (type bx@@159) BoxType) ($IsBox bx@@159 Tclass.Sequences.__default)) (and (= ($Box ($Unbox refType bx@@159)) bx@@159) ($Is ($Unbox refType bx@@159) Tclass.Sequences.__default)))
 :qid |unknown.0:0|
 :skolemid |4847|
 :pattern ( ($IsBox bx@@159 Tclass.Sequences.__default))
)))
(assert (forall (($o@@39 T@U) ) (!  (=> (= (type $o@@39) refType) (= ($Is $o@@39 Tclass.Sequences.__default)  (or (= $o@@39 null) (= (dtype $o@@39) Tclass.Sequences.__default))))
 :qid |unknown.0:0|
 :skolemid |4848|
 :pattern ( ($Is $o@@39 Tclass.Sequences.__default))
)))
(assert (forall (($o@@40 T@U) ($h@@90 T@U) ) (!  (=> (and (= (type $o@@40) refType) (= (type $h@@90) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@40 Tclass.Sequences.__default $h@@90)  (or (= $o@@40 null) (U_2_bool (MapType1Select (MapType0Select $h@@90 $o@@40) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4849|
 :pattern ( ($IsAlloc $o@@40 Tclass.Sequences.__default $h@@90))
)))
(assert (forall ((arg0@@492 T@U) (arg1@@207 T@U) ) (! (= (type (Sequences.__default.Last arg0@@492 arg1@@207)) BoxType)
 :qid |funType:Sequences.__default.Last|
 :pattern ( (Sequences.__default.Last arg0@@492 arg1@@207))
)))
(assert  (=> true (forall ((Sequences._default.Last$E T@U) (|run#0@@7| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E) TyType) (= (type |run#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E |run#0@@7|) (and ($Is |run#0@@7| (TSeq Sequences._default.Last$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@7|) 0)))) ($IsBox (Sequences.__default.Last Sequences._default.Last$E |run#0@@7|) Sequences._default.Last$E))
 :qid |unknown.0:0|
 :skolemid |4850|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E |run#0@@7|))
))))
(assert (forall ((Sequences._default.Last$E@@0 T@U) (|run#0@@8| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@0) TyType) (= (type |run#0@@8|) (SeqType BoxType))) ($Is |run#0@@8| (TSeq Sequences._default.Last$E@@0))) (= (|Sequences.__default.Last#requires| Sequences._default.Last$E@@0 |run#0@@8|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@8|) 0)))
 :qid |unknown.0:0|
 :skolemid |4851|
 :pattern ( (|Sequences.__default.Last#requires| Sequences._default.Last$E@@0 |run#0@@8|))
)))
(assert  (=> true (forall ((Sequences._default.Last$E@@1 T@U) (|run#0@@9| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@1) TyType) (= (type |run#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E@@1 |run#0@@9|) (and ($Is |run#0@@9| (TSeq Sequences._default.Last$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@9|) 0)))) (= (Sequences.__default.Last Sequences._default.Last$E@@1 |run#0@@9|) (|Seq#Index| |run#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@9|) 1))))
 :qid |unknown.0:0|
 :skolemid |4852|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E@@1 |run#0@@9|))
))))
(assert  (=> true (forall ((Sequences._default.Last$E@@2 T@U) (|run#0@@10| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@2) TyType) (= (type |run#0@@10|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E@@2 (Lit |run#0@@10|)) (and ($Is |run#0@@10| (TSeq Sequences._default.Last$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@10|)) 0)))) (= (Sequences.__default.Last Sequences._default.Last$E@@2 (Lit |run#0@@10|)) (|Seq#Index| (Lit |run#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@10|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4853|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E@@2 (Lit |run#0@@10|)))
))))
(assert (forall ((arg0@@493 T@U) (arg1@@208 T@U) ) (! (= (type (Sequences.__default.FirstOpt arg0@@493 arg1@@208)) DatatypeTypeType)
 :qid |funType:Sequences.__default.FirstOpt|
 :pattern ( (Sequences.__default.FirstOpt arg0@@493 arg1@@208))
)))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E T@U) (|run#0@@11| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E) TyType) (= (type |run#0@@11|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E |run#0@@11|) ($Is |run#0@@11| (TSeq Sequences._default.FirstOpt$E)))) ($Is (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E |run#0@@11|) (Tclass.Options.Option Sequences._default.FirstOpt$E)))
 :qid |unknown.0:0|
 :skolemid |4854|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E |run#0@@11|))
))))
(assert (forall ((Sequences._default.FirstOpt$E@@0 T@U) (|run#0@@12| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@0) TyType) (= (type |run#0@@12|) (SeqType BoxType))) ($Is |run#0@@12| (TSeq Sequences._default.FirstOpt$E@@0))) (= (|Sequences.__default.FirstOpt#requires| Sequences._default.FirstOpt$E@@0 |run#0@@12|) true))
 :qid |unknown.0:0|
 :skolemid |4855|
 :pattern ( (|Sequences.__default.FirstOpt#requires| Sequences._default.FirstOpt$E@@0 |run#0@@12|))
)))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E@@1 T@U) (|run#0@@13| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@1) TyType) (= (type |run#0@@13|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E@@1 |run#0@@13|) ($Is |run#0@@13| (TSeq Sequences._default.FirstOpt$E@@1)))) (= (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@1 |run#0@@13|) (ite (= (|Seq#Length| |run#0@@13|) (LitInt 0)) |#Options.Option.None| (|#Options.Option.Some| (|Seq#Index| |run#0@@13| (LitInt 0))))))
 :qid |unknown.0:0|
 :skolemid |4856|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@1 |run#0@@13|))
))))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E@@2 T@U) (|run#0@@14| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@2) TyType) (= (type |run#0@@14|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)) ($Is |run#0@@14| (TSeq Sequences._default.FirstOpt$E@@2)))) (= (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)) (ite (= (|Seq#Length| (Lit |run#0@@14|)) (LitInt 0)) |#Options.Option.None| (|#Options.Option.Some| (|Seq#Index| (Lit |run#0@@14|) (LitInt 0))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4857|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)))
))))
(assert (forall ((arg0@@494 T@U) (arg1@@209 T@U) ) (! (= (type (Sequences.__default.DropLast arg0@@494 arg1@@209)) (SeqType BoxType))
 :qid |funType:Sequences.__default.DropLast|
 :pattern ( (Sequences.__default.DropLast arg0@@494 arg1@@209))
)))
(assert  (=> true (forall ((Sequences._default.DropLast$E T@U) (|run#0@@15| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E) TyType) (= (type |run#0@@15|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E |run#0@@15|) (and ($Is |run#0@@15| (TSeq Sequences._default.DropLast$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@15|) 0)))) ($Is (Sequences.__default.DropLast Sequences._default.DropLast$E |run#0@@15|) (TSeq Sequences._default.DropLast$E)))
 :qid |unknown.0:0|
 :skolemid |4858|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E |run#0@@15|))
))))
(assert (forall ((Sequences._default.DropLast$E@@0 T@U) (|run#0@@16| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@0) TyType) (= (type |run#0@@16|) (SeqType BoxType))) ($Is |run#0@@16| (TSeq Sequences._default.DropLast$E@@0))) (= (|Sequences.__default.DropLast#requires| Sequences._default.DropLast$E@@0 |run#0@@16|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@16|) 0)))
 :qid |unknown.0:0|
 :skolemid |4859|
 :pattern ( (|Sequences.__default.DropLast#requires| Sequences._default.DropLast$E@@0 |run#0@@16|))
)))
(assert  (=> true (forall ((Sequences._default.DropLast$E@@1 T@U) (|run#0@@17| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@1) TyType) (= (type |run#0@@17|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E@@1 |run#0@@17|) (and ($Is |run#0@@17| (TSeq Sequences._default.DropLast$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@17|) 0)))) (= (Sequences.__default.DropLast Sequences._default.DropLast$E@@1 |run#0@@17|) (|Seq#Take| |run#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@17|) 1))))
 :qid |unknown.0:0|
 :skolemid |4860|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E@@1 |run#0@@17|))
))))
(assert  (=> true (forall ((Sequences._default.DropLast$E@@2 T@U) (|run#0@@18| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@2) TyType) (= (type |run#0@@18|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)) (and ($Is |run#0@@18| (TSeq Sequences._default.DropLast$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@18|)) 0)))) (= (Sequences.__default.DropLast Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)) (|Seq#Take| (Lit |run#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@18|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4861|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)))
))))
(assert (forall ((arg0@@495 T@U) (arg1@@210 T@U) ) (! (= (type (Sequences.__default.Set arg0@@495 arg1@@210)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.Set|
 :pattern ( (Sequences.__default.Set arg0@@495 arg1@@210))
)))
(assert  (=> true (forall ((Sequences._default.Set$T T@U) (|run#0@@19| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T) TyType) (= (type |run#0@@19|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T |run#0@@19|) ($Is |run#0@@19| (TSeq Sequences._default.Set$T)))) ($Is (Sequences.__default.Set Sequences._default.Set$T |run#0@@19|) (TSet Sequences._default.Set$T)))
 :qid |unknown.0:0|
 :skolemid |4862|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T |run#0@@19|))
))))
(assert (forall ((Sequences._default.Set$T@@0 T@U) (|run#0@@20| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@0) TyType) (= (type |run#0@@20|) (SeqType BoxType))) ($Is |run#0@@20| (TSeq Sequences._default.Set$T@@0))) (= (|Sequences.__default.Set#requires| Sequences._default.Set$T@@0 |run#0@@20|) true))
 :qid |unknown.0:0|
 :skolemid |4863|
 :pattern ( (|Sequences.__default.Set#requires| Sequences._default.Set$T@@0 |run#0@@20|))
)))
(assert  (=> true (forall ((Sequences._default.Set$T@@1 T@U) (|run#0@@21| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@1) TyType) (= (type |run#0@@21|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T@@1 |run#0@@21|) ($Is |run#0@@21| (TSeq Sequences._default.Set$T@@1)))) (= (Sequences.__default.Set Sequences._default.Set$T@@1 |run#0@@21|) (|lambda#153| Sequences._default.Set$T@@1 (|MultiSet#FromSeq| |run#0@@21|) 0)))
 :qid |unknown.0:0|
 :skolemid |4864|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T@@1 |run#0@@21|))
))))
(assert  (=> true (forall ((Sequences._default.Set$T@@2 T@U) (|run#0@@22| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@2) TyType) (= (type |run#0@@22|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T@@2 (Lit |run#0@@22|)) ($Is |run#0@@22| (TSeq Sequences._default.Set$T@@2)))) (= (Sequences.__default.Set Sequences._default.Set$T@@2 (Lit |run#0@@22|)) (|lambda#153| Sequences._default.Set$T@@2 (|MultiSet#FromSeq| (Lit |run#0@@22|)) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4865|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T@@2 (Lit |run#0@@22|)))
))))
(assert (forall ((arg0@@496 T@U) (arg1@@211 T@U) ) (! (= (type (Sequences.__default.ISet arg0@@496 arg1@@211)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.ISet|
 :pattern ( (Sequences.__default.ISet arg0@@496 arg1@@211))
)))
(assert  (=> true (forall ((Sequences._default.ISet$T T@U) (|run#0@@23| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T) TyType) (= (type |run#0@@23|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T |run#0@@23|) ($Is |run#0@@23| (TSeq Sequences._default.ISet$T)))) ($Is (Sequences.__default.ISet Sequences._default.ISet$T |run#0@@23|) (TISet Sequences._default.ISet$T)))
 :qid |unknown.0:0|
 :skolemid |4866|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T |run#0@@23|))
))))
(assert (forall ((Sequences._default.ISet$T@@0 T@U) (|run#0@@24| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@0) TyType) (= (type |run#0@@24|) (SeqType BoxType))) ($Is |run#0@@24| (TSeq Sequences._default.ISet$T@@0))) (= (|Sequences.__default.ISet#requires| Sequences._default.ISet$T@@0 |run#0@@24|) true))
 :qid |unknown.0:0|
 :skolemid |4867|
 :pattern ( (|Sequences.__default.ISet#requires| Sequences._default.ISet$T@@0 |run#0@@24|))
)))
(assert  (=> true (forall ((Sequences._default.ISet$T@@1 T@U) (|run#0@@25| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@1) TyType) (= (type |run#0@@25|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T@@1 |run#0@@25|) ($Is |run#0@@25| (TSeq Sequences._default.ISet$T@@1)))) (= (Sequences.__default.ISet Sequences._default.ISet$T@@1 |run#0@@25|) (|lambda#153| Sequences._default.ISet$T@@1 (|MultiSet#FromSeq| |run#0@@25|) 0)))
 :qid |unknown.0:0|
 :skolemid |4868|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T@@1 |run#0@@25|))
))))
(assert  (=> true (forall ((Sequences._default.ISet$T@@2 T@U) (|run#0@@26| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@2) TyType) (= (type |run#0@@26|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T@@2 (Lit |run#0@@26|)) ($Is |run#0@@26| (TSeq Sequences._default.ISet$T@@2)))) (= (Sequences.__default.ISet Sequences._default.ISet$T@@2 (Lit |run#0@@26|)) (|lambda#153| Sequences._default.ISet$T@@2 (|MultiSet#FromSeq| (Lit |run#0@@26|)) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4869|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T@@2 (Lit |run#0@@26|)))
))))
(assert (forall ((Sequences._default.NoDupes$T T@U) ($ly@@21 T@U) (|a#0@@21| T@U) ) (!  (=> (and (and (= (type Sequences._default.NoDupes$T) TyType) (= (type $ly@@21) LayerTypeType)) (= (type |a#0@@21|) (SeqType BoxType))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T ($LS $ly@@21) |a#0@@21|) (Sequences.__default.NoDupes Sequences._default.NoDupes$T $ly@@21 |a#0@@21|)))
 :qid |unknown.0:0|
 :skolemid |4870|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T ($LS $ly@@21) |a#0@@21|))
)))
(assert (forall ((Sequences._default.NoDupes$T@@0 T@U) ($ly@@22 T@U) (|a#0@@22| T@U) ) (!  (=> (and (and (= (type Sequences._default.NoDupes$T@@0) TyType) (= (type $ly@@22) LayerTypeType)) (= (type |a#0@@22|) (SeqType BoxType))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 $ly@@22 |a#0@@22|) (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 $LZ |a#0@@22|)))
 :qid |unknown.0:0|
 :skolemid |4871|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 (AsFuelBottom $ly@@22) |a#0@@22|))
)))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@1 T@U) ($ly@@23 T@U) (|a#0@@23| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@1) TyType) (= (type $ly@@23) LayerTypeType)) (= (type |a#0@@23|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@1 |a#0@@23|) ($Is |a#0@@23| (TSeq Sequences._default.NoDupes$T@@1)))) true)
 :qid |unknown.0:0|
 :skolemid |4872|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@1 $ly@@23 |a#0@@23|))
))))
(assert (forall ((Sequences._default.NoDupes$T@@2 T@U) ($ly@@24 T@U) (|a#0@@24| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@2) TyType) (= (type $ly@@24) LayerTypeType)) (= (type |a#0@@24|) (SeqType BoxType))) ($Is |a#0@@24| (TSeq Sequences._default.NoDupes$T@@2))) (= (|Sequences.__default.NoDupes#requires| Sequences._default.NoDupes$T@@2 $ly@@24 |a#0@@24|) true))
 :qid |unknown.0:0|
 :skolemid |4873|
 :pattern ( (|Sequences.__default.NoDupes#requires| Sequences._default.NoDupes$T@@2 $ly@@24 |a#0@@24|))
)))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@3 T@U) ($ly@@25 T@U) (|a#0@@25| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@3) TyType) (= (type $ly@@25) LayerTypeType)) (= (type |a#0@@25|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@3 |a#0@@25|) ($Is |a#0@@25| (TSeq Sequences._default.NoDupes$T@@3)))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@3 ($LS $ly@@25) |a#0@@25|) (forall ((|i#0@@60| Int) (|j#0@@0| Int) ) (!  (=> true (=> (and (and (and (INTERNAL_le_boogie 0 |i#0@@60|) (INTERNAL_lt_boogie |i#0@@60| (|Seq#Length| |a#0@@25|))) (and (INTERNAL_le_boogie 0 |j#0@@0|) (INTERNAL_lt_boogie |j#0@@0| (|Seq#Length| |a#0@@25|)))) (not (= |i#0@@60| |j#0@@0|))) (not (= (|Seq#Index| |a#0@@25| |i#0@@60|) (|Seq#Index| |a#0@@25| |j#0@@0|)))))
 :qid |Sequencesidfy.70:13|
 :skolemid |4874|
 :pattern ( (|Seq#Index| |a#0@@25| |j#0@@0|) (|Seq#Index| |a#0@@25| |i#0@@60|))
))))
 :qid |unknown.0:0|
 :skolemid |4875|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@3 ($LS $ly@@25) |a#0@@25|))
))))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@4 T@U) ($ly@@26 T@U) (|a#0@@26| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@4) TyType) (= (type $ly@@26) LayerTypeType)) (= (type |a#0@@26|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@4 (Lit |a#0@@26|)) ($Is |a#0@@26| (TSeq Sequences._default.NoDupes$T@@4)))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@4 ($LS $ly@@26) (Lit |a#0@@26|)) (forall ((|i#1@@7| Int) (|j#1| Int) ) (!  (=> true (=> (and (and (and (INTERNAL_le_boogie 0 |i#1@@7|) (INTERNAL_lt_boogie |i#1@@7| (|Seq#Length| (Lit |a#0@@26|)))) (and (INTERNAL_le_boogie 0 |j#1|) (INTERNAL_lt_boogie |j#1| (|Seq#Length| (Lit |a#0@@26|))))) (not (= |i#1@@7| |j#1|))) (not (= (|Seq#Index| (Lit |a#0@@26|) |i#1@@7|) (|Seq#Index| (Lit |a#0@@26|) |j#1|)))))
 :qid |Sequencesidfy.70:13|
 :skolemid |4876|
 :pattern ( (|Seq#Index| |a#0@@26| |j#1|) (|Seq#Index| |a#0@@26| |i#1@@7|))
))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4877|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@4 ($LS $ly@@26) (Lit |a#0@@26|)))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T T@U) (|s#0@@51| T@U) (|e#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IndexOf$T) TyType) (= (type |s#0@@51|) (SeqType BoxType))) (= (type |e#0|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T |s#0@@51| |e#0|) (and (and ($Is |s#0@@51| (TSeq Sequences._default.IndexOf$T)) ($IsBox |e#0| Sequences._default.IndexOf$T)) (|Seq#Contains| |s#0@@51| |e#0|)))) (and (and (INTERNAL_le_boogie 0 (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|)) (INTERNAL_lt_boogie (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|) (|Seq#Length| |s#0@@51|))) (= (|Seq#Index| |s#0@@51| (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|)) |e#0|)))
 :qid |unknown.0:0|
 :skolemid |4878|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|))
))))
(assert (forall ((Sequences._default.IndexOf$T@@0 T@U) ($Heap@@11 T@U) (|s#0@@52| T@U) (|e#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@0) TyType) (= (type $Heap@@11) (MapType0Type refType MapType1Type))) (= (type |s#0@@52|) (SeqType BoxType))) (= (type |e#0@@0|) BoxType)) (and (and ($IsGoodHeap $Heap@@11) ($Is |s#0@@52| (TSeq Sequences._default.IndexOf$T@@0))) ($IsBox |e#0@@0| Sequences._default.IndexOf$T@@0))) (= (|Sequences.__default.IndexOf#requires| Sequences._default.IndexOf$T@@0 |s#0@@52| |e#0@@0|) (|Seq#Contains| |s#0@@52| |e#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |4879|
 :pattern ( (|Sequences.__default.IndexOf#requires| Sequences._default.IndexOf$T@@0 |s#0@@52| |e#0@@0|) ($IsGoodHeap $Heap@@11))
)))
(assert (forall ((Sequences._default.IndexOf$T@@1 T@U) (s@@49 T@U) (e T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IndexOf$T@@1) TyType) (= (type s@@49) (SeqType BoxType))) (= (type e) BoxType)) (|$let#0$canCall| Sequences._default.IndexOf$T@@1 s@@49 e)) (and (and (INTERNAL_le_boogie 0 (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e)) (INTERNAL_lt_boogie (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e) (|Seq#Length| s@@49))) (= (|Seq#Index| s@@49 (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e)) e)))
 :qid |Sequencesidfy.121:5|
 :skolemid |4880|
 :pattern ( (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e))
)))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@2 T@U) ($Heap@@12 T@U) (|s#0@@53| T@U) (|e#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@2) TyType) (= (type $Heap@@12) (MapType0Type refType MapType1Type))) (= (type |s#0@@53|) (SeqType BoxType))) (= (type |e#0@@1|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (and (and (and ($IsGoodHeap $Heap@@12) ($Is |s#0@@53| (TSeq Sequences._default.IndexOf$T@@2))) ($IsBox |e#0@@1| Sequences._default.IndexOf$T@@2)) (|Seq#Contains| |s#0@@53| |e#0@@1|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (let ((|i#0@@61| (|$let#0_i| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|)))
|i#0@@61|))))
 :qid |unknown.0:0|
 :skolemid |4881|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) ($IsGoodHeap $Heap@@12))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@3 T@U) ($Heap@@13 T@U) (|s#0@@54| T@U) (|e#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@3) TyType) (= (type $Heap@@13) (MapType0Type refType MapType1Type))) (= (type |s#0@@54|) (SeqType BoxType))) (= (type |e#0@@2|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (and (and (and ($IsGoodHeap $Heap@@13) ($Is |s#0@@54| (TSeq Sequences._default.IndexOf$T@@3))) ($IsBox |e#0@@2| Sequences._default.IndexOf$T@@3)) (|Seq#Contains| |s#0@@54| |e#0@@2|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (let ((|i#1@@8| (|$let#0_i| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|)))
|i#1@@8|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4882|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) ($IsGoodHeap $Heap@@13))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@4 T@U) ($Heap@@14 T@U) (|s#0@@55| T@U) (|e#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@4) TyType) (= (type $Heap@@14) (MapType0Type refType MapType1Type))) (= (type |s#0@@55|) (SeqType BoxType))) (= (type |e#0@@3|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (and (and (and ($IsGoodHeap $Heap@@14) ($Is |s#0@@55| (TSeq Sequences._default.IndexOf$T@@4))) ($IsBox |e#0@@3| Sequences._default.IndexOf$T@@4)) (|Seq#Contains| |s#0@@55| |e#0@@3|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (let ((|i#2| (|$let#0_i| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|))))
|i#2|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4883|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) ($IsGoodHeap $Heap@@14))
))))
(assert (forall ((arg0@@497 T@U) (arg1@@212 Int) ) (! (= (type (Sequences.__default.Range arg0@@497 arg1@@212)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Range|
 :pattern ( (Sequences.__default.Range arg0@@497 arg1@@212))
)))
(assert (forall (($ly@@27 T@U) (|n#0| Int) ) (!  (=> (= (type $ly@@27) LayerTypeType) (= (Sequences.__default.Range ($LS $ly@@27) |n#0|) (Sequences.__default.Range $ly@@27 |n#0|)))
 :qid |Sequencesidfy.125:22|
 :skolemid |4884|
 :pattern ( (Sequences.__default.Range ($LS $ly@@27) |n#0|))
)))
(assert (forall (($ly@@28 T@U) (|n#0@@0| Int) ) (!  (=> (= (type $ly@@28) LayerTypeType) (= (Sequences.__default.Range $ly@@28 |n#0@@0|) (Sequences.__default.Range $LZ |n#0@@0|)))
 :qid |Sequencesidfy.125:22|
 :skolemid |4885|
 :pattern ( (Sequences.__default.Range (AsFuelBottom $ly@@28) |n#0@@0|))
)))
(assert  (=> true (forall (($ly@@29 T@U) (|n#0@@1| Int) ) (!  (=> (and (= (type $ly@@29) LayerTypeType) (or (|Sequences.__default.Range#canCall| |n#0@@1|) (INTERNAL_ge_boogie |n#0@@1| 0))) (and (and (= (|Seq#Length| (Sequences.__default.Range $ly@@29 |n#0@@1|)) |n#0@@1|) (forall ((|i#0@@62| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@62|) (INTERNAL_lt_boogie |i#0@@62| |n#0@@1|)) (= (U_2_int ($Unbox intType (|Seq#Index| (Sequences.__default.Range $ly@@29 |n#0@@1|) |i#0@@62|))) |i#0@@62|))
 :qid |Sequencesidfy.128:20|
 :skolemid |4886|
 :pattern ( ($Unbox intType (|Seq#Index| (Sequences.__default.Range $ly@@29 |n#0@@1|) |i#0@@62|)))
))) ($Is (Sequences.__default.Range $ly@@29 |n#0@@1|) (TSeq TInt))))
 :qid |Sequencesidfy.125:22|
 :skolemid |4887|
 :pattern ( (Sequences.__default.Range $ly@@29 |n#0@@1|))
))))
(assert (forall (($ly@@30 T@U) (|n#0@@2| Int) ) (!  (=> (= (type $ly@@30) LayerTypeType) (= (|Sequences.__default.Range#requires| $ly@@30 |n#0@@2|) (INTERNAL_ge_boogie |n#0@@2| 0)))
 :qid |Sequencesidfy.125:22|
 :skolemid |4888|
 :pattern ( (|Sequences.__default.Range#requires| $ly@@30 |n#0@@2|))
)))
(assert  (=> true (forall (($ly@@31 T@U) (|n#0@@3| Int) ) (!  (=> (and (= (type $ly@@31) LayerTypeType) (or (|Sequences.__default.Range#canCall| |n#0@@3|) (INTERNAL_ge_boogie |n#0@@3| 0))) (and (=> (not (= |n#0@@3| (LitInt 0))) (|Sequences.__default.Range#canCall| (INTERNAL_sub_boogie |n#0@@3| 1))) (= (Sequences.__default.Range ($LS $ly@@31) |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Range $ly@@31 (INTERNAL_sub_boogie |n#0@@3| 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (INTERNAL_sub_boogie |n#0@@3| 1)))))))))
 :qid |Sequencesidfy.125:22|
 :skolemid |4889|
 :pattern ( (Sequences.__default.Range ($LS $ly@@31) |n#0@@3|))
))))
(assert  (=> true (forall (($ly@@32 T@U) (|n#0@@4| Int) ) (!  (=> (and (= (type $ly@@32) LayerTypeType) (or (|Sequences.__default.Range#canCall| (LitInt |n#0@@4|)) (INTERNAL_ge_boogie |n#0@@4| 0))) (and (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|Sequences.__default.Range#canCall| (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))) (= (Sequences.__default.Range ($LS $ly@@32) (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Range ($LS $ly@@32) (LitInt (INTERNAL_sub_boogie |n#0@@4| 1))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie |n#0@@4| 1))))))))))
 :qid |Sequencesidfy.125:22|
 :weight 3
 :skolemid |4890|
 :pattern ( (Sequences.__default.Range ($LS $ly@@32) (LitInt |n#0@@4|)))
))))
(assert (forall ((arg0@@498 T@U) (arg1@@213 T@U) (arg2@@101 T@U) (arg3@@50 T@U) ) (! (= (type (Sequences.__default.Apply arg0@@498 arg1@@213 arg2@@101 arg3@@50)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Apply|
 :pattern ( (Sequences.__default.Apply arg0@@498 arg1@@213 arg2@@101 arg3@@50))
)))
(assert  (=> true (forall ((Sequences._default.Apply$E T@U) (Sequences._default.Apply$R T@U) ($Heap@@15 T@U) (|f#0@@75| T@U) (|run#0@@27| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E) TyType) (= (type Sequences._default.Apply$R) TyType)) (= (type $Heap@@15) (MapType0Type refType MapType1Type))) (= (type |f#0@@75|) HandleTypeType)) (= (type |run#0@@27|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) (and (and (and ($IsGoodHeap $Heap@@15) ($Is |f#0@@75| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E Sequences._default.Apply$R))) ($Is |run#0@@27| (TSeq Sequences._default.Apply$E))) (forall ((|i#0@@63| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@63|) (INTERNAL_lt_boogie |i#0@@63| (|Seq#Length| |run#0@@27|))) (Requires1 Sequences._default.Apply$E Sequences._default.Apply$R $Heap@@15 |f#0@@75| (|Seq#Index| |run#0@@27| |i#0@@63|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |4891|
 :pattern ( (|Seq#Index| |run#0@@27| |i#0@@63|))
))))) (and (and (= (|Seq#Length| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|)) (|Seq#Length| |run#0@@27|)) (forall ((|i#1@@9| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@9|) (INTERNAL_lt_boogie |i#1@@9| (|Seq#Length| |run#0@@27|))) (= (|Seq#Index| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) |i#1@@9|) (Apply1 Sequences._default.Apply$E Sequences._default.Apply$R $Heap@@15 |f#0@@75| (|Seq#Index| |run#0@@27| |i#1@@9|)))))
 :qid |Sequencesidfy.136:20|
 :skolemid |4892|
 :pattern ( (|Seq#Index| |run#0@@27| |i#1@@9|))
 :pattern ( (|Seq#Index| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) |i#1@@9|))
))) ($Is (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) (TSeq Sequences._default.Apply$R))))
 :qid |unknown.0:0|
 :skolemid |4893|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) ($IsGoodHeap $Heap@@15))
))))
(assert (forall ((Sequences._default.Apply$E@@0 T@U) (Sequences._default.Apply$R@@0 T@U) ($Heap@@16 T@U) (|f#0@@76| T@U) (|run#0@@28| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@0) TyType) (= (type Sequences._default.Apply$R@@0) TyType)) (= (type $Heap@@16) (MapType0Type refType MapType1Type))) (= (type |f#0@@76|) HandleTypeType)) (= (type |run#0@@28|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@16) ($Is |f#0@@76| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0))) ($Is |run#0@@28| (TSeq Sequences._default.Apply$E@@0)))) (= (|Sequences.__default.Apply#requires| Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 |f#0@@76| |run#0@@28|) (forall ((|i#2@@0| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@0|) (INTERNAL_lt_boogie |i#2@@0| (|Seq#Length| |run#0@@28|))) (Requires1 Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 $Heap@@16 |f#0@@76| (|Seq#Index| |run#0@@28| |i#2@@0|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |4894|
 :pattern ( (|Seq#Index| |run#0@@28| |i#2@@0|))
))))
 :qid |unknown.0:0|
 :skolemid |4895|
 :pattern ( (|Sequences.__default.Apply#requires| Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 |f#0@@76| |run#0@@28|) ($IsGoodHeap $Heap@@16))
)))
(assert  (and (and (forall ((arg0@@499 T@U) (arg1@@214 T@U) (arg2@@102 T@U) (arg3@@51 T@U) ) (! (= (type (|lambda#161| arg0@@499 arg1@@214 arg2@@102 arg3@@51)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#161|
 :pattern ( (|lambda#161| arg0@@499 arg1@@214 arg2@@102 arg3@@51))
)) (forall ((arg0@@500 T@U) (arg1@@215 Int) (arg2@@103 Int) (arg3@@52 T@U) (arg4@@30 T@U) (arg5@@15 T@U) (arg6@@6 T@U) ) (! (= (type (|lambda#162| arg0@@500 arg1@@215 arg2@@103 arg3@@52 arg4@@30 arg5@@15 arg6@@6)) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))
 :qid |funType:lambda#162|
 :pattern ( (|lambda#162| arg0@@500 arg1@@215 arg2@@103 arg3@@52 arg4@@30 arg5@@15 arg6@@6))
))) (forall ((arg0@@501 T@U) (arg1@@216 Int) (arg2@@104 Int) (arg3@@53 T@U) (arg4@@31 T@U) (arg5@@16 T@U) (arg6@@7 T@U) (arg7@@3 T@U) (arg8@@3 T@U) (arg9@@1 T@U) (arg10@@1 T@U) ) (! (= (type (|lambda#164| arg0@@501 arg1@@216 arg2@@104 arg3@@53 arg4@@31 arg5@@16 arg6@@7 arg7@@3 arg8@@3 arg9@@1 arg10@@1)) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#164|
 :pattern ( (|lambda#164| arg0@@501 arg1@@216 arg2@@104 arg3@@53 arg4@@31 arg5@@16 arg6@@7 arg7@@3 arg8@@3 arg9@@1 arg10@@1))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@1 T@U) (Sequences._default.Apply$R@@1 T@U) ($Heap@@17 T@U) (|f#0@@77| T@U) (|run#0@@29| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@1) TyType) (= (type Sequences._default.Apply$R@@1) TyType)) (= (type $Heap@@17) (MapType0Type refType MapType1Type))) (= (type |f#0@@77|) HandleTypeType)) (= (type |run#0@@29|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (and (and (and ($IsGoodHeap $Heap@@17) ($Is |f#0@@77| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1))) ($Is |run#0@@29| (TSeq Sequences._default.Apply$E@@1))) (forall ((|i#2@@1| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@1|) (INTERNAL_lt_boogie |i#2@@1| (|Seq#Length| |run#0@@29|))) (Requires1 Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 $Heap@@17 |f#0@@77| (|Seq#Index| |run#0@@29| |i#2@@1|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |4894|
 :pattern ( (|Seq#Index| |run#0@@29| |i#2@@1|))
))))) (and (forall ((|$l#1#i#0@@1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@1|) (=> (INTERNAL_lt_boogie |$l#1#i#0@@1| (|Seq#Length| |run#0@@29|)) true))
 :qid |unknown.0:0|
 :skolemid |4897|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0@@1| (|Seq#Length| |run#0@@29|))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|Seq#Create| Sequences._default.Apply$R@@1 $Heap@@17 (|Seq#Length| |run#0@@29|) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#161| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|lambda#162| TInt 0 (|Seq#Length| |run#0@@29|) Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|lambda#164| Tclass._System.object? 0 (|Seq#Length| |run#0@@29|) Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :skolemid |4898|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) ($IsGoodHeap $Heap@@17))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@2 T@U) (Sequences._default.Apply$R@@2 T@U) ($Heap@@18 T@U) (|f#0@@78| T@U) (|run#0@@30| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@2) TyType) (= (type Sequences._default.Apply$R@@2) TyType)) (= (type $Heap@@18) (MapType0Type refType MapType1Type))) (= (type |f#0@@78|) HandleTypeType)) (= (type |run#0@@30|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (and (and (and ($IsGoodHeap $Heap@@18) ($Is |f#0@@78| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2))) ($Is |run#0@@30| (TSeq Sequences._default.Apply$E@@2))) (forall ((|i#4| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4|) (INTERNAL_lt_boogie |i#4| (|Seq#Length| (Lit |run#0@@30|)))) (Requires1 Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 $Heap@@18 |f#0@@78| (|Seq#Index| (Lit |run#0@@30|) |i#4|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |4899|
 :pattern ( (|Seq#Index| |run#0@@30| |i#4|))
))))) (and (forall ((|$l#3#i#0@@1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@1|) (=> (INTERNAL_lt_boogie |$l#3#i#0@@1| (|Seq#Length| (Lit |run#0@@30|))) true))
 :qid |unknown.0:0|
 :skolemid |4901|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0@@1| (|Seq#Length| (Lit |run#0@@30|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|Seq#Create| Sequences._default.Apply$R@@2 $Heap@@18 (|Seq#Length| (Lit |run#0@@30|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#161| Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|lambda#162| TInt 0 (|Seq#Length| (Lit |run#0@@30|)) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|lambda#164| Tclass._System.object? 0 (|Seq#Length| (Lit |run#0@@30|)) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| |run#0@@30|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4902|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) ($IsGoodHeap $Heap@@18))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@3 T@U) (Sequences._default.Apply$R@@3 T@U) ($Heap@@19 T@U) (|f#0@@79| T@U) (|run#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@3) TyType) (= (type Sequences._default.Apply$R@@3) TyType)) (= (type $Heap@@19) (MapType0Type refType MapType1Type))) (= (type |f#0@@79|) HandleTypeType)) (= (type |run#0@@31|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (and (and (and ($IsGoodHeap $Heap@@19) ($Is |f#0@@79| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3))) ($Is |run#0@@31| (TSeq Sequences._default.Apply$E@@3))) (forall ((|i#6| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#6|) (INTERNAL_lt_boogie |i#6| (|Seq#Length| (Lit |run#0@@31|)))) (Requires1 Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 $Heap@@19 (Lit |f#0@@79|) (|Seq#Index| (Lit |run#0@@31|) |i#6|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |4903|
 :pattern ( (|Seq#Index| |run#0@@31| |i#6|))
))))) (and (forall ((|$l#5#i#0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#5#i#0|) (=> (INTERNAL_lt_boogie |$l#5#i#0| (|Seq#Length| (Lit |run#0@@31|))) true))
 :qid |unknown.0:0|
 :skolemid |4905|
 :no-pattern (INTERNAL_lt_boogie |$l#5#i#0| (|Seq#Length| (Lit |run#0@@31|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|Seq#Create| Sequences._default.Apply$R@@3 $Heap@@19 (|Seq#Length| (Lit |run#0@@31|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#161| Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|lambda#162| TInt 0 (|Seq#Length| (Lit |run#0@@31|)) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|lambda#164| Tclass._System.object? 0 (|Seq#Length| (Lit |run#0@@31|)) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 |f#0@@79| |run#0@@31|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4906|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) ($IsGoodHeap $Heap@@19))
))))
(assert (forall ((arg0@@502 T@U) (arg1@@217 T@U) (arg2@@105 T@U) (arg3@@54 T@U) (arg4@@32 T@U) ) (! (= (type (Sequences.__default.ApplyOpaque arg0@@502 arg1@@217 arg2@@105 arg3@@54 arg4@@32)) (SeqType BoxType))
 :qid |funType:Sequences.__default.ApplyOpaque|
 :pattern ( (Sequences.__default.ApplyOpaque arg0@@502 arg1@@217 arg2@@105 arg3@@54 arg4@@32))
)))
(assert (forall ((Sequences._default.ApplyOpaque$E T@U) (Sequences._default.ApplyOpaque$R T@U) ($ly@@33 T@U) (|f#0@@80| T@U) (|run#0@@32| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.ApplyOpaque$E) TyType) (= (type Sequences._default.ApplyOpaque$R) TyType)) (= (type $ly@@33) LayerTypeType)) (= (type |f#0@@80|) HandleTypeType)) (= (type |run#0@@32|) (SeqType BoxType))) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R ($LS $ly@@33) |f#0@@80| |run#0@@32|) (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R $ly@@33 |f#0@@80| |run#0@@32|)))
 :qid |unknown.0:0|
 :skolemid |4907|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R ($LS $ly@@33) |f#0@@80| |run#0@@32|))
)))
(assert (forall ((Sequences._default.ApplyOpaque$E@@0 T@U) (Sequences._default.ApplyOpaque$R@@0 T@U) ($ly@@34 T@U) (|f#0@@81| T@U) (|run#0@@33| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@0) TyType) (= (type Sequences._default.ApplyOpaque$R@@0) TyType)) (= (type $ly@@34) LayerTypeType)) (= (type |f#0@@81|) HandleTypeType)) (= (type |run#0@@33|) (SeqType BoxType))) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 $ly@@34 |f#0@@81| |run#0@@33|) (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 $LZ |f#0@@81| |run#0@@33|)))
 :qid |unknown.0:0|
 :skolemid |4908|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 (AsFuelBottom $ly@@34) |f#0@@81| |run#0@@33|))
)))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@1 T@U) (Sequences._default.ApplyOpaque$R@@1 T@U) ($ly@@35 T@U) ($Heap@@20 T@U) (|f#0@@82| T@U) (|run#0@@34| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@1) TyType) (= (type Sequences._default.ApplyOpaque$R@@1) TyType)) (= (type $ly@@35) LayerTypeType)) (= (type $Heap@@20) (MapType0Type refType MapType1Type))) (= (type |f#0@@82|) HandleTypeType)) (= (type |run#0@@34|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 |f#0@@82| |run#0@@34|) (and (and (and ($IsGoodHeap $Heap@@20) ($Is |f#0@@82| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1))) ($Is |run#0@@34| (TSeq Sequences._default.ApplyOpaque$E@@1))) (forall ((|i#0@@64| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@64|) (INTERNAL_lt_boogie |i#0@@64| (|Seq#Length| |run#0@@34|))) (Requires1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $Heap@@20 |f#0@@82| (|Seq#Index| |run#0@@34| |i#0@@64|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |4909|
 :pattern ( (|Seq#Index| |run#0@@34| |i#0@@64|))
))))) (and (and (= (|Seq#Length| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@35 |f#0@@82| |run#0@@34|)) (|Seq#Length| |run#0@@34|)) (forall ((|i#1@@10| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@10|) (INTERNAL_lt_boogie |i#1@@10| (|Seq#Length| |run#0@@34|))) (= (|Seq#Index| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@35 |f#0@@82| |run#0@@34|) |i#1@@10|) (Apply1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $Heap@@20 |f#0@@82| (|Seq#Index| |run#0@@34| |i#1@@10|)))))
 :qid |Sequencesidfy.158:20|
 :skolemid |4910|
 :pattern ( (|Seq#Index| |run#0@@34| |i#1@@10|))
 :pattern ( (|Seq#Index| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@35 |f#0@@82| |run#0@@34|) |i#1@@10|))
))) ($Is (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@35 |f#0@@82| |run#0@@34|) (TSeq Sequences._default.ApplyOpaque$R@@1))))
 :qid |unknown.0:0|
 :skolemid |4911|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@35 |f#0@@82| |run#0@@34|) ($IsGoodHeap $Heap@@20))
))))
(assert (forall ((Sequences._default.ApplyOpaque$E@@2 T@U) (Sequences._default.ApplyOpaque$R@@2 T@U) ($ly@@36 T@U) ($Heap@@21 T@U) (|f#0@@83| T@U) (|run#0@@35| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@2) TyType) (= (type Sequences._default.ApplyOpaque$R@@2) TyType)) (= (type $ly@@36) LayerTypeType)) (= (type $Heap@@21) (MapType0Type refType MapType1Type))) (= (type |f#0@@83|) HandleTypeType)) (= (type |run#0@@35|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@21) ($Is |f#0@@83| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2))) ($Is |run#0@@35| (TSeq Sequences._default.ApplyOpaque$E@@2)))) (= (|Sequences.__default.ApplyOpaque#requires| Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $ly@@36 |f#0@@83| |run#0@@35|) (forall ((|i#2@@2| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@2|) (INTERNAL_lt_boogie |i#2@@2| (|Seq#Length| |run#0@@35|))) (Requires1 Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $Heap@@21 |f#0@@83| (|Seq#Index| |run#0@@35| |i#2@@2|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |4912|
 :pattern ( (|Seq#Index| |run#0@@35| |i#2@@2|))
))))
 :qid |unknown.0:0|
 :skolemid |4913|
 :pattern ( (|Sequences.__default.ApplyOpaque#requires| Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $ly@@36 |f#0@@83| |run#0@@35|) ($IsGoodHeap $Heap@@21))
)))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@3 T@U) (Sequences._default.ApplyOpaque$R@@3 T@U) ($ly@@37 T@U) ($Heap@@22 T@U) (|f#0@@84| T@U) (|run#0@@36| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@3) TyType) (= (type Sequences._default.ApplyOpaque$R@@3) TyType)) (= (type $ly@@37) LayerTypeType)) (= (type $Heap@@22) (MapType0Type refType MapType1Type))) (= (type |f#0@@84|) HandleTypeType)) (= (type |run#0@@36|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|) (and (and (and ($IsGoodHeap $Heap@@22) ($Is |f#0@@84| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3))) ($Is |run#0@@36| (TSeq Sequences._default.ApplyOpaque$E@@3))) (forall ((|i#2@@3| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@3|) (INTERNAL_lt_boogie |i#2@@3| (|Seq#Length| |run#0@@36|))) (Requires1 Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 $Heap@@22 |f#0@@84| (|Seq#Index| |run#0@@36| |i#2@@3|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |4912|
 :pattern ( (|Seq#Index| |run#0@@36| |i#2@@3|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 ($LS $ly@@37) |f#0@@84| |run#0@@36|) (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|))))
 :qid |unknown.0:0|
 :skolemid |4914|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 ($LS $ly@@37) |f#0@@84| |run#0@@36|) ($IsGoodHeap $Heap@@22))
))))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@4 T@U) (Sequences._default.ApplyOpaque$R@@4 T@U) ($ly@@38 T@U) ($Heap@@23 T@U) (|f#0@@85| T@U) (|run#0@@37| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@4) TyType) (= (type Sequences._default.ApplyOpaque$R@@4) TyType)) (= (type $ly@@38) LayerTypeType)) (= (type $Heap@@23) (MapType0Type refType MapType1Type))) (= (type |f#0@@85|) HandleTypeType)) (= (type |run#0@@37|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)) (and (and (and ($IsGoodHeap $Heap@@23) ($Is |f#0@@85| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4))) ($Is |run#0@@37| (TSeq Sequences._default.ApplyOpaque$E@@4))) (forall ((|i#3| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#3|) (INTERNAL_lt_boogie |i#3| (|Seq#Length| (Lit |run#0@@37|)))) (Requires1 Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 $Heap@@23 |f#0@@85| (|Seq#Index| (Lit |run#0@@37|) |i#3|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |4915|
 :pattern ( (|Seq#Index| |run#0@@37| |i#3|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 ($LS $ly@@38) |f#0@@85| (Lit |run#0@@37|)) (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4916|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 ($LS $ly@@38) |f#0@@85| (Lit |run#0@@37|)) ($IsGoodHeap $Heap@@23))
))))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@5 T@U) (Sequences._default.ApplyOpaque$R@@5 T@U) ($ly@@39 T@U) ($Heap@@24 T@U) (|f#0@@86| T@U) (|run#0@@38| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@5) TyType) (= (type Sequences._default.ApplyOpaque$R@@5) TyType)) (= (type $ly@@39) LayerTypeType)) (= (type $Heap@@24) (MapType0Type refType MapType1Type))) (= (type |f#0@@86|) HandleTypeType)) (= (type |run#0@@38|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|)) (and (and (and ($IsGoodHeap $Heap@@24) ($Is |f#0@@86| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5))) ($Is |run#0@@38| (TSeq Sequences._default.ApplyOpaque$E@@5))) (forall ((|i#4@@0| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@0|) (INTERNAL_lt_boogie |i#4@@0| (|Seq#Length| (Lit |run#0@@38|)))) (Requires1 Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 $Heap@@24 (Lit |f#0@@86|) (|Seq#Index| (Lit |run#0@@38|) |i#4@@0|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |4917|
 :pattern ( (|Seq#Index| |run#0@@38| |i#4@@0|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|)) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 ($LS $ly@@39) (Lit |f#0@@86|) (Lit |run#0@@38|)) (Lit (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4918|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 ($LS $ly@@39) (Lit |f#0@@86|) (Lit |run#0@@38|)) ($IsGoodHeap $Heap@@24))
))))
(assert (forall ((arg0@@503 T@U) (arg1@@218 T@U) (arg2@@106 T@U) (arg3@@55 T@U) ) (! (= (type (Sequences.__default.Filter arg0@@503 arg1@@218 arg2@@106 arg3@@55)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Filter|
 :pattern ( (Sequences.__default.Filter arg0@@503 arg1@@218 arg2@@106 arg3@@55))
)))
(assert (forall ((Sequences._default.Filter$E T@U) ($ly@@40 T@U) (|f#0@@87| T@U) (|run#0@@39| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Filter$E) TyType) (= (type $ly@@40) LayerTypeType)) (= (type |f#0@@87|) HandleTypeType)) (= (type |run#0@@39|) (SeqType BoxType))) (= (Sequences.__default.Filter Sequences._default.Filter$E ($LS $ly@@40) |f#0@@87| |run#0@@39|) (Sequences.__default.Filter Sequences._default.Filter$E $ly@@40 |f#0@@87| |run#0@@39|)))
 :qid |unknown.0:0|
 :skolemid |4919|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E ($LS $ly@@40) |f#0@@87| |run#0@@39|))
)))
(assert (forall ((Sequences._default.Filter$E@@0 T@U) ($ly@@41 T@U) (|f#0@@88| T@U) (|run#0@@40| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Filter$E@@0) TyType) (= (type $ly@@41) LayerTypeType)) (= (type |f#0@@88|) HandleTypeType)) (= (type |run#0@@40|) (SeqType BoxType))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@0 $ly@@41 |f#0@@88| |run#0@@40|) (Sequences.__default.Filter Sequences._default.Filter$E@@0 $LZ |f#0@@88| |run#0@@40|)))
 :qid |unknown.0:0|
 :skolemid |4920|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@0 (AsFuelBottom $ly@@41) |f#0@@88| |run#0@@40|))
)))
(assert  (=> true (forall ((Sequences._default.Filter$E@@1 T@U) ($ly@@42 T@U) ($Heap@@25 T@U) (|f#0@@89| T@U) (|run#0@@41| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@1) TyType) (= (type $ly@@42) LayerTypeType)) (= (type $Heap@@25) (MapType0Type refType MapType1Type))) (= (type |f#0@@89|) HandleTypeType)) (= (type |run#0@@41|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@1 |f#0@@89| |run#0@@41|) (and (and (and ($IsGoodHeap $Heap@@25) ($Is |f#0@@89| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@1 TBool))) ($Is |run#0@@41| (TSeq Sequences._default.Filter$E@@1))) (forall ((|i#0@@65| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@65|) (INTERNAL_lt_boogie |i#0@@65| (|Seq#Length| |run#0@@41|))) (Requires1 Sequences._default.Filter$E@@1 TBool $Heap@@25 |f#0@@89| (|Seq#Index| |run#0@@41| |i#0@@65|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |4921|
 :pattern ( (|Seq#Index| |run#0@@41| |i#0@@65|))
))))) (and (and (and (and (INTERNAL_le_boogie (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|)) (|Seq#Length| |run#0@@41|)) (forall ((|i#1@@11| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@11|) (INTERNAL_lt_boogie |i#1@@11| (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|)))) (|Seq#Contains| |run#0@@41| (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) |i#1@@11|)))
 :qid |Sequencesidfy.192:20|
 :skolemid |4922|
 :pattern ( (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) |i#1@@11|))
))) (forall ((|i#2@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@4|) (INTERNAL_lt_boogie |i#2@@4| (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|)))) (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@1 TBool $Heap@@25 |f#0@@89| (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) |i#2@@4|)))))
 :qid |Sequencesidfy.193:20|
 :skolemid |4923|
 :pattern ( (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) |i#2@@4|))
))) (forall ((|i#3@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@0|) (and (INTERNAL_lt_boogie |i#3@@0| (|Seq#Length| |run#0@@41|)) (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@1 TBool $Heap@@25 |f#0@@89| (|Seq#Index| |run#0@@41| |i#3@@0|)))))) (|Seq#Contains| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) (|Seq#Index| |run#0@@41| |i#3@@0|)))
 :qid |Sequencesidfy.194:20|
 :skolemid |4924|
 :pattern ( (|Seq#Index| |run#0@@41| |i#3@@0|))
))) ($Is (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) (TSeq Sequences._default.Filter$E@@1))))
 :qid |unknown.0:0|
 :skolemid |4925|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@42 |f#0@@89| |run#0@@41|) ($IsGoodHeap $Heap@@25))
))))
(assert (forall ((Sequences._default.Filter$E@@2 T@U) ($ly@@43 T@U) ($Heap@@26 T@U) (|f#0@@90| T@U) (|run#0@@42| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@2) TyType) (= (type $ly@@43) LayerTypeType)) (= (type $Heap@@26) (MapType0Type refType MapType1Type))) (= (type |f#0@@90|) HandleTypeType)) (= (type |run#0@@42|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@26) ($Is |f#0@@90| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@2 TBool))) ($Is |run#0@@42| (TSeq Sequences._default.Filter$E@@2)))) (= (|Sequences.__default.Filter#requires| Sequences._default.Filter$E@@2 $ly@@43 |f#0@@90| |run#0@@42|) (forall ((|i#4@@1| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@1|) (INTERNAL_lt_boogie |i#4@@1| (|Seq#Length| |run#0@@42|))) (Requires1 Sequences._default.Filter$E@@2 TBool $Heap@@26 |f#0@@90| (|Seq#Index| |run#0@@42| |i#4@@1|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |4926|
 :pattern ( (|Seq#Index| |run#0@@42| |i#4@@1|))
))))
 :qid |unknown.0:0|
 :skolemid |4927|
 :pattern ( (|Sequences.__default.Filter#requires| Sequences._default.Filter$E@@2 $ly@@43 |f#0@@90| |run#0@@42|) ($IsGoodHeap $Heap@@26))
)))
(assert  (=> true (forall ((Sequences._default.Filter$E@@3 T@U) ($ly@@44 T@U) ($Heap@@27 T@U) (|f#0@@91| T@U) (|run#0@@43| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@3) TyType) (= (type $ly@@44) LayerTypeType)) (= (type $Heap@@27) (MapType0Type refType MapType1Type))) (= (type |f#0@@91|) HandleTypeType)) (= (type |run#0@@43|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| |run#0@@43|) (and (and (and ($IsGoodHeap $Heap@@27) ($Is |f#0@@91| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@3 TBool))) ($Is |run#0@@43| (TSeq Sequences._default.Filter$E@@3))) (forall ((|i#4@@2| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@2|) (INTERNAL_lt_boogie |i#4@@2| (|Seq#Length| |run#0@@43|))) (Requires1 Sequences._default.Filter$E@@3 TBool $Heap@@27 |f#0@@91| (|Seq#Index| |run#0@@43| |i#4@@2|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |4926|
 :pattern ( (|Seq#Index| |run#0@@43| |i#4@@2|))
))))) (and (=> (not (= (|Seq#Length| |run#0@@43|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@27 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|)))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@3 |run#0@@43|)))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@27 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@3 ($LS $ly@@44) |f#0@@91| |run#0@@43|) (ite (= (|Seq#Length| |run#0@@43|) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@27 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|)))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@3 $ly@@44 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)) (|Seq#Build| (|Seq#Empty| BoxType) (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|))) (Sequences.__default.Filter Sequences._default.Filter$E@@3 $ly@@44 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)))))))
 :qid |unknown.0:0|
 :skolemid |4928|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@3 ($LS $ly@@44) |f#0@@91| |run#0@@43|) ($IsGoodHeap $Heap@@27))
))))
(assert  (=> true (forall ((Sequences._default.Filter$E@@4 T@U) ($ly@@45 T@U) ($Heap@@28 T@U) (|f#0@@92| T@U) (|run#0@@44| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@4) TyType) (= (type $ly@@45) LayerTypeType)) (= (type $Heap@@28) (MapType0Type refType MapType1Type))) (= (type |f#0@@92|) HandleTypeType)) (= (type |run#0@@44|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit |run#0@@44|)) (and (and (and ($IsGoodHeap $Heap@@28) ($Is |f#0@@92| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@4 TBool))) ($Is |run#0@@44| (TSeq Sequences._default.Filter$E@@4))) (forall ((|i#5| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#5|) (INTERNAL_lt_boogie |i#5| (|Seq#Length| (Lit |run#0@@44|)))) (Requires1 Sequences._default.Filter$E@@4 TBool $Heap@@28 |f#0@@92| (|Seq#Index| (Lit |run#0@@44|) |i#5|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |4929|
 :pattern ( (|Seq#Index| |run#0@@44| |i#5|))
))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@28 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@28 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@45) |f#0@@92| (Lit |run#0@@44|)) (ite (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@28 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@45) |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))) (|Seq#Build| (|Seq#Empty| BoxType) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@45) |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4930|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@45) |f#0@@92| (Lit |run#0@@44|)) ($IsGoodHeap $Heap@@28))
))))
(assert  (=> true (forall ((Sequences._default.Filter$E@@5 T@U) ($ly@@46 T@U) ($Heap@@29 T@U) (|f#0@@93| T@U) (|run#0@@45| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@5) TyType) (= (type $ly@@46) LayerTypeType)) (= (type $Heap@@29) (MapType0Type refType MapType1Type))) (= (type |f#0@@93|) HandleTypeType)) (= (type |run#0@@45|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit |run#0@@45|)) (and (and (and ($IsGoodHeap $Heap@@29) ($Is |f#0@@93| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@5 TBool))) ($Is |run#0@@45| (TSeq Sequences._default.Filter$E@@5))) (forall ((|i#6@@0| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#6@@0|) (INTERNAL_lt_boogie |i#6@@0| (|Seq#Length| (Lit |run#0@@45|)))) (Requires1 Sequences._default.Filter$E@@5 TBool $Heap@@29 (Lit |f#0@@93|) (|Seq#Index| (Lit |run#0@@45|) |i#6@@0|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |4931|
 :pattern ( (|Seq#Index| |run#0@@45| |i#6@@0|))
))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@29 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@29 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@46) (Lit |f#0@@93|) (Lit |run#0@@45|)) (ite (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@29 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@46) (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))) (|Seq#Build| (|Seq#Empty| BoxType) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@46) (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4932|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@46) (Lit |f#0@@93|) (Lit |run#0@@45|)) ($IsGoodHeap $Heap@@29))
))))
(assert (forall ((arg0@@504 T@U) (arg1@@219 T@U) (arg2@@107 T@U) (arg3@@56 T@U) (arg4@@33 T@U) (arg5@@17 T@U) ) (! (= (type (Sequences.__default.FoldLeft arg0@@504 arg1@@219 arg2@@107 arg3@@56 arg4@@33 arg5@@17)) BoxType)
 :qid |funType:Sequences.__default.FoldLeft|
 :pattern ( (Sequences.__default.FoldLeft arg0@@504 arg1@@219 arg2@@107 arg3@@56 arg4@@33 arg5@@17))
)))
(assert (forall ((Sequences._default.FoldLeft$A T@U) (Sequences._default.FoldLeft$E T@U) ($ly@@47 T@U) (|f#0@@94| T@U) (|init#0| T@U) (|run#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldLeft$A) TyType) (= (type Sequences._default.FoldLeft$E) TyType)) (= (type $ly@@47) LayerTypeType)) (= (type |f#0@@94|) HandleTypeType)) (= (type |init#0|) BoxType)) (= (type |run#0@@46|) (SeqType BoxType))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E ($LS $ly@@47) |f#0@@94| |init#0| |run#0@@46|) (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E $ly@@47 |f#0@@94| |init#0| |run#0@@46|)))
 :qid |unknown.0:0|
 :skolemid |4933|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E ($LS $ly@@47) |f#0@@94| |init#0| |run#0@@46|))
)))
(assert (forall ((Sequences._default.FoldLeft$A@@0 T@U) (Sequences._default.FoldLeft$E@@0 T@U) ($ly@@48 T@U) (|f#0@@95| T@U) (|init#0@@0| T@U) (|run#0@@47| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@0) TyType) (= (type Sequences._default.FoldLeft$E@@0) TyType)) (= (type $ly@@48) LayerTypeType)) (= (type |f#0@@95|) HandleTypeType)) (= (type |init#0@@0|) BoxType)) (= (type |run#0@@47|) (SeqType BoxType))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 $ly@@48 |f#0@@95| |init#0@@0| |run#0@@47|) (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 $LZ |f#0@@95| |init#0@@0| |run#0@@47|)))
 :qid |unknown.0:0|
 :skolemid |4934|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 (AsFuelBottom $ly@@48) |f#0@@95| |init#0@@0| |run#0@@47|))
)))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@1 T@U) (Sequences._default.FoldLeft$E@@1 T@U) ($ly@@49 T@U) (|f#0@@96| T@U) (|init#0@@1| T@U) (|run#0@@48| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@1) TyType) (= (type Sequences._default.FoldLeft$E@@1) TyType)) (= (type $ly@@49) LayerTypeType)) (= (type |f#0@@96|) HandleTypeType)) (= (type |init#0@@1|) BoxType)) (= (type |run#0@@48|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 |f#0@@96| |init#0@@1| |run#0@@48|) (and (and ($Is |f#0@@96| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 Sequences._default.FoldLeft$A@@1)) ($IsBox |init#0@@1| Sequences._default.FoldLeft$A@@1)) ($Is |run#0@@48| (TSeq Sequences._default.FoldLeft$E@@1))))) ($IsBox (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 $ly@@49 |f#0@@96| |init#0@@1| |run#0@@48|) Sequences._default.FoldLeft$A@@1))
 :qid |unknown.0:0|
 :skolemid |4935|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 $ly@@49 |f#0@@96| |init#0@@1| |run#0@@48|))
))))
(assert (forall ((Sequences._default.FoldLeft$A@@2 T@U) (Sequences._default.FoldLeft$E@@2 T@U) ($ly@@50 T@U) ($Heap@@30 T@U) (|f#0@@97| T@U) (|init#0@@2| T@U) (|run#0@@49| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@2) TyType) (= (type Sequences._default.FoldLeft$E@@2) TyType)) (= (type $ly@@50) LayerTypeType)) (= (type $Heap@@30) (MapType0Type refType MapType1Type))) (= (type |f#0@@97|) HandleTypeType)) (= (type |init#0@@2|) BoxType)) (= (type |run#0@@49|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@30) ($Is |f#0@@97| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 Sequences._default.FoldLeft$A@@2))) ($IsBox |init#0@@2| Sequences._default.FoldLeft$A@@2)) ($Is |run#0@@49| (TSeq Sequences._default.FoldLeft$E@@2)))) (= (|Sequences.__default.FoldLeft#requires| Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 $ly@@50 |f#0@@97| |init#0@@2| |run#0@@49|) true))
 :qid |unknown.0:0|
 :skolemid |4936|
 :pattern ( (|Sequences.__default.FoldLeft#requires| Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 $ly@@50 |f#0@@97| |init#0@@2| |run#0@@49|) ($IsGoodHeap $Heap@@30))
)))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@3 T@U) (Sequences._default.FoldLeft$E@@3 T@U) ($ly@@51 T@U) ($Heap@@31 T@U) (|f#0@@98| T@U) (|init#0@@3| T@U) (|run#0@@50| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@3) TyType) (= (type Sequences._default.FoldLeft$E@@3) TyType)) (= (type $ly@@51) LayerTypeType)) (= (type $Heap@@31) (MapType0Type refType MapType1Type))) (= (type |f#0@@98|) HandleTypeType)) (= (type |init#0@@3|) BoxType)) (= (type |run#0@@50|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 |f#0@@98| |init#0@@3| |run#0@@50|) (and (and (and ($IsGoodHeap $Heap@@31) ($Is |f#0@@98| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3))) ($IsBox |init#0@@3| Sequences._default.FoldLeft$A@@3)) ($Is |run#0@@50| (TSeq Sequences._default.FoldLeft$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@50|) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 |f#0@@98| (Apply2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3 $Heap@@31 |f#0@@98| |init#0@@3| (|Seq#Index| |run#0@@50| (LitInt 0))) (|Seq#Drop| |run#0@@50| (LitInt 1)))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 ($LS $ly@@51) |f#0@@98| |init#0@@3| |run#0@@50|) (ite (= (|Seq#Length| |run#0@@50|) (LitInt 0)) |init#0@@3| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 $ly@@51 |f#0@@98| (Apply2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3 $Heap@@31 |f#0@@98| |init#0@@3| (|Seq#Index| |run#0@@50| (LitInt 0))) (|Seq#Drop| |run#0@@50| (LitInt 1)))))))
 :qid |unknown.0:0|
 :skolemid |4937|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 ($LS $ly@@51) |f#0@@98| |init#0@@3| |run#0@@50|) ($IsGoodHeap $Heap@@31))
))))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@4 T@U) (Sequences._default.FoldLeft$E@@4 T@U) ($ly@@52 T@U) ($Heap@@32 T@U) (|f#0@@99| T@U) (|init#0@@4| T@U) (|run#0@@51| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@4) TyType) (= (type Sequences._default.FoldLeft$E@@4) TyType)) (= (type $ly@@52) LayerTypeType)) (= (type $Heap@@32) (MapType0Type refType MapType1Type))) (= (type |f#0@@99|) HandleTypeType)) (= (type |init#0@@4|) BoxType)) (= (type |run#0@@51|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) (and (and (and ($IsGoodHeap $Heap@@32) ($Is |f#0@@99| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4))) ($IsBox |init#0@@4| Sequences._default.FoldLeft$A@@4)) ($Is |run#0@@51| (TSeq Sequences._default.FoldLeft$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 |f#0@@99| (Apply2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4 $Heap@@32 |f#0@@99| |init#0@@4| (|Seq#Index| (Lit |run#0@@51|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1))))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@52) |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) (ite (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0)) |init#0@@4| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@52) |f#0@@99| (Apply2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4 $Heap@@32 |f#0@@99| |init#0@@4| (|Seq#Index| (Lit |run#0@@51|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4938|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@52) |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) ($IsGoodHeap $Heap@@32))
))))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@5 T@U) (Sequences._default.FoldLeft$E@@5 T@U) ($ly@@53 T@U) ($Heap@@33 T@U) (|f#0@@100| T@U) (|init#0@@5| T@U) (|run#0@@52| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@5) TyType) (= (type Sequences._default.FoldLeft$E@@5) TyType)) (= (type $ly@@53) LayerTypeType)) (= (type $Heap@@33) (MapType0Type refType MapType1Type))) (= (type |f#0@@100|) HandleTypeType)) (= (type |init#0@@5|) BoxType)) (= (type |run#0@@52|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) (and (and (and ($IsGoodHeap $Heap@@33) ($Is |f#0@@100| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5))) ($IsBox |init#0@@5| Sequences._default.FoldLeft$A@@5)) ($Is |run#0@@52| (TSeq Sequences._default.FoldLeft$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 (Lit |f#0@@100|) (Apply2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5 $Heap@@33 (Lit |f#0@@100|) (Lit |init#0@@5|) (|Seq#Index| (Lit |run#0@@52|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1))))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@53) (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) (ite (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0)) |init#0@@5| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@53) (Lit |f#0@@100|) (Apply2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5 $Heap@@33 (Lit |f#0@@100|) (Lit |init#0@@5|) (|Seq#Index| (Lit |run#0@@52|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4939|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@53) (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) ($IsGoodHeap $Heap@@33))
))))
(assert (forall ((arg0@@505 T@U) (arg1@@220 T@U) (arg2@@108 T@U) (arg3@@57 T@U) (arg4@@34 T@U) (arg5@@18 T@U) ) (! (= (type (Sequences.__default.FoldRight arg0@@505 arg1@@220 arg2@@108 arg3@@57 arg4@@34 arg5@@18)) BoxType)
 :qid |funType:Sequences.__default.FoldRight|
 :pattern ( (Sequences.__default.FoldRight arg0@@505 arg1@@220 arg2@@108 arg3@@57 arg4@@34 arg5@@18))
)))
(assert (forall ((Sequences._default.FoldRight$A T@U) (Sequences._default.FoldRight$E T@U) ($ly@@54 T@U) (|f#0@@101| T@U) (|init#0@@6| T@U) (|run#0@@53| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldRight$A) TyType) (= (type Sequences._default.FoldRight$E) TyType)) (= (type $ly@@54) LayerTypeType)) (= (type |f#0@@101|) HandleTypeType)) (= (type |init#0@@6|) BoxType)) (= (type |run#0@@53|) (SeqType BoxType))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E ($LS $ly@@54) |f#0@@101| |init#0@@6| |run#0@@53|) (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E $ly@@54 |f#0@@101| |init#0@@6| |run#0@@53|)))
 :qid |unknown.0:0|
 :skolemid |4940|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E ($LS $ly@@54) |f#0@@101| |init#0@@6| |run#0@@53|))
)))
(assert (forall ((Sequences._default.FoldRight$A@@0 T@U) (Sequences._default.FoldRight$E@@0 T@U) ($ly@@55 T@U) (|f#0@@102| T@U) (|init#0@@7| T@U) (|run#0@@54| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@0) TyType) (= (type Sequences._default.FoldRight$E@@0) TyType)) (= (type $ly@@55) LayerTypeType)) (= (type |f#0@@102|) HandleTypeType)) (= (type |init#0@@7|) BoxType)) (= (type |run#0@@54|) (SeqType BoxType))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 $ly@@55 |f#0@@102| |init#0@@7| |run#0@@54|) (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 $LZ |f#0@@102| |init#0@@7| |run#0@@54|)))
 :qid |unknown.0:0|
 :skolemid |4941|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 (AsFuelBottom $ly@@55) |f#0@@102| |init#0@@7| |run#0@@54|))
)))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@1 T@U) (Sequences._default.FoldRight$E@@1 T@U) ($ly@@56 T@U) (|f#0@@103| T@U) (|init#0@@8| T@U) (|run#0@@55| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@1) TyType) (= (type Sequences._default.FoldRight$E@@1) TyType)) (= (type $ly@@56) LayerTypeType)) (= (type |f#0@@103|) HandleTypeType)) (= (type |init#0@@8|) BoxType)) (= (type |run#0@@55|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 |f#0@@103| |init#0@@8| |run#0@@55|) (and (and ($Is |f#0@@103| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 Sequences._default.FoldRight$A@@1)) ($IsBox |init#0@@8| Sequences._default.FoldRight$A@@1)) ($Is |run#0@@55| (TSeq Sequences._default.FoldRight$E@@1))))) ($IsBox (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 $ly@@56 |f#0@@103| |init#0@@8| |run#0@@55|) Sequences._default.FoldRight$A@@1))
 :qid |unknown.0:0|
 :skolemid |4942|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 $ly@@56 |f#0@@103| |init#0@@8| |run#0@@55|))
))))
(assert (forall ((Sequences._default.FoldRight$A@@2 T@U) (Sequences._default.FoldRight$E@@2 T@U) ($ly@@57 T@U) ($Heap@@34 T@U) (|f#0@@104| T@U) (|init#0@@9| T@U) (|run#0@@56| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@2) TyType) (= (type Sequences._default.FoldRight$E@@2) TyType)) (= (type $ly@@57) LayerTypeType)) (= (type $Heap@@34) (MapType0Type refType MapType1Type))) (= (type |f#0@@104|) HandleTypeType)) (= (type |init#0@@9|) BoxType)) (= (type |run#0@@56|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@34) ($Is |f#0@@104| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 Sequences._default.FoldRight$A@@2))) ($IsBox |init#0@@9| Sequences._default.FoldRight$A@@2)) ($Is |run#0@@56| (TSeq Sequences._default.FoldRight$E@@2)))) (= (|Sequences.__default.FoldRight#requires| Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 $ly@@57 |f#0@@104| |init#0@@9| |run#0@@56|) true))
 :qid |unknown.0:0|
 :skolemid |4943|
 :pattern ( (|Sequences.__default.FoldRight#requires| Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 $ly@@57 |f#0@@104| |init#0@@9| |run#0@@56|) ($IsGoodHeap $Heap@@34))
)))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@3 T@U) (Sequences._default.FoldRight$E@@3 T@U) ($ly@@58 T@U) ($Heap@@35 T@U) (|f#0@@105| T@U) (|init#0@@10| T@U) (|run#0@@57| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@3) TyType) (= (type Sequences._default.FoldRight$E@@3) TyType)) (= (type $ly@@58) LayerTypeType)) (= (type $Heap@@35) (MapType0Type refType MapType1Type))) (= (type |f#0@@105|) HandleTypeType)) (= (type |init#0@@10|) BoxType)) (= (type |run#0@@57|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 |f#0@@105| |init#0@@10| |run#0@@57|) (and (and (and ($IsGoodHeap $Heap@@35) ($Is |f#0@@105| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 Sequences._default.FoldRight$A@@3))) ($IsBox |init#0@@10| Sequences._default.FoldRight$A@@3)) ($Is |run#0@@57| (TSeq Sequences._default.FoldRight$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@57|) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 |f#0@@105| |init#0@@10| (|Seq#Drop| |run#0@@57| (LitInt 1)))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 ($LS $ly@@58) |f#0@@105| |init#0@@10| |run#0@@57|) (ite (= (|Seq#Length| |run#0@@57|) (LitInt 0)) |init#0@@10| (Apply2 Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 Sequences._default.FoldRight$A@@3 $Heap@@35 |f#0@@105| (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 $ly@@58 |f#0@@105| |init#0@@10| (|Seq#Drop| |run#0@@57| (LitInt 1))) (|Seq#Index| |run#0@@57| (LitInt 0)))))))
 :qid |unknown.0:0|
 :skolemid |4944|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 ($LS $ly@@58) |f#0@@105| |init#0@@10| |run#0@@57|) ($IsGoodHeap $Heap@@35))
))))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@4 T@U) (Sequences._default.FoldRight$E@@4 T@U) ($ly@@59 T@U) ($Heap@@36 T@U) (|f#0@@106| T@U) (|init#0@@11| T@U) (|run#0@@58| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@4) TyType) (= (type Sequences._default.FoldRight$E@@4) TyType)) (= (type $ly@@59) LayerTypeType)) (= (type $Heap@@36) (MapType0Type refType MapType1Type))) (= (type |f#0@@106|) HandleTypeType)) (= (type |init#0@@11|) BoxType)) (= (type |run#0@@58|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) (and (and (and ($IsGoodHeap $Heap@@36) ($Is |f#0@@106| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 Sequences._default.FoldRight$A@@4))) ($IsBox |init#0@@11| Sequences._default.FoldRight$A@@4)) ($Is |run#0@@58| (TSeq Sequences._default.FoldRight$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 |f#0@@106| |init#0@@11| (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1))))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@59) |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) (ite (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0)) |init#0@@11| (Apply2 Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 Sequences._default.FoldRight$A@@4 $Heap@@36 |f#0@@106| (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@59) |f#0@@106| |init#0@@11| (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1)))) (|Seq#Index| (Lit |run#0@@58|) (LitInt 0)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4945|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@59) |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) ($IsGoodHeap $Heap@@36))
))))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@5 T@U) (Sequences._default.FoldRight$E@@5 T@U) ($ly@@60 T@U) ($Heap@@37 T@U) (|f#0@@107| T@U) (|init#0@@12| T@U) (|run#0@@59| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@5) TyType) (= (type Sequences._default.FoldRight$E@@5) TyType)) (= (type $ly@@60) LayerTypeType)) (= (type $Heap@@37) (MapType0Type refType MapType1Type))) (= (type |f#0@@107|) HandleTypeType)) (= (type |init#0@@12|) BoxType)) (= (type |run#0@@59|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) (and (and (and ($IsGoodHeap $Heap@@37) ($Is |f#0@@107| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 Sequences._default.FoldRight$A@@5))) ($IsBox |init#0@@12| Sequences._default.FoldRight$A@@5)) ($Is |run#0@@59| (TSeq Sequences._default.FoldRight$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1))))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@60) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) (ite (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0)) |init#0@@12| (Apply2 Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 Sequences._default.FoldRight$A@@5 $Heap@@37 (Lit |f#0@@107|) (Lit (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@60) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1))))) (|Seq#Index| (Lit |run#0@@59|) (LitInt 0)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4946|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@60) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) ($IsGoodHeap $Heap@@37))
))))
(assert (forall ((arg0@@506 T@U) (arg1@@221 T@U) (arg2@@109 T@U) (arg3@@58 T@U) (arg4@@35 T@U) (arg5@@19 T@U) ) (! (= (type (Sequences.__default.FoldFromRight arg0@@506 arg1@@221 arg2@@109 arg3@@58 arg4@@35 arg5@@19)) BoxType)
 :qid |funType:Sequences.__default.FoldFromRight|
 :pattern ( (Sequences.__default.FoldFromRight arg0@@506 arg1@@221 arg2@@109 arg3@@58 arg4@@35 arg5@@19))
)))
(assert (forall ((Sequences._default.FoldFromRight$A T@U) (Sequences._default.FoldFromRight$E T@U) ($ly@@61 T@U) (|f#0@@108| T@U) (|init#0@@13| T@U) (|run#0@@60| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A) TyType) (= (type Sequences._default.FoldFromRight$E) TyType)) (= (type $ly@@61) LayerTypeType)) (= (type |f#0@@108|) HandleTypeType)) (= (type |init#0@@13|) BoxType)) (= (type |run#0@@60|) (SeqType BoxType))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E ($LS $ly@@61) |f#0@@108| |init#0@@13| |run#0@@60|) (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E $ly@@61 |f#0@@108| |init#0@@13| |run#0@@60|)))
 :qid |unknown.0:0|
 :skolemid |4947|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E ($LS $ly@@61) |f#0@@108| |init#0@@13| |run#0@@60|))
)))
(assert (forall ((Sequences._default.FoldFromRight$A@@0 T@U) (Sequences._default.FoldFromRight$E@@0 T@U) ($ly@@62 T@U) (|f#0@@109| T@U) (|init#0@@14| T@U) (|run#0@@61| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@0) TyType) (= (type Sequences._default.FoldFromRight$E@@0) TyType)) (= (type $ly@@62) LayerTypeType)) (= (type |f#0@@109|) HandleTypeType)) (= (type |init#0@@14|) BoxType)) (= (type |run#0@@61|) (SeqType BoxType))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 $ly@@62 |f#0@@109| |init#0@@14| |run#0@@61|) (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 $LZ |f#0@@109| |init#0@@14| |run#0@@61|)))
 :qid |unknown.0:0|
 :skolemid |4948|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 (AsFuelBottom $ly@@62) |f#0@@109| |init#0@@14| |run#0@@61|))
)))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@1 T@U) (Sequences._default.FoldFromRight$E@@1 T@U) ($ly@@63 T@U) (|f#0@@110| T@U) (|init#0@@15| T@U) (|run#0@@62| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@1) TyType) (= (type Sequences._default.FoldFromRight$E@@1) TyType)) (= (type $ly@@63) LayerTypeType)) (= (type |f#0@@110|) HandleTypeType)) (= (type |init#0@@15|) BoxType)) (= (type |run#0@@62|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 |f#0@@110| |init#0@@15| |run#0@@62|) (and (and ($Is |f#0@@110| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 Sequences._default.FoldFromRight$A@@1)) ($IsBox |init#0@@15| Sequences._default.FoldFromRight$A@@1)) ($Is |run#0@@62| (TSeq Sequences._default.FoldFromRight$E@@1))))) ($IsBox (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 $ly@@63 |f#0@@110| |init#0@@15| |run#0@@62|) Sequences._default.FoldFromRight$A@@1))
 :qid |unknown.0:0|
 :skolemid |4949|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 $ly@@63 |f#0@@110| |init#0@@15| |run#0@@62|))
))))
(assert (forall ((Sequences._default.FoldFromRight$A@@2 T@U) (Sequences._default.FoldFromRight$E@@2 T@U) ($ly@@64 T@U) ($Heap@@38 T@U) (|f#0@@111| T@U) (|init#0@@16| T@U) (|run#0@@63| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@2) TyType) (= (type Sequences._default.FoldFromRight$E@@2) TyType)) (= (type $ly@@64) LayerTypeType)) (= (type $Heap@@38) (MapType0Type refType MapType1Type))) (= (type |f#0@@111|) HandleTypeType)) (= (type |init#0@@16|) BoxType)) (= (type |run#0@@63|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@38) ($Is |f#0@@111| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 Sequences._default.FoldFromRight$A@@2))) ($IsBox |init#0@@16| Sequences._default.FoldFromRight$A@@2)) ($Is |run#0@@63| (TSeq Sequences._default.FoldFromRight$E@@2)))) (= (|Sequences.__default.FoldFromRight#requires| Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 $ly@@64 |f#0@@111| |init#0@@16| |run#0@@63|) true))
 :qid |unknown.0:0|
 :skolemid |4950|
 :pattern ( (|Sequences.__default.FoldFromRight#requires| Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 $ly@@64 |f#0@@111| |init#0@@16| |run#0@@63|) ($IsGoodHeap $Heap@@38))
)))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@3 T@U) (Sequences._default.FoldFromRight$E@@3 T@U) ($ly@@65 T@U) ($Heap@@39 T@U) (|f#0@@112| T@U) (|init#0@@17| T@U) (|run#0@@64| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@3) TyType) (= (type Sequences._default.FoldFromRight$E@@3) TyType)) (= (type $ly@@65) LayerTypeType)) (= (type $Heap@@39) (MapType0Type refType MapType1Type))) (= (type |f#0@@112|) HandleTypeType)) (= (type |init#0@@17|) BoxType)) (= (type |run#0@@64|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 |f#0@@112| |init#0@@17| |run#0@@64|) (and (and (and ($IsGoodHeap $Heap@@39) ($Is |f#0@@112| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 Sequences._default.FoldFromRight$A@@3))) ($IsBox |init#0@@17| Sequences._default.FoldFromRight$A@@3)) ($Is |run#0@@64| (TSeq Sequences._default.FoldFromRight$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@64|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@3 |run#0@@64|) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 |f#0@@112| |init#0@@17| (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@3 |run#0@@64|))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@3 |run#0@@64|))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 ($LS $ly@@65) |f#0@@112| |init#0@@17| |run#0@@64|) (ite (= (|Seq#Length| |run#0@@64|) (LitInt 0)) |init#0@@17| (Apply2 Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 Sequences._default.FoldFromRight$A@@3 $Heap@@39 |f#0@@112| (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 $ly@@65 |f#0@@112| |init#0@@17| (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@3 |run#0@@64|)) (Sequences.__default.Last Sequences._default.FoldFromRight$E@@3 |run#0@@64|))))))
 :qid |unknown.0:0|
 :skolemid |4951|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 ($LS $ly@@65) |f#0@@112| |init#0@@17| |run#0@@64|) ($IsGoodHeap $Heap@@39))
))))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@4 T@U) (Sequences._default.FoldFromRight$E@@4 T@U) ($ly@@66 T@U) ($Heap@@40 T@U) (|f#0@@113| T@U) (|init#0@@18| T@U) (|run#0@@65| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@4) TyType) (= (type Sequences._default.FoldFromRight$E@@4) TyType)) (= (type $ly@@66) LayerTypeType)) (= (type $Heap@@40) (MapType0Type refType MapType1Type))) (= (type |f#0@@113|) HandleTypeType)) (= (type |init#0@@18|) BoxType)) (= (type |run#0@@65|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) (and (and (and ($IsGoodHeap $Heap@@40) ($Is |f#0@@113| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 Sequences._default.FoldFromRight$A@@4))) ($IsBox |init#0@@18| Sequences._default.FoldFromRight$A@@4)) ($Is |run#0@@65| (TSeq Sequences._default.FoldFromRight$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 |f#0@@113| |init#0@@18| (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|))))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@66) |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) (ite (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0)) |init#0@@18| (Apply2 Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 Sequences._default.FoldFromRight$A@@4 $Heap@@40 |f#0@@113| (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@66) |f#0@@113| |init#0@@18| (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)))) (Lit (Sequences.__default.Last Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4952|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@66) |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) ($IsGoodHeap $Heap@@40))
))))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@5 T@U) (Sequences._default.FoldFromRight$E@@5 T@U) ($ly@@67 T@U) ($Heap@@41 T@U) (|f#0@@114| T@U) (|init#0@@19| T@U) (|run#0@@66| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@5) TyType) (= (type Sequences._default.FoldFromRight$E@@5) TyType)) (= (type $ly@@67) LayerTypeType)) (= (type $Heap@@41) (MapType0Type refType MapType1Type))) (= (type |f#0@@114|) HandleTypeType)) (= (type |init#0@@19|) BoxType)) (= (type |run#0@@66|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) (and (and (and ($IsGoodHeap $Heap@@41) ($Is |f#0@@114| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 Sequences._default.FoldFromRight$A@@5))) ($IsBox |init#0@@19| Sequences._default.FoldFromRight$A@@5)) ($Is |run#0@@66| (TSeq Sequences._default.FoldFromRight$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|)) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|)))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@67) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) (ite (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0)) |init#0@@19| (Apply2 Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 Sequences._default.FoldFromRight$A@@5 $Heap@@41 (Lit |f#0@@114|) (Lit (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@67) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))) (Lit (Sequences.__default.Last Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4953|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@67) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) ($IsGoodHeap $Heap@@41))
))))
(assert (forall ((arg0@@507 T@U) (arg1@@222 T@U) ) (! (= (type (Sequences.__default.FoldSets arg0@@507 arg1@@222)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.FoldSets|
 :pattern ( (Sequences.__default.FoldSets arg0@@507 arg1@@222))
)))
(assert  (=> true (forall ((Sequences._default.FoldSets$E T@U) (|run#0@@67| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E) TyType) (= (type |run#0@@67|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E |run#0@@67|) ($Is |run#0@@67| (TSeq (TSet Sequences._default.FoldSets$E))))) ($Is (Sequences.__default.FoldSets Sequences._default.FoldSets$E |run#0@@67|) (TSet Sequences._default.FoldSets$E)))
 :qid |unknown.0:0|
 :skolemid |4954|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E |run#0@@67|))
))))
(assert (forall ((Sequences._default.FoldSets$E@@0 T@U) (|run#0@@68| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@0) TyType) (= (type |run#0@@68|) (SeqType BoxType))) ($Is |run#0@@68| (TSeq (TSet Sequences._default.FoldSets$E@@0)))) (= (|Sequences.__default.FoldSets#requires| Sequences._default.FoldSets$E@@0 |run#0@@68|) true))
 :qid |unknown.0:0|
 :skolemid |4955|
 :pattern ( (|Sequences.__default.FoldSets#requires| Sequences._default.FoldSets$E@@0 |run#0@@68|))
)))
(assert  (and (and (= (type |lambda#176|) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType)) (forall ((arg0@@508 T@U) (arg1@@223 T@U) ) (! (= (type (|lambda#177| arg0@@508 arg1@@223)) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))
 :qid |funType:lambda#177|
 :pattern ( (|lambda#177| arg0@@508 arg1@@223))
))) (forall ((arg0@@509 T@U) ) (! (= (type (|lambda#179| arg0@@509)) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#179|
 :pattern ( (|lambda#179| arg0@@509))
))))
(assert  (=> true (forall ((Sequences._default.FoldSets$E@@1 T@U) (|run#0@@69| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@1) TyType) (= (type |run#0@@69|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E@@1 |run#0@@69|) ($Is |run#0@@69| (TSeq (TSet Sequences._default.FoldSets$E@@1))))) (and (|Sequences.__default.FoldRight#canCall| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1) (Lit (AtLayer (|lambda#35| (Handle2 |lambda#176| (|lambda#177| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1)) (|lambda#179| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) |run#0@@69|) (= (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@1 |run#0@@69|) ($Unbox (MapType0Type BoxType boolType) (Sequences.__default.FoldRight (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1) ($LS $LZ) (Lit (AtLayer (|lambda#35| (Handle2 |lambda#176| (|lambda#177| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1)) (|lambda#179| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) |run#0@@69|)))))
 :qid |unknown.0:0|
 :skolemid |4956|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@1 |run#0@@69|))
))))
(assert  (=> true (forall ((Sequences._default.FoldSets$E@@2 T@U) (|run#0@@70| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@2) TyType) (= (type |run#0@@70|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)) ($Is |run#0@@70| (TSeq (TSet Sequences._default.FoldSets$E@@2))))) (and (|Sequences.__default.FoldRight#canCall| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2) (Lit (AtLayer (|lambda#35| (Handle2 |lambda#176| (|lambda#177| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2)) (|lambda#179| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) (Lit |run#0@@70|)) (= (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)) (Lit ($Unbox (MapType0Type BoxType boolType) (Sequences.__default.FoldRight (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2) ($LS $LZ) (Lit (AtLayer (|lambda#35| (Handle2 |lambda#176| (|lambda#177| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2)) (|lambda#179| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) (Lit |run#0@@70|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4957|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)))
))))
(assert (forall ((arg0@@510 T@U) (arg1@@224 T@U) (arg2@@110 T@U) (arg3@@59 Int) ) (! (= (type (Sequences.__default.remove arg0@@510 arg1@@224 arg2@@110 arg3@@59)) (SeqType BoxType))
 :qid |funType:Sequences.__default.remove|
 :pattern ( (Sequences.__default.remove arg0@@510 arg1@@224 arg2@@110 arg3@@59))
)))
(assert (forall ((Sequences._default.remove$A T@U) ($ly@@68 T@U) (|s#0@@56| T@U) (|pos#0| Int) ) (!  (=> (and (and (= (type Sequences._default.remove$A) TyType) (= (type $ly@@68) LayerTypeType)) (= (type |s#0@@56|) (SeqType BoxType))) (= (Sequences.__default.remove Sequences._default.remove$A ($LS $ly@@68) |s#0@@56| |pos#0|) (Sequences.__default.remove Sequences._default.remove$A $ly@@68 |s#0@@56| |pos#0|)))
 :qid |unknown.0:0|
 :skolemid |4958|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A ($LS $ly@@68) |s#0@@56| |pos#0|))
)))
(assert (forall ((Sequences._default.remove$A@@0 T@U) ($ly@@69 T@U) (|s#0@@57| T@U) (|pos#0@@0| Int) ) (!  (=> (and (and (= (type Sequences._default.remove$A@@0) TyType) (= (type $ly@@69) LayerTypeType)) (= (type |s#0@@57|) (SeqType BoxType))) (= (Sequences.__default.remove Sequences._default.remove$A@@0 $ly@@69 |s#0@@57| |pos#0@@0|) (Sequences.__default.remove Sequences._default.remove$A@@0 $LZ |s#0@@57| |pos#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |4959|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@0 (AsFuelBottom $ly@@69) |s#0@@57| |pos#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.remove$A@@1 T@U) ($ly@@70 T@U) (|s#0@@58| T@U) (|pos#0@@1| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@1) TyType) (= (type $ly@@70) LayerTypeType)) (= (type |s#0@@58|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@1 |s#0@@58| |pos#0@@1|) (and ($Is |s#0@@58| (TSeq Sequences._default.remove$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@1|) (INTERNAL_lt_boogie |pos#0@@1| (|Seq#Length| |s#0@@58|)))))) (and (and (and (= (|Seq#Length| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|)) (INTERNAL_sub_boogie (|Seq#Length| |s#0@@58|) 1)) (forall ((|i#0@@66| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@66|) (INTERNAL_lt_boogie |i#0@@66| |pos#0@@1|)) (= (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|) |i#0@@66|) (|Seq#Index| |s#0@@58| |i#0@@66|)))
 :qid |Sequencesidfy.369:18|
 :skolemid |4960|
 :pattern ( (|Seq#Index| |s#0@@58| |i#0@@66|))
 :pattern ( (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|) |i#0@@66|))
))) (forall ((|i#1@@12| Int) ) (!  (=> (and (INTERNAL_le_boogie |pos#0@@1| |i#1@@12|) (INTERNAL_lt_boogie |i#1@@12| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@58|) 1))) (= (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|) |i#1@@12|) (|Seq#Index| |s#0@@58| (INTERNAL_add_boogie |i#1@@12| 1))))
 :qid |Sequencesidfy.370:18|
 :skolemid |4961|
 :pattern ( (|Seq#Index| |s#0@@58| (INTERNAL_add_boogie |i#1@@12| 1)))
 :pattern ( (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|) |i#1@@12|))
))) ($Is (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|) (TSeq Sequences._default.remove$A@@1))))
 :qid |unknown.0:0|
 :skolemid |4962|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@70 |s#0@@58| |pos#0@@1|))
))))
(assert (forall ((Sequences._default.remove$A@@2 T@U) ($ly@@71 T@U) (|s#0@@59| T@U) (|pos#0@@2| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@2) TyType) (= (type $ly@@71) LayerTypeType)) (= (type |s#0@@59|) (SeqType BoxType))) ($Is |s#0@@59| (TSeq Sequences._default.remove$A@@2))) (= (|Sequences.__default.remove#requires| Sequences._default.remove$A@@2 $ly@@71 |s#0@@59| |pos#0@@2|)  (and (INTERNAL_le_boogie 0 |pos#0@@2|) (INTERNAL_lt_boogie |pos#0@@2| (|Seq#Length| |s#0@@59|)))))
 :qid |unknown.0:0|
 :skolemid |4963|
 :pattern ( (|Sequences.__default.remove#requires| Sequences._default.remove$A@@2 $ly@@71 |s#0@@59| |pos#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.remove$A@@3 T@U) ($ly@@72 T@U) (|s#0@@60| T@U) (|pos#0@@3| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@3) TyType) (= (type $ly@@72) LayerTypeType)) (= (type |s#0@@60|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@3 |s#0@@60| |pos#0@@3|) (and ($Is |s#0@@60| (TSeq Sequences._default.remove$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@3|) (INTERNAL_lt_boogie |pos#0@@3| (|Seq#Length| |s#0@@60|)))))) (= (Sequences.__default.remove Sequences._default.remove$A@@3 ($LS $ly@@72) |s#0@@60| |pos#0@@3|) (|Seq#Append| (|Seq#Take| |s#0@@60| |pos#0@@3|) (|Seq#Drop| |s#0@@60| (INTERNAL_add_boogie |pos#0@@3| 1)))))
 :qid |unknown.0:0|
 :skolemid |4964|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@3 ($LS $ly@@72) |s#0@@60| |pos#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.remove$A@@4 T@U) ($ly@@73 T@U) (|s#0@@61| T@U) (|pos#0@@4| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@4) TyType) (= (type $ly@@73) LayerTypeType)) (= (type |s#0@@61|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@4 (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (and ($Is |s#0@@61| (TSeq Sequences._default.remove$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@4|) (INTERNAL_lt_boogie |pos#0@@4| (|Seq#Length| (Lit |s#0@@61|))))))) (= (Sequences.__default.remove Sequences._default.remove$A@@4 ($LS $ly@@73) (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (|Seq#Append| (|Seq#Take| (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (|Seq#Drop| (Lit |s#0@@61|) (LitInt (INTERNAL_add_boogie |pos#0@@4| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4965|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@4 ($LS $ly@@73) (Lit |s#0@@61|) (LitInt |pos#0@@4|)))
))))
(assert (forall ((arg0@@511 T@U) (arg1@@225 T@U) (arg2@@111 T@U) (arg3@@60 T@U) ) (! (= (type (Sequences.__default.RemoveOneValue arg0@@511 arg1@@225 arg2@@111 arg3@@60)) (SeqType BoxType))
 :qid |funType:Sequences.__default.RemoveOneValue|
 :pattern ( (Sequences.__default.RemoveOneValue arg0@@511 arg1@@225 arg2@@111 arg3@@60))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V T@U) ($ly@@74 T@U) (|s#0@@62| T@U) (|v#0@@17| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V) TyType) (= (type $ly@@74) LayerTypeType)) (= (type |s#0@@62|) (SeqType BoxType))) (= (type |v#0@@17|) BoxType)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V ($LS $ly@@74) |s#0@@62| |v#0@@17|) (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V $ly@@74 |s#0@@62| |v#0@@17|)))
 :qid |unknown.0:0|
 :skolemid |4966|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V ($LS $ly@@74) |s#0@@62| |v#0@@17|))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@0 T@U) ($ly@@75 T@U) (|s#0@@63| T@U) (|v#0@@18| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V@@0) TyType) (= (type $ly@@75) LayerTypeType)) (= (type |s#0@@63|) (SeqType BoxType))) (= (type |v#0@@18|) BoxType)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 $ly@@75 |s#0@@63| |v#0@@18|) (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 $LZ |s#0@@63| |v#0@@18|)))
 :qid |unknown.0:0|
 :skolemid |4967|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 (AsFuelBottom $ly@@75) |s#0@@63| |v#0@@18|))
)))
(assert (= (type StartFuel_Sequences._default.NoDupes) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@1 T@U) ($ly@@76 T@U) (|s#0@@64| T@U) (|v#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@1) TyType) (= (type $ly@@76) LayerTypeType)) (= (type |s#0@@64|) (SeqType BoxType))) (= (type |v#0@@19|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@1 |s#0@@64| |v#0@@19|) (and ($Is |s#0@@64| (TSeq Sequences._default.RemoveOneValue$V@@1)) ($IsBox |v#0@@19| Sequences._default.RemoveOneValue$V@@1)))) (and (=> (Sequences.__default.NoDupes Sequences._default.RemoveOneValue$V@@1 StartFuel_Sequences._default.NoDupes |s#0@@64|) (and (Sequences.__default.NoDupes Sequences._default.RemoveOneValue$V@@1 StartFuel_Sequences._default.NoDupes (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@76 |s#0@@64| |v#0@@19|)) (|Set#Equal| (Sequences.__default.Set Sequences._default.RemoveOneValue$V@@1 (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@76 |s#0@@64| |v#0@@19|)) (|Set#Difference| (Sequences.__default.Set Sequences._default.RemoveOneValue$V@@1 |s#0@@64|) (|Set#UnionOne| (|Set#Empty| BoxType) |v#0@@19|))))) ($Is (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@76 |s#0@@64| |v#0@@19|) (TSeq Sequences._default.RemoveOneValue$V@@1))))
 :qid |unknown.0:0|
 :skolemid |4968|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@76 |s#0@@64| |v#0@@19|))
))))
(assert (forall ((Sequences._default.RemoveOneValue$V@@2 T@U) ($ly@@77 T@U) ($Heap@@42 T@U) (|s#0@@65| T@U) (|v#0@@20| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@2) TyType) (= (type $ly@@77) LayerTypeType)) (= (type $Heap@@42) (MapType0Type refType MapType1Type))) (= (type |s#0@@65|) (SeqType BoxType))) (= (type |v#0@@20|) BoxType)) (and (and ($IsGoodHeap $Heap@@42) ($Is |s#0@@65| (TSeq Sequences._default.RemoveOneValue$V@@2))) ($IsBox |v#0@@20| Sequences._default.RemoveOneValue$V@@2))) (= (|Sequences.__default.RemoveOneValue#requires| Sequences._default.RemoveOneValue$V@@2 $ly@@77 |s#0@@65| |v#0@@20|) true))
 :qid |unknown.0:0|
 :skolemid |4969|
 :pattern ( (|Sequences.__default.RemoveOneValue#requires| Sequences._default.RemoveOneValue$V@@2 $ly@@77 |s#0@@65| |v#0@@20|) ($IsGoodHeap $Heap@@42))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@3 T@U) (s@@50 T@U) (v@@52 T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V@@3) TyType) (= (type s@@50) (SeqType BoxType))) (= (type v@@52) BoxType)) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) (and (and (INTERNAL_le_boogie 0 (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) (INTERNAL_lt_boogie (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52) (|Seq#Length| s@@50))) (= (|Seq#Index| s@@50 (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) v@@52)))
 :qid |Sequencesidfy.380:5|
 :skolemid |4970|
 :pattern ( (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52))
)))
(assert  (and (= (type MoreFuel_Sequences._default.NoDupes0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.NoDupes) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@4 T@U) ($ly@@78 T@U) ($Heap@@43 T@U) (|s#0@@66| T@U) (|v#0@@21| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@4) TyType) (= (type $ly@@78) LayerTypeType)) (= (type $Heap@@43) (MapType0Type refType MapType1Type))) (= (type |s#0@@66|) (SeqType BoxType))) (= (type |v#0@@21|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@21|) (and (and ($IsGoodHeap $Heap@@43) ($Is |s#0@@66| (TSeq Sequences._default.RemoveOneValue$V@@4))) ($IsBox |v#0@@21| Sequences._default.RemoveOneValue$V@@4)))) (and (=> (|Seq#Contains| |s#0@@66| |v#0@@21|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@21|)) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes0)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes0)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes0) MoreFuel_Sequences._default.NoDupes0)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@4 ($LS $ly@@78) |s#0@@66| |v#0@@21|) (ite  (not (|Seq#Contains| |s#0@@66| |v#0@@21|)) |s#0@@66| (let ((|i#0@@67| (|$let#4_i| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@21|)))
(|Seq#Append| (|Seq#Take| |s#0@@66| |i#0@@67|) (|Seq#Drop| |s#0@@66| (INTERNAL_add_boogie |i#0@@67| 1)))))))))
 :qid |unknown.0:0|
 :skolemid |4971|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@4 ($LS $ly@@78) |s#0@@66| |v#0@@21|) ($IsGoodHeap $Heap@@43))
))))
(assert (= (type MoreFuel_Sequences._default.NoDupes1) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@5 T@U) ($ly@@79 T@U) ($Heap@@44 T@U) (|s#0@@67| T@U) (|v#0@@22| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@5) TyType) (= (type $ly@@79) LayerTypeType)) (= (type $Heap@@44) (MapType0Type refType MapType1Type))) (= (type |s#0@@67|) (SeqType BoxType))) (= (type |v#0@@22|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@22|) (and (and ($IsGoodHeap $Heap@@44) ($Is |s#0@@67| (TSeq Sequences._default.RemoveOneValue$V@@5))) ($IsBox |v#0@@22| Sequences._default.RemoveOneValue$V@@5)))) (and (=> (|Seq#Contains| |s#0@@67| |v#0@@22|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@22|)) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes1)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes1)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes1) MoreFuel_Sequences._default.NoDupes1)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@5 ($LS $ly@@79) (Lit |s#0@@67|) |v#0@@22|) (ite  (not (|Seq#Contains| |s#0@@67| |v#0@@22|)) |s#0@@67| (let ((|i#1@@13| (|$let#4_i| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@22|)))
(|Seq#Append| (|Seq#Take| (Lit |s#0@@67|) |i#1@@13|) (|Seq#Drop| (Lit |s#0@@67|) (INTERNAL_add_boogie |i#1@@13| 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4972|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@5 ($LS $ly@@79) (Lit |s#0@@67|) |v#0@@22|) ($IsGoodHeap $Heap@@44))
))))
(assert (= (type MoreFuel_Sequences._default.NoDupes2) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@6 T@U) ($ly@@80 T@U) ($Heap@@45 T@U) (|s#0@@68| T@U) (|v#0@@23| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@6) TyType) (= (type $ly@@80) LayerTypeType)) (= (type $Heap@@45) (MapType0Type refType MapType1Type))) (= (type |s#0@@68|) (SeqType BoxType))) (= (type |v#0@@23|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@23|)) (and (and ($IsGoodHeap $Heap@@45) ($Is |s#0@@68| (TSeq Sequences._default.RemoveOneValue$V@@6))) ($IsBox |v#0@@23| Sequences._default.RemoveOneValue$V@@6)))) (and (=> (|Seq#Contains| |s#0@@68| |v#0@@23|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@23|))) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes2)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes2)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes2) MoreFuel_Sequences._default.NoDupes2)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@6 ($LS $ly@@80) (Lit |s#0@@68|) (Lit |v#0@@23|)) (ite  (not (|Seq#Contains| |s#0@@68| |v#0@@23|)) |s#0@@68| (let ((|i#2@@5| (|$let#4_i| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@23|))))
(|Seq#Append| (|Seq#Take| (Lit |s#0@@68|) |i#2@@5|) (|Seq#Drop| (Lit |s#0@@68|) (INTERNAL_add_boogie |i#2@@5| 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4973|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@6 ($LS $ly@@80) (Lit |s#0@@68|) (Lit |v#0@@23|)) ($IsGoodHeap $Heap@@45))
))))
(assert (forall ((arg0@@512 T@U) (arg1@@226 T@U) (arg2@@112 T@U) (arg3@@61 T@U) (arg4@@36 Int) ) (! (= (type (Sequences.__default.insert arg0@@512 arg1@@226 arg2@@112 arg3@@61 arg4@@36)) (SeqType BoxType))
 :qid |funType:Sequences.__default.insert|
 :pattern ( (Sequences.__default.insert arg0@@512 arg1@@226 arg2@@112 arg3@@61 arg4@@36))
)))
(assert (forall ((Sequences._default.insert$A T@U) ($ly@@81 T@U) (|s#0@@69| T@U) (|a#0@@27| T@U) (|pos#0@@5| Int) ) (!  (=> (and (and (and (= (type Sequences._default.insert$A) TyType) (= (type $ly@@81) LayerTypeType)) (= (type |s#0@@69|) (SeqType BoxType))) (= (type |a#0@@27|) BoxType)) (= (Sequences.__default.insert Sequences._default.insert$A ($LS $ly@@81) |s#0@@69| |a#0@@27| |pos#0@@5|) (Sequences.__default.insert Sequences._default.insert$A $ly@@81 |s#0@@69| |a#0@@27| |pos#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |4974|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A ($LS $ly@@81) |s#0@@69| |a#0@@27| |pos#0@@5|))
)))
(assert (forall ((Sequences._default.insert$A@@0 T@U) ($ly@@82 T@U) (|s#0@@70| T@U) (|a#0@@28| T@U) (|pos#0@@6| Int) ) (!  (=> (and (and (and (= (type Sequences._default.insert$A@@0) TyType) (= (type $ly@@82) LayerTypeType)) (= (type |s#0@@70|) (SeqType BoxType))) (= (type |a#0@@28|) BoxType)) (= (Sequences.__default.insert Sequences._default.insert$A@@0 $ly@@82 |s#0@@70| |a#0@@28| |pos#0@@6|) (Sequences.__default.insert Sequences._default.insert$A@@0 $LZ |s#0@@70| |a#0@@28| |pos#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |4975|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@0 (AsFuelBottom $ly@@82) |s#0@@70| |a#0@@28| |pos#0@@6|))
)))
(assert  (=> true (forall ((Sequences._default.insert$A@@1 T@U) ($ly@@83 T@U) (|s#0@@71| T@U) (|a#0@@29| T@U) (|pos#0@@7| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@1) TyType) (= (type $ly@@83) LayerTypeType)) (= (type |s#0@@71|) (SeqType BoxType))) (= (type |a#0@@29|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@1 |s#0@@71| |a#0@@29| |pos#0@@7|) (and (and ($Is |s#0@@71| (TSeq Sequences._default.insert$A@@1)) ($IsBox |a#0@@29| Sequences._default.insert$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@7|) (INTERNAL_le_boogie |pos#0@@7| (|Seq#Length| |s#0@@71|)))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|)) (INTERNAL_add_boogie (|Seq#Length| |s#0@@71|) 1)) (forall ((|i#0@@68| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@68|) (INTERNAL_lt_boogie |i#0@@68| |pos#0@@7|)) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) |i#0@@68|) (|Seq#Index| |s#0@@71| |i#0@@68|))))
 :qid |Sequencesidfy.387:18|
 :skolemid |4976|
 :pattern ( (|Seq#Index| |s#0@@71| |i#0@@68|))
 :pattern ( (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) |i#0@@68|))
))) (forall ((|i#1@@14| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie |pos#0@@7| |i#1@@14|) (INTERNAL_lt_boogie |i#1@@14| (|Seq#Length| |s#0@@71|))) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) (INTERNAL_add_boogie |i#1@@14| 1)) (|Seq#Index| |s#0@@71| |i#1@@14|))))
 :qid |Sequencesidfy.388:18|
 :skolemid |4977|
 :pattern ( (|Seq#Index| |s#0@@71| |i#1@@14|))
 :pattern ( (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) (INTERNAL_add_boogie |i#1@@14| 1)))
))) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) |pos#0@@7|) |a#0@@29|)) ($Is (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|) (TSeq Sequences._default.insert$A@@1))))
 :qid |unknown.0:0|
 :skolemid |4978|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@83 |s#0@@71| |a#0@@29| |pos#0@@7|))
))))
(assert (forall ((Sequences._default.insert$A@@2 T@U) ($ly@@84 T@U) (|s#0@@72| T@U) (|a#0@@30| T@U) (|pos#0@@8| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@2) TyType) (= (type $ly@@84) LayerTypeType)) (= (type |s#0@@72|) (SeqType BoxType))) (= (type |a#0@@30|) BoxType)) (and ($Is |s#0@@72| (TSeq Sequences._default.insert$A@@2)) ($IsBox |a#0@@30| Sequences._default.insert$A@@2))) (= (|Sequences.__default.insert#requires| Sequences._default.insert$A@@2 $ly@@84 |s#0@@72| |a#0@@30| |pos#0@@8|)  (and (INTERNAL_le_boogie 0 |pos#0@@8|) (INTERNAL_le_boogie |pos#0@@8| (|Seq#Length| |s#0@@72|)))))
 :qid |unknown.0:0|
 :skolemid |4979|
 :pattern ( (|Sequences.__default.insert#requires| Sequences._default.insert$A@@2 $ly@@84 |s#0@@72| |a#0@@30| |pos#0@@8|))
)))
(assert  (=> true (forall ((Sequences._default.insert$A@@3 T@U) ($ly@@85 T@U) (|s#0@@73| T@U) (|a#0@@31| T@U) (|pos#0@@9| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@3) TyType) (= (type $ly@@85) LayerTypeType)) (= (type |s#0@@73|) (SeqType BoxType))) (= (type |a#0@@31|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@3 |s#0@@73| |a#0@@31| |pos#0@@9|) (and (and ($Is |s#0@@73| (TSeq Sequences._default.insert$A@@3)) ($IsBox |a#0@@31| Sequences._default.insert$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@9|) (INTERNAL_le_boogie |pos#0@@9| (|Seq#Length| |s#0@@73|)))))) (= (Sequences.__default.insert Sequences._default.insert$A@@3 ($LS $ly@@85) |s#0@@73| |a#0@@31| |pos#0@@9|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@73| |pos#0@@9|) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@31|)) (|Seq#Drop| |s#0@@73| |pos#0@@9|))))
 :qid |unknown.0:0|
 :skolemid |4980|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@3 ($LS $ly@@85) |s#0@@73| |a#0@@31| |pos#0@@9|))
))))
(assert  (=> true (forall ((Sequences._default.insert$A@@4 T@U) ($ly@@86 T@U) (|s#0@@74| T@U) (|a#0@@32| T@U) (|pos#0@@10| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@4) TyType) (= (type $ly@@86) LayerTypeType)) (= (type |s#0@@74|) (SeqType BoxType))) (= (type |a#0@@32|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@4 (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)) (and (and ($Is |s#0@@74| (TSeq Sequences._default.insert$A@@4)) ($IsBox |a#0@@32| Sequences._default.insert$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@10|) (INTERNAL_le_boogie |pos#0@@10| (|Seq#Length| (Lit |s#0@@74|))))))) (= (Sequences.__default.insert Sequences._default.insert$A@@4 ($LS $ly@@86) (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@74|) (LitInt |pos#0@@10|)) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@32|)) (|Seq#Drop| (Lit |s#0@@74|) (LitInt |pos#0@@10|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4981|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@4 ($LS $ly@@86) (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)))
))))
(assert  (=> true (forall ((Sequences._default.insert$A@@5 T@U) ($ly@@87 T@U) (|s#0@@75| T@U) (|a#0@@33| T@U) (|pos#0@@11| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@5) TyType) (= (type $ly@@87) LayerTypeType)) (= (type |s#0@@75|) (SeqType BoxType))) (= (type |a#0@@33|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@5 (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)) (and (and ($Is |s#0@@75| (TSeq Sequences._default.insert$A@@5)) ($IsBox |a#0@@33| Sequences._default.insert$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@11|) (INTERNAL_le_boogie |pos#0@@11| (|Seq#Length| (Lit |s#0@@75|))))))) (= (Sequences.__default.insert Sequences._default.insert$A@@5 ($LS $ly@@87) (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@75|) (LitInt |pos#0@@11|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@33|))) (|Seq#Drop| (Lit |s#0@@75|) (LitInt |pos#0@@11|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4982|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@5 ($LS $ly@@87) (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)))
))))
(assert (forall ((arg0@@513 T@U) (arg1@@227 T@U) (arg2@@113 T@U) (arg3@@62 T@U) (arg4@@37 T@U) (arg5@@20 Int) ) (! (= (type (Sequences.__default.replace1with2 arg0@@513 arg1@@227 arg2@@113 arg3@@62 arg4@@37 arg5@@20)) (SeqType BoxType))
 :qid |funType:Sequences.__default.replace1with2|
 :pattern ( (Sequences.__default.replace1with2 arg0@@513 arg1@@227 arg2@@113 arg3@@62 arg4@@37 arg5@@20))
)))
(assert (forall ((Sequences._default.replace1with2$A T@U) ($ly@@88 T@U) (|s#0@@76| T@U) (|a#0@@34| T@U) (|b#0@@9| T@U) (|pos#0@@12| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace1with2$A) TyType) (= (type $ly@@88) LayerTypeType)) (= (type |s#0@@76|) (SeqType BoxType))) (= (type |a#0@@34|) BoxType)) (= (type |b#0@@9|) BoxType)) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A ($LS $ly@@88) |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|) (Sequences.__default.replace1with2 Sequences._default.replace1with2$A $ly@@88 |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |4983|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A ($LS $ly@@88) |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|))
)))
(assert (forall ((Sequences._default.replace1with2$A@@0 T@U) ($ly@@89 T@U) (|s#0@@77| T@U) (|a#0@@35| T@U) (|b#0@@10| T@U) (|pos#0@@13| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace1with2$A@@0) TyType) (= (type $ly@@89) LayerTypeType)) (= (type |s#0@@77|) (SeqType BoxType))) (= (type |a#0@@35|) BoxType)) (= (type |b#0@@10|) BoxType)) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 $ly@@89 |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|) (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 $LZ |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|)))
 :qid |unknown.0:0|
 :skolemid |4984|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 (AsFuelBottom $ly@@89) |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|))
)))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@1 T@U) ($ly@@90 T@U) (|s#0@@78| T@U) (|a#0@@36| T@U) (|b#0@@11| T@U) (|pos#0@@14| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@1) TyType) (= (type $ly@@90) LayerTypeType)) (= (type |s#0@@78|) (SeqType BoxType))) (= (type |a#0@@36|) BoxType)) (= (type |b#0@@11|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@1 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (and (and (and ($Is |s#0@@78| (TSeq Sequences._default.replace1with2$A@@1)) ($IsBox |a#0@@36| Sequences._default.replace1with2$A@@1)) ($IsBox |b#0@@11| Sequences._default.replace1with2$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@14|) (INTERNAL_lt_boogie |pos#0@@14| (|Seq#Length| |s#0@@78|)))))) (and (and (and (and (and (= (|Seq#Length| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|)) (INTERNAL_add_boogie (|Seq#Length| |s#0@@78|) 1)) (forall ((|i#0@@69| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@69|) (INTERNAL_lt_boogie |i#0@@69| |pos#0@@14|)) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |i#0@@69|) (|Seq#Index| |s#0@@78| |i#0@@69|))))
 :qid |Sequencesidfy.412:18|
 :skolemid |4985|
 :pattern ( (|Seq#Index| |s#0@@78| |i#0@@69|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |i#0@@69|))
))) (forall ((|i#1@@15| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie |pos#0@@14| |i#1@@15|) (INTERNAL_lt_boogie |i#1@@15| (|Seq#Length| |s#0@@78|))) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |i#1@@15| 1)) (|Seq#Index| |s#0@@78| |i#1@@15|))))
 :qid |Sequencesidfy.413:18|
 :skolemid |4986|
 :pattern ( (|Seq#Index| |s#0@@78| |i#1@@15|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |i#1@@15| 1)))
))) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |pos#0@@14|) |a#0@@36|)) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |pos#0@@14| 1)) |b#0@@11|)) ($Is (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (TSeq Sequences._default.replace1with2$A@@1))))
 :qid |unknown.0:0|
 :skolemid |4987|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@90 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|))
))))
(assert (forall ((Sequences._default.replace1with2$A@@2 T@U) ($ly@@91 T@U) (|s#0@@79| T@U) (|a#0@@37| T@U) (|b#0@@12| T@U) (|pos#0@@15| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@2) TyType) (= (type $ly@@91) LayerTypeType)) (= (type |s#0@@79|) (SeqType BoxType))) (= (type |a#0@@37|) BoxType)) (= (type |b#0@@12|) BoxType)) (and (and ($Is |s#0@@79| (TSeq Sequences._default.replace1with2$A@@2)) ($IsBox |a#0@@37| Sequences._default.replace1with2$A@@2)) ($IsBox |b#0@@12| Sequences._default.replace1with2$A@@2))) (= (|Sequences.__default.replace1with2#requires| Sequences._default.replace1with2$A@@2 $ly@@91 |s#0@@79| |a#0@@37| |b#0@@12| |pos#0@@15|)  (and (INTERNAL_le_boogie 0 |pos#0@@15|) (INTERNAL_lt_boogie |pos#0@@15| (|Seq#Length| |s#0@@79|)))))
 :qid |unknown.0:0|
 :skolemid |4988|
 :pattern ( (|Sequences.__default.replace1with2#requires| Sequences._default.replace1with2$A@@2 $ly@@91 |s#0@@79| |a#0@@37| |b#0@@12| |pos#0@@15|))
)))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@3 T@U) ($ly@@92 T@U) (|s#0@@80| T@U) (|a#0@@38| T@U) (|b#0@@13| T@U) (|pos#0@@16| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@3) TyType) (= (type $ly@@92) LayerTypeType)) (= (type |s#0@@80|) (SeqType BoxType))) (= (type |a#0@@38|) BoxType)) (= (type |b#0@@13|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@3 |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|) (and (and (and ($Is |s#0@@80| (TSeq Sequences._default.replace1with2$A@@3)) ($IsBox |a#0@@38| Sequences._default.replace1with2$A@@3)) ($IsBox |b#0@@13| Sequences._default.replace1with2$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@16|) (INTERNAL_lt_boogie |pos#0@@16| (|Seq#Length| |s#0@@80|)))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@3 ($LS $ly@@92) |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@80| |pos#0@@16|) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@38|) |b#0@@13|)) (|Seq#Drop| |s#0@@80| (INTERNAL_add_boogie |pos#0@@16| 1)))))
 :qid |unknown.0:0|
 :skolemid |4989|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@3 ($LS $ly@@92) |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|))
))))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@4 T@U) ($ly@@93 T@U) (|s#0@@81| T@U) (|a#0@@39| T@U) (|b#0@@14| T@U) (|pos#0@@17| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@4) TyType) (= (type $ly@@93) LayerTypeType)) (= (type |s#0@@81|) (SeqType BoxType))) (= (type |a#0@@39|) BoxType)) (= (type |b#0@@14|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@4 (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)) (and (and (and ($Is |s#0@@81| (TSeq Sequences._default.replace1with2$A@@4)) ($IsBox |a#0@@39| Sequences._default.replace1with2$A@@4)) ($IsBox |b#0@@14| Sequences._default.replace1with2$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@17|) (INTERNAL_lt_boogie |pos#0@@17| (|Seq#Length| (Lit |s#0@@81|))))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@4 ($LS $ly@@93) (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@81|) (LitInt |pos#0@@17|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@39|) |b#0@@14|)) (|Seq#Drop| (Lit |s#0@@81|) (LitInt (INTERNAL_add_boogie |pos#0@@17| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4990|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@4 ($LS $ly@@93) (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)))
))))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@5 T@U) ($ly@@94 T@U) (|s#0@@82| T@U) (|a#0@@40| T@U) (|b#0@@15| T@U) (|pos#0@@18| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@5) TyType) (= (type $ly@@94) LayerTypeType)) (= (type |s#0@@82|) (SeqType BoxType))) (= (type |a#0@@40|) BoxType)) (= (type |b#0@@15|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@5 (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)) (and (and (and ($Is |s#0@@82| (TSeq Sequences._default.replace1with2$A@@5)) ($IsBox |a#0@@40| Sequences._default.replace1with2$A@@5)) ($IsBox |b#0@@15| Sequences._default.replace1with2$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@18|) (INTERNAL_lt_boogie |pos#0@@18| (|Seq#Length| (Lit |s#0@@82|))))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@5 ($LS $ly@@94) (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@82|) (LitInt |pos#0@@18|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@40|)) (Lit |b#0@@15|))) (|Seq#Drop| (Lit |s#0@@82|) (LitInt (INTERNAL_add_boogie |pos#0@@18| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4991|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@5 ($LS $ly@@94) (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)))
))))
(assert (forall ((arg0@@514 T@U) (arg1@@228 T@U) (arg2@@114 T@U) (arg3@@63 T@U) (arg4@@38 Int) ) (! (= (type (Sequences.__default.replace2with1 arg0@@514 arg1@@228 arg2@@114 arg3@@63 arg4@@38)) (SeqType BoxType))
 :qid |funType:Sequences.__default.replace2with1|
 :pattern ( (Sequences.__default.replace2with1 arg0@@514 arg1@@228 arg2@@114 arg3@@63 arg4@@38))
)))
(assert (forall ((Sequences._default.replace2with1$A T@U) ($ly@@95 T@U) (|s#0@@83| T@U) (|a#0@@41| T@U) (|pos#0@@19| Int) ) (!  (=> (and (and (and (= (type Sequences._default.replace2with1$A) TyType) (= (type $ly@@95) LayerTypeType)) (= (type |s#0@@83|) (SeqType BoxType))) (= (type |a#0@@41|) BoxType)) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A ($LS $ly@@95) |s#0@@83| |a#0@@41| |pos#0@@19|) (Sequences.__default.replace2with1 Sequences._default.replace2with1$A $ly@@95 |s#0@@83| |a#0@@41| |pos#0@@19|)))
 :qid |unknown.0:0|
 :skolemid |4992|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A ($LS $ly@@95) |s#0@@83| |a#0@@41| |pos#0@@19|))
)))
(assert (forall ((Sequences._default.replace2with1$A@@0 T@U) ($ly@@96 T@U) (|s#0@@84| T@U) (|a#0@@42| T@U) (|pos#0@@20| Int) ) (!  (=> (and (and (and (= (type Sequences._default.replace2with1$A@@0) TyType) (= (type $ly@@96) LayerTypeType)) (= (type |s#0@@84|) (SeqType BoxType))) (= (type |a#0@@42|) BoxType)) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 $ly@@96 |s#0@@84| |a#0@@42| |pos#0@@20|) (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 $LZ |s#0@@84| |a#0@@42| |pos#0@@20|)))
 :qid |unknown.0:0|
 :skolemid |4993|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 (AsFuelBottom $ly@@96) |s#0@@84| |a#0@@42| |pos#0@@20|))
)))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@1 T@U) ($ly@@97 T@U) (|s#0@@85| T@U) (|a#0@@43| T@U) (|pos#0@@21| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@1) TyType) (= (type $ly@@97) LayerTypeType)) (= (type |s#0@@85|) (SeqType BoxType))) (= (type |a#0@@43|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@1 |s#0@@85| |a#0@@43| |pos#0@@21|) (and (and ($Is |s#0@@85| (TSeq Sequences._default.replace2with1$A@@1)) ($IsBox |a#0@@43| Sequences._default.replace2with1$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@21|) (INTERNAL_lt_boogie |pos#0@@21| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1)))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|)) (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1)) (forall ((|i#0@@70| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@70|) (INTERNAL_lt_boogie |i#0@@70| |pos#0@@21|)) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#0@@70|) (|Seq#Index| |s#0@@85| |i#0@@70|))))
 :qid |Sequencesidfy.431:18|
 :skolemid |4994|
 :pattern ( (|Seq#Index| |s#0@@85| |i#0@@70|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#0@@70|))
))) (forall ((|i#1@@16| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie |pos#0@@21| |i#1@@16|) (INTERNAL_lt_boogie |i#1@@16| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1))) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#1@@16|) (|Seq#Index| |s#0@@85| (INTERNAL_add_boogie |i#1@@16| 1)))))
 :qid |Sequencesidfy.432:18|
 :skolemid |4995|
 :pattern ( (|Seq#Index| |s#0@@85| (INTERNAL_add_boogie |i#1@@16| 1)))
 :pattern ( (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#1@@16|))
))) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) |pos#0@@21|) |a#0@@43|)) ($Is (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|) (TSeq Sequences._default.replace2with1$A@@1))))
 :qid |unknown.0:0|
 :skolemid |4996|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@97 |s#0@@85| |a#0@@43| |pos#0@@21|))
))))
(assert (forall ((Sequences._default.replace2with1$A@@2 T@U) ($ly@@98 T@U) (|s#0@@86| T@U) (|a#0@@44| T@U) (|pos#0@@22| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@2) TyType) (= (type $ly@@98) LayerTypeType)) (= (type |s#0@@86|) (SeqType BoxType))) (= (type |a#0@@44|) BoxType)) (and ($Is |s#0@@86| (TSeq Sequences._default.replace2with1$A@@2)) ($IsBox |a#0@@44| Sequences._default.replace2with1$A@@2))) (= (|Sequences.__default.replace2with1#requires| Sequences._default.replace2with1$A@@2 $ly@@98 |s#0@@86| |a#0@@44| |pos#0@@22|)  (and (INTERNAL_le_boogie 0 |pos#0@@22|) (INTERNAL_lt_boogie |pos#0@@22| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@86|) 1)))))
 :qid |unknown.0:0|
 :skolemid |4997|
 :pattern ( (|Sequences.__default.replace2with1#requires| Sequences._default.replace2with1$A@@2 $ly@@98 |s#0@@86| |a#0@@44| |pos#0@@22|))
)))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@3 T@U) ($ly@@99 T@U) (|s#0@@87| T@U) (|a#0@@45| T@U) (|pos#0@@23| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@3) TyType) (= (type $ly@@99) LayerTypeType)) (= (type |s#0@@87|) (SeqType BoxType))) (= (type |a#0@@45|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@3 |s#0@@87| |a#0@@45| |pos#0@@23|) (and (and ($Is |s#0@@87| (TSeq Sequences._default.replace2with1$A@@3)) ($IsBox |a#0@@45| Sequences._default.replace2with1$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@23|) (INTERNAL_lt_boogie |pos#0@@23| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@87|) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@3 ($LS $ly@@99) |s#0@@87| |a#0@@45| |pos#0@@23|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@87| |pos#0@@23|) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@45|)) (|Seq#Drop| |s#0@@87| (INTERNAL_add_boogie |pos#0@@23| 2)))))
 :qid |unknown.0:0|
 :skolemid |4998|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@3 ($LS $ly@@99) |s#0@@87| |a#0@@45| |pos#0@@23|))
))))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@4 T@U) ($ly@@100 T@U) (|s#0@@88| T@U) (|a#0@@46| T@U) (|pos#0@@24| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@4) TyType) (= (type $ly@@100) LayerTypeType)) (= (type |s#0@@88|) (SeqType BoxType))) (= (type |a#0@@46|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@4 (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)) (and (and ($Is |s#0@@88| (TSeq Sequences._default.replace2with1$A@@4)) ($IsBox |a#0@@46| Sequences._default.replace2with1$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@24|) (INTERNAL_lt_boogie |pos#0@@24| (INTERNAL_sub_boogie (|Seq#Length| (Lit |s#0@@88|)) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@4 ($LS $ly@@100) (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@88|) (LitInt |pos#0@@24|)) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@46|)) (|Seq#Drop| (Lit |s#0@@88|) (LitInt (INTERNAL_add_boogie |pos#0@@24| 2))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4999|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@4 ($LS $ly@@100) (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)))
))))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@5 T@U) ($ly@@101 T@U) (|s#0@@89| T@U) (|a#0@@47| T@U) (|pos#0@@25| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@5) TyType) (= (type $ly@@101) LayerTypeType)) (= (type |s#0@@89|) (SeqType BoxType))) (= (type |a#0@@47|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@5 (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)) (and (and ($Is |s#0@@89| (TSeq Sequences._default.replace2with1$A@@5)) ($IsBox |a#0@@47| Sequences._default.replace2with1$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@25|) (INTERNAL_lt_boogie |pos#0@@25| (INTERNAL_sub_boogie (|Seq#Length| (Lit |s#0@@89|)) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@5 ($LS $ly@@101) (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@89|) (LitInt |pos#0@@25|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@47|))) (|Seq#Drop| (Lit |s#0@@89|) (LitInt (INTERNAL_add_boogie |pos#0@@25| 2))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5000|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@5 ($LS $ly@@101) (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)))
))))
(assert (forall ((arg0@@515 T@U) (arg1@@229 T@U) (arg2@@115 T@U) (arg3@@64 T@U) ) (! (= (type (Sequences.__default.concat arg0@@515 arg1@@229 arg2@@115 arg3@@64)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concat|
 :pattern ( (Sequences.__default.concat arg0@@515 arg1@@229 arg2@@115 arg3@@64))
)))
(assert (forall ((Sequences._default.concat$A T@U) ($ly@@102 T@U) (|a#0@@48| T@U) (|b#0@@16| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concat$A) TyType) (= (type $ly@@102) LayerTypeType)) (= (type |a#0@@48|) (SeqType BoxType))) (= (type |b#0@@16|) (SeqType BoxType))) (= (Sequences.__default.concat Sequences._default.concat$A ($LS $ly@@102) |a#0@@48| |b#0@@16|) (Sequences.__default.concat Sequences._default.concat$A $ly@@102 |a#0@@48| |b#0@@16|)))
 :qid |unknown.0:0|
 :skolemid |5001|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A ($LS $ly@@102) |a#0@@48| |b#0@@16|))
)))
(assert (forall ((Sequences._default.concat$A@@0 T@U) ($ly@@103 T@U) (|a#0@@49| T@U) (|b#0@@17| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concat$A@@0) TyType) (= (type $ly@@103) LayerTypeType)) (= (type |a#0@@49|) (SeqType BoxType))) (= (type |b#0@@17|) (SeqType BoxType))) (= (Sequences.__default.concat Sequences._default.concat$A@@0 $ly@@103 |a#0@@49| |b#0@@17|) (Sequences.__default.concat Sequences._default.concat$A@@0 $LZ |a#0@@49| |b#0@@17|)))
 :qid |unknown.0:0|
 :skolemid |5002|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@0 (AsFuelBottom $ly@@103) |a#0@@49| |b#0@@17|))
)))
(assert  (=> true (forall ((Sequences._default.concat$A@@1 T@U) ($ly@@104 T@U) (|a#0@@50| T@U) (|b#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@1) TyType) (= (type $ly@@104) LayerTypeType)) (= (type |a#0@@50|) (SeqType BoxType))) (= (type |b#0@@18|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@1 |a#0@@50| |b#0@@18|) (and ($Is |a#0@@50| (TSeq Sequences._default.concat$A@@1)) ($Is |b#0@@18| (TSeq Sequences._default.concat$A@@1))))) (and (and (and (= (|Seq#Length| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|)) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) (|Seq#Length| |b#0@@18|))) (forall ((|i#0@@71| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@71|) (INTERNAL_lt_boogie |i#0@@71| (|Seq#Length| |a#0@@50|))) (= (|Seq#Index| |a#0@@50| |i#0@@71|) (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|) |i#0@@71|))))
 :qid |Sequencesidfy.440:18|
 :skolemid |5003|
 :pattern ( (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|) |i#0@@71|))
 :pattern ( (|Seq#Index| |a#0@@50| |i#0@@71|))
))) (forall ((|i#1@@17| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@17|) (INTERNAL_lt_boogie |i#1@@17| (|Seq#Length| |b#0@@18|))) (= (|Seq#Index| |b#0@@18| |i#1@@17|) (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) |i#1@@17|)))))
 :qid |Sequencesidfy.441:18|
 :skolemid |5004|
 :pattern ( (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) |i#1@@17|)))
 :pattern ( (|Seq#Index| |b#0@@18| |i#1@@17|))
))) ($Is (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|) (TSeq Sequences._default.concat$A@@1))))
 :qid |unknown.0:0|
 :skolemid |5005|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@104 |a#0@@50| |b#0@@18|))
))))
(assert (forall ((Sequences._default.concat$A@@2 T@U) ($ly@@105 T@U) (|a#0@@51| T@U) (|b#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@2) TyType) (= (type $ly@@105) LayerTypeType)) (= (type |a#0@@51|) (SeqType BoxType))) (= (type |b#0@@19|) (SeqType BoxType))) (and ($Is |a#0@@51| (TSeq Sequences._default.concat$A@@2)) ($Is |b#0@@19| (TSeq Sequences._default.concat$A@@2)))) (= (|Sequences.__default.concat#requires| Sequences._default.concat$A@@2 $ly@@105 |a#0@@51| |b#0@@19|) true))
 :qid |unknown.0:0|
 :skolemid |5006|
 :pattern ( (|Sequences.__default.concat#requires| Sequences._default.concat$A@@2 $ly@@105 |a#0@@51| |b#0@@19|))
)))
(assert  (=> true (forall ((Sequences._default.concat$A@@3 T@U) ($ly@@106 T@U) (|a#0@@52| T@U) (|b#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@3) TyType) (= (type $ly@@106) LayerTypeType)) (= (type |a#0@@52|) (SeqType BoxType))) (= (type |b#0@@20|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@3 |a#0@@52| |b#0@@20|) (and ($Is |a#0@@52| (TSeq Sequences._default.concat$A@@3)) ($Is |b#0@@20| (TSeq Sequences._default.concat$A@@3))))) (= (Sequences.__default.concat Sequences._default.concat$A@@3 ($LS $ly@@106) |a#0@@52| |b#0@@20|) (|Seq#Append| |a#0@@52| |b#0@@20|)))
 :qid |unknown.0:0|
 :skolemid |5007|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@3 ($LS $ly@@106) |a#0@@52| |b#0@@20|))
))))
(assert  (=> true (forall ((Sequences._default.concat$A@@4 T@U) ($ly@@107 T@U) (|a#0@@53| T@U) (|b#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@4) TyType) (= (type $ly@@107) LayerTypeType)) (= (type |a#0@@53|) (SeqType BoxType))) (= (type |b#0@@21|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@4 (Lit |a#0@@53|) (Lit |b#0@@21|)) (and ($Is |a#0@@53| (TSeq Sequences._default.concat$A@@4)) ($Is |b#0@@21| (TSeq Sequences._default.concat$A@@4))))) (= (Sequences.__default.concat Sequences._default.concat$A@@4 ($LS $ly@@107) (Lit |a#0@@53|) (Lit |b#0@@21|)) (|Seq#Append| |a#0@@53| |b#0@@21|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5008|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@4 ($LS $ly@@107) (Lit |a#0@@53|) (Lit |b#0@@21|)))
))))
(assert (forall ((arg0@@516 T@U) (arg1@@230 T@U) (arg2@@116 T@U) (arg3@@65 T@U) (arg4@@39 T@U) ) (! (= (type (Sequences.__default.concat3 arg0@@516 arg1@@230 arg2@@116 arg3@@65 arg4@@39)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concat3|
 :pattern ( (Sequences.__default.concat3 arg0@@516 arg1@@230 arg2@@116 arg3@@65 arg4@@39))
)))
(assert (forall ((Sequences._default.concat3$A T@U) ($ly@@108 T@U) (|a#0@@54| T@U) (|b#0@@22| T@U) (|c#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat3$A) TyType) (= (type $ly@@108) LayerTypeType)) (= (type |a#0@@54|) (SeqType BoxType))) (= (type |b#0@@22|) BoxType)) (= (type |c#0@@3|) (SeqType BoxType))) (= (Sequences.__default.concat3 Sequences._default.concat3$A ($LS $ly@@108) |a#0@@54| |b#0@@22| |c#0@@3|) (Sequences.__default.concat3 Sequences._default.concat3$A $ly@@108 |a#0@@54| |b#0@@22| |c#0@@3|)))
 :qid |unknown.0:0|
 :skolemid |5009|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A ($LS $ly@@108) |a#0@@54| |b#0@@22| |c#0@@3|))
)))
(assert (forall ((Sequences._default.concat3$A@@0 T@U) ($ly@@109 T@U) (|a#0@@55| T@U) (|b#0@@23| T@U) (|c#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat3$A@@0) TyType) (= (type $ly@@109) LayerTypeType)) (= (type |a#0@@55|) (SeqType BoxType))) (= (type |b#0@@23|) BoxType)) (= (type |c#0@@4|) (SeqType BoxType))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@0 $ly@@109 |a#0@@55| |b#0@@23| |c#0@@4|) (Sequences.__default.concat3 Sequences._default.concat3$A@@0 $LZ |a#0@@55| |b#0@@23| |c#0@@4|)))
 :qid |unknown.0:0|
 :skolemid |5010|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@0 (AsFuelBottom $ly@@109) |a#0@@55| |b#0@@23| |c#0@@4|))
)))
(assert  (=> true (forall ((Sequences._default.concat3$A@@1 T@U) ($ly@@110 T@U) (|a#0@@56| T@U) (|b#0@@24| T@U) (|c#0@@5| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@1) TyType) (= (type $ly@@110) LayerTypeType)) (= (type |a#0@@56|) (SeqType BoxType))) (= (type |b#0@@24|) BoxType)) (= (type |c#0@@5|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@1 |a#0@@56| |b#0@@24| |c#0@@5|) (and (and ($Is |a#0@@56| (TSeq Sequences._default.concat3$A@@1)) ($IsBox |b#0@@24| Sequences._default.concat3$A@@1)) ($Is |c#0@@5| (TSeq Sequences._default.concat3$A@@1))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|)) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) (|Seq#Length| |c#0@@5|)) 1)) (forall ((|i#0@@72| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@72|) (INTERNAL_lt_boogie |i#0@@72| (|Seq#Length| |a#0@@56|))) (= (|Seq#Index| |a#0@@56| |i#0@@72|) (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) |i#0@@72|))))
 :qid |Sequencesidfy.448:18|
 :skolemid |5011|
 :pattern ( (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) |i#0@@72|))
 :pattern ( (|Seq#Index| |a#0@@56| |i#0@@72|))
))) (= (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) (|Seq#Length| |a#0@@56|)) |b#0@@24|)) (forall ((|i#1@@18| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@18|) (INTERNAL_lt_boogie |i#1@@18| (|Seq#Length| |c#0@@5|))) (= (|Seq#Index| |c#0@@5| |i#1@@18|) (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) 1) |i#1@@18|)))))
 :qid |Sequencesidfy.450:18|
 :skolemid |5012|
 :pattern ( (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) 1) |i#1@@18|)))
 :pattern ( (|Seq#Index| |c#0@@5| |i#1@@18|))
))) ($Is (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|) (TSeq Sequences._default.concat3$A@@1))))
 :qid |unknown.0:0|
 :skolemid |5013|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@110 |a#0@@56| |b#0@@24| |c#0@@5|))
))))
(assert (forall ((Sequences._default.concat3$A@@2 T@U) ($ly@@111 T@U) (|a#0@@57| T@U) (|b#0@@25| T@U) (|c#0@@6| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@2) TyType) (= (type $ly@@111) LayerTypeType)) (= (type |a#0@@57|) (SeqType BoxType))) (= (type |b#0@@25|) BoxType)) (= (type |c#0@@6|) (SeqType BoxType))) (and (and ($Is |a#0@@57| (TSeq Sequences._default.concat3$A@@2)) ($IsBox |b#0@@25| Sequences._default.concat3$A@@2)) ($Is |c#0@@6| (TSeq Sequences._default.concat3$A@@2)))) (= (|Sequences.__default.concat3#requires| Sequences._default.concat3$A@@2 $ly@@111 |a#0@@57| |b#0@@25| |c#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |5014|
 :pattern ( (|Sequences.__default.concat3#requires| Sequences._default.concat3$A@@2 $ly@@111 |a#0@@57| |b#0@@25| |c#0@@6|))
)))
(assert  (=> true (forall ((Sequences._default.concat3$A@@3 T@U) ($ly@@112 T@U) (|a#0@@58| T@U) (|b#0@@26| T@U) (|c#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@3) TyType) (= (type $ly@@112) LayerTypeType)) (= (type |a#0@@58|) (SeqType BoxType))) (= (type |b#0@@26|) BoxType)) (= (type |c#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@3 |a#0@@58| |b#0@@26| |c#0@@7|) (and (and ($Is |a#0@@58| (TSeq Sequences._default.concat3$A@@3)) ($IsBox |b#0@@26| Sequences._default.concat3$A@@3)) ($Is |c#0@@7| (TSeq Sequences._default.concat3$A@@3))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@3 ($LS $ly@@112) |a#0@@58| |b#0@@26| |c#0@@7|) (|Seq#Append| (|Seq#Append| |a#0@@58| (|Seq#Build| (|Seq#Empty| BoxType) |b#0@@26|)) |c#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |5015|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@3 ($LS $ly@@112) |a#0@@58| |b#0@@26| |c#0@@7|))
))))
(assert  (=> true (forall ((Sequences._default.concat3$A@@4 T@U) ($ly@@113 T@U) (|a#0@@59| T@U) (|b#0@@27| T@U) (|c#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@4) TyType) (= (type $ly@@113) LayerTypeType)) (= (type |a#0@@59|) (SeqType BoxType))) (= (type |b#0@@27|) BoxType)) (= (type |c#0@@8|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@4 (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)) (and (and ($Is |a#0@@59| (TSeq Sequences._default.concat3$A@@4)) ($IsBox |b#0@@27| Sequences._default.concat3$A@@4)) ($Is |c#0@@8| (TSeq Sequences._default.concat3$A@@4))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@4 ($LS $ly@@113) (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)) (|Seq#Append| (|Seq#Append| |a#0@@59| (|Seq#Build| (|Seq#Empty| BoxType) |b#0@@27|)) |c#0@@8|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5016|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@4 ($LS $ly@@113) (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)))
))))
(assert  (=> true (forall ((Sequences._default.concat3$A@@5 T@U) ($ly@@114 T@U) (|a#0@@60| T@U) (|b#0@@28| T@U) (|c#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@5) TyType) (= (type $ly@@114) LayerTypeType)) (= (type |a#0@@60|) (SeqType BoxType))) (= (type |b#0@@28|) BoxType)) (= (type |c#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@5 (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)) (and (and ($Is |a#0@@60| (TSeq Sequences._default.concat3$A@@5)) ($IsBox |b#0@@28| Sequences._default.concat3$A@@5)) ($Is |c#0@@9| (TSeq Sequences._default.concat3$A@@5))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@5 ($LS $ly@@114) (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)) (|Seq#Append| (|Seq#Append| |a#0@@60| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |b#0@@28|))) |c#0@@9|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5017|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@5 ($LS $ly@@114) (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)))
))))
(assert (forall ((arg0@@517 T@U) (arg1@@231 T@U) (arg2@@117 T@U) ) (! (= (type (Sequences.__default.concatSeq arg0@@517 arg1@@231 arg2@@117)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concatSeq|
 :pattern ( (Sequences.__default.concatSeq arg0@@517 arg1@@231 arg2@@117))
)))
(assert (forall ((Sequences._default.concatSeq$A T@U) ($ly@@115 T@U) (|a#0@@61| T@U) ) (!  (=> (and (and (= (type Sequences._default.concatSeq$A) TyType) (= (type $ly@@115) LayerTypeType)) (= (type |a#0@@61|) (SeqType BoxType))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A ($LS $ly@@115) |a#0@@61|) (Sequences.__default.concatSeq Sequences._default.concatSeq$A $ly@@115 |a#0@@61|)))
 :qid |unknown.0:0|
 :skolemid |5018|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A ($LS $ly@@115) |a#0@@61|))
)))
(assert (forall ((Sequences._default.concatSeq$A@@0 T@U) ($ly@@116 T@U) (|a#0@@62| T@U) ) (!  (=> (and (and (= (type Sequences._default.concatSeq$A@@0) TyType) (= (type $ly@@116) LayerTypeType)) (= (type |a#0@@62|) (SeqType BoxType))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 $ly@@116 |a#0@@62|) (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 $LZ |a#0@@62|)))
 :qid |unknown.0:0|
 :skolemid |5019|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 (AsFuelBottom $ly@@116) |a#0@@62|))
)))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@1 T@U) ($ly@@117 T@U) (|a#0@@63| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@1) TyType) (= (type $ly@@117) LayerTypeType)) (= (type |a#0@@63|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@1 |a#0@@63|) ($Is |a#0@@63| (TSeq (TSeq Sequences._default.concatSeq$A@@1))))) ($Is (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@1 $ly@@117 |a#0@@63|) (TSeq Sequences._default.concatSeq$A@@1)))
 :qid |unknown.0:0|
 :skolemid |5020|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@1 $ly@@117 |a#0@@63|))
))))
(assert (forall ((Sequences._default.concatSeq$A@@2 T@U) ($ly@@118 T@U) (|a#0@@64| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@2) TyType) (= (type $ly@@118) LayerTypeType)) (= (type |a#0@@64|) (SeqType BoxType))) ($Is |a#0@@64| (TSeq (TSeq Sequences._default.concatSeq$A@@2)))) (= (|Sequences.__default.concatSeq#requires| Sequences._default.concatSeq$A@@2 $ly@@118 |a#0@@64|) true))
 :qid |unknown.0:0|
 :skolemid |5021|
 :pattern ( (|Sequences.__default.concatSeq#requires| Sequences._default.concatSeq$A@@2 $ly@@118 |a#0@@64|))
)))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@3 T@U) ($ly@@119 T@U) (|a#0@@65| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@3) TyType) (= (type $ly@@119) LayerTypeType)) (= (type |a#0@@65|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@3 |a#0@@65|) ($Is |a#0@@65| (TSeq (TSeq Sequences._default.concatSeq$A@@3))))) (and (=> (not (= (|Seq#Length| |a#0@@65|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|) (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 ($LS $ly@@119) |a#0@@65|) (ite (= (|Seq#Length| |a#0@@65|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 $ly@@119 (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|)) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|)))))))
 :qid |unknown.0:0|
 :skolemid |5022|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 ($LS $ly@@119) |a#0@@65|))
))))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@4 T@U) ($ly@@120 T@U) (|a#0@@66| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@4) TyType) (= (type $ly@@120) LayerTypeType)) (= (type |a#0@@66|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@4 (Lit |a#0@@66|)) ($Is |a#0@@66| (TSeq (TSeq Sequences._default.concatSeq$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)) (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@120) (Lit |a#0@@66|)) (ite (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@120) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)))) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5023|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@120) (Lit |a#0@@66|)))
))))
(assert (forall ((Sequences._default.IsPrefix$A T@U) ($ly@@121 T@U) (|a#0@@67| T@U) (|b#0@@29| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsPrefix$A) TyType) (= (type $ly@@121) LayerTypeType)) (= (type |a#0@@67|) (SeqType BoxType))) (= (type |b#0@@29|) (SeqType BoxType))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A ($LS $ly@@121) |a#0@@67| |b#0@@29|) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A $ly@@121 |a#0@@67| |b#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |5024|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A ($LS $ly@@121) |a#0@@67| |b#0@@29|))
)))
(assert (forall ((Sequences._default.IsPrefix$A@@0 T@U) ($ly@@122 T@U) (|a#0@@68| T@U) (|b#0@@30| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsPrefix$A@@0) TyType) (= (type $ly@@122) LayerTypeType)) (= (type |a#0@@68|) (SeqType BoxType))) (= (type |b#0@@30|) (SeqType BoxType))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 $ly@@122 |a#0@@68| |b#0@@30|) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 $LZ |a#0@@68| |b#0@@30|)))
 :qid |unknown.0:0|
 :skolemid |5025|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 (AsFuelBottom $ly@@122) |a#0@@68| |b#0@@30|))
)))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@1 T@U) ($ly@@123 T@U) (|a#0@@69| T@U) (|b#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.IsPrefix$A@@1) TyType) (= (type $ly@@123) LayerTypeType)) (= (type |a#0@@69|) (SeqType BoxType))) (= (type |b#0@@31|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@1 |a#0@@69| |b#0@@31|) (and ($Is |a#0@@69| (TSeq Sequences._default.IsPrefix$A@@1)) ($Is |b#0@@31| (TSeq Sequences._default.IsPrefix$A@@1))))) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@1 $ly@@123 |a#0@@69| |b#0@@31|)) (INTERNAL_le_boogie (|Seq#Length| |a#0@@69|) (|Seq#Length| |b#0@@31|)))
 :qid |unknown.0:0|
 :skolemid |5026|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@1 $ly@@123 |a#0@@69| |b#0@@31|))
))))
(assert (forall ((Sequences._default.IsPrefix$A@@2 T@U) ($ly@@124 T@U) (|a#0@@70| T@U) (|b#0@@32| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@2) TyType) (= (type $ly@@124) LayerTypeType)) (= (type |a#0@@70|) (SeqType BoxType))) (= (type |b#0@@32|) (SeqType BoxType))) (and ($Is |a#0@@70| (TSeq Sequences._default.IsPrefix$A@@2)) ($Is |b#0@@32| (TSeq Sequences._default.IsPrefix$A@@2)))) (= (|Sequences.__default.IsPrefix#requires| Sequences._default.IsPrefix$A@@2 $ly@@124 |a#0@@70| |b#0@@32|) true))
 :qid |unknown.0:0|
 :skolemid |5027|
 :pattern ( (|Sequences.__default.IsPrefix#requires| Sequences._default.IsPrefix$A@@2 $ly@@124 |a#0@@70| |b#0@@32|))
)))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@3 T@U) ($ly@@125 T@U) (|a#0@@71| T@U) (|b#0@@33| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@3) TyType) (= (type $ly@@125) LayerTypeType)) (= (type |a#0@@71|) (SeqType BoxType))) (= (type |b#0@@33|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@3 |a#0@@71| |b#0@@33|) (and ($Is |a#0@@71| (TSeq Sequences._default.IsPrefix$A@@3)) ($Is |b#0@@33| (TSeq Sequences._default.IsPrefix$A@@3))))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@3 ($LS $ly@@125) |a#0@@71| |b#0@@33|)  (and (INTERNAL_le_boogie (|Seq#Length| |a#0@@71|) (|Seq#Length| |b#0@@33|)) (|Seq#Equal| |a#0@@71| (|Seq#Take| |b#0@@33| (|Seq#Length| |a#0@@71|))))))
 :qid |unknown.0:0|
 :skolemid |5028|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@3 ($LS $ly@@125) |a#0@@71| |b#0@@33|))
))))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@4 T@U) ($ly@@126 T@U) (|a#0@@72| T@U) (|b#0@@34| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@4) TyType) (= (type $ly@@126) LayerTypeType)) (= (type |a#0@@72|) (SeqType BoxType))) (= (type |b#0@@34|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@4 (Lit |a#0@@72|) (Lit |b#0@@34|)) (and ($Is |a#0@@72| (TSeq Sequences._default.IsPrefix$A@@4)) ($Is |b#0@@34| (TSeq Sequences._default.IsPrefix$A@@4))))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@4 ($LS $ly@@126) (Lit |a#0@@72|) (Lit |b#0@@34|))  (and (INTERNAL_le_boogie (|Seq#Length| (Lit |a#0@@72|)) (|Seq#Length| (Lit |b#0@@34|))) (|Seq#Equal| |a#0@@72| (|Seq#Take| (Lit |b#0@@34|) (|Seq#Length| (Lit |a#0@@72|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5029|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@4 ($LS $ly@@126) (Lit |a#0@@72|) (Lit |b#0@@34|)))
))))
(assert (forall ((Sequences._default.IsSuffix$A T@U) ($ly@@127 T@U) (|a#0@@73| T@U) (|b#0@@35| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsSuffix$A) TyType) (= (type $ly@@127) LayerTypeType)) (= (type |a#0@@73|) (SeqType BoxType))) (= (type |b#0@@35|) (SeqType BoxType))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A ($LS $ly@@127) |a#0@@73| |b#0@@35|) (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A $ly@@127 |a#0@@73| |b#0@@35|)))
 :qid |unknown.0:0|
 :skolemid |5030|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A ($LS $ly@@127) |a#0@@73| |b#0@@35|))
)))
(assert (forall ((Sequences._default.IsSuffix$A@@0 T@U) ($ly@@128 T@U) (|a#0@@74| T@U) (|b#0@@36| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsSuffix$A@@0) TyType) (= (type $ly@@128) LayerTypeType)) (= (type |a#0@@74|) (SeqType BoxType))) (= (type |b#0@@36|) (SeqType BoxType))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 $ly@@128 |a#0@@74| |b#0@@36|) (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 $LZ |a#0@@74| |b#0@@36|)))
 :qid |unknown.0:0|
 :skolemid |5031|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 (AsFuelBottom $ly@@128) |a#0@@74| |b#0@@36|))
)))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@1 T@U) ($ly@@129 T@U) (|a#0@@75| T@U) (|b#0@@37| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@1) TyType) (= (type $ly@@129) LayerTypeType)) (= (type |a#0@@75|) (SeqType BoxType))) (= (type |b#0@@37|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@1 |a#0@@75| |b#0@@37|) (and ($Is |a#0@@75| (TSeq Sequences._default.IsSuffix$A@@1)) ($Is |b#0@@37| (TSeq Sequences._default.IsSuffix$A@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |5032|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@1 $ly@@129 |a#0@@75| |b#0@@37|))
))))
(assert (forall ((Sequences._default.IsSuffix$A@@2 T@U) ($ly@@130 T@U) (|a#0@@76| T@U) (|b#0@@38| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@2) TyType) (= (type $ly@@130) LayerTypeType)) (= (type |a#0@@76|) (SeqType BoxType))) (= (type |b#0@@38|) (SeqType BoxType))) (and ($Is |a#0@@76| (TSeq Sequences._default.IsSuffix$A@@2)) ($Is |b#0@@38| (TSeq Sequences._default.IsSuffix$A@@2)))) (= (|Sequences.__default.IsSuffix#requires| Sequences._default.IsSuffix$A@@2 $ly@@130 |a#0@@76| |b#0@@38|) true))
 :qid |unknown.0:0|
 :skolemid |5033|
 :pattern ( (|Sequences.__default.IsSuffix#requires| Sequences._default.IsSuffix$A@@2 $ly@@130 |a#0@@76| |b#0@@38|))
)))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@3 T@U) ($ly@@131 T@U) (|a#0@@77| T@U) (|b#0@@39| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@3) TyType) (= (type $ly@@131) LayerTypeType)) (= (type |a#0@@77|) (SeqType BoxType))) (= (type |b#0@@39|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@3 |a#0@@77| |b#0@@39|) (and ($Is |a#0@@77| (TSeq Sequences._default.IsSuffix$A@@3)) ($Is |b#0@@39| (TSeq Sequences._default.IsSuffix$A@@3))))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@3 ($LS $ly@@131) |a#0@@77| |b#0@@39|)  (and (INTERNAL_le_boogie (|Seq#Length| |a#0@@77|) (|Seq#Length| |b#0@@39|)) (|Seq#Equal| |a#0@@77| (|Seq#Drop| |b#0@@39| (INTERNAL_sub_boogie (|Seq#Length| |b#0@@39|) (|Seq#Length| |a#0@@77|)))))))
 :qid |unknown.0:0|
 :skolemid |5034|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@3 ($LS $ly@@131) |a#0@@77| |b#0@@39|))
))))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@4 T@U) ($ly@@132 T@U) (|a#0@@78| T@U) (|b#0@@40| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@4) TyType) (= (type $ly@@132) LayerTypeType)) (= (type |a#0@@78|) (SeqType BoxType))) (= (type |b#0@@40|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@4 (Lit |a#0@@78|) (Lit |b#0@@40|)) (and ($Is |a#0@@78| (TSeq Sequences._default.IsSuffix$A@@4)) ($Is |b#0@@40| (TSeq Sequences._default.IsSuffix$A@@4))))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@4 ($LS $ly@@132) (Lit |a#0@@78|) (Lit |b#0@@40|))  (and (INTERNAL_le_boogie (|Seq#Length| (Lit |a#0@@78|)) (|Seq#Length| (Lit |b#0@@40|))) (|Seq#Equal| |a#0@@78| (|Seq#Drop| (Lit |b#0@@40|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |b#0@@40|)) (|Seq#Length| (Lit |a#0@@78|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5035|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@4 ($LS $ly@@132) (Lit |a#0@@78|) (Lit |b#0@@40|)))
))))
(assert (forall ((arg0@@518 T@U) (arg1@@232 T@U) (arg2@@118 T@U) (arg3@@66 T@U) (arg4@@40 Int) ) (! (= (type (Sequences.__default.SeqIndexIterate arg0@@518 arg1@@232 arg2@@118 arg3@@66 arg4@@40)) DatatypeTypeType)
 :qid |funType:Sequences.__default.SeqIndexIterate|
 :pattern ( (Sequences.__default.SeqIndexIterate arg0@@518 arg1@@232 arg2@@118 arg3@@66 arg4@@40))
)))
(assert (forall ((Sequences._default.SeqIndexIterate$A T@U) ($ly@@133 T@U) (|run#0@@71| T@U) (|needle#0| T@U) (|i#0@@73| Int) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexIterate$A) TyType) (= (type $ly@@133) LayerTypeType)) (= (type |run#0@@71|) (SeqType BoxType))) (= (type |needle#0|) BoxType)) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A ($LS $ly@@133) |run#0@@71| |needle#0| |i#0@@73|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A $ly@@133 |run#0@@71| |needle#0| |i#0@@73|)))
 :qid |unknown.0:0|
 :skolemid |5036|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A ($LS $ly@@133) |run#0@@71| |needle#0| |i#0@@73|))
)))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@0 T@U) ($ly@@134 T@U) (|run#0@@72| T@U) (|needle#0@@0| T@U) (|i#0@@74| Int) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@0) TyType) (= (type $ly@@134) LayerTypeType)) (= (type |run#0@@72|) (SeqType BoxType))) (= (type |needle#0@@0|) BoxType)) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 $ly@@134 |run#0@@72| |needle#0@@0| |i#0@@74|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 $LZ |run#0@@72| |needle#0@@0| |i#0@@74|)))
 :qid |unknown.0:0|
 :skolemid |5037|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 (AsFuelBottom $ly@@134) |run#0@@72| |needle#0@@0| |i#0@@74|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@1 T@U) ($ly@@135 T@U) (|run#0@@73| T@U) (|needle#0@@1| T@U) (|i#0@@75| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@1) TyType) (= (type $ly@@135) LayerTypeType)) (= (type |run#0@@73|) (SeqType BoxType))) (= (type |needle#0@@1|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@1 |run#0@@73| |needle#0@@1| |i#0@@75|) (and (and ($Is |run#0@@73| (TSeq Sequences._default.SeqIndexIterate$A@@1)) ($IsBox |needle#0@@1| Sequences._default.SeqIndexIterate$A@@1)) (and (INTERNAL_le_boogie 0 |i#0@@75|) (INTERNAL_le_boogie |i#0@@75| (|Seq#Length| |run#0@@73|)))))) (and (and (=> (Options.Option.Some_q (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|)) (and (and (INTERNAL_le_boogie 0 (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|))))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|)))) (|Seq#Length| |run#0@@73|))) (= (|Seq#Index| |run#0@@73| (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|))))) |needle#0@@1|))) (=> (Options.Option.None_q (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|)) (forall ((|j#0@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie |i#0@@75| |j#0@@1|) (INTERNAL_lt_boogie |j#0@@1| (|Seq#Length| |run#0@@73|))) (not (= (|Seq#Index| |run#0@@73| |j#0@@1|) |needle#0@@1|)))
 :qid |Sequencesidfy.530:32|
 :skolemid |5038|
 :pattern ( (|Seq#Index| |run#0@@73| |j#0@@1|))
)))) ($Is (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|) (Tclass.Options.Option TInt))))
 :qid |unknown.0:0|
 :skolemid |5039|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@135 |run#0@@73| |needle#0@@1| |i#0@@75|))
))))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@2 T@U) ($ly@@136 T@U) (|run#0@@74| T@U) (|needle#0@@2| T@U) (|i#0@@76| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@2) TyType) (= (type $ly@@136) LayerTypeType)) (= (type |run#0@@74|) (SeqType BoxType))) (= (type |needle#0@@2|) BoxType)) (and ($Is |run#0@@74| (TSeq Sequences._default.SeqIndexIterate$A@@2)) ($IsBox |needle#0@@2| Sequences._default.SeqIndexIterate$A@@2))) (= (|Sequences.__default.SeqIndexIterate#requires| Sequences._default.SeqIndexIterate$A@@2 $ly@@136 |run#0@@74| |needle#0@@2| |i#0@@76|)  (and (INTERNAL_le_boogie 0 |i#0@@76|) (INTERNAL_le_boogie |i#0@@76| (|Seq#Length| |run#0@@74|)))))
 :qid |unknown.0:0|
 :skolemid |5040|
 :pattern ( (|Sequences.__default.SeqIndexIterate#requires| Sequences._default.SeqIndexIterate$A@@2 $ly@@136 |run#0@@74| |needle#0@@2| |i#0@@76|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@3 T@U) ($ly@@137 T@U) (|run#0@@75| T@U) (|needle#0@@3| T@U) (|i#0@@77| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@3) TyType) (= (type $ly@@137) LayerTypeType)) (= (type |run#0@@75|) (SeqType BoxType))) (= (type |needle#0@@3|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@3 |run#0@@75| |needle#0@@3| |i#0@@77|) (and (and ($Is |run#0@@75| (TSeq Sequences._default.SeqIndexIterate$A@@3)) ($IsBox |needle#0@@3| Sequences._default.SeqIndexIterate$A@@3)) (and (INTERNAL_le_boogie 0 |i#0@@77|) (INTERNAL_le_boogie |i#0@@77| (|Seq#Length| |run#0@@75|)))))) (and (=> (not (= |i#0@@77| (|Seq#Length| |run#0@@75|))) (=> (not (= (|Seq#Index| |run#0@@75| |i#0@@77|) |needle#0@@3|)) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@3 |run#0@@75| |needle#0@@3| (INTERNAL_add_boogie |i#0@@77| 1)))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 ($LS $ly@@137) |run#0@@75| |needle#0@@3| |i#0@@77|) (ite (= |i#0@@77| (|Seq#Length| |run#0@@75|)) |#Options.Option.None| (ite (= (|Seq#Index| |run#0@@75| |i#0@@77|) |needle#0@@3|) (|#Options.Option.Some| ($Box (int_2_U |i#0@@77|))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 $ly@@137 |run#0@@75| |needle#0@@3| (INTERNAL_add_boogie |i#0@@77| 1)))))))
 :qid |unknown.0:0|
 :skolemid |5041|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 ($LS $ly@@137) |run#0@@75| |needle#0@@3| |i#0@@77|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@4 T@U) ($ly@@138 T@U) (|run#0@@76| T@U) (|needle#0@@4| T@U) (|i#0@@78| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@4) TyType) (= (type $ly@@138) LayerTypeType)) (= (type |run#0@@76|) (SeqType BoxType))) (= (type |needle#0@@4|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@4 (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@78|)) (and (and ($Is |run#0@@76| (TSeq Sequences._default.SeqIndexIterate$A@@4)) ($IsBox |needle#0@@4| Sequences._default.SeqIndexIterate$A@@4)) (and (INTERNAL_le_boogie 0 |i#0@@78|) (INTERNAL_le_boogie |i#0@@78| (|Seq#Length| (Lit |run#0@@76|))))))) (and (=> (not (= (LitInt |i#0@@78|) (|Seq#Length| (Lit |run#0@@76|)))) (=> (not (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@78|)) |needle#0@@4|)) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@4 (Lit |run#0@@76|) |needle#0@@4| (LitInt (INTERNAL_add_boogie |i#0@@78| 1))))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@138) (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@78|)) (ite (= (LitInt |i#0@@78|) (|Seq#Length| (Lit |run#0@@76|))) |#Options.Option.None| (ite (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@78|)) |needle#0@@4|) (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@78|)))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@138) (Lit |run#0@@76|) |needle#0@@4| (LitInt (INTERNAL_add_boogie |i#0@@78| 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5042|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@138) (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@78|)))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@5 T@U) ($ly@@139 T@U) (|run#0@@77| T@U) (|needle#0@@5| T@U) (|i#0@@79| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@5) TyType) (= (type $ly@@139) LayerTypeType)) (= (type |run#0@@77|) (SeqType BoxType))) (= (type |needle#0@@5|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@5 (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@79|)) (and (and ($Is |run#0@@77| (TSeq Sequences._default.SeqIndexIterate$A@@5)) ($IsBox |needle#0@@5| Sequences._default.SeqIndexIterate$A@@5)) (and (INTERNAL_le_boogie 0 |i#0@@79|) (INTERNAL_le_boogie |i#0@@79| (|Seq#Length| (Lit |run#0@@77|))))))) (and (=> (not (= (LitInt |i#0@@79|) (|Seq#Length| (Lit |run#0@@77|)))) (=> (not (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@79|)) (Lit |needle#0@@5|))) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@5 (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt (INTERNAL_add_boogie |i#0@@79| 1))))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@139) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@79|)) (ite (= (LitInt |i#0@@79|) (|Seq#Length| (Lit |run#0@@77|))) |#Options.Option.None| (ite (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@79|)) (Lit |needle#0@@5|)) (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@79|)))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@139) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt (INTERNAL_add_boogie |i#0@@79| 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5043|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@139) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@79|)))
))))
(assert (forall ((arg0@@519 T@U) (arg1@@233 T@U) (arg2@@119 T@U) (arg3@@67 T@U) ) (! (= (type (Sequences.__default.SeqIndex arg0@@519 arg1@@233 arg2@@119 arg3@@67)) DatatypeTypeType)
 :qid |funType:Sequences.__default.SeqIndex|
 :pattern ( (Sequences.__default.SeqIndex arg0@@519 arg1@@233 arg2@@119 arg3@@67))
)))
(assert (forall ((Sequences._default.SeqIndex$A T@U) ($ly@@140 T@U) (|run#0@@78| T@U) (|needle#0@@6| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndex$A) TyType) (= (type $ly@@140) LayerTypeType)) (= (type |run#0@@78|) (SeqType BoxType))) (= (type |needle#0@@6|) BoxType)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A ($LS $ly@@140) |run#0@@78| |needle#0@@6|) (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A $ly@@140 |run#0@@78| |needle#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |5044|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A ($LS $ly@@140) |run#0@@78| |needle#0@@6|))
)))
(assert (forall ((Sequences._default.SeqIndex$A@@0 T@U) ($ly@@141 T@U) (|run#0@@79| T@U) (|needle#0@@7| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndex$A@@0) TyType) (= (type $ly@@141) LayerTypeType)) (= (type |run#0@@79|) (SeqType BoxType))) (= (type |needle#0@@7|) BoxType)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 $ly@@141 |run#0@@79| |needle#0@@7|) (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 $LZ |run#0@@79| |needle#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |5045|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 (AsFuelBottom $ly@@141) |run#0@@79| |needle#0@@7|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@1 T@U) ($ly@@142 T@U) (|run#0@@80| T@U) (|needle#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@1) TyType) (= (type $ly@@142) LayerTypeType)) (= (type |run#0@@80|) (SeqType BoxType))) (= (type |needle#0@@8|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@1 |run#0@@80| |needle#0@@8|) (and ($Is |run#0@@80| (TSeq Sequences._default.SeqIndex$A@@1)) ($IsBox |needle#0@@8| Sequences._default.SeqIndex$A@@1)))) (and (and (=> (Options.Option.Some_q (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|)) (and (and (INTERNAL_le_boogie 0 (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|))))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|)))) (|Seq#Length| |run#0@@80|))) (= (|Seq#Index| |run#0@@80| (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|))))) |needle#0@@8|))) (=> (Options.Option.None_q (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|)) (forall ((|i#0@@80| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@80|) (INTERNAL_lt_boogie |i#0@@80| (|Seq#Length| |run#0@@80|))) (not (= (|Seq#Index| |run#0@@80| |i#0@@80|) |needle#0@@8|)))
 :qid |Sequencesidfy.540:32|
 :skolemid |5046|
 :pattern ( (|Seq#Index| |run#0@@80| |i#0@@80|))
)))) ($Is (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|) (Tclass.Options.Option TInt))))
 :qid |unknown.0:0|
 :skolemid |5047|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@142 |run#0@@80| |needle#0@@8|))
))))
(assert (forall ((Sequences._default.SeqIndex$A@@2 T@U) ($ly@@143 T@U) (|run#0@@81| T@U) (|needle#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@2) TyType) (= (type $ly@@143) LayerTypeType)) (= (type |run#0@@81|) (SeqType BoxType))) (= (type |needle#0@@9|) BoxType)) (and ($Is |run#0@@81| (TSeq Sequences._default.SeqIndex$A@@2)) ($IsBox |needle#0@@9| Sequences._default.SeqIndex$A@@2))) (= (|Sequences.__default.SeqIndex#requires| Sequences._default.SeqIndex$A@@2 $ly@@143 |run#0@@81| |needle#0@@9|) true))
 :qid |unknown.0:0|
 :skolemid |5048|
 :pattern ( (|Sequences.__default.SeqIndex#requires| Sequences._default.SeqIndex$A@@2 $ly@@143 |run#0@@81| |needle#0@@9|))
)))
(assert (= (type StartFuel_Sequences._default.SeqIndexIterate) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@3 T@U) ($ly@@144 T@U) (|run#0@@82| T@U) (|needle#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@3) TyType) (= (type $ly@@144) LayerTypeType)) (= (type |run#0@@82|) (SeqType BoxType))) (= (type |needle#0@@10|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@3 |run#0@@82| |needle#0@@10|) (and ($Is |run#0@@82| (TSeq Sequences._default.SeqIndex$A@@3)) ($IsBox |needle#0@@10| Sequences._default.SeqIndex$A@@3)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@3 |run#0@@82| |needle#0@@10| (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@3 ($LS $ly@@144) |run#0@@82| |needle#0@@10|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@3 StartFuel_Sequences._default.SeqIndexIterate |run#0@@82| |needle#0@@10| (LitInt 0)))))
 :qid |unknown.0:0|
 :skolemid |5049|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@3 ($LS $ly@@144) |run#0@@82| |needle#0@@10|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@4 T@U) ($ly@@145 T@U) (|run#0@@83| T@U) (|needle#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@4) TyType) (= (type $ly@@145) LayerTypeType)) (= (type |run#0@@83|) (SeqType BoxType))) (= (type |needle#0@@11|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@4 (Lit |run#0@@83|) |needle#0@@11|) (and ($Is |run#0@@83| (TSeq Sequences._default.SeqIndex$A@@4)) ($IsBox |needle#0@@11| Sequences._default.SeqIndex$A@@4)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@4 (Lit |run#0@@83|) |needle#0@@11| (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@4 ($LS $ly@@145) (Lit |run#0@@83|) |needle#0@@11|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@4 StartFuel_Sequences._default.SeqIndexIterate (Lit |run#0@@83|) |needle#0@@11| (LitInt 0)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5050|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@4 ($LS $ly@@145) (Lit |run#0@@83|) |needle#0@@11|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@5 T@U) ($ly@@146 T@U) (|run#0@@84| T@U) (|needle#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@5) TyType) (= (type $ly@@146) LayerTypeType)) (= (type |run#0@@84|) (SeqType BoxType))) (= (type |needle#0@@12|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@5 (Lit |run#0@@84|) (Lit |needle#0@@12|)) (and ($Is |run#0@@84| (TSeq Sequences._default.SeqIndex$A@@5)) ($IsBox |needle#0@@12| Sequences._default.SeqIndex$A@@5)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@5 (Lit |run#0@@84|) (Lit |needle#0@@12|) (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@5 ($LS $ly@@146) (Lit |run#0@@84|) (Lit |needle#0@@12|)) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@5 StartFuel_Sequences._default.SeqIndexIterate (Lit |run#0@@84|) (Lit |needle#0@@12|) (LitInt 0)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5051|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@5 ($LS $ly@@146) (Lit |run#0@@84|) (Lit |needle#0@@12|)))
))))
(assert (forall ((arg0@@520 T@U) (arg1@@234 T@U) (arg2@@120 Int) (arg3@@68 T@U) ) (! (= (type (Sequences.__default.SeqOfLength arg0@@520 arg1@@234 arg2@@120 arg3@@68)) (SeqType BoxType))
 :qid |funType:Sequences.__default.SeqOfLength|
 :pattern ( (Sequences.__default.SeqOfLength arg0@@520 arg1@@234 arg2@@120 arg3@@68))
)))
(assert (forall ((Sequences._default.SeqOfLength$V T@U) ($ly@@147 T@U) (|length#0@@5| Int) (|v#0@@24| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqOfLength$V) TyType) (= (type $ly@@147) LayerTypeType)) (= (type |v#0@@24|) BoxType)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V ($LS $ly@@147) |length#0@@5| |v#0@@24|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V $ly@@147 |length#0@@5| |v#0@@24|)))
 :qid |unknown.0:0|
 :skolemid |5052|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V ($LS $ly@@147) |length#0@@5| |v#0@@24|))
)))
(assert (forall ((Sequences._default.SeqOfLength$V@@0 T@U) ($ly@@148 T@U) (|length#0@@6| Int) (|v#0@@25| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqOfLength$V@@0) TyType) (= (type $ly@@148) LayerTypeType)) (= (type |v#0@@25|) BoxType)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 $ly@@148 |length#0@@6| |v#0@@25|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 $LZ |length#0@@6| |v#0@@25|)))
 :qid |unknown.0:0|
 :skolemid |5053|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 (AsFuelBottom $ly@@148) |length#0@@6| |v#0@@25|))
)))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@1 T@U) ($ly@@149 T@U) (|length#0@@7| Int) (|v#0@@26| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@1) TyType) (= (type $ly@@149) LayerTypeType)) (= (type |v#0@@26|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@1 |length#0@@7| |v#0@@26|) (and (INTERNAL_le_boogie 0 |length#0@@7|) ($IsBox |v#0@@26| Sequences._default.SeqOfLength$V@@1)))) (and (and (= (|Seq#Length| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|)) |length#0@@7|) (forall ((|i#0@@81| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@81|) (INTERNAL_lt_boogie |i#0@@81| (|Seq#Length| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|)))) (= (|Seq#Index| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|) |i#0@@81|) |v#0@@26|))
 :qid |Sequencesidfy.547:18|
 :skolemid |5054|
 :pattern ( (|Seq#Index| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|) |i#0@@81|))
))) ($Is (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|) (TSeq Sequences._default.SeqOfLength$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5055|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@149 |length#0@@7| |v#0@@26|))
))))
(assert (forall ((Sequences._default.SeqOfLength$V@@2 T@U) ($ly@@150 T@U) (|length#0@@8| Int) (|v#0@@27| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@2) TyType) (= (type $ly@@150) LayerTypeType)) (= (type |v#0@@27|) BoxType)) (and (INTERNAL_le_boogie 0 |length#0@@8|) ($IsBox |v#0@@27| Sequences._default.SeqOfLength$V@@2))) (= (|Sequences.__default.SeqOfLength#requires| Sequences._default.SeqOfLength$V@@2 $ly@@150 |length#0@@8| |v#0@@27|) true))
 :qid |unknown.0:0|
 :skolemid |5056|
 :pattern ( (|Sequences.__default.SeqOfLength#requires| Sequences._default.SeqOfLength$V@@2 $ly@@150 |length#0@@8| |v#0@@27|))
)))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@3 T@U) ($ly@@151 T@U) (|length#0@@9| Int) (|v#0@@28| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@3) TyType) (= (type $ly@@151) LayerTypeType)) (= (type |v#0@@28|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@3 |length#0@@9| |v#0@@28|) (and (INTERNAL_le_boogie 0 |length#0@@9|) ($IsBox |v#0@@28| Sequences._default.SeqOfLength$V@@3)))) (and (=> (not (= |length#0@@9| (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@3 (INTERNAL_sub_boogie |length#0@@9| 1) |v#0@@28|)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 ($LS $ly@@151) |length#0@@9| |v#0@@28|) (ite (= |length#0@@9| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) |v#0@@28|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 $ly@@151 (INTERNAL_sub_boogie |length#0@@9| 1) |v#0@@28|))))))
 :qid |unknown.0:0|
 :skolemid |5057|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 ($LS $ly@@151) |length#0@@9| |v#0@@28|))
))))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@4 T@U) ($ly@@152 T@U) (|length#0@@10| Int) (|v#0@@29| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@4) TyType) (= (type $ly@@152) LayerTypeType)) (= (type |v#0@@29|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@4 (LitInt |length#0@@10|) |v#0@@29|) (and (INTERNAL_le_boogie 0 |length#0@@10|) ($IsBox |v#0@@29| Sequences._default.SeqOfLength$V@@4)))) (and (=> (not (= (LitInt |length#0@@10|) (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@4 (LitInt (INTERNAL_sub_boogie |length#0@@10| 1)) |v#0@@29|)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@152) (LitInt |length#0@@10|) |v#0@@29|) (ite (= (LitInt |length#0@@10|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) |v#0@@29|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@152) (LitInt (INTERNAL_sub_boogie |length#0@@10| 1)) |v#0@@29|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5058|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@152) (LitInt |length#0@@10|) |v#0@@29|))
))))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@5 T@U) ($ly@@153 T@U) (|length#0@@11| Int) (|v#0@@30| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@5) TyType) (= (type $ly@@153) LayerTypeType)) (= (type |v#0@@30|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@5 (LitInt |length#0@@11|) (Lit |v#0@@30|)) (and (INTERNAL_le_boogie 0 |length#0@@11|) ($IsBox |v#0@@30| Sequences._default.SeqOfLength$V@@5)))) (and (=> (not (= (LitInt |length#0@@11|) (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@5 (LitInt (INTERNAL_sub_boogie |length#0@@11| 1)) (Lit |v#0@@30|))) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@153) (LitInt |length#0@@11|) (Lit |v#0@@30|)) (ite (= (LitInt |length#0@@11|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |v#0@@30|)) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@153) (LitInt (INTERNAL_sub_boogie |length#0@@11| 1)) (Lit |v#0@@30|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5059|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@153) (LitInt |length#0@@11|) (Lit |v#0@@30|)))
))))
(assert (forall ((arg0@@521 T@U) (arg1@@235 T@U) (arg2@@121 T@U) (arg3@@69 Int) (arg4@@41 T@U) ) (! (= (type (Sequences.__default.SeqIndexUpdate arg0@@521 arg1@@235 arg2@@121 arg3@@69 arg4@@41)) (SeqType BoxType))
 :qid |funType:Sequences.__default.SeqIndexUpdate|
 :pattern ( (Sequences.__default.SeqIndexUpdate arg0@@521 arg1@@235 arg2@@121 arg3@@69 arg4@@41))
)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T T@U) ($ly@@154 T@U) (|s#0@@90| T@U) (|i#0@@82| Int) (|t#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexUpdate$T) TyType) (= (type $ly@@154) LayerTypeType)) (= (type |s#0@@90|) (SeqType BoxType))) (= (type |t#0|) BoxType)) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T ($LS $ly@@154) |s#0@@90| |i#0@@82| |t#0|) (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T $ly@@154 |s#0@@90| |i#0@@82| |t#0|)))
 :qid |unknown.0:0|
 :skolemid |5060|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T ($LS $ly@@154) |s#0@@90| |i#0@@82| |t#0|))
)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@0 T@U) ($ly@@155 T@U) (|s#0@@91| T@U) (|i#0@@83| Int) (|t#0@@0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@0) TyType) (= (type $ly@@155) LayerTypeType)) (= (type |s#0@@91|) (SeqType BoxType))) (= (type |t#0@@0|) BoxType)) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 $ly@@155 |s#0@@91| |i#0@@83| |t#0@@0|) (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 $LZ |s#0@@91| |i#0@@83| |t#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5061|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 (AsFuelBottom $ly@@155) |s#0@@91| |i#0@@83| |t#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@1 T@U) ($ly@@156 T@U) (|s#0@@92| T@U) (|i#0@@84| Int) (|t#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@1) TyType) (= (type $ly@@156) LayerTypeType)) (= (type |s#0@@92|) (SeqType BoxType))) (= (type |t#0@@1|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@1 |s#0@@92| |i#0@@84| |t#0@@1|) (and (and (and ($Is |s#0@@92| (TSeq Sequences._default.SeqIndexUpdate$T@@1)) (and (INTERNAL_le_boogie 0 |i#0@@84|) (INTERNAL_lt_boogie |i#0@@84| 18446744073709551616))) ($IsBox |t#0@@1| Sequences._default.SeqIndexUpdate$T@@1)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@84| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@84|) (INTERNAL_lt_boogie |i#0@@84| (|Seq#Length| |s#0@@92|))))))) (and (|Seq#Equal| (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@156 |s#0@@92| |i#0@@84| |t#0@@1|) (|Seq#Update| |s#0@@92| |i#0@@84| |t#0@@1|)) ($Is (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@156 |s#0@@92| |i#0@@84| |t#0@@1|) (TSeq Sequences._default.SeqIndexUpdate$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5062|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@156 |s#0@@92| |i#0@@84| |t#0@@1|))
))))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@2 T@U) ($ly@@157 T@U) (|s#0@@93| T@U) (|i#0@@85| Int) (|t#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@2) TyType) (= (type $ly@@157) LayerTypeType)) (= (type |s#0@@93|) (SeqType BoxType))) (= (type |t#0@@2|) BoxType)) (and (and ($Is |s#0@@93| (TSeq Sequences._default.SeqIndexUpdate$T@@2)) (and (INTERNAL_le_boogie 0 |i#0@@85|) (INTERNAL_lt_boogie |i#0@@85| 18446744073709551616))) ($IsBox |t#0@@2| Sequences._default.SeqIndexUpdate$T@@2))) (= (|Sequences.__default.SeqIndexUpdate#requires| Sequences._default.SeqIndexUpdate$T@@2 $ly@@157 |s#0@@93| |i#0@@85| |t#0@@2|)  (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@85| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@85|) (INTERNAL_lt_boogie |i#0@@85| (|Seq#Length| |s#0@@93|))))))
 :qid |unknown.0:0|
 :skolemid |5063|
 :pattern ( (|Sequences.__default.SeqIndexUpdate#requires| Sequences._default.SeqIndexUpdate$T@@2 $ly@@157 |s#0@@93| |i#0@@85| |t#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@3 T@U) ($ly@@158 T@U) (|s#0@@94| T@U) (|i#0@@86| Int) (|t#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@3) TyType) (= (type $ly@@158) LayerTypeType)) (= (type |s#0@@94|) (SeqType BoxType))) (= (type |t#0@@3|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@3 |s#0@@94| |i#0@@86| |t#0@@3|) (and (and (and ($Is |s#0@@94| (TSeq Sequences._default.SeqIndexUpdate$T@@3)) (and (INTERNAL_le_boogie 0 |i#0@@86|) (INTERNAL_lt_boogie |i#0@@86| 18446744073709551616))) ($IsBox |t#0@@3| Sequences._default.SeqIndexUpdate$T@@3)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@86| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@86|) (INTERNAL_lt_boogie |i#0@@86| (|Seq#Length| |s#0@@94|))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@3 ($LS $ly@@158) |s#0@@94| |i#0@@86| |t#0@@3|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@94| |i#0@@86|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@3|)) (|Seq#Drop| |s#0@@94| (INTERNAL_add_boogie |i#0@@86| 1)))))
 :qid |unknown.0:0|
 :skolemid |5064|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@3 ($LS $ly@@158) |s#0@@94| |i#0@@86| |t#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@4 T@U) ($ly@@159 T@U) (|s#0@@95| T@U) (|i#0@@87| Int) (|t#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@4) TyType) (= (type $ly@@159) LayerTypeType)) (= (type |s#0@@95|) (SeqType BoxType))) (= (type |t#0@@4|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@4 (Lit |s#0@@95|) (LitInt |i#0@@87|) |t#0@@4|) (and (and (and ($Is |s#0@@95| (TSeq Sequences._default.SeqIndexUpdate$T@@4)) (and (INTERNAL_le_boogie 0 |i#0@@87|) (INTERNAL_lt_boogie |i#0@@87| 18446744073709551616))) ($IsBox |t#0@@4| Sequences._default.SeqIndexUpdate$T@@4)) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@87| 1) 18446744073709551616)))) (and (INTERNAL_le_boogie 0 |i#0@@87|) (INTERNAL_lt_boogie |i#0@@87| (|Seq#Length| (Lit |s#0@@95|)))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@4 ($LS $ly@@159) (Lit |s#0@@95|) (LitInt |i#0@@87|) |t#0@@4|) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@95|) (LitInt |i#0@@87|)) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@4|)) (|Seq#Drop| (Lit |s#0@@95|) (LitInt (INTERNAL_add_boogie |i#0@@87| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5065|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@4 ($LS $ly@@159) (Lit |s#0@@95|) (LitInt |i#0@@87|) |t#0@@4|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@5 T@U) ($ly@@160 T@U) (|s#0@@96| T@U) (|i#0@@88| Int) (|t#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@5) TyType) (= (type $ly@@160) LayerTypeType)) (= (type |s#0@@96|) (SeqType BoxType))) (= (type |t#0@@5|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@5 (Lit |s#0@@96|) (LitInt |i#0@@88|) (Lit |t#0@@5|)) (and (and (and ($Is |s#0@@96| (TSeq Sequences._default.SeqIndexUpdate$T@@5)) (and (INTERNAL_le_boogie 0 |i#0@@88|) (INTERNAL_lt_boogie |i#0@@88| 18446744073709551616))) ($IsBox |t#0@@5| Sequences._default.SeqIndexUpdate$T@@5)) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@88| 1) 18446744073709551616)))) (and (INTERNAL_le_boogie 0 |i#0@@88|) (INTERNAL_lt_boogie |i#0@@88| (|Seq#Length| (Lit |s#0@@96|)))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@5 ($LS $ly@@160) (Lit |s#0@@96|) (LitInt |i#0@@88|) (Lit |t#0@@5|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@96|) (LitInt |i#0@@88|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |t#0@@5|))) (|Seq#Drop| (Lit |s#0@@96|) (LitInt (INTERNAL_add_boogie |i#0@@88| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5066|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@5 ($LS $ly@@160) (Lit |s#0@@96|) (LitInt |i#0@@88|) (Lit |t#0@@5|)))
))))
(assert (forall ((arg0@@522 T@U) (arg1@@236 T@U) (arg2@@122 T@U) (arg3@@70 T@U) (arg4@@42 T@U) ) (! (= (type (Sequences.__default.Zip arg0@@522 arg1@@236 arg2@@122 arg3@@70 arg4@@42)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Zip|
 :pattern ( (Sequences.__default.Zip arg0@@522 arg1@@236 arg2@@122 arg3@@70 arg4@@42))
)))
(assert (forall ((Sequences._default.Zip$A T@U) (Sequences._default.Zip$B T@U) ($ly@@161 T@U) (|a#0@@79| T@U) (|b#0@@41| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Zip$A) TyType) (= (type Sequences._default.Zip$B) TyType)) (= (type $ly@@161) LayerTypeType)) (= (type |a#0@@79|) (SeqType BoxType))) (= (type |b#0@@41|) (SeqType BoxType))) (= (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B ($LS $ly@@161) |a#0@@79| |b#0@@41|) (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B $ly@@161 |a#0@@79| |b#0@@41|)))
 :qid |unknown.0:0|
 :skolemid |5067|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B ($LS $ly@@161) |a#0@@79| |b#0@@41|))
)))
(assert (forall ((Sequences._default.Zip$A@@0 T@U) (Sequences._default.Zip$B@@0 T@U) ($ly@@162 T@U) (|a#0@@80| T@U) (|b#0@@42| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Zip$A@@0) TyType) (= (type Sequences._default.Zip$B@@0) TyType)) (= (type $ly@@162) LayerTypeType)) (= (type |a#0@@80|) (SeqType BoxType))) (= (type |b#0@@42|) (SeqType BoxType))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 $ly@@162 |a#0@@80| |b#0@@42|) (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 $LZ |a#0@@80| |b#0@@42|)))
 :qid |unknown.0:0|
 :skolemid |5068|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 (AsFuelBottom $ly@@162) |a#0@@80| |b#0@@42|))
)))
(assert  (=> true (forall ((Sequences._default.Zip$A@@1 T@U) (Sequences._default.Zip$B@@1 T@U) ($ly@@163 T@U) (|a#0@@81| T@U) (|b#0@@43| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@1) TyType) (= (type Sequences._default.Zip$B@@1) TyType)) (= (type $ly@@163) LayerTypeType)) (= (type |a#0@@81|) (SeqType BoxType))) (= (type |b#0@@43|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 |a#0@@81| |b#0@@43|) (and (and ($Is |a#0@@81| (TSeq Sequences._default.Zip$A@@1)) ($Is |b#0@@43| (TSeq Sequences._default.Zip$B@@1))) (= (|Seq#Length| |a#0@@81|) (|Seq#Length| |b#0@@43|))))) (and (and (= (|Seq#Length| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|)) (|Seq#Length| |a#0@@81|)) (forall ((|i#0@@89| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@89|) (INTERNAL_lt_boogie |i#0@@89| (|Seq#Length| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|)))) (|_System.Tuple2#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|) |i#0@@89|)) (|#_System._tuple#2._#Make2| (|Seq#Index| |a#0@@81| |i#0@@89|) (|Seq#Index| |b#0@@43| |i#0@@89|)))))
 :qid |Sequencesidfy.568:20|
 :skolemid |5069|
 :pattern ( (|Seq#Index| |b#0@@43| |i#0@@89|))
 :pattern ( (|Seq#Index| |a#0@@81| |i#0@@89|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|) |i#0@@89|)))
))) ($Is (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|) (TSeq (Tclass._System.Tuple2 Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1)))))
 :qid |unknown.0:0|
 :skolemid |5070|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@163 |a#0@@81| |b#0@@43|))
))))
(assert (forall ((Sequences._default.Zip$A@@2 T@U) (Sequences._default.Zip$B@@2 T@U) ($ly@@164 T@U) (|a#0@@82| T@U) (|b#0@@44| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@2) TyType) (= (type Sequences._default.Zip$B@@2) TyType)) (= (type $ly@@164) LayerTypeType)) (= (type |a#0@@82|) (SeqType BoxType))) (= (type |b#0@@44|) (SeqType BoxType))) (and ($Is |a#0@@82| (TSeq Sequences._default.Zip$A@@2)) ($Is |b#0@@44| (TSeq Sequences._default.Zip$B@@2)))) (= (|Sequences.__default.Zip#requires| Sequences._default.Zip$A@@2 Sequences._default.Zip$B@@2 $ly@@164 |a#0@@82| |b#0@@44|) (= (|Seq#Length| |a#0@@82|) (|Seq#Length| |b#0@@44|))))
 :qid |unknown.0:0|
 :skolemid |5071|
 :pattern ( (|Sequences.__default.Zip#requires| Sequences._default.Zip$A@@2 Sequences._default.Zip$B@@2 $ly@@164 |a#0@@82| |b#0@@44|))
)))
(assert  (=> true (forall ((Sequences._default.Zip$A@@3 T@U) (Sequences._default.Zip$B@@3 T@U) ($ly@@165 T@U) (|a#0@@83| T@U) (|b#0@@45| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@3) TyType) (= (type Sequences._default.Zip$B@@3) TyType)) (= (type $ly@@165) LayerTypeType)) (= (type |a#0@@83|) (SeqType BoxType))) (= (type |b#0@@45|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 |a#0@@83| |b#0@@45|) (and (and ($Is |a#0@@83| (TSeq Sequences._default.Zip$A@@3)) ($Is |b#0@@45| (TSeq Sequences._default.Zip$B@@3))) (= (|Seq#Length| |a#0@@83|) (|Seq#Length| |b#0@@45|))))) (and (=> (not (= (|Seq#Length| |a#0@@83|) (LitInt 0))) (and (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$A@@3 |a#0@@83|) (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$B@@3 |b#0@@45|)) (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 (Sequences.__default.DropLast Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.DropLast Sequences._default.Zip$B@@3 |b#0@@45|))) (and (|Sequences.__default.Last#canCall| Sequences._default.Zip$A@@3 |a#0@@83|) (|Sequences.__default.Last#canCall| Sequences._default.Zip$B@@3 |b#0@@45|)))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 ($LS $ly@@165) |a#0@@83| |b#0@@45|) (ite (= (|Seq#Length| |a#0@@83|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 $ly@@165 (Sequences.__default.DropLast Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.DropLast Sequences._default.Zip$B@@3 |b#0@@45|)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (|#_System._tuple#2._#Make2| (Sequences.__default.Last Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.Last Sequences._default.Zip$B@@3 |b#0@@45|)))))))))
 :qid |unknown.0:0|
 :skolemid |5072|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 ($LS $ly@@165) |a#0@@83| |b#0@@45|))
))))
(assert  (=> true (forall ((Sequences._default.Zip$A@@4 T@U) (Sequences._default.Zip$B@@4 T@U) ($ly@@166 T@U) (|a#0@@84| T@U) (|b#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@4) TyType) (= (type Sequences._default.Zip$B@@4) TyType)) (= (type $ly@@166) LayerTypeType)) (= (type |a#0@@84|) (SeqType BoxType))) (= (type |b#0@@46|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 (Lit |a#0@@84|) (Lit |b#0@@46|)) (and (and ($Is |a#0@@84| (TSeq Sequences._default.Zip$A@@4)) ($Is |b#0@@46| (TSeq Sequences._default.Zip$B@@4))) (= (|Seq#Length| (Lit |a#0@@84|)) (|Seq#Length| (Lit |b#0@@46|)))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0))) (and (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$A@@4 (Lit |a#0@@84|)) (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$B@@4 (Lit |b#0@@46|))) (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 (Lit (Sequences.__default.DropLast Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.DropLast Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))) (and (|Sequences.__default.Last#canCall| Sequences._default.Zip$A@@4 (Lit |a#0@@84|)) (|Sequences.__default.Last#canCall| Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@166) (Lit |a#0@@84|) (Lit |b#0@@46|)) (ite (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@166) (Lit (Sequences.__default.DropLast Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.DropLast Sequences._default.Zip$B@@4 (Lit |b#0@@46|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#_System._tuple#2._#Make2| (Lit (Sequences.__default.Last Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.Last Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5073|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@166) (Lit |a#0@@84|) (Lit |b#0@@46|)))
))))
(assert (forall ((arg0@@523 T@U) (arg1@@237 T@U) (arg2@@123 T@U) (arg3@@71 T@U) ) (! (= (type (Sequences.__default.Unzip arg0@@523 arg1@@237 arg2@@123 arg3@@71)) DatatypeTypeType)
 :qid |funType:Sequences.__default.Unzip|
 :pattern ( (Sequences.__default.Unzip arg0@@523 arg1@@237 arg2@@123 arg3@@71))
)))
(assert (forall ((Sequences._default.Unzip$A T@U) (Sequences._default.Unzip$B T@U) ($ly@@167 T@U) (|z#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Unzip$A) TyType) (= (type Sequences._default.Unzip$B) TyType)) (= (type $ly@@167) LayerTypeType)) (= (type |z#0|) (SeqType BoxType))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B ($LS $ly@@167) |z#0|) (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B $ly@@167 |z#0|)))
 :qid |unknown.0:0|
 :skolemid |5074|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B ($LS $ly@@167) |z#0|))
)))
(assert (forall ((Sequences._default.Unzip$A@@0 T@U) (Sequences._default.Unzip$B@@0 T@U) ($ly@@168 T@U) (|z#0@@0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Unzip$A@@0) TyType) (= (type Sequences._default.Unzip$B@@0) TyType)) (= (type $ly@@168) LayerTypeType)) (= (type |z#0@@0|) (SeqType BoxType))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 $ly@@168 |z#0@@0|) (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 $LZ |z#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5075|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 (AsFuelBottom $ly@@168) |z#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@1 T@U) (Sequences._default.Unzip$B@@1 T@U) ($ly@@169 T@U) (|z#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@1) TyType) (= (type Sequences._default.Unzip$B@@1) TyType)) (= (type $ly@@169) LayerTypeType)) (= (type |z#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 |z#0@@1|) ($Is |z#0@@1| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1))))) (and (and (and (= (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|)))) (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))))) (= (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|)))) (|Seq#Length| |z#0@@1|))) (forall ((|i#0@@90| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@90|) (INTERNAL_lt_boogie |i#0@@90| (|Seq#Length| |z#0@@1|))) (|_System.Tuple2#Equal| (|#_System._tuple#2._#Make2| (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))) |i#0@@90|) (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))) |i#0@@90|)) ($Unbox DatatypeTypeType (|Seq#Index| |z#0@@1| |i#0@@90|)))))
 :qid |Sequencesidfy.576:20|
 :skolemid |5076|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |z#0@@1| |i#0@@90|)))
 :pattern ( (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))) |i#0@@90|))
 :pattern ( (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))) |i#0@@90|))
))) ($Is (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|) (Tclass._System.Tuple2 (TSeq Sequences._default.Unzip$A@@1) (TSeq Sequences._default.Unzip$B@@1)))))
 :qid |unknown.0:0|
 :skolemid |5077|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@169 |z#0@@1|))
))))
(assert (forall ((Sequences._default.Unzip$A@@2 T@U) (Sequences._default.Unzip$B@@2 T@U) ($ly@@170 T@U) (|z#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@2) TyType) (= (type Sequences._default.Unzip$B@@2) TyType)) (= (type $ly@@170) LayerTypeType)) (= (type |z#0@@2|) (SeqType BoxType))) ($Is |z#0@@2| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2)))) (= (|Sequences.__default.Unzip#requires| Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2 $ly@@170 |z#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |5078|
 :pattern ( (|Sequences.__default.Unzip#requires| Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2 $ly@@170 |z#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@3 T@U) (Sequences._default.Unzip$B@@3 T@U) ($ly@@171 T@U) (|z#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@3) TyType) (= (type Sequences._default.Unzip$B@@3) TyType)) (= (type $ly@@171) LayerTypeType)) (= (type |z#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 |z#0@@3|) ($Is |z#0@@3| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3))))) (and (=> (not (= (|Seq#Length| |z#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))) (and (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))) (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 ($LS $ly@@171) |z#0@@3|) (ite (= (|Seq#Length| |z#0@@3|) (LitInt 0)) (|#_System._tuple#2._#Make2| ($Box (Lit (|Seq#Empty| BoxType))) ($Box (Lit (|Seq#Empty| BoxType)))) (let ((|b#0@@47| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 $ly@@171 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))
(let ((|a#0@@85| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 $ly@@171 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))
(|#_System._tuple#2._#Make2| ($Box (|Seq#Append| |a#0@@85| (|Seq#Build| (|Seq#Empty| BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))))) ($Box (|Seq#Append| |b#0@@47| (|Seq#Build| (|Seq#Empty| BoxType) (_System.Tuple2._1 ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))))))))))))
 :qid |unknown.0:0|
 :skolemid |5079|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 ($LS $ly@@171) |z#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@4 T@U) (Sequences._default.Unzip$B@@4 T@U) ($ly@@172 T@U) (|z#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@4) TyType) (= (type Sequences._default.Unzip$B@@4) TyType)) (= (type $ly@@172) LayerTypeType)) (= (type |z#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 (Lit |z#0@@4|)) ($Is |z#0@@4| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4))))) (and (=> (not (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))) (and (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (_System.Tuple2.___hMake2_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)))))) (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (_System.Tuple2.___hMake2_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@172) (Lit |z#0@@4|)) (ite (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0)) (|#_System._tuple#2._#Make2| ($Box (Lit (|Seq#Empty| BoxType))) ($Box (Lit (|Seq#Empty| BoxType)))) (let ((|b#1| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@172) (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))
(let ((|a#1| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@172) (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))
(|#_System._tuple#2._#Make2| ($Box (|Seq#Append| |a#1| (|Seq#Build| (|Seq#Empty| BoxType) (Lit (_System.Tuple2._0 (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))) ($Box (|Seq#Append| |b#1| (|Seq#Build| (|Seq#Empty| BoxType) (Lit (_System.Tuple2._1 (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5080|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@172) (Lit |z#0@@4|)))
))))
(assert (forall ((arg0@@524 T@U) (arg1@@238 T@U) (arg2@@124 T@U) ) (! (= (type (Sequences.__default.FlattenShape arg0@@524 arg1@@238 arg2@@124)) (SeqType BoxType))
 :qid |funType:Sequences.__default.FlattenShape|
 :pattern ( (Sequences.__default.FlattenShape arg0@@524 arg1@@238 arg2@@124))
)))
(assert (forall ((Sequences._default.FlattenShape$A T@U) ($ly@@173 T@U) (|seqs#0| T@U) ) (!  (=> (and (and (= (type Sequences._default.FlattenShape$A) TyType) (= (type $ly@@173) LayerTypeType)) (= (type |seqs#0|) (SeqType BoxType))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A ($LS $ly@@173) |seqs#0|) (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A $ly@@173 |seqs#0|)))
 :qid |unknown.0:0|
 :skolemid |5081|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A ($LS $ly@@173) |seqs#0|))
)))
(assert (forall ((Sequences._default.FlattenShape$A@@0 T@U) ($ly@@174 T@U) (|seqs#0@@0| T@U) ) (!  (=> (and (and (= (type Sequences._default.FlattenShape$A@@0) TyType) (= (type $ly@@174) LayerTypeType)) (= (type |seqs#0@@0|) (SeqType BoxType))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 $ly@@174 |seqs#0@@0|) (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 $LZ |seqs#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5082|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 (AsFuelBottom $ly@@174) |seqs#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@1 T@U) ($ly@@175 T@U) (|seqs#0@@1| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@1) TyType) (= (type $ly@@175) LayerTypeType)) (= (type |seqs#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@1 |seqs#0@@1|) ($Is |seqs#0@@1| (TSeq (TSeq Sequences._default.FlattenShape$A@@1))))) (and (and (= (|Seq#Length| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|)) (|Seq#Length| |seqs#0@@1|)) (forall ((|i#0@@91| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@91|) (INTERNAL_lt_boogie |i#0@@91| (|Seq#Length| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|)))) (= (U_2_int ($Unbox intType (|Seq#Index| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|) |i#0@@91|))) (|Seq#Length| ($Unbox (SeqType BoxType) (|Seq#Index| |seqs#0@@1| |i#0@@91|))))))
 :qid |Sequencesidfy.598:20|
 :skolemid |5083|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |seqs#0@@1| |i#0@@91|)))
 :pattern ( ($Unbox intType (|Seq#Index| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|) |i#0@@91|)))
))) ($Is (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|) (TSeq Tclass._System.nat))))
 :qid |unknown.0:0|
 :skolemid |5084|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@175 |seqs#0@@1|))
))))
(assert (forall ((Sequences._default.FlattenShape$A@@2 T@U) ($ly@@176 T@U) (|seqs#0@@2| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@2) TyType) (= (type $ly@@176) LayerTypeType)) (= (type |seqs#0@@2|) (SeqType BoxType))) ($Is |seqs#0@@2| (TSeq (TSeq Sequences._default.FlattenShape$A@@2)))) (= (|Sequences.__default.FlattenShape#requires| Sequences._default.FlattenShape$A@@2 $ly@@176 |seqs#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |5085|
 :pattern ( (|Sequences.__default.FlattenShape#requires| Sequences._default.FlattenShape$A@@2 $ly@@176 |seqs#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@3 T@U) ($ly@@177 T@U) (|seqs#0@@3| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@3) TyType) (= (type $ly@@177) LayerTypeType)) (= (type |seqs#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@3 |seqs#0@@3|) ($Is |seqs#0@@3| (TSeq (TSeq Sequences._default.FlattenShape$A@@3))))) (and (=> (not (= (|Seq#Length| |seqs#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|) (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 ($LS $ly@@177) |seqs#0@@3|) (ite (= (|Seq#Length| |seqs#0@@3|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 $ly@@177 (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (|Seq#Length| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|)))))))))))
 :qid |unknown.0:0|
 :skolemid |5086|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 ($LS $ly@@177) |seqs#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@4 T@U) ($ly@@178 T@U) (|seqs#0@@4| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@4) TyType) (= (type $ly@@178) LayerTypeType)) (= (type |seqs#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@4 (Lit |seqs#0@@4|)) ($Is |seqs#0@@4| (TSeq (TSeq Sequences._default.FlattenShape$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)) (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@178) (Lit |seqs#0@@4|)) (ite (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@178) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (|Seq#Length| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5087|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@178) (Lit |seqs#0@@4|)))
))))
(assert (forall (($ly@@179 T@U) (|shape#0| T@U) ) (!  (=> (and (= (type $ly@@179) LayerTypeType) (= (type |shape#0|) (SeqType BoxType))) (= (Sequences.__default.FlattenLength ($LS $ly@@179) |shape#0|) (Sequences.__default.FlattenLength $ly@@179 |shape#0|)))
 :qid |Sequencesidfy.609:22|
 :skolemid |5088|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@179) |shape#0|))
)))
(assert (forall (($ly@@180 T@U) (|shape#0@@0| T@U) ) (!  (=> (and (= (type $ly@@180) LayerTypeType) (= (type |shape#0@@0|) (SeqType BoxType))) (= (Sequences.__default.FlattenLength $ly@@180 |shape#0@@0|) (Sequences.__default.FlattenLength $LZ |shape#0@@0|)))
 :qid |Sequencesidfy.609:22|
 :skolemid |5089|
 :pattern ( (Sequences.__default.FlattenLength (AsFuelBottom $ly@@180) |shape#0@@0|))
)))
(assert  (=> true (forall (($ly@@181 T@U) (|shape#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@181) LayerTypeType) (= (type |shape#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| |shape#0@@1|) ($Is |shape#0@@1| (TSeq Tclass._System.nat)))) (and (=> (= (|Seq#Length| |shape#0@@1|) (LitInt 0)) (= (Sequences.__default.FlattenLength $ly@@181 |shape#0@@1|) (LitInt 0))) (INTERNAL_le_boogie 0 (Sequences.__default.FlattenLength $ly@@181 |shape#0@@1|))))
 :qid |Sequencesidfy.609:22|
 :skolemid |5090|
 :pattern ( (Sequences.__default.FlattenLength $ly@@181 |shape#0@@1|))
))))
(assert (forall (($ly@@182 T@U) (|shape#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@182) LayerTypeType) (= (type |shape#0@@2|) (SeqType BoxType))) ($Is |shape#0@@2| (TSeq Tclass._System.nat))) (= (|Sequences.__default.FlattenLength#requires| $ly@@182 |shape#0@@2|) true))
 :qid |Sequencesidfy.609:22|
 :skolemid |5091|
 :pattern ( (|Sequences.__default.FlattenLength#requires| $ly@@182 |shape#0@@2|))
)))
(assert  (=> true (forall (($ly@@183 T@U) (|shape#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@183) LayerTypeType) (= (type |shape#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| |shape#0@@3|) ($Is |shape#0@@3| (TSeq Tclass._System.nat)))) (and (=> (not (= (|Seq#Length| |shape#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@3|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@3|))) (|Sequences.__default.Last#canCall| Tclass._System.nat |shape#0@@3|))) (= (Sequences.__default.FlattenLength ($LS $ly@@183) |shape#0@@3|) (ite (= (|Seq#Length| |shape#0@@3|) (LitInt 0)) 0 (INTERNAL_add_boogie (Sequences.__default.FlattenLength $ly@@183 (Sequences.__default.DropLast Tclass._System.nat |shape#0@@3|)) (U_2_int ($Unbox intType (Sequences.__default.Last Tclass._System.nat |shape#0@@3|))))))))
 :qid |Sequencesidfy.609:22|
 :skolemid |5092|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@183) |shape#0@@3|))
))))
(assert  (=> true (forall (($ly@@184 T@U) (|shape#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@184) LayerTypeType) (= (type |shape#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| (Lit |shape#0@@4|)) ($Is |shape#0@@4| (TSeq Tclass._System.nat)))) (and (=> (not (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@4|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@4|))))) (|Sequences.__default.Last#canCall| Tclass._System.nat (Lit |shape#0@@4|)))) (= (Sequences.__default.FlattenLength ($LS $ly@@184) (Lit |shape#0@@4|)) (ite (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0)) 0 (INTERNAL_add_boogie (Sequences.__default.FlattenLength ($LS $ly@@184) (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@4|)))) (U_2_int ($Unbox intType (Sequences.__default.Last Tclass._System.nat (Lit |shape#0@@4|)))))))))
 :qid |Sequencesidfy.609:22|
 :weight 3
 :skolemid |5093|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@184) (Lit |shape#0@@4|)))
))))
(assert (forall ((arg0@@525 T@U) (arg1@@239 T@U) (arg2@@125 T@U) ) (! (= (type (Sequences.__default.Flatten arg0@@525 arg1@@239 arg2@@125)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Flatten|
 :pattern ( (Sequences.__default.Flatten arg0@@525 arg1@@239 arg2@@125))
)))
(assert (forall ((Sequences._default.Flatten$A T@U) ($ly@@185 T@U) (|seqs#0@@5| T@U) ) (!  (=> (and (and (= (type Sequences._default.Flatten$A) TyType) (= (type $ly@@185) LayerTypeType)) (= (type |seqs#0@@5|) (SeqType BoxType))) (= (Sequences.__default.Flatten Sequences._default.Flatten$A ($LS $ly@@185) |seqs#0@@5|) (Sequences.__default.Flatten Sequences._default.Flatten$A $ly@@185 |seqs#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |5094|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A ($LS $ly@@185) |seqs#0@@5|))
)))
(assert (forall ((Sequences._default.Flatten$A@@0 T@U) ($ly@@186 T@U) (|seqs#0@@6| T@U) ) (!  (=> (and (and (= (type Sequences._default.Flatten$A@@0) TyType) (= (type $ly@@186) LayerTypeType)) (= (type |seqs#0@@6|) (SeqType BoxType))) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 $ly@@186 |seqs#0@@6|) (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 $LZ |seqs#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |5095|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 (AsFuelBottom $ly@@186) |seqs#0@@6|))
)))
(assert  (and (= (type StartFuel_Sequences._default.FlattenLength) LayerTypeType) (= (type StartFuel_Sequences._default.FlattenShape) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@1 T@U) ($ly@@187 T@U) (|seqs#0@@7| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@1) TyType) (= (type $ly@@187) LayerTypeType)) (= (type |seqs#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@1 |seqs#0@@7|) ($Is |seqs#0@@7| (TSeq (TSeq Sequences._default.Flatten$A@@1))))) (and (and (= (|Seq#Length| (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@187 |seqs#0@@7|)) (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.FlattenShape Sequences._default.Flatten$A@@1 StartFuel_Sequences._default.FlattenShape |seqs#0@@7|))) (=> (= (|Seq#Length| |seqs#0@@7|) (LitInt 0)) (= (|Seq#Length| (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@187 |seqs#0@@7|)) (LitInt 0)))) ($Is (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@187 |seqs#0@@7|) (TSeq Sequences._default.Flatten$A@@1))))
 :qid |unknown.0:0|
 :skolemid |5096|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@187 |seqs#0@@7|))
))))
(assert (forall ((Sequences._default.Flatten$A@@2 T@U) ($ly@@188 T@U) (|seqs#0@@8| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@2) TyType) (= (type $ly@@188) LayerTypeType)) (= (type |seqs#0@@8|) (SeqType BoxType))) ($Is |seqs#0@@8| (TSeq (TSeq Sequences._default.Flatten$A@@2)))) (= (|Sequences.__default.Flatten#requires| Sequences._default.Flatten$A@@2 $ly@@188 |seqs#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |5097|
 :pattern ( (|Sequences.__default.Flatten#requires| Sequences._default.Flatten$A@@2 $ly@@188 |seqs#0@@8|))
)))
(assert  (and (= (type MoreFuel_Sequences._default.FlattenShape0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.FlattenShape) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@3 T@U) ($ly@@189 T@U) (|seqs#0@@9| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@3) TyType) (= (type $ly@@189) LayerTypeType)) (= (type |seqs#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@3 |seqs#0@@9|) ($Is |seqs#0@@9| (TSeq (TSeq Sequences._default.Flatten$A@@3))))) (and (=> (not (= (|Seq#Length| |seqs#0@@9|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|) (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))) (and (and (and (= StartFuel_Sequences._default.FlattenShape ($LS MoreFuel_Sequences._default.FlattenShape0)) (= StartFuelAssert_Sequences._default.FlattenShape ($LS ($LS MoreFuel_Sequences._default.FlattenShape0)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape0) MoreFuel_Sequences._default.FlattenShape0)) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 ($LS $ly@@189) |seqs#0@@9|) (ite (= (|Seq#Length| |seqs#0@@9|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 $ly@@189 (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|)) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))))))))
 :qid |unknown.0:0|
 :skolemid |5098|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 ($LS $ly@@189) |seqs#0@@9|))
))))
(assert (= (type MoreFuel_Sequences._default.FlattenShape1) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@4 T@U) ($ly@@190 T@U) (|seqs#0@@10| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@4) TyType) (= (type $ly@@190) LayerTypeType)) (= (type |seqs#0@@10|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@4 (Lit |seqs#0@@10|)) ($Is |seqs#0@@10| (TSeq (TSeq Sequences._default.Flatten$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)) (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))) (and (and (and (= StartFuel_Sequences._default.FlattenShape ($LS MoreFuel_Sequences._default.FlattenShape1)) (= StartFuelAssert_Sequences._default.FlattenShape ($LS ($LS MoreFuel_Sequences._default.FlattenShape1)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape1) MoreFuel_Sequences._default.FlattenShape1)) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@190) (Lit |seqs#0@@10|)) (ite (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@190) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5099|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@190) (Lit |seqs#0@@10|)))
))))
(assert  (=> true (forall ((|shape#0@@5| T@U) (|i#0@@92| Int) (|j#0@@2| Int) ) (!  (=> (and (= (type |shape#0@@5|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| |shape#0@@5| |i#0@@92| |j#0@@2|) (and (and (and ($Is |shape#0@@5| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@92|)) (INTERNAL_le_boogie 0 |j#0@@2|)) (and (INTERNAL_lt_boogie |i#0@@92| (|Seq#Length| |shape#0@@5|)) (INTERNAL_lt_boogie |j#0@@2| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@5| |i#0@@92|)))))))) (INTERNAL_le_boogie 0 (Sequences.__default.FlattenIndex |shape#0@@5| |i#0@@92| |j#0@@2|)))
 :qid |Sequencesidfy.678:25|
 :skolemid |5100|
 :pattern ( (Sequences.__default.FlattenIndex |shape#0@@5| |i#0@@92| |j#0@@2|))
))))
(assert (forall ((|shape#0@@6| T@U) (|i#0@@93| Int) (|j#0@@3| Int) ) (!  (=> (= (type |shape#0@@6|) (SeqType BoxType)) (=> (and (and ($Is |shape#0@@6| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@93|)) (INTERNAL_le_boogie 0 |j#0@@3|)) (= (|Sequences.__default.FlattenIndex#requires| |shape#0@@6| |i#0@@93| |j#0@@3|)  (and (INTERNAL_lt_boogie |i#0@@93| (|Seq#Length| |shape#0@@6|)) (INTERNAL_lt_boogie |j#0@@3| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@6| |i#0@@93|))))))))
 :qid |Sequencesidfy.678:25|
 :skolemid |5101|
 :pattern ( (|Sequences.__default.FlattenIndex#requires| |shape#0@@6| |i#0@@93| |j#0@@3|))
)))
(assert  (=> true (forall ((|shape#0@@7| T@U) (|i#0@@94| Int) (|j#0@@4| Int) ) (!  (=> (and (= (type |shape#0@@7|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| |shape#0@@7| |i#0@@94| |j#0@@4|) (and (and (and ($Is |shape#0@@7| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@94|)) (INTERNAL_le_boogie 0 |j#0@@4|)) (and (INTERNAL_lt_boogie |i#0@@94| (|Seq#Length| |shape#0@@7|)) (INTERNAL_lt_boogie |j#0@@4| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@7| |i#0@@94|)))))))) (and (|Sequences.__default.FlattenLength#canCall| (|Seq#Take| |shape#0@@7| |i#0@@94|)) (= (Sequences.__default.FlattenIndex |shape#0@@7| |i#0@@94| |j#0@@4|) (INTERNAL_add_boogie (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (|Seq#Take| |shape#0@@7| |i#0@@94|)) |j#0@@4|))))
 :qid |Sequencesidfy.678:25|
 :skolemid |5102|
 :pattern ( (Sequences.__default.FlattenIndex |shape#0@@7| |i#0@@94| |j#0@@4|))
))))
(assert  (=> true (forall ((|shape#0@@8| T@U) (|i#0@@95| Int) (|j#0@@5| Int) ) (!  (=> (and (= (type |shape#0@@8|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| (Lit |shape#0@@8|) (LitInt |i#0@@95|) (LitInt |j#0@@5|)) (and (and (and ($Is |shape#0@@8| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@95|)) (INTERNAL_le_boogie 0 |j#0@@5|)) (and (INTERNAL_lt_boogie |i#0@@95| (|Seq#Length| (Lit |shape#0@@8|))) (INTERNAL_lt_boogie |j#0@@5| (U_2_int ($Unbox intType (|Seq#Index| (Lit |shape#0@@8|) (LitInt |i#0@@95|))))))))) (and (|Sequences.__default.FlattenLength#canCall| (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@95|)))) (= (Sequences.__default.FlattenIndex (Lit |shape#0@@8|) (LitInt |i#0@@95|) (LitInt |j#0@@5|)) (INTERNAL_add_boogie (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@95|)))) |j#0@@5|))))
 :qid |Sequencesidfy.678:25|
 :weight 3
 :skolemid |5103|
 :pattern ( (Sequences.__default.FlattenIndex (Lit |shape#0@@8|) (LitInt |i#0@@95|) (LitInt |j#0@@5|)))
))))
(assert (forall ((arg0@@526 T@U) (arg1@@240 T@U) (arg2@@126 Int) ) (! (= (type (Sequences.__default.UnflattenIndex arg0@@526 arg1@@240 arg2@@126)) DatatypeTypeType)
 :qid |funType:Sequences.__default.UnflattenIndex|
 :pattern ( (Sequences.__default.UnflattenIndex arg0@@526 arg1@@240 arg2@@126))
)))
(assert (forall (($ly@@191 T@U) (|shape#0@@9| T@U) (|i#0@@96| Int) ) (!  (=> (and (= (type $ly@@191) LayerTypeType) (= (type |shape#0@@9|) (SeqType BoxType))) (= (Sequences.__default.UnflattenIndex ($LS $ly@@191) |shape#0@@9| |i#0@@96|) (Sequences.__default.UnflattenIndex $ly@@191 |shape#0@@9| |i#0@@96|)))
 :qid |Sequencesidfy.685:12|
 :skolemid |5104|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@191) |shape#0@@9| |i#0@@96|))
)))
(assert (forall (($ly@@192 T@U) (|shape#0@@10| T@U) (|i#0@@97| Int) ) (!  (=> (and (= (type $ly@@192) LayerTypeType) (= (type |shape#0@@10|) (SeqType BoxType))) (= (Sequences.__default.UnflattenIndex $ly@@192 |shape#0@@10| |i#0@@97|) (Sequences.__default.UnflattenIndex $LZ |shape#0@@10| |i#0@@97|)))
 :qid |Sequencesidfy.685:12|
 :skolemid |5105|
 :pattern ( (Sequences.__default.UnflattenIndex (AsFuelBottom $ly@@192) |shape#0@@10| |i#0@@97|))
)))
(assert  (=> true (forall (($ly@@193 T@U) (|shape#0@@11| T@U) (|i#0@@98| Int) ) (!  (=> (and (and (= (type $ly@@193) LayerTypeType) (= (type |shape#0@@11|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| |shape#0@@11| |i#0@@98|) (and (and ($Is |shape#0@@11| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@98|)) (INTERNAL_lt_boogie |i#0@@98| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@11|))))) ($Is (Sequences.__default.UnflattenIndex $ly@@193 |shape#0@@11| |i#0@@98|) (Tclass._System.Tuple2 Tclass._System.nat Tclass._System.nat)))
 :qid |Sequencesidfy.685:12|
 :skolemid |5106|
 :pattern ( (Sequences.__default.UnflattenIndex $ly@@193 |shape#0@@11| |i#0@@98|))
))))
(assert (forall (($ly@@194 T@U) (|shape#0@@12| T@U) (|i#0@@99| Int) ) (!  (=> (and (and (= (type $ly@@194) LayerTypeType) (= (type |shape#0@@12|) (SeqType BoxType))) (and ($Is |shape#0@@12| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@99|))) (= (|Sequences.__default.UnflattenIndex#requires| $ly@@194 |shape#0@@12| |i#0@@99|) (INTERNAL_lt_boogie |i#0@@99| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@12|))))
 :qid |Sequencesidfy.685:12|
 :skolemid |5107|
 :pattern ( (|Sequences.__default.UnflattenIndex#requires| $ly@@194 |shape#0@@12| |i#0@@99|))
)))
(assert  (and (= (type MoreFuel_Sequences._default.FlattenLength0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.FlattenLength) LayerTypeType)))
(assert  (=> true (forall (($ly@@195 T@U) (|shape#0@@13| T@U) (|i#0@@100| Int) ) (!  (=> (and (and (= (type $ly@@195) LayerTypeType) (= (type |shape#0@@13|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| |shape#0@@13| |i#0@@100|) (and (and ($Is |shape#0@@13| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@100|)) (INTERNAL_lt_boogie |i#0@@100| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@13|))))) (and (and (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (=> (INTERNAL_lt_boogie |i#0@@100| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.UnflattenIndex#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|) |i#0@@100|)))) (=> (not (INTERNAL_lt_boogie |i#0@@100| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|)))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))))) (and (and (and (= StartFuel_Sequences._default.FlattenLength ($LS MoreFuel_Sequences._default.FlattenLength0)) (= StartFuelAssert_Sequences._default.FlattenLength ($LS ($LS MoreFuel_Sequences._default.FlattenLength0)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength0) MoreFuel_Sequences._default.FlattenLength0)) (= (Sequences.__default.UnflattenIndex ($LS $ly@@195) |shape#0@@13| |i#0@@100|) (ite (INTERNAL_lt_boogie |i#0@@100| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (Sequences.__default.UnflattenIndex $ly@@195 (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|) |i#0@@100|) (|#_System._tuple#2._#Make2| ($Box (int_2_U (INTERNAL_sub_boogie (|Seq#Length| |shape#0@@13|) 1))) ($Box (int_2_U (INTERNAL_sub_boogie |i#0@@100| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|)))))))))))
 :qid |Sequencesidfy.685:12|
 :skolemid |5108|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@195) |shape#0@@13| |i#0@@100|))
))))
(assert (= (type MoreFuel_Sequences._default.FlattenLength1) LayerTypeType))
(assert  (=> true (forall (($ly@@196 T@U) (|shape#0@@14| T@U) (|i#0@@101| Int) ) (!  (=> (and (and (= (type $ly@@196) LayerTypeType) (= (type |shape#0@@14|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| (Lit |shape#0@@14|) (LitInt |i#0@@101|)) (and (and ($Is |shape#0@@14| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@101|)) (INTERNAL_lt_boogie |i#0@@101| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit |shape#0@@14|)))))) (and (and (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (=> (INTERNAL_lt_boogie |i#0@@101| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.UnflattenIndex#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))) (LitInt |i#0@@101|))))) (=> (not (INTERNAL_lt_boogie |i#0@@101| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))))) (and (and (and (= StartFuel_Sequences._default.FlattenLength ($LS MoreFuel_Sequences._default.FlattenLength1)) (= StartFuelAssert_Sequences._default.FlattenLength ($LS ($LS MoreFuel_Sequences._default.FlattenLength1)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength1) MoreFuel_Sequences._default.FlattenLength1)) (= (Sequences.__default.UnflattenIndex ($LS $ly@@196) (Lit |shape#0@@14|) (LitInt |i#0@@101|)) (ite (INTERNAL_lt_boogie |i#0@@101| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (Sequences.__default.UnflattenIndex ($LS $ly@@196) (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))) (LitInt |i#0@@101|)) (|#_System._tuple#2._#Make2| ($Box (int_2_U (INTERNAL_sub_boogie (|Seq#Length| (Lit |shape#0@@14|)) 1))) ($Box (int_2_U (INTERNAL_sub_boogie |i#0@@101| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|)))))))))))))
 :qid |Sequencesidfy.685:12|
 :weight 3
 :skolemid |5109|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@196) (Lit |shape#0@@14|) (LitInt |i#0@@101|)))
))))
(assert (forall (($ly@@197 T@U) (|s#0@@97| T@U) ) (!  (=> (and (= (type $ly@@197) LayerTypeType) (= (type |s#0@@97|) (SeqType BoxType))) (= (Sequences.__default.seqMax ($LS $ly@@197) |s#0@@97|) (Sequences.__default.seqMax $ly@@197 |s#0@@97|)))
 :qid |Sequencesidfy.795:22|
 :skolemid |5110|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@197) |s#0@@97|))
)))
(assert (forall (($ly@@198 T@U) (|s#0@@98| T@U) ) (!  (=> (and (= (type $ly@@198) LayerTypeType) (= (type |s#0@@98|) (SeqType BoxType))) (= (Sequences.__default.seqMax $ly@@198 |s#0@@98|) (Sequences.__default.seqMax $LZ |s#0@@98|)))
 :qid |Sequencesidfy.795:22|
 :skolemid |5111|
 :pattern ( (Sequences.__default.seqMax (AsFuelBottom $ly@@198) |s#0@@98|))
)))
(assert  (=> true (forall (($ly@@199 T@U) (|s#0@@99| T@U) ) (!  (=> (and (and (= (type $ly@@199) LayerTypeType) (= (type |s#0@@99|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| |s#0@@99|) (and ($Is |s#0@@99| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@99|))))) (and (forall ((|k#0@@12| T@U) ) (!  (=> (and (and (= (type |k#0@@12|) intType) true) (|Seq#Contains| |s#0@@99| ($Box |k#0@@12|))) (INTERNAL_ge_boogie (Sequences.__default.seqMax $ly@@199 |s#0@@99|) (U_2_int |k#0@@12|)))
 :qid |Sequencesidfy.797:20|
 :skolemid |5112|
 :pattern ( (|Seq#Contains| |s#0@@99| ($Box |k#0@@12|)))
)) (|Seq#Contains| |s#0@@99| ($Box (int_2_U (Sequences.__default.seqMax $ly@@199 |s#0@@99|))))))
 :qid |Sequencesidfy.795:22|
 :skolemid |5113|
 :pattern ( (Sequences.__default.seqMax $ly@@199 |s#0@@99|))
))))
(assert (forall (($ly@@200 T@U) (|s#0@@100| T@U) ) (!  (=> (and (and (= (type $ly@@200) LayerTypeType) (= (type |s#0@@100|) (SeqType BoxType))) ($Is |s#0@@100| (TSeq TInt))) (= (|Sequences.__default.seqMax#requires| $ly@@200 |s#0@@100|) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@100|))))
 :qid |Sequencesidfy.795:22|
 :skolemid |5114|
 :pattern ( (|Sequences.__default.seqMax#requires| $ly@@200 |s#0@@100|))
)))
(assert  (=> true (forall (($ly@@201 T@U) (|s#0@@101| T@U) ) (!  (=> (and (and (= (type $ly@@201) LayerTypeType) (= (type |s#0@@101|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| |s#0@@101|) (and ($Is |s#0@@101| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@101|))))) (and (=> (not (= (|Seq#Length| |s#0@@101|) (LitInt 1))) (and (and (and (|Sequences.__default.DropLast#canCall| TInt |s#0@@101|) (|Sequences.__default.seqMax#canCall| (Sequences.__default.DropLast TInt |s#0@@101|))) (|Sequences.__default.Last#canCall| TInt |s#0@@101|)) (|Mathematics.__default.max#canCall| (Sequences.__default.seqMax $ly@@201 (Sequences.__default.DropLast TInt |s#0@@101|)) (U_2_int ($Unbox intType (Sequences.__default.Last TInt |s#0@@101|)))))) (= (Sequences.__default.seqMax ($LS $ly@@201) |s#0@@101|) (ite (= (|Seq#Length| |s#0@@101|) (LitInt 1)) (U_2_int ($Unbox intType (|Seq#Index| |s#0@@101| (LitInt 0)))) (Mathematics.__default.max (Sequences.__default.seqMax $ly@@201 (Sequences.__default.DropLast TInt |s#0@@101|)) (U_2_int ($Unbox intType (Sequences.__default.Last TInt |s#0@@101|))))))))
 :qid |Sequencesidfy.795:22|
 :skolemid |5115|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@201) |s#0@@101|))
))))
(assert  (=> true (forall (($ly@@202 T@U) (|s#0@@102| T@U) ) (!  (=> (and (and (= (type $ly@@202) LayerTypeType) (= (type |s#0@@102|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| (Lit |s#0@@102|)) (and ($Is |s#0@@102| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit |s#0@@102|)))))) (and (=> (not (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1))) (and (and (and (|Sequences.__default.DropLast#canCall| TInt (Lit |s#0@@102|)) (|Sequences.__default.seqMax#canCall| (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|))))) (|Sequences.__default.Last#canCall| TInt (Lit |s#0@@102|))) (|Mathematics.__default.max#canCall| (Sequences.__default.seqMax ($LS $ly@@202) (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))) (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last TInt (Lit |s#0@@102|)))))))) (= (Sequences.__default.seqMax ($LS $ly@@202) (Lit |s#0@@102|)) (ite (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1)) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@102|) (LitInt 0)))) (Mathematics.__default.max (Sequences.__default.seqMax ($LS $ly@@202) (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))) (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last TInt (Lit |s#0@@102|))))))))))
 :qid |Sequencesidfy.795:22|
 :weight 3
 :skolemid |5116|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@202) (Lit |s#0@@102|)))
))))
(assert (forall ((arg0@@527 T@U) (arg1@@241 T@U) (arg2@@127 Int) (arg3@@72 T@U) ) (! (= (type (Sequences.__default.fill arg0@@527 arg1@@241 arg2@@127 arg3@@72)) (SeqType BoxType))
 :qid |funType:Sequences.__default.fill|
 :pattern ( (Sequences.__default.fill arg0@@527 arg1@@241 arg2@@127 arg3@@72))
)))
(assert (forall ((Sequences._default.fill$T T@U) ($ly@@203 T@U) (|n#0@@5| Int) (|t#0@@6| T@U) ) (!  (=> (and (and (= (type Sequences._default.fill$T) TyType) (= (type $ly@@203) LayerTypeType)) (= (type |t#0@@6|) BoxType)) (= (Sequences.__default.fill Sequences._default.fill$T ($LS $ly@@203) |n#0@@5| |t#0@@6|) (Sequences.__default.fill Sequences._default.fill$T $ly@@203 |n#0@@5| |t#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |5117|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T ($LS $ly@@203) |n#0@@5| |t#0@@6|))
)))
(assert (forall ((Sequences._default.fill$T@@0 T@U) ($ly@@204 T@U) (|n#0@@6| Int) (|t#0@@7| T@U) ) (!  (=> (and (and (= (type Sequences._default.fill$T@@0) TyType) (= (type $ly@@204) LayerTypeType)) (= (type |t#0@@7|) BoxType)) (= (Sequences.__default.fill Sequences._default.fill$T@@0 $ly@@204 |n#0@@6| |t#0@@7|) (Sequences.__default.fill Sequences._default.fill$T@@0 $LZ |n#0@@6| |t#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |5118|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@0 (AsFuelBottom $ly@@204) |n#0@@6| |t#0@@7|))
)))
(assert  (=> true (forall ((Sequences._default.fill$T@@1 T@U) ($ly@@205 T@U) (|n#0@@7| Int) (|t#0@@8| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@1) TyType) (= (type $ly@@205) LayerTypeType)) (= (type |t#0@@8|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@1 |n#0@@7| |t#0@@8|) (and ($IsBox |t#0@@8| Sequences._default.fill$T@@1) (INTERNAL_ge_boogie |n#0@@7| 0)))) (and (and (= (|Seq#Length| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@205 |n#0@@7| |t#0@@8|)) |n#0@@7|) (forall ((|i#0@@102| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@102|) (INTERNAL_lt_boogie |i#0@@102| |n#0@@7|)) (= (|Seq#Index| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@205 |n#0@@7| |t#0@@8|) |i#0@@102|) |t#0@@8|))
 :qid |Sequencesidfy.884:18|
 :skolemid |5119|
 :pattern ( (|Seq#Index| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@205 |n#0@@7| |t#0@@8|) |i#0@@102|))
))) ($Is (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@205 |n#0@@7| |t#0@@8|) (TSeq Sequences._default.fill$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5120|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@205 |n#0@@7| |t#0@@8|))
))))
(assert (forall ((Sequences._default.fill$T@@2 T@U) ($ly@@206 T@U) (|n#0@@8| Int) (|t#0@@9| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@2) TyType) (= (type $ly@@206) LayerTypeType)) (= (type |t#0@@9|) BoxType)) ($IsBox |t#0@@9| Sequences._default.fill$T@@2)) (= (|Sequences.__default.fill#requires| Sequences._default.fill$T@@2 $ly@@206 |n#0@@8| |t#0@@9|) (INTERNAL_ge_boogie |n#0@@8| 0)))
 :qid |unknown.0:0|
 :skolemid |5121|
 :pattern ( (|Sequences.__default.fill#requires| Sequences._default.fill$T@@2 $ly@@206 |n#0@@8| |t#0@@9|))
)))
(assert  (=> true (forall ((Sequences._default.fill$T@@3 T@U) ($ly@@207 T@U) (|n#0@@9| Int) (|t#0@@10| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@3) TyType) (= (type $ly@@207) LayerTypeType)) (= (type |t#0@@10|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@3 |n#0@@9| |t#0@@10|) (and ($IsBox |t#0@@10| Sequences._default.fill$T@@3) (INTERNAL_ge_boogie |n#0@@9| 0)))) (and (=> (not (= |n#0@@9| (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@3 (INTERNAL_sub_boogie |n#0@@9| 1) |t#0@@10|)) (= (Sequences.__default.fill Sequences._default.fill$T@@3 ($LS $ly@@207) |n#0@@9| |t#0@@10|) (ite (= |n#0@@9| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@3 $ly@@207 (INTERNAL_sub_boogie |n#0@@9| 1) |t#0@@10|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@10|))))))
 :qid |unknown.0:0|
 :skolemid |5122|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@3 ($LS $ly@@207) |n#0@@9| |t#0@@10|))
))))
(assert  (=> true (forall ((Sequences._default.fill$T@@4 T@U) ($ly@@208 T@U) (|n#0@@10| Int) (|t#0@@11| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@4) TyType) (= (type $ly@@208) LayerTypeType)) (= (type |t#0@@11|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@4 (LitInt |n#0@@10|) |t#0@@11|) (and ($IsBox |t#0@@11| Sequences._default.fill$T@@4) (INTERNAL_ge_boogie |n#0@@10| 0)))) (and (=> (not (= (LitInt |n#0@@10|) (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@4 (LitInt (INTERNAL_sub_boogie |n#0@@10| 1)) |t#0@@11|)) (= (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@208) (LitInt |n#0@@10|) |t#0@@11|) (ite (= (LitInt |n#0@@10|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@208) (LitInt (INTERNAL_sub_boogie |n#0@@10| 1)) |t#0@@11|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@11|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5123|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@208) (LitInt |n#0@@10|) |t#0@@11|))
))))
(assert  (=> true (forall ((Sequences._default.fill$T@@5 T@U) ($ly@@209 T@U) (|n#0@@11| Int) (|t#0@@12| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@5) TyType) (= (type $ly@@209) LayerTypeType)) (= (type |t#0@@12|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@5 (LitInt |n#0@@11|) (Lit |t#0@@12|)) (and ($IsBox |t#0@@12| Sequences._default.fill$T@@5) (INTERNAL_ge_boogie |n#0@@11| 0)))) (and (=> (not (= (LitInt |n#0@@11|) (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@5 (LitInt (INTERNAL_sub_boogie |n#0@@11| 1)) (Lit |t#0@@12|))) (= (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@209) (LitInt |n#0@@11|) (Lit |t#0@@12|)) (ite (= (LitInt |n#0@@11|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@209) (LitInt (INTERNAL_sub_boogie |n#0@@11| 1)) (Lit |t#0@@12|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |t#0@@12|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5124|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@209) (LitInt |n#0@@11|) (Lit |t#0@@12|)))
))))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T T@U) (|s#0@@103| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T) TyType) (= (type |s#0@@103|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T |s#0@@103|) ($Is |s#0@@103| (TSeq Sequences._default.SeqHasUniqueElems$T)))) true)
 :qid |unknown.0:0|
 :skolemid |5125|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T |s#0@@103|))
))))
(assert (forall ((Sequences._default.SeqHasUniqueElems$T@@0 T@U) (|s#0@@104| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@0) TyType) (= (type |s#0@@104|) (SeqType BoxType))) ($Is |s#0@@104| (TSeq Sequences._default.SeqHasUniqueElems$T@@0))) (= (|Sequences.__default.SeqHasUniqueElems#requires| Sequences._default.SeqHasUniqueElems$T@@0 |s#0@@104|) true))
 :qid |unknown.0:0|
 :skolemid |5126|
 :pattern ( (|Sequences.__default.SeqHasUniqueElems#requires| Sequences._default.SeqHasUniqueElems$T@@0 |s#0@@104|))
)))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T@@1 T@U) (|s#0@@105| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@1) TyType) (= (type |s#0@@105|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|) ($Is |s#0@@105| (TSeq Sequences._default.SeqHasUniqueElems$T@@1)))) (= (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|) (forall ((|i#0@@103| Int) (|j#0@@6| Int) ) (!  (=> (and (and (and (INTERNAL_le_boogie 0 |i#0@@103|) (INTERNAL_lt_boogie |i#0@@103| (|Seq#Length| |s#0@@105|))) (and (INTERNAL_le_boogie 0 |j#0@@6|) (INTERNAL_lt_boogie |j#0@@6| (|Seq#Length| |s#0@@105|)))) (= (|Seq#Index| |s#0@@105| |i#0@@103|) (|Seq#Index| |s#0@@105| |j#0@@6|))) (= |i#0@@103| |j#0@@6|))
 :qid |Sequencesidfy.896:12|
 :skolemid |5127|
 :pattern ( (|Seq#Index| |s#0@@105| |j#0@@6|) (|Seq#Index| |s#0@@105| |i#0@@103|))
))))
 :qid |unknown.0:0|
 :skolemid |5128|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|))
))))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T@@2 T@U) (|s#0@@106| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@2) TyType) (= (type |s#0@@106|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)) ($Is |s#0@@106| (TSeq Sequences._default.SeqHasUniqueElems$T@@2)))) (= (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)) (forall ((|i#1@@19| Int) (|j#1@@0| Int) ) (!  (=> (and (and (and (INTERNAL_le_boogie 0 |i#1@@19|) (INTERNAL_lt_boogie |i#1@@19| (|Seq#Length| (Lit |s#0@@106|)))) (and (INTERNAL_le_boogie 0 |j#1@@0|) (INTERNAL_lt_boogie |j#1@@0| (|Seq#Length| (Lit |s#0@@106|))))) (= (|Seq#Index| (Lit |s#0@@106|) |i#1@@19|) (|Seq#Index| (Lit |s#0@@106|) |j#1@@0|))) (= |i#1@@19| |j#1@@0|))
 :qid |Sequencesidfy.896:12|
 :skolemid |5129|
 :pattern ( (|Seq#Index| |s#0@@106| |j#1@@0|) (|Seq#Index| |s#0@@106| |i#1@@19|))
))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5130|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)))
))))
(assert (= (type Tclass.MapRemove_s.__default) TyType))
(assert (= (Tag Tclass.MapRemove_s.__default) Tagclass.MapRemove_s.__default))
(assert (= (TagFamily Tclass.MapRemove_s.__default) tytagFamily$_default))
(assert (forall ((bx@@160 T@U) ) (!  (=> (and (= (type bx@@160) BoxType) ($IsBox bx@@160 Tclass.MapRemove_s.__default)) (and (= ($Box ($Unbox refType bx@@160)) bx@@160) ($Is ($Unbox refType bx@@160) Tclass.MapRemove_s.__default)))
 :qid |unknown.0:0|
 :skolemid |5131|
 :pattern ( ($IsBox bx@@160 Tclass.MapRemove_s.__default))
)))
(assert (forall (($o@@41 T@U) ) (!  (=> (= (type $o@@41) refType) (= ($Is $o@@41 Tclass.MapRemove_s.__default)  (or (= $o@@41 null) (= (dtype $o@@41) Tclass.MapRemove_s.__default))))
 :qid |unknown.0:0|
 :skolemid |5132|
 :pattern ( ($Is $o@@41 Tclass.MapRemove_s.__default))
)))
(assert (forall (($o@@42 T@U) ($h@@91 T@U) ) (!  (=> (and (= (type $o@@42) refType) (= (type $h@@91) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@91)  (or (= $o@@42 null) (U_2_bool (MapType1Select (MapType0Select $h@@91 $o@@42) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5133|
 :pattern ( ($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@91))
)))
(assert (forall ((arg0@@528 T@U) (arg1@@242 T@U) (arg2@@128 T@U) (arg3@@73 T@U) (arg4@@43 T@U) ) (! (= (type (MapRemove_s.__default.MapRemove1 arg0@@528 arg1@@242 arg2@@128 arg3@@73 arg4@@43)) (MapType BoxType BoxType))
 :qid |funType:MapRemove_s.__default.MapRemove1|
 :pattern ( (MapRemove_s.__default.MapRemove1 arg0@@528 arg1@@242 arg2@@128 arg3@@73 arg4@@43))
)))
(assert (forall ((MapRemove_s._default.MapRemove1$K T@U) (MapRemove_s._default.MapRemove1$V T@U) ($ly@@210 T@U) (|m#0@@13| T@U) (|k#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K) TyType) (= (type MapRemove_s._default.MapRemove1$V) TyType)) (= (type $ly@@210) LayerTypeType)) (= (type |m#0@@13|) (MapType BoxType BoxType))) (= (type |k#0@@13|) BoxType)) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V ($LS $ly@@210) |m#0@@13| |k#0@@13|) (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V $ly@@210 |m#0@@13| |k#0@@13|)))
 :qid |unknown.0:0|
 :skolemid |5134|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V ($LS $ly@@210) |m#0@@13| |k#0@@13|))
)))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@0 T@U) (MapRemove_s._default.MapRemove1$V@@0 T@U) ($ly@@211 T@U) (|m#0@@14| T@U) (|k#0@@14| T@U) ) (!  (=> (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@0) TyType) (= (type MapRemove_s._default.MapRemove1$V@@0) TyType)) (= (type $ly@@211) LayerTypeType)) (= (type |m#0@@14|) (MapType BoxType BoxType))) (= (type |k#0@@14|) BoxType)) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 $ly@@211 |m#0@@14| |k#0@@14|) (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 $LZ |m#0@@14| |k#0@@14|)))
 :qid |unknown.0:0|
 :skolemid |5135|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 (AsFuelBottom $ly@@211) |m#0@@14| |k#0@@14|))
)))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@1 T@U) (MapRemove_s._default.MapRemove1$V@@1 T@U) ($ly@@212 T@U) (|m#0@@15| T@U) (|k#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@1) TyType) (= (type MapRemove_s._default.MapRemove1$V@@1) TyType)) (= (type $ly@@212) LayerTypeType)) (= (type |m#0@@15|) (MapType BoxType BoxType))) (= (type |k#0@@15|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 |m#0@@15| |k#0@@15|) (and ($Is |m#0@@15| (TMap MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1)) ($IsBox |k#0@@15| MapRemove_s._default.MapRemove1$K@@1)))) (and (and (and (and (and (and (forall ((|j#0@@7| T@U) ) (!  (=> (and (and (= (type |j#0@@7|) BoxType) ($IsBox |j#0@@7| MapRemove_s._default.MapRemove1$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |j#0@@7|)) (not (= |j#0@@7| |k#0@@15|)))) (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#0@@7|)))
 :qid |MapRemovesdfy.15:20|
 :skolemid |5136|
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#0@@7|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@15|) |j#0@@7|))
)) (forall ((|j#1@@1| T@U) ) (!  (=> (and (= (type |j#1@@1|) BoxType) ($IsBox |j#1@@1| MapRemove_s._default.MapRemove1$K@@1)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#1@@1|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |j#1@@1|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#1@@1|)) (not (= |j#1@@1| |k#0@@15|)))))
 :qid |MapRemovesdfy.16:20|
 :skolemid |5137|
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@15|) |j#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#1@@1|))
))) (forall ((|j#2| T@U) ) (!  (=> (and (and (= (type |j#2|) BoxType) ($IsBox |j#2| MapRemove_s._default.MapRemove1$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#2|))) (= (MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#2|) (MapType0Select (|Map#Elements| |m#0@@15|) |j#2|)))
 :qid |MapRemovesdfy.17:20|
 :skolemid |5138|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@15|) |j#2|))
 :pattern ( (MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#2|))
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) |j#2|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|))) (|Set#Card| (|Map#Domain| |m#0@@15|)))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |k#0@@15|)) (= (|Map#Card| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) (INTERNAL_sub_boogie (|Map#Card| |m#0@@15|) 1)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |k#0@@15|))) (= (|Map#Card| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|)) (|Map#Card| |m#0@@15|)))) ($Is (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|) (TMap MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5139|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@212 |m#0@@15| |k#0@@15|))
))))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@2 T@U) (MapRemove_s._default.MapRemove1$V@@2 T@U) ($ly@@213 T@U) (|m#0@@16| T@U) (|k#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@2) TyType) (= (type MapRemove_s._default.MapRemove1$V@@2) TyType)) (= (type $ly@@213) LayerTypeType)) (= (type |m#0@@16|) (MapType BoxType BoxType))) (= (type |k#0@@16|) BoxType)) (and ($Is |m#0@@16| (TMap MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2)) ($IsBox |k#0@@16| MapRemove_s._default.MapRemove1$K@@2))) (= (|MapRemove_s.__default.MapRemove1#requires| MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2 $ly@@213 |m#0@@16| |k#0@@16|) true))
 :qid |unknown.0:0|
 :skolemid |5140|
 :pattern ( (|MapRemove_s.__default.MapRemove1#requires| MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2 $ly@@213 |m#0@@16| |k#0@@16|))
)))
(assert  (and (forall ((arg0@@529 T@U) (arg1@@243 T@U) (arg2@@129 T@U) ) (! (= (type (|lambda#196| arg0@@529 arg1@@243 arg2@@129)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#196|
 :pattern ( (|lambda#196| arg0@@529 arg1@@243 arg2@@129))
)) (forall ((arg0@@530 T@U) ) (! (= (type (|lambda#197| arg0@@530)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#197|
 :pattern ( (|lambda#197| arg0@@530))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@3 T@U) (MapRemove_s._default.MapRemove1$V@@3 T@U) ($ly@@214 T@U) (|m#0@@17| T@U) (|k#0@@17| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@3) TyType) (= (type MapRemove_s._default.MapRemove1$V@@3) TyType)) (= (type $ly@@214) LayerTypeType)) (= (type |m#0@@17|) (MapType BoxType BoxType))) (= (type |k#0@@17|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 |m#0@@17| |k#0@@17|) (and ($Is |m#0@@17| (TMap MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3)) ($IsBox |k#0@@17| MapRemove_s._default.MapRemove1$K@@3)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 ($LS $ly@@214) |m#0@@17| |k#0@@17|) (let ((|m'#0| (|Map#Glue| (|lambda#196| MapRemove_s._default.MapRemove1$K@@3 (|Map#Domain| |m#0@@17|) |k#0@@17|) (|lambda#197| (|Map#Elements| |m#0@@17|)) (TMap MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3))))
|m'#0|)))
 :qid |unknown.0:0|
 :skolemid |5141|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 ($LS $ly@@214) |m#0@@17| |k#0@@17|))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@4 T@U) (MapRemove_s._default.MapRemove1$V@@4 T@U) ($ly@@215 T@U) (|m#0@@18| T@U) (|k#0@@18| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@4) TyType) (= (type MapRemove_s._default.MapRemove1$V@@4) TyType)) (= (type $ly@@215) LayerTypeType)) (= (type |m#0@@18|) (MapType BoxType BoxType))) (= (type |k#0@@18|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 (Lit |m#0@@18|) |k#0@@18|) (and ($Is |m#0@@18| (TMap MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4)) ($IsBox |k#0@@18| MapRemove_s._default.MapRemove1$K@@4)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 ($LS $ly@@215) (Lit |m#0@@18|) |k#0@@18|) (let ((|m'#1| (|Map#Glue| (|lambda#196| MapRemove_s._default.MapRemove1$K@@4 (|Map#Domain| |m#0@@18|) |k#0@@18|) (|lambda#197| (|Map#Elements| (Lit |m#0@@18|))) (TMap MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4))))
|m'#1|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5142|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 ($LS $ly@@215) (Lit |m#0@@18|) |k#0@@18|))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@5 T@U) (MapRemove_s._default.MapRemove1$V@@5 T@U) ($ly@@216 T@U) (|m#0@@19| T@U) (|k#0@@19| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@5) TyType) (= (type MapRemove_s._default.MapRemove1$V@@5) TyType)) (= (type $ly@@216) LayerTypeType)) (= (type |m#0@@19|) (MapType BoxType BoxType))) (= (type |k#0@@19|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 (Lit |m#0@@19|) (Lit |k#0@@19|)) (and ($Is |m#0@@19| (TMap MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5)) ($IsBox |k#0@@19| MapRemove_s._default.MapRemove1$K@@5)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 ($LS $ly@@216) (Lit |m#0@@19|) (Lit |k#0@@19|)) (let ((|m'#2| (|Map#Glue| (|lambda#196| MapRemove_s._default.MapRemove1$K@@5 (|Map#Domain| |m#0@@19|) |k#0@@19|) (|lambda#197| (|Map#Elements| (Lit |m#0@@19|))) (TMap MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5))))
|m'#2|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5143|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 ($LS $ly@@216) (Lit |m#0@@19|) (Lit |k#0@@19|)))
))))
(assert (= (type Tclass.Maps.__default) TyType))
(assert (= (Tag Tclass.Maps.__default) Tagclass.Maps.__default))
(assert (= (TagFamily Tclass.Maps.__default) tytagFamily$_default))
(assert (forall ((bx@@161 T@U) ) (!  (=> (and (= (type bx@@161) BoxType) ($IsBox bx@@161 Tclass.Maps.__default)) (and (= ($Box ($Unbox refType bx@@161)) bx@@161) ($Is ($Unbox refType bx@@161) Tclass.Maps.__default)))
 :qid |unknown.0:0|
 :skolemid |5144|
 :pattern ( ($IsBox bx@@161 Tclass.Maps.__default))
)))
(assert (forall (($o@@43 T@U) ) (!  (=> (= (type $o@@43) refType) (= ($Is $o@@43 Tclass.Maps.__default)  (or (= $o@@43 null) (= (dtype $o@@43) Tclass.Maps.__default))))
 :qid |unknown.0:0|
 :skolemid |5145|
 :pattern ( ($Is $o@@43 Tclass.Maps.__default))
)))
(assert (forall (($o@@44 T@U) ($h@@92 T@U) ) (!  (=> (and (= (type $o@@44) refType) (= (type $h@@92) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@44 Tclass.Maps.__default $h@@92)  (or (= $o@@44 null) (U_2_bool (MapType1Select (MapType0Select $h@@92 $o@@44) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5146|
 :pattern ( ($IsAlloc $o@@44 Tclass.Maps.__default $h@@92))
)))
(assert  (=> true (forall ((Maps._default.IMapsTo$K T@U) (Maps._default.IMapsTo$V T@U) (|m#0@@20| T@U) (|k#0@@20| T@U) (|v#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K) TyType) (= (type Maps._default.IMapsTo$V) TyType)) (= (type |m#0@@20|) (IMapType BoxType BoxType))) (= (type |k#0@@20|) BoxType)) (= (type |v#0@@31|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K Maps._default.IMapsTo$V |m#0@@20| |k#0@@20| |v#0@@31|) (and (and ($Is |m#0@@20| (TIMap Maps._default.IMapsTo$K Maps._default.IMapsTo$V)) ($IsBox |k#0@@20| Maps._default.IMapsTo$K)) ($IsBox |v#0@@31| Maps._default.IMapsTo$V)))) true)
 :qid |unknown.0:0|
 :skolemid |5147|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K Maps._default.IMapsTo$V |m#0@@20| |k#0@@20| |v#0@@31|))
))))
(assert (forall ((Maps._default.IMapsTo$K@@0 T@U) (Maps._default.IMapsTo$V@@0 T@U) (|m#0@@21| T@U) (|k#0@@21| T@U) (|v#0@@32| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@0) TyType) (= (type Maps._default.IMapsTo$V@@0) TyType)) (= (type |m#0@@21|) (IMapType BoxType BoxType))) (= (type |k#0@@21|) BoxType)) (= (type |v#0@@32|) BoxType)) (and (and ($Is |m#0@@21| (TIMap Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0)) ($IsBox |k#0@@21| Maps._default.IMapsTo$K@@0)) ($IsBox |v#0@@32| Maps._default.IMapsTo$V@@0))) (= (|Maps.__default.IMapsTo#requires| Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0 |m#0@@21| |k#0@@21| |v#0@@32|) true))
 :qid |unknown.0:0|
 :skolemid |5148|
 :pattern ( (|Maps.__default.IMapsTo#requires| Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0 |m#0@@21| |k#0@@21| |v#0@@32|))
)))
(assert  (=> true (forall ((Maps._default.IMapsTo$K@@1 T@U) (Maps._default.IMapsTo$V@@1 T@U) (|m#0@@22| T@U) (|k#0@@22| T@U) (|v#0@@33| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@1) TyType) (= (type Maps._default.IMapsTo$V@@1) TyType)) (= (type |m#0@@22|) (IMapType BoxType BoxType))) (= (type |k#0@@22|) BoxType)) (= (type |v#0@@33|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@33|) (and (and ($Is |m#0@@22| (TIMap Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1)) ($IsBox |k#0@@22| Maps._default.IMapsTo$K@@1)) ($IsBox |v#0@@33| Maps._default.IMapsTo$V@@1)))) (= (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@33|)  (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@22|) |k#0@@22|)) (= (MapType0Select (|IMap#Elements| |m#0@@22|) |k#0@@22|) |v#0@@33|))))
 :qid |unknown.0:0|
 :skolemid |5149|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@33|))
))))
(assert  (=> true (forall ((Maps._default.IMapsTo$K@@2 T@U) (Maps._default.IMapsTo$V@@2 T@U) (|m#0@@23| T@U) (|k#0@@23| T@U) (|v#0@@34| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@2) TyType) (= (type Maps._default.IMapsTo$V@@2) TyType)) (= (type |m#0@@23|) (IMapType BoxType BoxType))) (= (type |k#0@@23|) BoxType)) (= (type |v#0@@34|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@34|)) (and (and ($Is |m#0@@23| (TIMap Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2)) ($IsBox |k#0@@23| Maps._default.IMapsTo$K@@2)) ($IsBox |v#0@@34| Maps._default.IMapsTo$V@@2)))) (= (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@34|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@23|) |k#0@@23|)) (= (MapType0Select (|IMap#Elements| (Lit |m#0@@23|)) (Lit |k#0@@23|)) (Lit |v#0@@34|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5150|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@34|)))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K T@U) (Maps._default.MapsTo$V T@U) (|m#0@@24| T@U) (|k#0@@24| T@U) (|v#0@@35| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K) TyType) (= (type Maps._default.MapsTo$V) TyType)) (= (type |m#0@@24|) (MapType BoxType BoxType))) (= (type |k#0@@24|) BoxType)) (= (type |v#0@@35|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K Maps._default.MapsTo$V |m#0@@24| |k#0@@24| |v#0@@35|) (and (and ($Is |m#0@@24| (TMap Maps._default.MapsTo$K Maps._default.MapsTo$V)) ($IsBox |k#0@@24| Maps._default.MapsTo$K)) ($IsBox |v#0@@35| Maps._default.MapsTo$V)))) true)
 :qid |unknown.0:0|
 :skolemid |5151|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K Maps._default.MapsTo$V |m#0@@24| |k#0@@24| |v#0@@35|))
))))
(assert (forall ((Maps._default.MapsTo$K@@0 T@U) (Maps._default.MapsTo$V@@0 T@U) (|m#0@@25| T@U) (|k#0@@25| T@U) (|v#0@@36| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@0) TyType) (= (type Maps._default.MapsTo$V@@0) TyType)) (= (type |m#0@@25|) (MapType BoxType BoxType))) (= (type |k#0@@25|) BoxType)) (= (type |v#0@@36|) BoxType)) (and (and ($Is |m#0@@25| (TMap Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0)) ($IsBox |k#0@@25| Maps._default.MapsTo$K@@0)) ($IsBox |v#0@@36| Maps._default.MapsTo$V@@0))) (= (|Maps.__default.MapsTo#requires| Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0 |m#0@@25| |k#0@@25| |v#0@@36|) true))
 :qid |unknown.0:0|
 :skolemid |5152|
 :pattern ( (|Maps.__default.MapsTo#requires| Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0 |m#0@@25| |k#0@@25| |v#0@@36|))
)))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@1 T@U) (Maps._default.MapsTo$V@@1 T@U) (|m#0@@26| T@U) (|k#0@@26| T@U) (|v#0@@37| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@1) TyType) (= (type Maps._default.MapsTo$V@@1) TyType)) (= (type |m#0@@26|) (MapType BoxType BoxType))) (= (type |k#0@@26|) BoxType)) (= (type |v#0@@37|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@37|) (and (and ($Is |m#0@@26| (TMap Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1)) ($IsBox |k#0@@26| Maps._default.MapsTo$K@@1)) ($IsBox |v#0@@37| Maps._default.MapsTo$V@@1)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@37|)  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@26|) |k#0@@26|)) (= (MapType0Select (|Map#Elements| |m#0@@26|) |k#0@@26|) |v#0@@37|))))
 :qid |unknown.0:0|
 :skolemid |5153|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@37|))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@2 T@U) (Maps._default.MapsTo$V@@2 T@U) (|m#0@@27| T@U) (|k#0@@27| T@U) (|v#0@@38| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@2) TyType) (= (type Maps._default.MapsTo$V@@2) TyType)) (= (type |m#0@@27|) (MapType BoxType BoxType))) (= (type |k#0@@27|) BoxType)) (= (type |v#0@@38|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@38|) (and (and ($Is |m#0@@27| (TMap Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2)) ($IsBox |k#0@@27| Maps._default.MapsTo$K@@2)) ($IsBox |v#0@@38| Maps._default.MapsTo$V@@2)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@38|)  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@27|) |k#0@@27|)) (= (MapType0Select (|Map#Elements| (Lit |m#0@@27|)) |k#0@@27|) |v#0@@38|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5154|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@38|))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@3 T@U) (Maps._default.MapsTo$V@@3 T@U) (|m#0@@28| T@U) (|k#0@@28| T@U) (|v#0@@39| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@3) TyType) (= (type Maps._default.MapsTo$V@@3) TyType)) (= (type |m#0@@28|) (MapType BoxType BoxType))) (= (type |k#0@@28|) BoxType)) (= (type |v#0@@39|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@39|)) (and (and ($Is |m#0@@28| (TMap Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3)) ($IsBox |k#0@@28| Maps._default.MapsTo$K@@3)) ($IsBox |v#0@@39| Maps._default.MapsTo$V@@3)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@39|))  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@28|) |k#0@@28|)) (= (MapType0Select (|Map#Elements| (Lit |m#0@@28|)) (Lit |k#0@@28|)) (Lit |v#0@@39|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5155|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@39|)))
))))
(assert  (=> true (forall ((Maps._default.IMapInjective$K T@U) (Maps._default.IMapInjective$V T@U) (|m#0@@29| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K) TyType) (= (type Maps._default.IMapInjective$V) TyType)) (= (type |m#0@@29|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K Maps._default.IMapInjective$V |m#0@@29|) ($Is |m#0@@29| (TIMap Maps._default.IMapInjective$K Maps._default.IMapInjective$V)))) true)
 :qid |unknown.0:0|
 :skolemid |5156|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K Maps._default.IMapInjective$V |m#0@@29|))
))))
(assert (forall ((Maps._default.IMapInjective$K@@0 T@U) (Maps._default.IMapInjective$V@@0 T@U) (|m#0@@30| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@0) TyType) (= (type Maps._default.IMapInjective$V@@0) TyType)) (= (type |m#0@@30|) (IMapType BoxType BoxType))) ($Is |m#0@@30| (TIMap Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0))) (= (|Maps.__default.IMapInjective#requires| Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0 |m#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |5157|
 :pattern ( (|Maps.__default.IMapInjective#requires| Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0 |m#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.IMapInjective$K@@1 T@U) (Maps._default.IMapInjective$V@@1 T@U) (|m#0@@31| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@1) TyType) (= (type Maps._default.IMapInjective$V@@1) TyType)) (= (type |m#0@@31|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|) ($Is |m#0@@31| (TIMap Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1)))) (= (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|)  (and true (forall ((|k1#0| T@U) (|k2#0| T@U) ) (!  (=> (and (= (type |k1#0|) BoxType) (= (type |k2#0|) BoxType)) (=> (and (and ($IsBox |k1#0| Maps._default.IMapInjective$K@@1) ($IsBox |k2#0| Maps._default.IMapInjective$K@@1)) (and (and (not (= |k1#0| |k2#0|)) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|)))) (not (= (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|) (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|)))))
 :qid |Mapsidfy.22:16|
 :skolemid |5158|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|))
 :pattern ( (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))
)))))
 :qid |unknown.0:0|
 :skolemid |5159|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|))
))))
(assert  (=> true (forall ((Maps._default.IMapInjective$K@@2 T@U) (Maps._default.IMapInjective$V@@2 T@U) (|m#0@@32| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@2) TyType) (= (type Maps._default.IMapInjective$V@@2) TyType)) (= (type |m#0@@32|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|)) ($Is |m#0@@32| (TIMap Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2)))) (= (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|))  (and true (forall ((|k1#1| T@U) (|k2#1| T@U) ) (!  (=> (and (= (type |k1#1|) BoxType) (= (type |k2#1|) BoxType)) (=> (and (and ($IsBox |k1#1| Maps._default.IMapInjective$K@@2) ($IsBox |k2#1| Maps._default.IMapInjective$K@@2)) (and (and (not (= |k1#1| |k2#1|)) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|)))) (not (= (MapType0Select (|IMap#Elements| (Lit |m#0@@32|)) |k1#1|) (MapType0Select (|IMap#Elements| (Lit |m#0@@32|)) |k2#1|)))))
 :qid |Mapsidfy.22:16|
 :skolemid |5160|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Elements| |m#0@@32|) |k1#1|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k1#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|))
 :pattern ( (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))
)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5161|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|)))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K T@U) (Maps._default.MapsAgreeOnKey$V T@U) (|m#0@@33| T@U) (|m'#0@@0| T@U) (|k#0@@29| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K) TyType) (= (type Maps._default.MapsAgreeOnKey$V) TyType)) (= (type |m#0@@33|) (MapType BoxType BoxType))) (= (type |m'#0@@0|) (MapType BoxType BoxType))) (= (type |k#0@@29|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V |m#0@@33| |m'#0@@0| |k#0@@29|) (and (and ($Is |m#0@@33| (TMap Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V)) ($Is |m'#0@@0| (TMap Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V))) ($IsBox |k#0@@29| Maps._default.MapsAgreeOnKey$K)))) true)
 :qid |unknown.0:0|
 :skolemid |5162|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V |m#0@@33| |m'#0@@0| |k#0@@29|))
))))
(assert (forall ((Maps._default.MapsAgreeOnKey$K@@0 T@U) (Maps._default.MapsAgreeOnKey$V@@0 T@U) (|m#0@@34| T@U) (|m'#0@@1| T@U) (|k#0@@30| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@0) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@0) TyType)) (= (type |m#0@@34|) (MapType BoxType BoxType))) (= (type |m'#0@@1|) (MapType BoxType BoxType))) (= (type |k#0@@30|) BoxType)) (and (and ($Is |m#0@@34| (TMap Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0)) ($Is |m'#0@@1| (TMap Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0))) ($IsBox |k#0@@30| Maps._default.MapsAgreeOnKey$K@@0))) (= (|Maps.__default.MapsAgreeOnKey#requires| Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0 |m#0@@34| |m'#0@@1| |k#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |5163|
 :pattern ( (|Maps.__default.MapsAgreeOnKey#requires| Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0 |m#0@@34| |m'#0@@1| |k#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@1 T@U) (Maps._default.MapsAgreeOnKey$V@@1 T@U) (|m#0@@35| T@U) (|m'#0@@2| T@U) (|k#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@1) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@1) TyType)) (= (type |m#0@@35|) (MapType BoxType BoxType))) (= (type |m'#0@@2|) (MapType BoxType BoxType))) (= (type |k#0@@31|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|) (and (and ($Is |m#0@@35| (TMap Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1)) ($Is |m'#0@@2| (TMap Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1))) ($IsBox |k#0@@31| Maps._default.MapsAgreeOnKey$K@@1)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|)  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|) |k#0@@31|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|) |k#0@@31|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|) |k#0@@31|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|) |k#0@@31|))) (= (MapType0Select (|Map#Elements| |m#0@@35|) |k#0@@31|) (MapType0Select (|Map#Elements| |m'#0@@2|) |k#0@@31|))))))
 :qid |unknown.0:0|
 :skolemid |5164|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@2 T@U) (Maps._default.MapsAgreeOnKey$V@@2 T@U) (|m#0@@36| T@U) (|m'#0@@3| T@U) (|k#0@@32| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@2) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@2) TyType)) (= (type |m#0@@36|) (MapType BoxType BoxType))) (= (type |m'#0@@3|) (MapType BoxType BoxType))) (= (type |k#0@@32|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|) (and (and ($Is |m#0@@36| (TMap Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2)) ($Is |m'#0@@3| (TMap Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2))) ($IsBox |k#0@@32| Maps._default.MapsAgreeOnKey$K@@2)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|)  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|) |k#0@@32|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|) |k#0@@32|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|) |k#0@@32|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|) |k#0@@32|))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@36|)) |k#0@@32|) (MapType0Select (|Map#Elements| (Lit |m'#0@@3|)) |k#0@@32|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5165|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@3 T@U) (Maps._default.MapsAgreeOnKey$V@@3 T@U) (|m#0@@37| T@U) (|m'#0@@4| T@U) (|k#0@@33| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@3) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@3) TyType)) (= (type |m#0@@37|) (MapType BoxType BoxType))) (= (type |m'#0@@4|) (MapType BoxType BoxType))) (= (type |k#0@@33|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|)) (and (and ($Is |m#0@@37| (TMap Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3)) ($Is |m'#0@@4| (TMap Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3))) ($IsBox |k#0@@33| Maps._default.MapsAgreeOnKey$K@@3)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|))  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|) |k#0@@33|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|) |k#0@@33|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|) |k#0@@33|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|) |k#0@@33|))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@37|)) (Lit |k#0@@33|)) (MapType0Select (|Map#Elements| (Lit |m'#0@@4|)) (Lit |k#0@@33|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5166|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|)))
))))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K T@U) (Maps._default.IMapsAgreeOnKey$V T@U) (|m#0@@38| T@U) (|m'#0@@5| T@U) (|k#0@@34| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K) TyType) (= (type Maps._default.IMapsAgreeOnKey$V) TyType)) (= (type |m#0@@38|) (IMapType BoxType BoxType))) (= (type |m'#0@@5|) (IMapType BoxType BoxType))) (= (type |k#0@@34|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V |m#0@@38| |m'#0@@5| |k#0@@34|) (and (and ($Is |m#0@@38| (TIMap Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V)) ($Is |m'#0@@5| (TIMap Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V))) ($IsBox |k#0@@34| Maps._default.IMapsAgreeOnKey$K)))) true)
 :qid |unknown.0:0|
 :skolemid |5167|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V |m#0@@38| |m'#0@@5| |k#0@@34|))
))))
(assert (forall ((Maps._default.IMapsAgreeOnKey$K@@0 T@U) (Maps._default.IMapsAgreeOnKey$V@@0 T@U) (|m#0@@39| T@U) (|m'#0@@6| T@U) (|k#0@@35| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@0) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@0) TyType)) (= (type |m#0@@39|) (IMapType BoxType BoxType))) (= (type |m'#0@@6|) (IMapType BoxType BoxType))) (= (type |k#0@@35|) BoxType)) (and (and ($Is |m#0@@39| (TIMap Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0)) ($Is |m'#0@@6| (TIMap Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0))) ($IsBox |k#0@@35| Maps._default.IMapsAgreeOnKey$K@@0))) (= (|Maps.__default.IMapsAgreeOnKey#requires| Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0 |m#0@@39| |m'#0@@6| |k#0@@35|) true))
 :qid |unknown.0:0|
 :skolemid |5168|
 :pattern ( (|Maps.__default.IMapsAgreeOnKey#requires| Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0 |m#0@@39| |m'#0@@6| |k#0@@35|))
)))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K@@1 T@U) (Maps._default.IMapsAgreeOnKey$V@@1 T@U) (|m#0@@40| T@U) (|m'#0@@7| T@U) (|k#0@@36| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@1) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@1) TyType)) (= (type |m#0@@40|) (IMapType BoxType BoxType))) (= (type |m'#0@@7|) (IMapType BoxType BoxType))) (= (type |k#0@@36|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|) (and (and ($Is |m#0@@40| (TIMap Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1)) ($Is |m'#0@@7| (TIMap Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1))) ($IsBox |k#0@@36| Maps._default.IMapsAgreeOnKey$K@@1)))) (= (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|)  (or (and (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|) |k#0@@36|))) (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|) |k#0@@36|)))) (and (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|) |k#0@@36|)) (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|) |k#0@@36|))) (= (MapType0Select (|IMap#Elements| |m#0@@40|) |k#0@@36|) (MapType0Select (|IMap#Elements| |m'#0@@7|) |k#0@@36|))))))
 :qid |unknown.0:0|
 :skolemid |5169|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|))
))))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K@@2 T@U) (Maps._default.IMapsAgreeOnKey$V@@2 T@U) (|m#0@@41| T@U) (|m'#0@@8| T@U) (|k#0@@37| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@2) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@2) TyType)) (= (type |m#0@@41|) (IMapType BoxType BoxType))) (= (type |m'#0@@8|) (IMapType BoxType BoxType))) (= (type |k#0@@37|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|)) (and (and ($Is |m#0@@41| (TIMap Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2)) ($Is |m'#0@@8| (TIMap Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2))) ($IsBox |k#0@@37| Maps._default.IMapsAgreeOnKey$K@@2)))) (= (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|))  (or (and (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|) |k#0@@37|))) (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|) |k#0@@37|)))) (and (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|) |k#0@@37|)) (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|) |k#0@@37|))) (= (MapType0Select (|IMap#Elements| (Lit |m#0@@41|)) (Lit |k#0@@37|)) (MapType0Select (|IMap#Elements| (Lit |m'#0@@8|)) (Lit |k#0@@37|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5170|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|)))
))))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K T@U) (Maps._default.IsSubIMap$V T@U) (|sub#0| T@U) (|sup#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K) TyType) (= (type Maps._default.IsSubIMap$V) TyType)) (= (type |sub#0|) (IMapType BoxType BoxType))) (= (type |sup#0|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V |sub#0| |sup#0|) (and ($Is |sub#0| (TIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V)) ($Is |sup#0| (TIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V))))) true)
 :qid |unknown.0:0|
 :skolemid |5171|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V |sub#0| |sup#0|))
))))
(assert (forall ((Maps._default.IsSubIMap$K@@0 T@U) (Maps._default.IsSubIMap$V@@0 T@U) (|sub#0@@0| T@U) (|sup#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@0) TyType) (= (type Maps._default.IsSubIMap$V@@0) TyType)) (= (type |sub#0@@0|) (IMapType BoxType BoxType))) (= (type |sup#0@@0|) (IMapType BoxType BoxType))) (and ($Is |sub#0@@0| (TIMap Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0)) ($Is |sup#0@@0| (TIMap Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0)))) (= (|Maps.__default.IsSubIMap#requires| Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0 |sub#0@@0| |sup#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |5172|
 :pattern ( (|Maps.__default.IsSubIMap#requires| Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0 |sub#0@@0| |sup#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K@@1 T@U) (Maps._default.IsSubIMap$V@@1 T@U) (|sub#0@@1| T@U) (|sup#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@1) TyType) (= (type Maps._default.IsSubIMap$V@@1) TyType)) (= (type |sub#0@@1|) (IMapType BoxType BoxType))) (= (type |sup#0@@1|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|) (and ($Is |sub#0@@1| (TIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1)) ($Is |sup#0@@1| (TIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1))))) (and (=> (|ISet#Subset| (|IMap#Domain| |sub#0@@1|) (|IMap#Domain| |sup#0@@1|)) (forall ((|key#0@@3| T@U) ) (!  (=> (and (and (= (type |key#0@@3|) BoxType) ($IsBox |key#0@@3| Maps._default.IsSubIMap$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@3|))) (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@3|))
 :qid |Mapsidfy.35:16|
 :skolemid |5174|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@3|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@3|))
))) (= (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|)  (and (|ISet#Subset| (|IMap#Domain| |sub#0@@1|) (|IMap#Domain| |sup#0@@1|)) (forall ((|key#0@@4| T@U) ) (!  (=> (and (and (= (type |key#0@@4|) BoxType) ($IsBox |key#0@@4| Maps._default.IsSubIMap$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@4|))) (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@4|))
 :qid |Mapsidfy.35:16|
 :skolemid |5173|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@4|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@4|))
))))))
 :qid |unknown.0:0|
 :skolemid |5175|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|))
))))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K@@2 T@U) (Maps._default.IsSubIMap$V@@2 T@U) (|sub#0@@2| T@U) (|sup#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@2) TyType) (= (type Maps._default.IsSubIMap$V@@2) TyType)) (= (type |sub#0@@2|) (IMapType BoxType BoxType))) (= (type |sup#0@@2|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|)) (and ($Is |sub#0@@2| (TIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2)) ($Is |sup#0@@2| (TIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2))))) (and (=> (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|)) (|IMap#Domain| (Lit |sup#0@@2|))) (forall ((|key#1@@0| T@U) ) (!  (=> (and (and (= (type |key#1@@0|) BoxType) ($IsBox |key#1@@0| Maps._default.IsSubIMap$K@@2)) (U_2_bool (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|))) |key#1@@0|))) (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|) |key#1@@0|))
 :qid |Mapsidfy.35:16|
 :skolemid |5177|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 |sub#0@@2| |sup#0@@2| |key#1@@0|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@2|) |key#1@@0|))
))) (= (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|))  (and (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|)) (|IMap#Domain| (Lit |sup#0@@2|))) (forall ((|key#1@@1| T@U) ) (!  (=> (and (and (= (type |key#1@@1|) BoxType) ($IsBox |key#1@@1| Maps._default.IsSubIMap$K@@2)) (U_2_bool (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|))) |key#1@@1|))) (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|) |key#1@@1|))
 :qid |Mapsidfy.35:16|
 :skolemid |5176|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 |sub#0@@2| |sup#0@@2| |key#1@@1|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@2|) |key#1@@1|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5178|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|)))
))))
(assert  (=> true (forall ((Maps._default.IsSubMap$K T@U) (Maps._default.IsSubMap$V T@U) (|sub#0@@3| T@U) (|sup#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K) TyType) (= (type Maps._default.IsSubMap$V) TyType)) (= (type |sub#0@@3|) (MapType BoxType BoxType))) (= (type |sup#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K Maps._default.IsSubMap$V |sub#0@@3| |sup#0@@3|) (and ($Is |sub#0@@3| (TMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V)) ($Is |sup#0@@3| (TMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V))))) true)
 :qid |unknown.0:0|
 :skolemid |5179|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V |sub#0@@3| |sup#0@@3|))
))))
(assert (forall ((Maps._default.IsSubMap$K@@0 T@U) (Maps._default.IsSubMap$V@@0 T@U) (|sub#0@@4| T@U) (|sup#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@0) TyType) (= (type Maps._default.IsSubMap$V@@0) TyType)) (= (type |sub#0@@4|) (MapType BoxType BoxType))) (= (type |sup#0@@4|) (MapType BoxType BoxType))) (and ($Is |sub#0@@4| (TMap Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0)) ($Is |sup#0@@4| (TMap Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0)))) (= (|Maps.__default.IsSubMap#requires| Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0 |sub#0@@4| |sup#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |5180|
 :pattern ( (|Maps.__default.IsSubMap#requires| Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0 |sub#0@@4| |sup#0@@4|))
)))
(assert  (=> true (forall ((Maps._default.IsSubMap$K@@1 T@U) (Maps._default.IsSubMap$V@@1 T@U) (|sub#0@@5| T@U) (|sup#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@1) TyType) (= (type Maps._default.IsSubMap$V@@1) TyType)) (= (type |sub#0@@5|) (MapType BoxType BoxType))) (= (type |sup#0@@5|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|) (and ($Is |sub#0@@5| (TMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1)) ($Is |sup#0@@5| (TMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1))))) (and (=> (|Set#Subset| (|Map#Domain| |sub#0@@5|) (|Map#Domain| |sup#0@@5|)) (forall ((|key#0@@5| T@U) ) (!  (=> (and (and (= (type |key#0@@5|) BoxType) ($IsBox |key#0@@5| Maps._default.IsSubMap$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@5|))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@5|))
 :qid |Mapsidfy.40:16|
 :skolemid |5182|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@5|))
))) (= (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|)  (and (|Set#Subset| (|Map#Domain| |sub#0@@5|) (|Map#Domain| |sup#0@@5|)) (forall ((|key#0@@6| T@U) ) (!  (=> (and (and (= (type |key#0@@6|) BoxType) ($IsBox |key#0@@6| Maps._default.IsSubMap$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@6|))) (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@6|))
 :qid |Mapsidfy.40:16|
 :skolemid |5181|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@6|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@6|))
))))))
 :qid |unknown.0:0|
 :skolemid |5183|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|))
))))
(assert  (=> true (forall ((Maps._default.IsSubMap$K@@2 T@U) (Maps._default.IsSubMap$V@@2 T@U) (|sub#0@@6| T@U) (|sup#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@2) TyType) (= (type Maps._default.IsSubMap$V@@2) TyType)) (= (type |sub#0@@6|) (MapType BoxType BoxType))) (= (type |sup#0@@6|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|)) (and ($Is |sub#0@@6| (TMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2)) ($Is |sup#0@@6| (TMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2))))) (and (=> (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|)) (|Map#Domain| (Lit |sup#0@@6|))) (forall ((|key#1@@2| T@U) ) (!  (=> (and (and (= (type |key#1@@2|) BoxType) ($IsBox |key#1@@2| Maps._default.IsSubMap$K@@2)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|))) |key#1@@2|))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|) |key#1@@2|))
 :qid |Mapsidfy.40:16|
 :skolemid |5185|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 |sub#0@@6| |sup#0@@6| |key#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@6|) |key#1@@2|))
))) (= (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|))  (and (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|)) (|Map#Domain| (Lit |sup#0@@6|))) (forall ((|key#1@@3| T@U) ) (!  (=> (and (and (= (type |key#1@@3|) BoxType) ($IsBox |key#1@@3| Maps._default.IsSubMap$K@@2)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|))) |key#1@@3|))) (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|) |key#1@@3|))
 :qid |Mapsidfy.40:16|
 :skolemid |5184|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 |sub#0@@6| |sup#0@@6| |key#1@@3|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@6|) |key#1@@3|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5186|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|)))
))))
(assert  (=> true (forall ((Maps._default.MapsAgree$K T@U) (Maps._default.MapsAgree$V T@U) (|ma#0| T@U) (|mb#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K) TyType) (= (type Maps._default.MapsAgree$V) TyType)) (= (type |ma#0|) (MapType BoxType BoxType))) (= (type |mb#0|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K Maps._default.MapsAgree$V |ma#0| |mb#0|) (and ($Is |ma#0| (TMap Maps._default.MapsAgree$K Maps._default.MapsAgree$V)) ($Is |mb#0| (TMap Maps._default.MapsAgree$K Maps._default.MapsAgree$V))))) true)
 :qid |unknown.0:0|
 :skolemid |5187|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K Maps._default.MapsAgree$V |ma#0| |mb#0|))
))))
(assert (forall ((Maps._default.MapsAgree$K@@0 T@U) (Maps._default.MapsAgree$V@@0 T@U) (|ma#0@@0| T@U) (|mb#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@0) TyType) (= (type Maps._default.MapsAgree$V@@0) TyType)) (= (type |ma#0@@0|) (MapType BoxType BoxType))) (= (type |mb#0@@0|) (MapType BoxType BoxType))) (and ($Is |ma#0@@0| (TMap Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0)) ($Is |mb#0@@0| (TMap Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0)))) (= (|Maps.__default.MapsAgree#requires| Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0 |ma#0@@0| |mb#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |5188|
 :pattern ( (|Maps.__default.MapsAgree#requires| Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0 |ma#0@@0| |mb#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapsAgree$K@@1 T@U) (Maps._default.MapsAgree$V@@1 T@U) (|ma#0@@1| T@U) (|mb#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@1) TyType) (= (type Maps._default.MapsAgree$V@@1) TyType)) (= (type |ma#0@@1|) (MapType BoxType BoxType))) (= (type |mb#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|) (and ($Is |ma#0@@1| (TMap Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1)) ($Is |mb#0@@1| (TMap Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|key#0@@7| T@U) ) (!  (=> (and (and (= (type |key#0@@7|) BoxType) ($IsBox |key#0@@7| Maps._default.MapsAgree$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@7|)) (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@7|)))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@7|))
 :qid |Mapsidfy.44:16|
 :skolemid |5190|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@7|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@7|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@7|))
))) (= (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|)  (and true (forall ((|key#0@@8| T@U) ) (!  (=> (= (type |key#0@@8|) BoxType) (=> (and ($IsBox |key#0@@8| Maps._default.MapsAgree$K@@1) (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@8|)) (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@8|)))) (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@8|)))
 :qid |Mapsidfy.44:16|
 :skolemid |5189|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@8|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@8|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@8|))
))))))
 :qid |unknown.0:0|
 :skolemid |5191|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgree$K@@2 T@U) (Maps._default.MapsAgree$V@@2 T@U) (|ma#0@@2| T@U) (|mb#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@2) TyType) (= (type Maps._default.MapsAgree$V@@2) TyType)) (= (type |ma#0@@2|) (MapType BoxType BoxType))) (= (type |mb#0@@2|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|)) (and ($Is |ma#0@@2| (TMap Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2)) ($Is |mb#0@@2| (TMap Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|key#1@@4| T@U) ) (!  (=> (and (and (= (type |key#1@@4|) BoxType) ($IsBox |key#1@@4| Maps._default.MapsAgree$K@@2)) (and (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|))) |key#1@@4|)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|))) |key#1@@4|)))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|) |key#1@@4|))
 :qid |Mapsidfy.44:16|
 :skolemid |5193|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 |ma#0@@2| |mb#0@@2| |key#1@@4|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@2|) |key#1@@4|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@2|) |key#1@@4|))
))) (= (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|))  (and true (forall ((|key#1@@5| T@U) ) (!  (=> (= (type |key#1@@5|) BoxType) (=> (and ($IsBox |key#1@@5| Maps._default.MapsAgree$K@@2) (and (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|))) |key#1@@5|)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|))) |key#1@@5|)))) (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|) |key#1@@5|)))
 :qid |Mapsidfy.44:16|
 :skolemid |5192|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 |ma#0@@2| |mb#0@@2| |key#1@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@2|) |key#1@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@2|) |key#1@@5|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5194|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|)))
))))
(assert (forall ((arg0@@531 T@U) (arg1@@244 T@U) (arg2@@130 T@U) (arg3@@74 T@U) (arg4@@44 T@U) ) (! (= (type (Maps.__default.MapRemove arg0@@531 arg1@@244 arg2@@130 arg3@@74 arg4@@44)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove|
 :pattern ( (Maps.__default.MapRemove arg0@@531 arg1@@244 arg2@@130 arg3@@74 arg4@@44))
)))
(assert (forall ((Maps._default.MapRemove$K T@U) (Maps._default.MapRemove$V T@U) ($ly@@217 T@U) (|m#0@@42| T@U) (|ks#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove$K) TyType) (= (type Maps._default.MapRemove$V) TyType)) (= (type $ly@@217) LayerTypeType)) (= (type |m#0@@42|) (MapType BoxType BoxType))) (= (type |ks#0|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V ($LS $ly@@217) |m#0@@42| |ks#0|) (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V $ly@@217 |m#0@@42| |ks#0|)))
 :qid |unknown.0:0|
 :skolemid |5195|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V ($LS $ly@@217) |m#0@@42| |ks#0|))
)))
(assert (forall ((Maps._default.MapRemove$K@@0 T@U) (Maps._default.MapRemove$V@@0 T@U) ($ly@@218 T@U) (|m#0@@43| T@U) (|ks#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove$K@@0) TyType) (= (type Maps._default.MapRemove$V@@0) TyType)) (= (type $ly@@218) LayerTypeType)) (= (type |m#0@@43|) (MapType BoxType BoxType))) (= (type |ks#0@@0|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 $ly@@218 |m#0@@43| |ks#0@@0|) (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 $LZ |m#0@@43| |ks#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5196|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 (AsFuelBottom $ly@@218) |m#0@@43| |ks#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@1 T@U) (Maps._default.MapRemove$V@@1 T@U) ($ly@@219 T@U) (|m#0@@44| T@U) (|ks#0@@1| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@1) TyType) (= (type Maps._default.MapRemove$V@@1) TyType)) (= (type $ly@@219) LayerTypeType)) (= (type |m#0@@44|) (MapType BoxType BoxType))) (= (type |ks#0@@1|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 |m#0@@44| |ks#0@@1|) (and ($Is |m#0@@44| (TMap Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1)) ($Is |ks#0@@1| (TSet Maps._default.MapRemove$K@@1))))) (and (and (and (and (and (forall ((|k#0@@38| T@U) ) (!  (=> (and (and (= (type |k#0@@38|) BoxType) ($IsBox |k#0@@38| Maps._default.MapRemove$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|) |k#0@@38|)) (not (U_2_bool (MapType0Select |ks#0@@1| |k#0@@38|))))) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |k#0@@38|)))
 :qid |Mapsidfy.48:20|
 :skolemid |5197|
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |k#0@@38|))
 :pattern ( (MapType0Select |ks#0@@1| |k#0@@38|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@44|) |k#0@@38|))
)) (forall ((|k#1@@1| T@U) ) (!  (=> (and (= (type |k#1@@1|) BoxType) ($IsBox |k#1@@1| Maps._default.MapRemove$K@@1)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |k#1@@1|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|) |k#1@@1|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |k#1@@1|)) (not (U_2_bool (MapType0Select |ks#0@@1| |k#1@@1|))))))
 :qid |Mapsidfy.49:20|
 :skolemid |5198|
 :pattern ( (MapType0Select |ks#0@@1| |k#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@44|) |k#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |k#1@@1|))
))) (forall ((|j#0@@8| T@U) ) (!  (=> (and (and (= (type |j#0@@8|) BoxType) ($IsBox |j#0@@8| Maps._default.MapRemove$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |j#0@@8|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |j#0@@8|) (MapType0Select (|Map#Elements| |m#0@@44|) |j#0@@8|)))
 :qid |Mapsidfy.50:20|
 :skolemid |5199|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@44|) |j#0@@8|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |j#0@@8|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) |j#0@@8|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|))) (|Set#Card| (|Map#Domain| |m#0@@44|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|)) (|Map#Card| |m#0@@44|))) ($Is (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|) (TMap Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5200|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@219 |m#0@@44| |ks#0@@1|))
))))
(assert (forall ((Maps._default.MapRemove$K@@2 T@U) (Maps._default.MapRemove$V@@2 T@U) ($ly@@220 T@U) (|m#0@@45| T@U) (|ks#0@@2| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@2) TyType) (= (type Maps._default.MapRemove$V@@2) TyType)) (= (type $ly@@220) LayerTypeType)) (= (type |m#0@@45|) (MapType BoxType BoxType))) (= (type |ks#0@@2|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@45| (TMap Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2)) ($Is |ks#0@@2| (TSet Maps._default.MapRemove$K@@2)))) (= (|Maps.__default.MapRemove#requires| Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2 $ly@@220 |m#0@@45| |ks#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |5201|
 :pattern ( (|Maps.__default.MapRemove#requires| Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2 $ly@@220 |m#0@@45| |ks#0@@2|))
)))
(assert (forall ((arg0@@532 T@U) (arg1@@245 T@U) (arg2@@131 T@U) ) (! (= (type (|lambda#202| arg0@@532 arg1@@245 arg2@@131)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#202|
 :pattern ( (|lambda#202| arg0@@532 arg1@@245 arg2@@131))
)))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@3 T@U) (Maps._default.MapRemove$V@@3 T@U) ($ly@@221 T@U) (|m#0@@46| T@U) (|ks#0@@3| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@3) TyType) (= (type Maps._default.MapRemove$V@@3) TyType)) (= (type $ly@@221) LayerTypeType)) (= (type |m#0@@46|) (MapType BoxType BoxType))) (= (type |ks#0@@3|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 |m#0@@46| |ks#0@@3|) (and ($Is |m#0@@46| (TMap Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3)) ($Is |ks#0@@3| (TSet Maps._default.MapRemove$K@@3))))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 ($LS $ly@@221) |m#0@@46| |ks#0@@3|) (let ((|m'#0@@9| (|Map#Glue| (|lambda#202| Maps._default.MapRemove$K@@3 (|Map#Domain| |m#0@@46|) |ks#0@@3|) (|lambda#197| (|Map#Elements| |m#0@@46|)) (TMap Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3))))
|m'#0@@9|)))
 :qid |unknown.0:0|
 :skolemid |5202|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 ($LS $ly@@221) |m#0@@46| |ks#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@4 T@U) (Maps._default.MapRemove$V@@4 T@U) ($ly@@222 T@U) (|m#0@@47| T@U) (|ks#0@@4| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@4) TyType) (= (type Maps._default.MapRemove$V@@4) TyType)) (= (type $ly@@222) LayerTypeType)) (= (type |m#0@@47|) (MapType BoxType BoxType))) (= (type |ks#0@@4|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 (Lit |m#0@@47|) (Lit |ks#0@@4|)) (and ($Is |m#0@@47| (TMap Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4)) ($Is |ks#0@@4| (TSet Maps._default.MapRemove$K@@4))))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 ($LS $ly@@222) (Lit |m#0@@47|) (Lit |ks#0@@4|)) (let ((|m'#1@@0| (|Map#Glue| (|lambda#202| Maps._default.MapRemove$K@@4 (|Map#Domain| |m#0@@47|) (Lit |ks#0@@4|)) (|lambda#197| (|Map#Elements| (Lit |m#0@@47|))) (TMap Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4))))
|m'#1@@0|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5203|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 ($LS $ly@@222) (Lit |m#0@@47|) (Lit |ks#0@@4|)))
))))
(assert (forall ((arg0@@533 T@U) (arg1@@246 T@U) (arg2@@132 T@U) (arg3@@75 T@U) (arg4@@45 T@U) ) (! (= (type (Maps.__default.MapRemoveStrong arg0@@533 arg1@@246 arg2@@132 arg3@@75 arg4@@45)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemoveStrong|
 :pattern ( (Maps.__default.MapRemoveStrong arg0@@533 arg1@@246 arg2@@132 arg3@@75 arg4@@45))
)))
(assert (forall ((Maps._default.MapRemoveStrong$K T@U) (Maps._default.MapRemoveStrong$V T@U) ($ly@@223 T@U) (|m#0@@48| T@U) (|ks#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemoveStrong$K) TyType) (= (type Maps._default.MapRemoveStrong$V) TyType)) (= (type $ly@@223) LayerTypeType)) (= (type |m#0@@48|) (MapType BoxType BoxType))) (= (type |ks#0@@5|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V ($LS $ly@@223) |m#0@@48| |ks#0@@5|) (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V $ly@@223 |m#0@@48| |ks#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |5204|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V ($LS $ly@@223) |m#0@@48| |ks#0@@5|))
)))
(assert (forall ((Maps._default.MapRemoveStrong$K@@0 T@U) (Maps._default.MapRemoveStrong$V@@0 T@U) ($ly@@224 T@U) (|m#0@@49| T@U) (|ks#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@0) TyType) (= (type Maps._default.MapRemoveStrong$V@@0) TyType)) (= (type $ly@@224) LayerTypeType)) (= (type |m#0@@49|) (MapType BoxType BoxType))) (= (type |ks#0@@6|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 $ly@@224 |m#0@@49| |ks#0@@6|) (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 $LZ |m#0@@49| |ks#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |5205|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 (AsFuelBottom $ly@@224) |m#0@@49| |ks#0@@6|))
)))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@1 T@U) (Maps._default.MapRemoveStrong$V@@1 T@U) ($ly@@225 T@U) (|m#0@@50| T@U) (|ks#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@1) TyType) (= (type Maps._default.MapRemoveStrong$V@@1) TyType)) (= (type $ly@@225) LayerTypeType)) (= (type |m#0@@50|) (MapType BoxType BoxType))) (= (type |ks#0@@7|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 |m#0@@50| |ks#0@@7|) (and ($Is |m#0@@50| (TMap Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1)) ($Is |ks#0@@7| (TSet Maps._default.MapRemoveStrong$K@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) (|Set#Difference| (|Map#Domain| |m#0@@50|) |ks#0@@7|)) (forall ((|j#0@@9| T@U) ) (!  (=> (and (and (= (type |j#0@@9|) BoxType) ($IsBox |j#0@@9| Maps._default.MapRemoveStrong$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) |j#0@@9|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) |j#0@@9|) (MapType0Select (|Map#Elements| |m#0@@50|) |j#0@@9|)))
 :qid |Mapsidfy.61:20|
 :skolemid |5206|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@50|) |j#0@@9|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) |j#0@@9|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) |j#0@@9|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|))) (|Set#Card| (|Map#Domain| |m#0@@50|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|)) (|Map#Card| |m#0@@50|))) ($Is (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|) (TMap Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5207|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@225 |m#0@@50| |ks#0@@7|))
))))
(assert (forall ((Maps._default.MapRemoveStrong$K@@2 T@U) (Maps._default.MapRemoveStrong$V@@2 T@U) ($ly@@226 T@U) (|m#0@@51| T@U) (|ks#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@2) TyType) (= (type Maps._default.MapRemoveStrong$V@@2) TyType)) (= (type $ly@@226) LayerTypeType)) (= (type |m#0@@51|) (MapType BoxType BoxType))) (= (type |ks#0@@8|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@51| (TMap Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2)) ($Is |ks#0@@8| (TSet Maps._default.MapRemoveStrong$K@@2)))) (= (|Maps.__default.MapRemoveStrong#requires| Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2 $ly@@226 |m#0@@51| |ks#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |5208|
 :pattern ( (|Maps.__default.MapRemoveStrong#requires| Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2 $ly@@226 |m#0@@51| |ks#0@@8|))
)))
(assert  (and (and (= (type StartFuel_Maps._default.MapRemove) LayerTypeType) (= (type MoreFuel_Maps._default.MapRemove0) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemove) LayerTypeType)))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@3 T@U) (Maps._default.MapRemoveStrong$V@@3 T@U) ($ly@@227 T@U) (|m#0@@52| T@U) (|ks#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@3) TyType) (= (type Maps._default.MapRemoveStrong$V@@3) TyType)) (= (type $ly@@227) LayerTypeType)) (= (type |m#0@@52|) (MapType BoxType BoxType))) (= (type |ks#0@@9|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 |m#0@@52| |ks#0@@9|) (and ($Is |m#0@@52| (TMap Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3)) ($Is |ks#0@@9| (TSet Maps._default.MapRemoveStrong$K@@3))))) (and (|Maps.__default.MapRemove#canCall| Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 |m#0@@52| |ks#0@@9|) (and (and (and (= StartFuel_Maps._default.MapRemove ($LS MoreFuel_Maps._default.MapRemove0)) (= StartFuelAssert_Maps._default.MapRemove ($LS ($LS MoreFuel_Maps._default.MapRemove0)))) (= (AsFuelBottom MoreFuel_Maps._default.MapRemove0) MoreFuel_Maps._default.MapRemove0)) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 ($LS $ly@@227) |m#0@@52| |ks#0@@9|) (Maps.__default.MapRemove Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 StartFuel_Maps._default.MapRemove |m#0@@52| |ks#0@@9|)))))
 :qid |unknown.0:0|
 :skolemid |5209|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 ($LS $ly@@227) |m#0@@52| |ks#0@@9|))
))))
(assert (= (type MoreFuel_Maps._default.MapRemove1) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@4 T@U) (Maps._default.MapRemoveStrong$V@@4 T@U) ($ly@@228 T@U) (|m#0@@53| T@U) (|ks#0@@10| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@4) TyType) (= (type Maps._default.MapRemoveStrong$V@@4) TyType)) (= (type $ly@@228) LayerTypeType)) (= (type |m#0@@53|) (MapType BoxType BoxType))) (= (type |ks#0@@10|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 (Lit |m#0@@53|) (Lit |ks#0@@10|)) (and ($Is |m#0@@53| (TMap Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4)) ($Is |ks#0@@10| (TSet Maps._default.MapRemoveStrong$K@@4))))) (and (|Maps.__default.MapRemove#canCall| Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 (Lit |m#0@@53|) (Lit |ks#0@@10|)) (and (and (and (= StartFuel_Maps._default.MapRemove ($LS MoreFuel_Maps._default.MapRemove1)) (= StartFuelAssert_Maps._default.MapRemove ($LS ($LS MoreFuel_Maps._default.MapRemove1)))) (= (AsFuelBottom MoreFuel_Maps._default.MapRemove1) MoreFuel_Maps._default.MapRemove1)) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 ($LS $ly@@228) (Lit |m#0@@53|) (Lit |ks#0@@10|)) (Maps.__default.MapRemove Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 StartFuel_Maps._default.MapRemove (Lit |m#0@@53|) (Lit |ks#0@@10|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5210|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 ($LS $ly@@228) (Lit |m#0@@53|) (Lit |ks#0@@10|)))
))))
(assert (forall ((arg0@@534 T@U) (arg1@@247 T@U) (arg2@@133 T@U) (arg3@@76 T@U) ) (! (= (type (Maps.__default.MapRemove1 arg0@@534 arg1@@247 arg2@@133 arg3@@76)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove1|
 :pattern ( (Maps.__default.MapRemove1 arg0@@534 arg1@@247 arg2@@133 arg3@@76))
)))
(assert  (=> true (forall ((Maps._default.MapRemove1$K T@U) (Maps._default.MapRemove1$V T@U) (|m#0@@54| T@U) (|k#0@@39| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K) TyType) (= (type Maps._default.MapRemove1$V) TyType)) (= (type |m#0@@54|) (MapType BoxType BoxType))) (= (type |k#0@@39|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|) (and ($Is |m#0@@54| (TMap Maps._default.MapRemove1$K Maps._default.MapRemove1$V)) ($IsBox |k#0@@39| Maps._default.MapRemove1$K)))) (and (and (and (and (and (and (forall ((|j#0@@10| T@U) ) (!  (=> (and (and (= (type |j#0@@10|) BoxType) ($IsBox |j#0@@10| Maps._default.MapRemove1$K)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |j#0@@10|)) (not (= |j#0@@10| |k#0@@39|)))) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#0@@10|)))
 :qid |Mapsidfy.70:18|
 :skolemid |5211|
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#0@@10|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@54|) |j#0@@10|))
)) (forall ((|j#1@@2| T@U) ) (!  (=> (and (= (type |j#1@@2|) BoxType) ($IsBox |j#1@@2| Maps._default.MapRemove1$K)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |j#1@@2|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|)) (not (= |j#1@@2| |k#0@@39|)))))
 :qid |Mapsidfy.71:18|
 :skolemid |5212|
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@54|) |j#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|))
))) (forall ((|j#2@@0| T@U) ) (!  (=> (and (and (= (type |j#2@@0|) BoxType) ($IsBox |j#2@@0| Maps._default.MapRemove1$K)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|) (MapType0Select (|Map#Elements| |m#0@@54|) |j#2@@0|)))
 :qid |Mapsidfy.72:18|
 :skolemid |5213|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@54|) |j#2@@0|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|))) (|Set#Card| (|Map#Domain| |m#0@@54|)))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |k#0@@39|)) (= (|Map#Card| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) (INTERNAL_sub_boogie (|Map#Card| |m#0@@54|) 1)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |k#0@@39|))) (= (|Map#Card| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) (|Map#Card| |m#0@@54|)))) ($Is (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|) (TMap Maps._default.MapRemove1$K Maps._default.MapRemove1$V))))
 :qid |unknown.0:0|
 :skolemid |5214|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|))
))))
(assert (forall ((Maps._default.MapRemove1$K@@0 T@U) (Maps._default.MapRemove1$V@@0 T@U) (|m#0@@55| T@U) (|k#0@@40| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@0) TyType) (= (type Maps._default.MapRemove1$V@@0) TyType)) (= (type |m#0@@55|) (MapType BoxType BoxType))) (= (type |k#0@@40|) BoxType)) (and ($Is |m#0@@55| (TMap Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0)) ($IsBox |k#0@@40| Maps._default.MapRemove1$K@@0))) (= (|Maps.__default.MapRemove1#requires| Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0 |m#0@@55| |k#0@@40|) true))
 :qid |unknown.0:0|
 :skolemid |5215|
 :pattern ( (|Maps.__default.MapRemove1#requires| Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0 |m#0@@55| |k#0@@40|))
)))
(assert (= (type StartFuel_MapRemove_s._default.MapRemove1) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@1 T@U) (Maps._default.MapRemove1$V@@1 T@U) (|m#0@@56| T@U) (|k#0@@41| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@1) TyType) (= (type Maps._default.MapRemove1$V@@1) TyType)) (= (type |m#0@@56|) (MapType BoxType BoxType))) (= (type |k#0@@41|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (and ($Is |m#0@@56| (TMap Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1)) ($IsBox |k#0@@41| Maps._default.MapRemove1$K@@1)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 StartFuel_MapRemove_s._default.MapRemove1 |m#0@@56| |k#0@@41|))))
 :qid |unknown.0:0|
 :skolemid |5216|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@2 T@U) (Maps._default.MapRemove1$V@@2 T@U) (|m#0@@57| T@U) (|k#0@@42| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@2) TyType) (= (type Maps._default.MapRemove1$V@@2) TyType)) (= (type |m#0@@57|) (MapType BoxType BoxType))) (= (type |k#0@@42|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (and ($Is |m#0@@57| (TMap Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2)) ($IsBox |k#0@@42| Maps._default.MapRemove1$K@@2)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 StartFuel_MapRemove_s._default.MapRemove1 (Lit |m#0@@57|) |k#0@@42|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5217|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@3 T@U) (Maps._default.MapRemove1$V@@3 T@U) (|m#0@@58| T@U) (|k#0@@43| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@3) TyType) (= (type Maps._default.MapRemove1$V@@3) TyType)) (= (type |m#0@@58|) (MapType BoxType BoxType))) (= (type |k#0@@43|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (and ($Is |m#0@@58| (TMap Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3)) ($IsBox |k#0@@43| Maps._default.MapRemove1$K@@3)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 StartFuel_MapRemove_s._default.MapRemove1 (Lit |m#0@@58|) (Lit |k#0@@43|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5218|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)))
))))
(assert (forall ((arg0@@535 T@U) (arg1@@248 T@U) (arg2@@134 T@U) (arg3@@77 T@U) (arg4@@46 T@U) ) (! (= (type (Maps.__default.MapRemove1Strong arg0@@535 arg1@@248 arg2@@134 arg3@@77 arg4@@46)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove1Strong|
 :pattern ( (Maps.__default.MapRemove1Strong arg0@@535 arg1@@248 arg2@@134 arg3@@77 arg4@@46))
)))
(assert (forall ((Maps._default.MapRemove1Strong$K T@U) (Maps._default.MapRemove1Strong$V T@U) ($ly@@229 T@U) (|m#0@@59| T@U) (|k#0@@44| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1Strong$K) TyType) (= (type Maps._default.MapRemove1Strong$V) TyType)) (= (type $ly@@229) LayerTypeType)) (= (type |m#0@@59|) (MapType BoxType BoxType))) (= (type |k#0@@44|) BoxType)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V ($LS $ly@@229) |m#0@@59| |k#0@@44|) (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V $ly@@229 |m#0@@59| |k#0@@44|)))
 :qid |unknown.0:0|
 :skolemid |5219|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V ($LS $ly@@229) |m#0@@59| |k#0@@44|))
)))
(assert (forall ((Maps._default.MapRemove1Strong$K@@0 T@U) (Maps._default.MapRemove1Strong$V@@0 T@U) ($ly@@230 T@U) (|m#0@@60| T@U) (|k#0@@45| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@0) TyType) (= (type Maps._default.MapRemove1Strong$V@@0) TyType)) (= (type $ly@@230) LayerTypeType)) (= (type |m#0@@60|) (MapType BoxType BoxType))) (= (type |k#0@@45|) BoxType)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 $ly@@230 |m#0@@60| |k#0@@45|) (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 $LZ |m#0@@60| |k#0@@45|)))
 :qid |unknown.0:0|
 :skolemid |5220|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 (AsFuelBottom $ly@@230) |m#0@@60| |k#0@@45|))
)))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@1 T@U) (Maps._default.MapRemove1Strong$V@@1 T@U) ($ly@@231 T@U) (|m#0@@61| T@U) (|k#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@1) TyType) (= (type Maps._default.MapRemove1Strong$V@@1) TyType)) (= (type $ly@@231) LayerTypeType)) (= (type |m#0@@61|) (MapType BoxType BoxType))) (= (type |k#0@@46|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 |m#0@@61| |k#0@@46|) (and ($Is |m#0@@61| (TMap Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1)) ($IsBox |k#0@@46| Maps._default.MapRemove1Strong$K@@1)))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) (|Set#Difference| (|Map#Domain| |m#0@@61|) (|Set#UnionOne| (|Set#Empty| BoxType) |k#0@@46|))) (forall ((|j#0@@11| T@U) ) (!  (=> (and (and (= (type |j#0@@11|) BoxType) ($IsBox |j#0@@11| Maps._default.MapRemove1Strong$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) |j#0@@11|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) |j#0@@11|) (MapType0Select (|Map#Elements| |m#0@@61|) |j#0@@11|)))
 :qid |Mapsidfy.82:20|
 :skolemid |5221|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@61|) |j#0@@11|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) |j#0@@11|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) |j#0@@11|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|))) (|Set#Card| (|Map#Domain| |m#0@@61|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|)) (|Map#Card| |m#0@@61|))) ($Is (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|) (TMap Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5222|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@231 |m#0@@61| |k#0@@46|))
))))
(assert (forall ((Maps._default.MapRemove1Strong$K@@2 T@U) (Maps._default.MapRemove1Strong$V@@2 T@U) ($ly@@232 T@U) (|m#0@@62| T@U) (|k#0@@47| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@2) TyType) (= (type Maps._default.MapRemove1Strong$V@@2) TyType)) (= (type $ly@@232) LayerTypeType)) (= (type |m#0@@62|) (MapType BoxType BoxType))) (= (type |k#0@@47|) BoxType)) (and ($Is |m#0@@62| (TMap Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2)) ($IsBox |k#0@@47| Maps._default.MapRemove1Strong$K@@2))) (= (|Maps.__default.MapRemove1Strong#requires| Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2 $ly@@232 |m#0@@62| |k#0@@47|) true))
 :qid |unknown.0:0|
 :skolemid |5223|
 :pattern ( (|Maps.__default.MapRemove1Strong#requires| Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2 $ly@@232 |m#0@@62| |k#0@@47|))
)))
(assert  (and (= (type MoreFuel_MapRemove_s._default.MapRemove10) LayerTypeType) (= (type StartFuelAssert_MapRemove_s._default.MapRemove1) LayerTypeType)))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@3 T@U) (Maps._default.MapRemove1Strong$V@@3 T@U) ($ly@@233 T@U) (|m#0@@63| T@U) (|k#0@@48| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@3) TyType) (= (type Maps._default.MapRemove1Strong$V@@3) TyType)) (= (type $ly@@233) LayerTypeType)) (= (type |m#0@@63|) (MapType BoxType BoxType))) (= (type |k#0@@48|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|) (and ($Is |m#0@@63| (TMap Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3)) ($IsBox |k#0@@48| Maps._default.MapRemove1Strong$K@@3)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove10)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove10)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove10) MoreFuel_MapRemove_s._default.MapRemove10)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 ($LS $ly@@233) |m#0@@63| |k#0@@48|) (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|)))))
 :qid |unknown.0:0|
 :skolemid |5224|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 ($LS $ly@@233) |m#0@@63| |k#0@@48|))
))))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove11) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@4 T@U) (Maps._default.MapRemove1Strong$V@@4 T@U) ($ly@@234 T@U) (|m#0@@64| T@U) (|k#0@@49| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@4) TyType) (= (type Maps._default.MapRemove1Strong$V@@4) TyType)) (= (type $ly@@234) LayerTypeType)) (= (type |m#0@@64|) (MapType BoxType BoxType))) (= (type |k#0@@49|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|) (and ($Is |m#0@@64| (TMap Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4)) ($IsBox |k#0@@49| Maps._default.MapRemove1Strong$K@@4)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove11)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove11)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove11) MoreFuel_MapRemove_s._default.MapRemove11)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 ($LS $ly@@234) (Lit |m#0@@64|) |k#0@@49|) (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5225|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 ($LS $ly@@234) (Lit |m#0@@64|) |k#0@@49|))
))))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove12) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@5 T@U) (Maps._default.MapRemove1Strong$V@@5 T@U) ($ly@@235 T@U) (|m#0@@65| T@U) (|k#0@@50| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@5) TyType) (= (type Maps._default.MapRemove1Strong$V@@5) TyType)) (= (type $ly@@235) LayerTypeType)) (= (type |m#0@@65|) (MapType BoxType BoxType))) (= (type |k#0@@50|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)) (and ($Is |m#0@@65| (TMap Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5)) ($IsBox |k#0@@50| Maps._default.MapRemove1Strong$K@@5)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove12)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove12)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove12) MoreFuel_MapRemove_s._default.MapRemove12)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 ($LS $ly@@235) (Lit |m#0@@65|) (Lit |k#0@@50|)) (Lit (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5226|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 ($LS $ly@@235) (Lit |m#0@@65|) (Lit |k#0@@50|)))
))))
(assert (forall ((arg0@@536 T@U) (arg1@@249 T@U) (arg2@@135 T@U) (arg3@@78 T@U) ) (! (= (type (Maps.__default.IMapInvert arg0@@536 arg1@@249 arg2@@135 arg3@@78)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapInvert|
 :pattern ( (Maps.__default.IMapInvert arg0@@536 arg1@@249 arg2@@135 arg3@@78))
)))
(assert (forall ((Maps._default.IMapInvert$K T@U) (Maps._default.IMapInvert$V T@U) ($ly@@236 T@U) (|m#0@@66| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInvert$K) TyType) (= (type Maps._default.IMapInvert$V) TyType)) (= (type $ly@@236) LayerTypeType)) (= (type |m#0@@66|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V ($LS $ly@@236) |m#0@@66|) (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V $ly@@236 |m#0@@66|)))
 :qid |unknown.0:0|
 :skolemid |5227|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V ($LS $ly@@236) |m#0@@66|))
)))
(assert (forall ((Maps._default.IMapInvert$K@@0 T@U) (Maps._default.IMapInvert$V@@0 T@U) ($ly@@237 T@U) (|m#0@@67| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInvert$K@@0) TyType) (= (type Maps._default.IMapInvert$V@@0) TyType)) (= (type $ly@@237) LayerTypeType)) (= (type |m#0@@67|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 $ly@@237 |m#0@@67|) (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 $LZ |m#0@@67|)))
 :qid |unknown.0:0|
 :skolemid |5228|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 (AsFuelBottom $ly@@237) |m#0@@67|))
)))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@1 T@U) (Maps._default.IMapInvert$V@@1 T@U) ($ly@@238 T@U) (|m#0@@68| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapInvert$K@@1) TyType) (= (type Maps._default.IMapInvert$V@@1) TyType)) (= (type $ly@@238) LayerTypeType)) (= (type |m#0@@68|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 |m#0@@68|) ($Is |m#0@@68| (TIMap Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1)))) ($Is (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 $ly@@238 |m#0@@68|) (TIMap Maps._default.IMapInvert$V@@1 Maps._default.IMapInvert$K@@1)))
 :qid |unknown.0:0|
 :skolemid |5229|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 $ly@@238 |m#0@@68|))
))))
(assert (forall ((Maps._default.IMapInvert$K@@2 T@U) (Maps._default.IMapInvert$V@@2 T@U) ($ly@@239 T@U) ($Heap@@46 T@U) (|m#0@@69| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@2) TyType) (= (type Maps._default.IMapInvert$V@@2) TyType)) (= (type $ly@@239) LayerTypeType)) (= (type $Heap@@46) (MapType0Type refType MapType1Type))) (= (type |m#0@@69|) (IMapType BoxType BoxType))) (and ($IsGoodHeap $Heap@@46) ($Is |m#0@@69| (TIMap Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2)))) (= (|Maps.__default.IMapInvert#requires| Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2 $ly@@239 |m#0@@69|) true))
 :qid |unknown.0:0|
 :skolemid |5230|
 :pattern ( (|Maps.__default.IMapInvert#requires| Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2 $ly@@239 |m#0@@69|) ($IsGoodHeap $Heap@@46))
)))
(assert (forall ((arg0@@537 T@U) (arg1@@250 T@U) (arg2@@136 T@U) (arg3@@79 T@U) ) (! (= (type (|$let#8_a| arg0@@537 arg1@@250 arg2@@136 arg3@@79)) BoxType)
 :qid |funType:$let#8_a|
 :pattern ( (|$let#8_a| arg0@@537 arg1@@250 arg2@@136 arg3@@79))
)))
(assert (forall ((Maps._default.IMapInvert$K@@3 T@U) (Maps._default.IMapInvert$V@@3 T@U) (m@@67 T@U) (b@@77 T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapInvert$K@@3) TyType) (= (type Maps._default.IMapInvert$V@@3) TyType)) (= (type m@@67) (IMapType BoxType BoxType))) (= (type b@@77) BoxType)) (|$let#8$canCall| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@77)) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@67) (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@77))) (= (MapType0Select (|IMap#Elements| m@@67) (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@77)) b@@77)))
 :qid |Mapsidfy.92:31|
 :skolemid |5231|
 :pattern ( (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@77))
)))
(assert (forall ((arg0@@538 T@U) (arg1@@251 T@U) (arg2@@137 T@U) ) (! (= (type (|lambda#207| arg0@@538 arg1@@251 arg2@@137)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#207|
 :pattern ( (|lambda#207| arg0@@538 arg1@@251 arg2@@137))
)))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@4 T@U) (Maps._default.IMapInvert$V@@4 T@U) ($ly@@240 T@U) ($Heap@@47 T@U) (|m#0@@70| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@4) TyType) (= (type Maps._default.IMapInvert$V@@4) TyType)) (= (type $ly@@240) LayerTypeType)) (= (type $Heap@@47) (MapType0Type refType MapType1Type))) (= (type |m#0@@70|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70|) (and ($IsGoodHeap $Heap@@47) ($Is |m#0@@70| (TIMap Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4))))) (and (forall ((|b#0@@48| T@U) ) (!  (=> (and (and (= (type |b#0@@48|) BoxType) ($IsBox |b#0@@48| Maps._default.IMapInvert$V@@4)) (U_2_bool (MapType0Select (|IMap#Values| |m#0@@70|) |b#0@@48|))) (|$let#8$canCall| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70| |b#0@@48|))
 :qid |Mapsidfy.92:10|
 :skolemid |5232|
 :pattern ( (MapType0Select (|IMap#Values| |m#0@@70|) |b#0@@48|))
)) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 ($LS $ly@@240) |m#0@@70|) (|IMap#Glue| (|lambda#155| Maps._default.IMapInvert$V@@4 (|IMap#Values| |m#0@@70|)) (|lambda#207| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70|) (TIMap Maps._default.IMapInvert$V@@4 Maps._default.IMapInvert$K@@4)))))
 :qid |unknown.0:0|
 :skolemid |5233|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 ($LS $ly@@240) |m#0@@70|) ($IsGoodHeap $Heap@@47))
))))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@5 T@U) (Maps._default.IMapInvert$V@@5 T@U) ($ly@@241 T@U) ($Heap@@48 T@U) (|m#0@@71| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@5) TyType) (= (type Maps._default.IMapInvert$V@@5) TyType)) (= (type $ly@@241) LayerTypeType)) (= (type $Heap@@48) (MapType0Type refType MapType1Type))) (= (type |m#0@@71|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|)) (and ($IsGoodHeap $Heap@@48) ($Is |m#0@@71| (TIMap Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5))))) (and (forall ((|b#0@@49| T@U) ) (!  (=> (and (and (= (type |b#0@@49|) BoxType) ($IsBox |b#0@@49| Maps._default.IMapInvert$V@@5)) (U_2_bool (MapType0Select (Lit (|IMap#Values| (Lit |m#0@@71|))) |b#0@@49|))) (|$let#8$canCall| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|) |b#0@@49|))
 :qid |Mapsidfy.92:10|
 :skolemid |5234|
 :pattern ( (MapType0Select (|IMap#Values| |m#0@@71|) |b#0@@49|))
)) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 ($LS $ly@@241) (Lit |m#0@@71|)) (|IMap#Glue| (|lambda#155| Maps._default.IMapInvert$V@@5 (Lit (|IMap#Values| (Lit |m#0@@71|)))) (|lambda#207| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|)) (TIMap Maps._default.IMapInvert$V@@5 Maps._default.IMapInvert$K@@5)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5235|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 ($LS $ly@@241) (Lit |m#0@@71|)) ($IsGoodHeap $Heap@@48))
))))
(assert (forall ((arg0@@539 T@U) (arg1@@252 T@U) (arg2@@138 T@U) (arg3@@80 T@U) (arg4@@47 T@U) ) (! (= (type (Maps.__default.IMapRemove arg0@@539 arg1@@252 arg2@@138 arg3@@80 arg4@@47)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRemove|
 :pattern ( (Maps.__default.IMapRemove arg0@@539 arg1@@252 arg2@@138 arg3@@80 arg4@@47))
)))
(assert (forall ((Maps._default.IMapRemove$K T@U) (Maps._default.IMapRemove$V T@U) ($ly@@242 T@U) (|m#0@@72| T@U) (|ks#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove$K) TyType) (= (type Maps._default.IMapRemove$V) TyType)) (= (type $ly@@242) LayerTypeType)) (= (type |m#0@@72|) (IMapType BoxType BoxType))) (= (type |ks#0@@11|) (MapType0Type BoxType boolType))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V ($LS $ly@@242) |m#0@@72| |ks#0@@11|) (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V $ly@@242 |m#0@@72| |ks#0@@11|)))
 :qid |unknown.0:0|
 :skolemid |5236|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V ($LS $ly@@242) |m#0@@72| |ks#0@@11|))
)))
(assert (forall ((Maps._default.IMapRemove$K@@0 T@U) (Maps._default.IMapRemove$V@@0 T@U) ($ly@@243 T@U) (|m#0@@73| T@U) (|ks#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove$K@@0) TyType) (= (type Maps._default.IMapRemove$V@@0) TyType)) (= (type $ly@@243) LayerTypeType)) (= (type |m#0@@73|) (IMapType BoxType BoxType))) (= (type |ks#0@@12|) (MapType0Type BoxType boolType))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 $ly@@243 |m#0@@73| |ks#0@@12|) (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 $LZ |m#0@@73| |ks#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |5237|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 (AsFuelBottom $ly@@243) |m#0@@73| |ks#0@@12|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@1 T@U) (Maps._default.IMapRemove$V@@1 T@U) ($ly@@244 T@U) (|m#0@@74| T@U) (|ks#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@1) TyType) (= (type Maps._default.IMapRemove$V@@1) TyType)) (= (type $ly@@244) LayerTypeType)) (= (type |m#0@@74|) (IMapType BoxType BoxType))) (= (type |ks#0@@13|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 |m#0@@74| |ks#0@@13|) (and ($Is |m#0@@74| (TIMap Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1)) ($Is |ks#0@@13| (TISet Maps._default.IMapRemove$K@@1))))) (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|)) (|ISet#Difference| (|IMap#Domain| |m#0@@74|) |ks#0@@13|)) (forall ((|j#0@@12| T@U) ) (!  (=> (and (and (= (type |j#0@@12|) BoxType) ($IsBox |j#0@@12| Maps._default.IMapRemove$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|)) |j#0@@12|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|)) |j#0@@12|) (MapType0Select (|IMap#Elements| |m#0@@74|) |j#0@@12|)))
 :qid |Mapsidfy.103:20|
 :skolemid |5238|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@74|) |j#0@@12|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|)) |j#0@@12|))
 :pattern ( (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|)) |j#0@@12|))
))) ($Is (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|) (TIMap Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5239|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@244 |m#0@@74| |ks#0@@13|))
))))
(assert (forall ((Maps._default.IMapRemove$K@@2 T@U) (Maps._default.IMapRemove$V@@2 T@U) ($ly@@245 T@U) (|m#0@@75| T@U) (|ks#0@@14| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@2) TyType) (= (type Maps._default.IMapRemove$V@@2) TyType)) (= (type $ly@@245) LayerTypeType)) (= (type |m#0@@75|) (IMapType BoxType BoxType))) (= (type |ks#0@@14|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@75| (TIMap Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2)) ($Is |ks#0@@14| (TISet Maps._default.IMapRemove$K@@2)))) (= (|Maps.__default.IMapRemove#requires| Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2 $ly@@245 |m#0@@75| |ks#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |5240|
 :pattern ( (|Maps.__default.IMapRemove#requires| Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2 $ly@@245 |m#0@@75| |ks#0@@14|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@3 T@U) (Maps._default.IMapRemove$V@@3 T@U) ($ly@@246 T@U) (|m#0@@76| T@U) (|ks#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@3) TyType) (= (type Maps._default.IMapRemove$V@@3) TyType)) (= (type $ly@@246) LayerTypeType)) (= (type |m#0@@76|) (IMapType BoxType BoxType))) (= (type |ks#0@@15|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 |m#0@@76| |ks#0@@15|) (and ($Is |m#0@@76| (TIMap Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3)) ($Is |ks#0@@15| (TISet Maps._default.IMapRemove$K@@3))))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 ($LS $ly@@246) |m#0@@76| |ks#0@@15|) (|IMap#Glue| (|lambda#202| Maps._default.IMapRemove$K@@3 (|IMap#Domain| |m#0@@76|) |ks#0@@15|) (|lambda#197| (|IMap#Elements| |m#0@@76|)) (TIMap Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3))))
 :qid |unknown.0:0|
 :skolemid |5241|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 ($LS $ly@@246) |m#0@@76| |ks#0@@15|))
))))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@4 T@U) (Maps._default.IMapRemove$V@@4 T@U) ($ly@@247 T@U) (|m#0@@77| T@U) (|ks#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@4) TyType) (= (type Maps._default.IMapRemove$V@@4) TyType)) (= (type $ly@@247) LayerTypeType)) (= (type |m#0@@77|) (IMapType BoxType BoxType))) (= (type |ks#0@@16|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 (Lit |m#0@@77|) (Lit |ks#0@@16|)) (and ($Is |m#0@@77| (TIMap Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4)) ($Is |ks#0@@16| (TISet Maps._default.IMapRemove$K@@4))))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 ($LS $ly@@247) (Lit |m#0@@77|) (Lit |ks#0@@16|)) (|IMap#Glue| (|lambda#202| Maps._default.IMapRemove$K@@4 (|IMap#Domain| |m#0@@77|) (Lit |ks#0@@16|)) (|lambda#197| (|IMap#Elements| (Lit |m#0@@77|))) (TIMap Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5242|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 ($LS $ly@@247) (Lit |m#0@@77|) (Lit |ks#0@@16|)))
))))
(assert (forall ((arg0@@540 T@U) (arg1@@253 T@U) (arg2@@139 T@U) (arg3@@81 T@U) (arg4@@48 T@U) ) (! (= (type (Maps.__default.IMapRemove1 arg0@@540 arg1@@253 arg2@@139 arg3@@81 arg4@@48)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRemove1|
 :pattern ( (Maps.__default.IMapRemove1 arg0@@540 arg1@@253 arg2@@139 arg3@@81 arg4@@48))
)))
(assert (forall ((Maps._default.IMapRemove1$K T@U) (Maps._default.IMapRemove1$V T@U) ($ly@@248 T@U) (|m#0@@78| T@U) (|k#0@@51| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove1$K) TyType) (= (type Maps._default.IMapRemove1$V) TyType)) (= (type $ly@@248) LayerTypeType)) (= (type |m#0@@78|) (IMapType BoxType BoxType))) (= (type |k#0@@51|) BoxType)) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V ($LS $ly@@248) |m#0@@78| |k#0@@51|) (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V $ly@@248 |m#0@@78| |k#0@@51|)))
 :qid |unknown.0:0|
 :skolemid |5243|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V ($LS $ly@@248) |m#0@@78| |k#0@@51|))
)))
(assert (forall ((Maps._default.IMapRemove1$K@@0 T@U) (Maps._default.IMapRemove1$V@@0 T@U) ($ly@@249 T@U) (|m#0@@79| T@U) (|k#0@@52| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove1$K@@0) TyType) (= (type Maps._default.IMapRemove1$V@@0) TyType)) (= (type $ly@@249) LayerTypeType)) (= (type |m#0@@79|) (IMapType BoxType BoxType))) (= (type |k#0@@52|) BoxType)) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 $ly@@249 |m#0@@79| |k#0@@52|) (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 $LZ |m#0@@79| |k#0@@52|)))
 :qid |unknown.0:0|
 :skolemid |5244|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 (AsFuelBottom $ly@@249) |m#0@@79| |k#0@@52|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@1 T@U) (Maps._default.IMapRemove1$V@@1 T@U) ($ly@@250 T@U) (|m#0@@80| T@U) (|k#0@@53| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@1) TyType) (= (type Maps._default.IMapRemove1$V@@1) TyType)) (= (type $ly@@250) LayerTypeType)) (= (type |m#0@@80|) (IMapType BoxType BoxType))) (= (type |k#0@@53|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 |m#0@@80| |k#0@@53|) (and ($Is |m#0@@80| (TIMap Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1)) ($IsBox |k#0@@53| Maps._default.IMapRemove1$K@@1)))) (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|)) (|ISet#Difference| (|IMap#Domain| |m#0@@80|) (|ISet#UnionOne| (|ISet#Empty| BoxType) |k#0@@53|))) (forall ((|j#0@@13| T@U) ) (!  (=> (and (and (= (type |j#0@@13|) BoxType) ($IsBox |j#0@@13| Maps._default.IMapRemove1$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|)) |j#0@@13|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|)) |j#0@@13|) (MapType0Select (|IMap#Elements| |m#0@@80|) |j#0@@13|)))
 :qid |Mapsidfy.110:20|
 :skolemid |5245|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@80|) |j#0@@13|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|)) |j#0@@13|))
 :pattern ( (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|)) |j#0@@13|))
))) ($Is (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|) (TIMap Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5246|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@250 |m#0@@80| |k#0@@53|))
))))
(assert (forall ((Maps._default.IMapRemove1$K@@2 T@U) (Maps._default.IMapRemove1$V@@2 T@U) ($ly@@251 T@U) (|m#0@@81| T@U) (|k#0@@54| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@2) TyType) (= (type Maps._default.IMapRemove1$V@@2) TyType)) (= (type $ly@@251) LayerTypeType)) (= (type |m#0@@81|) (IMapType BoxType BoxType))) (= (type |k#0@@54|) BoxType)) (and ($Is |m#0@@81| (TIMap Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2)) ($IsBox |k#0@@54| Maps._default.IMapRemove1$K@@2))) (= (|Maps.__default.IMapRemove1#requires| Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2 $ly@@251 |m#0@@81| |k#0@@54|) true))
 :qid |unknown.0:0|
 :skolemid |5247|
 :pattern ( (|Maps.__default.IMapRemove1#requires| Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2 $ly@@251 |m#0@@81| |k#0@@54|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@3 T@U) (Maps._default.IMapRemove1$V@@3 T@U) ($ly@@252 T@U) (|m#0@@82| T@U) (|k#0@@55| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@3) TyType) (= (type Maps._default.IMapRemove1$V@@3) TyType)) (= (type $ly@@252) LayerTypeType)) (= (type |m#0@@82|) (IMapType BoxType BoxType))) (= (type |k#0@@55|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 |m#0@@82| |k#0@@55|) (and ($Is |m#0@@82| (TIMap Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3)) ($IsBox |k#0@@55| Maps._default.IMapRemove1$K@@3)))) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 ($LS $ly@@252) |m#0@@82| |k#0@@55|) (|IMap#Glue| (|lambda#196| Maps._default.IMapRemove1$K@@3 (|IMap#Domain| |m#0@@82|) |k#0@@55|) (|lambda#197| (|IMap#Elements| |m#0@@82|)) (TIMap Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3))))
 :qid |unknown.0:0|
 :skolemid |5248|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 ($LS $ly@@252) |m#0@@82| |k#0@@55|))
))))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@4 T@U) (Maps._default.IMapRemove1$V@@4 T@U) ($ly@@253 T@U) (|m#0@@83| T@U) (|k#0@@56| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@4) TyType) (= (type Maps._default.IMapRemove1$V@@4) TyType)) (= (type $ly@@253) LayerTypeType)) (= (type |m#0@@83|) (IMapType BoxType BoxType))) (= (type |k#0@@56|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 (Lit |m#0@@83|) (Lit |k#0@@56|)) (and ($Is |m#0@@83| (TIMap Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4)) ($IsBox |k#0@@56| Maps._default.IMapRemove1$K@@4)))) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 ($LS $ly@@253) (Lit |m#0@@83|) (Lit |k#0@@56|)) (|IMap#Glue| (|lambda#196| Maps._default.IMapRemove1$K@@4 (|IMap#Domain| |m#0@@83|) |k#0@@56|) (|lambda#197| (|IMap#Elements| (Lit |m#0@@83|))) (TIMap Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5249|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 ($LS $ly@@253) (Lit |m#0@@83|) (Lit |k#0@@56|)))
))))
(assert (forall ((arg0@@541 T@U) (arg1@@254 T@U) (arg2@@140 T@U) (arg3@@82 T@U) ) (! (= (type (Maps.__default.MapRestrict arg0@@541 arg1@@254 arg2@@140 arg3@@82)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRestrict|
 :pattern ( (Maps.__default.MapRestrict arg0@@541 arg1@@254 arg2@@140 arg3@@82))
)))
(assert  (=> true (forall ((Maps._default.MapRestrict$K T@U) (Maps._default.MapRestrict$V T@U) (|m#0@@84| T@U) (|ks#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K) TyType) (= (type Maps._default.MapRestrict$V) TyType)) (= (type |m#0@@84|) (MapType BoxType BoxType))) (= (type |ks#0@@17|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|) (and ($Is |m#0@@84| (TMap Maps._default.MapRestrict$K Maps._default.MapRestrict$V)) ($Is |ks#0@@17| (TSet Maps._default.MapRestrict$K))))) ($Is (Maps.__default.MapRestrict Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|) (TMap Maps._default.MapRestrict$K Maps._default.MapRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |5250|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|))
))))
(assert (forall ((Maps._default.MapRestrict$K@@0 T@U) (Maps._default.MapRestrict$V@@0 T@U) (|m#0@@85| T@U) (|ks#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@0) TyType) (= (type Maps._default.MapRestrict$V@@0) TyType)) (= (type |m#0@@85|) (MapType BoxType BoxType))) (= (type |ks#0@@18|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@85| (TMap Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0)) ($Is |ks#0@@18| (TSet Maps._default.MapRestrict$K@@0)))) (= (|Maps.__default.MapRestrict#requires| Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0 |m#0@@85| |ks#0@@18|) true))
 :qid |unknown.0:0|
 :skolemid |5251|
 :pattern ( (|Maps.__default.MapRestrict#requires| Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0 |m#0@@85| |ks#0@@18|))
)))
(assert (forall ((arg0@@542 T@U) (arg1@@255 T@U) (arg2@@141 T@U) ) (! (= (type (|lambda#218| arg0@@542 arg1@@255 arg2@@141)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#218|
 :pattern ( (|lambda#218| arg0@@542 arg1@@255 arg2@@141))
)))
(assert  (=> true (forall ((Maps._default.MapRestrict$K@@1 T@U) (Maps._default.MapRestrict$V@@1 T@U) (|m#0@@86| T@U) (|ks#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@1) TyType) (= (type Maps._default.MapRestrict$V@@1) TyType)) (= (type |m#0@@86|) (MapType BoxType BoxType))) (= (type |ks#0@@19|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|) (and ($Is |m#0@@86| (TMap Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1)) ($Is |ks#0@@19| (TSet Maps._default.MapRestrict$K@@1))))) (= (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|) (|Map#Glue| (|lambda#218| Maps._default.MapRestrict$K@@1 |ks#0@@19| (|Map#Domain| |m#0@@86|)) (|lambda#197| (|Map#Elements| |m#0@@86|)) (TMap Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5252|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|))
))))
(assert  (=> true (forall ((Maps._default.MapRestrict$K@@2 T@U) (Maps._default.MapRestrict$V@@2 T@U) (|m#0@@87| T@U) (|ks#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@2) TyType) (= (type Maps._default.MapRestrict$V@@2) TyType)) (= (type |m#0@@87|) (MapType BoxType BoxType))) (= (type |ks#0@@20|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)) (and ($Is |m#0@@87| (TMap Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2)) ($Is |ks#0@@20| (TSet Maps._default.MapRestrict$K@@2))))) (= (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)) (|Map#Glue| (|lambda#218| Maps._default.MapRestrict$K@@2 (Lit |ks#0@@20|) (|Map#Domain| |m#0@@87|)) (|lambda#197| (|Map#Elements| (Lit |m#0@@87|))) (TMap Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5253|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)))
))))
(assert (forall ((arg0@@543 T@U) (arg1@@256 T@U) (arg2@@142 T@U) (arg3@@83 T@U) ) (! (= (type (Maps.__default.MapIRestrict arg0@@543 arg1@@256 arg2@@142 arg3@@83)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapIRestrict|
 :pattern ( (Maps.__default.MapIRestrict arg0@@543 arg1@@256 arg2@@142 arg3@@83))
)))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K T@U) (Maps._default.MapIRestrict$V T@U) (|m#0@@88| T@U) (|ks#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K) TyType) (= (type Maps._default.MapIRestrict$V) TyType)) (= (type |m#0@@88|) (MapType BoxType BoxType))) (= (type |ks#0@@21|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|) (and ($Is |m#0@@88| (TMap Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V)) ($Is |ks#0@@21| (TISet Maps._default.MapIRestrict$K))))) ($Is (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|) (TMap Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |5254|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|))
))))
(assert (forall ((Maps._default.MapIRestrict$K@@0 T@U) (Maps._default.MapIRestrict$V@@0 T@U) (|m#0@@89| T@U) (|ks#0@@22| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@0) TyType) (= (type Maps._default.MapIRestrict$V@@0) TyType)) (= (type |m#0@@89|) (MapType BoxType BoxType))) (= (type |ks#0@@22|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@89| (TMap Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0)) ($Is |ks#0@@22| (TISet Maps._default.MapIRestrict$K@@0)))) (= (|Maps.__default.MapIRestrict#requires| Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0 |m#0@@89| |ks#0@@22|) true))
 :qid |unknown.0:0|
 :skolemid |5255|
 :pattern ( (|Maps.__default.MapIRestrict#requires| Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0 |m#0@@89| |ks#0@@22|))
)))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@1 T@U) (Maps._default.MapIRestrict$V@@1 T@U) (|m#0@@90| T@U) (|ks#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@1) TyType) (= (type Maps._default.MapIRestrict$V@@1) TyType)) (= (type |m#0@@90|) (MapType BoxType BoxType))) (= (type |ks#0@@23|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|) (and ($Is |m#0@@90| (TMap Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1)) ($Is |ks#0@@23| (TISet Maps._default.MapIRestrict$K@@1))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|) (|Map#Glue| (|lambda#218| Maps._default.MapIRestrict$K@@1 (|Map#Domain| |m#0@@90|) |ks#0@@23|) (|lambda#197| (|Map#Elements| |m#0@@90|)) (TMap Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5256|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|))
))))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@2 T@U) (Maps._default.MapIRestrict$V@@2 T@U) (|m#0@@91| T@U) (|ks#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@2) TyType) (= (type Maps._default.MapIRestrict$V@@2) TyType)) (= (type |m#0@@91|) (MapType BoxType BoxType))) (= (type |ks#0@@24|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|) (and ($Is |m#0@@91| (TMap Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2)) ($Is |ks#0@@24| (TISet Maps._default.MapIRestrict$K@@2))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|) (|Map#Glue| (|lambda#218| Maps._default.MapIRestrict$K@@2 (|Map#Domain| |m#0@@91|) |ks#0@@24|) (|lambda#197| (|Map#Elements| (Lit |m#0@@91|))) (TMap Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5257|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|))
))))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@3 T@U) (Maps._default.MapIRestrict$V@@3 T@U) (|m#0@@92| T@U) (|ks#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@3) TyType) (= (type Maps._default.MapIRestrict$V@@3) TyType)) (= (type |m#0@@92|) (MapType BoxType BoxType))) (= (type |ks#0@@25|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)) (and ($Is |m#0@@92| (TMap Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3)) ($Is |ks#0@@25| (TISet Maps._default.MapIRestrict$K@@3))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)) (|Map#Glue| (|lambda#218| Maps._default.MapIRestrict$K@@3 (|Map#Domain| |m#0@@92|) (Lit |ks#0@@25|)) (|lambda#197| (|Map#Elements| (Lit |m#0@@92|))) (TMap Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5258|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)))
))))
(assert (forall ((arg0@@544 T@U) (arg1@@257 T@U) (arg2@@143 T@U) (arg3@@84 T@U) ) (! (= (type (Maps.__default.IMapRestrict arg0@@544 arg1@@257 arg2@@143 arg3@@84)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRestrict|
 :pattern ( (Maps.__default.IMapRestrict arg0@@544 arg1@@257 arg2@@143 arg3@@84))
)))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K T@U) (Maps._default.IMapRestrict$V T@U) (|m#0@@93| T@U) (|ks#0@@26| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K) TyType) (= (type Maps._default.IMapRestrict$V) TyType)) (= (type |m#0@@93|) (IMapType BoxType BoxType))) (= (type |ks#0@@26|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|) (and ($Is |m#0@@93| (TIMap Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V)) ($Is |ks#0@@26| (TISet Maps._default.IMapRestrict$K))))) ($Is (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|) (TIMap Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |5259|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|))
))))
(assert (forall ((Maps._default.IMapRestrict$K@@0 T@U) (Maps._default.IMapRestrict$V@@0 T@U) (|m#0@@94| T@U) (|ks#0@@27| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@0) TyType) (= (type Maps._default.IMapRestrict$V@@0) TyType)) (= (type |m#0@@94|) (IMapType BoxType BoxType))) (= (type |ks#0@@27|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@94| (TIMap Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0)) ($Is |ks#0@@27| (TISet Maps._default.IMapRestrict$K@@0)))) (= (|Maps.__default.IMapRestrict#requires| Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0 |m#0@@94| |ks#0@@27|) true))
 :qid |unknown.0:0|
 :skolemid |5260|
 :pattern ( (|Maps.__default.IMapRestrict#requires| Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0 |m#0@@94| |ks#0@@27|))
)))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K@@1 T@U) (Maps._default.IMapRestrict$V@@1 T@U) (|m#0@@95| T@U) (|ks#0@@28| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@1) TyType) (= (type Maps._default.IMapRestrict$V@@1) TyType)) (= (type |m#0@@95|) (IMapType BoxType BoxType))) (= (type |ks#0@@28|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|) (and ($Is |m#0@@95| (TIMap Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1)) ($Is |ks#0@@28| (TISet Maps._default.IMapRestrict$K@@1))))) (= (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|) (|IMap#Glue| (|lambda#218| Maps._default.IMapRestrict$K@@1 |ks#0@@28| (|IMap#Domain| |m#0@@95|)) (|lambda#197| (|IMap#Elements| |m#0@@95|)) (TIMap Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5261|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|))
))))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K@@2 T@U) (Maps._default.IMapRestrict$V@@2 T@U) (|m#0@@96| T@U) (|ks#0@@29| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@2) TyType) (= (type Maps._default.IMapRestrict$V@@2) TyType)) (= (type |m#0@@96|) (IMapType BoxType BoxType))) (= (type |ks#0@@29|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)) (and ($Is |m#0@@96| (TIMap Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2)) ($Is |ks#0@@29| (TISet Maps._default.IMapRestrict$K@@2))))) (= (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)) (|IMap#Glue| (|lambda#218| Maps._default.IMapRestrict$K@@2 (Lit |ks#0@@29|) (|IMap#Domain| |m#0@@96|)) (|lambda#197| (|IMap#Elements| (Lit |m#0@@96|))) (TIMap Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5262|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)))
))))
(assert (forall ((arg0@@545 T@U) (arg1@@258 T@U) (arg2@@144 T@U) (arg3@@85 T@U) (arg4@@49 T@U) ) (! (= (type (Maps.__default.MapDisjointUnion arg0@@545 arg1@@258 arg2@@144 arg3@@85 arg4@@49)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapDisjointUnion|
 :pattern ( (Maps.__default.MapDisjointUnion arg0@@545 arg1@@258 arg2@@144 arg3@@85 arg4@@49))
)))
(assert (forall ((Maps._default.MapDisjointUnion$U T@U) (Maps._default.MapDisjointUnion$T T@U) ($ly@@254 T@U) (|mapa#0| T@U) (|mapb#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapDisjointUnion$U) TyType) (= (type Maps._default.MapDisjointUnion$T) TyType)) (= (type $ly@@254) LayerTypeType)) (= (type |mapa#0|) (MapType BoxType BoxType))) (= (type |mapb#0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T ($LS $ly@@254) |mapa#0| |mapb#0|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T $ly@@254 |mapa#0| |mapb#0|)))
 :qid |unknown.0:0|
 :skolemid |5263|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T ($LS $ly@@254) |mapa#0| |mapb#0|))
)))
(assert (forall ((Maps._default.MapDisjointUnion$U@@0 T@U) (Maps._default.MapDisjointUnion$T@@0 T@U) ($ly@@255 T@U) (|mapa#0@@0| T@U) (|mapb#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@0) TyType) (= (type Maps._default.MapDisjointUnion$T@@0) TyType)) (= (type $ly@@255) LayerTypeType)) (= (type |mapa#0@@0|) (MapType BoxType BoxType))) (= (type |mapb#0@@0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 $ly@@255 |mapa#0@@0| |mapb#0@@0|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 $LZ |mapa#0@@0| |mapb#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5264|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 (AsFuelBottom $ly@@255) |mapa#0@@0| |mapb#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@1 T@U) (Maps._default.MapDisjointUnion$T@@1 T@U) ($ly@@256 T@U) (|mapa#0@@1| T@U) (|mapb#0@@1| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@1) TyType) (= (type Maps._default.MapDisjointUnion$T@@1) TyType)) (= (type $ly@@256) LayerTypeType)) (= (type |mapa#0@@1|) (MapType BoxType BoxType))) (= (type |mapb#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 |mapa#0@@1| |mapb#0@@1|) (and (and ($Is |mapa#0@@1| (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1)) ($Is |mapb#0@@1| (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1))) (|Set#Disjoint| (|Map#Domain| |mapa#0@@1|) (|Map#Domain| |mapb#0@@1|))))) (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|)) (|Set#Union| (|Map#Domain| |mapa#0@@1|) (|Map#Domain| |mapb#0@@1|))) (forall ((|k#0@@57| T@U) ) (!  (=> (and (and (= (type |k#0@@57|) BoxType) ($IsBox |k#0@@57| Maps._default.MapDisjointUnion$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@1|) |k#0@@57|))) (= (MapType0Select (|Map#Elements| |mapa#0@@1|) |k#0@@57|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|)) |k#0@@57|)))
 :qid |Mapsidfy.131:18|
 :skolemid |5265|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|)) |k#0@@57|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@1|) |k#0@@57|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@1|) |k#0@@57|))
))) (forall ((|k#1@@2| T@U) ) (!  (=> (and (and (= (type |k#1@@2|) BoxType) ($IsBox |k#1@@2| Maps._default.MapDisjointUnion$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@1|) |k#1@@2|))) (= (MapType0Select (|Map#Elements| |mapb#0@@1|) |k#1@@2|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|)) |k#1@@2|)))
 :qid |Mapsidfy.132:18|
 :skolemid |5266|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|)) |k#1@@2|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@1|) |k#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@1|) |k#1@@2|))
))) ($Is (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|) (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5267|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@256 |mapa#0@@1| |mapb#0@@1|))
))))
(assert (forall ((Maps._default.MapDisjointUnion$U@@2 T@U) (Maps._default.MapDisjointUnion$T@@2 T@U) ($ly@@257 T@U) (|mapa#0@@2| T@U) (|mapb#0@@2| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@2) TyType) (= (type Maps._default.MapDisjointUnion$T@@2) TyType)) (= (type $ly@@257) LayerTypeType)) (= (type |mapa#0@@2|) (MapType BoxType BoxType))) (= (type |mapb#0@@2|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@2| (TMap Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2)) ($Is |mapb#0@@2| (TMap Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2)))) (= (|Maps.__default.MapDisjointUnion#requires| Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2 $ly@@257 |mapa#0@@2| |mapb#0@@2|) (|Set#Disjoint| (|Map#Domain| |mapa#0@@2|) (|Map#Domain| |mapb#0@@2|))))
 :qid |unknown.0:0|
 :skolemid |5268|
 :pattern ( (|Maps.__default.MapDisjointUnion#requires| Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2 $ly@@257 |mapa#0@@2| |mapb#0@@2|))
)))
(assert (forall ((arg0@@546 T@U) (arg1@@259 T@U) (arg2@@145 T@U) ) (! (= (type (|lambda#233| arg0@@546 arg1@@259 arg2@@145)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#233|
 :pattern ( (|lambda#233| arg0@@546 arg1@@259 arg2@@145))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@3 T@U) (Maps._default.MapDisjointUnion$T@@3 T@U) ($ly@@258 T@U) (|mapa#0@@3| T@U) (|mapb#0@@3| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@3) TyType) (= (type Maps._default.MapDisjointUnion$T@@3) TyType)) (= (type $ly@@258) LayerTypeType)) (= (type |mapa#0@@3|) (MapType BoxType BoxType))) (= (type |mapb#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 |mapa#0@@3| |mapb#0@@3|) (and (and ($Is |mapa#0@@3| (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3)) ($Is |mapb#0@@3| (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3))) (|Set#Disjoint| (|Map#Domain| |mapa#0@@3|) (|Map#Domain| |mapb#0@@3|))))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 ($LS $ly@@258) |mapa#0@@3| |mapb#0@@3|) (|Map#Glue| (|lambda#155| Maps._default.MapDisjointUnion$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@3|) (|Map#Domain| |mapb#0@@3|))) (|lambda#233| (|Map#Domain| |mapa#0@@3|) (|Map#Elements| |mapa#0@@3|) (|Map#Elements| |mapb#0@@3|)) (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5269|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 ($LS $ly@@258) |mapa#0@@3| |mapb#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@4 T@U) (Maps._default.MapDisjointUnion$T@@4 T@U) ($ly@@259 T@U) (|mapa#0@@4| T@U) (|mapb#0@@4| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@4) TyType) (= (type Maps._default.MapDisjointUnion$T@@4) TyType)) (= (type $ly@@259) LayerTypeType)) (= (type |mapa#0@@4|) (MapType BoxType BoxType))) (= (type |mapb#0@@4|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)) (and (and ($Is |mapa#0@@4| (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4)) ($Is |mapb#0@@4| (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4))) (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@4|)) (|Map#Domain| (Lit |mapb#0@@4|)))))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 ($LS $ly@@259) (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)) (|Map#Glue| (|lambda#155| Maps._default.MapDisjointUnion$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@4|)) (|Map#Domain| (Lit |mapb#0@@4|)))) (|lambda#233| (|Map#Domain| |mapa#0@@4|) (|Map#Elements| (Lit |mapa#0@@4|)) (|Map#Elements| (Lit |mapb#0@@4|))) (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5270|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 ($LS $ly@@259) (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)))
))))
(assert (forall ((arg0@@547 T@U) (arg1@@260 T@U) (arg2@@146 T@U) (arg3@@86 T@U) (arg4@@50 T@U) ) (! (= (type (Maps.__default.MapUnionPreferA arg0@@547 arg1@@260 arg2@@146 arg3@@86 arg4@@50)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnionPreferA|
 :pattern ( (Maps.__default.MapUnionPreferA arg0@@547 arg1@@260 arg2@@146 arg3@@86 arg4@@50))
)))
(assert (forall ((Maps._default.MapUnionPreferA$U T@U) (Maps._default.MapUnionPreferA$T T@U) ($ly@@260 T@U) (|mapa#0@@5| T@U) (|mapb#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferA$U) TyType) (= (type Maps._default.MapUnionPreferA$T) TyType)) (= (type $ly@@260) LayerTypeType)) (= (type |mapa#0@@5|) (MapType BoxType BoxType))) (= (type |mapb#0@@5|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T ($LS $ly@@260) |mapa#0@@5| |mapb#0@@5|) (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T $ly@@260 |mapa#0@@5| |mapb#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |5271|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T ($LS $ly@@260) |mapa#0@@5| |mapb#0@@5|))
)))
(assert (forall ((Maps._default.MapUnionPreferA$U@@0 T@U) (Maps._default.MapUnionPreferA$T@@0 T@U) ($ly@@261 T@U) (|mapa#0@@6| T@U) (|mapb#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@0) TyType) (= (type Maps._default.MapUnionPreferA$T@@0) TyType)) (= (type $ly@@261) LayerTypeType)) (= (type |mapa#0@@6|) (MapType BoxType BoxType))) (= (type |mapb#0@@6|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 $ly@@261 |mapa#0@@6| |mapb#0@@6|) (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 $LZ |mapa#0@@6| |mapb#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |5272|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 (AsFuelBottom $ly@@261) |mapa#0@@6| |mapb#0@@6|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@1 T@U) (Maps._default.MapUnionPreferA$T@@1 T@U) ($ly@@262 T@U) (|mapa#0@@7| T@U) (|mapb#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@1) TyType) (= (type Maps._default.MapUnionPreferA$T@@1) TyType)) (= (type $ly@@262) LayerTypeType)) (= (type |mapa#0@@7|) (MapType BoxType BoxType))) (= (type |mapb#0@@7|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 |mapa#0@@7| |mapb#0@@7|) (and ($Is |mapa#0@@7| (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1)) ($Is |mapb#0@@7| (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) (|Set#Union| (|Map#Domain| |mapa#0@@7|) (|Map#Domain| |mapb#0@@7|))) (forall ((|k#0@@58| T@U) ) (!  (=> (and (and (= (type |k#0@@58|) BoxType) ($IsBox |k#0@@58| Maps._default.MapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#0@@58|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#0@@58|) (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#0@@58|)))
 :qid |Mapsidfy.141:20|
 :skolemid |5273|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#0@@58|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#0@@58|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#0@@58|))
))) (forall ((|k#1@@3| T@U) ) (!  (=> (and (and (= (type |k#1@@3|) BoxType) ($IsBox |k#1@@3| Maps._default.MapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|) (|Map#Domain| |mapa#0@@7|)) |k#1@@3|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#1@@3|) (MapType0Select (|Map#Elements| |mapb#0@@7|) |k#1@@3|)))
 :qid |Mapsidfy.142:20|
 :skolemid |5274|
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@7|) |k#1@@3|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#1@@3|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|) (|Map#Domain| |mapa#0@@7|)) |k#1@@3|))
))) (forall ((|k#2| T@U) ) (!  (=> (and (and (= (type |k#2|) BoxType) ($IsBox |k#2| Maps._default.MapUnionPreferA$U@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#2|)) (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@7|) |k#2|))))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#2|) (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#2|)))
 :qid |Mapsidfy.143:20|
 :skolemid |5275|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#2|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|)) |k#2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@7|) |k#2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#2|))
))) ($Is (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|) (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5276|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@262 |mapa#0@@7| |mapb#0@@7|))
))))
(assert (forall ((Maps._default.MapUnionPreferA$U@@2 T@U) (Maps._default.MapUnionPreferA$T@@2 T@U) ($ly@@263 T@U) (|mapa#0@@8| T@U) (|mapb#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@2) TyType) (= (type Maps._default.MapUnionPreferA$T@@2) TyType)) (= (type $ly@@263) LayerTypeType)) (= (type |mapa#0@@8|) (MapType BoxType BoxType))) (= (type |mapb#0@@8|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@8| (TMap Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2)) ($Is |mapb#0@@8| (TMap Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2)))) (= (|Maps.__default.MapUnionPreferA#requires| Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2 $ly@@263 |mapa#0@@8| |mapb#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |5277|
 :pattern ( (|Maps.__default.MapUnionPreferA#requires| Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2 $ly@@263 |mapa#0@@8| |mapb#0@@8|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@3 T@U) (Maps._default.MapUnionPreferA$T@@3 T@U) ($ly@@264 T@U) (|mapa#0@@9| T@U) (|mapb#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@3) TyType) (= (type Maps._default.MapUnionPreferA$T@@3) TyType)) (= (type $ly@@264) LayerTypeType)) (= (type |mapa#0@@9|) (MapType BoxType BoxType))) (= (type |mapb#0@@9|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 |mapa#0@@9| |mapb#0@@9|) (and ($Is |mapa#0@@9| (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3)) ($Is |mapb#0@@9| (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3))))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 ($LS $ly@@264) |mapa#0@@9| |mapb#0@@9|) (|Map#Glue| (|lambda#155| Maps._default.MapUnionPreferA$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@9|) (|Map#Domain| |mapb#0@@9|))) (|lambda#233| (|Map#Domain| |mapa#0@@9|) (|Map#Elements| |mapa#0@@9|) (|Map#Elements| |mapb#0@@9|)) (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5278|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 ($LS $ly@@264) |mapa#0@@9| |mapb#0@@9|))
))))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@4 T@U) (Maps._default.MapUnionPreferA$T@@4 T@U) ($ly@@265 T@U) (|mapa#0@@10| T@U) (|mapb#0@@10| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@4) TyType) (= (type Maps._default.MapUnionPreferA$T@@4) TyType)) (= (type $ly@@265) LayerTypeType)) (= (type |mapa#0@@10|) (MapType BoxType BoxType))) (= (type |mapb#0@@10|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)) (and ($Is |mapa#0@@10| (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4)) ($Is |mapb#0@@10| (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4))))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 ($LS $ly@@265) (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)) (|Map#Glue| (|lambda#155| Maps._default.MapUnionPreferA$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@10|)) (|Map#Domain| (Lit |mapb#0@@10|)))) (|lambda#233| (|Map#Domain| |mapa#0@@10|) (|Map#Elements| (Lit |mapa#0@@10|)) (|Map#Elements| (Lit |mapb#0@@10|))) (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5279|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 ($LS $ly@@265) (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)))
))))
(assert (forall ((arg0@@548 T@U) (arg1@@261 T@U) (arg2@@147 T@U) (arg3@@87 T@U) (arg4@@51 T@U) ) (! (= (type (Maps.__default.MapUnionPreferB arg0@@548 arg1@@261 arg2@@147 arg3@@87 arg4@@51)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnionPreferB|
 :pattern ( (Maps.__default.MapUnionPreferB arg0@@548 arg1@@261 arg2@@147 arg3@@87 arg4@@51))
)))
(assert (forall ((Maps._default.MapUnionPreferB$U T@U) (Maps._default.MapUnionPreferB$T T@U) ($ly@@266 T@U) (|mapa#0@@11| T@U) (|mapb#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferB$U) TyType) (= (type Maps._default.MapUnionPreferB$T) TyType)) (= (type $ly@@266) LayerTypeType)) (= (type |mapa#0@@11|) (MapType BoxType BoxType))) (= (type |mapb#0@@11|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T ($LS $ly@@266) |mapa#0@@11| |mapb#0@@11|) (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T $ly@@266 |mapa#0@@11| |mapb#0@@11|)))
 :qid |unknown.0:0|
 :skolemid |5280|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T ($LS $ly@@266) |mapa#0@@11| |mapb#0@@11|))
)))
(assert (forall ((Maps._default.MapUnionPreferB$U@@0 T@U) (Maps._default.MapUnionPreferB$T@@0 T@U) ($ly@@267 T@U) (|mapa#0@@12| T@U) (|mapb#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@0) TyType) (= (type Maps._default.MapUnionPreferB$T@@0) TyType)) (= (type $ly@@267) LayerTypeType)) (= (type |mapa#0@@12|) (MapType BoxType BoxType))) (= (type |mapb#0@@12|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 $ly@@267 |mapa#0@@12| |mapb#0@@12|) (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 $LZ |mapa#0@@12| |mapb#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |5281|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 (AsFuelBottom $ly@@267) |mapa#0@@12| |mapb#0@@12|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@1 T@U) (Maps._default.MapUnionPreferB$T@@1 T@U) ($ly@@268 T@U) (|mapa#0@@13| T@U) (|mapb#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@1) TyType) (= (type Maps._default.MapUnionPreferB$T@@1) TyType)) (= (type $ly@@268) LayerTypeType)) (= (type |mapa#0@@13|) (MapType BoxType BoxType))) (= (type |mapb#0@@13|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 |mapa#0@@13| |mapb#0@@13|) (and ($Is |mapa#0@@13| (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1)) ($Is |mapb#0@@13| (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) (|Set#Union| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|))) (forall ((|k#0@@59| T@U) ) (!  (=> (and (and (= (type |k#0@@59|) BoxType) ($IsBox |k#0@@59| Maps._default.MapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#0@@59|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#0@@59|) (MapType0Select (|Map#Elements| |mapb#0@@13|) |k#0@@59|)))
 :qid |Mapsidfy.150:20|
 :skolemid |5282|
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@13|) |k#0@@59|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#0@@59|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#0@@59|))
))) (forall ((|k#1@@4| T@U) ) (!  (=> (and (and (= (type |k#1@@4|) BoxType) ($IsBox |k#1@@4| Maps._default.MapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|)) |k#1@@4|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#1@@4|) (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#1@@4|)))
 :qid |Mapsidfy.151:20|
 :skolemid |5283|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#1@@4|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#1@@4|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|)) |k#1@@4|))
))) (forall ((|k#2@@0| T@U) ) (!  (=> (and (and (= (type |k#2@@0|) BoxType) ($IsBox |k#2@@0| Maps._default.MapUnionPreferB$U@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@13|) |k#2@@0|)) (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#2@@0|))))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#2@@0|) (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#2@@0|)))
 :qid |Mapsidfy.152:20|
 :skolemid |5284|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|)) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@13|) |k#2@@0|))
))) ($Is (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|) (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5285|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@268 |mapa#0@@13| |mapb#0@@13|))
))))
(assert (forall ((Maps._default.MapUnionPreferB$U@@2 T@U) (Maps._default.MapUnionPreferB$T@@2 T@U) ($ly@@269 T@U) (|mapa#0@@14| T@U) (|mapb#0@@14| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@2) TyType) (= (type Maps._default.MapUnionPreferB$T@@2) TyType)) (= (type $ly@@269) LayerTypeType)) (= (type |mapa#0@@14|) (MapType BoxType BoxType))) (= (type |mapb#0@@14|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@14| (TMap Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2)) ($Is |mapb#0@@14| (TMap Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2)))) (= (|Maps.__default.MapUnionPreferB#requires| Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2 $ly@@269 |mapa#0@@14| |mapb#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |5286|
 :pattern ( (|Maps.__default.MapUnionPreferB#requires| Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2 $ly@@269 |mapa#0@@14| |mapb#0@@14|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@3 T@U) (Maps._default.MapUnionPreferB$T@@3 T@U) ($ly@@270 T@U) (|mapa#0@@15| T@U) (|mapb#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@3) TyType) (= (type Maps._default.MapUnionPreferB$T@@3) TyType)) (= (type $ly@@270) LayerTypeType)) (= (type |mapa#0@@15|) (MapType BoxType BoxType))) (= (type |mapb#0@@15|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 |mapa#0@@15| |mapb#0@@15|) (and ($Is |mapa#0@@15| (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3)) ($Is |mapb#0@@15| (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3))))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 ($LS $ly@@270) |mapa#0@@15| |mapb#0@@15|) (|Map#Glue| (|lambda#155| Maps._default.MapUnionPreferB$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@15|) (|Map#Domain| |mapb#0@@15|))) (|lambda#233| (|Map#Domain| |mapb#0@@15|) (|Map#Elements| |mapb#0@@15|) (|Map#Elements| |mapa#0@@15|)) (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5287|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 ($LS $ly@@270) |mapa#0@@15| |mapb#0@@15|))
))))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@4 T@U) (Maps._default.MapUnionPreferB$T@@4 T@U) ($ly@@271 T@U) (|mapa#0@@16| T@U) (|mapb#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@4) TyType) (= (type Maps._default.MapUnionPreferB$T@@4) TyType)) (= (type $ly@@271) LayerTypeType)) (= (type |mapa#0@@16|) (MapType BoxType BoxType))) (= (type |mapb#0@@16|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)) (and ($Is |mapa#0@@16| (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4)) ($Is |mapb#0@@16| (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4))))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 ($LS $ly@@271) (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)) (|Map#Glue| (|lambda#155| Maps._default.MapUnionPreferB$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@16|)) (|Map#Domain| (Lit |mapb#0@@16|)))) (|lambda#233| (|Map#Domain| |mapb#0@@16|) (|Map#Elements| (Lit |mapb#0@@16|)) (|Map#Elements| (Lit |mapa#0@@16|))) (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5288|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 ($LS $ly@@271) (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)))
))))
(assert (forall ((arg0@@549 T@U) (arg1@@262 T@U) (arg2@@148 T@U) (arg3@@88 T@U) (arg4@@52 T@U) ) (! (= (type (Maps.__default.MapUnion arg0@@549 arg1@@262 arg2@@148 arg3@@88 arg4@@52)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnion|
 :pattern ( (Maps.__default.MapUnion arg0@@549 arg1@@262 arg2@@148 arg3@@88 arg4@@52))
)))
(assert (forall ((Maps._default.MapUnion$U T@U) (Maps._default.MapUnion$T T@U) ($ly@@272 T@U) (|mapa#0@@17| T@U) (|mapb#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnion$U) TyType) (= (type Maps._default.MapUnion$T) TyType)) (= (type $ly@@272) LayerTypeType)) (= (type |mapa#0@@17|) (MapType BoxType BoxType))) (= (type |mapb#0@@17|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T ($LS $ly@@272) |mapa#0@@17| |mapb#0@@17|) (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T $ly@@272 |mapa#0@@17| |mapb#0@@17|)))
 :qid |unknown.0:0|
 :skolemid |5289|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T ($LS $ly@@272) |mapa#0@@17| |mapb#0@@17|))
)))
(assert (forall ((Maps._default.MapUnion$U@@0 T@U) (Maps._default.MapUnion$T@@0 T@U) ($ly@@273 T@U) (|mapa#0@@18| T@U) (|mapb#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnion$U@@0) TyType) (= (type Maps._default.MapUnion$T@@0) TyType)) (= (type $ly@@273) LayerTypeType)) (= (type |mapa#0@@18|) (MapType BoxType BoxType))) (= (type |mapb#0@@18|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 $ly@@273 |mapa#0@@18| |mapb#0@@18|) (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 $LZ |mapa#0@@18| |mapb#0@@18|)))
 :qid |unknown.0:0|
 :skolemid |5290|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 (AsFuelBottom $ly@@273) |mapa#0@@18| |mapb#0@@18|))
)))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@1 T@U) (Maps._default.MapUnion$T@@1 T@U) ($ly@@274 T@U) (|mapa#0@@19| T@U) (|mapb#0@@19| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@1) TyType) (= (type Maps._default.MapUnion$T@@1) TyType)) (= (type $ly@@274) LayerTypeType)) (= (type |mapa#0@@19|) (MapType BoxType BoxType))) (= (type |mapb#0@@19|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapa#0@@19| |mapb#0@@19|) (and ($Is |mapa#0@@19| (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1)) ($Is |mapb#0@@19| (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1))))) (and (and (and (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) (|Set#Union| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|))) (forall ((|k#0@@60| T@U) ) (!  (=> (and (and (= (type |k#0@@60|) BoxType) ($IsBox |k#0@@60| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#0@@60|))) (= (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#0@@60|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#0@@60|)))
 :qid |Mapsidfy.161:18|
 :skolemid |5291|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#0@@60|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#0@@60|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#0@@60|))
))) (forall ((|k#1@@5| T@U) ) (!  (=> (and (and (= (type |k#1@@5|) BoxType) ($IsBox |k#1@@5| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|) (|Map#Domain| |mapa#0@@19|)) |k#1@@5|))) (= (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#1@@5|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#1@@5|)))
 :qid |Mapsidfy.162:18|
 :skolemid |5292|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#1@@5|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#1@@5|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|) (|Map#Domain| |mapa#0@@19|)) |k#1@@5|))
))) (forall ((|k#2@@1| T@U) ) (!  (=> (and (and (= (type |k#2@@1|) BoxType) ($IsBox |k#2@@1| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Intersection| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#2@@1|))) (or (= (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#2@@1|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|)) (= (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#2@@1|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|))))
 :qid |Mapsidfy.163:18|
 :skolemid |5293|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#2@@1|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#2@@1|))
 :pattern ( (MapType0Select (|Set#Intersection| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#2@@1|))
))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (|Set#Equal| (|Map#Values| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)) (|Set#Union| (|Map#Values| |mapa#0@@19|) (|Map#Values| |mapb#0@@19|))))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (Maps.__default.IsSubMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapa#0@@19| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (Maps.__default.IsSubMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapb#0@@19| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|)))) ($Is (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|) (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5294|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@274 |mapa#0@@19| |mapb#0@@19|))
))))
(assert (forall ((Maps._default.MapUnion$U@@2 T@U) (Maps._default.MapUnion$T@@2 T@U) ($ly@@275 T@U) (|mapa#0@@20| T@U) (|mapb#0@@20| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@2) TyType) (= (type Maps._default.MapUnion$T@@2) TyType)) (= (type $ly@@275) LayerTypeType)) (= (type |mapa#0@@20|) (MapType BoxType BoxType))) (= (type |mapb#0@@20|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@20| (TMap Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2)) ($Is |mapb#0@@20| (TMap Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2)))) (= (|Maps.__default.MapUnion#requires| Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2 $ly@@275 |mapa#0@@20| |mapb#0@@20|) true))
 :qid |unknown.0:0|
 :skolemid |5295|
 :pattern ( (|Maps.__default.MapUnion#requires| Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2 $ly@@275 |mapa#0@@20| |mapb#0@@20|))
)))
(assert (= (type StartFuel_Maps._default.MapUnionPreferA) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@3 T@U) (Maps._default.MapUnion$T@@3 T@U) ($ly@@276 T@U) (|mapa#0@@21| T@U) (|mapb#0@@21| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@3) TyType) (= (type Maps._default.MapUnion$T@@3) TyType)) (= (type $ly@@276) LayerTypeType)) (= (type |mapa#0@@21|) (MapType BoxType BoxType))) (= (type |mapb#0@@21|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 |mapa#0@@21| |mapb#0@@21|) (and ($Is |mapa#0@@21| (TMap Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3)) ($Is |mapb#0@@21| (TMap Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3))))) (and (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 |mapa#0@@21| |mapb#0@@21|) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 ($LS $ly@@276) |mapa#0@@21| |mapb#0@@21|) (Maps.__default.MapUnionPreferA Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 StartFuel_Maps._default.MapUnionPreferA |mapa#0@@21| |mapb#0@@21|))))
 :qid |unknown.0:0|
 :skolemid |5296|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 ($LS $ly@@276) |mapa#0@@21| |mapb#0@@21|))
))))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@4 T@U) (Maps._default.MapUnion$T@@4 T@U) ($ly@@277 T@U) (|mapa#0@@22| T@U) (|mapb#0@@22| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@4) TyType) (= (type Maps._default.MapUnion$T@@4) TyType)) (= (type $ly@@277) LayerTypeType)) (= (type |mapa#0@@22|) (MapType BoxType BoxType))) (= (type |mapb#0@@22|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (and ($Is |mapa#0@@22| (TMap Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4)) ($Is |mapb#0@@22| (TMap Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4))))) (and (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 ($LS $ly@@277) (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (Maps.__default.MapUnionPreferA Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 StartFuel_Maps._default.MapUnionPreferA (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5297|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 ($LS $ly@@277) (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)))
))))
(assert (forall ((arg0@@550 T@U) (arg1@@263 T@U) (arg2@@149 T@U) (arg3@@89 T@U) (arg4@@53 T@U) ) (! (= (type (Maps.__default.IMapUnionPreferA arg0@@550 arg1@@263 arg2@@149 arg3@@89 arg4@@53)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnionPreferA|
 :pattern ( (Maps.__default.IMapUnionPreferA arg0@@550 arg1@@263 arg2@@149 arg3@@89 arg4@@53))
)))
(assert (forall ((Maps._default.IMapUnionPreferA$U T@U) (Maps._default.IMapUnionPreferA$T T@U) ($ly@@278 T@U) (|mapa#0@@23| T@U) (|mapb#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U) TyType) (= (type Maps._default.IMapUnionPreferA$T) TyType)) (= (type $ly@@278) LayerTypeType)) (= (type |mapa#0@@23|) (IMapType BoxType BoxType))) (= (type |mapb#0@@23|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T ($LS $ly@@278) |mapa#0@@23| |mapb#0@@23|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T $ly@@278 |mapa#0@@23| |mapb#0@@23|)))
 :qid |unknown.0:0|
 :skolemid |5298|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T ($LS $ly@@278) |mapa#0@@23| |mapb#0@@23|))
)))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@0 T@U) (Maps._default.IMapUnionPreferA$T@@0 T@U) ($ly@@279 T@U) (|mapa#0@@24| T@U) (|mapb#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@0) TyType) (= (type Maps._default.IMapUnionPreferA$T@@0) TyType)) (= (type $ly@@279) LayerTypeType)) (= (type |mapa#0@@24|) (IMapType BoxType BoxType))) (= (type |mapb#0@@24|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 $ly@@279 |mapa#0@@24| |mapb#0@@24|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 $LZ |mapa#0@@24| |mapb#0@@24|)))
 :qid |unknown.0:0|
 :skolemid |5299|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 (AsFuelBottom $ly@@279) |mapa#0@@24| |mapb#0@@24|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@1 T@U) (Maps._default.IMapUnionPreferA$T@@1 T@U) ($ly@@280 T@U) (|mapa#0@@25| T@U) (|mapb#0@@25| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@1) TyType) (= (type Maps._default.IMapUnionPreferA$T@@1) TyType)) (= (type $ly@@280) LayerTypeType)) (= (type |mapa#0@@25|) (IMapType BoxType BoxType))) (= (type |mapb#0@@25|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 |mapa#0@@25| |mapb#0@@25|) (and ($Is |mapa#0@@25| (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1)) ($Is |mapb#0@@25| (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@25|) (|IMap#Domain| |mapb#0@@25|))) (forall ((|k#0@@61| T@U) ) (!  (=> (and (and (= (type |k#0@@61|) BoxType) ($IsBox |k#0@@61| Maps._default.IMapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#0@@61|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#0@@61|) (MapType0Select (|IMap#Elements| |mapa#0@@25|) |k#0@@61|)))
 :qid |Mapsidfy.173:20|
 :skolemid |5300|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@25|) |k#0@@61|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#0@@61|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#0@@61|))
))) (forall ((|k#1@@6| T@U) ) (!  (=> (and (and (= (type |k#1@@6|) BoxType) ($IsBox |k#1@@6| Maps._default.IMapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@25|) (|IMap#Domain| |mapa#0@@25|)) |k#1@@6|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#1@@6|) (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#1@@6|)))
 :qid |Mapsidfy.174:20|
 :skolemid |5301|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#1@@6|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#1@@6|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@25|) (|IMap#Domain| |mapa#0@@25|)) |k#1@@6|))
))) (forall ((|k#2@@2| T@U) ) (!  (=> (and (and (= (type |k#2@@2|) BoxType) ($IsBox |k#2@@2| Maps._default.IMapUnionPreferA$U@@1)) (and (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@25|) |k#2@@2|)) (not (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#2@@2|))))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#2@@2|) (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#2@@2|)))
 :qid |Mapsidfy.175:20|
 :skolemid |5302|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|)) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@25|) |k#2@@2|))
))) ($Is (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|) (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5303|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@280 |mapa#0@@25| |mapb#0@@25|))
))))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@2 T@U) (Maps._default.IMapUnionPreferA$T@@2 T@U) ($ly@@281 T@U) (|mapa#0@@26| T@U) (|mapb#0@@26| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@2) TyType) (= (type Maps._default.IMapUnionPreferA$T@@2) TyType)) (= (type $ly@@281) LayerTypeType)) (= (type |mapa#0@@26|) (IMapType BoxType BoxType))) (= (type |mapb#0@@26|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@26| (TIMap Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2)) ($Is |mapb#0@@26| (TIMap Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2)))) (= (|Maps.__default.IMapUnionPreferA#requires| Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2 $ly@@281 |mapa#0@@26| |mapb#0@@26|) true))
 :qid |unknown.0:0|
 :skolemid |5304|
 :pattern ( (|Maps.__default.IMapUnionPreferA#requires| Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2 $ly@@281 |mapa#0@@26| |mapb#0@@26|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@3 T@U) (Maps._default.IMapUnionPreferA$T@@3 T@U) ($ly@@282 T@U) (|mapa#0@@27| T@U) (|mapb#0@@27| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@3) TyType) (= (type Maps._default.IMapUnionPreferA$T@@3) TyType)) (= (type $ly@@282) LayerTypeType)) (= (type |mapa#0@@27|) (IMapType BoxType BoxType))) (= (type |mapb#0@@27|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 |mapa#0@@27| |mapb#0@@27|) (and ($Is |mapa#0@@27| (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3)) ($Is |mapb#0@@27| (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3))))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 ($LS $ly@@282) |mapa#0@@27| |mapb#0@@27|) (|IMap#Glue| (|lambda#155| Maps._default.IMapUnionPreferA$U@@3 (|ISet#Union| (|IMap#Domain| |mapa#0@@27|) (|IMap#Domain| |mapb#0@@27|))) (|lambda#233| (|IMap#Domain| |mapa#0@@27|) (|IMap#Elements| |mapa#0@@27|) (|IMap#Elements| |mapb#0@@27|)) (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5305|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 ($LS $ly@@282) |mapa#0@@27| |mapb#0@@27|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@4 T@U) (Maps._default.IMapUnionPreferA$T@@4 T@U) ($ly@@283 T@U) (|mapa#0@@28| T@U) (|mapb#0@@28| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@4) TyType) (= (type Maps._default.IMapUnionPreferA$T@@4) TyType)) (= (type $ly@@283) LayerTypeType)) (= (type |mapa#0@@28|) (IMapType BoxType BoxType))) (= (type |mapb#0@@28|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)) (and ($Is |mapa#0@@28| (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4)) ($Is |mapb#0@@28| (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4))))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 ($LS $ly@@283) (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)) (|IMap#Glue| (|lambda#155| Maps._default.IMapUnionPreferA$U@@4 (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@28|)) (|IMap#Domain| (Lit |mapb#0@@28|)))) (|lambda#233| (|IMap#Domain| |mapa#0@@28|) (|IMap#Elements| (Lit |mapa#0@@28|)) (|IMap#Elements| (Lit |mapb#0@@28|))) (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5306|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 ($LS $ly@@283) (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)))
))))
(assert (forall ((arg0@@551 T@U) (arg1@@264 T@U) (arg2@@150 T@U) (arg3@@90 T@U) (arg4@@54 T@U) ) (! (= (type (Maps.__default.IMapUnionPreferB arg0@@551 arg1@@264 arg2@@150 arg3@@90 arg4@@54)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnionPreferB|
 :pattern ( (Maps.__default.IMapUnionPreferB arg0@@551 arg1@@264 arg2@@150 arg3@@90 arg4@@54))
)))
(assert (forall ((Maps._default.IMapUnionPreferB$U T@U) (Maps._default.IMapUnionPreferB$T T@U) ($ly@@284 T@U) (|mapa#0@@29| T@U) (|mapb#0@@29| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U) TyType) (= (type Maps._default.IMapUnionPreferB$T) TyType)) (= (type $ly@@284) LayerTypeType)) (= (type |mapa#0@@29|) (IMapType BoxType BoxType))) (= (type |mapb#0@@29|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T ($LS $ly@@284) |mapa#0@@29| |mapb#0@@29|) (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T $ly@@284 |mapa#0@@29| |mapb#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |5307|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T ($LS $ly@@284) |mapa#0@@29| |mapb#0@@29|))
)))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@0 T@U) (Maps._default.IMapUnionPreferB$T@@0 T@U) ($ly@@285 T@U) (|mapa#0@@30| T@U) (|mapb#0@@30| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@0) TyType) (= (type Maps._default.IMapUnionPreferB$T@@0) TyType)) (= (type $ly@@285) LayerTypeType)) (= (type |mapa#0@@30|) (IMapType BoxType BoxType))) (= (type |mapb#0@@30|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 $ly@@285 |mapa#0@@30| |mapb#0@@30|) (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 $LZ |mapa#0@@30| |mapb#0@@30|)))
 :qid |unknown.0:0|
 :skolemid |5308|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 (AsFuelBottom $ly@@285) |mapa#0@@30| |mapb#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@1 T@U) (Maps._default.IMapUnionPreferB$T@@1 T@U) ($ly@@286 T@U) (|mapa#0@@31| T@U) (|mapb#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@1) TyType) (= (type Maps._default.IMapUnionPreferB$T@@1) TyType)) (= (type $ly@@286) LayerTypeType)) (= (type |mapa#0@@31|) (IMapType BoxType BoxType))) (= (type |mapb#0@@31|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 |mapa#0@@31| |mapb#0@@31|) (and ($Is |mapa#0@@31| (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1)) ($Is |mapb#0@@31| (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|))) (forall ((|k#0@@62| T@U) ) (!  (=> (and (and (= (type |k#0@@62|) BoxType) ($IsBox |k#0@@62| Maps._default.IMapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#0@@62|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#0@@62|) (MapType0Select (|IMap#Elements| |mapb#0@@31|) |k#0@@62|)))
 :qid |Mapsidfy.182:20|
 :skolemid |5309|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@31|) |k#0@@62|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#0@@62|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#0@@62|))
))) (forall ((|k#1@@7| T@U) ) (!  (=> (and (and (= (type |k#1@@7|) BoxType) ($IsBox |k#1@@7| Maps._default.IMapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|)) |k#1@@7|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#1@@7|) (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#1@@7|)))
 :qid |Mapsidfy.183:20|
 :skolemid |5310|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#1@@7|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#1@@7|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|)) |k#1@@7|))
))) (forall ((|k#2@@3| T@U) ) (!  (=> (and (and (= (type |k#2@@3|) BoxType) ($IsBox |k#2@@3| Maps._default.IMapUnionPreferB$U@@1)) (and (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@31|) |k#2@@3|)) (not (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#2@@3|))))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#2@@3|) (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#2@@3|)))
 :qid |Mapsidfy.184:20|
 :skolemid |5311|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|)) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@31|) |k#2@@3|))
))) ($Is (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|) (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5312|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@286 |mapa#0@@31| |mapb#0@@31|))
))))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@2 T@U) (Maps._default.IMapUnionPreferB$T@@2 T@U) ($ly@@287 T@U) (|mapa#0@@32| T@U) (|mapb#0@@32| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@2) TyType) (= (type Maps._default.IMapUnionPreferB$T@@2) TyType)) (= (type $ly@@287) LayerTypeType)) (= (type |mapa#0@@32|) (IMapType BoxType BoxType))) (= (type |mapb#0@@32|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@32| (TIMap Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2)) ($Is |mapb#0@@32| (TIMap Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2)))) (= (|Maps.__default.IMapUnionPreferB#requires| Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2 $ly@@287 |mapa#0@@32| |mapb#0@@32|) true))
 :qid |unknown.0:0|
 :skolemid |5313|
 :pattern ( (|Maps.__default.IMapUnionPreferB#requires| Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2 $ly@@287 |mapa#0@@32| |mapb#0@@32|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@3 T@U) (Maps._default.IMapUnionPreferB$T@@3 T@U) ($ly@@288 T@U) (|mapa#0@@33| T@U) (|mapb#0@@33| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@3) TyType) (= (type Maps._default.IMapUnionPreferB$T@@3) TyType)) (= (type $ly@@288) LayerTypeType)) (= (type |mapa#0@@33|) (IMapType BoxType BoxType))) (= (type |mapb#0@@33|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 |mapa#0@@33| |mapb#0@@33|) (and ($Is |mapa#0@@33| (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3)) ($Is |mapb#0@@33| (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3))))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 ($LS $ly@@288) |mapa#0@@33| |mapb#0@@33|) (|IMap#Glue| (|lambda#155| Maps._default.IMapUnionPreferB$U@@3 (|ISet#Union| (|IMap#Domain| |mapa#0@@33|) (|IMap#Domain| |mapb#0@@33|))) (|lambda#233| (|IMap#Domain| |mapb#0@@33|) (|IMap#Elements| |mapb#0@@33|) (|IMap#Elements| |mapa#0@@33|)) (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5314|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 ($LS $ly@@288) |mapa#0@@33| |mapb#0@@33|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@4 T@U) (Maps._default.IMapUnionPreferB$T@@4 T@U) ($ly@@289 T@U) (|mapa#0@@34| T@U) (|mapb#0@@34| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@4) TyType) (= (type Maps._default.IMapUnionPreferB$T@@4) TyType)) (= (type $ly@@289) LayerTypeType)) (= (type |mapa#0@@34|) (IMapType BoxType BoxType))) (= (type |mapb#0@@34|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)) (and ($Is |mapa#0@@34| (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4)) ($Is |mapb#0@@34| (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4))))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 ($LS $ly@@289) (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)) (|IMap#Glue| (|lambda#155| Maps._default.IMapUnionPreferB$U@@4 (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@34|)) (|IMap#Domain| (Lit |mapb#0@@34|)))) (|lambda#233| (|IMap#Domain| |mapb#0@@34|) (|IMap#Elements| (Lit |mapb#0@@34|)) (|IMap#Elements| (Lit |mapa#0@@34|))) (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5315|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 ($LS $ly@@289) (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)))
))))
(assert (forall ((arg0@@552 T@U) (arg1@@265 T@U) (arg2@@151 T@U) (arg3@@91 T@U) (arg4@@55 T@U) ) (! (= (type (Maps.__default.IMapUnion arg0@@552 arg1@@265 arg2@@151 arg3@@91 arg4@@55)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnion|
 :pattern ( (Maps.__default.IMapUnion arg0@@552 arg1@@265 arg2@@151 arg3@@91 arg4@@55))
)))
(assert (forall ((Maps._default.IMapUnion$U T@U) (Maps._default.IMapUnion$T T@U) ($ly@@290 T@U) (|mapa#0@@35| T@U) (|mapb#0@@35| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnion$U) TyType) (= (type Maps._default.IMapUnion$T) TyType)) (= (type $ly@@290) LayerTypeType)) (= (type |mapa#0@@35|) (IMapType BoxType BoxType))) (= (type |mapb#0@@35|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T ($LS $ly@@290) |mapa#0@@35| |mapb#0@@35|) (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T $ly@@290 |mapa#0@@35| |mapb#0@@35|)))
 :qid |unknown.0:0|
 :skolemid |5316|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T ($LS $ly@@290) |mapa#0@@35| |mapb#0@@35|))
)))
(assert (forall ((Maps._default.IMapUnion$U@@0 T@U) (Maps._default.IMapUnion$T@@0 T@U) ($ly@@291 T@U) (|mapa#0@@36| T@U) (|mapb#0@@36| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnion$U@@0) TyType) (= (type Maps._default.IMapUnion$T@@0) TyType)) (= (type $ly@@291) LayerTypeType)) (= (type |mapa#0@@36|) (IMapType BoxType BoxType))) (= (type |mapb#0@@36|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 $ly@@291 |mapa#0@@36| |mapb#0@@36|) (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 $LZ |mapa#0@@36| |mapb#0@@36|)))
 :qid |unknown.0:0|
 :skolemid |5317|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 (AsFuelBottom $ly@@291) |mapa#0@@36| |mapb#0@@36|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@1 T@U) (Maps._default.IMapUnion$T@@1 T@U) ($ly@@292 T@U) (|mapa#0@@37| T@U) (|mapb#0@@37| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@1) TyType) (= (type Maps._default.IMapUnion$T@@1) TyType)) (= (type $ly@@292) LayerTypeType)) (= (type |mapa#0@@37|) (IMapType BoxType BoxType))) (= (type |mapb#0@@37|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 |mapa#0@@37| |mapb#0@@37|) (and ($Is |mapa#0@@37| (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1)) ($Is |mapb#0@@37| (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|))) (forall ((|k#0@@63| T@U) ) (!  (=> (and (and (= (type |k#0@@63|) BoxType) ($IsBox |k#0@@63| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#0@@63|))) (= (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#0@@63|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#0@@63|)))
 :qid |Mapsidfy.193:18|
 :skolemid |5318|
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#0@@63|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#0@@63|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#0@@63|))
))) (forall ((|k#1@@8| T@U) ) (!  (=> (and (and (= (type |k#1@@8|) BoxType) ($IsBox |k#1@@8| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@37|) (|IMap#Domain| |mapa#0@@37|)) |k#1@@8|))) (= (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#1@@8|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#1@@8|)))
 :qid |Mapsidfy.194:18|
 :skolemid |5319|
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#1@@8|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#1@@8|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@37|) (|IMap#Domain| |mapa#0@@37|)) |k#1@@8|))
))) (forall ((|k#2@@4| T@U) ) (!  (=> (and (and (= (type |k#2@@4|) BoxType) ($IsBox |k#2@@4| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Intersection| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#2@@4|))) (or (= (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#2@@4|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|)) (= (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#2@@4|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|))))
 :qid |Mapsidfy.195:18|
 :skolemid |5320|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#2@@4|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#2@@4|))
 :pattern ( (MapType0Select (|ISet#Intersection| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#2@@4|))
))) ($Is (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|) (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5321|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@292 |mapa#0@@37| |mapb#0@@37|))
))))
(assert (forall ((Maps._default.IMapUnion$U@@2 T@U) (Maps._default.IMapUnion$T@@2 T@U) ($ly@@293 T@U) (|mapa#0@@38| T@U) (|mapb#0@@38| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@2) TyType) (= (type Maps._default.IMapUnion$T@@2) TyType)) (= (type $ly@@293) LayerTypeType)) (= (type |mapa#0@@38|) (IMapType BoxType BoxType))) (= (type |mapb#0@@38|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@38| (TIMap Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2)) ($Is |mapb#0@@38| (TIMap Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2)))) (= (|Maps.__default.IMapUnion#requires| Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2 $ly@@293 |mapa#0@@38| |mapb#0@@38|) true))
 :qid |unknown.0:0|
 :skolemid |5322|
 :pattern ( (|Maps.__default.IMapUnion#requires| Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2 $ly@@293 |mapa#0@@38| |mapb#0@@38|))
)))
(assert (= (type StartFuel_Maps._default.IMapUnionPreferA) LayerTypeType))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@3 T@U) (Maps._default.IMapUnion$T@@3 T@U) ($ly@@294 T@U) (|mapa#0@@39| T@U) (|mapb#0@@39| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@3) TyType) (= (type Maps._default.IMapUnion$T@@3) TyType)) (= (type $ly@@294) LayerTypeType)) (= (type |mapa#0@@39|) (IMapType BoxType BoxType))) (= (type |mapb#0@@39|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 |mapa#0@@39| |mapb#0@@39|) (and ($Is |mapa#0@@39| (TIMap Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3)) ($Is |mapb#0@@39| (TIMap Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3))))) (and (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 |mapa#0@@39| |mapb#0@@39|) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 ($LS $ly@@294) |mapa#0@@39| |mapb#0@@39|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 StartFuel_Maps._default.IMapUnionPreferA |mapa#0@@39| |mapb#0@@39|))))
 :qid |unknown.0:0|
 :skolemid |5323|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 ($LS $ly@@294) |mapa#0@@39| |mapb#0@@39|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@4 T@U) (Maps._default.IMapUnion$T@@4 T@U) ($ly@@295 T@U) (|mapa#0@@40| T@U) (|mapb#0@@40| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@4) TyType) (= (type Maps._default.IMapUnion$T@@4) TyType)) (= (type $ly@@295) LayerTypeType)) (= (type |mapa#0@@40|) (IMapType BoxType BoxType))) (= (type |mapb#0@@40|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (and ($Is |mapa#0@@40| (TIMap Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4)) ($Is |mapb#0@@40| (TIMap Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4))))) (and (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 ($LS $ly@@295) (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 StartFuel_Maps._default.IMapUnionPreferA (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5324|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 ($LS $ly@@295) (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)))
))))
(assert (forall ((arg0@@553 T@U) (arg1@@266 T@U) (arg2@@152 T@U) (arg3@@92 T@U) (arg4@@56 T@U) (arg5@@21 T@U) ) (! (= (type (Maps.__default.MapDisjointUnion3 arg0@@553 arg1@@266 arg2@@152 arg3@@92 arg4@@56 arg5@@21)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapDisjointUnion3|
 :pattern ( (Maps.__default.MapDisjointUnion3 arg0@@553 arg1@@266 arg2@@152 arg3@@92 arg4@@56 arg5@@21))
)))
(assert (forall ((Maps._default.MapDisjointUnion3$U T@U) (Maps._default.MapDisjointUnion3$T T@U) ($ly@@296 T@U) (|mapa#0@@41| T@U) (|mapb#0@@41| T@U) (|mapc#0| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U) TyType) (= (type Maps._default.MapDisjointUnion3$T) TyType)) (= (type $ly@@296) LayerTypeType)) (= (type |mapa#0@@41|) (MapType BoxType BoxType))) (= (type |mapb#0@@41|) (MapType BoxType BoxType))) (= (type |mapc#0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T ($LS $ly@@296) |mapa#0@@41| |mapb#0@@41| |mapc#0|) (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T $ly@@296 |mapa#0@@41| |mapb#0@@41| |mapc#0|)))
 :qid |unknown.0:0|
 :skolemid |5325|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T ($LS $ly@@296) |mapa#0@@41| |mapb#0@@41| |mapc#0|))
)))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@0 T@U) (Maps._default.MapDisjointUnion3$T@@0 T@U) ($ly@@297 T@U) (|mapa#0@@42| T@U) (|mapb#0@@42| T@U) (|mapc#0@@0| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@0) TyType) (= (type Maps._default.MapDisjointUnion3$T@@0) TyType)) (= (type $ly@@297) LayerTypeType)) (= (type |mapa#0@@42|) (MapType BoxType BoxType))) (= (type |mapb#0@@42|) (MapType BoxType BoxType))) (= (type |mapc#0@@0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 $ly@@297 |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|) (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 $LZ |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |5326|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 (AsFuelBottom $ly@@297) |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|))
)))
(assert (= (type StartFuel_Maps._default.MapDisjointUnion) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@1 T@U) (Maps._default.MapDisjointUnion3$T@@1 T@U) ($ly@@298 T@U) (|mapa#0@@43| T@U) (|mapb#0@@43| T@U) (|mapc#0@@1| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@1) TyType) (= (type Maps._default.MapDisjointUnion3$T@@1) TyType)) (= (type $ly@@298) LayerTypeType)) (= (type |mapa#0@@43|) (MapType BoxType BoxType))) (= (type |mapb#0@@43|) (MapType BoxType BoxType))) (= (type |mapc#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (and (and (and ($Is |mapa#0@@43| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1)) ($Is |mapb#0@@43| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))) ($Is |mapc#0@@1| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))) (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Map#Domain| |mapc#0@@1|)))))) (and (and (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Map#Domain| |mapc#0@@1|))) (=> (or (or (not (|Set#Equal| (|Map#Domain| |mapa#0@@43|) (|Set#Empty| BoxType))) (not (|Set#Equal| (|Map#Domain| |mapb#0@@43|) (|Set#Empty| BoxType)))) (not (|Set#Equal| (|Map#Domain| |mapc#0@@1|) (|Set#Empty| BoxType)))) (not (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) (|Set#Empty| BoxType))))) (forall ((|k#0@@64| T@U) ) (!  (=> (and (and (= (type |k#0@@64|) BoxType) ($IsBox |k#0@@64| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@43|) |k#0@@64|))) (= (MapType0Select (|Map#Elements| |mapa#0@@43|) |k#0@@64|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#0@@64|)))
 :qid |Mapsidfy.205:18|
 :skolemid |5327|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#0@@64|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@43|) |k#0@@64|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@43|) |k#0@@64|))
))) (forall ((|k#1@@9| T@U) ) (!  (=> (and (and (= (type |k#1@@9|) BoxType) ($IsBox |k#1@@9| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@43|) |k#1@@9|))) (= (MapType0Select (|Map#Elements| |mapb#0@@43|) |k#1@@9|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#1@@9|)))
 :qid |Mapsidfy.206:18|
 :skolemid |5328|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#1@@9|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@43|) |k#1@@9|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@43|) |k#1@@9|))
))) (forall ((|k#2@@5| T@U) ) (!  (=> (and (and (= (type |k#2@@5|) BoxType) ($IsBox |k#2@@5| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapc#0@@1|) |k#2@@5|))) (= (MapType0Select (|Map#Elements| |mapc#0@@1|) |k#2@@5|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#2@@5|)))
 :qid |Mapsidfy.207:18|
 :skolemid |5329|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#2@@5|))
 :pattern ( (MapType0Select (|Map#Elements| |mapc#0@@1|) |k#2@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |mapc#0@@1|) |k#2@@5|))
))) (and (|Map#Equal| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapb#0@@43| |mapc#0@@1|))) (|Map#Equal| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapb#0@@43| |mapc#0@@1|)) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| |mapb#0@@43|) |mapc#0@@1|)))) ($Is (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5330|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@298 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|))
))))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@2 T@U) (Maps._default.MapDisjointUnion3$T@@2 T@U) ($ly@@299 T@U) (|mapa#0@@44| T@U) (|mapb#0@@44| T@U) (|mapc#0@@2| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@2) TyType) (= (type Maps._default.MapDisjointUnion3$T@@2) TyType)) (= (type $ly@@299) LayerTypeType)) (= (type |mapa#0@@44|) (MapType BoxType BoxType))) (= (type |mapb#0@@44|) (MapType BoxType BoxType))) (= (type |mapc#0@@2|) (MapType BoxType BoxType))) (and (and ($Is |mapa#0@@44| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2)) ($Is |mapb#0@@44| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2))) ($Is |mapc#0@@2| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2)))) (= (|Maps.__default.MapDisjointUnion3#requires| Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2 $ly@@299 |mapa#0@@44| |mapb#0@@44| |mapc#0@@2|)  (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|)) (|Map#Domain| |mapc#0@@2|)))))
 :qid |unknown.0:0|
 :skolemid |5331|
 :pattern ( (|Maps.__default.MapDisjointUnion3#requires| Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2 $ly@@299 |mapa#0@@44| |mapb#0@@44| |mapc#0@@2|))
)))
(assert (forall ((arg0@@554 T@U) (arg1@@267 T@U) (arg2@@153 T@U) (arg3@@93 T@U) (arg4@@57 T@U) ) (! (= (type (|lambda#253| arg0@@554 arg1@@267 arg2@@153 arg3@@93 arg4@@57)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#253|
 :pattern ( (|lambda#253| arg0@@554 arg1@@267 arg2@@153 arg3@@93 arg4@@57))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@3 T@U) (Maps._default.MapDisjointUnion3$T@@3 T@U) ($ly@@300 T@U) (|mapa#0@@45| T@U) (|mapb#0@@45| T@U) (|mapc#0@@3| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@3) TyType) (= (type Maps._default.MapDisjointUnion3$T@@3) TyType)) (= (type $ly@@300) LayerTypeType)) (= (type |mapa#0@@45|) (MapType BoxType BoxType))) (= (type |mapb#0@@45|) (MapType BoxType BoxType))) (= (type |mapc#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|) (and (and (and ($Is |mapa#0@@45| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3)) ($Is |mapb#0@@45| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))) ($Is |mapc#0@@3| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))) (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Map#Domain| |mapc#0@@3|)))))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 ($LS $ly@@300) |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|) (|Map#Glue| (|lambda#155| Maps._default.MapDisjointUnion3$U@@3 (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Map#Domain| |mapc#0@@3|))) (|lambda#253| (|Map#Domain| |mapa#0@@45|) (|Map#Elements| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|) (|Map#Elements| |mapb#0@@45|) (|Map#Elements| |mapc#0@@3|)) (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))))
 :qid |unknown.0:0|
 :skolemid |5332|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 ($LS $ly@@300) |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@4 T@U) (Maps._default.MapDisjointUnion3$T@@4 T@U) ($ly@@301 T@U) (|mapa#0@@46| T@U) (|mapb#0@@46| T@U) (|mapc#0@@4| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@4) TyType) (= (type Maps._default.MapDisjointUnion3$T@@4) TyType)) (= (type $ly@@301) LayerTypeType)) (= (type |mapa#0@@46|) (MapType BoxType BoxType))) (= (type |mapb#0@@46|) (MapType BoxType BoxType))) (= (type |mapc#0@@4|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)) (and (and (and ($Is |mapa#0@@46| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4)) ($Is |mapb#0@@46| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))) ($Is |mapc#0@@4| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))) (and (and (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|)))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Map#Domain| (Lit |mapc#0@@4|))))))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 ($LS $ly@@301) (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)) (|Map#Glue| (|lambda#155| Maps._default.MapDisjointUnion3$U@@4 (|Set#Union| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Map#Domain| (Lit |mapc#0@@4|)))) (|lambda#253| (|Map#Domain| |mapa#0@@46|) (|Map#Elements| (Lit |mapa#0@@46|)) (|Map#Domain| |mapb#0@@46|) (|Map#Elements| (Lit |mapb#0@@46|)) (|Map#Elements| (Lit |mapc#0@@4|))) (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5333|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 ($LS $ly@@301) (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)))
))))
(assert (forall ((arg0@@555 T@U) (arg1@@268 T@U) (arg2@@154 T@U) ) (! (= (type (Maps.__default.MapToImap arg0@@555 arg1@@268 arg2@@154)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.MapToImap|
 :pattern ( (Maps.__default.MapToImap arg0@@555 arg1@@268 arg2@@154))
)))
(assert  (=> true (forall ((Maps._default.MapToImap$K T@U) (Maps._default.MapToImap$V T@U) (|m#0@@97| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K) TyType) (= (type Maps._default.MapToImap$V) TyType)) (= (type |m#0@@97|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|) ($Is |m#0@@97| (TMap Maps._default.MapToImap$K Maps._default.MapToImap$V)))) ($Is (Maps.__default.MapToImap Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|) (TIMap Maps._default.MapToImap$K Maps._default.MapToImap$V)))
 :qid |unknown.0:0|
 :skolemid |5334|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|))
))))
(assert (forall ((Maps._default.MapToImap$K@@0 T@U) (Maps._default.MapToImap$V@@0 T@U) (|m#0@@98| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@0) TyType) (= (type Maps._default.MapToImap$V@@0) TyType)) (= (type |m#0@@98|) (MapType BoxType BoxType))) ($Is |m#0@@98| (TMap Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0))) (= (|Maps.__default.MapToImap#requires| Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0 |m#0@@98|) true))
 :qid |unknown.0:0|
 :skolemid |5335|
 :pattern ( (|Maps.__default.MapToImap#requires| Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0 |m#0@@98|))
)))
(assert  (=> true (forall ((Maps._default.MapToImap$K@@1 T@U) (Maps._default.MapToImap$V@@1 T@U) (|m#0@@99| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@1) TyType) (= (type Maps._default.MapToImap$V@@1) TyType)) (= (type |m#0@@99|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|) ($Is |m#0@@99| (TMap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1)))) (= (Maps.__default.MapToImap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|) (|IMap#Glue| (|lambda#155| Maps._default.MapToImap$K@@1 (|Map#Domain| |m#0@@99|)) (|lambda#197| (|Map#Elements| |m#0@@99|)) (TIMap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1))))
 :qid |unknown.0:0|
 :skolemid |5336|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|))
))))
(assert  (=> true (forall ((Maps._default.MapToImap$K@@2 T@U) (Maps._default.MapToImap$V@@2 T@U) (|m#0@@100| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@2) TyType) (= (type Maps._default.MapToImap$V@@2) TyType)) (= (type |m#0@@100|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)) ($Is |m#0@@100| (TMap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2)))) (= (Maps.__default.MapToImap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)) (|IMap#Glue| (|lambda#155| Maps._default.MapToImap$K@@2 (|Map#Domain| |m#0@@100|)) (|lambda#197| (|Map#Elements| (Lit |m#0@@100|))) (TIMap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5337|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)))
))))
(assert (forall ((arg0@@556 T@U) (arg1@@269 T@U) (arg2@@155 T@U) (arg3@@94 T@U) ) (! (= (type (Maps.__default.MapLookupOption arg0@@556 arg1@@269 arg2@@155 arg3@@94)) DatatypeTypeType)
 :qid |funType:Maps.__default.MapLookupOption|
 :pattern ( (Maps.__default.MapLookupOption arg0@@556 arg1@@269 arg2@@155 arg3@@94))
)))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K T@U) (Maps._default.MapLookupOption$V T@U) (|m#0@@101| T@U) (|key#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K) TyType) (= (type Maps._default.MapLookupOption$V) TyType)) (= (type |m#0@@101|) (MapType BoxType BoxType))) (= (type |key#0@@9|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@9|) (and ($Is |m#0@@101| (TMap Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V)) ($IsBox |key#0@@9| Maps._default.MapLookupOption$K)))) ($Is (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@9|) (Tclass.Options.Option Maps._default.MapLookupOption$V)))
 :qid |unknown.0:0|
 :skolemid |5338|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@9|))
))))
(assert (forall ((Maps._default.MapLookupOption$K@@0 T@U) (Maps._default.MapLookupOption$V@@0 T@U) (|m#0@@102| T@U) (|key#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@0) TyType) (= (type Maps._default.MapLookupOption$V@@0) TyType)) (= (type |m#0@@102|) (MapType BoxType BoxType))) (= (type |key#0@@10|) BoxType)) (and ($Is |m#0@@102| (TMap Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0)) ($IsBox |key#0@@10| Maps._default.MapLookupOption$K@@0))) (= (|Maps.__default.MapLookupOption#requires| Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0 |m#0@@102| |key#0@@10|) true))
 :qid |unknown.0:0|
 :skolemid |5339|
 :pattern ( (|Maps.__default.MapLookupOption#requires| Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0 |m#0@@102| |key#0@@10|))
)))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@1 T@U) (Maps._default.MapLookupOption$V@@1 T@U) (|m#0@@103| T@U) (|key#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@1) TyType) (= (type Maps._default.MapLookupOption$V@@1) TyType)) (= (type |m#0@@103|) (MapType BoxType BoxType))) (= (type |key#0@@11|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@11|) (and ($Is |m#0@@103| (TMap Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1)) ($IsBox |key#0@@11| Maps._default.MapLookupOption$K@@1)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@11|) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@103|) |key#0@@11|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| |m#0@@103|) |key#0@@11|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |5340|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@11|))
))))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@2 T@U) (Maps._default.MapLookupOption$V@@2 T@U) (|m#0@@104| T@U) (|key#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@2) TyType) (= (type Maps._default.MapLookupOption$V@@2) TyType)) (= (type |m#0@@104|) (MapType BoxType BoxType))) (= (type |key#0@@12|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@12|) (and ($Is |m#0@@104| (TMap Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2)) ($IsBox |key#0@@12| Maps._default.MapLookupOption$K@@2)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@12|) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@104|) |key#0@@12|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| (Lit |m#0@@104|)) |key#0@@12|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5341|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@12|))
))))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@3 T@U) (Maps._default.MapLookupOption$V@@3 T@U) (|m#0@@105| T@U) (|key#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@3) TyType) (= (type Maps._default.MapLookupOption$V@@3) TyType)) (= (type |m#0@@105|) (MapType BoxType BoxType))) (= (type |key#0@@13|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@13|)) (and ($Is |m#0@@105| (TMap Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3)) ($IsBox |key#0@@13| Maps._default.MapLookupOption$K@@3)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@13|)) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@105|) |key#0@@13|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| (Lit |m#0@@105|)) (Lit |key#0@@13|))) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5342|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@13|)))
))))
(assert (forall ((arg0@@557 T@U) (arg1@@270 T@U) (arg2@@156 T@U) (arg3@@95 T@U) ) (! (= (type (Maps.__default.ImapLookupOption arg0@@557 arg1@@270 arg2@@156 arg3@@95)) DatatypeTypeType)
 :qid |funType:Maps.__default.ImapLookupOption|
 :pattern ( (Maps.__default.ImapLookupOption arg0@@557 arg1@@270 arg2@@156 arg3@@95))
)))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K T@U) (Maps._default.ImapLookupOption$V T@U) (|m#0@@106| T@U) (|key#0@@14| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K) TyType) (= (type Maps._default.ImapLookupOption$V) TyType)) (= (type |m#0@@106|) (IMapType BoxType BoxType))) (= (type |key#0@@14|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@14|) (and ($Is |m#0@@106| (TIMap Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V)) ($IsBox |key#0@@14| Maps._default.ImapLookupOption$K)))) ($Is (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@14|) (Tclass.Options.Option Maps._default.ImapLookupOption$V)))
 :qid |unknown.0:0|
 :skolemid |5343|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@14|))
))))
(assert (forall ((Maps._default.ImapLookupOption$K@@0 T@U) (Maps._default.ImapLookupOption$V@@0 T@U) (|m#0@@107| T@U) (|key#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@0) TyType) (= (type Maps._default.ImapLookupOption$V@@0) TyType)) (= (type |m#0@@107|) (IMapType BoxType BoxType))) (= (type |key#0@@15|) BoxType)) (and ($Is |m#0@@107| (TIMap Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0)) ($IsBox |key#0@@15| Maps._default.ImapLookupOption$K@@0))) (= (|Maps.__default.ImapLookupOption#requires| Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0 |m#0@@107| |key#0@@15|) true))
 :qid |unknown.0:0|
 :skolemid |5344|
 :pattern ( (|Maps.__default.ImapLookupOption#requires| Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0 |m#0@@107| |key#0@@15|))
)))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K@@1 T@U) (Maps._default.ImapLookupOption$V@@1 T@U) (|m#0@@108| T@U) (|key#0@@16| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@1) TyType) (= (type Maps._default.ImapLookupOption$V@@1) TyType)) (= (type |m#0@@108|) (IMapType BoxType BoxType))) (= (type |key#0@@16|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@16|) (and ($Is |m#0@@108| (TIMap Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1)) ($IsBox |key#0@@16| Maps._default.ImapLookupOption$K@@1)))) (= (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@16|) (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@108|) |key#0@@16|)) (|#Options.Option.Some| (MapType0Select (|IMap#Elements| |m#0@@108|) |key#0@@16|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |5345|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@16|))
))))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K@@2 T@U) (Maps._default.ImapLookupOption$V@@2 T@U) (|m#0@@109| T@U) (|key#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@2) TyType) (= (type Maps._default.ImapLookupOption$V@@2) TyType)) (= (type |m#0@@109|) (IMapType BoxType BoxType))) (= (type |key#0@@17|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@17|)) (and ($Is |m#0@@109| (TIMap Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2)) ($IsBox |key#0@@17| Maps._default.ImapLookupOption$K@@2)))) (= (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@17|)) (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@109|) |key#0@@17|)) (|#Options.Option.Some| (MapType0Select (|IMap#Elements| (Lit |m#0@@109|)) (Lit |key#0@@17|))) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5346|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@17|)))
))))
(assert (forall ((arg0@@558 T@U) (arg1@@271 T@U) ) (! (= (type (|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@558 arg1@@271)) DatatypeTypeType)
 :qid |funType:#MsgHistoryMod.KeyedMessage.KeyedMessage|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@558 arg1@@271))
)))
(assert (forall ((|a#0#0#0@@2| T@U) (|a#0#1#0@@1| T@U) ) (!  (=> (and (= (type |a#0#0#0@@2|) (SeqType BoxType)) (= (type |a#0#1#0@@1|) DatatypeTypeType)) (= (DatatypeCtorId (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#0#0#0@@2| |a#0#1#0@@1|)) |##MsgHistoryMod.KeyedMessage.KeyedMessage|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5347|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#0#0#0@@2| |a#0#1#0@@1|))
)))
(assert (forall ((d@@41 T@U) ) (!  (=> (= (type d@@41) DatatypeTypeType) (= (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@41) (= (DatatypeCtorId d@@41) |##MsgHistoryMod.KeyedMessage.KeyedMessage|)))
 :qid |unknown.0:0|
 :skolemid |5348|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@41))
)))
(assert (forall ((d@@42 T@U) ) (!  (=> (and (= (type d@@42) DatatypeTypeType) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@42)) (exists ((|a#1#0#0@@2| T@U) (|a#1#1#0@@1| T@U) ) (!  (and (and (= (type |a#1#0#0@@2|) (SeqType BoxType)) (= (type |a#1#1#0@@1|) DatatypeTypeType)) (= d@@42 (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#1#0#0@@2| |a#1#1#0@@1|)))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5349|
 :no-pattern (type |a#1#0#0@@2|)
 :no-pattern (type |a#1#1#0@@1|)
 :no-pattern (U_2_int |a#1#0#0@@2|)
 :no-pattern (U_2_bool |a#1#0#0@@2|)
 :no-pattern (U_2_int |a#1#1#0@@1|)
 :no-pattern (U_2_bool |a#1#1#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |5350|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@42))
)))
(assert (= (type Tclass.MsgHistoryMod.KeyedMessage) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.KeyedMessage) Tagclass.MsgHistoryMod.KeyedMessage))
(assert (= (TagFamily Tclass.MsgHistoryMod.KeyedMessage) tytagFamily$KeyedMessage))
(assert (forall ((bx@@162 T@U) ) (!  (=> (and (= (type bx@@162) BoxType) ($IsBox bx@@162 Tclass.MsgHistoryMod.KeyedMessage)) (and (= ($Box ($Unbox DatatypeTypeType bx@@162)) bx@@162) ($Is ($Unbox DatatypeTypeType bx@@162) Tclass.MsgHistoryMod.KeyedMessage)))
 :qid |unknown.0:0|
 :skolemid |5351|
 :pattern ( ($IsBox bx@@162 Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((|a#2#0#0@@2| T@U) (|a#2#1#0@@1| T@U) ) (!  (=> (and (= (type |a#2#0#0@@2|) (SeqType BoxType)) (= (type |a#2#1#0@@1|) DatatypeTypeType)) (= ($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#2#0#0@@2| |a#2#1#0@@1|) Tclass.MsgHistoryMod.KeyedMessage)  (and ($Is |a#2#0#0@@2| Tclass.KeyType.Key) ($Is |a#2#1#0@@1| Tclass.ValueMessage.Message))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5352|
 :pattern ( ($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#2#0#0@@2| |a#2#1#0@@1|) Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((|a#3#0#0@@2| T@U) (|a#3#1#0@@1| T@U) ($h@@93 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@2|) (SeqType BoxType)) (= (type |a#3#1#0@@1|) DatatypeTypeType)) (= (type $h@@93) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@93)) (= ($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#3#0#0@@2| |a#3#1#0@@1|) Tclass.MsgHistoryMod.KeyedMessage $h@@93)  (and ($IsAlloc |a#3#0#0@@2| Tclass.KeyType.Key $h@@93) ($IsAlloc |a#3#1#0@@1| Tclass.ValueMessage.Message $h@@93))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5353|
 :pattern ( ($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#3#0#0@@2| |a#3#1#0@@1|) Tclass.MsgHistoryMod.KeyedMessage $h@@93))
)))
(assert (forall ((arg0@@559 T@U) ) (! (= (type (MsgHistoryMod.KeyedMessage.key arg0@@559)) (SeqType BoxType))
 :qid |funType:MsgHistoryMod.KeyedMessage.key|
 :pattern ( (MsgHistoryMod.KeyedMessage.key arg0@@559))
)))
(assert (forall ((d@@43 T@U) ($h@@94 T@U) ) (!  (=> (and (and (= (type d@@43) DatatypeTypeType) (= (type $h@@94) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@94) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@43) ($IsAlloc d@@43 Tclass.MsgHistoryMod.KeyedMessage $h@@94)))) ($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@43) Tclass.KeyType.Key $h@@94))
 :qid |unknown.0:0|
 :skolemid |5354|
 :pattern ( ($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@43) Tclass.KeyType.Key $h@@94))
)))
(assert (forall ((arg0@@560 T@U) ) (! (= (type (MsgHistoryMod.KeyedMessage.message arg0@@560)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.KeyedMessage.message|
 :pattern ( (MsgHistoryMod.KeyedMessage.message arg0@@560))
)))
(assert (forall ((d@@44 T@U) ($h@@95 T@U) ) (!  (=> (and (and (= (type d@@44) DatatypeTypeType) (= (type $h@@95) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@95) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@44) ($IsAlloc d@@44 Tclass.MsgHistoryMod.KeyedMessage $h@@95)))) ($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@44) Tclass.ValueMessage.Message $h@@95))
 :qid |unknown.0:0|
 :skolemid |5355|
 :pattern ( ($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@44) Tclass.ValueMessage.Message $h@@95))
)))
(assert (forall ((|a#4#0#0@@2| T@U) (|a#4#1#0@@1| T@U) ) (!  (=> (and (= (type |a#4#0#0@@2|) (SeqType BoxType)) (= (type |a#4#1#0@@1|) DatatypeTypeType)) (= (|#MsgHistoryMod.KeyedMessage.KeyedMessage| (Lit |a#4#0#0@@2|) (Lit |a#4#1#0@@1|)) (Lit (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#4#0#0@@2| |a#4#1#0@@1|))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5356|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| (Lit |a#4#0#0@@2|) (Lit |a#4#1#0@@1|)))
)))
(assert (forall ((|a#5#0#0@@3| T@U) (|a#5#1#0@@1| T@U) ) (!  (=> (and (= (type |a#5#0#0@@3|) (SeqType BoxType)) (= (type |a#5#1#0@@1|) DatatypeTypeType)) (= (MsgHistoryMod.KeyedMessage.key (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#5#0#0@@3| |a#5#1#0@@1|)) |a#5#0#0@@3|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5357|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#5#0#0@@3| |a#5#1#0@@1|))
)))
(assert (forall ((|a#6#0#0@@3| T@U) (|a#6#1#0@@1| T@U) ) (!  (=> (and (= (type |a#6#0#0@@3|) (SeqType BoxType)) (= (type |a#6#1#0@@1|) DatatypeTypeType)) (= (MsgHistoryMod.KeyedMessage.message (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#6#0#0@@3| |a#6#1#0@@1|)) |a#6#1#0@@1|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5358|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#6#0#0@@3| |a#6#1#0@@1|))
)))
(assert (forall ((|a#7#0#0@@3| T@U) (|a#7#1#0@@1| T@U) ) (!  (=> (and (= (type |a#7#0#0@@3|) (SeqType BoxType)) (= (type |a#7#1#0@@1|) DatatypeTypeType)) (< (DtRank |a#7#1#0@@1|) (DtRank (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#7#0#0@@3| |a#7#1#0@@1|))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |5359|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#7#0#0@@3| |a#7#1#0@@1|))
)))
(assert (forall ((d@@45 T@U) ) (!  (=> (and (= (type d@@45) DatatypeTypeType) (|$IsA#MsgHistoryMod.KeyedMessage| d@@45)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@45))
 :qid |unknown.0:0|
 :skolemid |5360|
 :pattern ( (|$IsA#MsgHistoryMod.KeyedMessage| d@@45))
)))
(assert (forall ((d@@46 T@U) ) (!  (=> (and (= (type d@@46) DatatypeTypeType) ($Is d@@46 Tclass.MsgHistoryMod.KeyedMessage)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@46))
 :qid |unknown.0:0|
 :skolemid |5361|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@46) ($Is d@@46 Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((a@@128 T@U) (b@@78 T@U) ) (!  (=> (and (and (= (type a@@128) DatatypeTypeType) (= (type b@@78) DatatypeTypeType)) true) (= (|MsgHistoryMod.KeyedMessage#Equal| a@@128 b@@78)  (and (|Seq#Equal| (MsgHistoryMod.KeyedMessage.key a@@128) (MsgHistoryMod.KeyedMessage.key b@@78)) (|ValueMessage.Message#Equal| (MsgHistoryMod.KeyedMessage.message a@@128) (MsgHistoryMod.KeyedMessage.message b@@78)))))
 :qid |unknown.0:0|
 :skolemid |5362|
 :pattern ( (|MsgHistoryMod.KeyedMessage#Equal| a@@128 b@@78))
)))
(assert (forall ((a@@129 T@U) (b@@79 T@U) ) (!  (=> (and (= (type a@@129) DatatypeTypeType) (= (type b@@79) DatatypeTypeType)) (= (|MsgHistoryMod.KeyedMessage#Equal| a@@129 b@@79) (= a@@129 b@@79)))
 :qid |unknown.0:0|
 :skolemid |5363|
 :pattern ( (|MsgHistoryMod.KeyedMessage#Equal| a@@129 b@@79))
)))
(assert (forall ((arg0@@561 T@U) (arg1@@272 Int) (arg2@@157 Int) ) (! (= (type (|#MsgHistoryMod.MsgHistory.MsgHistory| arg0@@561 arg1@@272 arg2@@157)) DatatypeTypeType)
 :qid |funType:#MsgHistoryMod.MsgHistory.MsgHistory|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| arg0@@561 arg1@@272 arg2@@157))
)))
(assert (forall ((|a#8#0#0@@2| T@U) (|a#8#1#0@@0| Int) (|a#8#2#0| Int) ) (!  (=> (= (type |a#8#0#0@@2|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#8#0#0@@2| |a#8#1#0@@0| |a#8#2#0|)) |##MsgHistoryMod.MsgHistory.MsgHistory|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5364|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#8#0#0@@2| |a#8#1#0@@0| |a#8#2#0|))
)))
(assert (forall ((d@@47 T@U) ) (!  (=> (= (type d@@47) DatatypeTypeType) (= (MsgHistoryMod.MsgHistory.MsgHistory_q d@@47) (= (DatatypeCtorId d@@47) |##MsgHistoryMod.MsgHistory.MsgHistory|)))
 :qid |unknown.0:0|
 :skolemid |5365|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@47))
)))
(assert (forall ((d@@48 T@U) ) (!  (=> (and (= (type d@@48) DatatypeTypeType) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@48)) (exists ((|a#9#0#0@@1| T@U) (|a#9#1#0| Int) (|a#9#2#0| Int) ) (!  (and (= (type |a#9#0#0@@1|) (MapType BoxType BoxType)) (= d@@48 (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#9#0#0@@1| |a#9#1#0| |a#9#2#0|)))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5366|
 :no-pattern (type |a#9#0#0@@1|)
 :no-pattern (U_2_int |a#9#0#0@@1|)
 :no-pattern (U_2_bool |a#9#0#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |5367|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@48))
)))
(assert (forall ((|a#10#0#0@@1| T@U) (|a#10#1#0| Int) (|a#10#2#0| Int) ) (!  (=> (= (type |a#10#0#0@@1|) (MapType BoxType BoxType)) (= ($Is (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#10#0#0@@1| |a#10#1#0| |a#10#2#0|) Tclass.MsgHistoryMod.MsgHistory)  (and (and ($Is |a#10#0#0@@1| (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage)) ($Is (int_2_U |a#10#1#0|) Tclass._System.nat)) ($Is (int_2_U |a#10#2#0|) Tclass._System.nat))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5368|
 :pattern ( ($Is (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#10#0#0@@1| |a#10#1#0| |a#10#2#0|) Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (forall ((|a#11#0#0@@1| T@U) (|a#11#1#0| Int) (|a#11#2#0| Int) ($h@@96 T@U) ) (!  (=> (and (and (= (type |a#11#0#0@@1|) (MapType BoxType BoxType)) (= (type $h@@96) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@96)) (= ($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#11#0#0@@1| |a#11#1#0| |a#11#2#0|) Tclass.MsgHistoryMod.MsgHistory $h@@96)  (and (and ($IsAlloc |a#11#0#0@@1| (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@96) ($IsAlloc (int_2_U |a#11#1#0|) Tclass._System.nat $h@@96)) ($IsAlloc (int_2_U |a#11#2#0|) Tclass._System.nat $h@@96))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5369|
 :pattern ( ($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#11#0#0@@1| |a#11#1#0| |a#11#2#0|) Tclass.MsgHistoryMod.MsgHistory $h@@96))
)))
(assert (forall ((arg0@@562 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.msgs arg0@@562)) (MapType BoxType BoxType))
 :qid |funType:MsgHistoryMod.MsgHistory.msgs|
 :pattern ( (MsgHistoryMod.MsgHistory.msgs arg0@@562))
)))
(assert (forall ((d@@49 T@U) ($h@@97 T@U) ) (!  (=> (and (and (= (type d@@49) DatatypeTypeType) (= (type $h@@97) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@97) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@49) ($IsAlloc d@@49 Tclass.MsgHistoryMod.MsgHistory $h@@97)))) ($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@49) (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@97))
 :qid |unknown.0:0|
 :skolemid |5370|
 :pattern ( ($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@49) (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@97))
)))
(assert (forall ((d@@50 T@U) ($h@@98 T@U) ) (!  (=> (and (and (= (type d@@50) DatatypeTypeType) (= (type $h@@98) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@98) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@50) ($IsAlloc d@@50 Tclass.MsgHistoryMod.MsgHistory $h@@98)))) ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@50)) Tclass._System.nat $h@@98))
 :qid |unknown.0:0|
 :skolemid |5371|
 :pattern ( ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@50)) Tclass._System.nat $h@@98))
)))
(assert (forall ((d@@51 T@U) ($h@@99 T@U) ) (!  (=> (and (and (= (type d@@51) DatatypeTypeType) (= (type $h@@99) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@99) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@51) ($IsAlloc d@@51 Tclass.MsgHistoryMod.MsgHistory $h@@99)))) ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@51)) Tclass._System.nat $h@@99))
 :qid |unknown.0:0|
 :skolemid |5372|
 :pattern ( ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@51)) Tclass._System.nat $h@@99))
)))
(assert (forall ((|a#12#0#0@@0| T@U) (|a#12#1#0| Int) (|a#12#2#0| Int) ) (!  (=> (= (type |a#12#0#0@@0|) (MapType BoxType BoxType)) (= (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit |a#12#0#0@@0|) (LitInt |a#12#1#0|) (LitInt |a#12#2#0|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#12#0#0@@0| |a#12#1#0| |a#12#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5373|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit |a#12#0#0@@0|) (LitInt |a#12#1#0|) (LitInt |a#12#2#0|)))
)))
(assert (forall ((|a#13#0#0| T@U) (|a#13#1#0| Int) (|a#13#2#0| Int) ) (!  (=> (= (type |a#13#0#0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.msgs (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#13#0#0| |a#13#1#0| |a#13#2#0|)) |a#13#0#0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5374|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#13#0#0| |a#13#1#0| |a#13#2#0|))
)))
(assert (forall ((|a#14#0#0@@0| T@U) (|a#14#1#0@@0| Int) (|a#14#2#0| Int) (d@@52 T@U) ) (!  (=> (and (and (= (type |a#14#0#0@@0|) (MapType BoxType BoxType)) (= (type d@@52) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#14#0#0@@0|) ($Box d@@52)))) (< (DtRank d@@52) (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#14#0#0@@0| |a#14#1#0@@0| |a#14#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5375|
 :pattern ( (MapType0Select (|Map#Domain| |a#14#0#0@@0|) ($Box d@@52)) (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#14#0#0@@0| |a#14#1#0@@0| |a#14#2#0|))
)))
(assert (forall ((|a#15#0#0@@0| T@U) (|a#15#1#0@@0| Int) (|a#15#2#0| Int) (bx@@163 T@U) ) (!  (=> (and (and (= (type |a#15#0#0@@0|) (MapType BoxType BoxType)) (= (type bx@@163) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#15#0#0@@0|) bx@@163))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#15#0#0@@0|) bx@@163))) (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#15#0#0@@0| |a#15#1#0@@0| |a#15#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5376|
 :pattern ( (MapType0Select (|Map#Domain| |a#15#0#0@@0|) bx@@163) (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#15#0#0@@0| |a#15#1#0@@0| |a#15#2#0|))
)))
(assert (forall ((|a#16#0#0@@0| T@U) (|a#16#1#0@@0| Int) (|a#16#2#0| Int) ) (!  (=> (= (type |a#16#0#0@@0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.seqStart (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#16#0#0@@0| |a#16#1#0@@0| |a#16#2#0|)) |a#16#1#0@@0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5377|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#16#0#0@@0| |a#16#1#0@@0| |a#16#2#0|))
)))
(assert (forall ((|a#17#0#0@@0| T@U) (|a#17#1#0@@0| Int) (|a#17#2#0| Int) ) (!  (=> (= (type |a#17#0#0@@0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.seqEnd (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#17#0#0@@0| |a#17#1#0@@0| |a#17#2#0|)) |a#17#2#0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |5378|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#17#0#0@@0| |a#17#1#0@@0| |a#17#2#0|))
)))
(assert (forall ((d@@53 T@U) ) (!  (=> (and (= (type d@@53) DatatypeTypeType) (|$IsA#MsgHistoryMod.MsgHistory| d@@53)) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@53))
 :qid |unknown.0:0|
 :skolemid |5379|
 :pattern ( (|$IsA#MsgHistoryMod.MsgHistory| d@@53))
)))
(assert (forall ((d@@54 T@U) ) (!  (=> (and (= (type d@@54) DatatypeTypeType) ($Is d@@54 Tclass.MsgHistoryMod.MsgHistory)) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@54))
 :qid |unknown.0:0|
 :skolemid |5380|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@54) ($Is d@@54 Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (forall ((a@@130 T@U) (b@@80 T@U) ) (!  (=> (and (and (= (type a@@130) DatatypeTypeType) (= (type b@@80) DatatypeTypeType)) true) (= (|MsgHistoryMod.MsgHistory#Equal| a@@130 b@@80)  (and (and (|Map#Equal| (MsgHistoryMod.MsgHistory.msgs a@@130) (MsgHistoryMod.MsgHistory.msgs b@@80)) (= (MsgHistoryMod.MsgHistory.seqStart a@@130) (MsgHistoryMod.MsgHistory.seqStart b@@80))) (= (MsgHistoryMod.MsgHistory.seqEnd a@@130) (MsgHistoryMod.MsgHistory.seqEnd b@@80)))))
 :qid |unknown.0:0|
 :skolemid |5381|
 :pattern ( (|MsgHistoryMod.MsgHistory#Equal| a@@130 b@@80))
)))
(assert (forall ((a@@131 T@U) (b@@81 T@U) ) (!  (=> (and (= (type a@@131) DatatypeTypeType) (= (type b@@81) DatatypeTypeType)) (= (|MsgHistoryMod.MsgHistory#Equal| a@@131 b@@81) (= a@@131 b@@81)))
 :qid |unknown.0:0|
 :skolemid |5382|
 :pattern ( (|MsgHistoryMod.MsgHistory#Equal| a@@131 b@@81))
)))
(assert  (=> true (forall ((this T@U) ) (!  (=> (and (= (type this) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| this) ($Is this Tclass.MsgHistoryMod.MsgHistory))) true)
 :qid |MsgHistoryidfy.34:15|
 :skolemid |5383|
 :pattern ( (MsgHistoryMod.MsgHistory.WF this))
))))
(assert (forall ((this@@0 T@U) ) (!  (=> (and (= (type this@@0) DatatypeTypeType) ($Is this@@0 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.WF#requires| this@@0) true))
 :qid |MsgHistoryidfy.34:15|
 :skolemid |5384|
 :pattern ( (|MsgHistoryMod.MsgHistory.WF#requires| this@@0))
)))
(assert  (=> true (forall ((this@@1 T@U) ) (!  (=> (and (= (type this@@1) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| this@@1) ($Is this@@1 Tclass.MsgHistoryMod.MsgHistory))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@1) (MsgHistoryMod.MsgHistory.seqEnd this@@1)) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@1) (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@1 (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs this@@1)))))) (= (MsgHistoryMod.MsgHistory.WF this@@1)  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@1) (MsgHistoryMod.MsgHistory.seqEnd this@@1)) (MsgHistoryMod.MsgHistory.ContainsExactly this@@1 (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs this@@1)))))))
 :qid |MsgHistoryidfy.34:15|
 :skolemid |5385|
 :pattern ( (MsgHistoryMod.MsgHistory.WF this@@1))
))))
(assert  (=> true (forall ((this@@2 T@U) ) (!  (=> (and (= (type this@@2) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit this@@2)) ($Is this@@2 Tclass.MsgHistoryMod.MsgHistory))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@2)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@2))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@2)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@2))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@2)) (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (Lit this@@2) (Lit (|Map#Domain| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@2))))))))) (= (MsgHistoryMod.MsgHistory.WF (Lit this@@2))  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@2)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@2))) (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@2) (Lit (|Map#Domain| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@2))))))))))
 :qid |MsgHistoryidfy.34:15|
 :weight 3
 :skolemid |5386|
 :pattern ( (MsgHistoryMod.MsgHistory.WF (Lit this@@2)))
))))
(assert  (=> true (forall ((this@@3 T@U) (|lsns#0| T@U) ) (!  (=> (and (and (= (type this@@3) DatatypeTypeType) (= (type |lsns#0|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@3 |lsns#0|) (and ($Is this@@3 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0| (TSet Tclass._System.nat))))) true)
 :qid |MsgHistoryidfy.40:15|
 :skolemid |5387|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly this@@3 |lsns#0|))
))))
(assert (forall ((this@@4 T@U) (|lsns#0@@0| T@U) ) (!  (=> (and (and (= (type this@@4) DatatypeTypeType) (= (type |lsns#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@4 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@0| (TSet Tclass._System.nat)))) (= (|MsgHistoryMod.MsgHistory.ContainsExactly#requires| this@@4 |lsns#0@@0|) true))
 :qid |MsgHistoryidfy.40:15|
 :skolemid |5388|
 :pattern ( (|MsgHistoryMod.MsgHistory.ContainsExactly#requires| this@@4 |lsns#0@@0|))
)))
(assert  (=> true (forall ((this@@5 T@U) (|lsns#0@@1| T@U) ) (!  (=> (and (and (= (type this@@5) DatatypeTypeType) (= (type |lsns#0@@1|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@5 |lsns#0@@1|) (and ($Is this@@5 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@1| (TSet Tclass._System.nat))))) (and (forall ((|lsn#0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0|) (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@5 |lsn#0|))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |5390|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@5 |lsn#0|))
 :pattern ( (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0|))))
)) (= (MsgHistoryMod.MsgHistory.ContainsExactly this@@5 |lsns#0@@1|) (forall ((|lsn#0@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@0|) (= (U_2_bool (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0@@0|)))) (MsgHistoryMod.MsgHistory.Contains this@@5 |lsn#0@@0|)))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |5389|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@5 |lsn#0@@0|))
 :pattern ( (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0@@0|))))
)))))
 :qid |MsgHistoryidfy.40:15|
 :skolemid |5391|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly this@@5 |lsns#0@@1|))
))))
(assert  (=> true (forall ((this@@6 T@U) (|lsns#0@@2| T@U) ) (!  (=> (and (and (= (type this@@6) DatatypeTypeType) (= (type |lsns#0@@2|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (Lit this@@6) (Lit |lsns#0@@2|)) (and ($Is this@@6 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@2| (TSet Tclass._System.nat))))) (and (forall ((|lsn#1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1|) (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@6) |lsn#1|))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |5393|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@6 |lsn#1|))
 :pattern ( (MapType0Select |lsns#0@@2| ($Box (int_2_U |lsn#1|))))
)) (= (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@6) (Lit |lsns#0@@2|)) (forall ((|lsn#1@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1@@0|) (= (U_2_bool (MapType0Select (Lit |lsns#0@@2|) ($Box (int_2_U |lsn#1@@0|)))) (MsgHistoryMod.MsgHistory.Contains (Lit this@@6) |lsn#1@@0|)))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |5392|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@6 |lsn#1@@0|))
 :pattern ( (MapType0Select |lsns#0@@2| ($Box (int_2_U |lsn#1@@0|))))
)))))
 :qid |MsgHistoryidfy.40:15|
 :weight 3
 :skolemid |5394|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@6) (Lit |lsns#0@@2|)))
))))
(assert  (=> true (forall ((this@@7 T@U) (|lsn#0@@1| Int) ) (!  (=> (and (= (type this@@7) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@7 |lsn#0@@1|) (and ($Is this@@7 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@1|)))) true)
 :qid |MsgHistoryidfy.45:15|
 :skolemid |5395|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@7 |lsn#0@@1|))
))))
(assert (forall ((this@@8 T@U) (|lsn#0@@2| Int) ) (!  (=> (= (type this@@8) DatatypeTypeType) (=> (and ($Is this@@8 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@2|)) (= (|MsgHistoryMod.MsgHistory.Contains#requires| this@@8 |lsn#0@@2|) true)))
 :qid |MsgHistoryidfy.45:15|
 :skolemid |5396|
 :pattern ( (|MsgHistoryMod.MsgHistory.Contains#requires| this@@8 |lsn#0@@2|))
)))
(assert  (=> true (forall ((this@@9 T@U) (|lsn#0@@3| Int) ) (!  (=> (and (= (type this@@9) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@9 |lsn#0@@3|) (and ($Is this@@9 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@3|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@9) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@9) |lsn#0@@3|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@9)))) (= (MsgHistoryMod.MsgHistory.Contains this@@9 |lsn#0@@3|)  (and true (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@9) |lsn#0@@3|) (INTERNAL_lt_boogie |lsn#0@@3| (MsgHistoryMod.MsgHistory.seqEnd this@@9)))))))
 :qid |MsgHistoryidfy.45:15|
 :skolemid |5397|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@9 |lsn#0@@3|))
))))
(assert  (=> true (forall ((this@@10 T@U) (|lsn#0@@4| Int) ) (!  (=> (and (= (type this@@10) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@10) (LitInt |lsn#0@@4|)) (and ($Is this@@10 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@4|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@10)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@10)) |lsn#0@@4|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@10))))) (= (MsgHistoryMod.MsgHistory.Contains (Lit this@@10) (LitInt |lsn#0@@4|))  (and true (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@10)) |lsn#0@@4|) (INTERNAL_lt_boogie |lsn#0@@4| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@10))))))))
 :qid |MsgHistoryidfy.45:15|
 :weight 3
 :skolemid |5398|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains (Lit this@@10) (LitInt |lsn#0@@4|)))
))))
(assert (forall ((arg0@@563 T@U) (arg1@@273 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.LSNSet arg0@@563 arg1@@273)) (MapType0Type BoxType boolType))
 :qid |funType:MsgHistoryMod.MsgHistory.LSNSet|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet arg0@@563 arg1@@273))
)))
(assert (forall (($ly@@302 T@U) (this@@11 T@U) ) (!  (=> (and (= (type $ly@@302) LayerTypeType) (= (type this@@11) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@302) this@@11) (MsgHistoryMod.MsgHistory.LSNSet $ly@@302 this@@11)))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |5399|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@302) this@@11))
)))
(assert (forall (($ly@@303 T@U) (this@@12 T@U) ) (!  (=> (and (= (type $ly@@303) LayerTypeType) (= (type this@@12) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.LSNSet $ly@@303 this@@12) (MsgHistoryMod.MsgHistory.LSNSet $LZ this@@12)))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |5400|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet (AsFuelBottom $ly@@303) this@@12))
)))
(assert  (=> true (forall (($ly@@304 T@U) (this@@13 T@U) ) (!  (=> (and (and (= (type $ly@@304) LayerTypeType) (= (type this@@13) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| this@@13) ($Is this@@13 Tclass.MsgHistoryMod.MsgHistory))) (and (MsgHistoryMod.MsgHistory.ContainsExactly this@@13 (MsgHistoryMod.MsgHistory.LSNSet $ly@@304 this@@13)) ($Is (MsgHistoryMod.MsgHistory.LSNSet $ly@@304 this@@13) (TSet Tclass._System.nat))))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |5401|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet $ly@@304 this@@13))
))))
(assert (forall (($ly@@305 T@U) (this@@14 T@U) ) (!  (=> (and (and (= (type $ly@@305) LayerTypeType) (= (type this@@14) DatatypeTypeType)) ($Is this@@14 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@305 this@@14) true))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |5402|
 :pattern ( (|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@305 this@@14))
)))
(assert (forall ((arg0@@564 T@U) (arg1@@274 Int) (arg2@@158 Int) ) (! (= (type (|lambda#260| arg0@@564 arg1@@274 arg2@@158)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#260|
 :pattern ( (|lambda#260| arg0@@564 arg1@@274 arg2@@158))
)))
(assert  (=> true (forall (($ly@@306 T@U) (this@@15 T@U) ) (!  (=> (and (and (= (type $ly@@306) LayerTypeType) (= (type this@@15) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| this@@15) ($Is this@@15 Tclass.MsgHistoryMod.MsgHistory))) (and (forall ((|lsn#0@@5| Int) ) (!  (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@15) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@15) |lsn#0@@5|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@15)))
 :qid |MsgHistoryidfy.55:11|
 :skolemid |5403|
 :pattern ( (INTERNAL_lt_boogie |lsn#0@@5| (MsgHistoryMod.MsgHistory.seqEnd this@@15)))
 :pattern ( (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@15) |lsn#0@@5|))
)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@306) this@@15) (|lambda#260| TInt (MsgHistoryMod.MsgHistory.seqStart this@@15) (MsgHistoryMod.MsgHistory.seqEnd this@@15)))))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |5404|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@306) this@@15))
))))
(assert  (=> true (forall (($ly@@307 T@U) (this@@16 T@U) ) (!  (=> (and (and (= (type $ly@@307) LayerTypeType) (= (type this@@16) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| (Lit this@@16)) ($Is this@@16 Tclass.MsgHistoryMod.MsgHistory))) (and (forall ((|lsn#1@@1| Int) ) (!  (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@16)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@16)) |lsn#1@@1|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@16))))
 :qid |MsgHistoryidfy.55:11|
 :skolemid |5405|
 :pattern ( (INTERNAL_lt_boogie |lsn#1@@1| (MsgHistoryMod.MsgHistory.seqEnd this@@16)))
 :pattern ( (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@16) |lsn#1@@1|))
)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@307) (Lit this@@16)) (|lambda#260| TInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@16)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@16))))))
 :qid |MsgHistoryidfy.52:24|
 :weight 3
 :skolemid |5406|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@307) (Lit this@@16)))
))))
(assert  (=> true (forall ((this@@17 T@U) ) (!  (=> (and (= (type this@@17) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@17) (and ($Is this@@17 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@17)))) true)
 :qid |MsgHistoryidfy.58:15|
 :skolemid |5407|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty this@@17))
))))
(assert (forall ((this@@18 T@U) ) (!  (=> (and (= (type this@@18) DatatypeTypeType) ($Is this@@18 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@18) (MsgHistoryMod.MsgHistory.WF this@@18)))
 :qid |MsgHistoryidfy.58:15|
 :skolemid |5408|
 :pattern ( (|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@18))
)))
(assert  (=> true (forall ((this@@19 T@U) ) (!  (=> (and (= (type this@@19) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@19) (and ($Is this@@19 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@19)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@19) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@19)) (= (MsgHistoryMod.MsgHistory.IsEmpty this@@19) (= (MsgHistoryMod.MsgHistory.seqEnd this@@19) (MsgHistoryMod.MsgHistory.seqStart this@@19)))))
 :qid |MsgHistoryidfy.58:15|
 :skolemid |5409|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty this@@19))
))))
(assert  (=> true (forall ((this@@20 T@U) ) (!  (=> (and (= (type this@@20) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@20)) (and ($Is this@@20 Tclass.MsgHistoryMod.MsgHistory) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@20)))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@20)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@20))) (= (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@20)) (= (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@20))) (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@20)))))))
 :qid |MsgHistoryidfy.58:15|
 :weight 3
 :skolemid |5410|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@20)))
))))
(assert  (=> true (forall ((this@@21 T@U) ) (!  (=> (and (= (type this@@21) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| this@@21) (and ($Is this@@21 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@21)))) (INTERNAL_le_boogie 0 (MsgHistoryMod.MsgHistory.Len this@@21)))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |5411|
 :pattern ( (MsgHistoryMod.MsgHistory.Len this@@21))
))))
(assert (forall ((this@@22 T@U) ) (!  (=> (and (= (type this@@22) DatatypeTypeType) ($Is this@@22 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.Len#requires| this@@22) (MsgHistoryMod.MsgHistory.WF this@@22)))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |5412|
 :pattern ( (|MsgHistoryMod.MsgHistory.Len#requires| this@@22))
)))
(assert  (=> true (forall ((this@@23 T@U) ) (!  (=> (and (= (type this@@23) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| this@@23) (and ($Is this@@23 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@23)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@23) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@23)) (= (MsgHistoryMod.MsgHistory.Len this@@23) (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@23) (MsgHistoryMod.MsgHistory.seqStart this@@23)))))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |5413|
 :pattern ( (MsgHistoryMod.MsgHistory.Len this@@23))
))))
(assert  (=> true (forall ((this@@24 T@U) ) (!  (=> (and (= (type this@@24) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| (Lit this@@24)) (and ($Is this@@24 Tclass.MsgHistoryMod.MsgHistory) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@24)))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@24)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@24))) (= (MsgHistoryMod.MsgHistory.Len (Lit this@@24)) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@24)) (MsgHistoryMod.MsgHistory.seqStart (Lit this@@24)))))))
 :qid |MsgHistoryidfy.64:14|
 :weight 3
 :skolemid |5414|
 :pattern ( (MsgHistoryMod.MsgHistory.Len (Lit this@@24)))
))))
(assert  (=> true (forall ((this@@25 T@U) (|other#0@@3| T@U) ) (!  (=> (and (and (= (type this@@25) DatatypeTypeType) (= (type |other#0@@3|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| this@@25 |other#0@@3|) (and (and ($Is this@@25 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@3| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@25) (MsgHistoryMod.MsgHistory.WF |other#0@@3|))))) true)
 :qid |MsgHistoryidfy.70:15|
 :skolemid |5415|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat this@@25 |other#0@@3|))
))))
(assert (forall ((this@@26 T@U) (|other#0@@4| T@U) ) (!  (=> (and (and (= (type this@@26) DatatypeTypeType) (= (type |other#0@@4|) DatatypeTypeType)) (and ($Is this@@26 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@4| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.CanConcat#requires| this@@26 |other#0@@4|)  (and (MsgHistoryMod.MsgHistory.WF this@@26) (MsgHistoryMod.MsgHistory.WF |other#0@@4|))))
 :qid |MsgHistoryidfy.70:15|
 :skolemid |5416|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanConcat#requires| this@@26 |other#0@@4|))
)))
(assert  (=> true (forall ((this@@27 T@U) (|other#0@@5| T@U) ) (!  (=> (and (and (= (type this@@27) DatatypeTypeType) (= (type |other#0@@5|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| this@@27 |other#0@@5|) (and (and ($Is this@@27 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@5| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@27) (MsgHistoryMod.MsgHistory.WF |other#0@@5|))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@27) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| |other#0@@5| (MsgHistoryMod.MsgHistory.seqEnd this@@27))) (= (MsgHistoryMod.MsgHistory.CanConcat this@@27 |other#0@@5|) (MsgHistoryMod.MsgHistory.CanFollow |other#0@@5| (MsgHistoryMod.MsgHistory.seqEnd this@@27)))))
 :qid |MsgHistoryidfy.70:15|
 :skolemid |5417|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat this@@27 |other#0@@5|))
))))
(assert  (=> true (forall ((this@@28 T@U) (|other#0@@6| T@U) ) (!  (=> (and (and (= (type this@@28) DatatypeTypeType) (= (type |other#0@@6|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| (Lit this@@28) (Lit |other#0@@6|)) (and (and ($Is this@@28 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@6| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@28))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |other#0@@6|))))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@28)) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (Lit |other#0@@6|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@28))))) (= (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@28) (Lit |other#0@@6|)) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit |other#0@@6|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@28))))))))))
 :qid |MsgHistoryidfy.70:15|
 :weight 3
 :skolemid |5418|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@28) (Lit |other#0@@6|)))
))))
(assert  (and (forall ((arg0@@565 T@U) (arg1@@275 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.Concat arg0@@565 arg1@@275)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.Concat|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat arg0@@565 arg1@@275))
)) (= (type StartFuel_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType)))
(assert  (=> true (forall ((this@@29 T@U) (|other#0@@7| T@U) ) (!  (=> (and (and (= (type this@@29) DatatypeTypeType) (= (type |other#0@@7|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| this@@29 |other#0@@7|) (and (and ($Is this@@29 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@7| Tclass.MsgHistoryMod.MsgHistory)) (and (and (MsgHistoryMod.MsgHistory.WF this@@29) (MsgHistoryMod.MsgHistory.WF |other#0@@7|)) (MsgHistoryMod.MsgHistory.CanConcat this@@29 |other#0@@7|))))) (and (and (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|)) (|Set#Equal| (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet (MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|)) (|Set#Union| (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet this@@29) (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet |other#0@@7|)))) (=> (MsgHistoryMod.MsgHistory.IsEmpty |other#0@@7|) (|MsgHistoryMod.MsgHistory#Equal| (MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|) this@@29))) ($Is (MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |5419|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat this@@29 |other#0@@7|))
))))
(assert (forall ((this@@30 T@U) (|other#0@@8| T@U) ) (!  (=> (and (and (= (type this@@30) DatatypeTypeType) (= (type |other#0@@8|) DatatypeTypeType)) (and ($Is this@@30 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@8| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.Concat#requires| this@@30 |other#0@@8|)  (and (and (MsgHistoryMod.MsgHistory.WF this@@30) (MsgHistoryMod.MsgHistory.WF |other#0@@8|)) (MsgHistoryMod.MsgHistory.CanConcat this@@30 |other#0@@8|))))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |5420|
 :pattern ( (|MsgHistoryMod.MsgHistory.Concat#requires| this@@30 |other#0@@8|))
)))
(assert  (=> true (forall ((this@@31 T@U) (|other#0@@9| T@U) ) (!  (=> (and (and (= (type this@@31) DatatypeTypeType) (= (type |other#0@@9|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| this@@31 |other#0@@9|) (and (and ($Is this@@31 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@9| Tclass.MsgHistoryMod.MsgHistory)) (and (and (MsgHistoryMod.MsgHistory.WF this@@31) (MsgHistoryMod.MsgHistory.WF |other#0@@9|)) (MsgHistoryMod.MsgHistory.CanConcat this@@31 |other#0@@9|))))) (and (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@31) (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@9|)) (|Maps.__default.MapDisjointUnion#canCall| Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage (MsgHistoryMod.MsgHistory.msgs this@@31) (MsgHistoryMod.MsgHistory.msgs |other#0@@9|))) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@31)) (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@9|)) (= (MsgHistoryMod.MsgHistory.Concat this@@31 |other#0@@9|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Maps.__default.MapDisjointUnion Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage StartFuel_Maps._default.MapDisjointUnion (MsgHistoryMod.MsgHistory.msgs this@@31) (MsgHistoryMod.MsgHistory.msgs |other#0@@9|)) (MsgHistoryMod.MsgHistory.seqStart this@@31) (MsgHistoryMod.MsgHistory.seqEnd |other#0@@9|)))))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |5421|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat this@@31 |other#0@@9|))
))))
(assert  (=> true (forall ((this@@32 T@U) (|other#0@@10| T@U) ) (!  (=> (and (and (= (type this@@32) DatatypeTypeType) (= (type |other#0@@10|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| (Lit this@@32) (Lit |other#0@@10|)) (and (and ($Is this@@32 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@10| Tclass.MsgHistoryMod.MsgHistory)) (and (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@32))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |other#0@@10|)))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@32) (Lit |other#0@@10|))))))))) (and (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@32)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |other#0@@10|))) (|Maps.__default.MapDisjointUnion#canCall| Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@32))) (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@10|))))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@32))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |other#0@@10|))) (= (MsgHistoryMod.MsgHistory.Concat (Lit this@@32) (Lit |other#0@@10|)) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Maps.__default.MapDisjointUnion Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage StartFuel_Maps._default.MapDisjointUnion (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@32))) (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@10|)))) (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@32))) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit |other#0@@10|)))))))
 :qid |MsgHistoryidfy.77:14|
 :weight 3
 :skolemid |5422|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat (Lit this@@32) (Lit |other#0@@10|)))
))))
(assert  (=> true (forall ((this@@33 T@U) (|lsn#0@@6| Int) ) (!  (=> (and (= (type this@@33) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| this@@33 |lsn#0@@6|) (and ($Is this@@33 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@6|)))) true)
 :qid |MsgHistoryidfy.89:15|
 :skolemid |5423|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow this@@33 |lsn#0@@6|))
))))
(assert (forall ((this@@34 T@U) (|lsn#0@@7| Int) ) (!  (=> (= (type this@@34) DatatypeTypeType) (=> (and ($Is this@@34 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@7|)) (= (|MsgHistoryMod.MsgHistory.CanFollow#requires| this@@34 |lsn#0@@7|) true)))
 :qid |MsgHistoryidfy.89:15|
 :skolemid |5424|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanFollow#requires| this@@34 |lsn#0@@7|))
)))
(assert  (=> true (forall ((this@@35 T@U) (|lsn#0@@8| Int) ) (!  (=> (and (= (type this@@35) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| this@@35 |lsn#0@@8|) (and ($Is this@@35 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@8|)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@35) (= (MsgHistoryMod.MsgHistory.CanFollow this@@35 |lsn#0@@8|) (= (MsgHistoryMod.MsgHistory.seqStart this@@35) |lsn#0@@8|))))
 :qid |MsgHistoryidfy.89:15|
 :skolemid |5425|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow this@@35 |lsn#0@@8|))
))))
(assert  (=> true (forall ((this@@36 T@U) (|lsn#0@@9| Int) ) (!  (=> (and (= (type this@@36) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (Lit this@@36) (LitInt |lsn#0@@9|)) (and ($Is this@@36 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@9|)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@36)) (= (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@36) (LitInt |lsn#0@@9|)) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@36))) (LitInt |lsn#0@@9|)))))
 :qid |MsgHistoryidfy.89:15|
 :weight 3
 :skolemid |5426|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@36) (LitInt |lsn#0@@9|)))
))))
(assert (forall ((arg0@@566 T@U) (arg1@@276 T@U) (arg2@@159 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.ApplyToStampedMap arg0@@566 arg1@@276 arg2@@159)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.ApplyToStampedMap|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap arg0@@566 arg1@@276 arg2@@159))
)))
(assert (forall (($ly@@308 T@U) (this@@37 T@U) (|orig#0| T@U) ) (!  (=> (and (and (= (type $ly@@308) LayerTypeType) (= (type this@@37) DatatypeTypeType)) (= (type |orig#0|) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@308) this@@37 |orig#0|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@308 this@@37 |orig#0|)))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |5427|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@308) this@@37 |orig#0|))
)))
(assert (forall (($ly@@309 T@U) (this@@38 T@U) (|orig#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@309) LayerTypeType) (= (type this@@38) DatatypeTypeType)) (= (type |orig#0@@0|) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@309 this@@38 |orig#0@@0|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap $LZ this@@38 |orig#0@@0|)))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |5428|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap (AsFuelBottom $ly@@309) this@@38 |orig#0@@0|))
)))
(assert  (=> true (forall (($ly@@310 T@U) (this@@39 T@U) (|orig#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@310) LayerTypeType) (= (type this@@39) DatatypeTypeType)) (= (type |orig#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| this@@39 |orig#0@@1|) (and (and ($Is this@@39 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (MsgHistoryMod.MsgHistory.WF this@@39) (MsgHistoryMod.MsgHistory.CanFollow this@@39 (StampedMod.Stamped.seqEnd |orig#0@@1|)))))) (and (= (StampedMod.Stamped.seqEnd (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@310 this@@39 |orig#0@@1|)) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |orig#0@@1|) (MsgHistoryMod.MsgHistory.Len this@@39))) ($Is (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@310 this@@39 |orig#0@@1|) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |5429|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@310 this@@39 |orig#0@@1|))
))))
(assert (forall (($ly@@311 T@U) (this@@40 T@U) (|orig#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@311) LayerTypeType) (= (type this@@40) DatatypeTypeType)) (= (type |orig#0@@2|) DatatypeTypeType)) (and ($Is this@@40 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))) (= (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| $ly@@311 this@@40 |orig#0@@2|)  (and (MsgHistoryMod.MsgHistory.WF this@@40) (MsgHistoryMod.MsgHistory.CanFollow this@@40 (StampedMod.Stamped.seqEnd |orig#0@@2|)))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |5430|
 :pattern ( (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| $ly@@311 this@@40 |orig#0@@2|))
)))
(assert (forall ((arg0@@567 T@U) (arg1@@277 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.DiscardRecent arg0@@567 arg1@@277)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.DiscardRecent|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent arg0@@567 arg1@@277))
)))
(assert  (=> true (forall (($ly@@312 T@U) (this@@41 T@U) (|orig#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@312) LayerTypeType) (= (type this@@41) DatatypeTypeType)) (= (type |orig#0@@3|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| this@@41 |orig#0@@3|) (and (and ($Is this@@41 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@3| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (MsgHistoryMod.MsgHistory.WF this@@41) (MsgHistoryMod.MsgHistory.CanFollow this@@41 (StampedMod.Stamped.seqEnd |orig#0@@3|)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@41) (=> (not (MsgHistoryMod.MsgHistory.IsEmpty this@@41)) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@41) (let ((|lastLsn#0| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@41) 1)))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@41 |lastLsn#0|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent this@@41 |lastLsn#0|) |orig#0@@3|)) (let ((|subMap#0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@312 (MsgHistoryMod.MsgHistory.DiscardRecent this@@41 |lastLsn#0|) |orig#0@@3|)))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@41) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0|)))))) (let ((|key#0@@18| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@41) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0|)))))) (let ((|newMessage#0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#0|) (let ((|oldMessage#0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0|))) ($Box |key#0@@18|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#0|) (|ValueMessage.__default.Merge#canCall| |newMessage#0| |oldMessage#0|)) (StampedMod.Stamped.Stamped_q |subMap#0|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@312) this@@41 |orig#0@@3|) (ite (MsgHistoryMod.MsgHistory.IsEmpty this@@41) |orig#0@@3| (let ((|lastLsn#0@@0| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@41) 1)))
(let ((|subMap#0@@0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@312 (MsgHistoryMod.MsgHistory.DiscardRecent this@@41 |lastLsn#0@@0|) |orig#0@@3|)))
(let ((|key#0@@19| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0@@0|)))))))
(let ((|newMessage#0@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@41)) ($Box (int_2_U |lastLsn#0@@0|)))))))
(let ((|oldMessage#0@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0@@0|))) ($Box |key#0@@19|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0@@0|)) ($Box |key#0@@19|) ($Box (ValueMessage.__default.Merge |newMessage#0@@0| |oldMessage#0@@0|)))) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#0@@0|) 1)))))))))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |5431|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@312) this@@41 |orig#0@@3|))
))))
(assert  (=> true (forall (($ly@@313 T@U) (this@@42 T@U) (|orig#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@313) LayerTypeType) (= (type this@@42) DatatypeTypeType)) (= (type |orig#0@@4|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit this@@42) |orig#0@@4|) (and (and ($Is this@@42 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@4| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@42))))) (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@42) (StampedMod.Stamped.seqEnd |orig#0@@4|)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@42)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@42)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@42)) (let ((|lastLsn#1| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@42)) 1))))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@42) |lastLsn#1|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@42) |lastLsn#1|) |orig#0@@4|)) (let ((|subMap#1| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@313) (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@42) |lastLsn#1|) |orig#0@@4|)))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@42)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1|)))))) (let ((|key#1@@6| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@42)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1|)))))) (let ((|newMessage#1| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#1|) (let ((|oldMessage#1| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1|))) ($Box |key#1@@6|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#1|) (|ValueMessage.__default.Merge#canCall| |newMessage#1| |oldMessage#1|)) (StampedMod.Stamped.Stamped_q |subMap#1|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@313) (Lit this@@42) |orig#0@@4|) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@42)) |orig#0@@4| (let ((|lastLsn#1@@0| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@42)) 1))))
(let ((|subMap#1@@0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@313) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@42) |lastLsn#1@@0|)) |orig#0@@4|)))
(let ((|key#1@@7| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1@@0|)))))))
(let ((|newMessage#1@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@42)))) ($Box (int_2_U |lastLsn#1@@0|)))))))
(let ((|oldMessage#1@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1@@0|))) ($Box |key#1@@7|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1@@0|)) ($Box |key#1@@7|) ($Box (ValueMessage.__default.Merge |newMessage#1@@0| |oldMessage#1@@0|)))) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#1@@0|) 1)))))))))))
 :qid |MsgHistoryidfy.94:14|
 :weight 3
 :skolemid |5432|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@313) (Lit this@@42) |orig#0@@4|))
))))
(assert  (=> true (forall (($ly@@314 T@U) (this@@43 T@U) (|orig#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@314) LayerTypeType) (= (type this@@43) DatatypeTypeType)) (= (type |orig#0@@5|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit this@@43) (Lit |orig#0@@5|)) (and (and ($Is this@@43 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@5| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@43))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@43) (LitInt (StampedMod.Stamped.seqEnd (Lit |orig#0@@5|))))))))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@43)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@43)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@43)) (let ((|lastLsn#2| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@43)) 1))))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@43) |lastLsn#2|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@43) |lastLsn#2|) (Lit |orig#0@@5|))) (let ((|subMap#2| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@314) (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@43) |lastLsn#2|) (Lit |orig#0@@5|))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@43)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2|)))))) (let ((|key#2@@0| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@43)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2|)))))) (let ((|newMessage#2| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#2|) (let ((|oldMessage#2| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2|))) ($Box |key#2@@0|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#2|) (|ValueMessage.__default.Merge#canCall| |newMessage#2| |oldMessage#2|)) (StampedMod.Stamped.Stamped_q |subMap#2|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@314) (Lit this@@43) (Lit |orig#0@@5|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@43)) |orig#0@@5| (let ((|lastLsn#2@@0| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@43)) 1))))
(let ((|subMap#2@@0| (Lit (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@314) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@43) |lastLsn#2@@0|)) (Lit |orig#0@@5|)))))
(let ((|key#2@@1| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2@@0|)))))))
(let ((|newMessage#2@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@43)))) ($Box (int_2_U |lastLsn#2@@0|)))))))
(let ((|oldMessage#2@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2@@0|)))) ($Box |key#2@@1|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2@@0|))) ($Box |key#2@@1|) ($Box (ValueMessage.__default.Merge |newMessage#2@@0| |oldMessage#2@@0|)))) (LitInt (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#2@@0|) 1))))))))))))
 :qid |MsgHistoryidfy.94:14|
 :weight 3
 :skolemid |5433|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@314) (Lit this@@43) (Lit |orig#0@@5|)))
))))
(assert  (=> true (forall ((this@@44 T@U) (|lsn#0@@10| Int) ) (!  (=> (and (= (type this@@44) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| this@@44 |lsn#0@@10|) (and ($Is this@@44 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@10|)))) true)
 :qid |MsgHistoryidfy.112:15|
 :skolemid |5434|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo this@@44 |lsn#0@@10|))
))))
(assert (forall ((this@@45 T@U) (|lsn#0@@11| Int) ) (!  (=> (= (type this@@45) DatatypeTypeType) (=> (and ($Is this@@45 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@11|)) (= (|MsgHistoryMod.MsgHistory.CanDiscardTo#requires| this@@45 |lsn#0@@11|) true)))
 :qid |MsgHistoryidfy.112:15|
 :skolemid |5435|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanDiscardTo#requires| this@@45 |lsn#0@@11|))
)))
(assert  (=> true (forall ((this@@46 T@U) (|lsn#0@@12| Int) ) (!  (=> (and (= (type this@@46) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| this@@46 |lsn#0@@12|) (and ($Is this@@46 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@12|)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@46) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@46) |lsn#0@@12|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@46))) (= (MsgHistoryMod.MsgHistory.CanDiscardTo this@@46 |lsn#0@@12|)  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@46) |lsn#0@@12|) (INTERNAL_le_boogie |lsn#0@@12| (MsgHistoryMod.MsgHistory.seqEnd this@@46))))))
 :qid |MsgHistoryidfy.112:15|
 :skolemid |5436|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo this@@46 |lsn#0@@12|))
))))
(assert  (=> true (forall ((this@@47 T@U) (|lsn#0@@13| Int) ) (!  (=> (and (= (type this@@47) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| (Lit this@@47) (LitInt |lsn#0@@13|)) (and ($Is this@@47 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@13|)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@47)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@47)) |lsn#0@@13|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@47)))) (= (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@47) (LitInt |lsn#0@@13|))  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@47)) |lsn#0@@13|) (INTERNAL_le_boogie |lsn#0@@13| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@47)))))))
 :qid |MsgHistoryidfy.112:15|
 :weight 3
 :skolemid |5437|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@47) (LitInt |lsn#0@@13|)))
))))
(assert (forall ((arg0@@568 T@U) (arg1@@278 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.DiscardOld arg0@@568 arg1@@278)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.DiscardOld|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld arg0@@568 arg1@@278))
)))
(assert  (=> true (forall ((this@@48 T@U) (|lsn#0@@14| Int) ) (!  (=> (and (= (type this@@48) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@48 |lsn#0@@14|) (and (and ($Is this@@48 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@14|)) (and (MsgHistoryMod.MsgHistory.WF this@@48) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@48 |lsn#0@@14|))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.DiscardOld this@@48 |lsn#0@@14|)) ($Is (MsgHistoryMod.MsgHistory.DiscardOld this@@48 |lsn#0@@14|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |5438|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld this@@48 |lsn#0@@14|))
))))
(assert (forall ((this@@49 T@U) (|lsn#0@@15| Int) ) (!  (=> (= (type this@@49) DatatypeTypeType) (=> (and ($Is this@@49 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@15|)) (= (|MsgHistoryMod.MsgHistory.DiscardOld#requires| this@@49 |lsn#0@@15|)  (and (MsgHistoryMod.MsgHistory.WF this@@49) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@49 |lsn#0@@15|)))))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |5439|
 :pattern ( (|MsgHistoryMod.MsgHistory.DiscardOld#requires| this@@49 |lsn#0@@15|))
)))
(assert  (=> true (forall ((this@@50 T@U) (|lsn#0@@16| Int) ) (!  (=> (and (= (type this@@50) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@50 |lsn#0@@16|) (and (and ($Is this@@50 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@16|)) (and (MsgHistoryMod.MsgHistory.WF this@@50) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@50 |lsn#0@@16|))))) (and (and (forall ((|k#0@@65| T@U) ) (!  (=> (= (type |k#0@@65|) intType) (and (=> (INTERNAL_le_boogie |lsn#0@@16| (U_2_int |k#0@@65|)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@50)) (=> (and (INTERNAL_le_boogie |lsn#0@@16| (U_2_int |k#0@@65|)) (INTERNAL_lt_boogie (U_2_int |k#0@@65|) (MsgHistoryMod.MsgHistory.seqEnd this@@50))) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@50))))
 :qid |MsgHistoryidfy.126:26|
 :skolemid |5440|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@50)) ($Box |k#0@@65|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@50)) (= (MsgHistoryMod.MsgHistory.DiscardOld this@@50 |lsn#0@@16|) (let ((|keepMap#0| (|Map#Glue| (|lambda#260| TInt |lsn#0@@16| (MsgHistoryMod.MsgHistory.seqEnd this@@50)) (|lambda#197| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@50))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#0| |lsn#0@@16| (MsgHistoryMod.MsgHistory.seqEnd this@@50))))))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |5441|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld this@@50 |lsn#0@@16|))
))))
(assert  (=> true (forall ((this@@51 T@U) (|lsn#0@@17| Int) ) (!  (=> (and (= (type this@@51) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| (Lit this@@51) (LitInt |lsn#0@@17|)) (and (and ($Is this@@51 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@17|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@51))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@51) (LitInt |lsn#0@@17|))))))))) (and (and (forall ((|k#0@@66| T@U) ) (!  (=> (= (type |k#0@@66|) intType) (and (=> (INTERNAL_le_boogie |lsn#0@@17| (U_2_int |k#0@@66|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@51))) (=> (and (INTERNAL_le_boogie |lsn#0@@17| (U_2_int |k#0@@66|)) (INTERNAL_lt_boogie (U_2_int |k#0@@66|) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@51)))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@51)))))
 :qid |MsgHistoryidfy.126:26|
 :skolemid |5442|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@51)) ($Box |k#0@@66|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@51))) (= (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@51) (LitInt |lsn#0@@17|)) (let ((|keepMap#1| (|Map#Glue| (|lambda#260| TInt |lsn#0@@17| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@51))) (|lambda#197| (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@51))))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#1| (LitInt |lsn#0@@17|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@51))))))))
 :qid |MsgHistoryidfy.121:14|
 :weight 3
 :skolemid |5443|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@51) (LitInt |lsn#0@@17|)))
))))
(assert (forall ((arg0@@569 T@U) (arg1@@279 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@569 arg1@@279)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.MaybeDiscardOld|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@569 arg1@@279))
)))
(assert  (=> true (forall ((this@@52 T@U) (|lsn#0@@18| Int) ) (!  (=> (and (= (type this@@52) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| this@@52 |lsn#0@@18|) (and (and ($Is this@@52 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@18|)) (and (MsgHistoryMod.MsgHistory.WF this@@52) (INTERNAL_le_boogie |lsn#0@@18| (MsgHistoryMod.MsgHistory.seqEnd this@@52)))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@52 |lsn#0@@18|)) ($Is (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@52 |lsn#0@@18|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |5444|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@52 |lsn#0@@18|))
))))
(assert (forall ((this@@53 T@U) (|lsn#0@@19| Int) ) (!  (=> (= (type this@@53) DatatypeTypeType) (=> (and ($Is this@@53 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@19|)) (= (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| this@@53 |lsn#0@@19|)  (and (MsgHistoryMod.MsgHistory.WF this@@53) (INTERNAL_le_boogie |lsn#0@@19| (MsgHistoryMod.MsgHistory.seqEnd this@@53))))))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |5445|
 :pattern ( (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| this@@53 |lsn#0@@19|))
)))
(assert  (=> true (forall ((this@@54 T@U) (|lsn#0@@20| Int) ) (!  (=> (and (= (type this@@54) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| this@@54 |lsn#0@@20|) (and (and ($Is this@@54 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@20|)) (and (MsgHistoryMod.MsgHistory.WF this@@54) (INTERNAL_le_boogie |lsn#0@@20| (MsgHistoryMod.MsgHistory.seqEnd this@@54)))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@54) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@54) |lsn#0@@20|) (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@54 |lsn#0@@20|))) (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@54 |lsn#0@@20|) (ite (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@54) |lsn#0@@20|) (MsgHistoryMod.MsgHistory.DiscardOld this@@54 |lsn#0@@20|) this@@54))))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |5446|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@54 |lsn#0@@20|))
))))
(assert  (=> true (forall ((this@@55 T@U) (|lsn#0@@21| Int) ) (!  (=> (and (= (type this@@55) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| (Lit this@@55) (LitInt |lsn#0@@21|)) (and (and ($Is this@@55 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@21|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@55))))) (INTERNAL_le_boogie |lsn#0@@21| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@55))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@55)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@55)) |lsn#0@@21|) (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| (Lit this@@55) (LitInt |lsn#0@@21|)))) (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld (Lit this@@55) (LitInt |lsn#0@@21|)) (ite (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@55)) |lsn#0@@21|) (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@55) (LitInt |lsn#0@@21|)) this@@55))))
 :qid |MsgHistoryidfy.130:14|
 :weight 3
 :skolemid |5447|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld (Lit this@@55) (LitInt |lsn#0@@21|)))
))))
(assert  (=> true (forall ((this@@56 T@U) (|lsn#0@@22| Int) ) (!  (=> (and (= (type this@@56) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@56 |lsn#0@@22|) (and (and ($Is this@@56 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@22|)) (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@56 |lsn#0@@22|) (MsgHistoryMod.MsgHistory.WF this@@56))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.DiscardRecent this@@56 |lsn#0@@22|)) ($Is (MsgHistoryMod.MsgHistory.DiscardRecent this@@56 |lsn#0@@22|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |5448|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent this@@56 |lsn#0@@22|))
))))
(assert (forall ((this@@57 T@U) (|lsn#0@@23| Int) ) (!  (=> (= (type this@@57) DatatypeTypeType) (=> (and ($Is this@@57 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@23|)) (= (|MsgHistoryMod.MsgHistory.DiscardRecent#requires| this@@57 |lsn#0@@23|)  (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@57 |lsn#0@@23|) (MsgHistoryMod.MsgHistory.WF this@@57)))))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |5449|
 :pattern ( (|MsgHistoryMod.MsgHistory.DiscardRecent#requires| this@@57 |lsn#0@@23|))
)))
(assert  (=> true (forall ((this@@58 T@U) (|lsn#0@@24| Int) ) (!  (=> (and (= (type this@@58) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@58 |lsn#0@@24|) (and (and ($Is this@@58 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@24|)) (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@58 |lsn#0@@24|) (MsgHistoryMod.MsgHistory.WF this@@58))))) (and (and (forall ((|k#0@@67| T@U) ) (!  (=> (= (type |k#0@@67|) intType) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@58) (=> (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@58) (U_2_int |k#0@@67|)) (INTERNAL_lt_boogie (U_2_int |k#0@@67|) |lsn#0@@24|)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@58))))
 :qid |MsgHistoryidfy.145:26|
 :skolemid |5450|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@58)) ($Box |k#0@@67|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@58)) (= (MsgHistoryMod.MsgHistory.DiscardRecent this@@58 |lsn#0@@24|) (let ((|keepMap#0@@0| (|Map#Glue| (|lambda#260| TInt (MsgHistoryMod.MsgHistory.seqStart this@@58) |lsn#0@@24|) (|lambda#197| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@58))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#0@@0| (MsgHistoryMod.MsgHistory.seqStart this@@58) |lsn#0@@24|)))))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |5451|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent this@@58 |lsn#0@@24|))
))))
(assert  (=> true (forall ((this@@59 T@U) (|lsn#0@@25| Int) ) (!  (=> (and (= (type this@@59) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@59) (LitInt |lsn#0@@25|)) (and (and ($Is this@@59 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@25|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@59) (LitInt |lsn#0@@25|))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@59))))))))) (and (and (forall ((|k#0@@68| T@U) ) (!  (=> (= (type |k#0@@68|) intType) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@59)) (=> (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@59)) (U_2_int |k#0@@68|)) (INTERNAL_lt_boogie (U_2_int |k#0@@68|) |lsn#0@@25|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@59)))))
 :qid |MsgHistoryidfy.145:26|
 :skolemid |5452|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@59)) ($Box |k#0@@68|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@59))) (= (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@59) (LitInt |lsn#0@@25|)) (let ((|keepMap#1@@0| (|Map#Glue| (|lambda#260| TInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@59)) |lsn#0@@25|) (|lambda#197| (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@59))))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#1@@0| (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@59))) (LitInt |lsn#0@@25|))))))
 :qid |MsgHistoryidfy.140:14|
 :weight 3
 :skolemid |5453|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@59) (LitInt |lsn#0@@25|)))
))))
(assert  (=> true (forall ((this@@60 T@U) (|subseq#0| T@U) ) (!  (=> (and (and (and (= (type this@@60) DatatypeTypeType) (= (type |subseq#0|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| this@@60 |subseq#0|) (and (and ($Is this@@60 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@60) (MsgHistoryMod.MsgHistory.WF |subseq#0|))))) (and (MsgHistoryMod.MsgHistory.IncludesSubseq this@@60 |subseq#0|) (MsgHistoryMod.MsgHistory.IsEmpty this@@60))) (MsgHistoryMod.MsgHistory.IsEmpty |subseq#0|))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |5454|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq this@@60 |subseq#0|))
))))
(assert (forall ((this@@61 T@U) (|subseq#0@@0| T@U) ) (!  (=> (and (and (= (type this@@61) DatatypeTypeType) (= (type |subseq#0@@0|) DatatypeTypeType)) (and ($Is this@@61 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@0| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.IncludesSubseq#requires| this@@61 |subseq#0@@0|)  (and (MsgHistoryMod.MsgHistory.WF this@@61) (MsgHistoryMod.MsgHistory.WF |subseq#0@@0|))))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |5455|
 :pattern ( (|MsgHistoryMod.MsgHistory.IncludesSubseq#requires| this@@61 |subseq#0@@0|))
)))
(assert  (=> true (forall ((this@@62 T@U) (|subseq#0@@1| T@U) ) (!  (=> (and (and (= (type this@@62) DatatypeTypeType) (= (type |subseq#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| this@@62 |subseq#0@@1|) (and (and ($Is this@@62 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@62) (MsgHistoryMod.MsgHistory.WF |subseq#0@@1|))))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@62) (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@62) (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|)) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@62)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|) (MsgHistoryMod.MsgHistory.seqEnd this@@62)) (forall ((|lsn#0@@26| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@26|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| |subseq#0@@1| |lsn#0@@26|) (=> (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@26|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@62 |lsn#0@@26|) (=> (MsgHistoryMod.MsgHistory.Contains this@@62 |lsn#0@@26|) (and (and (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@62)) ($Box (int_2_U |lsn#0@@26|))))) (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@26|)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@62) (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|))))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |5457|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@26|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@62)) ($Box (int_2_U |lsn#0@@26|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@62 |lsn#0@@26|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@26|))
)))))) (= (MsgHistoryMod.MsgHistory.IncludesSubseq this@@62 |subseq#0@@1|)  (and (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@62) (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|)) (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|) (MsgHistoryMod.MsgHistory.seqEnd this@@62))) (let ((|result#0| (forall ((|lsn#0@@27| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |lsn#0@@27|) (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@27|)) (and (MsgHistoryMod.MsgHistory.Contains this@@62 |lsn#0@@27|) (|MsgHistoryMod.KeyedMessage#Equal| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@62)) ($Box (int_2_U |lsn#0@@27|)))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@27|)))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |5456|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@27|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@62)) ($Box (int_2_U |lsn#0@@27|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@62 |lsn#0@@27|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@27|))
))))
|result#0|)))))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |5459|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq this@@62 |subseq#0@@1|))
))))
(assert  (=> true (forall ((this@@63 T@U) (|subseq#0@@2| T@U) ) (!  (=> (and (and (= (type this@@63) DatatypeTypeType) (= (type |subseq#0@@2|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| (Lit this@@63) (Lit |subseq#0@@2|)) (and (and ($Is this@@63 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@63))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |subseq#0@@2|))))))))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@63)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@63)) (MsgHistoryMod.MsgHistory.seqStart (Lit |subseq#0@@2|))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@63))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@63))) (forall ((|lsn#1@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1@@2|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit |subseq#0@@2|) |lsn#1@@2|) (=> (MsgHistoryMod.MsgHistory.Contains (Lit |subseq#0@@2|) |lsn#1@@2|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@63) |lsn#1@@2|) (=> (MsgHistoryMod.MsgHistory.Contains (Lit this@@63) |lsn#1@@2|) (and (and (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@63)))) ($Box (int_2_U |lsn#1@@2|))))) (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |subseq#0@@2|)))) ($Box (int_2_U |lsn#1@@2|)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@63)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|)))))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |5461|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@2|)) ($Box (int_2_U |lsn#1@@2|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@63)) ($Box (int_2_U |lsn#1@@2|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@63 |lsn#1@@2|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@2| |lsn#1@@2|))
)))))) (= (MsgHistoryMod.MsgHistory.IncludesSubseq (Lit this@@63) (Lit |subseq#0@@2|))  (and (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@63)) (MsgHistoryMod.MsgHistory.seqStart (Lit |subseq#0@@2|))) (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@63)))) (let ((|result#1| (forall ((|lsn#1@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |lsn#1@@3|) (MsgHistoryMod.MsgHistory.Contains (Lit |subseq#0@@2|) |lsn#1@@3|)) (and (MsgHistoryMod.MsgHistory.Contains (Lit this@@63) |lsn#1@@3|) (|MsgHistoryMod.KeyedMessage#Equal| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@63)))) ($Box (int_2_U |lsn#1@@3|)))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |subseq#0@@2|)))) ($Box (int_2_U |lsn#1@@3|)))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |5460|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@2|)) ($Box (int_2_U |lsn#1@@3|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@63)) ($Box (int_2_U |lsn#1@@3|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@63 |lsn#1@@3|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@2| |lsn#1@@3|))
))))
|result#1|)))))
 :qid |MsgHistoryidfy.149:15|
 :weight 3
 :skolemid |5463|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq (Lit this@@63) (Lit |subseq#0@@2|)))
))))
(assert (= (type Tclass.MsgHistoryMod.__default) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.__default) Tagclass.MsgHistoryMod.__default))
(assert (= (TagFamily Tclass.MsgHistoryMod.__default) tytagFamily$_default))
(assert (forall ((bx@@164 T@U) ) (!  (=> (and (= (type bx@@164) BoxType) ($IsBox bx@@164 Tclass.MsgHistoryMod.__default)) (and (= ($Box ($Unbox refType bx@@164)) bx@@164) ($Is ($Unbox refType bx@@164) Tclass.MsgHistoryMod.__default)))
 :qid |unknown.0:0|
 :skolemid |5464|
 :pattern ( ($IsBox bx@@164 Tclass.MsgHistoryMod.__default))
)))
(assert (forall (($o@@45 T@U) ) (!  (=> (= (type $o@@45) refType) (= ($Is $o@@45 Tclass.MsgHistoryMod.__default)  (or (= $o@@45 null) (= (dtype $o@@45) Tclass.MsgHistoryMod.__default))))
 :qid |unknown.0:0|
 :skolemid |5465|
 :pattern ( ($Is $o@@45 Tclass.MsgHistoryMod.__default))
)))
(assert (forall (($o@@46 T@U) ($h@@100 T@U) ) (!  (=> (and (= (type $o@@46) refType) (= (type $h@@100) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@100)  (or (= $o@@46 null) (U_2_bool (MapType1Select (MapType0Select $h@@100 $o@@46) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5466|
 :pattern ( ($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@100))
)))
(assert (forall ((arg0@@570 Int) ) (! (= (type (MsgHistoryMod.__default.EmptyHistoryAt arg0@@570)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.EmptyHistoryAt|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt arg0@@570))
)))
(assert  (=> true (forall ((|lsn#0@@28| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| |lsn#0@@28|) (INTERNAL_le_boogie 0 |lsn#0@@28|)) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|)) ($Is (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |5467|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|))
))))
(assert (forall ((|lsn#0@@29| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@29|) (= (|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|) true))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |5468|
 :pattern ( (|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|))
)))
(assert  (=> true (forall ((|lsn#0@@30| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| |lsn#0@@30|) (INTERNAL_le_boogie 0 |lsn#0@@30|)) (= (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@30|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Empty| BoxType BoxType)) |lsn#0@@30| |lsn#0@@30|)))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |5469|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@30|))
))))
(assert  (=> true (forall ((|lsn#0@@31| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| (LitInt |lsn#0@@31|)) (INTERNAL_le_boogie 0 |lsn#0@@31|)) (= (MsgHistoryMod.__default.EmptyHistoryAt (LitInt |lsn#0@@31|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Empty| BoxType BoxType)) (LitInt |lsn#0@@31|) (LitInt |lsn#0@@31|)))))
 :qid |MsgHistoryidfy.162:27|
 :weight 3
 :skolemid |5470|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt (LitInt |lsn#0@@31|)))
))))
(assert (forall ((arg0@@571 Int) (arg1@@280 T@U) ) (! (= (type (MsgHistoryMod.__default.SingletonAt arg0@@571 arg1@@280)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.SingletonAt|
 :pattern ( (MsgHistoryMod.__default.SingletonAt arg0@@571 arg1@@280))
)))
(assert  (=> true (forall ((|lsn#0@@32| Int) (|msg#0@@3| T@U) ) (!  (=> (and (= (type |msg#0@@3|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| |lsn#0@@32| |msg#0@@3|) (and (INTERNAL_le_boogie 0 |lsn#0@@32|) ($Is |msg#0@@3| Tclass.MsgHistoryMod.KeyedMessage)))) ($Is (MsgHistoryMod.__default.SingletonAt |lsn#0@@32| |msg#0@@3|) Tclass.MsgHistoryMod.MsgHistory))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |5471|
 :pattern ( (MsgHistoryMod.__default.SingletonAt |lsn#0@@32| |msg#0@@3|))
))))
(assert (forall ((|lsn#0@@33| Int) (|msg#0@@4| T@U) ) (!  (=> (= (type |msg#0@@4|) DatatypeTypeType) (=> (and (INTERNAL_le_boogie 0 |lsn#0@@33|) ($Is |msg#0@@4| Tclass.MsgHistoryMod.KeyedMessage)) (= (|MsgHistoryMod.__default.SingletonAt#requires| |lsn#0@@33| |msg#0@@4|) true)))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |5472|
 :pattern ( (|MsgHistoryMod.__default.SingletonAt#requires| |lsn#0@@33| |msg#0@@4|))
)))
(assert  (=> true (forall ((|lsn#0@@34| Int) (|msg#0@@5| T@U) ) (!  (=> (and (= (type |msg#0@@5|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| |lsn#0@@34| |msg#0@@5|) (and (INTERNAL_le_boogie 0 |lsn#0@@34|) ($Is |msg#0@@5| Tclass.MsgHistoryMod.KeyedMessage)))) (= (MsgHistoryMod.__default.SingletonAt |lsn#0@@34| |msg#0@@5|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (|Map#Build| (|Map#Empty| BoxType BoxType) ($Box (int_2_U |lsn#0@@34|)) ($Box |msg#0@@5|)) |lsn#0@@34| (INTERNAL_add_boogie |lsn#0@@34| 1))))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |5473|
 :pattern ( (MsgHistoryMod.__default.SingletonAt |lsn#0@@34| |msg#0@@5|))
))))
(assert  (=> true (forall ((|lsn#0@@35| Int) (|msg#0@@6| T@U) ) (!  (=> (and (= (type |msg#0@@6|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)) (and (INTERNAL_le_boogie 0 |lsn#0@@35|) ($Is |msg#0@@6| Tclass.MsgHistoryMod.KeyedMessage)))) (= (MsgHistoryMod.__default.SingletonAt (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Build| (|Map#Empty| BoxType BoxType) ($Box (int_2_U (LitInt |lsn#0@@35|))) ($Box (Lit |msg#0@@6|)))) (LitInt |lsn#0@@35|) (LitInt (INTERNAL_add_boogie |lsn#0@@35| 1))))))
 :qid |MsgHistoryidfy.168:24|
 :weight 3
 :skolemid |5474|
 :pattern ( (MsgHistoryMod.__default.SingletonAt (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)))
))))
(assert (forall ((arg0@@572 T@U) (arg1@@281 T@U) ) (! (= (type (MsgHistoryMod.__default.MapPlusHistory arg0@@572 arg1@@281)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.MapPlusHistory|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory arg0@@572 arg1@@281))
)))
(assert  (=> true (forall ((|stampedMap#0| T@U) (|history#0| T@U) ) (!  (=> (and (and (= (type |stampedMap#0|) DatatypeTypeType) (= (type |history#0|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| |stampedMap#0| |history#0|) (and (and ($Is |stampedMap#0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |history#0|) (MsgHistoryMod.MsgHistory.CanFollow |history#0| (StampedMod.Stamped.seqEnd |stampedMap#0|)))))) ($Is (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0| |history#0|) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |5475|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0| |history#0|))
))))
(assert (forall ((|stampedMap#0@@0| T@U) (|history#0@@0| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@0|) DatatypeTypeType) (= (type |history#0@@0|) DatatypeTypeType)) (and ($Is |stampedMap#0@@0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@0| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.__default.MapPlusHistory#requires| |stampedMap#0@@0| |history#0@@0|)  (and (MsgHistoryMod.MsgHistory.WF |history#0@@0|) (MsgHistoryMod.MsgHistory.CanFollow |history#0@@0| (StampedMod.Stamped.seqEnd |stampedMap#0@@0|)))))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |5476|
 :pattern ( (|MsgHistoryMod.__default.MapPlusHistory#requires| |stampedMap#0@@0| |history#0@@0|))
)))
(assert  (=> true (forall ((|stampedMap#0@@1| T@U) (|history#0@@1| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@1|) DatatypeTypeType) (= (type |history#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| |stampedMap#0@@1| |history#0@@1|) (and (and ($Is |stampedMap#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |history#0@@1|) (MsgHistoryMod.MsgHistory.CanFollow |history#0@@1| (StampedMod.Stamped.seqEnd |stampedMap#0@@1|)))))) (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| |history#0@@1| |stampedMap#0@@1|) (= (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0@@1| |history#0@@1|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $LZ) |history#0@@1| |stampedMap#0@@1|))))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |5477|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0@@1| |history#0@@1|))
))))
(assert  (=> true (forall ((|stampedMap#0@@2| T@U) (|history#0@@2| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@2|) DatatypeTypeType) (= (type |history#0@@2|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)) (and (and ($Is |stampedMap#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |history#0@@2|))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit |history#0@@2|) (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedMap#0@@2|))))))))))) (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit |history#0@@2|) (Lit |stampedMap#0@@2|)) (= (MsgHistoryMod.__default.MapPlusHistory (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)) (Lit (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $LZ) (Lit |history#0@@2|) (Lit |stampedMap#0@@2|))))))
 :qid |MsgHistoryidfy.178:27|
 :weight 3
 :skolemid |5478|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)))
))))
(assert (forall ((arg0@@573 T@U) ) (! (= (type (|#Buffers.Buffer.Buffer| arg0@@573)) DatatypeTypeType)
 :qid |funType:#Buffers.Buffer.Buffer|
 :pattern ( (|#Buffers.Buffer.Buffer| arg0@@573))
)))
(assert (forall ((|a#0#0#0@@3| T@U) ) (!  (=> (= (type |a#0#0#0@@3|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#Buffers.Buffer.Buffer| |a#0#0#0@@3|)) |##Buffers.Buffer.Buffer|))
 :qid |Buffersidfy.25:28|
 :skolemid |5479|
 :pattern ( (|#Buffers.Buffer.Buffer| |a#0#0#0@@3|))
)))
(assert (forall ((d@@55 T@U) ) (!  (=> (= (type d@@55) DatatypeTypeType) (= (Buffers.Buffer.Buffer_q d@@55) (= (DatatypeCtorId d@@55) |##Buffers.Buffer.Buffer|)))
 :qid |unknown.0:0|
 :skolemid |5480|
 :pattern ( (Buffers.Buffer.Buffer_q d@@55))
)))
(assert (forall ((d@@56 T@U) ) (!  (=> (and (= (type d@@56) DatatypeTypeType) (Buffers.Buffer.Buffer_q d@@56)) (exists ((|a#1#0#0@@3| T@U) ) (!  (and (= (type |a#1#0#0@@3|) (MapType BoxType BoxType)) (= d@@56 (|#Buffers.Buffer.Buffer| |a#1#0#0@@3|)))
 :qid |Buffersidfy.25:28|
 :skolemid |5481|
 :no-pattern (type |a#1#0#0@@3|)
 :no-pattern (U_2_int |a#1#0#0@@3|)
 :no-pattern (U_2_bool |a#1#0#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |5482|
 :pattern ( (Buffers.Buffer.Buffer_q d@@56))
)))
(assert (= (type Tclass.Buffers.Buffer) TyType))
(assert (= (Tag Tclass.Buffers.Buffer) Tagclass.Buffers.Buffer))
(assert (= (TagFamily Tclass.Buffers.Buffer) tytagFamily$Buffer))
(assert (forall ((bx@@165 T@U) ) (!  (=> (and (= (type bx@@165) BoxType) ($IsBox bx@@165 Tclass.Buffers.Buffer)) (and (= ($Box ($Unbox DatatypeTypeType bx@@165)) bx@@165) ($Is ($Unbox DatatypeTypeType bx@@165) Tclass.Buffers.Buffer)))
 :qid |unknown.0:0|
 :skolemid |5483|
 :pattern ( ($IsBox bx@@165 Tclass.Buffers.Buffer))
)))
(assert (forall ((|a#2#0#0@@3| T@U) ) (!  (=> (= (type |a#2#0#0@@3|) (MapType BoxType BoxType)) (= ($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@3|) Tclass.Buffers.Buffer) ($Is |a#2#0#0@@3| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))
 :qid |Buffersidfy.25:28|
 :skolemid |5484|
 :pattern ( ($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@3|) Tclass.Buffers.Buffer))
)))
(assert (forall ((|a#3#0#0@@3| T@U) ($h@@101 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@3|) (MapType BoxType BoxType)) (= (type $h@@101) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@101)) (= ($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@3|) Tclass.Buffers.Buffer $h@@101) ($IsAlloc |a#3#0#0@@3| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@101)))
 :qid |Buffersidfy.25:28|
 :skolemid |5485|
 :pattern ( ($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@3|) Tclass.Buffers.Buffer $h@@101))
)))
(assert (forall ((arg0@@574 T@U) ) (! (= (type (Buffers.Buffer.mapp arg0@@574)) (MapType BoxType BoxType))
 :qid |funType:Buffers.Buffer.mapp|
 :pattern ( (Buffers.Buffer.mapp arg0@@574))
)))
(assert (forall ((d@@57 T@U) ($h@@102 T@U) ) (!  (=> (and (and (= (type d@@57) DatatypeTypeType) (= (type $h@@102) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@102) (and (Buffers.Buffer.Buffer_q d@@57) ($IsAlloc d@@57 Tclass.Buffers.Buffer $h@@102)))) ($IsAlloc (Buffers.Buffer.mapp d@@57) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@102))
 :qid |unknown.0:0|
 :skolemid |5486|
 :pattern ( ($IsAlloc (Buffers.Buffer.mapp d@@57) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@102))
)))
(assert (forall ((|a#4#0#0@@3| T@U) ) (!  (=> (= (type |a#4#0#0@@3|) (MapType BoxType BoxType)) (= (|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@3|)) (Lit (|#Buffers.Buffer.Buffer| |a#4#0#0@@3|))))
 :qid |Buffersidfy.25:28|
 :skolemid |5487|
 :pattern ( (|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@3|)))
)))
(assert (forall ((|a#5#0#0@@4| T@U) ) (!  (=> (= (type |a#5#0#0@@4|) (MapType BoxType BoxType)) (= (Buffers.Buffer.mapp (|#Buffers.Buffer.Buffer| |a#5#0#0@@4|)) |a#5#0#0@@4|))
 :qid |Buffersidfy.25:28|
 :skolemid |5488|
 :pattern ( (|#Buffers.Buffer.Buffer| |a#5#0#0@@4|))
)))
(assert (forall ((|a#6#0#0@@4| T@U) (d@@58 T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@4|) (MapType BoxType BoxType)) (= (type d@@58) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@4|) ($Box d@@58)))) (< (DtRank d@@58) (DtRank (|#Buffers.Buffer.Buffer| |a#6#0#0@@4|))))
 :qid |Buffersidfy.25:28|
 :skolemid |5489|
 :pattern ( (MapType0Select (|Map#Domain| |a#6#0#0@@4|) ($Box d@@58)) (|#Buffers.Buffer.Buffer| |a#6#0#0@@4|))
)))
(assert (forall ((|a#7#0#0@@4| T@U) (bx@@166 T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@4|) (MapType BoxType BoxType)) (= (type bx@@166) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@4|) bx@@166))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#7#0#0@@4|) bx@@166))) (DtRank (|#Buffers.Buffer.Buffer| |a#7#0#0@@4|))))
 :qid |Buffersidfy.25:28|
 :skolemid |5490|
 :pattern ( (MapType0Select (|Map#Domain| |a#7#0#0@@4|) bx@@166) (|#Buffers.Buffer.Buffer| |a#7#0#0@@4|))
)))
(assert (forall ((d@@59 T@U) ) (!  (=> (and (= (type d@@59) DatatypeTypeType) (|$IsA#Buffers.Buffer| d@@59)) (Buffers.Buffer.Buffer_q d@@59))
 :qid |unknown.0:0|
 :skolemid |5491|
 :pattern ( (|$IsA#Buffers.Buffer| d@@59))
)))
(assert (forall ((d@@60 T@U) ) (!  (=> (and (= (type d@@60) DatatypeTypeType) ($Is d@@60 Tclass.Buffers.Buffer)) (Buffers.Buffer.Buffer_q d@@60))
 :qid |unknown.0:0|
 :skolemid |5492|
 :pattern ( (Buffers.Buffer.Buffer_q d@@60) ($Is d@@60 Tclass.Buffers.Buffer))
)))
(assert (forall ((a@@132 T@U) (b@@82 T@U) ) (!  (=> (and (and (= (type a@@132) DatatypeTypeType) (= (type b@@82) DatatypeTypeType)) true) (= (|Buffers.Buffer#Equal| a@@132 b@@82) (|Map#Equal| (Buffers.Buffer.mapp a@@132) (Buffers.Buffer.mapp b@@82))))
 :qid |unknown.0:0|
 :skolemid |5493|
 :pattern ( (|Buffers.Buffer#Equal| a@@132 b@@82))
)))
(assert (forall ((a@@133 T@U) (b@@83 T@U) ) (!  (=> (and (= (type a@@133) DatatypeTypeType) (= (type b@@83) DatatypeTypeType)) (= (|Buffers.Buffer#Equal| a@@133 b@@83) (= a@@133 b@@83)))
 :qid |unknown.0:0|
 :skolemid |5494|
 :pattern ( (|Buffers.Buffer#Equal| a@@133 b@@83))
)))
(assert (forall ((arg0@@575 T@U) (arg1@@282 T@U) ) (! (= (type (Buffers.Buffer.Query arg0@@575 arg1@@282)) DatatypeTypeType)
 :qid |funType:Buffers.Buffer.Query|
 :pattern ( (Buffers.Buffer.Query arg0@@575 arg1@@282))
)))
(assert  (=> true (forall ((this@@64 T@U) (|key#0@@20| T@U) ) (!  (=> (and (and (= (type this@@64) DatatypeTypeType) (= (type |key#0@@20|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| this@@64 |key#0@@20|) (and ($Is this@@64 Tclass.Buffers.Buffer) ($Is |key#0@@20| Tclass.KeyType.Key)))) ($Is (Buffers.Buffer.Query this@@64 |key#0@@20|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.27:14|
 :skolemid |5495|
 :pattern ( (Buffers.Buffer.Query this@@64 |key#0@@20|))
))))
(assert (forall ((this@@65 T@U) (|key#0@@21| T@U) ) (!  (=> (and (and (= (type this@@65) DatatypeTypeType) (= (type |key#0@@21|) (SeqType BoxType))) (and ($Is this@@65 Tclass.Buffers.Buffer) ($Is |key#0@@21| Tclass.KeyType.Key))) (= (|Buffers.Buffer.Query#requires| this@@65 |key#0@@21|) true))
 :qid |Buffersidfy.27:14|
 :skolemid |5496|
 :pattern ( (|Buffers.Buffer.Query#requires| this@@65 |key#0@@21|))
)))
(assert  (=> true (forall ((this@@66 T@U) (|key#0@@22| T@U) ) (!  (=> (and (and (= (type this@@66) DatatypeTypeType) (= (type |key#0@@22|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| this@@66 |key#0@@22|) (and ($Is this@@66 Tclass.Buffers.Buffer) ($Is |key#0@@22| Tclass.KeyType.Key)))) (and (and (and (Buffers.Buffer.Buffer_q this@@66) (=> (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@66)) ($Box |key#0@@22|))) (Buffers.Buffer.Buffer_q this@@66))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@66)) ($Box |key#0@@22|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (Buffers.Buffer.Query this@@66 |key#0@@22|) (ite (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@66)) ($Box |key#0@@22|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@66)) ($Box |key#0@@22|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Buffersidfy.27:14|
 :skolemid |5497|
 :pattern ( (Buffers.Buffer.Query this@@66 |key#0@@22|))
))))
(assert  (=> true (forall ((this@@67 T@U) (|key#0@@23| T@U) ) (!  (=> (and (and (= (type this@@67) DatatypeTypeType) (= (type |key#0@@23|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| (Lit this@@67) (Lit |key#0@@23|)) (and ($Is this@@67 Tclass.Buffers.Buffer) ($Is |key#0@@23| Tclass.KeyType.Key)))) (and (and (and (Buffers.Buffer.Buffer_q (Lit this@@67)) (=> (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@67))) ($Box |key#0@@23|))) (Buffers.Buffer.Buffer_q (Lit this@@67)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@67))) ($Box |key#0@@23|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (Buffers.Buffer.Query (Lit this@@67) (Lit |key#0@@23|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@67))) ($Box |key#0@@23|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@67)))) ($Box (Lit |key#0@@23|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Buffersidfy.27:14|
 :weight 3
 :skolemid |5498|
 :pattern ( (Buffers.Buffer.Query (Lit this@@67) (Lit |key#0@@23|)))
))))
(assert (forall ((arg0@@576 T@U) (arg1@@283 T@U) ) (! (= (type (Buffers.Buffer.ApplyFilter arg0@@576 arg1@@283)) DatatypeTypeType)
 :qid |funType:Buffers.Buffer.ApplyFilter|
 :pattern ( (Buffers.Buffer.ApplyFilter arg0@@576 arg1@@283))
)))
(assert  (=> true (forall ((this@@68 T@U) (|accept#0| T@U) ) (!  (=> (and (and (= (type this@@68) DatatypeTypeType) (= (type |accept#0|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| this@@68 |accept#0|) (and ($Is this@@68 Tclass.Buffers.Buffer) ($Is |accept#0| (TISet Tclass.KeyType.Key))))) ($Is (Buffers.Buffer.ApplyFilter this@@68 |accept#0|) Tclass.Buffers.Buffer))
 :qid |Buffersidfy.32:14|
 :skolemid |5499|
 :pattern ( (Buffers.Buffer.ApplyFilter this@@68 |accept#0|))
))))
(assert (forall ((this@@69 T@U) (|accept#0@@0| T@U) ) (!  (=> (and (and (= (type this@@69) DatatypeTypeType) (= (type |accept#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@69 Tclass.Buffers.Buffer) ($Is |accept#0@@0| (TISet Tclass.KeyType.Key)))) (= (|Buffers.Buffer.ApplyFilter#requires| this@@69 |accept#0@@0|) true))
 :qid |Buffersidfy.32:14|
 :skolemid |5500|
 :pattern ( (|Buffers.Buffer.ApplyFilter#requires| this@@69 |accept#0@@0|))
)))
(assert  (=> true (forall ((this@@70 T@U) (|accept#0@@1| T@U) ) (!  (=> (and (and (= (type this@@70) DatatypeTypeType) (= (type |accept#0@@1|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| this@@70 |accept#0@@1|) (and ($Is this@@70 Tclass.Buffers.Buffer) ($Is |accept#0@@1| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@69| T@U) ) (!  (=> (and (= (type |k#0@@69|) (SeqType BoxType)) ($Is |k#0@@69| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q this@@70) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@70)) ($Box |k#0@@69|))) (U_2_bool (MapType0Select |accept#0@@1| ($Box |k#0@@69|)))) (Buffers.Buffer.Buffer_q this@@70))))
 :qid |Buffersidfy.34:18|
 :skolemid |5501|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@70)) ($Box |k#0@@69|))))
 :pattern ( (MapType0Select |accept#0@@1| ($Box |k#0@@69|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@70)) ($Box |k#0@@69|)))
)) (= (Buffers.Buffer.ApplyFilter this@@70 |accept#0@@1|) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#218| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp this@@70)) |accept#0@@1|) (|lambda#197| (|Map#Elements| (Buffers.Buffer.mapp this@@70))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :skolemid |5502|
 :pattern ( (Buffers.Buffer.ApplyFilter this@@70 |accept#0@@1|))
))))
(assert  (=> true (forall ((this@@71 T@U) (|accept#0@@2| T@U) ) (!  (=> (and (and (= (type this@@71) DatatypeTypeType) (= (type |accept#0@@2|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| (Lit this@@71) |accept#0@@2|) (and ($Is this@@71 Tclass.Buffers.Buffer) ($Is |accept#0@@2| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@70| T@U) ) (!  (=> (and (= (type |k#0@@70|) (SeqType BoxType)) ($Is |k#0@@70| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q (Lit this@@71)) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@71))) ($Box |k#0@@70|))) (U_2_bool (MapType0Select |accept#0@@2| ($Box |k#0@@70|)))) (Buffers.Buffer.Buffer_q (Lit this@@71)))))
 :qid |Buffersidfy.34:18|
 :skolemid |5503|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@71)) ($Box |k#0@@70|))))
 :pattern ( (MapType0Select |accept#0@@2| ($Box |k#0@@70|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@71)) ($Box |k#0@@70|)))
)) (= (Buffers.Buffer.ApplyFilter (Lit this@@71) |accept#0@@2|) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#218| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@71))) |accept#0@@2|) (|lambda#197| (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@71))))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :weight 3
 :skolemid |5504|
 :pattern ( (Buffers.Buffer.ApplyFilter (Lit this@@71) |accept#0@@2|))
))))
(assert  (=> true (forall ((this@@72 T@U) (|accept#0@@3| T@U) ) (!  (=> (and (and (= (type this@@72) DatatypeTypeType) (= (type |accept#0@@3|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| (Lit this@@72) (Lit |accept#0@@3|)) (and ($Is this@@72 Tclass.Buffers.Buffer) ($Is |accept#0@@3| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@71| T@U) ) (!  (=> (and (= (type |k#0@@71|) (SeqType BoxType)) ($Is |k#0@@71| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q (Lit this@@72)) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@72))) ($Box |k#0@@71|))) (U_2_bool (MapType0Select (Lit |accept#0@@3|) ($Box |k#0@@71|)))) (Buffers.Buffer.Buffer_q (Lit this@@72)))))
 :qid |Buffersidfy.34:18|
 :skolemid |5505|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@72)) ($Box |k#0@@71|))))
 :pattern ( (MapType0Select |accept#0@@3| ($Box |k#0@@71|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@72)) ($Box |k#0@@71|)))
)) (= (Buffers.Buffer.ApplyFilter (Lit this@@72) (Lit |accept#0@@3|)) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#218| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@72))) (Lit |accept#0@@3|)) (|lambda#197| (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@72))))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :weight 3
 :skolemid |5506|
 :pattern ( (Buffers.Buffer.ApplyFilter (Lit this@@72) (Lit |accept#0@@3|)))
))))
(assert (forall ((arg0@@577 T@U) ) (! (= (type (|#Buffers.BufferStack.BufferStack| arg0@@577)) DatatypeTypeType)
 :qid |funType:#Buffers.BufferStack.BufferStack|
 :pattern ( (|#Buffers.BufferStack.BufferStack| arg0@@577))
)))
(assert (forall ((|a#0#0#0@@4| T@U) ) (!  (=> (= (type |a#0#0#0@@4|) (SeqType BoxType)) (= (DatatypeCtorId (|#Buffers.BufferStack.BufferStack| |a#0#0#0@@4|)) |##Buffers.BufferStack.BufferStack|))
 :qid |Buffersidfy.39:38|
 :skolemid |5507|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#0#0#0@@4|))
)))
(assert (forall ((d@@61 T@U) ) (!  (=> (= (type d@@61) DatatypeTypeType) (= (Buffers.BufferStack.BufferStack_q d@@61) (= (DatatypeCtorId d@@61) |##Buffers.BufferStack.BufferStack|)))
 :qid |unknown.0:0|
 :skolemid |5508|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@61))
)))
(assert (forall ((d@@62 T@U) ) (!  (=> (and (= (type d@@62) DatatypeTypeType) (Buffers.BufferStack.BufferStack_q d@@62)) (exists ((|a#1#0#0@@4| T@U) ) (!  (and (= (type |a#1#0#0@@4|) (SeqType BoxType)) (= d@@62 (|#Buffers.BufferStack.BufferStack| |a#1#0#0@@4|)))
 :qid |Buffersidfy.39:38|
 :skolemid |5509|
 :no-pattern (type |a#1#0#0@@4|)
 :no-pattern (U_2_int |a#1#0#0@@4|)
 :no-pattern (U_2_bool |a#1#0#0@@4|)
)))
 :qid |unknown.0:0|
 :skolemid |5510|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@62))
)))
(assert (forall ((|a#2#0#0@@4| T@U) ) (!  (=> (= (type |a#2#0#0@@4|) (SeqType BoxType)) (= ($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@4|) Tclass.Buffers.BufferStack) ($Is |a#2#0#0@@4| (TSeq Tclass.Buffers.Buffer))))
 :qid |Buffersidfy.39:38|
 :skolemid |5511|
 :pattern ( ($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@4|) Tclass.Buffers.BufferStack))
)))
(assert (forall ((|a#3#0#0@@4| T@U) ($h@@103 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@4|) (SeqType BoxType)) (= (type $h@@103) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@103)) (= ($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@4|) Tclass.Buffers.BufferStack $h@@103) ($IsAlloc |a#3#0#0@@4| (TSeq Tclass.Buffers.Buffer) $h@@103)))
 :qid |Buffersidfy.39:38|
 :skolemid |5512|
 :pattern ( ($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@4|) Tclass.Buffers.BufferStack $h@@103))
)))
(assert (forall ((arg0@@578 T@U) ) (! (= (type (Buffers.BufferStack.buffers arg0@@578)) (SeqType BoxType))
 :qid |funType:Buffers.BufferStack.buffers|
 :pattern ( (Buffers.BufferStack.buffers arg0@@578))
)))
(assert (forall ((d@@63 T@U) ($h@@104 T@U) ) (!  (=> (and (and (= (type d@@63) DatatypeTypeType) (= (type $h@@104) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@104) (and (Buffers.BufferStack.BufferStack_q d@@63) ($IsAlloc d@@63 Tclass.Buffers.BufferStack $h@@104)))) ($IsAlloc (Buffers.BufferStack.buffers d@@63) (TSeq Tclass.Buffers.Buffer) $h@@104))
 :qid |unknown.0:0|
 :skolemid |5513|
 :pattern ( ($IsAlloc (Buffers.BufferStack.buffers d@@63) (TSeq Tclass.Buffers.Buffer) $h@@104))
)))
(assert (forall ((|a#4#0#0@@4| T@U) ) (!  (=> (= (type |a#4#0#0@@4|) (SeqType BoxType)) (= (|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@4|)) (Lit (|#Buffers.BufferStack.BufferStack| |a#4#0#0@@4|))))
 :qid |Buffersidfy.39:38|
 :skolemid |5514|
 :pattern ( (|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@4|)))
)))
(assert (forall ((|a#5#0#0@@5| T@U) ) (!  (=> (= (type |a#5#0#0@@5|) (SeqType BoxType)) (= (Buffers.BufferStack.buffers (|#Buffers.BufferStack.BufferStack| |a#5#0#0@@5|)) |a#5#0#0@@5|))
 :qid |Buffersidfy.39:38|
 :skolemid |5515|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#5#0#0@@5|))
)))
(assert (forall ((|a#6#0#0@@5| T@U) (i@@25 Int) ) (!  (=> (= (type |a#6#0#0@@5|) (SeqType BoxType)) (=> (and (<= 0 i@@25) (< i@@25 (|Seq#Length| |a#6#0#0@@5|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#6#0#0@@5| i@@25))) (DtRank (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@5|)))))
 :qid |Buffersidfy.39:38|
 :skolemid |5516|
 :pattern ( (|Seq#Index| |a#6#0#0@@5| i@@25) (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@5|))
)))
(assert (forall ((|a#7#0#0@@5| T@U) ) (!  (=> (= (type |a#7#0#0@@5|) (SeqType BoxType)) (< (|Seq#Rank| |a#7#0#0@@5|) (DtRank (|#Buffers.BufferStack.BufferStack| |a#7#0#0@@5|))))
 :qid |Buffersidfy.39:38|
 :skolemid |5517|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#7#0#0@@5|))
)))
(assert (forall ((d@@64 T@U) ) (!  (=> (and (= (type d@@64) DatatypeTypeType) (|$IsA#Buffers.BufferStack| d@@64)) (Buffers.BufferStack.BufferStack_q d@@64))
 :qid |unknown.0:0|
 :skolemid |5518|
 :pattern ( (|$IsA#Buffers.BufferStack| d@@64))
)))
(assert (forall ((d@@65 T@U) ) (!  (=> (and (= (type d@@65) DatatypeTypeType) ($Is d@@65 Tclass.Buffers.BufferStack)) (Buffers.BufferStack.BufferStack_q d@@65))
 :qid |unknown.0:0|
 :skolemid |5519|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@65) ($Is d@@65 Tclass.Buffers.BufferStack))
)))
(assert (forall ((a@@134 T@U) (b@@84 T@U) ) (!  (=> (and (and (= (type a@@134) DatatypeTypeType) (= (type b@@84) DatatypeTypeType)) true) (= (|Buffers.BufferStack#Equal| a@@134 b@@84) (|Seq#Equal| (Buffers.BufferStack.buffers a@@134) (Buffers.BufferStack.buffers b@@84))))
 :qid |unknown.0:0|
 :skolemid |5520|
 :pattern ( (|Buffers.BufferStack#Equal| a@@134 b@@84))
)))
(assert (forall ((a@@135 T@U) (b@@85 T@U) ) (!  (=> (and (= (type a@@135) DatatypeTypeType) (= (type b@@85) DatatypeTypeType)) (= (|Buffers.BufferStack#Equal| a@@135 b@@85) (= a@@135 b@@85)))
 :qid |unknown.0:0|
 :skolemid |5521|
 :pattern ( (|Buffers.BufferStack#Equal| a@@135 b@@85))
)))
(assert (forall ((arg0@@579 T@U) (arg1@@284 T@U) (arg2@@160 T@U) (arg3@@96 Int) ) (! (= (type (Buffers.BufferStack.QueryUpTo arg0@@579 arg1@@284 arg2@@160 arg3@@96)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.QueryUpTo|
 :pattern ( (Buffers.BufferStack.QueryUpTo arg0@@579 arg1@@284 arg2@@160 arg3@@96))
)))
(assert (forall (($ly@@315 T@U) (this@@73 T@U) (|key#0@@24| T@U) (|count#0| Int) ) (!  (=> (and (and (= (type $ly@@315) LayerTypeType) (= (type this@@73) DatatypeTypeType)) (= (type |key#0@@24|) (SeqType BoxType))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@315) this@@73 |key#0@@24| |count#0|) (Buffers.BufferStack.QueryUpTo $ly@@315 this@@73 |key#0@@24| |count#0|)))
 :qid |Buffersidfy.41:14|
 :skolemid |5522|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@315) this@@73 |key#0@@24| |count#0|))
)))
(assert (forall (($ly@@316 T@U) (this@@74 T@U) (|key#0@@25| T@U) (|count#0@@0| Int) ) (!  (=> (and (and (= (type $ly@@316) LayerTypeType) (= (type this@@74) DatatypeTypeType)) (= (type |key#0@@25|) (SeqType BoxType))) (= (Buffers.BufferStack.QueryUpTo $ly@@316 this@@74 |key#0@@25| |count#0@@0|) (Buffers.BufferStack.QueryUpTo $LZ this@@74 |key#0@@25| |count#0@@0|)))
 :qid |Buffersidfy.41:14|
 :skolemid |5523|
 :pattern ( (Buffers.BufferStack.QueryUpTo (AsFuelBottom $ly@@316) this@@74 |key#0@@25| |count#0@@0|))
)))
(assert  (=> true (forall (($ly@@317 T@U) (this@@75 T@U) (|key#0@@26| T@U) (|count#0@@1| Int) ) (!  (=> (and (and (and (= (type $ly@@317) LayerTypeType) (= (type this@@75) DatatypeTypeType)) (= (type |key#0@@26|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| this@@75 |key#0@@26| |count#0@@1|) (and (and (and ($Is this@@75 Tclass.Buffers.BufferStack) ($Is |key#0@@26| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@1|)) (INTERNAL_le_boogie |count#0@@1| (|Seq#Length| (Buffers.BufferStack.buffers this@@75)))))) ($Is (Buffers.BufferStack.QueryUpTo $ly@@317 this@@75 |key#0@@26| |count#0@@1|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.41:14|
 :skolemid |5524|
 :pattern ( (Buffers.BufferStack.QueryUpTo $ly@@317 this@@75 |key#0@@26| |count#0@@1|))
))))
(assert (forall (($ly@@318 T@U) (this@@76 T@U) (|key#0@@27| T@U) (|count#0@@2| Int) ) (!  (=> (and (and (and (= (type $ly@@318) LayerTypeType) (= (type this@@76) DatatypeTypeType)) (= (type |key#0@@27|) (SeqType BoxType))) (and (and ($Is this@@76 Tclass.Buffers.BufferStack) ($Is |key#0@@27| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@2|))) (= (|Buffers.BufferStack.QueryUpTo#requires| $ly@@318 this@@76 |key#0@@27| |count#0@@2|) (INTERNAL_le_boogie |count#0@@2| (|Seq#Length| (Buffers.BufferStack.buffers this@@76)))))
 :qid |Buffersidfy.41:14|
 :skolemid |5525|
 :pattern ( (|Buffers.BufferStack.QueryUpTo#requires| $ly@@318 this@@76 |key#0@@27| |count#0@@2|))
)))
(assert  (=> true (forall (($ly@@319 T@U) (this@@77 T@U) (|key#0@@28| T@U) (|count#0@@3| Int) ) (!  (=> (and (and (and (= (type $ly@@319) LayerTypeType) (= (type this@@77) DatatypeTypeType)) (= (type |key#0@@28|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| this@@77 |key#0@@28| |count#0@@3|) (and (and (and ($Is this@@77 Tclass.Buffers.BufferStack) ($Is |key#0@@28| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@3|)) (INTERNAL_le_boogie |count#0@@3| (|Seq#Length| (Buffers.BufferStack.buffers this@@77)))))) (and (and (=> (= |count#0@@3| (LitInt 0)) |ValueMessage.__default.NopDelta#canCall|) (=> (not (= |count#0@@3| (LitInt 0))) (and (and (|Buffers.BufferStack.QueryUpTo#canCall| this@@77 |key#0@@28| (INTERNAL_sub_boogie |count#0@@3| 1)) (and (Buffers.BufferStack.BufferStack_q this@@77) (|Buffers.Buffer.Query#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@77) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@28|))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.QueryUpTo $ly@@319 this@@77 |key#0@@28| (INTERNAL_sub_boogie |count#0@@3| 1)) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@77) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@28|))))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@319) this@@77 |key#0@@28| |count#0@@3|) (ite (= |count#0@@3| (LitInt 0)) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta)) (ValueMessage.__default.Merge (Buffers.BufferStack.QueryUpTo $ly@@319 this@@77 |key#0@@28| (INTERNAL_sub_boogie |count#0@@3| 1)) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@77) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@28|))))))
 :qid |Buffersidfy.41:14|
 :skolemid |5526|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@319) this@@77 |key#0@@28| |count#0@@3|))
))))
(assert  (=> true (forall (($ly@@320 T@U) (this@@78 T@U) (|key#0@@29| T@U) (|count#0@@4| Int) ) (!  (=> (and (and (and (= (type $ly@@320) LayerTypeType) (= (type this@@78) DatatypeTypeType)) (= (type |key#0@@29|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@78) (Lit |key#0@@29|) (LitInt |count#0@@4|)) (and (and (and ($Is this@@78 Tclass.Buffers.BufferStack) ($Is |key#0@@29| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@4|)) (INTERNAL_le_boogie |count#0@@4| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@78)))))))) (and (and (=> (= (LitInt |count#0@@4|) (LitInt 0)) |ValueMessage.__default.NopDelta#canCall|) (=> (not (= (LitInt |count#0@@4|) (LitInt 0))) (and (and (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@78) (Lit |key#0@@29|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@78)) (|Buffers.Buffer.Query#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@78))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@29|)))) (|ValueMessage.__default.Merge#canCall| (Lit (Buffers.BufferStack.QueryUpTo ($LS $ly@@320) (Lit this@@78) (Lit |key#0@@29|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@78))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@29|)))))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@320) (Lit this@@78) (Lit |key#0@@29|) (LitInt |count#0@@4|)) (ite (= (LitInt |count#0@@4|) (LitInt 0)) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta)) (ValueMessage.__default.Merge (Lit (Buffers.BufferStack.QueryUpTo ($LS $ly@@320) (Lit this@@78) (Lit |key#0@@29|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@78))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@29|)))))))
 :qid |Buffersidfy.41:14|
 :weight 3
 :skolemid |5527|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@320) (Lit this@@78) (Lit |key#0@@29|) (LitInt |count#0@@4|)))
))))
(assert (forall ((arg0@@580 T@U) (arg1@@285 T@U) ) (! (= (type (Buffers.BufferStack.Query arg0@@580 arg1@@285)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.Query|
 :pattern ( (Buffers.BufferStack.Query arg0@@580 arg1@@285))
)))
(assert  (=> true (forall ((this@@79 T@U) (|key#0@@30| T@U) ) (!  (=> (and (and (= (type this@@79) DatatypeTypeType) (= (type |key#0@@30|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| this@@79 |key#0@@30|) (and ($Is this@@79 Tclass.Buffers.BufferStack) ($Is |key#0@@30| Tclass.KeyType.Key)))) ($Is (Buffers.BufferStack.Query this@@79 |key#0@@30|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.48:14|
 :skolemid |5528|
 :pattern ( (Buffers.BufferStack.Query this@@79 |key#0@@30|))
))))
(assert (forall ((this@@80 T@U) (|key#0@@31| T@U) ) (!  (=> (and (and (= (type this@@80) DatatypeTypeType) (= (type |key#0@@31|) (SeqType BoxType))) (and ($Is this@@80 Tclass.Buffers.BufferStack) ($Is |key#0@@31| Tclass.KeyType.Key))) (= (|Buffers.BufferStack.Query#requires| this@@80 |key#0@@31|) true))
 :qid |Buffersidfy.48:14|
 :skolemid |5529|
 :pattern ( (|Buffers.BufferStack.Query#requires| this@@80 |key#0@@31|))
)))
(assert  (=> true (forall ((this@@81 T@U) (|key#0@@32| T@U) ) (!  (=> (and (and (= (type this@@81) DatatypeTypeType) (= (type |key#0@@32|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| this@@81 |key#0@@32|) (and ($Is this@@81 Tclass.Buffers.BufferStack) ($Is |key#0@@32| Tclass.KeyType.Key)))) (and (and (Buffers.BufferStack.BufferStack_q this@@81) (|Buffers.BufferStack.QueryUpTo#canCall| this@@81 |key#0@@32| (|Seq#Length| (Buffers.BufferStack.buffers this@@81)))) (= (Buffers.BufferStack.Query this@@81 |key#0@@32|) (Buffers.BufferStack.QueryUpTo ($LS $LZ) this@@81 |key#0@@32| (|Seq#Length| (Buffers.BufferStack.buffers this@@81))))))
 :qid |Buffersidfy.48:14|
 :skolemid |5530|
 :pattern ( (Buffers.BufferStack.Query this@@81 |key#0@@32|))
))))
(assert  (=> true (forall ((this@@82 T@U) (|key#0@@33| T@U) ) (!  (=> (and (and (= (type this@@82) DatatypeTypeType) (= (type |key#0@@33|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| (Lit this@@82) (Lit |key#0@@33|)) (and ($Is this@@82 Tclass.Buffers.BufferStack) ($Is |key#0@@33| Tclass.KeyType.Key)))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@82)) (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@82) (Lit |key#0@@33|) (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@82)))))) (= (Buffers.BufferStack.Query (Lit this@@82) (Lit |key#0@@33|)) (Buffers.BufferStack.QueryUpTo ($LS $LZ) (Lit this@@82) (Lit |key#0@@33|) (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@82))))))))
 :qid |Buffersidfy.48:14|
 :weight 3
 :skolemid |5531|
 :pattern ( (Buffers.BufferStack.Query (Lit this@@82) (Lit |key#0@@33|)))
))))
(assert (forall ((arg0@@581 T@U) (arg1@@286 T@U) ) (! (= (type (Buffers.BufferStack.ApplyFilter arg0@@581 arg1@@286)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.ApplyFilter|
 :pattern ( (Buffers.BufferStack.ApplyFilter arg0@@581 arg1@@286))
)))
(assert  (=> true (forall ((this@@83 T@U) (|accept#0@@4| T@U) ) (!  (=> (and (and (= (type this@@83) DatatypeTypeType) (= (type |accept#0@@4|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| this@@83 |accept#0@@4|) (and ($Is this@@83 Tclass.Buffers.BufferStack) ($Is |accept#0@@4| (TISet Tclass.KeyType.Key))))) ($Is (Buffers.BufferStack.ApplyFilter this@@83 |accept#0@@4|) Tclass.Buffers.BufferStack))
 :qid |Buffersidfy.53:14|
 :skolemid |5532|
 :pattern ( (Buffers.BufferStack.ApplyFilter this@@83 |accept#0@@4|))
))))
(assert (forall (($Heap@@49 T@U) (this@@84 T@U) (|accept#0@@5| T@U) ) (!  (=> (and (and (and (= (type $Heap@@49) (MapType0Type refType MapType1Type)) (= (type this@@84) DatatypeTypeType)) (= (type |accept#0@@5|) (MapType0Type BoxType boolType))) (and (and ($IsGoodHeap $Heap@@49) (and ($Is this@@84 Tclass.Buffers.BufferStack) ($IsAlloc this@@84 Tclass.Buffers.BufferStack $Heap@@49))) ($Is |accept#0@@5| (TISet Tclass.KeyType.Key)))) (= (|Buffers.BufferStack.ApplyFilter#requires| this@@84 |accept#0@@5|) true))
 :qid |Buffersidfy.53:14|
 :skolemid |5533|
 :pattern ( (|Buffers.BufferStack.ApplyFilter#requires| this@@84 |accept#0@@5|) ($IsGoodHeap $Heap@@49))
)))
(assert (forall ((arg0@@582 T@U) (arg1@@287 T@U) ) (! (= (type (|lambda#276| arg0@@582 arg1@@287)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#276|
 :pattern ( (|lambda#276| arg0@@582 arg1@@287))
)))
(assert  (=> true (forall (($Heap@@50 T@U) (this@@85 T@U) (|accept#0@@6| T@U) ) (!  (=> (and (and (and (= (type $Heap@@50) (MapType0Type refType MapType1Type)) (= (type this@@85) DatatypeTypeType)) (= (type |accept#0@@6|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| this@@85 |accept#0@@6|) (and (and ($IsGoodHeap $Heap@@50) (and ($Is this@@85 Tclass.Buffers.BufferStack) ($IsAlloc this@@85 Tclass.Buffers.BufferStack $Heap@@50))) ($Is |accept#0@@6| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q this@@85) (forall ((|$l#1#i#0@@2| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@2|) (Buffers.BufferStack.BufferStack_q this@@85)) (=> (and (INTERNAL_le_boogie 0 |$l#1#i#0@@2|) (INTERNAL_lt_boogie |$l#1#i#0@@2| (|Seq#Length| (Buffers.BufferStack.buffers this@@85)))) (and (Buffers.BufferStack.BufferStack_q this@@85) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@85) |$l#1#i#0@@2|)) |accept#0@@6|))))
 :qid |unknown.0:0|
 :skolemid |5534|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0@@2| (|Seq#Length| (Buffers.BufferStack.buffers this@@85)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@2|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@2|)
))) (= (Buffers.BufferStack.ApplyFilter this@@85 |accept#0@@6|) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@50 (|Seq#Length| (Buffers.BufferStack.buffers this@@85)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#276| (Buffers.BufferStack.buffers this@@85) |accept#0@@6|) (|lambda#32| TInt 0 (|Seq#Length| (Buffers.BufferStack.buffers this@@85))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :skolemid |5535|
 :pattern ( (Buffers.BufferStack.ApplyFilter this@@85 |accept#0@@6|) ($IsGoodHeap $Heap@@50))
))))
(assert  (=> true (forall (($Heap@@51 T@U) (this@@86 T@U) (|accept#0@@7| T@U) ) (!  (=> (and (and (and (= (type $Heap@@51) (MapType0Type refType MapType1Type)) (= (type this@@86) DatatypeTypeType)) (= (type |accept#0@@7|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| (Lit this@@86) |accept#0@@7|) (and (and ($IsGoodHeap $Heap@@51) (and ($Is this@@86 Tclass.Buffers.BufferStack) ($IsAlloc this@@86 Tclass.Buffers.BufferStack $Heap@@51))) ($Is |accept#0@@7| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@86)) (forall ((|$l#3#i#0@@2| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@2|) (Buffers.BufferStack.BufferStack_q (Lit this@@86))) (=> (and (INTERNAL_le_boogie 0 |$l#3#i#0@@2|) (INTERNAL_lt_boogie |$l#3#i#0@@2| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@86)))))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@86)) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@86))) |$l#3#i#0@@2|)) |accept#0@@7|))))
 :qid |unknown.0:0|
 :skolemid |5536|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0@@2| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@86)))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@2|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@2|)
))) (= (Buffers.BufferStack.ApplyFilter (Lit this@@86) |accept#0@@7|) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@51 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@86)))) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#276| (Lit (Buffers.BufferStack.buffers (Lit this@@86))) |accept#0@@7|) (|lambda#32| TInt 0 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@86))))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :weight 3
 :skolemid |5537|
 :pattern ( (Buffers.BufferStack.ApplyFilter (Lit this@@86) |accept#0@@7|) ($IsGoodHeap $Heap@@51))
))))
(assert  (=> true (forall (($Heap@@52 T@U) (this@@87 T@U) (|accept#0@@8| T@U) ) (!  (=> (and (and (and (= (type $Heap@@52) (MapType0Type refType MapType1Type)) (= (type this@@87) DatatypeTypeType)) (= (type |accept#0@@8|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| (Lit this@@87) (Lit |accept#0@@8|)) (and (and ($IsGoodHeap $Heap@@52) (and ($Is this@@87 Tclass.Buffers.BufferStack) ($IsAlloc this@@87 Tclass.Buffers.BufferStack $Heap@@52))) ($Is |accept#0@@8| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@87)) (forall ((|$l#5#i#0@@0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#5#i#0@@0|) (Buffers.BufferStack.BufferStack_q (Lit this@@87))) (=> (and (INTERNAL_le_boogie 0 |$l#5#i#0@@0|) (INTERNAL_lt_boogie |$l#5#i#0@@0| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@87)))))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@87)) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@87))) |$l#5#i#0@@0|)) (Lit |accept#0@@8|)))))
 :qid |unknown.0:0|
 :skolemid |5538|
 :no-pattern (INTERNAL_lt_boogie |$l#5#i#0@@0| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@87)))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
))) (= (Buffers.BufferStack.ApplyFilter (Lit this@@87) (Lit |accept#0@@8|)) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@52 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@87)))) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#276| (Lit (Buffers.BufferStack.buffers (Lit this@@87))) (Lit |accept#0@@8|)) (|lambda#32| TInt 0 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@87))))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :weight 3
 :skolemid |5539|
 :pattern ( (Buffers.BufferStack.ApplyFilter (Lit this@@87) (Lit |accept#0@@8|)) ($IsGoodHeap $Heap@@52))
))))
(assert (forall ((arg0@@583 T@U) (arg1@@288 T@U) ) (! (= (type (Buffers.BufferStack.PushBufferStack arg0@@583 arg1@@288)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.PushBufferStack|
 :pattern ( (Buffers.BufferStack.PushBufferStack arg0@@583 arg1@@288))
)))
(assert  (=> true (forall ((this@@88 T@U) (|newBuffers#0| T@U) ) (!  (=> (and (and (= (type this@@88) DatatypeTypeType) (= (type |newBuffers#0|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| this@@88 |newBuffers#0|) (and ($Is this@@88 Tclass.Buffers.BufferStack) ($Is |newBuffers#0| Tclass.Buffers.BufferStack)))) ($Is (Buffers.BufferStack.PushBufferStack this@@88 |newBuffers#0|) Tclass.Buffers.BufferStack))
 :qid |Buffersidfy.58:14|
 :skolemid |5540|
 :pattern ( (Buffers.BufferStack.PushBufferStack this@@88 |newBuffers#0|))
))))
(assert (forall ((this@@89 T@U) (|newBuffers#0@@0| T@U) ) (!  (=> (and (and (= (type this@@89) DatatypeTypeType) (= (type |newBuffers#0@@0|) DatatypeTypeType)) (and ($Is this@@89 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@0| Tclass.Buffers.BufferStack))) (= (|Buffers.BufferStack.PushBufferStack#requires| this@@89 |newBuffers#0@@0|) true))
 :qid |Buffersidfy.58:14|
 :skolemid |5541|
 :pattern ( (|Buffers.BufferStack.PushBufferStack#requires| this@@89 |newBuffers#0@@0|))
)))
(assert  (=> true (forall ((this@@90 T@U) (|newBuffers#0@@1| T@U) ) (!  (=> (and (and (= (type this@@90) DatatypeTypeType) (= (type |newBuffers#0@@1|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| this@@90 |newBuffers#0@@1|) (and ($Is this@@90 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@1| Tclass.Buffers.BufferStack)))) (and (and (Buffers.BufferStack.BufferStack_q |newBuffers#0@@1|) (Buffers.BufferStack.BufferStack_q this@@90)) (= (Buffers.BufferStack.PushBufferStack this@@90 |newBuffers#0@@1|) (|#Buffers.BufferStack.BufferStack| (|Seq#Append| (Buffers.BufferStack.buffers |newBuffers#0@@1|) (Buffers.BufferStack.buffers this@@90))))))
 :qid |Buffersidfy.58:14|
 :skolemid |5542|
 :pattern ( (Buffers.BufferStack.PushBufferStack this@@90 |newBuffers#0@@1|))
))))
(assert  (=> true (forall ((this@@91 T@U) (|newBuffers#0@@2| T@U) ) (!  (=> (and (and (= (type this@@91) DatatypeTypeType) (= (type |newBuffers#0@@2|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| (Lit this@@91) (Lit |newBuffers#0@@2|)) (and ($Is this@@91 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@2| Tclass.Buffers.BufferStack)))) (and (and (Buffers.BufferStack.BufferStack_q (Lit |newBuffers#0@@2|)) (Buffers.BufferStack.BufferStack_q (Lit this@@91))) (= (Buffers.BufferStack.PushBufferStack (Lit this@@91) (Lit |newBuffers#0@@2|)) (|#Buffers.BufferStack.BufferStack| (|Seq#Append| (Buffers.BufferStack.buffers (Lit |newBuffers#0@@2|)) (Buffers.BufferStack.buffers (Lit this@@91)))))))
 :qid |Buffersidfy.58:14|
 :weight 3
 :skolemid |5543|
 :pattern ( (Buffers.BufferStack.PushBufferStack (Lit this@@91) (Lit |newBuffers#0@@2|)))
))))
(assert  (=> true (forall ((this@@92 T@U) (|other#0@@11| T@U) ) (!  (=> (and (and (= (type this@@92) DatatypeTypeType) (= (type |other#0@@11|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| this@@92 |other#0@@11|) (and ($Is this@@92 Tclass.Buffers.BufferStack) ($Is |other#0@@11| Tclass.Buffers.BufferStack)))) true)
 :qid |Buffersidfy.63:15|
 :skolemid |5544|
 :pattern ( (Buffers.BufferStack.Equivalent this@@92 |other#0@@11|))
))))
(assert (forall ((this@@93 T@U) (|other#0@@12| T@U) ) (!  (=> (and (and (= (type this@@93) DatatypeTypeType) (= (type |other#0@@12|) DatatypeTypeType)) (and ($Is this@@93 Tclass.Buffers.BufferStack) ($Is |other#0@@12| Tclass.Buffers.BufferStack))) (= (|Buffers.BufferStack.Equivalent#requires| this@@93 |other#0@@12|) true))
 :qid |Buffersidfy.63:15|
 :skolemid |5545|
 :pattern ( (|Buffers.BufferStack.Equivalent#requires| this@@93 |other#0@@12|))
)))
(assert  (=> true (forall ((this@@94 T@U) (|other#0@@13| T@U) ) (!  (=> (and (and (= (type this@@94) DatatypeTypeType) (= (type |other#0@@13|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| this@@94 |other#0@@13|) (and ($Is this@@94 Tclass.Buffers.BufferStack) ($Is |other#0@@13| Tclass.Buffers.BufferStack)))) (and (forall ((|k#0@@72| T@U) ) (!  (=> (and (= (type |k#0@@72|) (SeqType BoxType)) ($Is |k#0@@72| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@72|) (=> (Buffers.__default.AnyKey |k#0@@72|) (and (and (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query this@@94 |k#0@@72|)) (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query |other#0@@13| |k#0@@72|))) (and (|Buffers.BufferStack.Query#canCall| this@@94 |k#0@@72|) (|Buffers.BufferStack.Query#canCall| |other#0@@13| |k#0@@72|))))))
 :qid |Buffersidfy.65:14|
 :skolemid |5547|
 :pattern ( (Buffers.BufferStack.Query |other#0@@13| |k#0@@72|))
 :pattern ( (Buffers.BufferStack.Query this@@94 |k#0@@72|))
 :pattern ( (Buffers.__default.AnyKey |k#0@@72|))
)) (= (Buffers.BufferStack.Equivalent this@@94 |other#0@@13|) (forall ((|k#0@@73| T@U) ) (!  (=> (= (type |k#0@@73|) (SeqType BoxType)) (=> (and ($Is |k#0@@73| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0@@73|)) (|ValueMessage.Message#Equal| (Buffers.BufferStack.Query this@@94 |k#0@@73|) (Buffers.BufferStack.Query |other#0@@13| |k#0@@73|))))
 :qid |Buffersidfy.65:14|
 :skolemid |5546|
 :pattern ( (Buffers.BufferStack.Query |other#0@@13| |k#0@@73|))
 :pattern ( (Buffers.BufferStack.Query this@@94 |k#0@@73|))
 :pattern ( (Buffers.__default.AnyKey |k#0@@73|))
)))))
 :qid |Buffersidfy.63:15|
 :skolemid |5548|
 :pattern ( (Buffers.BufferStack.Equivalent this@@94 |other#0@@13|))
))))
(assert  (=> true (forall ((this@@95 T@U) (|other#0@@14| T@U) ) (!  (=> (and (and (= (type this@@95) DatatypeTypeType) (= (type |other#0@@14|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| (Lit this@@95) (Lit |other#0@@14|)) (and ($Is this@@95 Tclass.Buffers.BufferStack) ($Is |other#0@@14| Tclass.Buffers.BufferStack)))) (and (forall ((|k#1@@10| T@U) ) (!  (=> (and (= (type |k#1@@10|) (SeqType BoxType)) ($Is |k#1@@10| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#1@@10|) (=> (Buffers.__default.AnyKey |k#1@@10|) (and (and (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query (Lit this@@95) |k#1@@10|)) (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query (Lit |other#0@@14|) |k#1@@10|))) (and (|Buffers.BufferStack.Query#canCall| (Lit this@@95) |k#1@@10|) (|Buffers.BufferStack.Query#canCall| (Lit |other#0@@14|) |k#1@@10|))))))
 :qid |Buffersidfy.65:14|
 :skolemid |5550|
 :pattern ( (Buffers.BufferStack.Query |other#0@@14| |k#1@@10|))
 :pattern ( (Buffers.BufferStack.Query this@@95 |k#1@@10|))
 :pattern ( (Buffers.__default.AnyKey |k#1@@10|))
)) (= (Buffers.BufferStack.Equivalent (Lit this@@95) (Lit |other#0@@14|)) (forall ((|k#1@@11| T@U) ) (!  (=> (= (type |k#1@@11|) (SeqType BoxType)) (=> (and ($Is |k#1@@11| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#1@@11|)) (|ValueMessage.Message#Equal| (Buffers.BufferStack.Query (Lit this@@95) |k#1@@11|) (Buffers.BufferStack.Query (Lit |other#0@@14|) |k#1@@11|))))
 :qid |Buffersidfy.65:14|
 :skolemid |5549|
 :pattern ( (Buffers.BufferStack.Query |other#0@@14| |k#1@@11|))
 :pattern ( (Buffers.BufferStack.Query this@@95 |k#1@@11|))
 :pattern ( (Buffers.__default.AnyKey |k#1@@11|))
)))))
 :qid |Buffersidfy.63:15|
 :weight 3
 :skolemid |5551|
 :pattern ( (Buffers.BufferStack.Equivalent (Lit this@@95) (Lit |other#0@@14|)))
))))
(assert (= (type Tclass.Buffers.__default) TyType))
(assert (= (Tag Tclass.Buffers.__default) Tagclass.Buffers.__default))
(assert (= (TagFamily Tclass.Buffers.__default) tytagFamily$_default))
(assert (forall ((bx@@167 T@U) ) (!  (=> (and (= (type bx@@167) BoxType) ($IsBox bx@@167 Tclass.Buffers.__default)) (and (= ($Box ($Unbox refType bx@@167)) bx@@167) ($Is ($Unbox refType bx@@167) Tclass.Buffers.__default)))
 :qid |unknown.0:0|
 :skolemid |5552|
 :pattern ( ($IsBox bx@@167 Tclass.Buffers.__default))
)))
(assert (forall (($o@@47 T@U) ) (!  (=> (= (type $o@@47) refType) (= ($Is $o@@47 Tclass.Buffers.__default)  (or (= $o@@47 null) (= (dtype $o@@47) Tclass.Buffers.__default))))
 :qid |unknown.0:0|
 :skolemid |5553|
 :pattern ( ($Is $o@@47 Tclass.Buffers.__default))
)))
(assert (forall (($o@@48 T@U) ($h@@105 T@U) ) (!  (=> (and (= (type $o@@48) refType) (= (type $h@@105) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@48 Tclass.Buffers.__default $h@@105)  (or (= $o@@48 null) (U_2_bool (MapType1Select (MapType0Select $h@@105 $o@@48) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5554|
 :pattern ( ($IsAlloc $o@@48 Tclass.Buffers.__default $h@@105))
)))
(assert  (=> true (forall ((|key#0@@34| T@U) ) (!  (=> (and (= (type |key#0@@34|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| |key#0@@34|) ($Is |key#0@@34| Tclass.KeyType.Key))) true)
 :qid |Buffersidfy.15:20|
 :skolemid |5555|
 :pattern ( (Buffers.__default.AnyKey |key#0@@34|))
))))
(assert (forall ((|key#0@@35| T@U) ) (!  (=> (and (= (type |key#0@@35|) (SeqType BoxType)) ($Is |key#0@@35| Tclass.KeyType.Key)) (= (|Buffers.__default.AnyKey#requires| |key#0@@35|) true))
 :qid |Buffersidfy.15:20|
 :skolemid |5556|
 :pattern ( (|Buffers.__default.AnyKey#requires| |key#0@@35|))
)))
(assert  (=> true (forall ((|key#0@@36| T@U) ) (!  (=> (and (= (type |key#0@@36|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| |key#0@@36|) ($Is |key#0@@36| Tclass.KeyType.Key))) (= (Buffers.__default.AnyKey |key#0@@36|) (U_2_bool (Lit (bool_2_U true)))))
 :qid |Buffersidfy.15:20|
 :skolemid |5557|
 :pattern ( (Buffers.__default.AnyKey |key#0@@36|))
))))
(assert  (=> true (forall ((|key#0@@37| T@U) ) (!  (=> (and (= (type |key#0@@37|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| (Lit |key#0@@37|)) ($Is |key#0@@37| Tclass.KeyType.Key))) (= (Buffers.__default.AnyKey (Lit |key#0@@37|)) (U_2_bool (Lit (bool_2_U true)))))
 :qid |Buffersidfy.15:20|
 :weight 3
 :skolemid |5558|
 :pattern ( (Buffers.__default.AnyKey (Lit |key#0@@37|)))
))))
(assert  (=> true (forall ((|keys#0@@0| T@U) ) (!  (=> (and (= (type |keys#0@@0|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| |keys#0@@0|) ($Is |keys#0@@0| (TISet Tclass.KeyType.Key)))) true)
 :qid |Buffersidfy.16:19|
 :skolemid |5559|
 :pattern ( (Buffers.__default.Total |keys#0@@0|))
))))
(assert (forall ((|keys#0@@1| T@U) ) (!  (=> (and (= (type |keys#0@@1|) (MapType0Type BoxType boolType)) ($Is |keys#0@@1| (TISet Tclass.KeyType.Key))) (= (|Buffers.__default.Total#requires| |keys#0@@1|) true))
 :qid |Buffersidfy.16:19|
 :skolemid |5560|
 :pattern ( (|Buffers.__default.Total#requires| |keys#0@@1|))
)))
(assert  (=> true (forall ((|keys#0@@2| T@U) ) (!  (=> (and (= (type |keys#0@@2|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| |keys#0@@2|) ($Is |keys#0@@2| (TISet Tclass.KeyType.Key)))) (and (forall ((|k#0@@74| T@U) ) (!  (=> (and (= (type |k#0@@74|) (SeqType BoxType)) ($Is |k#0@@74| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#0@@74|))
 :qid |Buffersidfy.17:12|
 :skolemid |5562|
 :pattern ( (MapType0Select |keys#0@@2| ($Box |k#0@@74|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@74|))
)) (= (Buffers.__default.Total |keys#0@@2|) (forall ((|k#0@@75| T@U) ) (!  (=> (= (type |k#0@@75|) (SeqType BoxType)) (=> (and ($Is |k#0@@75| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0@@75|)) (U_2_bool (MapType0Select |keys#0@@2| ($Box |k#0@@75|)))))
 :qid |Buffersidfy.17:12|
 :skolemid |5561|
 :pattern ( (MapType0Select |keys#0@@2| ($Box |k#0@@75|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@75|))
)))))
 :qid |Buffersidfy.16:19|
 :skolemid |5563|
 :pattern ( (Buffers.__default.Total |keys#0@@2|))
))))
(assert  (=> true (forall ((|keys#0@@3| T@U) ) (!  (=> (and (= (type |keys#0@@3|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| (Lit |keys#0@@3|)) ($Is |keys#0@@3| (TISet Tclass.KeyType.Key)))) (and (forall ((|k#1@@12| T@U) ) (!  (=> (and (= (type |k#1@@12|) (SeqType BoxType)) ($Is |k#1@@12| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#1@@12|))
 :qid |Buffersidfy.17:12|
 :skolemid |5565|
 :pattern ( (MapType0Select |keys#0@@3| ($Box |k#1@@12|)))
 :pattern ( (Buffers.__default.AnyKey |k#1@@12|))
)) (= (Buffers.__default.Total (Lit |keys#0@@3|)) (forall ((|k#1@@13| T@U) ) (!  (=> (= (type |k#1@@13|) (SeqType BoxType)) (=> (and ($Is |k#1@@13| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#1@@13|)) (U_2_bool (MapType0Select (Lit |keys#0@@3|) ($Box |k#1@@13|)))))
 :qid |Buffersidfy.17:12|
 :skolemid |5564|
 :pattern ( (MapType0Select |keys#0@@3| ($Box |k#1@@13|)))
 :pattern ( (Buffers.__default.AnyKey |k#1@@13|))
)))))
 :qid |Buffersidfy.16:19|
 :weight 3
 :skolemid |5566|
 :pattern ( (Buffers.__default.Total (Lit |keys#0@@3|)))
))))
(assert (= (type Buffers.__default.AllKeys) (MapType0Type BoxType boolType)))
(assert  (=> true (=> true (and (Buffers.__default.Total Buffers.__default.AllKeys) ($Is Buffers.__default.AllKeys (TISet Tclass.KeyType.Key))))))
(assert (= |Buffers.__default.AllKeys#requires| true))
(assert  (=> true (=> true (and (forall ((|k#0@@76| T@U) ) (!  (=> (and (= (type |k#0@@76|) (SeqType BoxType)) ($Is |k#0@@76| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#0@@76|))
 :qid |Buffersidfy.22:10|
 :skolemid |5567|
 :pattern ( (Buffers.__default.AnyKey |k#0@@76|))
)) (= Buffers.__default.AllKeys (|lambda#0| Tclass.KeyType.Key))))))
(assert  (=> true (=> true (and (forall ((|k#1@@14| T@U) ) (!  (=> (and (= (type |k#1@@14|) (SeqType BoxType)) ($Is |k#1@@14| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#1@@14|))
 :qid |Buffersidfy.22:10|
 :skolemid |5568|
 :pattern ( (Buffers.__default.AnyKey |k#1@@14|))
)) (= Buffers.__default.AllKeys (|lambda#0| Tclass.KeyType.Key))))))
(assert (forall ((arg0@@584 T@U) (arg1@@289 Int) ) (! (= (type (|#MemtableMod.Memtable.Memtable| arg0@@584 arg1@@289)) DatatypeTypeType)
 :qid |funType:#MemtableMod.Memtable.Memtable|
 :pattern ( (|#MemtableMod.Memtable.Memtable| arg0@@584 arg1@@289))
)))
(assert (forall ((|a#0#0#0@@5| T@U) (|a#0#1#0@@2| Int) ) (!  (=> (= (type |a#0#0#0@@5|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#MemtableMod.Memtable.Memtable| |a#0#0#0@@5| |a#0#1#0@@2|)) |##MemtableMod.Memtable.Memtable|))
 :qid |Memtableidfy.15:32|
 :skolemid |5569|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#0#0#0@@5| |a#0#1#0@@2|))
)))
(assert (forall ((d@@66 T@U) ) (!  (=> (= (type d@@66) DatatypeTypeType) (= (MemtableMod.Memtable.Memtable_q d@@66) (= (DatatypeCtorId d@@66) |##MemtableMod.Memtable.Memtable|)))
 :qid |unknown.0:0|
 :skolemid |5570|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@66))
)))
(assert (forall ((d@@67 T@U) ) (!  (=> (and (= (type d@@67) DatatypeTypeType) (MemtableMod.Memtable.Memtable_q d@@67)) (exists ((|a#1#0#0@@5| T@U) (|a#1#1#0@@2| Int) ) (!  (and (= (type |a#1#0#0@@5|) (MapType BoxType BoxType)) (= d@@67 (|#MemtableMod.Memtable.Memtable| |a#1#0#0@@5| |a#1#1#0@@2|)))
 :qid |Memtableidfy.15:32|
 :skolemid |5571|
 :no-pattern (type |a#1#0#0@@5|)
 :no-pattern (U_2_int |a#1#0#0@@5|)
 :no-pattern (U_2_bool |a#1#0#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |5572|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@67))
)))
(assert (forall ((|a#2#0#0@@5| T@U) (|a#2#1#0@@2| Int) ) (!  (=> (= (type |a#2#0#0@@5|) (MapType BoxType BoxType)) (= ($Is (|#MemtableMod.Memtable.Memtable| |a#2#0#0@@5| |a#2#1#0@@2|) Tclass.MemtableMod.Memtable)  (and ($Is |a#2#0#0@@5| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is (int_2_U |a#2#1#0@@2|) Tclass._System.nat))))
 :qid |Memtableidfy.15:32|
 :skolemid |5573|
 :pattern ( ($Is (|#MemtableMod.Memtable.Memtable| |a#2#0#0@@5| |a#2#1#0@@2|) Tclass.MemtableMod.Memtable))
)))
(assert (forall ((|a#3#0#0@@5| T@U) (|a#3#1#0@@2| Int) ($h@@106 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@5|) (MapType BoxType BoxType)) (= (type $h@@106) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@106)) (= ($IsAlloc (|#MemtableMod.Memtable.Memtable| |a#3#0#0@@5| |a#3#1#0@@2|) Tclass.MemtableMod.Memtable $h@@106)  (and ($IsAlloc |a#3#0#0@@5| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@106) ($IsAlloc (int_2_U |a#3#1#0@@2|) Tclass._System.nat $h@@106))))
 :qid |Memtableidfy.15:32|
 :skolemid |5574|
 :pattern ( ($IsAlloc (|#MemtableMod.Memtable.Memtable| |a#3#0#0@@5| |a#3#1#0@@2|) Tclass.MemtableMod.Memtable $h@@106))
)))
(assert (forall ((arg0@@585 T@U) ) (! (= (type (MemtableMod.Memtable.mapp arg0@@585)) (MapType BoxType BoxType))
 :qid |funType:MemtableMod.Memtable.mapp|
 :pattern ( (MemtableMod.Memtable.mapp arg0@@585))
)))
(assert (forall ((d@@68 T@U) ($h@@107 T@U) ) (!  (=> (and (and (= (type d@@68) DatatypeTypeType) (= (type $h@@107) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@107) (and (MemtableMod.Memtable.Memtable_q d@@68) ($IsAlloc d@@68 Tclass.MemtableMod.Memtable $h@@107)))) ($IsAlloc (MemtableMod.Memtable.mapp d@@68) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@107))
 :qid |unknown.0:0|
 :skolemid |5575|
 :pattern ( ($IsAlloc (MemtableMod.Memtable.mapp d@@68) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@107))
)))
(assert (forall ((d@@69 T@U) ($h@@108 T@U) ) (!  (=> (and (and (= (type d@@69) DatatypeTypeType) (= (type $h@@108) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@108) (and (MemtableMod.Memtable.Memtable_q d@@69) ($IsAlloc d@@69 Tclass.MemtableMod.Memtable $h@@108)))) ($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@69)) Tclass._System.nat $h@@108))
 :qid |unknown.0:0|
 :skolemid |5576|
 :pattern ( ($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@69)) Tclass._System.nat $h@@108))
)))
(assert (forall ((|a#4#0#0@@5| T@U) (|a#4#1#0@@2| Int) ) (!  (=> (= (type |a#4#0#0@@5|) (MapType BoxType BoxType)) (= (|#MemtableMod.Memtable.Memtable| (Lit |a#4#0#0@@5|) (LitInt |a#4#1#0@@2|)) (Lit (|#MemtableMod.Memtable.Memtable| |a#4#0#0@@5| |a#4#1#0@@2|))))
 :qid |Memtableidfy.15:32|
 :skolemid |5577|
 :pattern ( (|#MemtableMod.Memtable.Memtable| (Lit |a#4#0#0@@5|) (LitInt |a#4#1#0@@2|)))
)))
(assert (forall ((|a#5#0#0@@6| T@U) (|a#5#1#0@@2| Int) ) (!  (=> (= (type |a#5#0#0@@6|) (MapType BoxType BoxType)) (= (MemtableMod.Memtable.mapp (|#MemtableMod.Memtable.Memtable| |a#5#0#0@@6| |a#5#1#0@@2|)) |a#5#0#0@@6|))
 :qid |Memtableidfy.15:32|
 :skolemid |5578|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#5#0#0@@6| |a#5#1#0@@2|))
)))
(assert (forall ((|a#6#0#0@@6| T@U) (|a#6#1#0@@2| Int) (d@@70 T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@6|) (MapType BoxType BoxType)) (= (type d@@70) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@6|) ($Box d@@70)))) (< (DtRank d@@70) (DtRank (|#MemtableMod.Memtable.Memtable| |a#6#0#0@@6| |a#6#1#0@@2|))))
 :qid |Memtableidfy.15:32|
 :skolemid |5579|
 :pattern ( (MapType0Select (|Map#Domain| |a#6#0#0@@6|) ($Box d@@70)) (|#MemtableMod.Memtable.Memtable| |a#6#0#0@@6| |a#6#1#0@@2|))
)))
(assert (forall ((|a#7#0#0@@6| T@U) (|a#7#1#0@@2| Int) (bx@@168 T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@6|) (MapType BoxType BoxType)) (= (type bx@@168) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@6|) bx@@168))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#7#0#0@@6|) bx@@168))) (DtRank (|#MemtableMod.Memtable.Memtable| |a#7#0#0@@6| |a#7#1#0@@2|))))
 :qid |Memtableidfy.15:32|
 :skolemid |5580|
 :pattern ( (MapType0Select (|Map#Domain| |a#7#0#0@@6|) bx@@168) (|#MemtableMod.Memtable.Memtable| |a#7#0#0@@6| |a#7#1#0@@2|))
)))
(assert (forall ((|a#8#0#0@@3| T@U) (|a#8#1#0@@1| Int) ) (!  (=> (= (type |a#8#0#0@@3|) (MapType BoxType BoxType)) (= (MemtableMod.Memtable.seqEnd (|#MemtableMod.Memtable.Memtable| |a#8#0#0@@3| |a#8#1#0@@1|)) |a#8#1#0@@1|))
 :qid |Memtableidfy.15:32|
 :skolemid |5581|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#8#0#0@@3| |a#8#1#0@@1|))
)))
(assert (forall ((d@@71 T@U) ) (!  (=> (and (= (type d@@71) DatatypeTypeType) (|$IsA#MemtableMod.Memtable| d@@71)) (MemtableMod.Memtable.Memtable_q d@@71))
 :qid |unknown.0:0|
 :skolemid |5582|
 :pattern ( (|$IsA#MemtableMod.Memtable| d@@71))
)))
(assert (forall ((d@@72 T@U) ) (!  (=> (and (= (type d@@72) DatatypeTypeType) ($Is d@@72 Tclass.MemtableMod.Memtable)) (MemtableMod.Memtable.Memtable_q d@@72))
 :qid |unknown.0:0|
 :skolemid |5583|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@72) ($Is d@@72 Tclass.MemtableMod.Memtable))
)))
(assert (forall ((a@@136 T@U) (b@@86 T@U) ) (!  (=> (and (and (= (type a@@136) DatatypeTypeType) (= (type b@@86) DatatypeTypeType)) true) (= (|MemtableMod.Memtable#Equal| a@@136 b@@86)  (and (|Map#Equal| (MemtableMod.Memtable.mapp a@@136) (MemtableMod.Memtable.mapp b@@86)) (= (MemtableMod.Memtable.seqEnd a@@136) (MemtableMod.Memtable.seqEnd b@@86)))))
 :qid |unknown.0:0|
 :skolemid |5584|
 :pattern ( (|MemtableMod.Memtable#Equal| a@@136 b@@86))
)))
(assert (forall ((a@@137 T@U) (b@@87 T@U) ) (!  (=> (and (= (type a@@137) DatatypeTypeType) (= (type b@@87) DatatypeTypeType)) (= (|MemtableMod.Memtable#Equal| a@@137 b@@87) (= a@@137 b@@87)))
 :qid |unknown.0:0|
 :skolemid |5585|
 :pattern ( (|MemtableMod.Memtable#Equal| a@@137 b@@87))
)))
(assert (forall ((arg0@@586 T@U) (arg1@@290 T@U) ) (! (= (type (MemtableMod.Memtable.Get arg0@@586 arg1@@290)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Get|
 :pattern ( (MemtableMod.Memtable.Get arg0@@586 arg1@@290))
)))
(assert  (=> true (forall ((this@@96 T@U) (|key#0@@38| T@U) ) (!  (=> (and (and (= (type this@@96) DatatypeTypeType) (= (type |key#0@@38|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| this@@96 |key#0@@38|) (and ($Is this@@96 Tclass.MemtableMod.Memtable) ($Is |key#0@@38| Tclass.KeyType.Key)))) ($Is (MemtableMod.Memtable.Get this@@96 |key#0@@38|) Tclass.ValueMessage.Message))
 :qid |Memtableidfy.17:14|
 :skolemid |5586|
 :pattern ( (MemtableMod.Memtable.Get this@@96 |key#0@@38|))
))))
(assert (forall ((this@@97 T@U) (|key#0@@39| T@U) ) (!  (=> (and (and (= (type this@@97) DatatypeTypeType) (= (type |key#0@@39|) (SeqType BoxType))) (and ($Is this@@97 Tclass.MemtableMod.Memtable) ($Is |key#0@@39| Tclass.KeyType.Key))) (= (|MemtableMod.Memtable.Get#requires| this@@97 |key#0@@39|) true))
 :qid |Memtableidfy.17:14|
 :skolemid |5587|
 :pattern ( (|MemtableMod.Memtable.Get#requires| this@@97 |key#0@@39|))
)))
(assert  (=> true (forall ((this@@98 T@U) (|key#0@@40| T@U) ) (!  (=> (and (and (= (type this@@98) DatatypeTypeType) (= (type |key#0@@40|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| this@@98 |key#0@@40|) (and ($Is this@@98 Tclass.MemtableMod.Memtable) ($Is |key#0@@40| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q this@@98) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@98)) ($Box |key#0@@40|))) (MemtableMod.Memtable.Memtable_q this@@98))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@98)) ($Box |key#0@@40|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Get this@@98 |key#0@@40|) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@98)) ($Box |key#0@@40|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp this@@98)) ($Box |key#0@@40|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.17:14|
 :skolemid |5588|
 :pattern ( (MemtableMod.Memtable.Get this@@98 |key#0@@40|))
))))
(assert  (=> true (forall ((this@@99 T@U) (|key#0@@41| T@U) ) (!  (=> (and (and (= (type this@@99) DatatypeTypeType) (= (type |key#0@@41|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| (Lit this@@99) (Lit |key#0@@41|)) (and ($Is this@@99 Tclass.MemtableMod.Memtable) ($Is |key#0@@41| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@99)) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@99))) ($Box |key#0@@41|))) (MemtableMod.Memtable.Memtable_q (Lit this@@99)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@99))) ($Box |key#0@@41|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Get (Lit this@@99) (Lit |key#0@@41|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@99))) ($Box |key#0@@41|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MemtableMod.Memtable.mapp (Lit this@@99)))) ($Box (Lit |key#0@@41|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.17:14|
 :weight 3
 :skolemid |5589|
 :pattern ( (MemtableMod.Memtable.Get (Lit this@@99) (Lit |key#0@@41|)))
))))
(assert (forall ((arg0@@587 T@U) (arg1@@291 T@U) ) (! (= (type (MemtableMod.Memtable.ApplyPut arg0@@587 arg1@@291)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.ApplyPut|
 :pattern ( (MemtableMod.Memtable.ApplyPut arg0@@587 arg1@@291))
)))
(assert  (=> true (forall ((this@@100 T@U) (|km#0| T@U) ) (!  (=> (and (and (= (type this@@100) DatatypeTypeType) (= (type |km#0|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| this@@100 |km#0|) (and ($Is this@@100 Tclass.MemtableMod.Memtable) ($Is |km#0| Tclass.MsgHistoryMod.KeyedMessage)))) ($Is (MemtableMod.Memtable.ApplyPut this@@100 |km#0|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.22:14|
 :skolemid |5590|
 :pattern ( (MemtableMod.Memtable.ApplyPut this@@100 |km#0|))
))))
(assert (forall ((this@@101 T@U) (|km#0@@0| T@U) ) (!  (=> (and (and (= (type this@@101) DatatypeTypeType) (= (type |km#0@@0|) DatatypeTypeType)) (and ($Is this@@101 Tclass.MemtableMod.Memtable) ($Is |km#0@@0| Tclass.MsgHistoryMod.KeyedMessage))) (= (|MemtableMod.Memtable.ApplyPut#requires| this@@101 |km#0@@0|) true))
 :qid |Memtableidfy.22:14|
 :skolemid |5591|
 :pattern ( (|MemtableMod.Memtable.ApplyPut#requires| this@@101 |km#0@@0|))
)))
(assert  (=> true (forall ((this@@102 T@U) (|km#0@@1| T@U) ) (!  (=> (and (and (= (type this@@102) DatatypeTypeType) (= (type |km#0@@1|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| this@@102 |km#0@@1|) (and ($Is this@@102 Tclass.MemtableMod.Memtable) ($Is |km#0@@1| Tclass.MsgHistoryMod.KeyedMessage)))) (and (and (and (and (MemtableMod.Memtable.Memtable_q this@@102) (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|)) (and (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|) (|MemtableMod.Memtable.Get#canCall| this@@102 (MsgHistoryMod.KeyedMessage.key |km#0@@1|)))) (|ValueMessage.__default.Merge#canCall| (MsgHistoryMod.KeyedMessage.message |km#0@@1|) (MemtableMod.Memtable.Get this@@102 (MsgHistoryMod.KeyedMessage.key |km#0@@1|))))) (MemtableMod.Memtable.Memtable_q this@@102)) (= (MemtableMod.Memtable.ApplyPut this@@102 |km#0@@1|) (|#MemtableMod.Memtable.Memtable| (|Map#Build| (MemtableMod.Memtable.mapp this@@102) ($Box (MsgHistoryMod.KeyedMessage.key |km#0@@1|)) ($Box (ValueMessage.__default.Merge (MsgHistoryMod.KeyedMessage.message |km#0@@1|) (MemtableMod.Memtable.Get this@@102 (MsgHistoryMod.KeyedMessage.key |km#0@@1|))))) (INTERNAL_add_boogie (MemtableMod.Memtable.seqEnd this@@102) 1)))))
 :qid |Memtableidfy.22:14|
 :skolemid |5592|
 :pattern ( (MemtableMod.Memtable.ApplyPut this@@102 |km#0@@1|))
))))
(assert  (=> true (forall ((this@@103 T@U) (|km#0@@2| T@U) ) (!  (=> (and (and (= (type this@@103) DatatypeTypeType) (= (type |km#0@@2|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| (Lit this@@103) (Lit |km#0@@2|)) (and ($Is this@@103 Tclass.MemtableMod.Memtable) ($Is |km#0@@2| Tclass.MsgHistoryMod.KeyedMessage)))) (and (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@103)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|))) (and (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|)) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|)) (|MemtableMod.Memtable.Get#canCall| (Lit this@@103) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))) (|ValueMessage.__default.Merge#canCall| (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|))) (Lit (MemtableMod.Memtable.Get (Lit this@@103) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))))) (MemtableMod.Memtable.Memtable_q (Lit this@@103))) (= (MemtableMod.Memtable.ApplyPut (Lit this@@103) (Lit |km#0@@2|)) (|#MemtableMod.Memtable.Memtable| (|Map#Build| (Lit (MemtableMod.Memtable.mapp (Lit this@@103))) ($Box (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))) ($Box (Lit (ValueMessage.__default.Merge (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|))) (Lit (MemtableMod.Memtable.Get (Lit this@@103) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|))))))))) (LitInt (INTERNAL_add_boogie (MemtableMod.Memtable.seqEnd (Lit this@@103)) 1))))))
 :qid |Memtableidfy.22:14|
 :weight 3
 :skolemid |5593|
 :pattern ( (MemtableMod.Memtable.ApplyPut (Lit this@@103) (Lit |km#0@@2|)))
))))
(assert (forall ((arg0@@588 T@U) (arg1@@292 T@U) (arg2@@161 T@U) ) (! (= (type (MemtableMod.Memtable.ApplyPuts arg0@@588 arg1@@292 arg2@@161)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.ApplyPuts|
 :pattern ( (MemtableMod.Memtable.ApplyPuts arg0@@588 arg1@@292 arg2@@161))
)))
(assert (forall (($ly@@321 T@U) (this@@104 T@U) (|puts#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@321) LayerTypeType) (= (type this@@104) DatatypeTypeType)) (= (type |puts#0@@0|) DatatypeTypeType)) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@321) this@@104 |puts#0@@0|) (MemtableMod.Memtable.ApplyPuts $ly@@321 this@@104 |puts#0@@0|)))
 :qid |Memtableidfy.27:14|
 :skolemid |5594|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@321) this@@104 |puts#0@@0|))
)))
(assert (forall (($ly@@322 T@U) (this@@105 T@U) (|puts#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@322) LayerTypeType) (= (type this@@105) DatatypeTypeType)) (= (type |puts#0@@1|) DatatypeTypeType)) (= (MemtableMod.Memtable.ApplyPuts $ly@@322 this@@105 |puts#0@@1|) (MemtableMod.Memtable.ApplyPuts $LZ this@@105 |puts#0@@1|)))
 :qid |Memtableidfy.27:14|
 :skolemid |5595|
 :pattern ( (MemtableMod.Memtable.ApplyPuts (AsFuelBottom $ly@@322) this@@105 |puts#0@@1|))
)))
(assert  (=> true (forall (($ly@@323 T@U) (this@@106 T@U) (|puts#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@323) LayerTypeType) (= (type this@@106) DatatypeTypeType)) (= (type |puts#0@@2|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@106 |puts#0@@2|) (and (and ($Is this@@106 Tclass.MemtableMod.Memtable) ($Is |puts#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |puts#0@@2|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@2|) (MemtableMod.Memtable.seqEnd this@@106)))))) ($Is (MemtableMod.Memtable.ApplyPuts $ly@@323 this@@106 |puts#0@@2|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.27:14|
 :skolemid |5596|
 :pattern ( (MemtableMod.Memtable.ApplyPuts $ly@@323 this@@106 |puts#0@@2|))
))))
(assert (forall (($ly@@324 T@U) (this@@107 T@U) (|puts#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@324) LayerTypeType) (= (type this@@107) DatatypeTypeType)) (= (type |puts#0@@3|) DatatypeTypeType)) (and ($Is this@@107 Tclass.MemtableMod.Memtable) ($Is |puts#0@@3| Tclass.MsgHistoryMod.MsgHistory))) (= (|MemtableMod.Memtable.ApplyPuts#requires| $ly@@324 this@@107 |puts#0@@3|)  (and (MsgHistoryMod.MsgHistory.WF |puts#0@@3|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@3|) (MemtableMod.Memtable.seqEnd this@@107)))))
 :qid |Memtableidfy.27:14|
 :skolemid |5597|
 :pattern ( (|MemtableMod.Memtable.ApplyPuts#requires| $ly@@324 this@@107 |puts#0@@3|))
)))
(assert  (=> true (forall (($ly@@325 T@U) (this@@108 T@U) (|puts#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@325) LayerTypeType) (= (type this@@108) DatatypeTypeType)) (= (type |puts#0@@4|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@108 |puts#0@@4|) (and (and ($Is this@@108 Tclass.MemtableMod.Memtable) ($Is |puts#0@@4| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |puts#0@@4|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@4|) (MemtableMod.Memtable.seqEnd this@@108)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| |puts#0@@4|) (=> (not (MsgHistoryMod.MsgHistory.IsEmpty |puts#0@@4|)) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@4|) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| |puts#0@@4| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1))) (|MemtableMod.Memtable.ApplyPuts#canCall| this@@108 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@4| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@4|) (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@4|))) (|MemtableMod.Memtable.ApplyPut#canCall| (MemtableMod.Memtable.ApplyPuts $ly@@325 this@@108 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@4| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |puts#0@@4|)) ($Box (int_2_U (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@325) this@@108 |puts#0@@4|) (ite (MsgHistoryMod.MsgHistory.IsEmpty |puts#0@@4|) this@@108 (MemtableMod.Memtable.ApplyPut (MemtableMod.Memtable.ApplyPuts $ly@@325 this@@108 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@4| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |puts#0@@4|)) ($Box (int_2_U (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@4|) 1))))))))))
 :qid |Memtableidfy.27:14|
 :skolemid |5598|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@325) this@@108 |puts#0@@4|))
))))
(assert  (=> true (forall (($ly@@326 T@U) (this@@109 T@U) (|puts#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@326) LayerTypeType) (= (type this@@109) DatatypeTypeType)) (= (type |puts#0@@5|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@109 (Lit |puts#0@@5|)) (and (and ($Is this@@109 Tclass.MemtableMod.Memtable) ($Is |puts#0@@5| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |puts#0@@5|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit |puts#0@@5|))) (MemtableMod.Memtable.seqEnd this@@109)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit |puts#0@@5|)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@5|)))))) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))) (|MemtableMod.Memtable.ApplyPuts#canCall| this@@109 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)))) (|MemtableMod.Memtable.ApplyPut#canCall| (MemtableMod.Memtable.ApplyPuts ($LS $ly@@326) this@@109 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@5|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@326) this@@109 (Lit |puts#0@@5|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@5|)) this@@109 (MemtableMod.Memtable.ApplyPut (MemtableMod.Memtable.ApplyPuts ($LS $ly@@326) this@@109 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@5|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))))))))
 :qid |Memtableidfy.27:14|
 :weight 3
 :skolemid |5599|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@326) this@@109 (Lit |puts#0@@5|)))
))))
(assert  (=> true (forall (($ly@@327 T@U) (this@@110 T@U) (|puts#0@@6| T@U) ) (!  (=> (and (and (and (= (type $ly@@327) LayerTypeType) (= (type this@@110) DatatypeTypeType)) (= (type |puts#0@@6|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit this@@110) (Lit |puts#0@@6|)) (and (and ($Is this@@110 Tclass.MemtableMod.Memtable) ($Is |puts#0@@6| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |puts#0@@6|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit |puts#0@@6|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@110)))))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit |puts#0@@6|)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@6|)))))) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@6|)) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit |puts#0@@6|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))) (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit this@@110) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@6|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@6|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@6|)))) (|MemtableMod.Memtable.ApplyPut#canCall| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $ly@@327) (Lit this@@110) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@6|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@6|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@327) (Lit this@@110) (Lit |puts#0@@6|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@6|)) this@@110 (MemtableMod.Memtable.ApplyPut (Lit (MemtableMod.Memtable.ApplyPuts ($LS $ly@@327) (Lit this@@110) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@6|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@6|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@6|)) 1)))))))))))
 :qid |Memtableidfy.27:14|
 :weight 3
 :skolemid |5600|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@327) (Lit this@@110) (Lit |puts#0@@6|)))
))))
(assert (forall ((arg0@@589 T@U) (arg1@@293 T@U) ) (! (= (type (MemtableMod.Memtable.Query arg0@@589 arg1@@293)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Query|
 :pattern ( (MemtableMod.Memtable.Query arg0@@589 arg1@@293))
)))
(assert  (=> true (forall ((this@@111 T@U) (|key#0@@42| T@U) ) (!  (=> (and (and (= (type this@@111) DatatypeTypeType) (= (type |key#0@@42|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| this@@111 |key#0@@42|) (and ($Is this@@111 Tclass.MemtableMod.Memtable) ($Is |key#0@@42| Tclass.KeyType.Key)))) ($Is (MemtableMod.Memtable.Query this@@111 |key#0@@42|) Tclass.ValueMessage.Message))
 :qid |Memtableidfy.36:14|
 :skolemid |5601|
 :pattern ( (MemtableMod.Memtable.Query this@@111 |key#0@@42|))
))))
(assert (forall ((this@@112 T@U) (|key#0@@43| T@U) ) (!  (=> (and (and (= (type this@@112) DatatypeTypeType) (= (type |key#0@@43|) (SeqType BoxType))) (and ($Is this@@112 Tclass.MemtableMod.Memtable) ($Is |key#0@@43| Tclass.KeyType.Key))) (= (|MemtableMod.Memtable.Query#requires| this@@112 |key#0@@43|) true))
 :qid |Memtableidfy.36:14|
 :skolemid |5602|
 :pattern ( (|MemtableMod.Memtable.Query#requires| this@@112 |key#0@@43|))
)))
(assert  (=> true (forall ((this@@113 T@U) (|key#0@@44| T@U) ) (!  (=> (and (and (= (type this@@113) DatatypeTypeType) (= (type |key#0@@44|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| this@@113 |key#0@@44|) (and ($Is this@@113 Tclass.MemtableMod.Memtable) ($Is |key#0@@44| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q this@@113) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@113)) ($Box |key#0@@44|))) (MemtableMod.Memtable.Memtable_q this@@113))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@113)) ($Box |key#0@@44|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Query this@@113 |key#0@@44|) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@113)) ($Box |key#0@@44|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp this@@113)) ($Box |key#0@@44|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.36:14|
 :skolemid |5603|
 :pattern ( (MemtableMod.Memtable.Query this@@113 |key#0@@44|))
))))
(assert  (=> true (forall ((this@@114 T@U) (|key#0@@45| T@U) ) (!  (=> (and (and (= (type this@@114) DatatypeTypeType) (= (type |key#0@@45|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| (Lit this@@114) (Lit |key#0@@45|)) (and ($Is this@@114 Tclass.MemtableMod.Memtable) ($Is |key#0@@45| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@114)) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@114))) ($Box |key#0@@45|))) (MemtableMod.Memtable.Memtable_q (Lit this@@114)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@114))) ($Box |key#0@@45|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Query (Lit this@@114) (Lit |key#0@@45|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@114))) ($Box |key#0@@45|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MemtableMod.Memtable.mapp (Lit this@@114)))) ($Box (Lit |key#0@@45|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.36:14|
 :weight 3
 :skolemid |5604|
 :pattern ( (MemtableMod.Memtable.Query (Lit this@@114) (Lit |key#0@@45|)))
))))
(assert (forall ((arg0@@590 T@U) ) (! (= (type (MemtableMod.Memtable.Drain arg0@@590)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Drain|
 :pattern ( (MemtableMod.Memtable.Drain arg0@@590))
)))
(assert  (=> true (forall ((this@@115 T@U) ) (!  (=> (and (= (type this@@115) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| this@@115) ($Is this@@115 Tclass.MemtableMod.Memtable))) ($Is (MemtableMod.Memtable.Drain this@@115) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.42:14|
 :skolemid |5605|
 :pattern ( (MemtableMod.Memtable.Drain this@@115))
))))
(assert (forall ((this@@116 T@U) ) (!  (=> (and (= (type this@@116) DatatypeTypeType) ($Is this@@116 Tclass.MemtableMod.Memtable)) (= (|MemtableMod.Memtable.Drain#requires| this@@116) true))
 :qid |Memtableidfy.42:14|
 :skolemid |5606|
 :pattern ( (|MemtableMod.Memtable.Drain#requires| this@@116))
)))
(assert (forall ((arg0@@591 Int) ) (! (= (type (MemtableMod.__default.EmptyMemtable arg0@@591)) DatatypeTypeType)
 :qid |funType:MemtableMod.__default.EmptyMemtable|
 :pattern ( (MemtableMod.__default.EmptyMemtable arg0@@591))
)))
(assert  (=> true (forall ((this@@117 T@U) ) (!  (=> (and (= (type this@@117) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| this@@117) ($Is this@@117 Tclass.MemtableMod.Memtable))) (and (and (MemtableMod.Memtable.Memtable_q this@@117) (|MemtableMod.__default.EmptyMemtable#canCall| (MemtableMod.Memtable.seqEnd this@@117))) (= (MemtableMod.Memtable.Drain this@@117) (MemtableMod.__default.EmptyMemtable (MemtableMod.Memtable.seqEnd this@@117)))))
 :qid |Memtableidfy.42:14|
 :skolemid |5607|
 :pattern ( (MemtableMod.Memtable.Drain this@@117))
))))
(assert  (=> true (forall ((this@@118 T@U) ) (!  (=> (and (= (type this@@118) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| (Lit this@@118)) ($Is this@@118 Tclass.MemtableMod.Memtable))) (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@118)) (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@118))))) (= (MemtableMod.Memtable.Drain (Lit this@@118)) (Lit (MemtableMod.__default.EmptyMemtable (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@118))))))))
 :qid |Memtableidfy.42:14|
 :weight 3
 :skolemid |5608|
 :pattern ( (MemtableMod.Memtable.Drain (Lit this@@118)))
))))
(assert  (=> true (forall ((this@@119 T@U) ) (!  (=> (and (= (type this@@119) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| this@@119) ($Is this@@119 Tclass.MemtableMod.Memtable))) true)
 :qid |Memtableidfy.47:15|
 :skolemid |5609|
 :pattern ( (MemtableMod.Memtable.IsEmpty this@@119))
))))
(assert (forall ((this@@120 T@U) ) (!  (=> (and (= (type this@@120) DatatypeTypeType) ($Is this@@120 Tclass.MemtableMod.Memtable)) (= (|MemtableMod.Memtable.IsEmpty#requires| this@@120) true))
 :qid |Memtableidfy.47:15|
 :skolemid |5610|
 :pattern ( (|MemtableMod.Memtable.IsEmpty#requires| this@@120))
)))
(assert  (=> true (forall ((this@@121 T@U) ) (!  (=> (and (= (type this@@121) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| this@@121) ($Is this@@121 Tclass.MemtableMod.Memtable))) (and (MemtableMod.Memtable.Memtable_q this@@121) (= (MemtableMod.Memtable.IsEmpty this@@121) (|Set#Equal| (|Map#Domain| (MemtableMod.Memtable.mapp this@@121)) (|Set#Empty| BoxType)))))
 :qid |Memtableidfy.47:15|
 :skolemid |5611|
 :pattern ( (MemtableMod.Memtable.IsEmpty this@@121))
))))
(assert  (=> true (forall ((this@@122 T@U) ) (!  (=> (and (= (type this@@122) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| (Lit this@@122)) ($Is this@@122 Tclass.MemtableMod.Memtable))) (and (MemtableMod.Memtable.Memtable_q (Lit this@@122)) (= (MemtableMod.Memtable.IsEmpty (Lit this@@122)) (|Set#Equal| (|Map#Domain| (Lit (MemtableMod.Memtable.mapp (Lit this@@122)))) (|Set#Empty| BoxType)))))
 :qid |Memtableidfy.47:15|
 :weight 3
 :skolemid |5612|
 :pattern ( (MemtableMod.Memtable.IsEmpty (Lit this@@122)))
))))
(assert (= (type Tclass.MemtableMod.__default) TyType))
(assert (= (Tag Tclass.MemtableMod.__default) Tagclass.MemtableMod.__default))
(assert (= (TagFamily Tclass.MemtableMod.__default) tytagFamily$_default))
(assert (forall ((bx@@169 T@U) ) (!  (=> (and (= (type bx@@169) BoxType) ($IsBox bx@@169 Tclass.MemtableMod.__default)) (and (= ($Box ($Unbox refType bx@@169)) bx@@169) ($Is ($Unbox refType bx@@169) Tclass.MemtableMod.__default)))
 :qid |unknown.0:0|
 :skolemid |5613|
 :pattern ( ($IsBox bx@@169 Tclass.MemtableMod.__default))
)))
(assert (forall (($o@@49 T@U) ) (!  (=> (= (type $o@@49) refType) (= ($Is $o@@49 Tclass.MemtableMod.__default)  (or (= $o@@49 null) (= (dtype $o@@49) Tclass.MemtableMod.__default))))
 :qid |unknown.0:0|
 :skolemid |5614|
 :pattern ( ($Is $o@@49 Tclass.MemtableMod.__default))
)))
(assert (forall (($o@@50 T@U) ($h@@109 T@U) ) (!  (=> (and (= (type $o@@50) refType) (= (type $h@@109) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@109)  (or (= $o@@50 null) (U_2_bool (MapType1Select (MapType0Select $h@@109 $o@@50) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5615|
 :pattern ( ($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@109))
)))
(assert  (=> true (forall ((|lsn#0@@36| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| |lsn#0@@36|) (INTERNAL_le_boogie 0 |lsn#0@@36|)) ($Is (MemtableMod.__default.EmptyMemtable |lsn#0@@36|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.53:26|
 :skolemid |5616|
 :pattern ( (MemtableMod.__default.EmptyMemtable |lsn#0@@36|))
))))
(assert (forall ((|lsn#0@@37| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@37|) (= (|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|) true))
 :qid |Memtableidfy.53:26|
 :skolemid |5617|
 :pattern ( (|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|))
)))
(assert  (=> true (forall ((|lsn#0@@38| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| |lsn#0@@38|) (INTERNAL_le_boogie 0 |lsn#0@@38|)) (= (MemtableMod.__default.EmptyMemtable |lsn#0@@38|) (|#MemtableMod.Memtable.Memtable| (Lit (|Map#Empty| BoxType BoxType)) |lsn#0@@38|)))
 :qid |Memtableidfy.53:26|
 :skolemid |5618|
 :pattern ( (MemtableMod.__default.EmptyMemtable |lsn#0@@38|))
))))
(assert  (=> true (forall ((|lsn#0@@39| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt |lsn#0@@39|)) (INTERNAL_le_boogie 0 |lsn#0@@39|)) (= (MemtableMod.__default.EmptyMemtable (LitInt |lsn#0@@39|)) (Lit (|#MemtableMod.Memtable.Memtable| (Lit (|Map#Empty| BoxType BoxType)) (LitInt |lsn#0@@39|)))))
 :qid |Memtableidfy.53:26|
 :weight 3
 :skolemid |5619|
 :pattern ( (MemtableMod.__default.EmptyMemtable (LitInt |lsn#0@@39|)))
))))
(assert (= (type Tclass.Sets.__default) TyType))
(assert (= (Tag Tclass.Sets.__default) Tagclass.Sets.__default))
(assert (= (TagFamily Tclass.Sets.__default) tytagFamily$_default))
(assert (forall ((bx@@170 T@U) ) (!  (=> (and (= (type bx@@170) BoxType) ($IsBox bx@@170 Tclass.Sets.__default)) (and (= ($Box ($Unbox refType bx@@170)) bx@@170) ($Is ($Unbox refType bx@@170) Tclass.Sets.__default)))
 :qid |unknown.0:0|
 :skolemid |5620|
 :pattern ( ($IsBox bx@@170 Tclass.Sets.__default))
)))
(assert (forall (($o@@51 T@U) ) (!  (=> (= (type $o@@51) refType) (= ($Is $o@@51 Tclass.Sets.__default)  (or (= $o@@51 null) (= (dtype $o@@51) Tclass.Sets.__default))))
 :qid |unknown.0:0|
 :skolemid |5621|
 :pattern ( ($Is $o@@51 Tclass.Sets.__default))
)))
(assert (forall (($o@@52 T@U) ($h@@110 T@U) ) (!  (=> (and (= (type $o@@52) refType) (= (type $h@@110) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@52 Tclass.Sets.__default $h@@110)  (or (= $o@@52 null) (U_2_bool (MapType1Select (MapType0Select $h@@110 $o@@52) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5622|
 :pattern ( ($IsAlloc $o@@52 Tclass.Sets.__default $h@@110))
)))
(assert (forall ((arg0@@592 Int) ) (! (= (type (Sets.__default.SetRange arg0@@592)) (MapType0Type BoxType boolType))
 :qid |funType:Sets.__default.SetRange|
 :pattern ( (Sets.__default.SetRange arg0@@592))
)))
(assert  (=> true (forall ((|n#0@@12| Int) ) (!  (=> true ($Is (Sets.__default.SetRange |n#0@@12|) (TSet TInt)))
 :qid |Setsidfy.35:21|
 :skolemid |5623|
 :pattern ( (Sets.__default.SetRange |n#0@@12|))
))))
(assert (forall ((|n#0@@13| Int) ) (! (= (|Sets.__default.SetRange#requires| |n#0@@13|) true)
 :qid |Setsidfy.35:21|
 :skolemid |5624|
 :pattern ( (|Sets.__default.SetRange#requires| |n#0@@13|))
)))
(assert  (=> true (forall ((|n#0@@14| Int) ) (!  (=> true (= (Sets.__default.SetRange |n#0@@14|) (|lambda#260| TInt 0 |n#0@@14|)))
 :qid |Setsidfy.35:21|
 :skolemid |5625|
 :pattern ( (Sets.__default.SetRange |n#0@@14|))
))))
(assert  (=> true (forall ((|n#0@@15| Int) ) (!  (=> true (= (Sets.__default.SetRange (LitInt |n#0@@15|)) (|lambda#260| TInt 0 |n#0@@15|)))
 :qid |Setsidfy.35:21|
 :weight 3
 :skolemid |5626|
 :pattern ( (Sets.__default.SetRange (LitInt |n#0@@15|)))
))))
(assert (forall (($ly@@328 T@U) (|a#0@@86| T@U) ) (!  (=> (and (= (type $ly@@328) LayerTypeType) (= (type |a#0@@86|) (MapType0Type BoxType boolType))) (= (Sets.__default.SetMax ($LS $ly@@328) |a#0@@86|) (Sets.__default.SetMax $ly@@328 |a#0@@86|)))
 :qid |Setsidfy.59:12|
 :skolemid |5627|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@328) |a#0@@86|))
)))
(assert (forall (($ly@@329 T@U) (|a#0@@87| T@U) ) (!  (=> (and (= (type $ly@@329) LayerTypeType) (= (type |a#0@@87|) (MapType0Type BoxType boolType))) (= (Sets.__default.SetMax $ly@@329 |a#0@@87|) (Sets.__default.SetMax $LZ |a#0@@87|)))
 :qid |Setsidfy.59:12|
 :skolemid |5628|
 :pattern ( (Sets.__default.SetMax (AsFuelBottom $ly@@329) |a#0@@87|))
)))
(assert  (=> true (forall (($ly@@330 T@U) (|a#0@@88| T@U) ) (!  (=> (and (and (= (type $ly@@330) LayerTypeType) (= (type |a#0@@88|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| |a#0@@88|) (and ($Is |a#0@@88| (TSet TInt)) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@88|))))) (and (forall ((|e#0@@4| T@U) ) (!  (=> (and (= (type |e#0@@4|) intType) (U_2_bool (MapType0Select |a#0@@88| ($Box |e#0@@4|)))) (INTERNAL_le_boogie (U_2_int |e#0@@4|) (Sets.__default.SetMax $ly@@330 |a#0@@88|)))
 :qid |Setsidfy.61:20|
 :skolemid |5629|
 :pattern ( (MapType0Select |a#0@@88| ($Box |e#0@@4|)))
)) (U_2_bool (MapType0Select |a#0@@88| ($Box (int_2_U (Sets.__default.SetMax $ly@@330 |a#0@@88|)))))))
 :qid |Setsidfy.59:12|
 :skolemid |5630|
 :pattern ( (Sets.__default.SetMax $ly@@330 |a#0@@88|))
))))
(assert (forall (($ly@@331 T@U) ($Heap@@53 T@U) (|a#0@@89| T@U) ) (!  (=> (and (and (and (= (type $ly@@331) LayerTypeType) (= (type $Heap@@53) (MapType0Type refType MapType1Type))) (= (type |a#0@@89|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@53) ($Is |a#0@@89| (TSet TInt)))) (= (|Sets.__default.SetMax#requires| $ly@@331 |a#0@@89|) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@89|))))
 :qid |Setsidfy.59:12|
 :skolemid |5631|
 :pattern ( (|Sets.__default.SetMax#requires| $ly@@331 |a#0@@89|) ($IsGoodHeap $Heap@@53))
)))
(assert (forall ((a@@138 T@U) ) (!  (=> (and (= (type a@@138) (MapType0Type BoxType boolType)) (|$let#13$canCall| a@@138)) (U_2_bool (MapType0Select a@@138 ($Box (int_2_U (|$let#13_e| a@@138))))))
 :qid |Setsidfy.64:5|
 :skolemid |5632|
 :pattern ( (|$let#13_e| a@@138))
)))
(assert  (=> true (forall (($ly@@332 T@U) ($Heap@@54 T@U) (|a#0@@90| T@U) ) (!  (=> (and (and (and (= (type $ly@@332) LayerTypeType) (= (type $Heap@@54) (MapType0Type refType MapType1Type))) (= (type |a#0@@90|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| |a#0@@90|) (and (and ($IsGoodHeap $Heap@@54) ($Is |a#0@@90| (TSet TInt))) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@90|))))) (and (and (|$let#13$canCall| |a#0@@90|) (=> (not (= (|Set#Card| |a#0@@90|) (LitInt 1))) (|Sets.__default.SetMax#canCall| (|Set#Difference| |a#0@@90| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#13_e| |a#0@@90|)))))))) (= (Sets.__default.SetMax ($LS $ly@@332) |a#0@@90|) (let ((|e#1| (|$let#13_e| |a#0@@90|)))
(ite (= (|Set#Card| |a#0@@90|) (LitInt 1)) |e#1| (let ((|rest#0| (Sets.__default.SetMax $ly@@332 (|Set#Difference| |a#0@@90| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#1|)))))))
(let ((|out#0@@0| (ite (INTERNAL_lt_boogie |e#1| |rest#0|) |rest#0| |e#1|)))
|out#0@@0|)))))))
 :qid |Setsidfy.59:12|
 :skolemid |5633|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@332) |a#0@@90|) ($IsGoodHeap $Heap@@54))
))))
(assert  (=> true (forall (($ly@@333 T@U) ($Heap@@55 T@U) (|a#0@@91| T@U) ) (!  (=> (and (and (and (= (type $ly@@333) LayerTypeType) (= (type $Heap@@55) (MapType0Type refType MapType1Type))) (= (type |a#0@@91|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| (Lit |a#0@@91|)) (and (and ($IsGoodHeap $Heap@@55) ($Is |a#0@@91| (TSet TInt))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |a#0@@91|)))))) (and (and (|$let#13$canCall| (Lit |a#0@@91|)) (=> (not (= (|Set#Card| (Lit |a#0@@91|)) (LitInt 1))) (|Sets.__default.SetMax#canCall| (|Set#Difference| |a#0@@91| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#13_e| (Lit |a#0@@91|))))))))) (= (Sets.__default.SetMax ($LS $ly@@333) (Lit |a#0@@91|)) (let ((|e#2| (|$let#13_e| (Lit |a#0@@91|))))
(ite (= (|Set#Card| (Lit |a#0@@91|)) (LitInt 1)) |e#2| (let ((|rest#2| (Sets.__default.SetMax ($LS $ly@@333) (|Set#Difference| |a#0@@91| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#2|)))))))
(let ((|out#2@@0| (ite (INTERNAL_lt_boogie |e#2| |rest#2|) |rest#2| |e#2|)))
|out#2@@0|)))))))
 :qid |Setsidfy.59:12|
 :weight 3
 :skolemid |5634|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@333) (Lit |a#0@@91|)) ($IsGoodHeap $Heap@@55))
))))
(assert (forall ((arg0@@593 T@U) (arg1@@294 T@U) (arg2@@162 T@U) ) (! (= (type (Sets.__default.UnionSeqOfSets arg0@@593 arg1@@294 arg2@@162)) (MapType0Type BoxType boolType))
 :qid |funType:Sets.__default.UnionSeqOfSets|
 :pattern ( (Sets.__default.UnionSeqOfSets arg0@@593 arg1@@294 arg2@@162))
)))
(assert (forall ((Sets._default.UnionSeqOfSets$T T@U) ($ly@@334 T@U) (|s#0@@107| T@U) ) (!  (=> (and (and (= (type Sets._default.UnionSeqOfSets$T) TyType) (= (type $ly@@334) LayerTypeType)) (= (type |s#0@@107|) (SeqType BoxType))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T ($LS $ly@@334) |s#0@@107|) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T $ly@@334 |s#0@@107|)))
 :qid |unknown.0:0|
 :skolemid |5635|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T ($LS $ly@@334) |s#0@@107|))
)))
(assert (forall ((Sets._default.UnionSeqOfSets$T@@0 T@U) ($ly@@335 T@U) (|s#0@@108| T@U) ) (!  (=> (and (and (= (type Sets._default.UnionSeqOfSets$T@@0) TyType) (= (type $ly@@335) LayerTypeType)) (= (type |s#0@@108|) (SeqType BoxType))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 $ly@@335 |s#0@@108|) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 $LZ |s#0@@108|)))
 :qid |unknown.0:0|
 :skolemid |5636|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 (AsFuelBottom $ly@@335) |s#0@@108|))
)))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@1 T@U) ($ly@@336 T@U) (|s#0@@109| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@1) TyType) (= (type $ly@@336) LayerTypeType)) (= (type |s#0@@109|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@1 |s#0@@109|) ($Is |s#0@@109| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@1))))) (and (forall ((|i#0@@104| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@104|) (INTERNAL_lt_boogie |i#0@@104| (|Seq#Length| |s#0@@109|))) (|Set#Subset| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@109| |i#0@@104|)) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@336 |s#0@@109|)))
 :qid |Setsidfy.93:20|
 :skolemid |5637|
 :pattern ( ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@109| |i#0@@104|)))
)) ($Is (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@336 |s#0@@109|) (TSet Sets._default.UnionSeqOfSets$T@@1))))
 :qid |unknown.0:0|
 :skolemid |5638|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@336 |s#0@@109|))
))))
(assert (forall ((Sets._default.UnionSeqOfSets$T@@2 T@U) ($ly@@337 T@U) (|s#0@@110| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@2) TyType) (= (type $ly@@337) LayerTypeType)) (= (type |s#0@@110|) (SeqType BoxType))) ($Is |s#0@@110| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@2)))) (= (|Sets.__default.UnionSeqOfSets#requires| Sets._default.UnionSeqOfSets$T@@2 $ly@@337 |s#0@@110|) true))
 :qid |unknown.0:0|
 :skolemid |5639|
 :pattern ( (|Sets.__default.UnionSeqOfSets#requires| Sets._default.UnionSeqOfSets$T@@2 $ly@@337 |s#0@@110|))
)))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@3 T@U) ($ly@@338 T@U) (|s#0@@111| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@3) TyType) (= (type $ly@@338) LayerTypeType)) (= (type |s#0@@111|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@3 |s#0@@111|) ($Is |s#0@@111| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@3))))) (and (=> (not (= (|Seq#Length| |s#0@@111|) (LitInt 0))) (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@3 (|Seq#Drop| |s#0@@111| (LitInt 1)))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 ($LS $ly@@338) |s#0@@111|) (ite (= (|Seq#Length| |s#0@@111|) (LitInt 0)) (|Set#Empty| BoxType) (|Set#Union| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@111| (LitInt 0))) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 $ly@@338 (|Seq#Drop| |s#0@@111| (LitInt 1))))))))
 :qid |unknown.0:0|
 :skolemid |5640|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 ($LS $ly@@338) |s#0@@111|))
))))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@4 T@U) ($ly@@339 T@U) (|s#0@@112| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@4) TyType) (= (type $ly@@339) LayerTypeType)) (= (type |s#0@@112|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@4 (Lit |s#0@@112|)) ($Is |s#0@@112| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@4))))) (and (=> (not (= (|Seq#Length| (Lit |s#0@@112|)) (LitInt 0))) (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@4 (Lit (|Seq#Drop| (Lit |s#0@@112|) (LitInt 1))))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@339) (Lit |s#0@@112|)) (ite (= (|Seq#Length| (Lit |s#0@@112|)) (LitInt 0)) (|Set#Empty| BoxType) (|Set#Union| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit |s#0@@112|) (LitInt 0))) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@339) (Lit (|Seq#Drop| (Lit |s#0@@112|) (LitInt 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5641|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@339) (Lit |s#0@@112|)))
))))
(assert (= (type Tclass.SeqComparison.__default) TyType))
(assert (= (Tag Tclass.SeqComparison.__default) Tagclass.SeqComparison.__default))
(assert (= (TagFamily Tclass.SeqComparison.__default) tytagFamily$_default))
(assert (forall ((bx@@171 T@U) ) (!  (=> (and (= (type bx@@171) BoxType) ($IsBox bx@@171 Tclass.SeqComparison.__default)) (and (= ($Box ($Unbox refType bx@@171)) bx@@171) ($Is ($Unbox refType bx@@171) Tclass.SeqComparison.__default)))
 :qid |unknown.0:0|
 :skolemid |5642|
 :pattern ( ($IsBox bx@@171 Tclass.SeqComparison.__default))
)))
(assert (forall (($o@@53 T@U) ) (!  (=> (= (type $o@@53) refType) (= ($Is $o@@53 Tclass.SeqComparison.__default)  (or (= $o@@53 null) (= (dtype $o@@53) Tclass.SeqComparison.__default))))
 :qid |unknown.0:0|
 :skolemid |5643|
 :pattern ( ($Is $o@@53 Tclass.SeqComparison.__default))
)))
(assert (forall (($o@@54 T@U) ($h@@111 T@U) ) (!  (=> (and (= (type $o@@54) refType) (= (type $h@@111) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@54 Tclass.SeqComparison.__default $h@@111)  (or (= $o@@54 null) (U_2_bool (MapType1Select (MapType0Select $h@@111 $o@@54) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5644|
 :pattern ( ($IsAlloc $o@@54 Tclass.SeqComparison.__default $h@@111))
)))
(assert (forall (($ly@@340 T@U) (|a#0@@92| T@U) (|b#0@@50| T@U) ) (!  (=> (and (and (= (type $ly@@340) LayerTypeType) (= (type |a#0@@92|) (SeqType BoxType))) (= (type |b#0@@50|) (SeqType BoxType))) (= (SeqComparison.__default.lte ($LS $ly@@340) |a#0@@92| |b#0@@50|) (SeqComparison.__default.lte $ly@@340 |a#0@@92| |b#0@@50|)))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |5645|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@340) |a#0@@92| |b#0@@50|))
)))
(assert (forall (($ly@@341 T@U) (|a#0@@93| T@U) (|b#0@@51| T@U) ) (!  (=> (and (and (= (type $ly@@341) LayerTypeType) (= (type |a#0@@93|) (SeqType BoxType))) (= (type |b#0@@51|) (SeqType BoxType))) (= (SeqComparison.__default.lte $ly@@341 |a#0@@93| |b#0@@51|) (SeqComparison.__default.lte $LZ |a#0@@93| |b#0@@51|)))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |5646|
 :pattern ( (SeqComparison.__default.lte (AsFuelBottom $ly@@341) |a#0@@93| |b#0@@51|))
)))
(assert  (=> true (forall (($ly@@342 T@U) (|a#0@@94| T@U) (|b#0@@52| T@U) ) (!  (=> (and (and (and (= (type $ly@@342) LayerTypeType) (= (type |a#0@@94|) (SeqType BoxType))) (= (type |b#0@@52|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| |a#0@@94| |b#0@@52|) (and ($Is |a#0@@94| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@52| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |5647|
 :pattern ( (SeqComparison.__default.lte $ly@@342 |a#0@@94| |b#0@@52|))
))))
(assert (forall (($ly@@343 T@U) (|a#0@@95| T@U) (|b#0@@53| T@U) ) (!  (=> (and (and (and (= (type $ly@@343) LayerTypeType) (= (type |a#0@@95|) (SeqType BoxType))) (= (type |b#0@@53|) (SeqType BoxType))) (and ($Is |a#0@@95| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@53| (TSeq Tclass.NativeTypes.byte)))) (= (|SeqComparison.__default.lte#requires| $ly@@343 |a#0@@95| |b#0@@53|) true))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |5648|
 :pattern ( (|SeqComparison.__default.lte#requires| $ly@@343 |a#0@@95| |b#0@@53|))
)))
(assert  (=> true (forall (($ly@@344 T@U) (|a#0@@96| T@U) (|b#0@@54| T@U) ) (!  (=> (and (and (and (= (type $ly@@344) LayerTypeType) (= (type |a#0@@96|) (SeqType BoxType))) (= (type |b#0@@54|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| |a#0@@96| |b#0@@54|) (and ($Is |a#0@@96| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@54| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| |a#0@@96|) (LitInt 0))) (=> (not (= (|Seq#Length| |b#0@@54|) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (|Seq#Drop| |a#0@@96| (LitInt 1)) (|Seq#Drop| |b#0@@54| (LitInt 1))))))) (= (SeqComparison.__default.lte ($LS $ly@@344) |a#0@@96| |b#0@@54|) (ite (= (|Seq#Length| |a#0@@96|) (LitInt 0)) true (ite (= (|Seq#Length| |b#0@@54|) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0))))) false (SeqComparison.__default.lte $ly@@344 (|Seq#Drop| |a#0@@96| (LitInt 1)) (|Seq#Drop| |b#0@@54| (LitInt 1))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |5649|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@344) |a#0@@96| |b#0@@54|))
))))
(assert  (=> true (forall (($ly@@345 T@U) (|a#0@@97| T@U) (|b#0@@55| T@U) ) (!  (=> (and (and (and (= (type $ly@@345) LayerTypeType) (= (type |a#0@@97|) (SeqType BoxType))) (= (type |b#0@@55|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| (Lit |a#0@@97|) |b#0@@55|) (and ($Is |a#0@@97| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@55| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@97|)) (LitInt 0))) (=> (not (= (|Seq#Length| |b#0@@55|) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (Lit (|Seq#Drop| (Lit |a#0@@97|) (LitInt 1))) (|Seq#Drop| |b#0@@55| (LitInt 1))))))) (= (SeqComparison.__default.lte ($LS $ly@@345) (Lit |a#0@@97|) |b#0@@55|) (ite (= (|Seq#Length| (Lit |a#0@@97|)) (LitInt 0)) true (ite (= (|Seq#Length| |b#0@@55|) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0))))) false (SeqComparison.__default.lte ($LS $ly@@345) (Lit (|Seq#Drop| (Lit |a#0@@97|) (LitInt 1))) (|Seq#Drop| |b#0@@55| (LitInt 1))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :weight 3
 :skolemid |5650|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@345) (Lit |a#0@@97|) |b#0@@55|))
))))
(assert  (=> true (forall (($ly@@346 T@U) (|a#0@@98| T@U) (|b#0@@56| T@U) ) (!  (=> (and (and (and (= (type $ly@@346) LayerTypeType) (= (type |a#0@@98|) (SeqType BoxType))) (= (type |b#0@@56|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| (Lit |a#0@@98|) (Lit |b#0@@56|)) (and ($Is |a#0@@98| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@56| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@98|)) (LitInt 0))) (=> (not (= (|Seq#Length| (Lit |b#0@@56|)) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (Lit (|Seq#Drop| (Lit |a#0@@98|) (LitInt 1))) (Lit (|Seq#Drop| (Lit |b#0@@56|) (LitInt 1)))))))) (= (SeqComparison.__default.lte ($LS $ly@@346) (Lit |a#0@@98|) (Lit |b#0@@56|)) (ite (= (|Seq#Length| (Lit |a#0@@98|)) (LitInt 0)) true (ite (= (|Seq#Length| (Lit |b#0@@56|)) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0))))) false (SeqComparison.__default.lte ($LS $ly@@346) (Lit (|Seq#Drop| (Lit |a#0@@98|) (LitInt 1))) (Lit (|Seq#Drop| (Lit |b#0@@56|) (LitInt 1)))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :weight 3
 :skolemid |5651|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@346) (Lit |a#0@@98|) (Lit |b#0@@56|)))
))))
(assert  (=> true (forall ((|a#0@@99| T@U) (|b#0@@57| T@U) ) (!  (=> (and (and (= (type |a#0@@99|) (SeqType BoxType)) (= (type |b#0@@57|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| |a#0@@99| |b#0@@57|) (and ($Is |a#0@@99| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@57| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |5652|
 :pattern ( (SeqComparison.__default.lt |a#0@@99| |b#0@@57|))
))))
(assert (forall ((|a#0@@100| T@U) (|b#0@@58| T@U) ) (!  (=> (and (and (= (type |a#0@@100|) (SeqType BoxType)) (= (type |b#0@@58|) (SeqType BoxType))) (and ($Is |a#0@@100| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@58| (TSeq Tclass.NativeTypes.byte)))) (= (|SeqComparison.__default.lt#requires| |a#0@@100| |b#0@@58|) true))
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |5653|
 :pattern ( (|SeqComparison.__default.lt#requires| |a#0@@100| |b#0@@58|))
)))
(assert (= (type StartFuel_SeqComparison._default.lte) LayerTypeType))
(assert  (=> true (forall ((|a#0@@101| T@U) (|b#0@@59| T@U) ) (!  (=> (and (and (= (type |a#0@@101|) (SeqType BoxType)) (= (type |b#0@@59|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| |a#0@@101| |b#0@@59|) (and ($Is |a#0@@101| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@59| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@101| |b#0@@59|) (= (SeqComparison.__default.lt |a#0@@101| |b#0@@59|)  (and (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@101| |b#0@@59|) (not (|Seq#Equal| |a#0@@101| |b#0@@59|))))))
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |5654|
 :pattern ( (SeqComparison.__default.lt |a#0@@101| |b#0@@59|))
))))
(assert  (=> true (forall ((|a#0@@102| T@U) (|b#0@@60| T@U) ) (!  (=> (and (and (= (type |a#0@@102|) (SeqType BoxType)) (= (type |b#0@@60|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| (Lit |a#0@@102|) (Lit |b#0@@60|)) (and ($Is |a#0@@102| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@60| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@102|) (Lit |b#0@@60|)) (= (SeqComparison.__default.lt (Lit |a#0@@102|) (Lit |b#0@@60|))  (and (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@102|) (Lit |b#0@@60|)) (not (|Seq#Equal| |a#0@@102| |b#0@@60|))))))
 :qid |SeqComparisonsdfy.30:16|
 :weight 3
 :skolemid |5655|
 :pattern ( (SeqComparison.__default.lt (Lit |a#0@@102|) (Lit |b#0@@60|)))
))))
(assert (= (type Tclass.NativeArrays.__default) TyType))
(assert (= (Tag Tclass.NativeArrays.__default) Tagclass.NativeArrays.__default))
(assert (= (TagFamily Tclass.NativeArrays.__default) tytagFamily$_default))
(assert (forall ((bx@@172 T@U) ) (!  (=> (and (= (type bx@@172) BoxType) ($IsBox bx@@172 Tclass.NativeArrays.__default)) (and (= ($Box ($Unbox refType bx@@172)) bx@@172) ($Is ($Unbox refType bx@@172) Tclass.NativeArrays.__default)))
 :qid |unknown.0:0|
 :skolemid |5656|
 :pattern ( ($IsBox bx@@172 Tclass.NativeArrays.__default))
)))
(assert (forall (($o@@55 T@U) ) (!  (=> (= (type $o@@55) refType) (= ($Is $o@@55 Tclass.NativeArrays.__default)  (or (= $o@@55 null) (= (dtype $o@@55) Tclass.NativeArrays.__default))))
 :qid |unknown.0:0|
 :skolemid |5657|
 :pattern ( ($Is $o@@55 Tclass.NativeArrays.__default))
)))
(assert (forall (($o@@56 T@U) ($h@@112 T@U) ) (!  (=> (and (= (type $o@@56) refType) (= (type $h@@112) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@56 Tclass.NativeArrays.__default $h@@112)  (or (= $o@@56 null) (U_2_bool (MapType1Select (MapType0Select $h@@112 $o@@56) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5658|
 :pattern ( ($IsAlloc $o@@56 Tclass.NativeArrays.__default $h@@112))
)))
(assert (= (type Tclass.Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Byte__Order.__default) Tagclass.Byte__Order.__default))
(assert (= (TagFamily Tclass.Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@173 T@U) ) (!  (=> (and (= (type bx@@173) BoxType) ($IsBox bx@@173 Tclass.Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@173)) bx@@173) ($Is ($Unbox refType bx@@173) Tclass.Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |5659|
 :pattern ( ($IsBox bx@@173 Tclass.Byte__Order.__default))
)))
(assert (forall (($o@@57 T@U) ) (!  (=> (= (type $o@@57) refType) (= ($Is $o@@57 Tclass.Byte__Order.__default)  (or (= $o@@57 null) (= (dtype $o@@57) Tclass.Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |5660|
 :pattern ( ($Is $o@@57 Tclass.Byte__Order.__default))
)))
(assert (forall (($o@@58 T@U) ($h@@113 T@U) ) (!  (=> (and (= (type $o@@58) refType) (= (type $h@@113) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@58 Tclass.Byte__Order.__default $h@@113)  (or (= $o@@58 null) (U_2_bool (MapType1Select (MapType0Select $h@@113 $o@@58) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5661|
 :pattern ( ($IsAlloc $o@@58 Tclass.Byte__Order.__default $h@@113))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 Byte__Order.__default.SomeElement) (INTERNAL_lt_boogie Byte__Order.__default.SomeElement 256)))))
(assert (= |Byte__Order.__default.SomeElement#requires| true))
(assert  (=> true (=> true (= Byte__Order.__default.SomeElement (LitInt 0)))))
(assert  (=> true (=> true (= Byte__Order.__default.SomeElement (LitInt 0)))))
(assert (forall (($ly@@347 T@U) (|a#0@@103| Int) (|b#0@@61| Int) ) (!  (=> (= (type $ly@@347) LayerTypeType) (= (Byte__Order.__default.lte ($LS $ly@@347) |a#0@@103| |b#0@@61|) (Byte__Order.__default.lte $ly@@347 |a#0@@103| |b#0@@61|)))
 :qid |totalorderidfy.1087:30|
 :skolemid |5662|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@347) |a#0@@103| |b#0@@61|))
)))
(assert (forall (($ly@@348 T@U) (|a#0@@104| Int) (|b#0@@62| Int) ) (!  (=> (= (type $ly@@348) LayerTypeType) (= (Byte__Order.__default.lte $ly@@348 |a#0@@104| |b#0@@62|) (Byte__Order.__default.lte $LZ |a#0@@104| |b#0@@62|)))
 :qid |totalorderidfy.1087:30|
 :skolemid |5663|
 :pattern ( (Byte__Order.__default.lte (AsFuelBottom $ly@@348) |a#0@@104| |b#0@@62|))
)))
(assert (= (type StartFuel_Byte_Order._default.ltedef) LayerTypeType))
(assert  (=> true (forall (($ly@@349 T@U) (|a#0@@105| Int) (|b#0@@63| Int) ) (!  (=> (and (= (type $ly@@349) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| |a#0@@105| |b#0@@63|) (and (and (INTERNAL_le_boogie 0 |a#0@@105|) (INTERNAL_lt_boogie |a#0@@105| 256)) (and (INTERNAL_le_boogie 0 |b#0@@63|) (INTERNAL_lt_boogie |b#0@@63| 256))))) (and (and (and (and (= (Byte__Order.__default.lte $ly@@349 |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|)) (or (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|))) (= (Byte__Order.__default.lte $ly@@349 |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|))) (or (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|))) (=> (and (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|)) (= |a#0@@105| |b#0@@63|))))
 :qid |totalorderidfy.1087:30|
 :skolemid |5664|
 :pattern ( (Byte__Order.__default.lte $ly@@349 |a#0@@105| |b#0@@63|))
))))
(assert (forall (($ly@@350 T@U) (|a#0@@106| Int) (|b#0@@64| Int) ) (!  (=> (= (type $ly@@350) LayerTypeType) (=> (and (and (INTERNAL_le_boogie 0 |a#0@@106|) (INTERNAL_lt_boogie |a#0@@106| 256)) (and (INTERNAL_le_boogie 0 |b#0@@64|) (INTERNAL_lt_boogie |b#0@@64| 256))) (= (|Byte__Order.__default.lte#requires| $ly@@350 |a#0@@106| |b#0@@64|) true)))
 :qid |totalorderidfy.1087:30|
 :skolemid |5665|
 :pattern ( (|Byte__Order.__default.lte#requires| $ly@@350 |a#0@@106| |b#0@@64|))
)))
(assert  (and (= (type MoreFuel_Byte_Order._default.ltedef0) LayerTypeType) (= (type StartFuelAssert_Byte_Order._default.ltedef) LayerTypeType)))
(assert  (=> true (forall (($ly@@351 T@U) (|a#0@@107| Int) (|b#0@@65| Int) ) (!  (=> (and (= (type $ly@@351) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| |a#0@@107| |b#0@@65|) (and (and (INTERNAL_le_boogie 0 |a#0@@107|) (INTERNAL_lt_boogie |a#0@@107| 256)) (and (INTERNAL_le_boogie 0 |b#0@@65|) (INTERNAL_lt_boogie |b#0@@65| 256))))) (and (and (and (= StartFuel_Byte_Order._default.ltedef ($LS MoreFuel_Byte_Order._default.ltedef0)) (= StartFuelAssert_Byte_Order._default.ltedef ($LS ($LS MoreFuel_Byte_Order._default.ltedef0)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.ltedef0) MoreFuel_Byte_Order._default.ltedef0)) (= (Byte__Order.__default.lte ($LS $ly@@351) |a#0@@107| |b#0@@65|) (INTERNAL_le_boogie |a#0@@107| |b#0@@65|))))
 :qid |totalorderidfy.1087:30|
 :skolemid |5666|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@351) |a#0@@107| |b#0@@65|))
))))
(assert (= (type MoreFuel_Byte_Order._default.ltedef1) LayerTypeType))
(assert  (=> true (forall (($ly@@352 T@U) (|a#0@@108| Int) (|b#0@@66| Int) ) (!  (=> (and (= (type $ly@@352) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@108|) (LitInt |b#0@@66|)) (and (and (INTERNAL_le_boogie 0 |a#0@@108|) (INTERNAL_lt_boogie |a#0@@108| 256)) (and (INTERNAL_le_boogie 0 |b#0@@66|) (INTERNAL_lt_boogie |b#0@@66| 256))))) (and (and (and (= StartFuel_Byte_Order._default.ltedef ($LS MoreFuel_Byte_Order._default.ltedef1)) (= StartFuelAssert_Byte_Order._default.ltedef ($LS ($LS MoreFuel_Byte_Order._default.ltedef1)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.ltedef1) MoreFuel_Byte_Order._default.ltedef1)) (= (Byte__Order.__default.lte ($LS $ly@@352) (LitInt |a#0@@108|) (LitInt |b#0@@66|)) (INTERNAL_le_boogie |a#0@@108| |b#0@@66|))))
 :qid |totalorderidfy.1087:30|
 :weight 3
 :skolemid |5667|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@352) (LitInt |a#0@@108|) (LitInt |b#0@@66|)))
))))
(assert (forall (($ly@@353 T@U) (|a#0@@109| Int) (|b#0@@67| Int) ) (!  (=> (= (type $ly@@353) LayerTypeType) (= (Byte__Order.__default.ltedef ($LS $ly@@353) |a#0@@109| |b#0@@67|) (Byte__Order.__default.ltedef $ly@@353 |a#0@@109| |b#0@@67|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |5668|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@353) |a#0@@109| |b#0@@67|))
)))
(assert (forall (($ly@@354 T@U) (|a#0@@110| Int) (|b#0@@68| Int) ) (!  (=> (= (type $ly@@354) LayerTypeType) (= (Byte__Order.__default.ltedef $ly@@354 |a#0@@110| |b#0@@68|) (Byte__Order.__default.ltedef $LZ |a#0@@110| |b#0@@68|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |5669|
 :pattern ( (Byte__Order.__default.ltedef (AsFuelBottom $ly@@354) |a#0@@110| |b#0@@68|))
)))
(assert  (=> true (forall (($ly@@355 T@U) (|a#0@@111| Int) (|b#0@@69| Int) ) (!  (=> (and (= (type $ly@@355) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| |a#0@@111| |b#0@@69|) (and (and (INTERNAL_le_boogie 0 |a#0@@111|) (INTERNAL_lt_boogie |a#0@@111| 256)) (and (INTERNAL_le_boogie 0 |b#0@@69|) (INTERNAL_lt_boogie |b#0@@69| 256))))) true)
 :qid |totalorderidfy.1092:30|
 :skolemid |5670|
 :pattern ( (Byte__Order.__default.ltedef $ly@@355 |a#0@@111| |b#0@@69|))
))))
(assert (forall (($ly@@356 T@U) (|a#0@@112| Int) (|b#0@@70| Int) ) (!  (=> (= (type $ly@@356) LayerTypeType) (=> (and (and (INTERNAL_le_boogie 0 |a#0@@112|) (INTERNAL_lt_boogie |a#0@@112| 256)) (and (INTERNAL_le_boogie 0 |b#0@@70|) (INTERNAL_lt_boogie |b#0@@70| 256))) (= (|Byte__Order.__default.ltedef#requires| $ly@@356 |a#0@@112| |b#0@@70|) true)))
 :qid |totalorderidfy.1092:30|
 :skolemid |5671|
 :pattern ( (|Byte__Order.__default.ltedef#requires| $ly@@356 |a#0@@112| |b#0@@70|))
)))
(assert  (=> true (forall (($ly@@357 T@U) (|a#0@@113| Int) (|b#0@@71| Int) ) (!  (=> (and (= (type $ly@@357) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| |a#0@@113| |b#0@@71|) (and (and (INTERNAL_le_boogie 0 |a#0@@113|) (INTERNAL_lt_boogie |a#0@@113| 256)) (and (INTERNAL_le_boogie 0 |b#0@@71|) (INTERNAL_lt_boogie |b#0@@71| 256))))) (= (Byte__Order.__default.ltedef ($LS $ly@@357) |a#0@@113| |b#0@@71|) (INTERNAL_le_boogie |a#0@@113| |b#0@@71|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |5672|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@357) |a#0@@113| |b#0@@71|))
))))
(assert  (=> true (forall (($ly@@358 T@U) (|a#0@@114| Int) (|b#0@@72| Int) ) (!  (=> (and (= (type $ly@@358) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| (LitInt |a#0@@114|) (LitInt |b#0@@72|)) (and (and (INTERNAL_le_boogie 0 |a#0@@114|) (INTERNAL_lt_boogie |a#0@@114| 256)) (and (INTERNAL_le_boogie 0 |b#0@@72|) (INTERNAL_lt_boogie |b#0@@72| 256))))) (= (Byte__Order.__default.ltedef ($LS $ly@@358) (LitInt |a#0@@114|) (LitInt |b#0@@72|)) (INTERNAL_le_boogie |a#0@@114| |b#0@@72|)))
 :qid |totalorderidfy.1092:30|
 :weight 3
 :skolemid |5673|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@358) (LitInt |a#0@@114|) (LitInt |b#0@@72|)))
))))
(assert (forall (($ly@@359 T@U) (|run#0@@85| T@U) (|needle#0@@13| Int) ) (!  (=> (and (= (type $ly@@359) LayerTypeType) (= (type |run#0@@85|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@359) |run#0@@85| |needle#0@@13|) (Byte__Order.__default.LargestLteDefn $ly@@359 |run#0@@85| |needle#0@@13|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |5674|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@359) |run#0@@85| |needle#0@@13|))
)))
(assert (forall (($ly@@360 T@U) (|run#0@@86| T@U) (|needle#0@@14| Int) ) (!  (=> (and (= (type $ly@@360) LayerTypeType) (= (type |run#0@@86|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLteDefn $ly@@360 |run#0@@86| |needle#0@@14|) (Byte__Order.__default.LargestLteDefn $LZ |run#0@@86| |needle#0@@14|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |5675|
 :pattern ( (Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@360) |run#0@@86| |needle#0@@14|))
)))
(assert (= (type StartFuel_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@361 T@U) (|run#0@@87| T@U) (|needle#0@@15| Int) ) (!  (=> (and (and (= (type $ly@@361) LayerTypeType) (= (type |run#0@@87|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@87| |needle#0@@15|) (and (and ($Is |run#0@@87| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@15|) (INTERNAL_lt_boogie |needle#0@@15| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@87|)))) true)
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |5676|
 :pattern ( (Byte__Order.__default.LargestLteDefn $ly@@361 |run#0@@87| |needle#0@@15|))
))))
(assert (forall (($ly@@362 T@U) (|run#0@@88| T@U) (|needle#0@@16| Int) ) (!  (=> (and (and (= (type $ly@@362) LayerTypeType) (= (type |run#0@@88|) (SeqType BoxType))) (and ($Is |run#0@@88| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@16|) (INTERNAL_lt_boogie |needle#0@@16| 256)))) (= (|Byte__Order.__default.LargestLteDefn#requires| $ly@@362 |run#0@@88| |needle#0@@16|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@88|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |5677|
 :pattern ( (|Byte__Order.__default.LargestLteDefn#requires| $ly@@362 |run#0@@88| |needle#0@@16|))
)))
(assert  (=> true (forall (($ly@@363 T@U) (|run#0@@89| T@U) (|needle#0@@17| Int) ) (!  (=> (and (and (= (type $ly@@363) LayerTypeType) (= (type |run#0@@89|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@89| |needle#0@@17|) (and (and ($Is |run#0@@89| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@17|) (INTERNAL_lt_boogie |needle#0@@17| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@89|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@89|) (LitInt 0))) (|Byte__Order.__default.lt#canCall| |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0)))))) (=> (not (or (= (|Seq#Length| |run#0@@89|) (LitInt 0)) (Byte__Order.__default.lt |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0))))))) (|Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@89| (LitInt 1)) |needle#0@@17|))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@363) |run#0@@89| |needle#0@@17|) (ite  (or (= (|Seq#Length| |run#0@@89|) (LitInt 0)) (Byte__Order.__default.lt |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLteDefn $ly@@363 (|Seq#Drop| |run#0@@89| (LitInt 1)) |needle#0@@17|))))))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |5678|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@363) |run#0@@89| |needle#0@@17|))
))))
(assert  (=> true (forall (($ly@@364 T@U) (|run#0@@90| T@U) (|needle#0@@18| Int) ) (!  (=> (and (and (= (type $ly@@364) LayerTypeType) (= (type |run#0@@90|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@90|) (LitInt |needle#0@@18|)) (and (and ($Is |run#0@@90| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@18|) (INTERNAL_lt_boogie |needle#0@@18| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@90|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0))) (|Byte__Order.__default.lt#canCall| (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0)))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0)) (Byte__Order.__default.lt (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0))))))) (|Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@90|) (LitInt 1))) (LitInt |needle#0@@18|)))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@364) (Lit |run#0@@90|) (LitInt |needle#0@@18|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0)) (Byte__Order.__default.lt (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLteDefn ($LS $ly@@364) (Lit (|Seq#Drop| (Lit |run#0@@90|) (LitInt 1))) (LitInt |needle#0@@18|)))))))
 :qid |totalorderidfyByteOrder.333:12|
 :weight 3
 :skolemid |5679|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@364) (Lit |run#0@@90|) (LitInt |needle#0@@18|)))
))))
(assert (= (type StartFuel_Byte_Order._default.lte) LayerTypeType))
(assert  (=> true (forall ((|run#0@@91| T@U) (|needle#0@@19| Int) ) (!  (=> (and (= (type |run#0@@91|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| |run#0@@91| |needle#0@@19|) (and (and ($Is |run#0@@91| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@19|) (INTERNAL_lt_boogie |needle#0@@19| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@91|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)) (INTERNAL_lt_boogie (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|) (|Seq#Length| |run#0@@91|))) (forall ((|i#0@@105| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@105|) (INTERNAL_le_boogie |i#0@@105| (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| |i#0@@105|))) |needle#0@@19|)))
 :qid |totalorderidfyByteOrder.362:20|
 :skolemid |5680|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@91| |i#0@@105|)))
))) (forall ((|i#1@@20| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|) |i#1@@20|) (INTERNAL_lt_boogie |i#1@@20| (|Seq#Length| |run#0@@91|))) (Byte__Order.__default.lt |needle#0@@19| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| |i#1@@20|))))))
 :qid |totalorderidfyByteOrder.363:20|
 :skolemid |5681|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@91| |i#1@@20|)))
))) (=> (|Seq#Contains| |run#0@@91| ($Box (int_2_U |needle#0@@19|))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)) (= (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)))) |needle#0@@19|)))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |5682|
 :pattern ( (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|))
))))
(assert (forall ((|run#0@@92| T@U) (|needle#0@@20| Int) ) (!  (=> (= (type |run#0@@92|) (SeqType BoxType)) (=> (and ($Is |run#0@@92| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@20|) (INTERNAL_lt_boogie |needle#0@@20| 256))) (= (|Byte__Order.__default.LargestLte#requires| |run#0@@92| |needle#0@@20|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@92|))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |5683|
 :pattern ( (|Byte__Order.__default.LargestLte#requires| |run#0@@92| |needle#0@@20|))
)))
(assert  (=> true (forall ((|run#0@@93| T@U) (|needle#0@@21| Int) ) (!  (=> (and (= (type |run#0@@93|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| |run#0@@93| |needle#0@@21|) (and (and ($Is |run#0@@93| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@21|) (INTERNAL_lt_boogie |needle#0@@21| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@93|)))) (and (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@93| |needle#0@@21|) (= (Byte__Order.__default.LargestLte |run#0@@93| |needle#0@@21|) (let ((|out#0@@1| (Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@93| |needle#0@@21|)))
|out#0@@1|))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |5684|
 :pattern ( (Byte__Order.__default.LargestLte |run#0@@93| |needle#0@@21|))
))))
(assert  (=> true (forall ((|run#0@@94| T@U) (|needle#0@@22| Int) ) (!  (=> (and (= (type |run#0@@94|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (and (and ($Is |run#0@@94| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@22|) (INTERNAL_lt_boogie |needle#0@@22| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@94|))))) (and (|Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (= (Byte__Order.__default.LargestLte (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (let ((|out#1| (LitInt (Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@94|) (LitInt |needle#0@@22|)))))
|out#1|))))
 :qid |totalorderidfyByteOrder.359:23|
 :weight 3
 :skolemid |5685|
 :pattern ( (Byte__Order.__default.LargestLte (Lit |run#0@@94|) (LitInt |needle#0@@22|)))
))))
(assert (forall (($ly@@365 T@U) (|run#0@@95| T@U) (|needle#0@@23| Int) ) (!  (=> (and (= (type $ly@@365) LayerTypeType) (= (type |run#0@@95|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLt ($LS $ly@@365) |run#0@@95| |needle#0@@23|) (Byte__Order.__default.LargestLt $ly@@365 |run#0@@95| |needle#0@@23|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |5686|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@365) |run#0@@95| |needle#0@@23|))
)))
(assert (forall (($ly@@366 T@U) (|run#0@@96| T@U) (|needle#0@@24| Int) ) (!  (=> (and (= (type $ly@@366) LayerTypeType) (= (type |run#0@@96|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLt $ly@@366 |run#0@@96| |needle#0@@24|) (Byte__Order.__default.LargestLt $LZ |run#0@@96| |needle#0@@24|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |5687|
 :pattern ( (Byte__Order.__default.LargestLt (AsFuelBottom $ly@@366) |run#0@@96| |needle#0@@24|))
)))
(assert  (=> true (forall (($ly@@367 T@U) (|run#0@@97| T@U) (|needle#0@@25| Int) ) (!  (=> (and (and (= (type $ly@@367) LayerTypeType) (= (type |run#0@@97|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| |run#0@@97| |needle#0@@25|) (and (and ($Is |run#0@@97| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@25|) (INTERNAL_lt_boogie |needle#0@@25| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@97|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|)) (INTERNAL_lt_boogie (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|) (|Seq#Length| |run#0@@97|))) (forall ((|i#0@@106| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@106|) (INTERNAL_le_boogie |i#0@@106| (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| |i#0@@106|))) |needle#0@@25|)))
 :qid |totalorderidfyByteOrder.461:20|
 :skolemid |5688|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@97| |i#0@@106|)))
))) (forall ((|i#1@@21| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|) |i#1@@21|) (INTERNAL_lt_boogie |i#1@@21| (|Seq#Length| |run#0@@97|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@25| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| |i#1@@21|))))))
 :qid |totalorderidfyByteOrder.462:20|
 :skolemid |5689|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@97| |i#1@@21|)))
))) (=> (|Seq#Contains| |run#0@@97| ($Box (int_2_U |needle#0@@25|))) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|) 1) (|Seq#Length| |run#0@@97|)) (= (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| (INTERNAL_add_boogie (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|) 1)))) |needle#0@@25|)))))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |5690|
 :pattern ( (Byte__Order.__default.LargestLt $ly@@367 |run#0@@97| |needle#0@@25|))
))))
(assert (forall (($ly@@368 T@U) (|run#0@@98| T@U) (|needle#0@@26| Int) ) (!  (=> (and (and (= (type $ly@@368) LayerTypeType) (= (type |run#0@@98|) (SeqType BoxType))) (and ($Is |run#0@@98| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@26|) (INTERNAL_lt_boogie |needle#0@@26| 256)))) (= (|Byte__Order.__default.LargestLt#requires| $ly@@368 |run#0@@98| |needle#0@@26|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@98|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |5691|
 :pattern ( (|Byte__Order.__default.LargestLt#requires| $ly@@368 |run#0@@98| |needle#0@@26|))
)))
(assert  (and (= (type MoreFuel_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@369 T@U) (|run#0@@99| T@U) (|needle#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@369) LayerTypeType) (= (type |run#0@@99|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| |run#0@@99| |needle#0@@27|) (and (and ($Is |run#0@@99| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@27|) (INTERNAL_lt_boogie |needle#0@@27| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@99|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@99|) (LitInt 0))) (|Byte__Order.__default.lte#canCall| |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0)))))) (=> (not (or (= (|Seq#Length| |run#0@@99|) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0))))))) (|Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@99| (LitInt 1)) |needle#0@@27|))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted0) MoreFuel_Byte_Order._default.IsSorted0)) (= (Byte__Order.__default.LargestLt ($LS $ly@@369) |run#0@@99| |needle#0@@27|) (ite  (or (= (|Seq#Length| |run#0@@99|) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLt $ly@@369 (|Seq#Drop| |run#0@@99| (LitInt 1)) |needle#0@@27|)))))))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |5692|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@369) |run#0@@99| |needle#0@@27|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@370 T@U) (|run#0@@100| T@U) (|needle#0@@28| Int) ) (!  (=> (and (and (= (type $ly@@370) LayerTypeType) (= (type |run#0@@100|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@100|) (LitInt |needle#0@@28|)) (and (and ($Is |run#0@@100| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@28|) (INTERNAL_lt_boogie |needle#0@@28| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@100|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0))) (|Byte__Order.__default.lte#canCall| (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0)))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0))))))) (|Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@100|) (LitInt 1))) (LitInt |needle#0@@28|)))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted1) MoreFuel_Byte_Order._default.IsSorted1)) (= (Byte__Order.__default.LargestLt ($LS $ly@@370) (Lit |run#0@@100|) (LitInt |needle#0@@28|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLt ($LS $ly@@370) (Lit (|Seq#Drop| (Lit |run#0@@100|) (LitInt 1))) (LitInt |needle#0@@28|))))))))
 :qid |totalorderidfyByteOrder.458:12|
 :weight 3
 :skolemid |5693|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@370) (Lit |run#0@@100|) (LitInt |needle#0@@28|)))
))))
(assert (forall (($ly@@371 T@U) (|run#0@@101| T@U) (|needle#0@@29| Int) ) (!  (=> (and (= (type $ly@@371) LayerTypeType) (= (type |run#0@@101|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@371) |run#0@@101| |needle#0@@29|) (Byte__Order.__default.IndexOfFirstGte $ly@@371 |run#0@@101| |needle#0@@29|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |5694|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@371) |run#0@@101| |needle#0@@29|))
)))
(assert (forall (($ly@@372 T@U) (|run#0@@102| T@U) (|needle#0@@30| Int) ) (!  (=> (and (= (type $ly@@372) LayerTypeType) (= (type |run#0@@102|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGte $ly@@372 |run#0@@102| |needle#0@@30|) (Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@102| |needle#0@@30|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |5695|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@372) |run#0@@102| |needle#0@@30|))
)))
(assert  (=> true (forall (($ly@@373 T@U) (|run#0@@103| T@U) (|needle#0@@31| Int) ) (!  (=> (and (and (= (type $ly@@373) LayerTypeType) (= (type |run#0@@103|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@103| |needle#0@@31|) (and (and ($Is |run#0@@103| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@31|) (INTERNAL_lt_boogie |needle#0@@31| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@103|)))) (and (and (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGte $ly@@373 |run#0@@103| |needle#0@@31|) (|Seq#Length| |run#0@@103|)) (forall ((|i#0@@107| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@107|) (INTERNAL_lt_boogie |i#0@@107| (Byte__Order.__default.IndexOfFirstGte $ly@@373 |run#0@@103| |needle#0@@31|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@103| |i#0@@107|))) |needle#0@@31|))
 :qid |totalorderidfyByteOrder.495:20|
 :skolemid |5696|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@103| |i#0@@107|)))
))) (forall ((|i#1@@22| Int) ) (!  (=> (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGte $ly@@373 |run#0@@103| |needle#0@@31|) |i#1@@22|) (INTERNAL_lt_boogie |i#1@@22| (|Seq#Length| |run#0@@103|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@31| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@103| |i#1@@22|)))))
 :qid |totalorderidfyByteOrder.496:20|
 :skolemid |5697|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@103| |i#1@@22|)))
))) (INTERNAL_le_boogie 0 (Byte__Order.__default.IndexOfFirstGte $ly@@373 |run#0@@103| |needle#0@@31|))))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |5698|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte $ly@@373 |run#0@@103| |needle#0@@31|))
))))
(assert (forall (($ly@@374 T@U) (|run#0@@104| T@U) (|needle#0@@32| Int) ) (!  (=> (and (and (= (type $ly@@374) LayerTypeType) (= (type |run#0@@104|) (SeqType BoxType))) (and ($Is |run#0@@104| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@32|) (INTERNAL_lt_boogie |needle#0@@32| 256)))) (= (|Byte__Order.__default.IndexOfFirstGte#requires| $ly@@374 |run#0@@104| |needle#0@@32|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@104|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |5699|
 :pattern ( (|Byte__Order.__default.IndexOfFirstGte#requires| $ly@@374 |run#0@@104| |needle#0@@32|))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@375 T@U) (|run#0@@105| T@U) (|needle#0@@33| Int) ) (!  (=> (and (and (= (type $ly@@375) LayerTypeType) (= (type |run#0@@105|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@105| |needle#0@@33|) (and (and ($Is |run#0@@105| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@33|) (INTERNAL_lt_boogie |needle#0@@33| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@105|)))) (and (=> (not (= (|Seq#Length| |run#0@@105|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte |run#0@@105|) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|)) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|)) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte |run#0@@105|) (|Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@105|) |needle#0@@33|))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted2) MoreFuel_Byte_Order._default.IsSorted2)) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@375) |run#0@@105| |needle#0@@33|) (ite (= (|Seq#Length| |run#0@@105|) (LitInt 0)) 0 (ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|) (|Seq#Length| |run#0@@105|) (Byte__Order.__default.IndexOfFirstGte $ly@@375 (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@105|) |needle#0@@33|)))))))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |5700|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@375) |run#0@@105| |needle#0@@33|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@376 T@U) (|run#0@@106| T@U) (|needle#0@@34| Int) ) (!  (=> (and (and (= (type $ly@@376) LayerTypeType) (= (type |run#0@@106|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@106|) (LitInt |needle#0@@34|)) (and (and ($Is |run#0@@106| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@34|) (INTERNAL_lt_boogie |needle#0@@34| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@106|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@106|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte (Lit |run#0@@106|)) (|Byte__Order.__default.lt#canCall| (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|))) (=> (not (U_2_bool (Lit (bool_2_U (Byte__Order.__default.lt (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte (Lit |run#0@@106|)) (|Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@106|))) (LitInt |needle#0@@34|)))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted3) MoreFuel_Byte_Order._default.IsSorted3)) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@376) (Lit |run#0@@106|) (LitInt |needle#0@@34|)) (ite (= (|Seq#Length| (Lit |run#0@@106|)) (LitInt 0)) 0 (ite (Byte__Order.__default.lt (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|)) (|Seq#Length| (Lit |run#0@@106|)) (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@376) (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@106|))) (LitInt |needle#0@@34|))))))))
 :qid |totalorderidfyByteOrder.492:12|
 :weight 3
 :skolemid |5701|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@376) (Lit |run#0@@106|) (LitInt |needle#0@@34|)))
))))
(assert (forall (($ly@@377 T@U) (|s#0@@113| T@U) (|key#0@@46| Int) (|lo#0| Int) (|hi#0| Int) ) (!  (=> (and (= (type $ly@@377) LayerTypeType) (= (type |s#0@@113|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@377) |s#0@@113| |key#0@@46| |lo#0| |hi#0|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@377 |s#0@@113| |key#0@@46| |lo#0| |hi#0|)))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |5702|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@377) |s#0@@113| |key#0@@46| |lo#0| |hi#0|))
)))
(assert (forall (($ly@@378 T@U) (|s#0@@114| T@U) (|key#0@@47| Int) (|lo#0@@0| Int) (|hi#0@@0| Int) ) (!  (=> (and (= (type $ly@@378) LayerTypeType) (= (type |s#0@@114|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@378 |s#0@@114| |key#0@@47| |lo#0@@0| |hi#0@@0|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@114| |key#0@@47| |lo#0@@0| |hi#0@@0|)))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |5703|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@378) |s#0@@114| |key#0@@47| |lo#0@@0| |hi#0@@0|))
)))
(assert  (=> true (forall (($ly@@379 T@U) (|s#0@@115| T@U) (|key#0@@48| Int) (|lo#0@@1| Int) (|hi#0@@1| Int) ) (!  (=> (and (and (= (type $ly@@379) LayerTypeType) (= (type |s#0@@115|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) (and (and ($Is |s#0@@115| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@48|) (INTERNAL_lt_boogie |key#0@@48| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@1|) (INTERNAL_lt_boogie |lo#0@@1| |hi#0@@1|)) (INTERNAL_le_boogie |hi#0@@1| (INTERNAL_add_boogie (|Seq#Length| |s#0@@115|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@1| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie |lo#0@@1| 1)))) |key#0@@48|))) (=> (INTERNAL_le_boogie |hi#0@@1| (|Seq#Length| |s#0@@115|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@48| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie |hi#0@@1| 1)))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) (|Seq#Length| |s#0@@115|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) 1)))) |key#0@@48|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) (|Seq#Length| |s#0@@115|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@48| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|))))))) (and (INTERNAL_le_boogie |lo#0@@1| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|)) (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|) |hi#0@@1|))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |5704|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@379 |s#0@@115| |key#0@@48| |lo#0@@1| |hi#0@@1|))
))))
(assert (forall (($ly@@380 T@U) (|s#0@@116| T@U) (|key#0@@49| Int) (|lo#0@@2| Int) (|hi#0@@2| Int) ) (!  (=> (and (and (= (type $ly@@380) LayerTypeType) (= (type |s#0@@116|) (SeqType BoxType))) (and ($Is |s#0@@116| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@49|) (INTERNAL_lt_boogie |key#0@@49| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@380 |s#0@@116| |key#0@@49| |lo#0@@2| |hi#0@@2|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@2|) (INTERNAL_lt_boogie |lo#0@@2| |hi#0@@2|)) (INTERNAL_le_boogie |hi#0@@2| (INTERNAL_add_boogie (|Seq#Length| |s#0@@116|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@2| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@116| (INTERNAL_sub_boogie |lo#0@@2| 1)))) |key#0@@49|))) (=> (INTERNAL_le_boogie |hi#0@@2| (|Seq#Length| |s#0@@116|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@49| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@116| (INTERNAL_sub_boogie |hi#0@@2| 1)))))))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |5705|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@380 |s#0@@116| |key#0@@49| |lo#0@@2| |hi#0@@2|))
)))
(assert  (=> true (forall (($ly@@381 T@U) (|s#0@@117| T@U) (|key#0@@50| Int) (|lo#0@@3| Int) (|hi#0@@3| Int) ) (!  (=> (and (and (= (type $ly@@381) LayerTypeType) (= (type |s#0@@117|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@50| |lo#0@@3| |hi#0@@3|) (and (and ($Is |s#0@@117| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@50|) (INTERNAL_lt_boogie |key#0@@50| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@3|) (INTERNAL_lt_boogie |lo#0@@3| |hi#0@@3|)) (INTERNAL_le_boogie |hi#0@@3| (INTERNAL_add_boogie (|Seq#Length| |s#0@@117|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@3| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |lo#0@@3| 1)))) |key#0@@50|))) (=> (INTERNAL_le_boogie |hi#0@@3| (|Seq#Length| |s#0@@117|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@50| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |hi#0@@3| 1)))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@3| 1) |hi#0@@3|) (let ((|mid#0| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@3| |hi#0@@3|) 2)))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@50|) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@50|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@50| |mid#0| |hi#0@@3|))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@50|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@50| |lo#0@@3| |mid#0|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@381) |s#0@@117| |key#0@@50| |lo#0@@3| |hi#0@@3|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@3| 1) |hi#0@@3|) (let ((|mid#0@@0| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@3| |hi#0@@3|) 2)))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0@@0| 1)))) |key#0@@50|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@381 |s#0@@117| |key#0@@50| |mid#0@@0| |hi#0@@3|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@381 |s#0@@117| |key#0@@50| |lo#0@@3| |mid#0@@0|))) |lo#0@@3|))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |5706|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@381) |s#0@@117| |key#0@@50| |lo#0@@3| |hi#0@@3|))
))))
(assert  (=> true (forall (($ly@@382 T@U) (|s#0@@118| T@U) (|key#0@@51| Int) (|lo#0@@4| Int) (|hi#0@@4| Int) ) (!  (=> (and (and (= (type $ly@@382) LayerTypeType) (= (type |s#0@@118|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@51| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)) (and (and ($Is |s#0@@118| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@51|) (INTERNAL_lt_boogie |key#0@@51| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@4|) (INTERNAL_lt_boogie |lo#0@@4| |hi#0@@4|)) (INTERNAL_le_boogie |hi#0@@4| (INTERNAL_add_boogie (|Seq#Length| |s#0@@118|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@4| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |lo#0@@4| 1))))) |key#0@@51|))) (=> (INTERNAL_le_boogie |hi#0@@4| (|Seq#Length| |s#0@@118|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@51| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |hi#0@@4| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@4| 1) |hi#0@@4|)))) (let ((|mid#1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@4| |hi#0@@4|) 2))))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@51|) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@51|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@51| |mid#1| (LitInt |hi#0@@4|)))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@51|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@51| (LitInt |lo#0@@4|) |mid#1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@382) |s#0@@118| |key#0@@51| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@4| 1) |hi#0@@4|) (let ((|mid#1@@0| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@4| |hi#0@@4|) 2))))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |mid#1@@0| 1))))) |key#0@@51|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@382) |s#0@@118| |key#0@@51| |mid#1@@0| (LitInt |hi#0@@4|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@382) |s#0@@118| |key#0@@51| (LitInt |lo#0@@4|) |mid#1@@0|))) |lo#0@@4|))))
 :qid |totalorderidfyByteOrder.524:12|
 :weight 3
 :skolemid |5707|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@382) |s#0@@118| |key#0@@51| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)))
))))
(assert  (=> true (forall (($ly@@383 T@U) (|s#0@@119| T@U) (|key#0@@52| Int) (|lo#0@@5| Int) (|hi#0@@5| Int) ) (!  (=> (and (and (= (type $ly@@383) LayerTypeType) (= (type |s#0@@119|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@52|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)) (and (and ($Is |s#0@@119| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@52|) (INTERNAL_lt_boogie |key#0@@52| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@5|) (INTERNAL_lt_boogie |lo#0@@5| |hi#0@@5|)) (INTERNAL_le_boogie |hi#0@@5| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@119|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@5| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |lo#0@@5| 1))))) (LitInt |key#0@@52|)))) (=> (INTERNAL_le_boogie |hi#0@@5| (|Seq#Length| (Lit |s#0@@119|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |key#0@@52|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |hi#0@@5| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@5| 1) |hi#0@@5|)))) (let ((|mid#2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@5| |hi#0@@5|) 2))))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@52|)) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@52|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@52|) |mid#2| (LitInt |hi#0@@5|)))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@52|))) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@52|) (LitInt |lo#0@@5|) |mid#2|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@383) (Lit |s#0@@119|) (LitInt |key#0@@52|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@5| 1) |hi#0@@5|) (let ((|mid#2@@0| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@5| |hi#0@@5|) 2))))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |mid#2@@0| 1))))) (LitInt |key#0@@52|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@383) (Lit |s#0@@119|) (LitInt |key#0@@52|) |mid#2@@0| (LitInt |hi#0@@5|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@383) (Lit |s#0@@119|) (LitInt |key#0@@52|) (LitInt |lo#0@@5|) |mid#2@@0|))) |lo#0@@5|))))
 :qid |totalorderidfyByteOrder.524:12|
 :weight 3
 :skolemid |5708|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@383) (Lit |s#0@@119|) (LitInt |key#0@@52|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)))
))))
(assert (forall (($ly@@384 T@U) (|s#0@@120| T@U) (|key#0@@53| Int) ) (!  (=> (and (= (type $ly@@384) LayerTypeType) (= (type |s#0@@120|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@384) |s#0@@120| |key#0@@53|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@384 |s#0@@120| |key#0@@53|)))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |5709|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@384) |s#0@@120| |key#0@@53|))
)))
(assert (forall (($ly@@385 T@U) (|s#0@@121| T@U) (|key#0@@54| Int) ) (!  (=> (and (= (type $ly@@385) LayerTypeType) (= (type |s#0@@121|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@385 |s#0@@121| |key#0@@54|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@121| |key#0@@54|)))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |5710|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@385) |s#0@@121| |key#0@@54|))
)))
(assert  (=> true (forall (($ly@@386 T@U) (|s#0@@122| T@U) (|key#0@@55| Int) ) (!  (=> (and (and (= (type $ly@@386) LayerTypeType) (= (type |s#0@@122|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@122| |key#0@@55|) (and ($Is |s#0@@122| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@55|) (INTERNAL_lt_boogie |key#0@@55| 256))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|) (|Seq#Length| |s#0@@122|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@122| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|) 1)))) |key#0@@55|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|) (|Seq#Length| |s#0@@122|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@55| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@122| (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|))))))))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |5711|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@386 |s#0@@122| |key#0@@55|))
))))
(assert (forall (($ly@@387 T@U) (|s#0@@123| T@U) (|key#0@@56| Int) ) (!  (=> (and (and (= (type $ly@@387) LayerTypeType) (= (type |s#0@@123|) (SeqType BoxType))) (and ($Is |s#0@@123| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@56|) (INTERNAL_lt_boogie |key#0@@56| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@387 |s#0@@123| |key#0@@56|) true))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |5712|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@387 |s#0@@123| |key#0@@56|))
)))
(assert  (=> true (forall (($ly@@388 T@U) (|s#0@@124| T@U) (|key#0@@57| Int) ) (!  (=> (and (and (= (type $ly@@388) LayerTypeType) (= (type |s#0@@124|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@124| |key#0@@57|) (and ($Is |s#0@@124| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@57|) (INTERNAL_lt_boogie |key#0@@57| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@124| |key#0@@57| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@124|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@388) |s#0@@124| |key#0@@57|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@124| |key#0@@57| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@124|) 1)))))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |5713|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@388) |s#0@@124| |key#0@@57|))
))))
(assert  (=> true (forall (($ly@@389 T@U) (|s#0@@125| T@U) (|key#0@@58| Int) ) (!  (=> (and (and (= (type $ly@@389) LayerTypeType) (= (type |s#0@@125|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@125|) (LitInt |key#0@@58|)) (and ($Is |s#0@@125| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@58|) (INTERNAL_lt_boogie |key#0@@58| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@125|) (LitInt |key#0@@58|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@125|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@389) (Lit |s#0@@125|) (LitInt |key#0@@58|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@125|) (LitInt |key#0@@58|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@125|)) 1)))))
 :qid |totalorderidfyByteOrder.574:22|
 :weight 3
 :skolemid |5714|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@389) (Lit |s#0@@125|) (LitInt |key#0@@58|)))
))))
(assert (forall (($ly@@390 T@U) (|s#0@@126| T@U) (|key#0@@59| Int) (|lo#0@@6| Int) ) (!  (=> (and (= (type $ly@@390) LayerTypeType) (= (type |s#0@@126|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@390) |s#0@@126| |key#0@@59| |lo#0@@6|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@390 |s#0@@126| |key#0@@59| |lo#0@@6|)))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |5715|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@390) |s#0@@126| |key#0@@59| |lo#0@@6|))
)))
(assert (forall (($ly@@391 T@U) (|s#0@@127| T@U) (|key#0@@60| Int) (|lo#0@@7| Int) ) (!  (=> (and (= (type $ly@@391) LayerTypeType) (= (type |s#0@@127|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@391 |s#0@@127| |key#0@@60| |lo#0@@7|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@127| |key#0@@60| |lo#0@@7|)))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |5716|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@391) |s#0@@127| |key#0@@60| |lo#0@@7|))
)))
(assert  (=> true (forall (($ly@@392 T@U) (|s#0@@128| T@U) (|key#0@@61| Int) (|lo#0@@8| Int) ) (!  (=> (and (and (= (type $ly@@392) LayerTypeType) (= (type |s#0@@128|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@128| |key#0@@61| |lo#0@@8|) (and (and ($Is |s#0@@128| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@61|) (INTERNAL_lt_boogie |key#0@@61| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@8|) (INTERNAL_le_boogie |lo#0@@8| (|Seq#Length| |s#0@@128|))) (=> (INTERNAL_gt_boogie |lo#0@@8| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (INTERNAL_sub_boogie |lo#0@@8| 1)))) |key#0@@61|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@8| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|) (|Seq#Length| |s#0@@128|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|) 1)))) |key#0@@61|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|) (|Seq#Length| |s#0@@128|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@61| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|))))))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |5717|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@392 |s#0@@128| |key#0@@61| |lo#0@@8|))
))))
(assert (forall (($ly@@393 T@U) (|s#0@@129| T@U) (|key#0@@62| Int) (|lo#0@@9| Int) ) (!  (=> (and (and (= (type $ly@@393) LayerTypeType) (= (type |s#0@@129|) (SeqType BoxType))) (and ($Is |s#0@@129| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@62|) (INTERNAL_lt_boogie |key#0@@62| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@393 |s#0@@129| |key#0@@62| |lo#0@@9|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@9|) (INTERNAL_le_boogie |lo#0@@9| (|Seq#Length| |s#0@@129|))) (=> (INTERNAL_gt_boogie |lo#0@@9| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@129| (INTERNAL_sub_boogie |lo#0@@9| 1)))) |key#0@@62|)))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |5718|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@393 |s#0@@129| |key#0@@62| |lo#0@@9|))
)))
(assert  (=> true (forall (($ly@@394 T@U) (|s#0@@130| T@U) (|key#0@@63| Int) (|lo#0@@10| Int) ) (!  (=> (and (and (= (type $ly@@394) LayerTypeType) (= (type |s#0@@130|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@130| |key#0@@63| |lo#0@@10|) (and (and ($Is |s#0@@130| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@63|) (INTERNAL_lt_boogie |key#0@@63| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@10|) (INTERNAL_le_boogie |lo#0@@10| (|Seq#Length| |s#0@@130|))) (=> (INTERNAL_gt_boogie |lo#0@@10| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@130| (INTERNAL_sub_boogie |lo#0@@10| 1)))) |key#0@@63|)))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@130| |key#0@@63| |lo#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@130|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@394) |s#0@@130| |key#0@@63| |lo#0@@10|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@130| |key#0@@63| |lo#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@130|) 1)))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |5719|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@394) |s#0@@130| |key#0@@63| |lo#0@@10|))
))))
(assert  (=> true (forall (($ly@@395 T@U) (|s#0@@131| T@U) (|key#0@@64| Int) (|lo#0@@11| Int) ) (!  (=> (and (and (= (type $ly@@395) LayerTypeType) (= (type |s#0@@131|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@131|) (LitInt |key#0@@64|) (LitInt |lo#0@@11|)) (and (and ($Is |s#0@@131| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@64|) (INTERNAL_lt_boogie |key#0@@64| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@11|) (INTERNAL_le_boogie |lo#0@@11| (|Seq#Length| (Lit |s#0@@131|)))) (=> (INTERNAL_gt_boogie |lo#0@@11| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@131|) (LitInt (INTERNAL_sub_boogie |lo#0@@11| 1))))) (LitInt |key#0@@64|))))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@131|) (LitInt |key#0@@64|) (LitInt |lo#0@@11|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@131|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@395) (Lit |s#0@@131|) (LitInt |key#0@@64|) (LitInt |lo#0@@11|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@131|) (LitInt |key#0@@64|) (LitInt |lo#0@@11|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@131|)) 1)))))
 :qid |totalorderidfyByteOrder.582:22|
 :weight 3
 :skolemid |5720|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@395) (Lit |s#0@@131|) (LitInt |key#0@@64|) (LitInt |lo#0@@11|)))
))))
(assert (forall (($ly@@396 T@U) (|run#0@@107| T@U) (|needle#0@@35| Int) ) (!  (=> (and (= (type $ly@@396) LayerTypeType) (= (type |run#0@@107|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@396) |run#0@@107| |needle#0@@35|) (Byte__Order.__default.IndexOfFirstGt $ly@@396 |run#0@@107| |needle#0@@35|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |5721|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@396) |run#0@@107| |needle#0@@35|))
)))
(assert (forall (($ly@@397 T@U) (|run#0@@108| T@U) (|needle#0@@36| Int) ) (!  (=> (and (= (type $ly@@397) LayerTypeType) (= (type |run#0@@108|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGt $ly@@397 |run#0@@108| |needle#0@@36|) (Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@108| |needle#0@@36|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |5722|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@397) |run#0@@108| |needle#0@@36|))
)))
(assert  (=> true (forall (($ly@@398 T@U) (|run#0@@109| T@U) (|needle#0@@37| Int) ) (!  (=> (and (and (= (type $ly@@398) LayerTypeType) (= (type |run#0@@109|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@109| |needle#0@@37|) (and (and ($Is |run#0@@109| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@37|) (INTERNAL_lt_boogie |needle#0@@37| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@109|)))) (and (and (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGt $ly@@398 |run#0@@109| |needle#0@@37|) (|Seq#Length| |run#0@@109|)) (forall ((|i#0@@108| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@108|) (INTERNAL_lt_boogie |i#0@@108| (Byte__Order.__default.IndexOfFirstGt $ly@@398 |run#0@@109| |needle#0@@37|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@109| |i#0@@108|))) |needle#0@@37|))
 :qid |totalorderidfyByteOrder.595:20|
 :skolemid |5723|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@109| |i#0@@108|)))
))) (forall ((|i#1@@23| Int) ) (!  (=> (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGt $ly@@398 |run#0@@109| |needle#0@@37|) |i#1@@23|) (INTERNAL_lt_boogie |i#1@@23| (|Seq#Length| |run#0@@109|))) (Byte__Order.__default.lt |needle#0@@37| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@109| |i#1@@23|)))))
 :qid |totalorderidfyByteOrder.596:20|
 :skolemid |5724|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@109| |i#1@@23|)))
))) (INTERNAL_le_boogie 0 (Byte__Order.__default.IndexOfFirstGt $ly@@398 |run#0@@109| |needle#0@@37|))))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |5725|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt $ly@@398 |run#0@@109| |needle#0@@37|))
))))
(assert (forall (($ly@@399 T@U) (|run#0@@110| T@U) (|needle#0@@38| Int) ) (!  (=> (and (and (= (type $ly@@399) LayerTypeType) (= (type |run#0@@110|) (SeqType BoxType))) (and ($Is |run#0@@110| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@38|) (INTERNAL_lt_boogie |needle#0@@38| 256)))) (= (|Byte__Order.__default.IndexOfFirstGt#requires| $ly@@399 |run#0@@110| |needle#0@@38|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@110|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |5726|
 :pattern ( (|Byte__Order.__default.IndexOfFirstGt#requires| $ly@@399 |run#0@@110| |needle#0@@38|))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@400 T@U) (|run#0@@111| T@U) (|needle#0@@39| Int) ) (!  (=> (and (and (= (type $ly@@400) LayerTypeType) (= (type |run#0@@111|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@111| |needle#0@@39|) (and (and ($Is |run#0@@111| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@39|) (INTERNAL_lt_boogie |needle#0@@39| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@111|)))) (and (=> (not (= (|Seq#Length| |run#0@@111|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte |run#0@@111|) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|)) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|)) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte |run#0@@111|) (|Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@111|) |needle#0@@39|))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted4) MoreFuel_Byte_Order._default.IsSorted4)) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@400) |run#0@@111| |needle#0@@39|) (ite (= (|Seq#Length| |run#0@@111|) (LitInt 0)) 0 (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|) (|Seq#Length| |run#0@@111|) (Byte__Order.__default.IndexOfFirstGt $ly@@400 (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@111|) |needle#0@@39|)))))))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |5727|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@400) |run#0@@111| |needle#0@@39|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@401 T@U) (|run#0@@112| T@U) (|needle#0@@40| Int) ) (!  (=> (and (and (= (type $ly@@401) LayerTypeType) (= (type |run#0@@112|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@112|) (LitInt |needle#0@@40|)) (and (and ($Is |run#0@@112| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@40|) (INTERNAL_lt_boogie |needle#0@@40| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@112|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@112|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte (Lit |run#0@@112|)) (|Byte__Order.__default.lte#canCall| (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|))) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte (Lit |run#0@@112|)) (|Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@112|))) (LitInt |needle#0@@40|)))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted5) MoreFuel_Byte_Order._default.IsSorted5)) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@401) (Lit |run#0@@112|) (LitInt |needle#0@@40|)) (ite (= (|Seq#Length| (Lit |run#0@@112|)) (LitInt 0)) 0 (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|)) (|Seq#Length| (Lit |run#0@@112|)) (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@401) (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@112|))) (LitInt |needle#0@@40|))))))))
 :qid |totalorderidfyByteOrder.592:12|
 :weight 3
 :skolemid |5728|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@401) (Lit |run#0@@112|) (LitInt |needle#0@@40|)))
))))
(assert (forall (($ly@@402 T@U) (|s#0@@132| T@U) (|key#0@@65| Int) (|lo#0@@12| Int) (|hi#0@@6| Int) ) (!  (=> (and (= (type $ly@@402) LayerTypeType) (= (type |s#0@@132|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@402) |s#0@@132| |key#0@@65| |lo#0@@12| |hi#0@@6|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@402 |s#0@@132| |key#0@@65| |lo#0@@12| |hi#0@@6|)))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |5729|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@402) |s#0@@132| |key#0@@65| |lo#0@@12| |hi#0@@6|))
)))
(assert (forall (($ly@@403 T@U) (|s#0@@133| T@U) (|key#0@@66| Int) (|lo#0@@13| Int) (|hi#0@@7| Int) ) (!  (=> (and (= (type $ly@@403) LayerTypeType) (= (type |s#0@@133|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@403 |s#0@@133| |key#0@@66| |lo#0@@13| |hi#0@@7|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@133| |key#0@@66| |lo#0@@13| |hi#0@@7|)))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |5730|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@403) |s#0@@133| |key#0@@66| |lo#0@@13| |hi#0@@7|))
)))
(assert  (=> true (forall (($ly@@404 T@U) (|s#0@@134| T@U) (|key#0@@67| Int) (|lo#0@@14| Int) (|hi#0@@8| Int) ) (!  (=> (and (and (= (type $ly@@404) LayerTypeType) (= (type |s#0@@134|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|) (and (and ($Is |s#0@@134| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@67|) (INTERNAL_lt_boogie |key#0@@67| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@14|) (INTERNAL_lt_boogie |lo#0@@14| |hi#0@@8|)) (INTERNAL_le_boogie |hi#0@@8| (INTERNAL_add_boogie (|Seq#Length| |s#0@@134|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@14| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie |lo#0@@14| 1)))) |key#0@@67|))) (=> (INTERNAL_le_boogie |hi#0@@8| (|Seq#Length| |s#0@@134|)) (Byte__Order.__default.lt |key#0@@67| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie |hi#0@@8| 1)))))))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|) (|Seq#Length| |s#0@@134|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|) 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|) 1)))) |key#0@@67|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|) (|Seq#Length| |s#0@@134|)) (Byte__Order.__default.lt |key#0@@67| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|))))))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |5731|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@404 |s#0@@134| |key#0@@67| |lo#0@@14| |hi#0@@8|))
))))
(assert (forall (($ly@@405 T@U) (|s#0@@135| T@U) (|key#0@@68| Int) (|lo#0@@15| Int) (|hi#0@@9| Int) ) (!  (=> (and (and (= (type $ly@@405) LayerTypeType) (= (type |s#0@@135|) (SeqType BoxType))) (and ($Is |s#0@@135| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@68|) (INTERNAL_lt_boogie |key#0@@68| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@405 |s#0@@135| |key#0@@68| |lo#0@@15| |hi#0@@9|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@15|) (INTERNAL_lt_boogie |lo#0@@15| |hi#0@@9|)) (INTERNAL_le_boogie |hi#0@@9| (INTERNAL_add_boogie (|Seq#Length| |s#0@@135|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@15| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@135| (INTERNAL_sub_boogie |lo#0@@15| 1)))) |key#0@@68|))) (=> (INTERNAL_le_boogie |hi#0@@9| (|Seq#Length| |s#0@@135|)) (Byte__Order.__default.lt |key#0@@68| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@135| (INTERNAL_sub_boogie |hi#0@@9| 1)))))))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |5732|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@405 |s#0@@135| |key#0@@68| |lo#0@@15| |hi#0@@9|))
)))
(assert  (=> true (forall (($ly@@406 T@U) (|s#0@@136| T@U) (|key#0@@69| Int) (|lo#0@@16| Int) (|hi#0@@10| Int) ) (!  (=> (and (and (= (type $ly@@406) LayerTypeType) (= (type |s#0@@136|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@69| |lo#0@@16| |hi#0@@10|) (and (and ($Is |s#0@@136| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@69|) (INTERNAL_lt_boogie |key#0@@69| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@16|) (INTERNAL_lt_boogie |lo#0@@16| |hi#0@@10|)) (INTERNAL_le_boogie |hi#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@136|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@16| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |lo#0@@16| 1)))) |key#0@@69|))) (=> (INTERNAL_le_boogie |hi#0@@10| (|Seq#Length| |s#0@@136|)) (Byte__Order.__default.lt |key#0@@69| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |hi#0@@10| 1)))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@16| 1) |hi#0@@10|) (let ((|mid#0@@1| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@16| |hi#0@@10|) 2)))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@69|) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@69|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@69| |mid#0@@1| |hi#0@@10|))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@69|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@69| |lo#0@@16| |mid#0@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@406) |s#0@@136| |key#0@@69| |lo#0@@16| |hi#0@@10|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@16| 1) |hi#0@@10|) (let ((|mid#0@@2| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@16| |hi#0@@10|) 2)))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@2| 1)))) |key#0@@69|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@406 |s#0@@136| |key#0@@69| |mid#0@@2| |hi#0@@10|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@406 |s#0@@136| |key#0@@69| |lo#0@@16| |mid#0@@2|))) |lo#0@@16|))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |5733|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@406) |s#0@@136| |key#0@@69| |lo#0@@16| |hi#0@@10|))
))))
(assert  (=> true (forall (($ly@@407 T@U) (|s#0@@137| T@U) (|key#0@@70| Int) (|lo#0@@17| Int) (|hi#0@@11| Int) ) (!  (=> (and (and (= (type $ly@@407) LayerTypeType) (= (type |s#0@@137|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@70| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)) (and (and ($Is |s#0@@137| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@70|) (INTERNAL_lt_boogie |key#0@@70| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@17|) (INTERNAL_lt_boogie |lo#0@@17| |hi#0@@11|)) (INTERNAL_le_boogie |hi#0@@11| (INTERNAL_add_boogie (|Seq#Length| |s#0@@137|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@17| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |lo#0@@17| 1))))) |key#0@@70|))) (=> (INTERNAL_le_boogie |hi#0@@11| (|Seq#Length| |s#0@@137|)) (Byte__Order.__default.lt |key#0@@70| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |hi#0@@11| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@17| 1) |hi#0@@11|)))) (let ((|mid#1@@1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@17| |hi#0@@11|) 2))))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@70|) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@70|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@70| |mid#1@@1| (LitInt |hi#0@@11|)))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@70|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@70| (LitInt |lo#0@@17|) |mid#1@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@407) |s#0@@137| |key#0@@70| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@17| 1) |hi#0@@11|) (let ((|mid#1@@2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@17| |hi#0@@11|) 2))))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |mid#1@@2| 1))))) |key#0@@70|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@407) |s#0@@137| |key#0@@70| |mid#1@@2| (LitInt |hi#0@@11|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@407) |s#0@@137| |key#0@@70| (LitInt |lo#0@@17|) |mid#1@@2|))) |lo#0@@17|))))
 :qid |totalorderidfyByteOrder.624:12|
 :weight 3
 :skolemid |5734|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@407) |s#0@@137| |key#0@@70| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)))
))))
(assert  (=> true (forall (($ly@@408 T@U) (|s#0@@138| T@U) (|key#0@@71| Int) (|lo#0@@18| Int) (|hi#0@@12| Int) ) (!  (=> (and (and (= (type $ly@@408) LayerTypeType) (= (type |s#0@@138|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@71|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)) (and (and ($Is |s#0@@138| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@71|) (INTERNAL_lt_boogie |key#0@@71| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@18|) (INTERNAL_lt_boogie |lo#0@@18| |hi#0@@12|)) (INTERNAL_le_boogie |hi#0@@12| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@138|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@18| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |lo#0@@18| 1))))) (LitInt |key#0@@71|)))) (=> (INTERNAL_le_boogie |hi#0@@12| (|Seq#Length| (Lit |s#0@@138|))) (Byte__Order.__default.lt (LitInt |key#0@@71|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |hi#0@@12| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@18| 1) |hi#0@@12|)))) (let ((|mid#2@@1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@18| |hi#0@@12|) 2))))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@71|)) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@71|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@71|) |mid#2@@1| (LitInt |hi#0@@12|)))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@71|))) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@71|) (LitInt |lo#0@@18|) |mid#2@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@408) (Lit |s#0@@138|) (LitInt |key#0@@71|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@18| 1) |hi#0@@12|) (let ((|mid#2@@2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@18| |hi#0@@12|) 2))))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |mid#2@@2| 1))))) (LitInt |key#0@@71|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@408) (Lit |s#0@@138|) (LitInt |key#0@@71|) |mid#2@@2| (LitInt |hi#0@@12|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@408) (Lit |s#0@@138|) (LitInt |key#0@@71|) (LitInt |lo#0@@18|) |mid#2@@2|))) |lo#0@@18|))))
 :qid |totalorderidfyByteOrder.624:12|
 :weight 3
 :skolemid |5735|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@408) (Lit |s#0@@138|) (LitInt |key#0@@71|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)))
))))
(assert (forall (($ly@@409 T@U) (|s#0@@139| T@U) (|key#0@@72| Int) ) (!  (=> (and (= (type $ly@@409) LayerTypeType) (= (type |s#0@@139|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@409) |s#0@@139| |key#0@@72|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@409 |s#0@@139| |key#0@@72|)))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |5736|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@409) |s#0@@139| |key#0@@72|))
)))
(assert (forall (($ly@@410 T@U) (|s#0@@140| T@U) (|key#0@@73| Int) ) (!  (=> (and (= (type $ly@@410) LayerTypeType) (= (type |s#0@@140|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@410 |s#0@@140| |key#0@@73|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@140| |key#0@@73|)))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |5737|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@410) |s#0@@140| |key#0@@73|))
)))
(assert  (=> true (forall (($ly@@411 T@U) (|s#0@@141| T@U) (|key#0@@74| Int) ) (!  (=> (and (and (= (type $ly@@411) LayerTypeType) (= (type |s#0@@141|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@141| |key#0@@74|) (and ($Is |s#0@@141| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@74|) (INTERNAL_lt_boogie |key#0@@74| 256))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|) (|Seq#Length| |s#0@@141|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|) 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@141| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|) 1)))) |key#0@@74|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|) (|Seq#Length| |s#0@@141|)) (Byte__Order.__default.lt |key#0@@74| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@141| (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|))))))))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |5738|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@411 |s#0@@141| |key#0@@74|))
))))
(assert (forall (($ly@@412 T@U) (|s#0@@142| T@U) (|key#0@@75| Int) ) (!  (=> (and (and (= (type $ly@@412) LayerTypeType) (= (type |s#0@@142|) (SeqType BoxType))) (and ($Is |s#0@@142| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@75|) (INTERNAL_lt_boogie |key#0@@75| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@412 |s#0@@142| |key#0@@75|) true))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |5739|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@412 |s#0@@142| |key#0@@75|))
)))
(assert  (=> true (forall (($ly@@413 T@U) (|s#0@@143| T@U) (|key#0@@76| Int) ) (!  (=> (and (and (= (type $ly@@413) LayerTypeType) (= (type |s#0@@143|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@143| |key#0@@76|) (and ($Is |s#0@@143| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@76|) (INTERNAL_lt_boogie |key#0@@76| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@143| |key#0@@76| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@143|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@413) |s#0@@143| |key#0@@76|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@143| |key#0@@76| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@143|) 1)))))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |5740|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@413) |s#0@@143| |key#0@@76|))
))))
(assert  (=> true (forall (($ly@@414 T@U) (|s#0@@144| T@U) (|key#0@@77| Int) ) (!  (=> (and (and (= (type $ly@@414) LayerTypeType) (= (type |s#0@@144|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@144|) (LitInt |key#0@@77|)) (and ($Is |s#0@@144| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@77|) (INTERNAL_lt_boogie |key#0@@77| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@144|) (LitInt |key#0@@77|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@144|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@414) (Lit |s#0@@144|) (LitInt |key#0@@77|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@144|) (LitInt |key#0@@77|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@144|)) 1)))))
 :qid |totalorderidfyByteOrder.644:22|
 :weight 3
 :skolemid |5741|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@414) (Lit |s#0@@144|) (LitInt |key#0@@77|)))
))))
(assert  (=> true (forall ((|a#0@@115| T@U) (|b#0@@73| T@U) ) (!  (=> (and (and (= (type |a#0@@115|) (MapType0Type BoxType boolType)) (= (type |b#0@@73|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| |a#0@@115| |b#0@@73|) (and ($Is |a#0@@115| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@73| (TSet Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |5742|
 :pattern ( (Byte__Order.__default.SetAllLte |a#0@@115| |b#0@@73|))
))))
(assert (forall ((|a#0@@116| T@U) (|b#0@@74| T@U) ) (!  (=> (and (and (= (type |a#0@@116|) (MapType0Type BoxType boolType)) (= (type |b#0@@74|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@116| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@74| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SetAllLte#requires| |a#0@@116| |b#0@@74|) true))
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |5743|
 :pattern ( (|Byte__Order.__default.SetAllLte#requires| |a#0@@116| |b#0@@74|))
)))
(assert  (=> true (forall ((|a#0@@117| T@U) (|b#0@@75| T@U) ) (!  (=> (and (and (= (type |a#0@@117|) (MapType0Type BoxType boolType)) (= (type |b#0@@75|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| |a#0@@117| |b#0@@75|) (and ($Is |a#0@@117| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@75| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#0@@2| Int) (|y#0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@2|) (INTERNAL_lt_boogie |x#0@@2| 256)) (and (INTERNAL_le_boogie 0 |y#0|) (INTERNAL_lt_boogie |y#0| 256))) (=> (U_2_bool (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@2|)))) (=> (U_2_bool (MapType0Select |b#0@@75| ($Box (int_2_U |y#0|)))) (|Byte__Order.__default.lte#canCall| |x#0@@2| |y#0|))))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |5745|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@2| |y#0|))
 :pattern ( (MapType0Select |b#0@@75| ($Box (int_2_U |y#0|))) (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@2|))))
)) (= (Byte__Order.__default.SetAllLte |a#0@@117| |b#0@@75|) (forall ((|x#0@@3| Int) (|y#0@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@3|) (INTERNAL_lt_boogie |x#0@@3| 256)) (and (INTERNAL_le_boogie 0 |y#0@@0|) (INTERNAL_lt_boogie |y#0@@0| 256))) (=> (and (U_2_bool (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@3|)))) (U_2_bool (MapType0Select |b#0@@75| ($Box (int_2_U |y#0@@0|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@3| |y#0@@0|)))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |5744|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@3| |y#0@@0|))
 :pattern ( (MapType0Select |b#0@@75| ($Box (int_2_U |y#0@@0|))) (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@3|))))
)))))
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |5746|
 :pattern ( (Byte__Order.__default.SetAllLte |a#0@@117| |b#0@@75|))
))))
(assert  (=> true (forall ((|a#0@@118| T@U) (|b#0@@76| T@U) ) (!  (=> (and (and (= (type |a#0@@118|) (MapType0Type BoxType boolType)) (= (type |b#0@@76|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@118|) (Lit |b#0@@76|)) (and ($Is |a#0@@118| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@76| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#1| Int) (|y#1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1|) (INTERNAL_lt_boogie |x#1| 256)) (and (INTERNAL_le_boogie 0 |y#1|) (INTERNAL_lt_boogie |y#1| 256))) (=> (U_2_bool (MapType0Select (Lit |a#0@@118|) ($Box (int_2_U |x#1|)))) (=> (U_2_bool (MapType0Select (Lit |b#0@@76|) ($Box (int_2_U |y#1|)))) (|Byte__Order.__default.lte#canCall| |x#1| |y#1|))))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |5748|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1| |y#1|))
 :pattern ( (MapType0Select |b#0@@76| ($Box (int_2_U |y#1|))) (MapType0Select |a#0@@118| ($Box (int_2_U |x#1|))))
)) (= (Byte__Order.__default.SetAllLte (Lit |a#0@@118|) (Lit |b#0@@76|)) (forall ((|x#1@@0| Int) (|y#1@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@0|) (INTERNAL_lt_boogie |x#1@@0| 256)) (and (INTERNAL_le_boogie 0 |y#1@@0|) (INTERNAL_lt_boogie |y#1@@0| 256))) (=> (and (U_2_bool (MapType0Select (Lit |a#0@@118|) ($Box (int_2_U |x#1@@0|)))) (U_2_bool (MapType0Select (Lit |b#0@@76|) ($Box (int_2_U |y#1@@0|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1@@0| |y#1@@0|)))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |5747|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1@@0| |y#1@@0|))
 :pattern ( (MapType0Select |b#0@@76| ($Box (int_2_U |y#1@@0|))) (MapType0Select |a#0@@118| ($Box (int_2_U |x#1@@0|))))
)))))
 :qid |totalorderidfyByteOrder.803:23|
 :weight 3
 :skolemid |5749|
 :pattern ( (Byte__Order.__default.SetAllLte (Lit |a#0@@118|) (Lit |b#0@@76|)))
))))
(assert  (=> true (forall ((|a#0@@119| T@U) (|b#0@@77| T@U) ) (!  (=> (and (and (= (type |a#0@@119|) (MapType0Type BoxType boolType)) (= (type |b#0@@77|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| |a#0@@119| |b#0@@77|) (and ($Is |a#0@@119| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@77| (TSet Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |5750|
 :pattern ( (Byte__Order.__default.SetAllLt |a#0@@119| |b#0@@77|))
))))
(assert (forall ((|a#0@@120| T@U) (|b#0@@78| T@U) ) (!  (=> (and (and (= (type |a#0@@120|) (MapType0Type BoxType boolType)) (= (type |b#0@@78|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@120| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@78| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SetAllLt#requires| |a#0@@120| |b#0@@78|) true))
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |5751|
 :pattern ( (|Byte__Order.__default.SetAllLt#requires| |a#0@@120| |b#0@@78|))
)))
(assert  (=> true (forall ((|a#0@@121| T@U) (|b#0@@79| T@U) ) (!  (=> (and (and (= (type |a#0@@121|) (MapType0Type BoxType boolType)) (= (type |b#0@@79|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| |a#0@@121| |b#0@@79|) (and ($Is |a#0@@121| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@79| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#0@@4| Int) (|y#0@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@4|) (INTERNAL_lt_boogie |x#0@@4| 256)) (and (INTERNAL_le_boogie 0 |y#0@@1|) (INTERNAL_lt_boogie |y#0@@1| 256))) (=> (U_2_bool (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@4|)))) (=> (U_2_bool (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@1|)))) (|Byte__Order.__default.lt#canCall| |x#0@@4| |y#0@@1|))))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |5753|
 :pattern ( (Byte__Order.__default.lt |x#0@@4| |y#0@@1|))
 :pattern ( (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@1|))) (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@4|))))
)) (= (Byte__Order.__default.SetAllLt |a#0@@121| |b#0@@79|) (forall ((|x#0@@5| Int) (|y#0@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@5|) (INTERNAL_lt_boogie |x#0@@5| 256)) (and (INTERNAL_le_boogie 0 |y#0@@2|) (INTERNAL_lt_boogie |y#0@@2| 256))) (=> (and (U_2_bool (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@5|)))) (U_2_bool (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@2|))))) (Byte__Order.__default.lt |x#0@@5| |y#0@@2|)))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |5752|
 :pattern ( (Byte__Order.__default.lt |x#0@@5| |y#0@@2|))
 :pattern ( (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@2|))) (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@5|))))
)))))
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |5754|
 :pattern ( (Byte__Order.__default.SetAllLt |a#0@@121| |b#0@@79|))
))))
(assert  (=> true (forall ((|a#0@@122| T@U) (|b#0@@80| T@U) ) (!  (=> (and (and (= (type |a#0@@122|) (MapType0Type BoxType boolType)) (= (type |b#0@@80|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@122|) (Lit |b#0@@80|)) (and ($Is |a#0@@122| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@80| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#1@@1| Int) (|y#1@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@1|) (INTERNAL_lt_boogie |x#1@@1| 256)) (and (INTERNAL_le_boogie 0 |y#1@@1|) (INTERNAL_lt_boogie |y#1@@1| 256))) (=> (U_2_bool (MapType0Select (Lit |a#0@@122|) ($Box (int_2_U |x#1@@1|)))) (=> (U_2_bool (MapType0Select (Lit |b#0@@80|) ($Box (int_2_U |y#1@@1|)))) (|Byte__Order.__default.lt#canCall| |x#1@@1| |y#1@@1|))))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |5756|
 :pattern ( (Byte__Order.__default.lt |x#1@@1| |y#1@@1|))
 :pattern ( (MapType0Select |b#0@@80| ($Box (int_2_U |y#1@@1|))) (MapType0Select |a#0@@122| ($Box (int_2_U |x#1@@1|))))
)) (= (Byte__Order.__default.SetAllLt (Lit |a#0@@122|) (Lit |b#0@@80|)) (forall ((|x#1@@2| Int) (|y#1@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@2|) (INTERNAL_lt_boogie |x#1@@2| 256)) (and (INTERNAL_le_boogie 0 |y#1@@2|) (INTERNAL_lt_boogie |y#1@@2| 256))) (=> (and (U_2_bool (MapType0Select (Lit |a#0@@122|) ($Box (int_2_U |x#1@@2|)))) (U_2_bool (MapType0Select (Lit |b#0@@80|) ($Box (int_2_U |y#1@@2|))))) (Byte__Order.__default.lt |x#1@@2| |y#1@@2|)))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |5755|
 :pattern ( (Byte__Order.__default.lt |x#1@@2| |y#1@@2|))
 :pattern ( (MapType0Select |b#0@@80| ($Box (int_2_U |y#1@@2|))) (MapType0Select |a#0@@122| ($Box (int_2_U |x#1@@2|))))
)))))
 :qid |totalorderidfyByteOrder.807:22|
 :weight 3
 :skolemid |5757|
 :pattern ( (Byte__Order.__default.SetAllLt (Lit |a#0@@122|) (Lit |b#0@@80|)))
))))
(assert (forall (($ly@@415 T@U) (|a#0@@123| Int) ) (!  (=> (= (type $ly@@415) LayerTypeType) (= (Byte__Order.__default.NotMinimum ($LS $ly@@415) |a#0@@123|) (Byte__Order.__default.NotMinimum $ly@@415 |a#0@@123|)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |5758|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@415) |a#0@@123|))
)))
(assert (forall (($ly@@416 T@U) (|a#0@@124| Int) ) (!  (=> (= (type $ly@@416) LayerTypeType) (= (Byte__Order.__default.NotMinimum $ly@@416 |a#0@@124|) (Byte__Order.__default.NotMinimum $LZ |a#0@@124|)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |5759|
 :pattern ( (Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@416) |a#0@@124|))
)))
(assert  (=> true (forall (($ly@@417 T@U) (|a#0@@125| Int) ) (!  (=> (and (= (type $ly@@417) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| |a#0@@125|) (and (INTERNAL_le_boogie 0 |a#0@@125|) (INTERNAL_lt_boogie |a#0@@125| 256)))) true)
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |5760|
 :pattern ( (Byte__Order.__default.NotMinimum $ly@@417 |a#0@@125|))
))))
(assert (forall (($ly@@418 T@U) (|a#0@@126| Int) ) (!  (=> (= (type $ly@@418) LayerTypeType) (=> (and (INTERNAL_le_boogie 0 |a#0@@126|) (INTERNAL_lt_boogie |a#0@@126| 256)) (= (|Byte__Order.__default.NotMinimum#requires| $ly@@418 |a#0@@126|) true)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |5761|
 :pattern ( (|Byte__Order.__default.NotMinimum#requires| $ly@@418 |a#0@@126|))
)))
(assert  (=> true (forall (($ly@@419 T@U) (|a#0@@127| Int) ) (!  (=> (and (= (type $ly@@419) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| |a#0@@127|) (and (INTERNAL_le_boogie 0 |a#0@@127|) (INTERNAL_lt_boogie |a#0@@127| 256)))) (and (forall ((|b#0@@81| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |b#0@@81|) (INTERNAL_lt_boogie |b#0@@81| 256)) (|Byte__Order.__default.lt#canCall| |b#0@@81| |a#0@@127|))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |5763|
 :pattern ( (Byte__Order.__default.lt |b#0@@81| |a#0@@127|))
)) (= (Byte__Order.__default.NotMinimum ($LS $ly@@419) |a#0@@127|) (exists ((|b#0@@82| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |b#0@@82|) (INTERNAL_lt_boogie |b#0@@82| 256)) (Byte__Order.__default.lt |b#0@@82| |a#0@@127|))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |5762|
 :pattern ( (Byte__Order.__default.lt |b#0@@82| |a#0@@127|))
)))))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |5764|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@419) |a#0@@127|))
))))
(assert  (=> true (forall (($ly@@420 T@U) (|a#0@@128| Int) ) (!  (=> (and (= (type $ly@@420) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| (LitInt |a#0@@128|)) (and (INTERNAL_le_boogie 0 |a#0@@128|) (INTERNAL_lt_boogie |a#0@@128| 256)))) (and (forall ((|b#1@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |b#1@@0|) (INTERNAL_lt_boogie |b#1@@0| 256)) (|Byte__Order.__default.lt#canCall| |b#1@@0| (LitInt |a#0@@128|)))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |5766|
 :pattern ( (Byte__Order.__default.lt |b#1@@0| |a#0@@128|))
)) (= (Byte__Order.__default.NotMinimum ($LS $ly@@420) (LitInt |a#0@@128|)) (exists ((|b#1@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |b#1@@1|) (INTERNAL_lt_boogie |b#1@@1| 256)) (Byte__Order.__default.lt |b#1@@1| (LitInt |a#0@@128|)))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |5765|
 :pattern ( (Byte__Order.__default.lt |b#1@@1| |a#0@@128|))
)))))
 :qid |totalorderidfyByteOrder.820:23|
 :weight 3
 :skolemid |5767|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@420) (LitInt |a#0@@128|)))
))))
(assert (forall ((arg0@@594 T@U) (arg1@@295 T@U) (arg2@@163 Int) (arg3@@97 T@U) ) (! (= (type (Byte__Order.__default.MapPivotedUnion arg0@@594 arg1@@295 arg2@@163 arg3@@97)) (MapType BoxType BoxType))
 :qid |funType:Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Byte__Order.__default.MapPivotedUnion arg0@@594 arg1@@295 arg2@@163 arg3@@97))
)))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0| T@U) (|pivot#0| Int) (|right#0| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0|) (MapType BoxType BoxType))) (= (type |right#0|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|) (and (and ($Is |left#0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value)) (and (INTERNAL_le_boogie 0 |pivot#0|) (INTERNAL_lt_boogie |pivot#0| 256))) ($Is |right#0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|) (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |5768|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|))
))))
(assert (forall ((Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@0| T@U) (|pivot#0@@0| Int) (|right#0@@0| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@0|) (MapType BoxType BoxType))) (= (type |right#0@@0|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@0)) (and (INTERNAL_le_boogie 0 |pivot#0@@0|) (INTERNAL_lt_boogie |pivot#0@@0| 256))) ($Is |right#0@@0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Byte__Order.__default.MapPivotedUnion#requires| Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@0| |pivot#0@@0| |right#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |5769|
 :pattern ( (|Byte__Order.__default.MapPivotedUnion#requires| Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@0| |pivot#0@@0| |right#0@@0|))
)))
(assert  (and (forall ((arg0@@595 T@U) (arg1@@296 Int) ) (! (= (type (|lambda#295| arg0@@595 arg1@@296)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#295|
 :pattern ( (|lambda#295| arg0@@595 arg1@@296))
)) (forall ((arg0@@596 T@U) (arg1@@297 T@U) (arg2@@164 Int) ) (! (= (type (|lambda#297| arg0@@596 arg1@@297 arg2@@164)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#297|
 :pattern ( (|lambda#297| arg0@@596 arg1@@297 arg2@@164))
))))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@1| T@U) (|pivot#0@@1| Int) (|right#0@@1| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@1|) (MapType BoxType BoxType))) (= (type |right#0@@1|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|) (and (and ($Is |left#0@@1| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1)) (and (INTERNAL_le_boogie 0 |pivot#0@@1|) (INTERNAL_lt_boogie |pivot#0@@1| 256))) ($Is |right#0@@1| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@77| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#0@@77|) (INTERNAL_lt_boogie |k#0@@77| 256)) (|Byte__Order.__default.lt#canCall| |k#0@@77| |pivot#0@@1|))
 :qid |totalorderidfyByteOrder.840:57|
 :skolemid |5770|
 :pattern ( (Byte__Order.__default.lt |k#0@@77| |pivot#0@@1|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#295| Tclass.NativeTypes.byte |pivot#0@@1|))) (let ((|restricted_left#0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#295| Tclass.NativeTypes.byte |pivot#0@@1|))))
 (and (and (forall ((|k#1@@15| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#1@@15|) (INTERNAL_lt_boogie |k#1@@15| 256)) (|Byte__Order.__default.lte#canCall| |pivot#0@@1| |k#1@@15|))
 :qid |totalorderidfyByteOrder.841:59|
 :skolemid |5771|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |pivot#0@@1| |k#1@@15|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))) (let ((|restricted_right#0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0| |restricted_right#0|))))) (= (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|) (let ((|restricted_left#0@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#295| Tclass.NativeTypes.byte |pivot#0@@1|))))
(let ((|restricted_right#0@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))))
(Maps.__default.MapDisjointUnion Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@0| |restricted_right#0@@0|))))))
 :qid |unknown.0:0|
 :skolemid |5772|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|))
))))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@2| T@U) (|pivot#0@@2| Int) (|right#0@@2| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@2|) (MapType BoxType BoxType))) (= (type |right#0@@2|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)) (and (and ($Is |left#0@@2| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2)) (and (INTERNAL_le_boogie 0 |pivot#0@@2|) (INTERNAL_lt_boogie |pivot#0@@2| 256))) ($Is |right#0@@2| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#2@@6|) (INTERNAL_lt_boogie |k#2@@6| 256)) (|Byte__Order.__default.lt#canCall| |k#2@@6| (LitInt |pivot#0@@2|)))
 :qid |totalorderidfyByteOrder.840:57|
 :skolemid |5773|
 :pattern ( (Byte__Order.__default.lt |k#2@@6| |pivot#0@@2|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#295| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))) (let ((|restricted_left#1| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#295| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))))
 (and (and (forall ((|k#3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#3|) (INTERNAL_lt_boogie |k#3| 256)) (|Byte__Order.__default.lte#canCall| (LitInt |pivot#0@@2|) |k#3|))
 :qid |totalorderidfyByteOrder.841:59|
 :skolemid |5774|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |pivot#0@@2| |k#3|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))) (let ((|restricted_right#1| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1| |restricted_right#1|))))) (= (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)) (let ((|restricted_left#1@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#295| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))))
(let ((|restricted_right#1@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#297| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))))
(Maps.__default.MapDisjointUnion Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@0| |restricted_right#1@@0|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5775|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)))
))))
(assert (forall ((arg0@@597 T@U) (arg1@@298 Int) ) (! (= (type (Byte__Order.__default.SetSuccessor arg0@@597 arg1@@298)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.SetSuccessor|
 :pattern ( (Byte__Order.__default.SetSuccessor arg0@@597 arg1@@298))
)))
(assert  (=> true (forall ((|m#0@@110| T@U) (|key#0@@78| Int) ) (!  (=> (and (= (type |m#0@@110|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.SetSuccessor#canCall| |m#0@@110| |key#0@@78|) (and ($Is |m#0@@110| (TSet Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@78|) (INTERNAL_lt_boogie |key#0@@78| 256))))) ($Is (Byte__Order.__default.SetSuccessor |m#0@@110| |key#0@@78|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |totalorderidfyByteOrder.845:25|
 :skolemid |5776|
 :pattern ( (Byte__Order.__default.SetSuccessor |m#0@@110| |key#0@@78|))
))))
(assert (forall (($Heap@@56 T@U) (|m#0@@111| T@U) (|key#0@@79| Int) ) (!  (=> (and (= (type $Heap@@56) (MapType0Type refType MapType1Type)) (= (type |m#0@@111|) (MapType0Type BoxType boolType))) (=> (and (and ($IsGoodHeap $Heap@@56) ($Is |m#0@@111| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@79|) (INTERNAL_lt_boogie |key#0@@79| 256))) (= (|Byte__Order.__default.SetSuccessor#requires| |m#0@@111| |key#0@@79|) true)))
 :qid |totalorderidfyByteOrder.845:12|
 :skolemid |5777|
 :pattern ( (|Byte__Order.__default.SetSuccessor#requires| |m#0@@111| |key#0@@79|) ($IsGoodHeap $Heap@@56))
)))
(assert (forall ((m@@68 T@U) (key Int) ) (!  (=> (and (= (type m@@68) (MapType0Type BoxType boolType)) (|$let#16$canCall| m@@68 key)) (and (and (INTERNAL_le_boogie 0 (|$let#16_next| m@@68 key)) (INTERNAL_lt_boogie (|$let#16_next| m@@68 key) 256)) (and (and (U_2_bool (MapType0Select m@@68 ($Box (int_2_U (|$let#16_next| m@@68 key))))) (Byte__Order.__default.lt key (|$let#16_next| m@@68 key))) (forall ((|other#1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#1|) (INTERNAL_lt_boogie |other#1| 256)) (=> (and (and (U_2_bool (MapType0Select m@@68 ($Box (int_2_U |other#1|)))) (not (= |other#1| (|$let#16_next| m@@68 key)))) (Byte__Order.__default.lt key |other#1|)) (Byte__Order.__default.lt (|$let#16_next| m@@68 key) |other#1|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5780|
 :pattern ( (Byte__Order.__default.lt (|$let#16_next| m@@68 key) |other#1|))
 :pattern ( (Byte__Order.__default.lt key |other#1|))
 :pattern ( (MapType0Select m@@68 ($Box (int_2_U |other#1|))))
)))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5781|
 :pattern ( (|$let#16_next| m@@68 key))
)))
(assert  (=> true (forall (($Heap@@57 T@U) (|m#0@@112| T@U) (|key#0@@80| Int) ) (!  (=> (and (and (= (type $Heap@@57) (MapType0Type refType MapType1Type)) (= (type |m#0@@112|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetSuccessor#canCall| |m#0@@112| |key#0@@80|) (and (and ($IsGoodHeap $Heap@@57) ($Is |m#0@@112| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@80|) (INTERNAL_lt_boogie |key#0@@80| 256))))) (and (and (forall ((|next#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |next#0|) (INTERNAL_lt_boogie |next#0| 256)) (=> (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0|)))) (and (|Byte__Order.__default.lt#canCall| |key#0@@80| |next#0|) (=> (Byte__Order.__default.lt |key#0@@80| |next#0|) (forall ((|other#0@@15| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@15|) (INTERNAL_lt_boogie |other#0@@15| 256)) (=> (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@15|)))) (=> (not (= |other#0@@15| |next#0|)) (and (|Byte__Order.__default.lt#canCall| |key#0@@80| |other#0@@15|) (=> (Byte__Order.__default.lt |key#0@@80| |other#0@@15|) (|Byte__Order.__default.lt#canCall| |next#0| |other#0@@15|))))))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5782|
 :pattern ( (Byte__Order.__default.lt |next#0| |other#0@@15|))
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |other#0@@15|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@15|))))
))))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5783|
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |next#0|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0|))))
)) (=> (exists ((|next#0@@0| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#0@@0|) (INTERNAL_lt_boogie |next#0@@0| 256)) (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@0|)))) (Byte__Order.__default.lt |key#0@@80| |next#0@@0|)) (forall ((|other#0@@16| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@16|) (INTERNAL_lt_boogie |other#0@@16| 256)) (=> (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@16|)))) (not (= |other#0@@16| |next#0@@0|))) (Byte__Order.__default.lt |key#0@@80| |other#0@@16|)) (Byte__Order.__default.lt |next#0@@0| |other#0@@16|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5784|
 :pattern ( (Byte__Order.__default.lt |next#0@@0| |other#0@@16|))
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |other#0@@16|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@16|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5785|
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |next#0@@0|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@0|))))
)) (|$let#16$canCall| |m#0@@112| |key#0@@80|))) (= (Byte__Order.__default.SetSuccessor |m#0@@112| |key#0@@80|) (ite (exists ((|next#0@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#0@@1|) (INTERNAL_lt_boogie |next#0@@1| 256)) (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@1|)))) (Byte__Order.__default.lt |key#0@@80| |next#0@@1|)) (forall ((|other#0@@17| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@17|) (INTERNAL_lt_boogie |other#0@@17| 256)) (=> (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@17|)))) (not (= |other#0@@17| |next#0@@1|))) (Byte__Order.__default.lt |key#0@@80| |other#0@@17|)) (Byte__Order.__default.lt |next#0@@1| |other#0@@17|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5778|
 :pattern ( (Byte__Order.__default.lt |next#0@@1| |other#0@@17|))
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |other#0@@17|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@17|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5779|
 :pattern ( (Byte__Order.__default.lt |key#0@@80| |next#0@@1|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@1|))))
)) (let ((|next#1| (|$let#16_next| |m#0@@112| |key#0@@80|)))
(|#Options.Option.Some| ($Box (int_2_U |next#1|)))) |#Options.Option.None|))))
 :qid |totalorderidfyByteOrder.845:12|
 :skolemid |5786|
 :pattern ( (Byte__Order.__default.SetSuccessor |m#0@@112| |key#0@@80|) ($IsGoodHeap $Heap@@57))
))))
(assert  (=> true (forall (($Heap@@58 T@U) (|m#0@@113| T@U) (|key#0@@81| Int) ) (!  (=> (and (and (= (type $Heap@@58) (MapType0Type refType MapType1Type)) (= (type |m#0@@113|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@113|) (LitInt |key#0@@81|)) (and (and ($IsGoodHeap $Heap@@58) ($Is |m#0@@113| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@81|) (INTERNAL_lt_boogie |key#0@@81| 256))))) (and (and (forall ((|next#2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |next#2|) (INTERNAL_lt_boogie |next#2| 256)) (=> (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2|)))) (and (|Byte__Order.__default.lt#canCall| (LitInt |key#0@@81|) |next#2|) (=> (Byte__Order.__default.lt (LitInt |key#0@@81|) |next#2|) (forall ((|other#2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2|) (INTERNAL_lt_boogie |other#2| 256)) (=> (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2|)))) (=> (not (= |other#2| |next#2|)) (and (|Byte__Order.__default.lt#canCall| (LitInt |key#0@@81|) |other#2|) (=> (Byte__Order.__default.lt (LitInt |key#0@@81|) |other#2|) (|Byte__Order.__default.lt#canCall| |next#2| |other#2|))))))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5789|
 :pattern ( (Byte__Order.__default.lt |next#2| |other#2|))
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |other#2|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2|))))
))))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5790|
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |next#2|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2|))))
)) (=> (exists ((|next#2@@0| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#2@@0|) (INTERNAL_lt_boogie |next#2@@0| 256)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2@@0|)))) (Byte__Order.__default.lt (LitInt |key#0@@81|) |next#2@@0|)) (forall ((|other#2@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2@@0|) (INTERNAL_lt_boogie |other#2@@0| 256)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2@@0|)))) (not (= |other#2@@0| |next#2@@0|))) (Byte__Order.__default.lt (LitInt |key#0@@81|) |other#2@@0|)) (Byte__Order.__default.lt |next#2@@0| |other#2@@0|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5791|
 :pattern ( (Byte__Order.__default.lt |next#2@@0| |other#2@@0|))
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |other#2@@0|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2@@0|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5792|
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |next#2@@0|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2@@0|))))
)) (|$let#16$canCall| (Lit |m#0@@113|) (LitInt |key#0@@81|)))) (= (Byte__Order.__default.SetSuccessor (Lit |m#0@@113|) (LitInt |key#0@@81|)) (ite (exists ((|next#2@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#2@@1|) (INTERNAL_lt_boogie |next#2@@1| 256)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2@@1|)))) (Byte__Order.__default.lt (LitInt |key#0@@81|) |next#2@@1|)) (forall ((|other#2@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2@@1|) (INTERNAL_lt_boogie |other#2@@1| 256)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2@@1|)))) (not (= |other#2@@1| |next#2@@1|))) (Byte__Order.__default.lt (LitInt |key#0@@81|) |other#2@@1|)) (Byte__Order.__default.lt |next#2@@1| |other#2@@1|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |5787|
 :pattern ( (Byte__Order.__default.lt |next#2@@1| |other#2@@1|))
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |other#2@@1|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2@@1|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |5788|
 :pattern ( (Byte__Order.__default.lt |key#0@@81| |next#2@@1|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2@@1|))))
)) (let ((|next#3| (|$let#16_next| (Lit |m#0@@113|) (LitInt |key#0@@81|))))
(|#Options.Option.Some| ($Box (int_2_U |next#3|)))) |#Options.Option.None|))))
 :qid |totalorderidfyByteOrder.845:12|
 :weight 3
 :skolemid |5793|
 :pattern ( (Byte__Order.__default.SetSuccessor (Lit |m#0@@113|) (LitInt |key#0@@81|)) ($IsGoodHeap $Heap@@58))
))))
(assert (forall ((arg0@@598 T@U) (arg1@@299 T@U) (arg2@@165 Int) ) (! (= (type (Byte__Order.__default.MapSuccessor arg0@@598 arg1@@299 arg2@@165)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.MapSuccessor|
 :pattern ( (Byte__Order.__default.MapSuccessor arg0@@598 arg1@@299 arg2@@165))
)))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V T@U) (|m#0@@114| T@U) (|key#0@@82| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@114|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@82|) (and ($Is |m#0@@114| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V)) (and (INTERNAL_le_boogie 0 |key#0@@82|) (INTERNAL_lt_boogie |key#0@@82| 256))))) ($Is (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@82|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |unknown.0:0|
 :skolemid |5794|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@82|))
))))
(assert (forall ((Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@115| T@U) (|key#0@@83| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@115|) (MapType BoxType BoxType))) (and ($Is |m#0@@115| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@0)) (and (INTERNAL_le_boogie 0 |key#0@@83|) (INTERNAL_lt_boogie |key#0@@83| 256)))) (= (|Byte__Order.__default.MapSuccessor#requires| Byte_Order._default.MapSuccessor$V@@0 |m#0@@115| |key#0@@83|) true))
 :qid |unknown.0:0|
 :skolemid |5795|
 :pattern ( (|Byte__Order.__default.MapSuccessor#requires| Byte_Order._default.MapSuccessor$V@@0 |m#0@@115| |key#0@@83|))
)))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@116| T@U) (|key#0@@84| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@116|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@84|) (and ($Is |m#0@@116| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@1)) (and (INTERNAL_le_boogie 0 |key#0@@84|) (INTERNAL_lt_boogie |key#0@@84| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@116|) |key#0@@84|) (= (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@84|) (Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@116|) |key#0@@84|))))
 :qid |unknown.0:0|
 :skolemid |5796|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@84|))
))))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@117| T@U) (|key#0@@85| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@117|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@85|)) (and ($Is |m#0@@117| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@2)) (and (INTERNAL_le_boogie 0 |key#0@@85|) (INTERNAL_lt_boogie |key#0@@85| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@117|))) (LitInt |key#0@@85|)) (= (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@85|)) (Lit (Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@117|))) (LitInt |key#0@@85|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5797|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@85|)))
))))
(assert (forall ((arg0@@599 T@U) (arg1@@300 Int) ) (! (= (type (Byte__Order.__default.SeqSuccessor arg0@@599 arg1@@300)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.SeqSuccessor|
 :pattern ( (Byte__Order.__default.SeqSuccessor arg0@@599 arg1@@300))
)))
(assert  (=> true (forall ((|m#0@@118| T@U) (|key#0@@86| Int) ) (!  (=> (and (= (type |m#0@@118|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| |m#0@@118| |key#0@@86|) (and ($Is |m#0@@118| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@86|) (INTERNAL_lt_boogie |key#0@@86| 256))))) ($Is (Byte__Order.__default.SeqSuccessor |m#0@@118| |key#0@@86|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |5798|
 :pattern ( (Byte__Order.__default.SeqSuccessor |m#0@@118| |key#0@@86|))
))))
(assert (forall ((|m#0@@119| T@U) (|key#0@@87| Int) ) (!  (=> (= (type |m#0@@119|) (SeqType BoxType)) (=> (and ($Is |m#0@@119| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@87|) (INTERNAL_lt_boogie |key#0@@87| 256))) (= (|Byte__Order.__default.SeqSuccessor#requires| |m#0@@119| |key#0@@87|) true)))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |5799|
 :pattern ( (|Byte__Order.__default.SeqSuccessor#requires| |m#0@@119| |key#0@@87|))
)))
(assert (forall ((arg0@@600 T@U) (arg1@@301 T@U) ) (! (= (type (|lambda#307| arg0@@600 arg1@@301)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#307|
 :pattern ( (|lambda#307| arg0@@600 arg1@@301))
)))
(assert  (=> true (forall ((|m#0@@120| T@U) (|key#0@@88| Int) ) (!  (=> (and (= (type |m#0@@120|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| |m#0@@120| |key#0@@88|) (and ($Is |m#0@@120| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@88|) (INTERNAL_lt_boogie |key#0@@88| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| Tclass.NativeTypes.byte |m#0@@120|) |key#0@@88|) (= (Byte__Order.__default.SeqSuccessor |m#0@@120| |key#0@@88|) (Byte__Order.__default.SetSuccessor (|lambda#307| Tclass.NativeTypes.byte |m#0@@120|) |key#0@@88|))))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |5800|
 :pattern ( (Byte__Order.__default.SeqSuccessor |m#0@@120| |key#0@@88|))
))))
(assert  (=> true (forall ((|m#0@@121| T@U) (|key#0@@89| Int) ) (!  (=> (and (= (type |m#0@@121|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@121|) (LitInt |key#0@@89|)) (and ($Is |m#0@@121| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@89|) (INTERNAL_lt_boogie |key#0@@89| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| Tclass.NativeTypes.byte |m#0@@121|) (LitInt |key#0@@89|)) (= (Byte__Order.__default.SeqSuccessor (Lit |m#0@@121|) (LitInt |key#0@@89|)) (Byte__Order.__default.SetSuccessor (|lambda#307| Tclass.NativeTypes.byte |m#0@@121|) (LitInt |key#0@@89|)))))
 :qid |totalorderidfyByteOrder.861:25|
 :weight 3
 :skolemid |5801|
 :pattern ( (Byte__Order.__default.SeqSuccessor (Lit |m#0@@121|) (LitInt |key#0@@89|)))
))))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@421 T@U) (|s#0@@145| T@U) (|m#0@@122| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@421) LayerTypeType)) (= (type |s#0@@145|) (SeqType BoxType))) (= (type |m#0@@122|) (MapType BoxType BoxType))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V ($LS $ly@@421) |s#0@@145| |m#0@@122|) (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V $ly@@421 |s#0@@145| |m#0@@122|)))
 :qid |unknown.0:0|
 :skolemid |5802|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V ($LS $ly@@421) |s#0@@145| |m#0@@122|))
)))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@422 T@U) (|s#0@@146| T@U) (|m#0@@123| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@422) LayerTypeType)) (= (type |s#0@@146|) (SeqType BoxType))) (= (type |m#0@@123|) (MapType BoxType BoxType))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 $ly@@422 |s#0@@146| |m#0@@123|) (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@146| |m#0@@123|)))
 :qid |unknown.0:0|
 :skolemid |5803|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@422) |s#0@@146| |m#0@@123|))
)))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@423 T@U) (|s#0@@147| T@U) (|m#0@@124| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@423) LayerTypeType)) (= (type |s#0@@147|) (SeqType BoxType))) (= (type |m#0@@124|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@147| |m#0@@124|) (and ($Is |s#0@@147| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@124| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |5804|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@1 $ly@@423 |s#0@@147| |m#0@@124|))
))))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@424 T@U) (|s#0@@148| T@U) (|m#0@@125| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@424) LayerTypeType)) (= (type |s#0@@148|) (SeqType BoxType))) (= (type |m#0@@125|) (MapType BoxType BoxType))) (and ($Is |s#0@@148| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@125| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Byte__Order.__default.SortedSeqForMap#requires| Byte_Order._default.SortedSeqForMap$V@@2 $ly@@424 |s#0@@148| |m#0@@125|) true))
 :qid |unknown.0:0|
 :skolemid |5805|
 :pattern ( (|Byte__Order.__default.SortedSeqForMap#requires| Byte_Order._default.SortedSeqForMap$V@@2 $ly@@424 |s#0@@148| |m#0@@125|))
)))
(assert  (and (= (type StartFuel_Sequences._default.Unzip) LayerTypeType) (= (type StartFuel_Byte_Order._default.IsStrictlySorted) LayerTypeType)))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@425 T@U) (|s#0@@149| T@U) (|m#0@@126| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@425) LayerTypeType)) (= (type |s#0@@149|) (SeqType BoxType))) (= (type |m#0@@126|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@149| |m#0@@126|) (and ($Is |s#0@@149| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@126| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@149|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|))) (|Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|))))) (=> (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|)))) (and (forall ((|i#0@@109| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@109|) (=> (INTERNAL_lt_boogie |i#0@@109| (|Seq#Length| |s#0@@149|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@109|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@109|) (INTERNAL_lt_boogie |i#0@@109| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@109|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@109|) (=> (INTERNAL_lt_boogie |i#0@@109| (|Seq#Length| |s#0@@149|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@109|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@109|))))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5809|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@109|)))
)) (=> (forall ((|i#0@@110| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@110|) (INTERNAL_lt_boogie |i#0@@110| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@110|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@110|) (INTERNAL_lt_boogie |i#0@@110| (|Seq#Length| |s#0@@149|))) (= (MapType0Select (|Map#Elements| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@110|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@110|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5812|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@110|)))
)) (forall ((|key#0@@90| T@U) ) (!  (=> (= (type |key#0@@90|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |key#0@@90|)) (INTERNAL_lt_boogie (U_2_int |key#0@@90|) 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) ($Box |key#0@@90|))) (forall ((|i#1@@24| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@24|) (=> (INTERNAL_lt_boogie |i#1@@24| (|Seq#Length| |s#0@@149|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@24|))) (=> (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@24|))))) (U_2_int |key#0@@90|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@24|)))))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |5810|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@24|)))
)))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |5811|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@126|) ($Box |key#0@@90|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@126|) ($Box |key#0@@90|)))
)))))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@425) |s#0@@149| |m#0@@126|)  (and (and (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|)))) (forall ((|i#0@@111| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@111|) (INTERNAL_lt_boogie |i#0@@111| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@111|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@111|) (INTERNAL_lt_boogie |i#0@@111| (|Seq#Length| |s#0@@149|))) (= (MapType0Select (|Map#Elements| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@111|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@111|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5806|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@111|)))
))) (forall ((|key#0@@91| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |key#0@@91|) (INTERNAL_lt_boogie |key#0@@91| 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) ($Box (int_2_U |key#0@@91|)))) (exists ((|i#1@@25| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@25|) (INTERNAL_lt_boogie |i#1@@25| (|Seq#Length| |s#0@@149|))) (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@25|))))) |key#0@@91|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@25|))) (MapType0Select (|Map#Elements| |m#0@@126|) ($Box (int_2_U |key#0@@91|)))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |5807|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@25|)))
))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |5808|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@126|) ($Box (int_2_U |key#0@@91|))))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@126|) ($Box (int_2_U |key#0@@91|))))
))))))
 :qid |unknown.0:0|
 :skolemid |5813|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@425) |s#0@@149| |m#0@@126|))
))))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@426 T@U) (|s#0@@150| T@U) (|m#0@@127| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@426) LayerTypeType)) (= (type |s#0@@150|) (SeqType BoxType))) (= (type |m#0@@127|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@150|) (Lit |m#0@@127|)) (and ($Is |s#0@@150| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@127| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@150|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|)))) (|Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|)))))) (=> (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|))))) (and (forall ((|i#2@@6| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@6|) (=> (INTERNAL_lt_boogie |i#2@@6| (|Seq#Length| (Lit |s#0@@150|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@6|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@6|) (INTERNAL_lt_boogie |i#2@@6| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@6|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@6|) (=> (INTERNAL_lt_boogie |i#2@@6| (|Seq#Length| (Lit |s#0@@150|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@6|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@6|))))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5817|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@6|)))
)) (=> (forall ((|i#2@@7| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@7|) (INTERNAL_lt_boogie |i#2@@7| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@7|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@7|) (INTERNAL_lt_boogie |i#2@@7| (|Seq#Length| (Lit |s#0@@150|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@7|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@7|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5820|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@7|)))
)) (forall ((|key#1@@8| T@U) ) (!  (=> (= (type |key#1@@8|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |key#1@@8|)) (INTERNAL_lt_boogie (U_2_int |key#1@@8|) 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) ($Box |key#1@@8|))) (forall ((|i#3@@1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@1|) (=> (INTERNAL_lt_boogie |i#3@@1| (|Seq#Length| (Lit |s#0@@150|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@1|))) (=> (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@1|))))) (U_2_int |key#1@@8|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@1|)))))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |5818|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#3@@1|)))
)))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |5819|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@127|) ($Box |key#1@@8|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@127|) ($Box |key#1@@8|)))
)))))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@426) (Lit |s#0@@150|) (Lit |m#0@@127|))  (and (and (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|))))) (forall ((|i#2@@8| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@8|) (INTERNAL_lt_boogie |i#2@@8| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@8|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@8|) (INTERNAL_lt_boogie |i#2@@8| (|Seq#Length| (Lit |s#0@@150|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@8|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@8|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |5814|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@8|)))
))) (forall ((|key#1@@9| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |key#1@@9|) (INTERNAL_lt_boogie |key#1@@9| 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) ($Box (int_2_U |key#1@@9|)))) (exists ((|i#3@@2| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@2|) (INTERNAL_lt_boogie |i#3@@2| (|Seq#Length| (Lit |s#0@@150|)))) (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@2|))))) |key#1@@9|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@2|))) (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) ($Box (int_2_U |key#1@@9|)))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |5815|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#3@@2|)))
))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |5816|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@127|) ($Box (int_2_U |key#1@@9|))))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@127|) ($Box (int_2_U |key#1@@9|))))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |5821|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@426) (Lit |s#0@@150|) (Lit |m#0@@127|)))
))))
(assert (forall (($ly@@427 T@U) (|s#0@@151| T@U) ) (!  (=> (and (= (type $ly@@427) LayerTypeType) (= (type |s#0@@151|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimum ($LS $ly@@427) |s#0@@151|) (Byte__Order.__default.minimum $ly@@427 |s#0@@151|)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |5822|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@427) |s#0@@151|))
)))
(assert (forall (($ly@@428 T@U) (|s#0@@152| T@U) ) (!  (=> (and (= (type $ly@@428) LayerTypeType) (= (type |s#0@@152|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimum $ly@@428 |s#0@@152|) (Byte__Order.__default.minimum $LZ |s#0@@152|)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |5823|
 :pattern ( (Byte__Order.__default.minimum (AsFuelBottom $ly@@428) |s#0@@152|))
)))
(assert  (=> true (forall (($ly@@429 T@U) (|s#0@@153| T@U) ) (!  (=> (and (and (= (type $ly@@429) LayerTypeType) (= (type |s#0@@153|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| |s#0@@153|) (and ($Is |s#0@@153| (TSet Tclass.NativeTypes.byte)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@153|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@153| ($Box (int_2_U (Byte__Order.__default.minimum $ly@@429 |s#0@@153|))))) (forall ((|y#0@@3| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@3|) (INTERNAL_lt_boogie |y#0@@3| 256)) (U_2_bool (MapType0Select |s#0@@153| ($Box (int_2_U |y#0@@3|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (Byte__Order.__default.minimum $ly@@429 |s#0@@153|) |y#0@@3|))
 :qid |totalorderidfyByteOrder.876:18|
 :skolemid |5824|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (Byte__Order.__default.minimum $ly@@429 |s#0@@153|) |y#0@@3|))
 :pattern ( (MapType0Select |s#0@@153| ($Box (int_2_U |y#0@@3|))))
))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.minimum $ly@@429 |s#0@@153|)) (INTERNAL_lt_boogie (Byte__Order.__default.minimum $ly@@429 |s#0@@153|) 256))))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |5825|
 :pattern ( (Byte__Order.__default.minimum $ly@@429 |s#0@@153|))
))))
(assert (forall (($ly@@430 T@U) ($Heap@@59 T@U) (|s#0@@154| T@U) ) (!  (=> (and (and (and (= (type $ly@@430) LayerTypeType) (= (type $Heap@@59) (MapType0Type refType MapType1Type))) (= (type |s#0@@154|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@59) ($Is |s#0@@154| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.minimum#requires| $ly@@430 |s#0@@154|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@154|) 1)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |5826|
 :pattern ( (|Byte__Order.__default.minimum#requires| $ly@@430 |s#0@@154|) ($IsGoodHeap $Heap@@59))
)))
(assert (forall ((s@@51 T@U) ) (!  (=> (and (= (type s@@51) (MapType0Type BoxType boolType)) (|$let#19$canCall| s@@51)) (and (and (INTERNAL_le_boogie 0 (|$let#19_a| s@@51)) (INTERNAL_lt_boogie (|$let#19_a| s@@51) 256)) (U_2_bool (MapType0Select s@@51 ($Box (int_2_U (|$let#19_a| s@@51)))))))
 :qid |totalorderidfyByteOrder.881:5|
 :skolemid |5827|
 :pattern ( (|$let#19_a| s@@51))
)))
(assert  (=> true (forall (($ly@@431 T@U) ($Heap@@60 T@U) (|s#0@@155| T@U) ) (!  (=> (and (and (and (= (type $ly@@431) LayerTypeType) (= (type $Heap@@60) (MapType0Type refType MapType1Type))) (= (type |s#0@@155|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| |s#0@@155|) (and (and ($IsGoodHeap $Heap@@60) ($Is |s#0@@155| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@155|) 1)))) (and (and (|$let#19$canCall| |s#0@@155|) (let ((|s'#1| (|Set#Difference| |s#0@@155| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#19_a| |s#0@@155|)))))))
 (=> (not (|Set#Equal| |s'#1| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.minimum#canCall| |s'#1|) (let ((|m'#1@@1| (Byte__Order.__default.minimum $ly@@431 |s'#1|)))
(|Byte__Order.__default.lt#canCall| (|$let#19_a| |s#0@@155|) |m'#1@@1|)))))) (= (Byte__Order.__default.minimum ($LS $ly@@431) |s#0@@155|) (let ((|a#0@@129| (|$let#19_a| |s#0@@155|)))
(let ((|s'#0| (|Set#Difference| |s#0@@155| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#0@@129|))))))
(ite (|Set#Equal| |s'#0| (|Set#Empty| BoxType)) |a#0@@129| (let ((|m'#0@@10| (Byte__Order.__default.minimum $ly@@431 |s'#0|)))
(ite (Byte__Order.__default.lt |a#0@@129| |m'#0@@10|) |a#0@@129| |m'#0@@10|))))))))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |5828|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@431) |s#0@@155|) ($IsGoodHeap $Heap@@60))
))))
(assert  (=> true (forall (($ly@@432 T@U) ($Heap@@61 T@U) (|s#0@@156| T@U) ) (!  (=> (and (and (and (= (type $ly@@432) LayerTypeType) (= (type $Heap@@61) (MapType0Type refType MapType1Type))) (= (type |s#0@@156|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| (Lit |s#0@@156|)) (and (and ($IsGoodHeap $Heap@@61) ($Is |s#0@@156| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@156|)) 1)))) (and (and (|$let#19$canCall| (Lit |s#0@@156|)) (let ((|s'#3| (|Set#Difference| |s#0@@156| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#19_a| (Lit |s#0@@156|))))))))
 (=> (not (|Set#Equal| |s'#3| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.minimum#canCall| |s'#3|) (let ((|m'#3| (Byte__Order.__default.minimum ($LS $ly@@432) |s'#3|)))
(|Byte__Order.__default.lt#canCall| (|$let#19_a| (Lit |s#0@@156|)) |m'#3|)))))) (= (Byte__Order.__default.minimum ($LS $ly@@432) (Lit |s#0@@156|)) (let ((|a#1@@0| (|$let#19_a| (Lit |s#0@@156|))))
(let ((|s'#2| (|Set#Difference| |s#0@@156| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#1@@0|))))))
(ite (|Set#Equal| |s'#2| (|Set#Empty| BoxType)) |a#1@@0| (let ((|m'#2@@0| (Byte__Order.__default.minimum ($LS $ly@@432) |s'#2|)))
(ite (Byte__Order.__default.lt |a#1@@0| |m'#2@@0|) |a#1@@0| |m'#2@@0|))))))))
 :qid |totalorderidfyByteOrder.873:22|
 :weight 3
 :skolemid |5829|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@432) (Lit |s#0@@156|)) ($IsGoodHeap $Heap@@61))
))))
(assert (forall ((arg0@@601 T@U) (arg1@@302 T@U) ) (! (= (type (Byte__Order.__default.minimumOpt arg0@@601 arg1@@302)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.minimumOpt|
 :pattern ( (Byte__Order.__default.minimumOpt arg0@@601 arg1@@302))
)))
(assert (forall (($ly@@433 T@U) (|s#0@@157| T@U) ) (!  (=> (and (= (type $ly@@433) LayerTypeType) (= (type |s#0@@157|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimumOpt ($LS $ly@@433) |s#0@@157|) (Byte__Order.__default.minimumOpt $ly@@433 |s#0@@157|)))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |5830|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@433) |s#0@@157|))
)))
(assert (forall (($ly@@434 T@U) (|s#0@@158| T@U) ) (!  (=> (and (= (type $ly@@434) LayerTypeType) (= (type |s#0@@158|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimumOpt $ly@@434 |s#0@@158|) (Byte__Order.__default.minimumOpt $LZ |s#0@@158|)))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |5831|
 :pattern ( (Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@434) |s#0@@158|))
)))
(assert  (=> true (forall (($ly@@435 T@U) (|s#0@@159| T@U) ) (!  (=> (and (and (= (type $ly@@435) LayerTypeType) (= (type |s#0@@159|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| |s#0@@159|) ($Is |s#0@@159| (TSet Tclass.NativeTypes.byte)))) (and (and (and (=> (Options.Option.Some_q (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|)) (U_2_bool (MapType0Select |s#0@@159| (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|))))) (=> (Options.Option.Some_q (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|)) (forall ((|y#0@@4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@4|) (INTERNAL_lt_boogie |y#0@@4| 256)) (U_2_bool (MapType0Select |s#0@@159| ($Box (int_2_U |y#0@@4|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|)))) |y#0@@4|))
 :qid |totalorderidfyByteOrder.899:30|
 :skolemid |5832|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|)))) |y#0@@4|))
 :pattern ( (MapType0Select |s#0@@159| ($Box (int_2_U |y#0@@4|))))
)))) (=> (Options.Option.None_q (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|)) (|Set#Equal| |s#0@@159| (|Set#Empty| BoxType)))) ($Is (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|) (Tclass.Options.Option Tclass.NativeTypes.byte))))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |5833|
 :pattern ( (Byte__Order.__default.minimumOpt $ly@@435 |s#0@@159|))
))))
(assert (forall (($ly@@436 T@U) (|s#0@@160| T@U) ) (!  (=> (and (and (= (type $ly@@436) LayerTypeType) (= (type |s#0@@160|) (MapType0Type BoxType boolType))) ($Is |s#0@@160| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.minimumOpt#requires| $ly@@436 |s#0@@160|) true))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |5834|
 :pattern ( (|Byte__Order.__default.minimumOpt#requires| $ly@@436 |s#0@@160|))
)))
(assert (= (type StartFuel_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@437 T@U) (|s#0@@161| T@U) ) (!  (=> (and (and (= (type $ly@@437) LayerTypeType) (= (type |s#0@@161|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| |s#0@@161|) ($Is |s#0@@161| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@161| (|Set#Empty| BoxType))) (|Byte__Order.__default.minimum#canCall| |s#0@@161|)) (= (Byte__Order.__default.minimumOpt ($LS $ly@@437) |s#0@@161|) (ite (|Set#Equal| |s#0@@161| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.minimum StartFuel_Byte_Order._default.minimum |s#0@@161|))))))))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |5835|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@437) |s#0@@161|))
))))
(assert  (=> true (forall (($ly@@438 T@U) (|s#0@@162| T@U) ) (!  (=> (and (and (= (type $ly@@438) LayerTypeType) (= (type |s#0@@162|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@162|)) ($Is |s#0@@162| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@162| (|Set#Empty| BoxType))) (|Byte__Order.__default.minimum#canCall| (Lit |s#0@@162|))) (= (Byte__Order.__default.minimumOpt ($LS $ly@@438) (Lit |s#0@@162|)) (ite (|Set#Equal| |s#0@@162| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.minimum StartFuel_Byte_Order._default.minimum (Lit |s#0@@162|)))))))))
 :qid |totalorderidfyByteOrder.897:22|
 :weight 3
 :skolemid |5836|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@438) (Lit |s#0@@162|)))
))))
(assert (forall (($ly@@439 T@U) (|s#0@@163| T@U) ) (!  (=> (and (= (type $ly@@439) LayerTypeType) (= (type |s#0@@163|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximum ($LS $ly@@439) |s#0@@163|) (Byte__Order.__default.maximum $ly@@439 |s#0@@163|)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |5837|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@439) |s#0@@163|))
)))
(assert (forall (($ly@@440 T@U) (|s#0@@164| T@U) ) (!  (=> (and (= (type $ly@@440) LayerTypeType) (= (type |s#0@@164|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximum $ly@@440 |s#0@@164|) (Byte__Order.__default.maximum $LZ |s#0@@164|)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |5838|
 :pattern ( (Byte__Order.__default.maximum (AsFuelBottom $ly@@440) |s#0@@164|))
)))
(assert  (=> true (forall (($ly@@441 T@U) (|s#0@@165| T@U) ) (!  (=> (and (and (= (type $ly@@441) LayerTypeType) (= (type |s#0@@165|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| |s#0@@165|) (and ($Is |s#0@@165| (TSet Tclass.NativeTypes.byte)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@165|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@165| ($Box (int_2_U (Byte__Order.__default.maximum $ly@@441 |s#0@@165|))))) (forall ((|y#0@@5| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@5|) (INTERNAL_lt_boogie |y#0@@5| 256)) (U_2_bool (MapType0Select |s#0@@165| ($Box (int_2_U |y#0@@5|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@5| (Byte__Order.__default.maximum $ly@@441 |s#0@@165|)))
 :qid |totalorderidfyByteOrder.908:18|
 :skolemid |5839|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@5| (Byte__Order.__default.maximum $ly@@441 |s#0@@165|)))
 :pattern ( (MapType0Select |s#0@@165| ($Box (int_2_U |y#0@@5|))))
))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.maximum $ly@@441 |s#0@@165|)) (INTERNAL_lt_boogie (Byte__Order.__default.maximum $ly@@441 |s#0@@165|) 256))))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |5840|
 :pattern ( (Byte__Order.__default.maximum $ly@@441 |s#0@@165|))
))))
(assert (forall (($ly@@442 T@U) ($Heap@@62 T@U) (|s#0@@166| T@U) ) (!  (=> (and (and (and (= (type $ly@@442) LayerTypeType) (= (type $Heap@@62) (MapType0Type refType MapType1Type))) (= (type |s#0@@166|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@62) ($Is |s#0@@166| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.maximum#requires| $ly@@442 |s#0@@166|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@166|) 1)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |5841|
 :pattern ( (|Byte__Order.__default.maximum#requires| $ly@@442 |s#0@@166|) ($IsGoodHeap $Heap@@62))
)))
(assert (forall ((s@@52 T@U) ) (!  (=> (and (= (type s@@52) (MapType0Type BoxType boolType)) (|$let#22$canCall| s@@52)) (and (and (INTERNAL_le_boogie 0 (|$let#22_a| s@@52)) (INTERNAL_lt_boogie (|$let#22_a| s@@52) 256)) (U_2_bool (MapType0Select s@@52 ($Box (int_2_U (|$let#22_a| s@@52)))))))
 :qid |totalorderidfyByteOrder.911:5|
 :skolemid |5842|
 :pattern ( (|$let#22_a| s@@52))
)))
(assert  (=> true (forall (($ly@@443 T@U) ($Heap@@63 T@U) (|s#0@@167| T@U) ) (!  (=> (and (and (and (= (type $ly@@443) LayerTypeType) (= (type $Heap@@63) (MapType0Type refType MapType1Type))) (= (type |s#0@@167|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| |s#0@@167|) (and (and ($IsGoodHeap $Heap@@63) ($Is |s#0@@167| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@167|) 1)))) (and (and (|$let#22$canCall| |s#0@@167|) (let ((|s'#1@@0| (|Set#Difference| |s#0@@167| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#22_a| |s#0@@167|)))))))
 (=> (not (|Set#Equal| |s'#1@@0| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.maximum#canCall| |s'#1@@0|) (let ((|m'#1@@2| (Byte__Order.__default.maximum $ly@@443 |s'#1@@0|)))
(|Byte__Order.__default.lt#canCall| |m'#1@@2| (|$let#22_a| |s#0@@167|))))))) (= (Byte__Order.__default.maximum ($LS $ly@@443) |s#0@@167|) (let ((|a#0@@130| (|$let#22_a| |s#0@@167|)))
(let ((|s'#0@@0| (|Set#Difference| |s#0@@167| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#0@@130|))))))
(ite (|Set#Equal| |s'#0@@0| (|Set#Empty| BoxType)) |a#0@@130| (let ((|m'#0@@11| (Byte__Order.__default.maximum $ly@@443 |s'#0@@0|)))
(ite (Byte__Order.__default.lt |m'#0@@11| |a#0@@130|) |a#0@@130| |m'#0@@11|))))))))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |5843|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@443) |s#0@@167|) ($IsGoodHeap $Heap@@63))
))))
(assert  (=> true (forall (($ly@@444 T@U) ($Heap@@64 T@U) (|s#0@@168| T@U) ) (!  (=> (and (and (and (= (type $ly@@444) LayerTypeType) (= (type $Heap@@64) (MapType0Type refType MapType1Type))) (= (type |s#0@@168|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| (Lit |s#0@@168|)) (and (and ($IsGoodHeap $Heap@@64) ($Is |s#0@@168| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@168|)) 1)))) (and (and (|$let#22$canCall| (Lit |s#0@@168|)) (let ((|s'#3@@0| (|Set#Difference| |s#0@@168| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#22_a| (Lit |s#0@@168|))))))))
 (=> (not (|Set#Equal| |s'#3@@0| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.maximum#canCall| |s'#3@@0|) (let ((|m'#3@@0| (Byte__Order.__default.maximum ($LS $ly@@444) |s'#3@@0|)))
(|Byte__Order.__default.lt#canCall| |m'#3@@0| (|$let#22_a| (Lit |s#0@@168|)))))))) (= (Byte__Order.__default.maximum ($LS $ly@@444) (Lit |s#0@@168|)) (let ((|a#1@@1| (|$let#22_a| (Lit |s#0@@168|))))
(let ((|s'#2@@0| (|Set#Difference| |s#0@@168| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#1@@1|))))))
(ite (|Set#Equal| |s'#2@@0| (|Set#Empty| BoxType)) |a#1@@1| (let ((|m'#2@@1| (Byte__Order.__default.maximum ($LS $ly@@444) |s'#2@@0|)))
(ite (Byte__Order.__default.lt |m'#2@@1| |a#1@@1|) |a#1@@1| |m'#2@@1|))))))))
 :qid |totalorderidfyByteOrder.905:22|
 :weight 3
 :skolemid |5844|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@444) (Lit |s#0@@168|)) ($IsGoodHeap $Heap@@64))
))))
(assert (forall ((arg0@@602 T@U) (arg1@@303 T@U) ) (! (= (type (Byte__Order.__default.maximumOpt arg0@@602 arg1@@303)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.maximumOpt|
 :pattern ( (Byte__Order.__default.maximumOpt arg0@@602 arg1@@303))
)))
(assert (forall (($ly@@445 T@U) (|s#0@@169| T@U) ) (!  (=> (and (= (type $ly@@445) LayerTypeType) (= (type |s#0@@169|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximumOpt ($LS $ly@@445) |s#0@@169|) (Byte__Order.__default.maximumOpt $ly@@445 |s#0@@169|)))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |5845|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@445) |s#0@@169|))
)))
(assert (forall (($ly@@446 T@U) (|s#0@@170| T@U) ) (!  (=> (and (= (type $ly@@446) LayerTypeType) (= (type |s#0@@170|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximumOpt $ly@@446 |s#0@@170|) (Byte__Order.__default.maximumOpt $LZ |s#0@@170|)))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |5846|
 :pattern ( (Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@446) |s#0@@170|))
)))
(assert  (=> true (forall (($ly@@447 T@U) (|s#0@@171| T@U) ) (!  (=> (and (and (= (type $ly@@447) LayerTypeType) (= (type |s#0@@171|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| |s#0@@171|) ($Is |s#0@@171| (TSet Tclass.NativeTypes.byte)))) (and (and (and (=> (Options.Option.Some_q (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|)) (U_2_bool (MapType0Select |s#0@@171| (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|))))) (=> (Options.Option.Some_q (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|)) (forall ((|y#0@@6| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@6|) (INTERNAL_lt_boogie |y#0@@6| 256)) (U_2_bool (MapType0Select |s#0@@171| ($Box (int_2_U |y#0@@6|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@6| (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|))))))
 :qid |totalorderidfyByteOrder.929:30|
 :skolemid |5847|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@6| (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|))))))
 :pattern ( (MapType0Select |s#0@@171| ($Box (int_2_U |y#0@@6|))))
)))) (=> (Options.Option.None_q (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|)) (|Set#Equal| |s#0@@171| (|Set#Empty| BoxType)))) ($Is (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|) (Tclass.Options.Option Tclass.NativeTypes.byte))))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |5848|
 :pattern ( (Byte__Order.__default.maximumOpt $ly@@447 |s#0@@171|))
))))
(assert (forall (($ly@@448 T@U) (|s#0@@172| T@U) ) (!  (=> (and (and (= (type $ly@@448) LayerTypeType) (= (type |s#0@@172|) (MapType0Type BoxType boolType))) ($Is |s#0@@172| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.maximumOpt#requires| $ly@@448 |s#0@@172|) true))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |5849|
 :pattern ( (|Byte__Order.__default.maximumOpt#requires| $ly@@448 |s#0@@172|))
)))
(assert (= (type StartFuel_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@449 T@U) (|s#0@@173| T@U) ) (!  (=> (and (and (= (type $ly@@449) LayerTypeType) (= (type |s#0@@173|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| |s#0@@173|) ($Is |s#0@@173| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@173| (|Set#Empty| BoxType))) (|Byte__Order.__default.maximum#canCall| |s#0@@173|)) (= (Byte__Order.__default.maximumOpt ($LS $ly@@449) |s#0@@173|) (ite (|Set#Equal| |s#0@@173| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.maximum StartFuel_Byte_Order._default.maximum |s#0@@173|))))))))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |5850|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@449) |s#0@@173|))
))))
(assert  (=> true (forall (($ly@@450 T@U) (|s#0@@174| T@U) ) (!  (=> (and (and (= (type $ly@@450) LayerTypeType) (= (type |s#0@@174|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@174|)) ($Is |s#0@@174| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@174| (|Set#Empty| BoxType))) (|Byte__Order.__default.maximum#canCall| (Lit |s#0@@174|))) (= (Byte__Order.__default.maximumOpt ($LS $ly@@450) (Lit |s#0@@174|)) (ite (|Set#Equal| |s#0@@174| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.maximum StartFuel_Byte_Order._default.maximum (Lit |s#0@@174|)))))))))
 :qid |totalorderidfyByteOrder.927:22|
 :weight 3
 :skolemid |5851|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@450) (Lit |s#0@@174|)))
))))
(assert  (=> true (forall ((|a#0@@131| Int) (|b#0@@83| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| |a#0@@131| |b#0@@83|) (and (and (INTERNAL_le_boogie 0 |a#0@@131|) (INTERNAL_lt_boogie |a#0@@131| 256)) (and (INTERNAL_le_boogie 0 |b#0@@83|) (INTERNAL_lt_boogie |b#0@@83| 256)))) true)
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |5852|
 :pattern ( (Byte__Order.__default.lt |a#0@@131| |b#0@@83|))
))))
(assert (forall ((|a#0@@132| Int) (|b#0@@84| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@132|) (INTERNAL_lt_boogie |a#0@@132| 256)) (and (INTERNAL_le_boogie 0 |b#0@@84|) (INTERNAL_lt_boogie |b#0@@84| 256))) (= (|Byte__Order.__default.lt#requires| |a#0@@132| |b#0@@84|) true))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |5853|
 :pattern ( (|Byte__Order.__default.lt#requires| |a#0@@132| |b#0@@84|))
)))
(assert  (=> true (forall ((|a#0@@133| Int) (|b#0@@85| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| |a#0@@133| |b#0@@85|) (and (and (INTERNAL_le_boogie 0 |a#0@@133|) (INTERNAL_lt_boogie |a#0@@133| 256)) (and (INTERNAL_le_boogie 0 |b#0@@85|) (INTERNAL_lt_boogie |b#0@@85| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@133| |b#0@@85|) (= (Byte__Order.__default.lt |a#0@@133| |b#0@@85|)  (and (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@133| |b#0@@85|) (not (= |a#0@@133| |b#0@@85|))))))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |5854|
 :pattern ( (Byte__Order.__default.lt |a#0@@133| |b#0@@85|))
))))
(assert  (=> true (forall ((|a#0@@134| Int) (|b#0@@86| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (and (and (INTERNAL_le_boogie 0 |a#0@@134|) (INTERNAL_lt_boogie |a#0@@134| 256)) (and (INTERNAL_le_boogie 0 |b#0@@86|) (INTERNAL_lt_boogie |b#0@@86| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (= (Byte__Order.__default.lt (LitInt |a#0@@134|) (LitInt |b#0@@86|))  (and (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (not (= |a#0@@134| |b#0@@86|))))))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :weight 3
 :skolemid |5855|
 :pattern ( (Byte__Order.__default.lt (LitInt |a#0@@134|) (LitInt |b#0@@86|)))
))))
(assert  (=> true (forall ((|a#0@@135| Int) (|b#0@@87| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| |a#0@@135| |b#0@@87|) (and (and (INTERNAL_le_boogie 0 |a#0@@135|) (INTERNAL_lt_boogie |a#0@@135| 256)) (and (INTERNAL_le_boogie 0 |b#0@@87|) (INTERNAL_lt_boogie |b#0@@87| 256)))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.Min |a#0@@135| |b#0@@87|)) (INTERNAL_lt_boogie (Byte__Order.__default.Min |a#0@@135| |b#0@@87|) 256)))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |5856|
 :pattern ( (Byte__Order.__default.Min |a#0@@135| |b#0@@87|))
))))
(assert (forall ((|a#0@@136| Int) (|b#0@@88| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@136|) (INTERNAL_lt_boogie |a#0@@136| 256)) (and (INTERNAL_le_boogie 0 |b#0@@88|) (INTERNAL_lt_boogie |b#0@@88| 256))) (= (|Byte__Order.__default.Min#requires| |a#0@@136| |b#0@@88|) true))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |5857|
 :pattern ( (|Byte__Order.__default.Min#requires| |a#0@@136| |b#0@@88|))
)))
(assert  (=> true (forall ((|a#0@@137| Int) (|b#0@@89| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| |a#0@@137| |b#0@@89|) (and (and (INTERNAL_le_boogie 0 |a#0@@137|) (INTERNAL_lt_boogie |a#0@@137| 256)) (and (INTERNAL_le_boogie 0 |b#0@@89|) (INTERNAL_lt_boogie |b#0@@89| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@137| |b#0@@89|) (= (Byte__Order.__default.Min |a#0@@137| |b#0@@89|) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@137| |b#0@@89|) |a#0@@137| |b#0@@89|))))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |5858|
 :pattern ( (Byte__Order.__default.Min |a#0@@137| |b#0@@89|))
))))
(assert  (=> true (forall ((|a#0@@138| Int) (|b#0@@90| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (and (and (INTERNAL_le_boogie 0 |a#0@@138|) (INTERNAL_lt_boogie |a#0@@138| 256)) (and (INTERNAL_le_boogie 0 |b#0@@90|) (INTERNAL_lt_boogie |b#0@@90| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (= (Byte__Order.__default.Min (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@138|) (LitInt |b#0@@90|)) |a#0@@138| |b#0@@90|))))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :weight 3
 :skolemid |5859|
 :pattern ( (Byte__Order.__default.Min (LitInt |a#0@@138|) (LitInt |b#0@@90|)))
))))
(assert  (=> true (forall ((|a#0@@139| Int) (|b#0@@91| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| |a#0@@139| |b#0@@91|) (and (and (INTERNAL_le_boogie 0 |a#0@@139|) (INTERNAL_lt_boogie |a#0@@139| 256)) (and (INTERNAL_le_boogie 0 |b#0@@91|) (INTERNAL_lt_boogie |b#0@@91| 256)))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.Max |a#0@@139| |b#0@@91|)) (INTERNAL_lt_boogie (Byte__Order.__default.Max |a#0@@139| |b#0@@91|) 256)))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |5860|
 :pattern ( (Byte__Order.__default.Max |a#0@@139| |b#0@@91|))
))))
(assert (forall ((|a#0@@140| Int) (|b#0@@92| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@140|) (INTERNAL_lt_boogie |a#0@@140| 256)) (and (INTERNAL_le_boogie 0 |b#0@@92|) (INTERNAL_lt_boogie |b#0@@92| 256))) (= (|Byte__Order.__default.Max#requires| |a#0@@140| |b#0@@92|) true))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |5861|
 :pattern ( (|Byte__Order.__default.Max#requires| |a#0@@140| |b#0@@92|))
)))
(assert  (=> true (forall ((|a#0@@141| Int) (|b#0@@93| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| |a#0@@141| |b#0@@93|) (and (and (INTERNAL_le_boogie 0 |a#0@@141|) (INTERNAL_lt_boogie |a#0@@141| 256)) (and (INTERNAL_le_boogie 0 |b#0@@93|) (INTERNAL_lt_boogie |b#0@@93| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@141| |b#0@@93|) (= (Byte__Order.__default.Max |a#0@@141| |b#0@@93|) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@141| |b#0@@93|) |b#0@@93| |a#0@@141|))))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |5862|
 :pattern ( (Byte__Order.__default.Max |a#0@@141| |b#0@@93|))
))))
(assert  (=> true (forall ((|a#0@@142| Int) (|b#0@@94| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (and (and (INTERNAL_le_boogie 0 |a#0@@142|) (INTERNAL_lt_boogie |a#0@@142| 256)) (and (INTERNAL_le_boogie 0 |b#0@@94|) (INTERNAL_lt_boogie |b#0@@94| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (= (Byte__Order.__default.Max (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@142|) (LitInt |b#0@@94|)) |b#0@@94| |a#0@@142|))))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :weight 3
 :skolemid |5863|
 :pattern ( (Byte__Order.__default.Max (LitInt |a#0@@142|) (LitInt |b#0@@94|)))
))))
(assert (forall (($ly@@451 T@U) (|run#0@@113| T@U) ) (!  (=> (and (= (type $ly@@451) LayerTypeType) (= (type |run#0@@113|) (SeqType BoxType))) (= (Byte__Order.__default.IsSorted ($LS $ly@@451) |run#0@@113|) (Byte__Order.__default.IsSorted $ly@@451 |run#0@@113|)))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |5864|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@451) |run#0@@113|))
)))
(assert (forall (($ly@@452 T@U) (|run#0@@114| T@U) ) (!  (=> (and (= (type $ly@@452) LayerTypeType) (= (type |run#0@@114|) (SeqType BoxType))) (= (Byte__Order.__default.IsSorted $ly@@452 |run#0@@114|) (Byte__Order.__default.IsSorted $LZ |run#0@@114|)))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |5865|
 :pattern ( (Byte__Order.__default.IsSorted (AsFuelBottom $ly@@452) |run#0@@114|))
)))
(assert  (=> true (forall (($ly@@453 T@U) (|run#0@@115| T@U) ) (!  (=> (and (and (= (type $ly@@453) LayerTypeType) (= (type |run#0@@115|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| |run#0@@115|) ($Is |run#0@@115| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| |run#0@@115|) (LitInt 0)) (Byte__Order.__default.IsSorted $ly@@453 |run#0@@115|)) (=> (= (|Seq#Length| |run#0@@115|) (LitInt 1)) (Byte__Order.__default.IsSorted $ly@@453 |run#0@@115|))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |5866|
 :pattern ( (Byte__Order.__default.IsSorted $ly@@453 |run#0@@115|))
))))
(assert (forall (($ly@@454 T@U) (|run#0@@116| T@U) ) (!  (=> (and (and (= (type $ly@@454) LayerTypeType) (= (type |run#0@@116|) (SeqType BoxType))) ($Is |run#0@@116| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsSorted#requires| $ly@@454 |run#0@@116|) true))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |5867|
 :pattern ( (|Byte__Order.__default.IsSorted#requires| $ly@@454 |run#0@@116|))
)))
(assert  (=> true (forall (($ly@@455 T@U) (|run#0@@117| T@U) ) (!  (=> (and (and (= (type $ly@@455) LayerTypeType) (= (type |run#0@@117|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| |run#0@@117|) ($Is |run#0@@117| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#0@@112| Int) (|j#0@@14| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@112|) (=> (INTERNAL_le_boogie |i#0@@112| |j#0@@14|) (=> (INTERNAL_lt_boogie |j#0@@14| (|Seq#Length| |run#0@@117|)) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@112|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@14|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |5869|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@14|)) ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@112|)))
)) (= (Byte__Order.__default.IsSorted ($LS $ly@@455) |run#0@@117|) (forall ((|i#0@@113| Int) (|j#0@@15| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@113|) (INTERNAL_le_boogie |i#0@@113| |j#0@@15|)) (INTERNAL_lt_boogie |j#0@@15| (|Seq#Length| |run#0@@117|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@113|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@15|))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |5868|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@15|)) ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@113|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |5870|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@455) |run#0@@117|))
))))
(assert  (=> true (forall (($ly@@456 T@U) (|run#0@@118| T@U) ) (!  (=> (and (and (= (type $ly@@456) LayerTypeType) (= (type |run#0@@118|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@118|)) ($Is |run#0@@118| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#1@@26| Int) (|j#1@@3| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@26|) (=> (INTERNAL_le_boogie |i#1@@26| |j#1@@3|) (=> (INTERNAL_lt_boogie |j#1@@3| (|Seq#Length| (Lit |run#0@@118|))) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |i#1@@26|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |j#1@@3|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |5872|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@118| |j#1@@3|)) ($Unbox intType (|Seq#Index| |run#0@@118| |i#1@@26|)))
)) (= (Byte__Order.__default.IsSorted ($LS $ly@@456) (Lit |run#0@@118|)) (forall ((|i#1@@27| Int) (|j#1@@4| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@27|) (INTERNAL_le_boogie |i#1@@27| |j#1@@4|)) (INTERNAL_lt_boogie |j#1@@4| (|Seq#Length| (Lit |run#0@@118|)))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |i#1@@27|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |j#1@@4|))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |5871|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@118| |j#1@@4|)) ($Unbox intType (|Seq#Index| |run#0@@118| |i#1@@27|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :weight 3
 :skolemid |5873|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@456) (Lit |run#0@@118|)))
))))
(assert  (=> true (forall ((|run#0@@119| T@U) ) (!  (=> (and (= (type |run#0@@119|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@119|) ($Is |run#0@@119| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |5874|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal |run#0@@119|))
))))
(assert (forall ((|run#0@@120| T@U) ) (!  (=> (and (= (type |run#0@@120|) (SeqType BoxType)) ($Is |run#0@@120| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@120|) true))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |5875|
 :pattern ( (|Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@120|))
)))
(assert  (=> true (forall ((|run#0@@121| T@U) ) (!  (=> (and (= (type |run#0@@121|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@121|) ($Is |run#0@@121| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#0@@114| Int) (|j#0@@16| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@114|) (=> (INTERNAL_lt_boogie |i#0@@114| |j#0@@16|) (=> (INTERNAL_lt_boogie |j#0@@16| (|Seq#Length| |run#0@@121|)) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@114|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@16|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |5877|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@16|)) ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@114|)))
)) (= (Byte__Order.__default.IsStrictlySortedInternal |run#0@@121|) (forall ((|i#0@@115| Int) (|j#0@@17| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@115|) (INTERNAL_lt_boogie |i#0@@115| |j#0@@17|)) (INTERNAL_lt_boogie |j#0@@17| (|Seq#Length| |run#0@@121|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@115|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@17|))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |5876|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@17|)) ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@115|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |5878|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal |run#0@@121|))
))))
(assert  (=> true (forall ((|run#0@@122| T@U) ) (!  (=> (and (= (type |run#0@@122|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@122|)) ($Is |run#0@@122| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#1@@28| Int) (|j#1@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@28|) (=> (INTERNAL_lt_boogie |i#1@@28| |j#1@@5|) (=> (INTERNAL_lt_boogie |j#1@@5| (|Seq#Length| (Lit |run#0@@122|))) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |i#1@@28|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |j#1@@5|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |5880|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@122| |j#1@@5|)) ($Unbox intType (|Seq#Index| |run#0@@122| |i#1@@28|)))
)) (= (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@122|)) (forall ((|i#1@@29| Int) (|j#1@@6| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@29|) (INTERNAL_lt_boogie |i#1@@29| |j#1@@6|)) (INTERNAL_lt_boogie |j#1@@6| (|Seq#Length| (Lit |run#0@@122|)))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |i#1@@29|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |j#1@@6|))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |5879|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@122| |j#1@@6|)) ($Unbox intType (|Seq#Index| |run#0@@122| |i#1@@29|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :weight 3
 :skolemid |5881|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@122|)))
))))
(assert (forall (($ly@@457 T@U) (|run#0@@123| T@U) ) (!  (=> (and (= (type $ly@@457) LayerTypeType) (= (type |run#0@@123|) (SeqType BoxType))) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@457) |run#0@@123|) (Byte__Order.__default.IsStrictlySorted $ly@@457 |run#0@@123|)))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |5882|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@457) |run#0@@123|))
)))
(assert (forall (($ly@@458 T@U) (|run#0@@124| T@U) ) (!  (=> (and (= (type $ly@@458) LayerTypeType) (= (type |run#0@@124|) (SeqType BoxType))) (= (Byte__Order.__default.IsStrictlySorted $ly@@458 |run#0@@124|) (Byte__Order.__default.IsStrictlySorted $LZ |run#0@@124|)))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |5883|
 :pattern ( (Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@458) |run#0@@124|))
)))
(assert  (=> true (forall (($ly@@459 T@U) (|run#0@@125| T@U) ) (!  (=> (and (and (= (type $ly@@459) LayerTypeType) (= (type |run#0@@125|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@125|) ($Is |run#0@@125| (TSeq Tclass.NativeTypes.byte)))) (and (and (=> (= (|Seq#Length| |run#0@@125|) (LitInt 0)) (Byte__Order.__default.IsStrictlySorted $ly@@459 |run#0@@125|)) (=> (= (|Seq#Length| |run#0@@125|) (LitInt 1)) (Byte__Order.__default.IsStrictlySorted $ly@@459 |run#0@@125|))) (=> (Byte__Order.__default.IsStrictlySorted $ly@@459 |run#0@@125|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@125|))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |5884|
 :pattern ( (Byte__Order.__default.IsStrictlySorted $ly@@459 |run#0@@125|))
))))
(assert (forall (($ly@@460 T@U) (|run#0@@126| T@U) ) (!  (=> (and (and (= (type $ly@@460) LayerTypeType) (= (type |run#0@@126|) (SeqType BoxType))) ($Is |run#0@@126| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsStrictlySorted#requires| $ly@@460 |run#0@@126|) true))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |5885|
 :pattern ( (|Byte__Order.__default.IsStrictlySorted#requires| $ly@@460 |run#0@@126|))
)))
(assert  (=> true (forall (($ly@@461 T@U) (|run#0@@127| T@U) ) (!  (=> (and (and (= (type $ly@@461) LayerTypeType) (= (type |run#0@@127|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@127|) ($Is |run#0@@127| (TSeq Tclass.NativeTypes.byte)))) (and (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@127|) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@461) |run#0@@127|) (let ((|b#0@@95| (Byte__Order.__default.IsStrictlySortedInternal |run#0@@127|)))
(ite |b#0@@95| |b#0@@95| |b#0@@95|)))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |5886|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@461) |run#0@@127|))
))))
(assert  (=> true (forall (($ly@@462 T@U) (|run#0@@128| T@U) ) (!  (=> (and (and (= (type $ly@@462) LayerTypeType) (= (type |run#0@@128|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@128|)) ($Is |run#0@@128| (TSeq Tclass.NativeTypes.byte)))) (and (|Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@128|)) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@462) (Lit |run#0@@128|)) (let ((|b#1@@2| (U_2_bool (Lit (bool_2_U (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@128|)))))))
(ite |b#1@@2| |b#1@@2| |b#1@@2|)))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :weight 3
 :skolemid |5887|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@462) (Lit |run#0@@128|)))
))))
(assert  (=> true (forall ((|e#0@@5| Int) (|s#0@@175| T@U) ) (!  (=> (and (= (type |s#0@@175|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| |e#0@@5| |s#0@@175|) (and (and (and (INTERNAL_le_boogie 0 |e#0@@5|) (INTERNAL_lt_boogie |e#0@@5| 256)) ($Is |s#0@@175| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@175|))))) true)
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |5888|
 :pattern ( (Byte__Order.__default.BiggestInSet |e#0@@5| |s#0@@175|))
))))
(assert (forall ((|e#0@@6| Int) (|s#0@@176| T@U) ) (!  (=> (= (type |s#0@@176|) (MapType0Type BoxType boolType)) (=> (and (and (INTERNAL_le_boogie 0 |e#0@@6|) (INTERNAL_lt_boogie |e#0@@6| 256)) ($Is |s#0@@176| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.BiggestInSet#requires| |e#0@@6| |s#0@@176|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@176|)))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |5889|
 :pattern ( (|Byte__Order.__default.BiggestInSet#requires| |e#0@@6| |s#0@@176|))
)))
(assert  (=> true (forall ((|e#0@@7| Int) (|s#0@@177| T@U) ) (!  (=> (and (= (type |s#0@@177|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| |e#0@@7| |s#0@@177|) (and (and (and (INTERNAL_le_boogie 0 |e#0@@7|) (INTERNAL_lt_boogie |e#0@@7| 256)) ($Is |s#0@@177| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@177|))))) (and (=> (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e#0@@7|)))) (forall ((|e2#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |e2#0|) (INTERNAL_lt_boogie |e2#0| 256)) (=> (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0|)))) (not (= |e2#0| |e#0@@7|))) (|Byte__Order.__default.lt#canCall| |e2#0| |e#0@@7|)))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |5891|
 :pattern ( (Byte__Order.__default.lt |e2#0| |e#0@@7|))
 :pattern ( (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0|))))
))) (= (Byte__Order.__default.BiggestInSet |e#0@@7| |s#0@@177|)  (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e#0@@7|)))) (forall ((|e2#0@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |e2#0@@0|) (INTERNAL_lt_boogie |e2#0@@0| 256)) (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0@@0|)))) (not (= |e2#0@@0| |e#0@@7|)))) (Byte__Order.__default.lt |e2#0@@0| |e#0@@7|))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |5890|
 :pattern ( (Byte__Order.__default.lt |e2#0@@0| |e#0@@7|))
 :pattern ( (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0@@0|))))
))))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |5892|
 :pattern ( (Byte__Order.__default.BiggestInSet |e#0@@7| |s#0@@177|))
))))
(assert  (=> true (forall ((|e#0@@8| Int) (|s#0@@178| T@U) ) (!  (=> (and (= (type |s#0@@178|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| (LitInt |e#0@@8|) (Lit |s#0@@178|)) (and (and (and (INTERNAL_le_boogie 0 |e#0@@8|) (INTERNAL_lt_boogie |e#0@@8| 256)) ($Is |s#0@@178| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@178|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U (LitInt |e#0@@8|))))) (forall ((|e2#1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |e2#1|) (INTERNAL_lt_boogie |e2#1| 256)) (=> (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U |e2#1|)))) (not (= |e2#1| |e#0@@8|))) (|Byte__Order.__default.lt#canCall| |e2#1| (LitInt |e#0@@8|))))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |5894|
 :pattern ( (Byte__Order.__default.lt |e2#1| |e#0@@8|))
 :pattern ( (MapType0Select |s#0@@178| ($Box (int_2_U |e2#1|))))
))) (= (Byte__Order.__default.BiggestInSet (LitInt |e#0@@8|) (Lit |s#0@@178|))  (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U (LitInt |e#0@@8|))))) (forall ((|e2#1@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |e2#1@@0|) (INTERNAL_lt_boogie |e2#1@@0| 256)) (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U |e2#1@@0|)))) (not (= |e2#1@@0| |e#0@@8|)))) (Byte__Order.__default.lt |e2#1@@0| (LitInt |e#0@@8|)))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |5893|
 :pattern ( (Byte__Order.__default.lt |e2#1@@0| |e#0@@8|))
 :pattern ( (MapType0Select |s#0@@178| ($Box (int_2_U |e2#1@@0|))))
))))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :weight 3
 :skolemid |5895|
 :pattern ( (Byte__Order.__default.BiggestInSet (LitInt |e#0@@8|) (Lit |s#0@@178|)))
))))
(assert (forall ((arg0@@603 T@U) (arg1@@304 T@U) ) (! (= (type (Byte__Order.__default.SortSet arg0@@603 arg1@@304)) (SeqType BoxType))
 :qid |funType:Byte__Order.__default.SortSet|
 :pattern ( (Byte__Order.__default.SortSet arg0@@603 arg1@@304))
)))
(assert (forall (($ly@@463 T@U) (|s#0@@179| T@U) ) (!  (=> (and (= (type $ly@@463) LayerTypeType) (= (type |s#0@@179|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.SortSet ($LS $ly@@463) |s#0@@179|) (Byte__Order.__default.SortSet $ly@@463 |s#0@@179|)))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |5896|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@463) |s#0@@179|))
)))
(assert (forall (($ly@@464 T@U) (|s#0@@180| T@U) ) (!  (=> (and (= (type $ly@@464) LayerTypeType) (= (type |s#0@@180|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.SortSet $ly@@464 |s#0@@180|) (Byte__Order.__default.SortSet $LZ |s#0@@180|)))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |5897|
 :pattern ( (Byte__Order.__default.SortSet (AsFuelBottom $ly@@464) |s#0@@180|))
)))
(assert  (=> true (forall (($ly@@465 T@U) (|s#0@@181| T@U) ) (!  (=> (and (and (= (type $ly@@465) LayerTypeType) (= (type |s#0@@181|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| |s#0@@181|) ($Is |s#0@@181| (TSet Tclass.NativeTypes.byte)))) (and (and (and (= (|Set#Card| |s#0@@181|) (|Seq#Length| (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|))) (forall ((|t#0@@13| T@U) ) (!  (=> (= (type |t#0@@13|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |t#0@@13|)) (INTERNAL_lt_boogie (U_2_int |t#0@@13|) 256)) (= (U_2_bool (MapType0Select |s#0@@181| ($Box |t#0@@13|))) (|Seq#Contains| (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|) ($Box |t#0@@13|)))))
 :qid |totalorderidfyTotalOrderByteOrder.239:20|
 :skolemid |5898|
 :pattern ( (|Seq#Contains| (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|) ($Box |t#0@@13|)))
 :pattern ( (MapType0Select |s#0@@181| ($Box |t#0@@13|)))
))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|))) ($Is (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |5899|
 :pattern ( (Byte__Order.__default.SortSet $ly@@465 |s#0@@181|))
))))
(assert (forall (($ly@@466 T@U) ($Heap@@65 T@U) (|s#0@@182| T@U) ) (!  (=> (and (and (and (= (type $ly@@466) LayerTypeType) (= (type $Heap@@65) (MapType0Type refType MapType1Type))) (= (type |s#0@@182|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@65) ($Is |s#0@@182| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SortSet#requires| $ly@@466 |s#0@@182|) true))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |5900|
 :pattern ( (|Byte__Order.__default.SortSet#requires| $ly@@466 |s#0@@182|) ($IsGoodHeap $Heap@@65))
)))
(assert (forall ((s@@53 T@U) ) (!  (=> (and (= (type s@@53) (MapType0Type BoxType boolType)) (|$let#25$canCall| s@@53)) (and (and (INTERNAL_le_boogie 0 (|$let#25_e| s@@53)) (INTERNAL_lt_boogie (|$let#25_e| s@@53) 256)) (Byte__Order.__default.BiggestInSet (|$let#25_e| s@@53) s@@53)))
 :qid |totalorderidfyTotalOrderByteOrder.249:7|
 :skolemid |5901|
 :pattern ( (|$let#25_e| s@@53))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@467 T@U) ($Heap@@66 T@U) (|s#0@@183| T@U) ) (!  (=> (and (and (and (= (type $ly@@467) LayerTypeType) (= (type $Heap@@66) (MapType0Type refType MapType1Type))) (= (type |s#0@@183|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| |s#0@@183|) (and ($IsGoodHeap $Heap@@66) ($Is |s#0@@183| (TSet Tclass.NativeTypes.byte))))) (and (=> (not (= (|Set#Card| |s#0@@183|) (LitInt 0))) (and (|$let#25$canCall| |s#0@@183|) (|Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@183| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#25_e| |s#0@@183|)))))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted6) MoreFuel_Byte_Order._default.IsSorted6)) (= (Byte__Order.__default.SortSet ($LS $ly@@467) |s#0@@183|) (ite (= (|Set#Card| |s#0@@183|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@9| (|$let#25_e| |s#0@@183|)))
(|Seq#Append| (Byte__Order.__default.SortSet $ly@@467 (|Set#Difference| |s#0@@183| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#0@@9|))))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U |e#0@@9|))))))))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |5902|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@467) |s#0@@183|) ($IsGoodHeap $Heap@@66))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@468 T@U) ($Heap@@67 T@U) (|s#0@@184| T@U) ) (!  (=> (and (and (and (= (type $ly@@468) LayerTypeType) (= (type $Heap@@67) (MapType0Type refType MapType1Type))) (= (type |s#0@@184|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| (Lit |s#0@@184|)) (and ($IsGoodHeap $Heap@@67) ($Is |s#0@@184| (TSet Tclass.NativeTypes.byte))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@184|)) (LitInt 0))) (and (|$let#25$canCall| (Lit |s#0@@184|)) (|Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@184| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#25_e| (Lit |s#0@@184|))))))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted7) MoreFuel_Byte_Order._default.IsSorted7)) (= (Byte__Order.__default.SortSet ($LS $ly@@468) (Lit |s#0@@184|)) (ite (= (|Set#Card| (Lit |s#0@@184|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@0| (|$let#25_e| (Lit |s#0@@184|))))
(|Seq#Append| (Byte__Order.__default.SortSet ($LS $ly@@468) (|Set#Difference| |s#0@@184| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#1@@0|))))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U |e#1@@0|))))))))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :weight 3
 :skolemid |5903|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@468) (Lit |s#0@@184|)) ($IsGoodHeap $Heap@@67))
))))
(assert (= (type Tclass.Lexicographic__Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Lexicographic__Byte__Order.__default) Tagclass.Lexicographic__Byte__Order.__default))
(assert (= (TagFamily Tclass.Lexicographic__Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@174 T@U) ) (!  (=> (and (= (type bx@@174) BoxType) ($IsBox bx@@174 Tclass.Lexicographic__Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@174)) bx@@174) ($Is ($Unbox refType bx@@174) Tclass.Lexicographic__Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |5904|
 :pattern ( ($IsBox bx@@174 Tclass.Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@59 T@U) ) (!  (=> (= (type $o@@59) refType) (= ($Is $o@@59 Tclass.Lexicographic__Byte__Order.__default)  (or (= $o@@59 null) (= (dtype $o@@59) Tclass.Lexicographic__Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |5905|
 :pattern ( ($Is $o@@59 Tclass.Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@60 T@U) ($h@@114 T@U) ) (!  (=> (and (= (type $o@@60) refType) (= (type $h@@114) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@60 Tclass.Lexicographic__Byte__Order.__default $h@@114)  (or (= $o@@60 null) (U_2_bool (MapType1Select (MapType0Select $h@@114 $o@@60) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5906|
 :pattern ( ($IsAlloc $o@@60 Tclass.Lexicographic__Byte__Order.__default $h@@114))
)))
(assert (= (type Lexicographic__Byte__Order.__default.SomeElement) (SeqType BoxType)))
(assert  (=> true (=> true ($Is Lexicographic__Byte__Order.__default.SomeElement (TSeq Tclass.NativeTypes.byte)))))
(assert (= |Lexicographic__Byte__Order.__default.SomeElement#requires| true))
(assert  (=> true (=> true (= Lexicographic__Byte__Order.__default.SomeElement (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (=> true (= Lexicographic__Byte__Order.__default.SomeElement (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (forall ((|a#0@@143| T@U) (|b#0@@96| T@U) ) (!  (=> (and (and (= (type |a#0@@143|) (SeqType BoxType)) (= (type |b#0@@96|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@143| |b#0@@96|) (and ($Is |a#0@@143| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@96| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (and (= (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|)) (or (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|))) (= (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|))) (or (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|))) (=> (and (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|)) (|Seq#Equal| |a#0@@143| |b#0@@96|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |5907|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|))
))))
(assert (forall ((|a#0@@144| T@U) (|b#0@@97| T@U) ) (!  (=> (and (and (= (type |a#0@@144|) (SeqType BoxType)) (= (type |b#0@@97|) (SeqType BoxType))) (and ($Is |a#0@@144| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@97| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.lte#requires| |a#0@@144| |b#0@@97|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |5908|
 :pattern ( (|Lexicographic__Byte__Order.__default.lte#requires| |a#0@@144| |b#0@@97|))
)))
(assert  (=> true (forall ((|a#0@@145| T@U) (|b#0@@98| T@U) ) (!  (=> (and (and (= (type |a#0@@145|) (SeqType BoxType)) (= (type |b#0@@98|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@145| |b#0@@98|) (and ($Is |a#0@@145| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@98| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@145| |b#0@@98|) (= (Lexicographic__Byte__Order.__default.lte |a#0@@145| |b#0@@98|) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@145| |b#0@@98|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |5909|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |a#0@@145| |b#0@@98|))
))))
(assert  (=> true (forall ((|a#0@@146| T@U) (|b#0@@99| T@U) ) (!  (=> (and (and (= (type |a#0@@146|) (SeqType BoxType)) (= (type |b#0@@99|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@146|) (Lit |b#0@@99|)) (and ($Is |a#0@@146| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@99| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@146|) (Lit |b#0@@99|)) (= (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :weight 3
 :skolemid |5910|
 :pattern ( (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)))
))))
(assert  (=> true (forall ((|a#0@@147| T@U) (|b#0@@100| T@U) ) (!  (=> (and (and (= (type |a#0@@147|) (SeqType BoxType)) (= (type |b#0@@100|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@147| |b#0@@100|) (and ($Is |a#0@@147| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@100| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |5911|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef |a#0@@147| |b#0@@100|))
))))
(assert (forall ((|a#0@@148| T@U) (|b#0@@101| T@U) ) (!  (=> (and (and (= (type |a#0@@148|) (SeqType BoxType)) (= (type |b#0@@101|) (SeqType BoxType))) (and ($Is |a#0@@148| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@101| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@148| |b#0@@101|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |5912|
 :pattern ( (|Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@148| |b#0@@101|))
)))
(assert  (=> true (forall ((|a#0@@149| T@U) (|b#0@@102| T@U) ) (!  (=> (and (and (= (type |a#0@@149|) (SeqType BoxType)) (= (type |b#0@@102|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@149| |b#0@@102|) (and ($Is |a#0@@149| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@102| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@149| |b#0@@102|) (= (Lexicographic__Byte__Order.__default.ltedef |a#0@@149| |b#0@@102|) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@149| |b#0@@102|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |5913|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef |a#0@@149| |b#0@@102|))
))))
(assert  (=> true (forall ((|a#0@@150| T@U) (|b#0@@103| T@U) ) (!  (=> (and (and (= (type |a#0@@150|) (SeqType BoxType)) (= (type |b#0@@103|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| (Lit |a#0@@150|) (Lit |b#0@@103|)) (and ($Is |a#0@@150| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@103| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@150|) (Lit |b#0@@103|)) (= (Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@150|) (Lit |b#0@@103|)) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@150|) (Lit |b#0@@103|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :weight 3
 :skolemid |5914|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@150|) (Lit |b#0@@103|)))
))))
(assert  (=> true (forall ((|b#0@@104| T@U) ) (!  (=> (and (= (type |b#0@@104|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@104|) ($Is |b#0@@104| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfy.1174:31|
 :skolemid |5915|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@104|))
))))
(assert (forall ((|b#0@@105| T@U) ) (!  (=> (and (= (type |b#0@@105|) (SeqType BoxType)) ($Is |b#0@@105| (TSeq Tclass.NativeTypes.byte))) (= (|Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@105|) true))
 :qid |totalorderidfy.1174:31|
 :skolemid |5916|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@105|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType))
(assert  (=> true (forall ((|b#0@@106| T@U) ) (!  (=> (and (= (type |b#0@@106|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@106|) ($Is |b#0@@106| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| |b#0@@106|) (LitInt 0)) (forall ((|a#0@@151| T@U) ) (!  (=> (and (= (type |a#0@@151|) (SeqType BoxType)) ($Is |a#0@@151| (TSeq Tclass.NativeTypes.byte))) (and (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@151|) (=> (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@151|) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@106| |a#0@@151|))))
 :qid |totalorderidfy.1177:16|
 :skolemid |5918|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@151|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@151|))
))) (= (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@106|)  (and (= (|Seq#Length| |b#0@@106|) (LitInt 0)) (forall ((|a#0@@152| T@U) ) (!  (=> (= (type |a#0@@152|) (SeqType BoxType)) (=> (and ($Is |a#0@@152| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@152|)) (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@152|)))
 :qid |totalorderidfy.1177:16|
 :skolemid |5917|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@152|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@152|))
))))))
 :qid |totalorderidfy.1174:31|
 :skolemid |5919|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@106|))
))))
(assert  (=> true (forall ((|b#0@@107| T@U) ) (!  (=> (and (= (type |b#0@@107|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (Lit |b#0@@107|)) ($Is |b#0@@107| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| (Lit |b#0@@107|)) (LitInt 0)) (forall ((|a#1@@2| T@U) ) (!  (=> (and (= (type |a#1@@2|) (SeqType BoxType)) ($Is |a#1@@2| (TSeq Tclass.NativeTypes.byte))) (and (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#1@@2|) (=> (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@2|) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |b#0@@107|) |a#1@@2|))))
 :qid |totalorderidfy.1177:16|
 :skolemid |5921|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@107| |a#1@@2|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@2|))
))) (= (Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@107|))  (and (= (|Seq#Length| (Lit |b#0@@107|)) (LitInt 0)) (forall ((|a#1@@3| T@U) ) (!  (=> (= (type |a#1@@3|) (SeqType BoxType)) (=> (and ($Is |a#1@@3| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@3|)) (Lexicographic__Byte__Order.__default.lt (Lit |b#0@@107|) |a#1@@3|)))
 :qid |totalorderidfy.1177:16|
 :skolemid |5920|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@107| |a#1@@3|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@3|))
))))))
 :qid |totalorderidfy.1174:31|
 :weight 3
 :skolemid |5922|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@107|)))
))))
(assert (= (type Lexicographic__Byte__Order.__default.GetSmallestElement) (SeqType BoxType)))
(assert  (=> true (=> true (and (Lexicographic__Byte__Order.__default.IsSmallestElement Lexicographic__Byte__Order.__default.GetSmallestElement) ($Is Lexicographic__Byte__Order.__default.GetSmallestElement (TSeq Tclass.NativeTypes.byte))))))
(assert (forall (($Heap@@68 T@U) ) (!  (=> (and (= (type $Heap@@68) (MapType0Type refType MapType1Type)) ($IsGoodHeap $Heap@@68)) (= |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| true))
 :qid |totalorderidfy.1198:12|
 :skolemid |5923|
 :pattern ( |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| ($IsGoodHeap $Heap@@68))
)))
(assert (= (type |$let#28_b|) (SeqType BoxType)))
(assert  (=> |$let#28$canCall| (and ($Is |$let#28_b| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.IsSmallestElement |$let#28_b|))))
(assert  (=> true (forall (($Heap@@69 T@U) ) (!  (=> (and (= (type $Heap@@69) (MapType0Type refType MapType1Type)) (or |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@69))) (and |$let#28$canCall| (= Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#0@@108| |$let#28_b|))
|b#0@@108|))))
 :qid |totalorderidfy.1198:12|
 :skolemid |5924|
 :pattern ( Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@69))
))))
(assert  (=> true (forall (($Heap@@70 T@U) ) (!  (=> (and (= (type $Heap@@70) (MapType0Type refType MapType1Type)) (or |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@70))) (and |$let#28$canCall| (= Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#1@@3| |$let#28_b|))
|b#1@@3|))))
 :qid |totalorderidfy.1198:12|
 :weight 3
 :skolemid |5925|
 :pattern ( Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@70))
))))
(assert (forall (($ly@@469 T@U) (|run#0@@129| T@U) (|needle#0@@41| T@U) ) (!  (=> (and (and (= (type $ly@@469) LayerTypeType) (= (type |run#0@@129|) (SeqType BoxType))) (= (type |needle#0@@41|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@469) |run#0@@129| |needle#0@@41|) (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@469 |run#0@@129| |needle#0@@41|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |5926|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@469) |run#0@@129| |needle#0@@41|))
)))
(assert (forall (($ly@@470 T@U) (|run#0@@130| T@U) (|needle#0@@42| T@U) ) (!  (=> (and (and (= (type $ly@@470) LayerTypeType) (= (type |run#0@@130|) (SeqType BoxType))) (= (type |needle#0@@42|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@470 |run#0@@130| |needle#0@@42|) (Lexicographic__Byte__Order.__default.LargestLteDefn $LZ |run#0@@130| |needle#0@@42|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |5927|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@470) |run#0@@130| |needle#0@@42|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@471 T@U) (|run#0@@131| T@U) (|needle#0@@43| T@U) ) (!  (=> (and (and (and (= (type $ly@@471) LayerTypeType) (= (type |run#0@@131|) (SeqType BoxType))) (= (type |needle#0@@43|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@131| |needle#0@@43|) (and (and ($Is |run#0@@131| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@43| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@131|)))) true)
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |5928|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@471 |run#0@@131| |needle#0@@43|))
))))
(assert (forall (($ly@@472 T@U) (|run#0@@132| T@U) (|needle#0@@44| T@U) ) (!  (=> (and (and (and (= (type $ly@@472) LayerTypeType) (= (type |run#0@@132|) (SeqType BoxType))) (= (type |needle#0@@44|) (SeqType BoxType))) (and ($Is |run#0@@132| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@44| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@472 |run#0@@132| |needle#0@@44|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@132|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |5929|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@472 |run#0@@132| |needle#0@@44|))
)))
(assert  (=> true (forall (($ly@@473 T@U) (|run#0@@133| T@U) (|needle#0@@45| T@U) ) (!  (=> (and (and (and (= (type $ly@@473) LayerTypeType) (= (type |run#0@@133|) (SeqType BoxType))) (= (type |needle#0@@45|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@133| |needle#0@@45|) (and (and ($Is |run#0@@133| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@45| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@133|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@133|) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lt#canCall| |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@133|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@133| (LitInt 1)) |needle#0@@45|))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@473) |run#0@@133| |needle#0@@45|) (ite  (or (= (|Seq#Length| |run#0@@133|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@473 (|Seq#Drop| |run#0@@133| (LitInt 1)) |needle#0@@45|))))))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |5930|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@473) |run#0@@133| |needle#0@@45|))
))))
(assert  (=> true (forall (($ly@@474 T@U) (|run#0@@134| T@U) (|needle#0@@46| T@U) ) (!  (=> (and (and (and (= (type $ly@@474) LayerTypeType) (= (type |run#0@@134|) (SeqType BoxType))) (= (type |needle#0@@46|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@134|) (Lit |needle#0@@46|)) (and (and ($Is |run#0@@134| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@46| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@134|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@134|) (LitInt 1))) (Lit |needle#0@@46|)))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@474) (Lit |run#0@@134|) (Lit |needle#0@@46|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@474) (Lit (|Seq#Drop| (Lit |run#0@@134|) (LitInt 1))) (Lit |needle#0@@46|)))))))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :weight 3
 :skolemid |5931|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@474) (Lit |run#0@@134|) (Lit |needle#0@@46|)))
))))
(assert  (=> true (forall ((|run#0@@135| T@U) (|needle#0@@47| T@U) ) (!  (=> (and (and (= (type |run#0@@135|) (SeqType BoxType)) (= (type |needle#0@@47|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@135| |needle#0@@47|) (and (and ($Is |run#0@@135| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@47| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@135|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|) (|Seq#Length| |run#0@@135|))) (forall ((|i#0@@116| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@116|) (INTERNAL_le_boogie |i#0@@116| (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#0@@116|)) |needle#0@@47|)))
 :qid |totalorderidfyLexicographicByteOrder.362:20|
 :skolemid |5932|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#0@@116|)))
))) (forall ((|i#1@@30| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|) |i#1@@30|) (INTERNAL_lt_boogie |i#1@@30| (|Seq#Length| |run#0@@135|))) (Lexicographic__Byte__Order.__default.lt |needle#0@@47| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#1@@30|)))))
 :qid |totalorderidfyLexicographicByteOrder.363:20|
 :skolemid |5933|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#1@@30|)))
))) (=> (|Seq#Contains| |run#0@@135| ($Box |needle#0@@47|)) (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|)) (|Seq#Equal| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))) |needle#0@@47|)))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |5934|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))
))))
(assert (forall ((|run#0@@136| T@U) (|needle#0@@48| T@U) ) (!  (=> (and (and (= (type |run#0@@136|) (SeqType BoxType)) (= (type |needle#0@@48|) (SeqType BoxType))) (and ($Is |run#0@@136| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@48| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@136| |needle#0@@48|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@136|)))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |5935|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@136| |needle#0@@48|))
)))
(assert  (=> true (forall ((|run#0@@137| T@U) (|needle#0@@49| T@U) ) (!  (=> (and (and (= (type |run#0@@137|) (SeqType BoxType)) (= (type |needle#0@@49|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@137| |needle#0@@49|) (and (and ($Is |run#0@@137| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@49| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@137|)))) (and (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@137| |needle#0@@49|) (= (Lexicographic__Byte__Order.__default.LargestLte |run#0@@137| |needle#0@@49|) (let ((|out#0@@2| (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@137| |needle#0@@49|)))
|out#0@@2|))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |5936|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte |run#0@@137| |needle#0@@49|))
))))
(assert  (=> true (forall ((|run#0@@138| T@U) (|needle#0@@50| T@U) ) (!  (=> (and (and (= (type |run#0@@138|) (SeqType BoxType)) (= (type |needle#0@@50|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@138|) (Lit |needle#0@@50|)) (and (and ($Is |run#0@@138| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@50| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@138|))))) (and (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@138|) (Lit |needle#0@@50|)) (= (Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@138|) (Lit |needle#0@@50|)) (let ((|out#1@@0| (LitInt (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@138|) (Lit |needle#0@@50|)))))
|out#1@@0|))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :weight 3
 :skolemid |5937|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@138|) (Lit |needle#0@@50|)))
))))
(assert (forall (($ly@@475 T@U) (|run#0@@139| T@U) (|needle#0@@51| T@U) ) (!  (=> (and (and (= (type $ly@@475) LayerTypeType) (= (type |run#0@@139|) (SeqType BoxType))) (= (type |needle#0@@51|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@475) |run#0@@139| |needle#0@@51|) (Lexicographic__Byte__Order.__default.LargestLt $ly@@475 |run#0@@139| |needle#0@@51|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |5938|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@475) |run#0@@139| |needle#0@@51|))
)))
(assert (forall (($ly@@476 T@U) (|run#0@@140| T@U) (|needle#0@@52| T@U) ) (!  (=> (and (and (= (type $ly@@476) LayerTypeType) (= (type |run#0@@140|) (SeqType BoxType))) (= (type |needle#0@@52|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLt $ly@@476 |run#0@@140| |needle#0@@52|) (Lexicographic__Byte__Order.__default.LargestLt $LZ |run#0@@140| |needle#0@@52|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |5939|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt (AsFuelBottom $ly@@476) |run#0@@140| |needle#0@@52|))
)))
(assert  (=> true (forall (($ly@@477 T@U) (|run#0@@141| T@U) (|needle#0@@53| T@U) ) (!  (=> (and (and (and (= (type $ly@@477) LayerTypeType) (= (type |run#0@@141|) (SeqType BoxType))) (= (type |needle#0@@53|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@141| |needle#0@@53|) (and (and ($Is |run#0@@141| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@53| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@141|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|) (|Seq#Length| |run#0@@141|))) (forall ((|i#0@@117| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@117|) (INTERNAL_le_boogie |i#0@@117| (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#0@@117|)) |needle#0@@53|)))
 :qid |totalorderidfyLexicographicByteOrder.461:20|
 :skolemid |5940|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#0@@117|)))
))) (forall ((|i#1@@31| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|) |i#1@@31|) (INTERNAL_lt_boogie |i#1@@31| (|Seq#Length| |run#0@@141|))) (Lexicographic__Byte__Order.__default.lte |needle#0@@53| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#1@@31|)))))
 :qid |totalorderidfyLexicographicByteOrder.462:20|
 :skolemid |5941|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#1@@31|)))
))) (=> (|Seq#Contains| |run#0@@141| ($Box |needle#0@@53|)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|) 1) (|Seq#Length| |run#0@@141|)) (|Seq#Equal| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| (INTERNAL_add_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|) 1))) |needle#0@@53|)))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |5942|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt $ly@@477 |run#0@@141| |needle#0@@53|))
))))
(assert (forall (($ly@@478 T@U) (|run#0@@142| T@U) (|needle#0@@54| T@U) ) (!  (=> (and (and (and (= (type $ly@@478) LayerTypeType) (= (type |run#0@@142|) (SeqType BoxType))) (= (type |needle#0@@54|) (SeqType BoxType))) (and ($Is |run#0@@142| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@54| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@478 |run#0@@142| |needle#0@@54|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@142|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |5943|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@478 |run#0@@142| |needle#0@@54|))
)))
(assert  (and (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@479 T@U) (|run#0@@143| T@U) (|needle#0@@55| T@U) ) (!  (=> (and (and (and (= (type $ly@@479) LayerTypeType) (= (type |run#0@@143|) (SeqType BoxType))) (= (type |needle#0@@55|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@143| |needle#0@@55|) (and (and ($Is |run#0@@143| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@55| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@143|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@143|) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lte#canCall| |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@143|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@143| (LitInt 1)) |needle#0@@55|))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted0) MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@479) |run#0@@143| |needle#0@@55|) (ite  (or (= (|Seq#Length| |run#0@@143|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLt $ly@@479 (|Seq#Drop| |run#0@@143| (LitInt 1)) |needle#0@@55|)))))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |5944|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@479) |run#0@@143| |needle#0@@55|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@480 T@U) (|run#0@@144| T@U) (|needle#0@@56| T@U) ) (!  (=> (and (and (and (= (type $ly@@480) LayerTypeType) (= (type |run#0@@144|) (SeqType BoxType))) (= (type |needle#0@@56|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@144|) (Lit |needle#0@@56|)) (and (and ($Is |run#0@@144| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@56| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@144|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@144|) (LitInt 1))) (Lit |needle#0@@56|)))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted1) MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@480) (Lit |run#0@@144|) (Lit |needle#0@@56|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@480) (Lit (|Seq#Drop| (Lit |run#0@@144|) (LitInt 1))) (Lit |needle#0@@56|))))))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :weight 3
 :skolemid |5945|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@480) (Lit |run#0@@144|) (Lit |needle#0@@56|)))
))))
(assert (forall (($ly@@481 T@U) (|run#0@@145| T@U) (|needle#0@@57| T@U) ) (!  (=> (and (and (= (type $ly@@481) LayerTypeType) (= (type |run#0@@145|) (SeqType BoxType))) (= (type |needle#0@@57|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@481) |run#0@@145| |needle#0@@57|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@481 |run#0@@145| |needle#0@@57|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |5946|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@481) |run#0@@145| |needle#0@@57|))
)))
(assert (forall (($ly@@482 T@U) (|run#0@@146| T@U) (|needle#0@@58| T@U) ) (!  (=> (and (and (= (type $ly@@482) LayerTypeType) (= (type |run#0@@146|) (SeqType BoxType))) (= (type |needle#0@@58|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@482 |run#0@@146| |needle#0@@58|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@146| |needle#0@@58|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |5947|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@482) |run#0@@146| |needle#0@@58|))
)))
(assert  (=> true (forall (($ly@@483 T@U) (|run#0@@147| T@U) (|needle#0@@59| T@U) ) (!  (=> (and (and (and (= (type $ly@@483) LayerTypeType) (= (type |run#0@@147|) (SeqType BoxType))) (= (type |needle#0@@59|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@147| |needle#0@@59|) (and (and ($Is |run#0@@147| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@59| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@147|)))) (and (and (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@483 |run#0@@147| |needle#0@@59|) (|Seq#Length| |run#0@@147|)) (forall ((|i#0@@118| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@118|) (INTERNAL_lt_boogie |i#0@@118| (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@483 |run#0@@147| |needle#0@@59|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#0@@118|)) |needle#0@@59|))
 :qid |totalorderidfyLexicographicByteOrder.495:20|
 :skolemid |5948|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#0@@118|)))
))) (forall ((|i#1@@32| Int) ) (!  (=> (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@483 |run#0@@147| |needle#0@@59|) |i#1@@32|) (INTERNAL_lt_boogie |i#1@@32| (|Seq#Length| |run#0@@147|))) (Lexicographic__Byte__Order.__default.lte |needle#0@@59| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#1@@32|))))
 :qid |totalorderidfyLexicographicByteOrder.496:20|
 :skolemid |5949|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#1@@32|)))
))) (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@483 |run#0@@147| |needle#0@@59|))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |5950|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@483 |run#0@@147| |needle#0@@59|))
))))
(assert (forall (($ly@@484 T@U) (|run#0@@148| T@U) (|needle#0@@60| T@U) ) (!  (=> (and (and (and (= (type $ly@@484) LayerTypeType) (= (type |run#0@@148|) (SeqType BoxType))) (= (type |needle#0@@60|) (SeqType BoxType))) (and ($Is |run#0@@148| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@60| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@484 |run#0@@148| |needle#0@@60|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@148|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |5951|
 :pattern ( (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@484 |run#0@@148| |needle#0@@60|))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@485 T@U) (|run#0@@149| T@U) (|needle#0@@61| T@U) ) (!  (=> (and (and (and (= (type $ly@@485) LayerTypeType) (= (type |run#0@@149|) (SeqType BoxType))) (= (type |needle#0@@61|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@149| |needle#0@@61|) (and (and ($Is |run#0@@149| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@61| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@149|)))) (and (=> (not (= (|Seq#Length| |run#0@@149|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@149|) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|)) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|)) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@149|) (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@149|) |needle#0@@61|))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted2) MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@485) |run#0@@149| |needle#0@@61|) (ite (= (|Seq#Length| |run#0@@149|) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|) (|Seq#Length| |run#0@@149|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@485 (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@149|) |needle#0@@61|)))))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |5952|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@485) |run#0@@149| |needle#0@@61|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@486 T@U) (|run#0@@150| T@U) (|needle#0@@62| T@U) ) (!  (=> (and (and (and (= (type $ly@@486) LayerTypeType) (= (type |run#0@@150|) (SeqType BoxType))) (= (type |needle#0@@62|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@150|) (Lit |needle#0@@62|)) (and (and ($Is |run#0@@150| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@62| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@150|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@150|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|))) (=> (not (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.lt (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|)))))) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)) (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|))) (Lit |needle#0@@62|)))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted3) MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@486) (Lit |run#0@@150|) (Lit |needle#0@@62|)) (ite (= (|Seq#Length| (Lit |run#0@@150|)) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lt (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|)) (|Seq#Length| (Lit |run#0@@150|)) (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@486) (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|))) (Lit |needle#0@@62|))))))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :weight 3
 :skolemid |5953|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@486) (Lit |run#0@@150|) (Lit |needle#0@@62|)))
))))
(assert (forall (($ly@@487 T@U) (|s#0@@185| T@U) (|key#0@@92| T@U) (|lo#0@@19| Int) (|hi#0@@13| Int) ) (!  (=> (and (and (= (type $ly@@487) LayerTypeType) (= (type |s#0@@185|) (SeqType BoxType))) (= (type |key#0@@92|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@487) |s#0@@185| |key#0@@92| |lo#0@@19| |hi#0@@13|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@487 |s#0@@185| |key#0@@92| |lo#0@@19| |hi#0@@13|)))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |5954|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@487) |s#0@@185| |key#0@@92| |lo#0@@19| |hi#0@@13|))
)))
(assert (forall (($ly@@488 T@U) (|s#0@@186| T@U) (|key#0@@93| T@U) (|lo#0@@20| Int) (|hi#0@@14| Int) ) (!  (=> (and (and (= (type $ly@@488) LayerTypeType) (= (type |s#0@@186|) (SeqType BoxType))) (= (type |key#0@@93|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@488 |s#0@@186| |key#0@@93| |lo#0@@20| |hi#0@@14|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@186| |key#0@@93| |lo#0@@20| |hi#0@@14|)))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |5955|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@488) |s#0@@186| |key#0@@93| |lo#0@@20| |hi#0@@14|))
)))
(assert  (=> true (forall (($ly@@489 T@U) (|s#0@@187| T@U) (|key#0@@94| T@U) (|lo#0@@21| Int) (|hi#0@@15| Int) ) (!  (=> (and (and (and (= (type $ly@@489) LayerTypeType) (= (type |s#0@@187|) (SeqType BoxType))) (= (type |key#0@@94|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) (and (and ($Is |s#0@@187| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@94| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@21|) (INTERNAL_lt_boogie |lo#0@@21| |hi#0@@15|)) (INTERNAL_le_boogie |hi#0@@15| (INTERNAL_add_boogie (|Seq#Length| |s#0@@187|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@21| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie |lo#0@@21| 1))) |key#0@@94|))) (=> (INTERNAL_le_boogie |hi#0@@15| (|Seq#Length| |s#0@@187|)) (Lexicographic__Byte__Order.__default.lte |key#0@@94| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie |hi#0@@15| 1))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) (|Seq#Length| |s#0@@187|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) 1))) |key#0@@94|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) (|Seq#Length| |s#0@@187|)) (Lexicographic__Byte__Order.__default.lte |key#0@@94| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|)))))) (and (INTERNAL_le_boogie |lo#0@@21| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|) |hi#0@@15|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |5956|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@489 |s#0@@187| |key#0@@94| |lo#0@@21| |hi#0@@15|))
))))
(assert (forall (($ly@@490 T@U) (|s#0@@188| T@U) (|key#0@@95| T@U) (|lo#0@@22| Int) (|hi#0@@16| Int) ) (!  (=> (and (and (and (= (type $ly@@490) LayerTypeType) (= (type |s#0@@188|) (SeqType BoxType))) (= (type |key#0@@95|) (SeqType BoxType))) (and ($Is |s#0@@188| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@95| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@490 |s#0@@188| |key#0@@95| |lo#0@@22| |hi#0@@16|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@22|) (INTERNAL_lt_boogie |lo#0@@22| |hi#0@@16|)) (INTERNAL_le_boogie |hi#0@@16| (INTERNAL_add_boogie (|Seq#Length| |s#0@@188|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@22| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@188| (INTERNAL_sub_boogie |lo#0@@22| 1))) |key#0@@95|))) (=> (INTERNAL_le_boogie |hi#0@@16| (|Seq#Length| |s#0@@188|)) (Lexicographic__Byte__Order.__default.lte |key#0@@95| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@188| (INTERNAL_sub_boogie |hi#0@@16| 1))))))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |5957|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@490 |s#0@@188| |key#0@@95| |lo#0@@22| |hi#0@@16|))
)))
(assert  (=> true (forall (($ly@@491 T@U) (|s#0@@189| T@U) (|key#0@@96| T@U) (|lo#0@@23| Int) (|hi#0@@17| Int) ) (!  (=> (and (and (and (= (type $ly@@491) LayerTypeType) (= (type |s#0@@189|) (SeqType BoxType))) (= (type |key#0@@96|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@96| |lo#0@@23| |hi#0@@17|) (and (and ($Is |s#0@@189| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@96| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@23|) (INTERNAL_lt_boogie |lo#0@@23| |hi#0@@17|)) (INTERNAL_le_boogie |hi#0@@17| (INTERNAL_add_boogie (|Seq#Length| |s#0@@189|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@23| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |lo#0@@23| 1))) |key#0@@96|))) (=> (INTERNAL_le_boogie |hi#0@@17| (|Seq#Length| |s#0@@189|)) (Lexicographic__Byte__Order.__default.lte |key#0@@96| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |hi#0@@17| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@23| 1) |hi#0@@17|) (let ((|mid#0@@3| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@23| |hi#0@@17|) 2)))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@96|) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@96|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@96| |mid#0@@3| |hi#0@@17|))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@96|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@96| |lo#0@@23| |mid#0@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@491) |s#0@@189| |key#0@@96| |lo#0@@23| |hi#0@@17|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@23| 1) |hi#0@@17|) (let ((|mid#0@@4| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@23| |hi#0@@17|) 2)))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@4| 1))) |key#0@@96|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@491 |s#0@@189| |key#0@@96| |mid#0@@4| |hi#0@@17|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@491 |s#0@@189| |key#0@@96| |lo#0@@23| |mid#0@@4|))) |lo#0@@23|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |5958|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@491) |s#0@@189| |key#0@@96| |lo#0@@23| |hi#0@@17|))
))))
(assert  (=> true (forall (($ly@@492 T@U) (|s#0@@190| T@U) (|key#0@@97| T@U) (|lo#0@@24| Int) (|hi#0@@18| Int) ) (!  (=> (and (and (and (= (type $ly@@492) LayerTypeType) (= (type |s#0@@190|) (SeqType BoxType))) (= (type |key#0@@97|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@97| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)) (and (and ($Is |s#0@@190| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@97| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@24|) (INTERNAL_lt_boogie |lo#0@@24| |hi#0@@18|)) (INTERNAL_le_boogie |hi#0@@18| (INTERNAL_add_boogie (|Seq#Length| |s#0@@190|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@24| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |lo#0@@24| 1)))) |key#0@@97|))) (=> (INTERNAL_le_boogie |hi#0@@18| (|Seq#Length| |s#0@@190|)) (Lexicographic__Byte__Order.__default.lte |key#0@@97| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |hi#0@@18| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@24| 1) |hi#0@@18|)))) (let ((|mid#1@@3| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@24| |hi#0@@18|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@97|) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@97|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@97| |mid#1@@3| (LitInt |hi#0@@18|)))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@97|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@97| (LitInt |lo#0@@24|) |mid#1@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@492) |s#0@@190| |key#0@@97| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@24| 1) |hi#0@@18|) (let ((|mid#1@@4| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@24| |hi#0@@18|) 2))))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |mid#1@@4| 1)))) |key#0@@97|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@492) |s#0@@190| |key#0@@97| |mid#1@@4| (LitInt |hi#0@@18|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@492) |s#0@@190| |key#0@@97| (LitInt |lo#0@@24|) |mid#1@@4|))) |lo#0@@24|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |5959|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@492) |s#0@@190| |key#0@@97| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)))
))))
(assert  (=> true (forall (($ly@@493 T@U) (|s#0@@191| T@U) (|key#0@@98| T@U) (|lo#0@@25| Int) (|hi#0@@19| Int) ) (!  (=> (and (and (and (= (type $ly@@493) LayerTypeType) (= (type |s#0@@191|) (SeqType BoxType))) (= (type |key#0@@98|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@98|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)) (and (and ($Is |s#0@@191| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@98| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@25|) (INTERNAL_lt_boogie |lo#0@@25| |hi#0@@19|)) (INTERNAL_le_boogie |hi#0@@19| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@191|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@25| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |lo#0@@25| 1)))) (Lit |key#0@@98|)))) (=> (INTERNAL_le_boogie |hi#0@@19| (|Seq#Length| (Lit |s#0@@191|))) (Lexicographic__Byte__Order.__default.lte (Lit |key#0@@98|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |hi#0@@19| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@25| 1) |hi#0@@19|)))) (let ((|mid#2@@3| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@25| |hi#0@@19|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@98|)) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@98|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@98|) |mid#2@@3| (LitInt |hi#0@@19|)))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@98|))) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@98|) (LitInt |lo#0@@25|) |mid#2@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@493) (Lit |s#0@@191|) (Lit |key#0@@98|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@25| 1) |hi#0@@19|) (let ((|mid#2@@4| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@25| |hi#0@@19|) 2))))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |mid#2@@4| 1)))) (Lit |key#0@@98|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@493) (Lit |s#0@@191|) (Lit |key#0@@98|) |mid#2@@4| (LitInt |hi#0@@19|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@493) (Lit |s#0@@191|) (Lit |key#0@@98|) (LitInt |lo#0@@25|) |mid#2@@4|))) |lo#0@@25|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |5960|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@493) (Lit |s#0@@191|) (Lit |key#0@@98|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)))
))))
(assert (forall (($ly@@494 T@U) (|s#0@@192| T@U) (|key#0@@99| T@U) ) (!  (=> (and (and (= (type $ly@@494) LayerTypeType) (= (type |s#0@@192|) (SeqType BoxType))) (= (type |key#0@@99|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@494) |s#0@@192| |key#0@@99|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@494 |s#0@@192| |key#0@@99|)))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |5961|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@494) |s#0@@192| |key#0@@99|))
)))
(assert (forall (($ly@@495 T@U) (|s#0@@193| T@U) (|key#0@@100| T@U) ) (!  (=> (and (and (= (type $ly@@495) LayerTypeType) (= (type |s#0@@193|) (SeqType BoxType))) (= (type |key#0@@100|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@495 |s#0@@193| |key#0@@100|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@193| |key#0@@100|)))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |5962|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@495) |s#0@@193| |key#0@@100|))
)))
(assert  (=> true (forall (($ly@@496 T@U) (|s#0@@194| T@U) (|key#0@@101| T@U) ) (!  (=> (and (and (and (= (type $ly@@496) LayerTypeType) (= (type |s#0@@194|) (SeqType BoxType))) (= (type |key#0@@101|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@194| |key#0@@101|) (and ($Is |s#0@@194| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@101| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|) (|Seq#Length| |s#0@@194|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@194| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|) 1))) |key#0@@101|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|) (|Seq#Length| |s#0@@194|)) (Lexicographic__Byte__Order.__default.lte |key#0@@101| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@194| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|)))))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |5963|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@496 |s#0@@194| |key#0@@101|))
))))
(assert (forall (($ly@@497 T@U) (|s#0@@195| T@U) (|key#0@@102| T@U) ) (!  (=> (and (and (and (= (type $ly@@497) LayerTypeType) (= (type |s#0@@195|) (SeqType BoxType))) (= (type |key#0@@102|) (SeqType BoxType))) (and ($Is |s#0@@195| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@102| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@497 |s#0@@195| |key#0@@102|) true))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |5964|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@497 |s#0@@195| |key#0@@102|))
)))
(assert  (=> true (forall (($ly@@498 T@U) (|s#0@@196| T@U) (|key#0@@103| T@U) ) (!  (=> (and (and (and (= (type $ly@@498) LayerTypeType) (= (type |s#0@@196|) (SeqType BoxType))) (= (type |key#0@@103|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@196| |key#0@@103|) (and ($Is |s#0@@196| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@103| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@196| |key#0@@103| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@196|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@498) |s#0@@196| |key#0@@103|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@196| |key#0@@103| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@196|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |5965|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@498) |s#0@@196| |key#0@@103|))
))))
(assert  (=> true (forall (($ly@@499 T@U) (|s#0@@197| T@U) (|key#0@@104| T@U) ) (!  (=> (and (and (and (= (type $ly@@499) LayerTypeType) (= (type |s#0@@197|) (SeqType BoxType))) (= (type |key#0@@104|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@197|) (Lit |key#0@@104|)) (and ($Is |s#0@@197| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@104| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@197|) (Lit |key#0@@104|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@197|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@499) (Lit |s#0@@197|) (Lit |key#0@@104|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@197|) (Lit |key#0@@104|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@197|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :weight 3
 :skolemid |5966|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@499) (Lit |s#0@@197|) (Lit |key#0@@104|)))
))))
(assert (forall (($ly@@500 T@U) (|s#0@@198| T@U) (|key#0@@105| T@U) (|lo#0@@26| Int) ) (!  (=> (and (and (= (type $ly@@500) LayerTypeType) (= (type |s#0@@198|) (SeqType BoxType))) (= (type |key#0@@105|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@500) |s#0@@198| |key#0@@105| |lo#0@@26|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@500 |s#0@@198| |key#0@@105| |lo#0@@26|)))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |5967|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@500) |s#0@@198| |key#0@@105| |lo#0@@26|))
)))
(assert (forall (($ly@@501 T@U) (|s#0@@199| T@U) (|key#0@@106| T@U) (|lo#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@501) LayerTypeType) (= (type |s#0@@199|) (SeqType BoxType))) (= (type |key#0@@106|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@501 |s#0@@199| |key#0@@106| |lo#0@@27|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@199| |key#0@@106| |lo#0@@27|)))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |5968|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@501) |s#0@@199| |key#0@@106| |lo#0@@27|))
)))
(assert  (=> true (forall (($ly@@502 T@U) (|s#0@@200| T@U) (|key#0@@107| T@U) (|lo#0@@28| Int) ) (!  (=> (and (and (and (= (type $ly@@502) LayerTypeType) (= (type |s#0@@200|) (SeqType BoxType))) (= (type |key#0@@107|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@200| |key#0@@107| |lo#0@@28|) (and (and ($Is |s#0@@200| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@107| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@28|) (INTERNAL_le_boogie |lo#0@@28| (|Seq#Length| |s#0@@200|))) (=> (INTERNAL_gt_boogie |lo#0@@28| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (INTERNAL_sub_boogie |lo#0@@28| 1))) |key#0@@107|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@28| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|) (|Seq#Length| |s#0@@200|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|) 1))) |key#0@@107|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|) (|Seq#Length| |s#0@@200|)) (Lexicographic__Byte__Order.__default.lte |key#0@@107| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|)))))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |5969|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@502 |s#0@@200| |key#0@@107| |lo#0@@28|))
))))
(assert (forall (($ly@@503 T@U) (|s#0@@201| T@U) (|key#0@@108| T@U) (|lo#0@@29| Int) ) (!  (=> (and (and (and (= (type $ly@@503) LayerTypeType) (= (type |s#0@@201|) (SeqType BoxType))) (= (type |key#0@@108|) (SeqType BoxType))) (and ($Is |s#0@@201| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@108| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@503 |s#0@@201| |key#0@@108| |lo#0@@29|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@29|) (INTERNAL_le_boogie |lo#0@@29| (|Seq#Length| |s#0@@201|))) (=> (INTERNAL_gt_boogie |lo#0@@29| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@201| (INTERNAL_sub_boogie |lo#0@@29| 1))) |key#0@@108|)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |5970|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@503 |s#0@@201| |key#0@@108| |lo#0@@29|))
)))
(assert  (=> true (forall (($ly@@504 T@U) (|s#0@@202| T@U) (|key#0@@109| T@U) (|lo#0@@30| Int) ) (!  (=> (and (and (and (= (type $ly@@504) LayerTypeType) (= (type |s#0@@202|) (SeqType BoxType))) (= (type |key#0@@109|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@202| |key#0@@109| |lo#0@@30|) (and (and ($Is |s#0@@202| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@109| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@30|) (INTERNAL_le_boogie |lo#0@@30| (|Seq#Length| |s#0@@202|))) (=> (INTERNAL_gt_boogie |lo#0@@30| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@202| (INTERNAL_sub_boogie |lo#0@@30| 1))) |key#0@@109|)))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@202| |key#0@@109| |lo#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@202|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@504) |s#0@@202| |key#0@@109| |lo#0@@30|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@202| |key#0@@109| |lo#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@202|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |5971|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@504) |s#0@@202| |key#0@@109| |lo#0@@30|))
))))
(assert  (=> true (forall (($ly@@505 T@U) (|s#0@@203| T@U) (|key#0@@110| T@U) (|lo#0@@31| Int) ) (!  (=> (and (and (and (= (type $ly@@505) LayerTypeType) (= (type |s#0@@203|) (SeqType BoxType))) (= (type |key#0@@110|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@203|) (Lit |key#0@@110|) (LitInt |lo#0@@31|)) (and (and ($Is |s#0@@203| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@110| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@31|) (INTERNAL_le_boogie |lo#0@@31| (|Seq#Length| (Lit |s#0@@203|)))) (=> (INTERNAL_gt_boogie |lo#0@@31| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@203|) (LitInt (INTERNAL_sub_boogie |lo#0@@31| 1)))) (Lit |key#0@@110|))))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@203|) (Lit |key#0@@110|) (LitInt |lo#0@@31|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@203|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@505) (Lit |s#0@@203|) (Lit |key#0@@110|) (LitInt |lo#0@@31|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@203|) (Lit |key#0@@110|) (LitInt |lo#0@@31|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@203|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :weight 3
 :skolemid |5972|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@505) (Lit |s#0@@203|) (Lit |key#0@@110|) (LitInt |lo#0@@31|)))
))))
(assert (forall (($ly@@506 T@U) (|run#0@@151| T@U) (|needle#0@@63| T@U) ) (!  (=> (and (and (= (type $ly@@506) LayerTypeType) (= (type |run#0@@151|) (SeqType BoxType))) (= (type |needle#0@@63|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@506) |run#0@@151| |needle#0@@63|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@506 |run#0@@151| |needle#0@@63|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |5973|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@506) |run#0@@151| |needle#0@@63|))
)))
(assert (forall (($ly@@507 T@U) (|run#0@@152| T@U) (|needle#0@@64| T@U) ) (!  (=> (and (and (= (type $ly@@507) LayerTypeType) (= (type |run#0@@152|) (SeqType BoxType))) (= (type |needle#0@@64|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@507 |run#0@@152| |needle#0@@64|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@152| |needle#0@@64|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |5974|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@507) |run#0@@152| |needle#0@@64|))
)))
(assert  (=> true (forall (($ly@@508 T@U) (|run#0@@153| T@U) (|needle#0@@65| T@U) ) (!  (=> (and (and (and (= (type $ly@@508) LayerTypeType) (= (type |run#0@@153|) (SeqType BoxType))) (= (type |needle#0@@65|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@153| |needle#0@@65|) (and (and ($Is |run#0@@153| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@65| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@153|)))) (and (and (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@508 |run#0@@153| |needle#0@@65|) (|Seq#Length| |run#0@@153|)) (forall ((|i#0@@119| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@119|) (INTERNAL_lt_boogie |i#0@@119| (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@508 |run#0@@153| |needle#0@@65|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#0@@119|)) |needle#0@@65|))
 :qid |totalorderidfyLexicographicByteOrder.595:20|
 :skolemid |5975|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#0@@119|)))
))) (forall ((|i#1@@33| Int) ) (!  (=> (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@508 |run#0@@153| |needle#0@@65|) |i#1@@33|) (INTERNAL_lt_boogie |i#1@@33| (|Seq#Length| |run#0@@153|))) (Lexicographic__Byte__Order.__default.lt |needle#0@@65| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#1@@33|))))
 :qid |totalorderidfyLexicographicByteOrder.596:20|
 :skolemid |5976|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#1@@33|)))
))) (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@508 |run#0@@153| |needle#0@@65|))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |5977|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@508 |run#0@@153| |needle#0@@65|))
))))
(assert (forall (($ly@@509 T@U) (|run#0@@154| T@U) (|needle#0@@66| T@U) ) (!  (=> (and (and (and (= (type $ly@@509) LayerTypeType) (= (type |run#0@@154|) (SeqType BoxType))) (= (type |needle#0@@66|) (SeqType BoxType))) (and ($Is |run#0@@154| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@66| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@509 |run#0@@154| |needle#0@@66|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@154|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |5978|
 :pattern ( (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@509 |run#0@@154| |needle#0@@66|))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@510 T@U) (|run#0@@155| T@U) (|needle#0@@67| T@U) ) (!  (=> (and (and (and (= (type $ly@@510) LayerTypeType) (= (type |run#0@@155|) (SeqType BoxType))) (= (type |needle#0@@67|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@155| |needle#0@@67|) (and (and ($Is |run#0@@155| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@67| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@155|)))) (and (=> (not (= (|Seq#Length| |run#0@@155|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@155|) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|)) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|)) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@155|) (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@155|) |needle#0@@67|))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted4) MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@510) |run#0@@155| |needle#0@@67|) (ite (= (|Seq#Length| |run#0@@155|) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|) (|Seq#Length| |run#0@@155|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@510 (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@155|) |needle#0@@67|)))))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |5979|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@510) |run#0@@155| |needle#0@@67|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@511 T@U) (|run#0@@156| T@U) (|needle#0@@68| T@U) ) (!  (=> (and (and (and (= (type $ly@@511) LayerTypeType) (= (type |run#0@@156|) (SeqType BoxType))) (= (type |needle#0@@68|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@156|) (Lit |needle#0@@68|)) (and (and ($Is |run#0@@156| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@68| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@156|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@156|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|))) (=> (not (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.lte (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|)))))) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)) (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|))) (Lit |needle#0@@68|)))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted5) MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@511) (Lit |run#0@@156|) (Lit |needle#0@@68|)) (ite (= (|Seq#Length| (Lit |run#0@@156|)) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lte (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|)) (|Seq#Length| (Lit |run#0@@156|)) (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@511) (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|))) (Lit |needle#0@@68|))))))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :weight 3
 :skolemid |5980|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@511) (Lit |run#0@@156|) (Lit |needle#0@@68|)))
))))
(assert (forall (($ly@@512 T@U) (|s#0@@204| T@U) (|key#0@@111| T@U) (|lo#0@@32| Int) (|hi#0@@20| Int) ) (!  (=> (and (and (= (type $ly@@512) LayerTypeType) (= (type |s#0@@204|) (SeqType BoxType))) (= (type |key#0@@111|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@512) |s#0@@204| |key#0@@111| |lo#0@@32| |hi#0@@20|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@512 |s#0@@204| |key#0@@111| |lo#0@@32| |hi#0@@20|)))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |5981|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@512) |s#0@@204| |key#0@@111| |lo#0@@32| |hi#0@@20|))
)))
(assert (forall (($ly@@513 T@U) (|s#0@@205| T@U) (|key#0@@112| T@U) (|lo#0@@33| Int) (|hi#0@@21| Int) ) (!  (=> (and (and (= (type $ly@@513) LayerTypeType) (= (type |s#0@@205|) (SeqType BoxType))) (= (type |key#0@@112|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@513 |s#0@@205| |key#0@@112| |lo#0@@33| |hi#0@@21|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@205| |key#0@@112| |lo#0@@33| |hi#0@@21|)))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |5982|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@513) |s#0@@205| |key#0@@112| |lo#0@@33| |hi#0@@21|))
)))
(assert  (=> true (forall (($ly@@514 T@U) (|s#0@@206| T@U) (|key#0@@113| T@U) (|lo#0@@34| Int) (|hi#0@@22| Int) ) (!  (=> (and (and (and (= (type $ly@@514) LayerTypeType) (= (type |s#0@@206|) (SeqType BoxType))) (= (type |key#0@@113|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|) (and (and ($Is |s#0@@206| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@113| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@34|) (INTERNAL_lt_boogie |lo#0@@34| |hi#0@@22|)) (INTERNAL_le_boogie |hi#0@@22| (INTERNAL_add_boogie (|Seq#Length| |s#0@@206|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@34| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie |lo#0@@34| 1))) |key#0@@113|))) (=> (INTERNAL_le_boogie |hi#0@@22| (|Seq#Length| |s#0@@206|)) (Lexicographic__Byte__Order.__default.lt |key#0@@113| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie |hi#0@@22| 1))))))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|) (|Seq#Length| |s#0@@206|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|) 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|) 1))) |key#0@@113|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|) (|Seq#Length| |s#0@@206|)) (Lexicographic__Byte__Order.__default.lt |key#0@@113| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|)))))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |5983|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@514 |s#0@@206| |key#0@@113| |lo#0@@34| |hi#0@@22|))
))))
(assert (forall (($ly@@515 T@U) (|s#0@@207| T@U) (|key#0@@114| T@U) (|lo#0@@35| Int) (|hi#0@@23| Int) ) (!  (=> (and (and (and (= (type $ly@@515) LayerTypeType) (= (type |s#0@@207|) (SeqType BoxType))) (= (type |key#0@@114|) (SeqType BoxType))) (and ($Is |s#0@@207| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@114| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@515 |s#0@@207| |key#0@@114| |lo#0@@35| |hi#0@@23|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@35|) (INTERNAL_lt_boogie |lo#0@@35| |hi#0@@23|)) (INTERNAL_le_boogie |hi#0@@23| (INTERNAL_add_boogie (|Seq#Length| |s#0@@207|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@35| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@207| (INTERNAL_sub_boogie |lo#0@@35| 1))) |key#0@@114|))) (=> (INTERNAL_le_boogie |hi#0@@23| (|Seq#Length| |s#0@@207|)) (Lexicographic__Byte__Order.__default.lt |key#0@@114| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@207| (INTERNAL_sub_boogie |hi#0@@23| 1))))))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |5984|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@515 |s#0@@207| |key#0@@114| |lo#0@@35| |hi#0@@23|))
)))
(assert  (=> true (forall (($ly@@516 T@U) (|s#0@@208| T@U) (|key#0@@115| T@U) (|lo#0@@36| Int) (|hi#0@@24| Int) ) (!  (=> (and (and (and (= (type $ly@@516) LayerTypeType) (= (type |s#0@@208|) (SeqType BoxType))) (= (type |key#0@@115|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@115| |lo#0@@36| |hi#0@@24|) (and (and ($Is |s#0@@208| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@115| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@36|) (INTERNAL_lt_boogie |lo#0@@36| |hi#0@@24|)) (INTERNAL_le_boogie |hi#0@@24| (INTERNAL_add_boogie (|Seq#Length| |s#0@@208|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@36| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |lo#0@@36| 1))) |key#0@@115|))) (=> (INTERNAL_le_boogie |hi#0@@24| (|Seq#Length| |s#0@@208|)) (Lexicographic__Byte__Order.__default.lt |key#0@@115| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |hi#0@@24| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@36| 1) |hi#0@@24|) (let ((|mid#0@@5| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@36| |hi#0@@24|) 2)))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@115|) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@115|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@115| |mid#0@@5| |hi#0@@24|))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@115|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@115| |lo#0@@36| |mid#0@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@516) |s#0@@208| |key#0@@115| |lo#0@@36| |hi#0@@24|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@36| 1) |hi#0@@24|) (let ((|mid#0@@6| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@36| |hi#0@@24|) 2)))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@6| 1))) |key#0@@115|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@516 |s#0@@208| |key#0@@115| |mid#0@@6| |hi#0@@24|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@516 |s#0@@208| |key#0@@115| |lo#0@@36| |mid#0@@6|))) |lo#0@@36|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |5985|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@516) |s#0@@208| |key#0@@115| |lo#0@@36| |hi#0@@24|))
))))
(assert  (=> true (forall (($ly@@517 T@U) (|s#0@@209| T@U) (|key#0@@116| T@U) (|lo#0@@37| Int) (|hi#0@@25| Int) ) (!  (=> (and (and (and (= (type $ly@@517) LayerTypeType) (= (type |s#0@@209|) (SeqType BoxType))) (= (type |key#0@@116|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@116| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)) (and (and ($Is |s#0@@209| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@116| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@37|) (INTERNAL_lt_boogie |lo#0@@37| |hi#0@@25|)) (INTERNAL_le_boogie |hi#0@@25| (INTERNAL_add_boogie (|Seq#Length| |s#0@@209|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@37| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |lo#0@@37| 1)))) |key#0@@116|))) (=> (INTERNAL_le_boogie |hi#0@@25| (|Seq#Length| |s#0@@209|)) (Lexicographic__Byte__Order.__default.lt |key#0@@116| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |hi#0@@25| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@37| 1) |hi#0@@25|)))) (let ((|mid#1@@5| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@37| |hi#0@@25|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@116|) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@116|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@116| |mid#1@@5| (LitInt |hi#0@@25|)))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@116|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@116| (LitInt |lo#0@@37|) |mid#1@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@517) |s#0@@209| |key#0@@116| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@37| 1) |hi#0@@25|) (let ((|mid#1@@6| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@37| |hi#0@@25|) 2))))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |mid#1@@6| 1)))) |key#0@@116|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@517) |s#0@@209| |key#0@@116| |mid#1@@6| (LitInt |hi#0@@25|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@517) |s#0@@209| |key#0@@116| (LitInt |lo#0@@37|) |mid#1@@6|))) |lo#0@@37|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |5986|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@517) |s#0@@209| |key#0@@116| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)))
))))
(assert  (=> true (forall (($ly@@518 T@U) (|s#0@@210| T@U) (|key#0@@117| T@U) (|lo#0@@38| Int) (|hi#0@@26| Int) ) (!  (=> (and (and (and (= (type $ly@@518) LayerTypeType) (= (type |s#0@@210|) (SeqType BoxType))) (= (type |key#0@@117|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@117|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)) (and (and ($Is |s#0@@210| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@117| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@38|) (INTERNAL_lt_boogie |lo#0@@38| |hi#0@@26|)) (INTERNAL_le_boogie |hi#0@@26| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@210|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@38| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |lo#0@@38| 1)))) (Lit |key#0@@117|)))) (=> (INTERNAL_le_boogie |hi#0@@26| (|Seq#Length| (Lit |s#0@@210|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@117|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |hi#0@@26| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@38| 1) |hi#0@@26|)))) (let ((|mid#2@@5| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@38| |hi#0@@26|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@117|)) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@117|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@117|) |mid#2@@5| (LitInt |hi#0@@26|)))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@117|))) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@117|) (LitInt |lo#0@@38|) |mid#2@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@518) (Lit |s#0@@210|) (Lit |key#0@@117|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@38| 1) |hi#0@@26|) (let ((|mid#2@@6| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@38| |hi#0@@26|) 2))))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |mid#2@@6| 1)))) (Lit |key#0@@117|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@518) (Lit |s#0@@210|) (Lit |key#0@@117|) |mid#2@@6| (LitInt |hi#0@@26|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@518) (Lit |s#0@@210|) (Lit |key#0@@117|) (LitInt |lo#0@@38|) |mid#2@@6|))) |lo#0@@38|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |5987|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@518) (Lit |s#0@@210|) (Lit |key#0@@117|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)))
))))
(assert (forall (($ly@@519 T@U) (|s#0@@211| T@U) (|key#0@@118| T@U) ) (!  (=> (and (and (= (type $ly@@519) LayerTypeType) (= (type |s#0@@211|) (SeqType BoxType))) (= (type |key#0@@118|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@519) |s#0@@211| |key#0@@118|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@519 |s#0@@211| |key#0@@118|)))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |5988|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@519) |s#0@@211| |key#0@@118|))
)))
(assert (forall (($ly@@520 T@U) (|s#0@@212| T@U) (|key#0@@119| T@U) ) (!  (=> (and (and (= (type $ly@@520) LayerTypeType) (= (type |s#0@@212|) (SeqType BoxType))) (= (type |key#0@@119|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@520 |s#0@@212| |key#0@@119|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@212| |key#0@@119|)))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |5989|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@520) |s#0@@212| |key#0@@119|))
)))
(assert  (=> true (forall (($ly@@521 T@U) (|s#0@@213| T@U) (|key#0@@120| T@U) ) (!  (=> (and (and (and (= (type $ly@@521) LayerTypeType) (= (type |s#0@@213|) (SeqType BoxType))) (= (type |key#0@@120|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@213| |key#0@@120|) (and ($Is |s#0@@213| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@120| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|) (|Seq#Length| |s#0@@213|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|) 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@213| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|) 1))) |key#0@@120|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|) (|Seq#Length| |s#0@@213|)) (Lexicographic__Byte__Order.__default.lt |key#0@@120| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@213| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|)))))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |5990|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@521 |s#0@@213| |key#0@@120|))
))))
(assert (forall (($ly@@522 T@U) (|s#0@@214| T@U) (|key#0@@121| T@U) ) (!  (=> (and (and (and (= (type $ly@@522) LayerTypeType) (= (type |s#0@@214|) (SeqType BoxType))) (= (type |key#0@@121|) (SeqType BoxType))) (and ($Is |s#0@@214| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@121| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@522 |s#0@@214| |key#0@@121|) true))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |5991|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@522 |s#0@@214| |key#0@@121|))
)))
(assert  (=> true (forall (($ly@@523 T@U) (|s#0@@215| T@U) (|key#0@@122| T@U) ) (!  (=> (and (and (and (= (type $ly@@523) LayerTypeType) (= (type |s#0@@215|) (SeqType BoxType))) (= (type |key#0@@122|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@215| |key#0@@122|) (and ($Is |s#0@@215| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@122| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@215| |key#0@@122| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@215|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@523) |s#0@@215| |key#0@@122|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@215| |key#0@@122| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@215|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |5992|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@523) |s#0@@215| |key#0@@122|))
))))
(assert  (=> true (forall (($ly@@524 T@U) (|s#0@@216| T@U) (|key#0@@123| T@U) ) (!  (=> (and (and (and (= (type $ly@@524) LayerTypeType) (= (type |s#0@@216|) (SeqType BoxType))) (= (type |key#0@@123|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@216|) (Lit |key#0@@123|)) (and ($Is |s#0@@216| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@123| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@216|) (Lit |key#0@@123|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@216|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@524) (Lit |s#0@@216|) (Lit |key#0@@123|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@216|) (Lit |key#0@@123|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@216|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :weight 3
 :skolemid |5993|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@524) (Lit |s#0@@216|) (Lit |key#0@@123|)))
))))
(assert  (=> true (forall ((|a#0@@153| T@U) (|b#0@@109| T@U) ) (!  (=> (and (and (= (type |a#0@@153|) (MapType0Type BoxType boolType)) (= (type |b#0@@109|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@153| |b#0@@109|) (and ($Is |a#0@@153| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@109| (TSet (TSeq Tclass.NativeTypes.byte)))))) true)
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |5994|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@153| |b#0@@109|))
))))
(assert (forall ((|a#0@@154| T@U) (|b#0@@110| T@U) ) (!  (=> (and (and (= (type |a#0@@154|) (MapType0Type BoxType boolType)) (= (type |b#0@@110|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@154| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@110| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@154| |b#0@@110|) true))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |5995|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@154| |b#0@@110|))
)))
(assert  (=> true (forall ((|a#0@@155| T@U) (|b#0@@111| T@U) ) (!  (=> (and (and (= (type |a#0@@155|) (MapType0Type BoxType boolType)) (= (type |b#0@@111|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@155| |b#0@@111|) (and ($Is |a#0@@155| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@111| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#0@@6| T@U) (|y#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@6|) (SeqType BoxType)) (= (type |y#0@@7|) (SeqType BoxType))) (and ($Is |x#0@@6| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@7| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select |a#0@@155| ($Box |x#0@@6|)))) (U_2_bool (MapType0Select |b#0@@111| ($Box |y#0@@7|)))) (|Lexicographic__Byte__Order.__default.lte#canCall| |x#0@@6| |y#0@@7|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |5997|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#0@@6| |y#0@@7|))
 :pattern ( (MapType0Select |b#0@@111| ($Box |y#0@@7|)) (MapType0Select |a#0@@155| ($Box |x#0@@6|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@155| |b#0@@111|) (forall ((|x#0@@7| T@U) (|y#0@@8| T@U) ) (!  (=> (and (and (and (= (type |x#0@@7|) (SeqType BoxType)) (= (type |y#0@@8|) (SeqType BoxType))) (and ($Is |x#0@@7| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@8| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select |a#0@@155| ($Box |x#0@@7|))) (U_2_bool (MapType0Select |b#0@@111| ($Box |y#0@@8|))))) (Lexicographic__Byte__Order.__default.lte |x#0@@7| |y#0@@8|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |5996|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#0@@7| |y#0@@8|))
 :pattern ( (MapType0Select |b#0@@111| ($Box |y#0@@8|)) (MapType0Select |a#0@@155| ($Box |x#0@@7|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |5998|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@155| |b#0@@111|))
))))
(assert  (=> true (forall ((|a#0@@156| T@U) (|b#0@@112| T@U) ) (!  (=> (and (and (= (type |a#0@@156|) (MapType0Type BoxType boolType)) (= (type |b#0@@112|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@156|) (Lit |b#0@@112|)) (and ($Is |a#0@@156| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@112| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#1@@3| T@U) (|y#1@@3| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@3|) (SeqType BoxType)) (= (type |y#1@@3|) (SeqType BoxType))) (and ($Is |x#1@@3| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@3| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select (Lit |a#0@@156|) ($Box |x#1@@3|)))) (U_2_bool (MapType0Select (Lit |b#0@@112|) ($Box |y#1@@3|)))) (|Lexicographic__Byte__Order.__default.lte#canCall| |x#1@@3| |y#1@@3|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |6000|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#1@@3| |y#1@@3|))
 :pattern ( (MapType0Select |b#0@@112| ($Box |y#1@@3|)) (MapType0Select |a#0@@156| ($Box |x#1@@3|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@156|) (Lit |b#0@@112|)) (forall ((|x#1@@4| T@U) (|y#1@@4| T@U) ) (!  (=> (and (and (and (= (type |x#1@@4|) (SeqType BoxType)) (= (type |y#1@@4|) (SeqType BoxType))) (and ($Is |x#1@@4| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@4| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select (Lit |a#0@@156|) ($Box |x#1@@4|))) (U_2_bool (MapType0Select (Lit |b#0@@112|) ($Box |y#1@@4|))))) (Lexicographic__Byte__Order.__default.lte |x#1@@4| |y#1@@4|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |5999|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#1@@4| |y#1@@4|))
 :pattern ( (MapType0Select |b#0@@112| ($Box |y#1@@4|)) (MapType0Select |a#0@@156| ($Box |x#1@@4|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :weight 3
 :skolemid |6001|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@156|) (Lit |b#0@@112|)))
))))
(assert  (=> true (forall ((|a#0@@157| T@U) (|b#0@@113| T@U) ) (!  (=> (and (and (= (type |a#0@@157|) (MapType0Type BoxType boolType)) (= (type |b#0@@113|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@157| |b#0@@113|) (and ($Is |a#0@@157| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@113| (TSet (TSeq Tclass.NativeTypes.byte)))))) true)
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |6002|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@157| |b#0@@113|))
))))
(assert (forall ((|a#0@@158| T@U) (|b#0@@114| T@U) ) (!  (=> (and (and (= (type |a#0@@158|) (MapType0Type BoxType boolType)) (= (type |b#0@@114|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@158| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@114| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@158| |b#0@@114|) true))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |6003|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@158| |b#0@@114|))
)))
(assert  (=> true (forall ((|a#0@@159| T@U) (|b#0@@115| T@U) ) (!  (=> (and (and (= (type |a#0@@159|) (MapType0Type BoxType boolType)) (= (type |b#0@@115|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@159| |b#0@@115|) (and ($Is |a#0@@159| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@115| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#0@@8| T@U) (|y#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@8|) (SeqType BoxType)) (= (type |y#0@@9|) (SeqType BoxType))) (and ($Is |x#0@@8| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@9| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select |a#0@@159| ($Box |x#0@@8|)))) (U_2_bool (MapType0Select |b#0@@115| ($Box |y#0@@9|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |x#0@@8| |y#0@@9|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |6005|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#0@@8| |y#0@@9|))
 :pattern ( (MapType0Select |b#0@@115| ($Box |y#0@@9|)) (MapType0Select |a#0@@159| ($Box |x#0@@8|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@159| |b#0@@115|) (forall ((|x#0@@9| T@U) (|y#0@@10| T@U) ) (!  (=> (and (and (and (= (type |x#0@@9|) (SeqType BoxType)) (= (type |y#0@@10|) (SeqType BoxType))) (and ($Is |x#0@@9| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@10| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select |a#0@@159| ($Box |x#0@@9|))) (U_2_bool (MapType0Select |b#0@@115| ($Box |y#0@@10|))))) (Lexicographic__Byte__Order.__default.lt |x#0@@9| |y#0@@10|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |6004|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#0@@9| |y#0@@10|))
 :pattern ( (MapType0Select |b#0@@115| ($Box |y#0@@10|)) (MapType0Select |a#0@@159| ($Box |x#0@@9|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |6006|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@159| |b#0@@115|))
))))
(assert  (=> true (forall ((|a#0@@160| T@U) (|b#0@@116| T@U) ) (!  (=> (and (and (= (type |a#0@@160|) (MapType0Type BoxType boolType)) (= (type |b#0@@116|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@160|) (Lit |b#0@@116|)) (and ($Is |a#0@@160| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@116| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#1@@5| T@U) (|y#1@@5| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@5|) (SeqType BoxType)) (= (type |y#1@@5|) (SeqType BoxType))) (and ($Is |x#1@@5| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@5| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select (Lit |a#0@@160|) ($Box |x#1@@5|)))) (U_2_bool (MapType0Select (Lit |b#0@@116|) ($Box |y#1@@5|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |x#1@@5| |y#1@@5|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |6008|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#1@@5| |y#1@@5|))
 :pattern ( (MapType0Select |b#0@@116| ($Box |y#1@@5|)) (MapType0Select |a#0@@160| ($Box |x#1@@5|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@160|) (Lit |b#0@@116|)) (forall ((|x#1@@6| T@U) (|y#1@@6| T@U) ) (!  (=> (and (and (and (= (type |x#1@@6|) (SeqType BoxType)) (= (type |y#1@@6|) (SeqType BoxType))) (and ($Is |x#1@@6| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@6| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select (Lit |a#0@@160|) ($Box |x#1@@6|))) (U_2_bool (MapType0Select (Lit |b#0@@116|) ($Box |y#1@@6|))))) (Lexicographic__Byte__Order.__default.lt |x#1@@6| |y#1@@6|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |6007|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#1@@6| |y#1@@6|))
 :pattern ( (MapType0Select |b#0@@116| ($Box |y#1@@6|)) (MapType0Select |a#0@@160| ($Box |x#1@@6|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :weight 3
 :skolemid |6009|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@160|) (Lit |b#0@@116|)))
))))
(assert (forall (($ly@@525 T@U) (|a#0@@161| T@U) ) (!  (=> (and (= (type $ly@@525) LayerTypeType) (= (type |a#0@@161|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@525) |a#0@@161|) (Lexicographic__Byte__Order.__default.NotMinimum $ly@@525 |a#0@@161|)))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |6010|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@525) |a#0@@161|))
)))
(assert (forall (($ly@@526 T@U) (|a#0@@162| T@U) ) (!  (=> (and (= (type $ly@@526) LayerTypeType) (= (type |a#0@@162|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.NotMinimum $ly@@526 |a#0@@162|) (Lexicographic__Byte__Order.__default.NotMinimum $LZ |a#0@@162|)))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |6011|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@526) |a#0@@162|))
)))
(assert  (=> true (forall (($ly@@527 T@U) (|a#0@@163| T@U) ) (!  (=> (and (and (= (type $ly@@527) LayerTypeType) (= (type |a#0@@163|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@163|) ($Is |a#0@@163| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |6012|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum $ly@@527 |a#0@@163|))
))))
(assert (forall (($ly@@528 T@U) (|a#0@@164| T@U) ) (!  (=> (and (and (= (type $ly@@528) LayerTypeType) (= (type |a#0@@164|) (SeqType BoxType))) ($Is |a#0@@164| (TSeq Tclass.NativeTypes.byte))) (= (|Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@528 |a#0@@164|) true))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |6013|
 :pattern ( (|Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@528 |a#0@@164|))
)))
(assert  (=> true (forall (($ly@@529 T@U) (|a#0@@165| T@U) ) (!  (=> (and (and (= (type $ly@@529) LayerTypeType) (= (type |a#0@@165|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@165|) ($Is |a#0@@165| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|b#0@@117| T@U) ) (!  (=> (and (= (type |b#0@@117|) (SeqType BoxType)) ($Is |b#0@@117| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@117| |a#0@@165|))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |6015|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@117| |a#0@@165|))
)) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@529) |a#0@@165|) (exists ((|b#0@@118| T@U) ) (!  (and (= (type |b#0@@118|) (SeqType BoxType)) (and ($Is |b#0@@118| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.lt |b#0@@118| |a#0@@165|)))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |6014|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@118| |a#0@@165|))
)))))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |6016|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@529) |a#0@@165|))
))))
(assert  (=> true (forall (($ly@@530 T@U) (|a#0@@166| T@U) ) (!  (=> (and (and (= (type $ly@@530) LayerTypeType) (= (type |a#0@@166|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| (Lit |a#0@@166|)) ($Is |a#0@@166| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|b#1@@4| T@U) ) (!  (=> (and (= (type |b#1@@4|) (SeqType BoxType)) ($Is |b#1@@4| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#1@@4| (Lit |a#0@@166|)))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |6018|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#1@@4| |a#0@@166|))
)) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@530) (Lit |a#0@@166|)) (exists ((|b#1@@5| T@U) ) (!  (and (= (type |b#1@@5|) (SeqType BoxType)) (and ($Is |b#1@@5| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.lt |b#1@@5| (Lit |a#0@@166|))))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |6017|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#1@@5| |a#0@@166|))
)))))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :weight 3
 :skolemid |6019|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@530) (Lit |a#0@@166|)))
))))
(assert (forall ((arg0@@604 T@U) (arg1@@305 T@U) (arg2@@166 T@U) (arg3@@98 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@604 arg1@@305 arg2@@166 arg3@@98)) (MapType BoxType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@604 arg1@@305 arg2@@166 arg3@@98))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0@@3| T@U) (|pivot#0@@3| T@U) (|right#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0@@3|) (MapType BoxType BoxType))) (= (type |pivot#0@@3|) (SeqType BoxType))) (= (type |right#0@@3|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|) (and (and ($Is |left#0@@3| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value)) ($Is |pivot#0@@3| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@3| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|) (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |6020|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@4| T@U) (|pivot#0@@4| T@U) (|right#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@4|) (MapType BoxType BoxType))) (= (type |pivot#0@@4|) (SeqType BoxType))) (= (type |right#0@@4|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@4| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)) ($Is |pivot#0@@4| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@4| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@4| |pivot#0@@4| |right#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |6021|
 :pattern ( (|Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@4| |pivot#0@@4| |right#0@@4|))
)))
(assert  (and (forall ((arg0@@605 T@U) (arg1@@306 T@U) ) (! (= (type (|lambda#311| arg0@@605 arg1@@306)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#311|
 :pattern ( (|lambda#311| arg0@@605 arg1@@306))
)) (forall ((arg0@@606 T@U) (arg1@@307 T@U) ) (! (= (type (|lambda#313| arg0@@606 arg1@@307)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#313|
 :pattern ( (|lambda#313| arg0@@606 arg1@@307))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@5| T@U) (|pivot#0@@5| T@U) (|right#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@5|) (MapType BoxType BoxType))) (= (type |pivot#0@@5|) (SeqType BoxType))) (= (type |right#0@@5|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|) (and (and ($Is |left#0@@5| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1)) ($Is |pivot#0@@5| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@5| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@78| T@U) ) (!  (=> (and (= (type |k#0@@78|) (SeqType BoxType)) ($Is |k#0@@78| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |k#0@@78| |pivot#0@@5|))
 :qid |totalorderidfyLexicographicByteOrder.840:57|
 :skolemid |6022|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |k#0@@78| |pivot#0@@5|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#311| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))) (let ((|restricted_left#0@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#311| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
 (and (and (forall ((|k#1@@16| T@U) ) (!  (=> (and (= (type |k#1@@16|) (SeqType BoxType)) ($Is |k#1@@16| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lte#canCall| |pivot#0@@5| |k#1@@16|))
 :qid |totalorderidfyLexicographicByteOrder.841:59|
 :skolemid |6023|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |pivot#0@@5| |k#1@@16|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#313| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))) (let ((|restricted_right#0@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#313| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(|Maps.__default.MapDisjointUnion#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0@@1| |restricted_right#0@@1|))))) (= (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|) (let ((|restricted_left#0@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#311| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(let ((|restricted_right#0@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#313| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(Maps.__default.MapDisjointUnion (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@2| |restricted_right#0@@2|))))))
 :qid |unknown.0:0|
 :skolemid |6024|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@6| T@U) (|pivot#0@@6| T@U) (|right#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@6|) (MapType BoxType BoxType))) (= (type |pivot#0@@6|) (SeqType BoxType))) (= (type |right#0@@6|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)) (and (and ($Is |left#0@@6| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2)) ($Is |pivot#0@@6| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@6| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@7| T@U) ) (!  (=> (and (= (type |k#2@@7|) (SeqType BoxType)) ($Is |k#2@@7| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |k#2@@7| (Lit |pivot#0@@6|)))
 :qid |totalorderidfyLexicographicByteOrder.840:57|
 :skolemid |6025|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |k#2@@7| |pivot#0@@6|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#311| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))) (let ((|restricted_left#1@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#311| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
 (and (and (forall ((|k#3@@0| T@U) ) (!  (=> (and (= (type |k#3@@0|) (SeqType BoxType)) ($Is |k#3@@0| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |pivot#0@@6|) |k#3@@0|))
 :qid |totalorderidfyLexicographicByteOrder.841:59|
 :skolemid |6026|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |pivot#0@@6| |k#3@@0|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#313| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))) (let ((|restricted_right#1@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#313| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(|Maps.__default.MapDisjointUnion#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1@@1| |restricted_right#1@@1|))))) (= (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)) (let ((|restricted_left#1@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#311| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(let ((|restricted_right#1@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#313| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(Maps.__default.MapDisjointUnion (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@2| |restricted_right#1@@2|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6027|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)))
))))
(assert (forall ((arg0@@607 T@U) (arg1@@308 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SetSuccessor arg0@@607 arg1@@308)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.SetSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor arg0@@607 arg1@@308))
)))
(assert  (=> true (forall ((|m#0@@128| T@U) (|key#0@@124| T@U) ) (!  (=> (and (and (= (type |m#0@@128|) (MapType0Type BoxType boolType)) (= (type |key#0@@124|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@128| |key#0@@124|) (and ($Is |m#0@@128| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@124| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@128| |key#0@@124|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.845:25|
 :skolemid |6028|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@128| |key#0@@124|))
))))
(assert (forall (($Heap@@71 T@U) (|m#0@@129| T@U) (|key#0@@125| T@U) ) (!  (=> (and (and (and (= (type $Heap@@71) (MapType0Type refType MapType1Type)) (= (type |m#0@@129|) (MapType0Type BoxType boolType))) (= (type |key#0@@125|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@71) ($Is |m#0@@129| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@125| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@129| |key#0@@125|) true))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :skolemid |6029|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@129| |key#0@@125|) ($IsGoodHeap $Heap@@71))
)))
(assert (forall ((arg0@@608 T@U) (arg1@@309 T@U) ) (! (= (type (|$let#31_next| arg0@@608 arg1@@309)) (SeqType BoxType))
 :qid |funType:$let#31_next|
 :pattern ( (|$let#31_next| arg0@@608 arg1@@309))
)))
(assert (forall ((m@@69 T@U) (key@@0 T@U) ) (!  (=> (and (and (= (type m@@69) (MapType0Type BoxType boolType)) (= (type key@@0) (SeqType BoxType))) (|$let#31$canCall| m@@69 key@@0)) (and ($Is (|$let#31_next| m@@69 key@@0) (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select m@@69 ($Box (|$let#31_next| m@@69 key@@0)))) (Lexicographic__Byte__Order.__default.lt key@@0 (|$let#31_next| m@@69 key@@0))) (forall ((|other#1@@0| T@U) ) (!  (=> (and (= (type |other#1@@0|) (SeqType BoxType)) ($Is |other#1@@0| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select m@@69 ($Box |other#1@@0|))) (not (|Seq#Equal| |other#1@@0| (|$let#31_next| m@@69 key@@0)))) (Lexicographic__Byte__Order.__default.lt key@@0 |other#1@@0|)) (Lexicographic__Byte__Order.__default.lt (|$let#31_next| m@@69 key@@0) |other#1@@0|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6032|
 :pattern ( (Lexicographic__Byte__Order.__default.lt (|$let#31_next| m@@69 key@@0) |other#1@@0|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt key@@0 |other#1@@0|))
 :pattern ( (MapType0Select m@@69 ($Box |other#1@@0|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6033|
 :pattern ( (|$let#31_next| m@@69 key@@0))
)))
(assert  (=> true (forall (($Heap@@72 T@U) (|m#0@@130| T@U) (|key#0@@126| T@U) ) (!  (=> (and (and (and (= (type $Heap@@72) (MapType0Type refType MapType1Type)) (= (type |m#0@@130|) (MapType0Type BoxType boolType))) (= (type |key#0@@126|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@130| |key#0@@126|) (and (and ($IsGoodHeap $Heap@@72) ($Is |m#0@@130| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@126| (TSeq Tclass.NativeTypes.byte))))) (and (and (forall ((|next#0@@2| T@U) ) (!  (=> (and (and (= (type |next#0@@2|) (SeqType BoxType)) ($Is |next#0@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@2|)))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@126| |next#0@@2|) (=> (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@2|) (forall ((|other#0@@18| T@U) ) (!  (=> (and (and (and (= (type |other#0@@18|) (SeqType BoxType)) ($Is |other#0@@18| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@18|)))) (not (|Seq#Equal| |other#0@@18| |next#0@@2|))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@126| |other#0@@18|) (=> (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@18|) (|Lexicographic__Byte__Order.__default.lt#canCall| |next#0@@2| |other#0@@18|))))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6034|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@2| |other#0@@18|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@18|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@18|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6035|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@2|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@2|)))
)) (=> (exists ((|next#0@@3| T@U) ) (!  (and (= (type |next#0@@3|) (SeqType BoxType)) (and ($Is |next#0@@3| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@3|))) (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@3|)) (forall ((|other#0@@19| T@U) ) (!  (=> (and (= (type |other#0@@19|) (SeqType BoxType)) ($Is |other#0@@19| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@19|))) (not (|Seq#Equal| |other#0@@19| |next#0@@3|))) (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@19|)) (Lexicographic__Byte__Order.__default.lt |next#0@@3| |other#0@@19|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6036|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@3| |other#0@@19|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@19|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@19|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6037|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@3|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@3|)))
)) (|$let#31$canCall| |m#0@@130| |key#0@@126|))) (= (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@130| |key#0@@126|) (ite (exists ((|next#0@@4| T@U) ) (!  (and (= (type |next#0@@4|) (SeqType BoxType)) (and ($Is |next#0@@4| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@4|))) (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@4|)) (forall ((|other#0@@20| T@U) ) (!  (=> (and (= (type |other#0@@20|) (SeqType BoxType)) ($Is |other#0@@20| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@20|))) (not (|Seq#Equal| |other#0@@20| |next#0@@4|))) (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@20|)) (Lexicographic__Byte__Order.__default.lt |next#0@@4| |other#0@@20|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6030|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@4| |other#0@@20|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |other#0@@20|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@20|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6031|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@126| |next#0@@4|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@4|)))
)) (let ((|next#1@@0| (|$let#31_next| |m#0@@130| |key#0@@126|)))
(|#Options.Option.Some| ($Box |next#1@@0|))) |#Options.Option.None|))))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :skolemid |6038|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@130| |key#0@@126|) ($IsGoodHeap $Heap@@72))
))))
(assert  (=> true (forall (($Heap@@73 T@U) (|m#0@@131| T@U) (|key#0@@127| T@U) ) (!  (=> (and (and (and (= (type $Heap@@73) (MapType0Type refType MapType1Type)) (= (type |m#0@@131|) (MapType0Type BoxType boolType))) (= (type |key#0@@127|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@131|) (Lit |key#0@@127|)) (and (and ($IsGoodHeap $Heap@@73) ($Is |m#0@@131| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@127| (TSeq Tclass.NativeTypes.byte))))) (and (and (forall ((|next#2@@2| T@U) ) (!  (=> (and (and (= (type |next#2@@2|) (SeqType BoxType)) ($Is |next#2@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@2|)))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@127|) |next#2@@2|) (=> (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |next#2@@2|) (forall ((|other#2@@2| T@U) ) (!  (=> (and (and (and (= (type |other#2@@2|) (SeqType BoxType)) ($Is |other#2@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@2|)))) (not (|Seq#Equal| |other#2@@2| |next#2@@2|))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@127|) |other#2@@2|) (=> (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |other#2@@2|) (|Lexicographic__Byte__Order.__default.lt#canCall| |next#2@@2| |other#2@@2|))))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6041|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@2| |other#2@@2|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |other#2@@2|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@2|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6042|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |next#2@@2|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@2|)))
)) (=> (exists ((|next#2@@3| T@U) ) (!  (and (= (type |next#2@@3|) (SeqType BoxType)) (and ($Is |next#2@@3| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@3|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |next#2@@3|)) (forall ((|other#2@@3| T@U) ) (!  (=> (and (= (type |other#2@@3|) (SeqType BoxType)) ($Is |other#2@@3| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@3|))) (not (|Seq#Equal| |other#2@@3| |next#2@@3|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |other#2@@3|)) (Lexicographic__Byte__Order.__default.lt |next#2@@3| |other#2@@3|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6043|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@3| |other#2@@3|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |other#2@@3|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@3|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6044|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |next#2@@3|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@3|)))
)) (|$let#31$canCall| (Lit |m#0@@131|) (Lit |key#0@@127|)))) (= (Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@131|) (Lit |key#0@@127|)) (ite (exists ((|next#2@@4| T@U) ) (!  (and (= (type |next#2@@4|) (SeqType BoxType)) (and ($Is |next#2@@4| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@4|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |next#2@@4|)) (forall ((|other#2@@4| T@U) ) (!  (=> (and (= (type |other#2@@4|) (SeqType BoxType)) ($Is |other#2@@4| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@4|))) (not (|Seq#Equal| |other#2@@4| |next#2@@4|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@127|) |other#2@@4|)) (Lexicographic__Byte__Order.__default.lt |next#2@@4| |other#2@@4|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |6039|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@4| |other#2@@4|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |other#2@@4|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@4|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |6040|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@127| |next#2@@4|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@4|)))
)) (let ((|next#3@@0| (|$let#31_next| (Lit |m#0@@131|) (Lit |key#0@@127|))))
(|#Options.Option.Some| ($Box |next#3@@0|))) |#Options.Option.None|))))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :weight 3
 :skolemid |6045|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@131|) (Lit |key#0@@127|)) ($IsGoodHeap $Heap@@73))
))))
(assert (forall ((arg0@@609 T@U) (arg1@@310 T@U) (arg2@@167 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.MapSuccessor arg0@@609 arg1@@310 arg2@@167)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.MapSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor arg0@@609 arg1@@310 arg2@@167))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V T@U) (|m#0@@132| T@U) (|key#0@@128| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@132|) (MapType BoxType BoxType))) (= (type |key#0@@128|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@128|) (and ($Is |m#0@@132| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V)) ($Is |key#0@@128| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@128|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |unknown.0:0|
 :skolemid |6046|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@128|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@133| T@U) (|key#0@@129| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@133|) (MapType BoxType BoxType))) (= (type |key#0@@129|) (SeqType BoxType))) (and ($Is |m#0@@133| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@0)) ($Is |key#0@@129| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.MapSuccessor#requires| Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@133| |key#0@@129|) true))
 :qid |unknown.0:0|
 :skolemid |6047|
 :pattern ( (|Lexicographic__Byte__Order.__default.MapSuccessor#requires| Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@133| |key#0@@129|))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@134| T@U) (|key#0@@130| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@134|) (MapType BoxType BoxType))) (= (type |key#0@@130|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@130|) (and ($Is |m#0@@134| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@1)) ($Is |key#0@@130| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@134|) |key#0@@130|) (= (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@130|) (Lexicographic__Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@134|) |key#0@@130|))))
 :qid |unknown.0:0|
 :skolemid |6048|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@130|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@135| T@U) (|key#0@@131| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@135|) (MapType BoxType BoxType))) (= (type |key#0@@131|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@131|)) (and ($Is |m#0@@135| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@2)) ($Is |key#0@@131| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@135|))) (Lit |key#0@@131|)) (= (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@131|)) (Lit (Lexicographic__Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@135|))) (Lit |key#0@@131|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6049|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@131|)))
))))
(assert (forall ((arg0@@610 T@U) (arg1@@311 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@610 arg1@@311)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.SeqSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@610 arg1@@311))
)))
(assert  (=> true (forall ((|m#0@@136| T@U) (|key#0@@132| T@U) ) (!  (=> (and (and (= (type |m#0@@136|) (SeqType BoxType)) (= (type |key#0@@132|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@136| |key#0@@132|) (and ($Is |m#0@@136| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@132| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@136| |key#0@@132|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |6050|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@136| |key#0@@132|))
))))
(assert (forall ((|m#0@@137| T@U) (|key#0@@133| T@U) ) (!  (=> (and (and (= (type |m#0@@137|) (SeqType BoxType)) (= (type |key#0@@133|) (SeqType BoxType))) (and ($Is |m#0@@137| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@133| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@137| |key#0@@133|) true))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |6051|
 :pattern ( (|Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@137| |key#0@@133|))
)))
(assert  (=> true (forall ((|m#0@@138| T@U) (|key#0@@134| T@U) ) (!  (=> (and (and (= (type |m#0@@138|) (SeqType BoxType)) (= (type |key#0@@134|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@138| |key#0@@134|) (and ($Is |m#0@@138| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@134| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| (TSeq Tclass.NativeTypes.byte) |m#0@@138|) |key#0@@134|) (= (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@138| |key#0@@134|) (Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#307| (TSeq Tclass.NativeTypes.byte) |m#0@@138|) |key#0@@134|))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |6052|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@138| |key#0@@134|))
))))
(assert  (=> true (forall ((|m#0@@139| T@U) (|key#0@@135| T@U) ) (!  (=> (and (and (= (type |m#0@@139|) (SeqType BoxType)) (= (type |key#0@@135|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@139|) (Lit |key#0@@135|)) (and ($Is |m#0@@139| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@135| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| (TSeq Tclass.NativeTypes.byte) |m#0@@139|) (Lit |key#0@@135|)) (= (Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@139|) (Lit |key#0@@135|)) (Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#307| (TSeq Tclass.NativeTypes.byte) |m#0@@139|) (Lit |key#0@@135|)))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :weight 3
 :skolemid |6053|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@139|) (Lit |key#0@@135|)))
))))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@531 T@U) (|s#0@@217| T@U) (|m#0@@140| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@531) LayerTypeType)) (= (type |s#0@@217|) (SeqType BoxType))) (= (type |m#0@@140|) (MapType BoxType BoxType))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@531) |s#0@@217| |m#0@@140|) (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V $ly@@531 |s#0@@217| |m#0@@140|)))
 :qid |unknown.0:0|
 :skolemid |6054|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@531) |s#0@@217| |m#0@@140|))
)))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@532 T@U) (|s#0@@218| T@U) (|m#0@@141| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@532) LayerTypeType)) (= (type |s#0@@218|) (SeqType BoxType))) (= (type |m#0@@141|) (MapType BoxType BoxType))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $ly@@532 |s#0@@218| |m#0@@141|) (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@218| |m#0@@141|)))
 :qid |unknown.0:0|
 :skolemid |6055|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@532) |s#0@@218| |m#0@@141|))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@533 T@U) (|s#0@@219| T@U) (|m#0@@142| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@533) LayerTypeType)) (= (type |s#0@@219|) (SeqType BoxType))) (= (type |m#0@@142|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@219| |m#0@@142|) (and ($Is |s#0@@219| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@142| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |6056|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 $ly@@533 |s#0@@219| |m#0@@142|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@534 T@U) (|s#0@@220| T@U) (|m#0@@143| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@534) LayerTypeType)) (= (type |s#0@@220|) (SeqType BoxType))) (= (type |m#0@@143|) (MapType BoxType BoxType))) (and ($Is |s#0@@220| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@143| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@534 |s#0@@220| |m#0@@143|) true))
 :qid |unknown.0:0|
 :skolemid |6057|
 :pattern ( (|Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@534 |s#0@@220| |m#0@@143|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@535 T@U) (|s#0@@221| T@U) (|m#0@@144| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@535) LayerTypeType)) (= (type |s#0@@221|) (SeqType BoxType))) (= (type |m#0@@144|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@221| |m#0@@144|) (and ($Is |s#0@@221| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@144| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@221|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|))) (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|))))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|)))) (and (forall ((|i#0@@120| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@120|) (=> (INTERNAL_lt_boogie |i#0@@120| (|Seq#Length| |s#0@@221|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@120|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@120|) (INTERNAL_lt_boogie |i#0@@120| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@120|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@120|) (=> (INTERNAL_lt_boogie |i#0@@120| (|Seq#Length| |s#0@@221|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@120|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@120|))))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6061|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@120|)))
)) (=> (forall ((|i#0@@121| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@121|) (INTERNAL_lt_boogie |i#0@@121| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@121|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@121|) (INTERNAL_lt_boogie |i#0@@121| (|Seq#Length| |s#0@@221|))) (= (MapType0Select (|Map#Elements| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@121|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@121|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6064|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@121|)))
)) (forall ((|key#0@@136| T@U) ) (!  (=> (and (and (= (type |key#0@@136|) (SeqType BoxType)) ($Is |key#0@@136| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@136|)))) (forall ((|i#1@@34| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@34|) (=> (INTERNAL_lt_boogie |i#1@@34| (|Seq#Length| |s#0@@221|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@34|))) (=> (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@34|)))) |key#0@@136|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@34|)))))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |6062|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@34|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |6063|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@136|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@136|)))
)))))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@535) |s#0@@221| |m#0@@144|)  (and (and (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|)))) (forall ((|i#0@@122| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@122|) (INTERNAL_lt_boogie |i#0@@122| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@122|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@122|) (INTERNAL_lt_boogie |i#0@@122| (|Seq#Length| |s#0@@221|))) (= (MapType0Select (|Map#Elements| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@122|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@122|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6058|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@122|)))
))) (forall ((|key#0@@137| T@U) ) (!  (=> (and (and (= (type |key#0@@137|) (SeqType BoxType)) ($Is |key#0@@137| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@137|)))) (exists ((|i#1@@35| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@35|) (INTERNAL_lt_boogie |i#1@@35| (|Seq#Length| |s#0@@221|))) (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@35|)))) |key#0@@137|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@35|))) (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@137|))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |6059|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@35|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |6060|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@137|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@137|)))
))))))
 :qid |unknown.0:0|
 :skolemid |6065|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@535) |s#0@@221| |m#0@@144|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@536 T@U) (|s#0@@222| T@U) (|m#0@@145| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@536) LayerTypeType)) (= (type |s#0@@222|) (SeqType BoxType))) (= (type |m#0@@145|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@222|) (Lit |m#0@@145|)) (and ($Is |s#0@@222| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@145| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@222|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|)))) (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|)))))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|))))) (and (forall ((|i#2@@9| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@9|) (=> (INTERNAL_lt_boogie |i#2@@9| (|Seq#Length| (Lit |s#0@@222|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@9|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@9|) (INTERNAL_lt_boogie |i#2@@9| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@9|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@9|) (=> (INTERNAL_lt_boogie |i#2@@9| (|Seq#Length| (Lit |s#0@@222|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@9|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@9|))))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6069|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@9|)))
)) (=> (forall ((|i#2@@10| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@10|) (INTERNAL_lt_boogie |i#2@@10| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@10|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@10|) (INTERNAL_lt_boogie |i#2@@10| (|Seq#Length| (Lit |s#0@@222|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@10|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@10|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6072|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@10|)))
)) (forall ((|key#1@@10| T@U) ) (!  (=> (and (and (= (type |key#1@@10|) (SeqType BoxType)) ($Is |key#1@@10| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@10|)))) (forall ((|i#3@@3| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@3|) (=> (INTERNAL_lt_boogie |i#3@@3| (|Seq#Length| (Lit |s#0@@222|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@3|))) (=> (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@3|)))) |key#1@@10|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@3|)))))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |6070|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#3@@3|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |6071|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@145|) ($Box |key#1@@10|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@10|)))
)))))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@536) (Lit |s#0@@222|) (Lit |m#0@@145|))  (and (and (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|))))) (forall ((|i#2@@11| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@11|) (INTERNAL_lt_boogie |i#2@@11| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@11|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@11|) (INTERNAL_lt_boogie |i#2@@11| (|Seq#Length| (Lit |s#0@@222|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@11|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@11|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |6066|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@11|)))
))) (forall ((|key#1@@11| T@U) ) (!  (=> (and (and (= (type |key#1@@11|) (SeqType BoxType)) ($Is |key#1@@11| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@11|)))) (exists ((|i#3@@4| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@4|) (INTERNAL_lt_boogie |i#3@@4| (|Seq#Length| (Lit |s#0@@222|)))) (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@4|)))) |key#1@@11|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@4|))) (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) ($Box |key#1@@11|))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |6067|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#3@@4|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |6068|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@145|) ($Box |key#1@@11|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@11|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6073|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@536) (Lit |s#0@@222|) (Lit |m#0@@145|)))
))))
(assert (forall ((arg0@@611 T@U) (arg1@@312 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.minimum arg0@@611 arg1@@312)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.minimum|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum arg0@@611 arg1@@312))
)))
(assert (forall (($ly@@537 T@U) (|s#0@@223| T@U) ) (!  (=> (and (= (type $ly@@537) LayerTypeType) (= (type |s#0@@223|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@537) |s#0@@223|) (Lexicographic__Byte__Order.__default.minimum $ly@@537 |s#0@@223|)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |6074|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@537) |s#0@@223|))
)))
(assert (forall (($ly@@538 T@U) (|s#0@@224| T@U) ) (!  (=> (and (= (type $ly@@538) LayerTypeType) (= (type |s#0@@224|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimum $ly@@538 |s#0@@224|) (Lexicographic__Byte__Order.__default.minimum $LZ |s#0@@224|)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |6075|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum (AsFuelBottom $ly@@538) |s#0@@224|))
)))
(assert  (=> true (forall (($ly@@539 T@U) (|s#0@@225| T@U) ) (!  (=> (and (and (= (type $ly@@539) LayerTypeType) (= (type |s#0@@225|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@225|) (and ($Is |s#0@@225| (TSet (TSeq Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@225|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@225| ($Box (Lexicographic__Byte__Order.__default.minimum $ly@@539 |s#0@@225|)))) (forall ((|y#0@@11| T@U) ) (!  (=> (= (type |y#0@@11|) (SeqType BoxType)) (=> (and ($Is |y#0@@11| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@225| ($Box |y#0@@11|)))) (Lexicographic__Byte__Order.__default.lte (Lexicographic__Byte__Order.__default.minimum $ly@@539 |s#0@@225|) |y#0@@11|)))
 :qid |totalorderidfyLexicographicByteOrder.876:18|
 :skolemid |6076|
 :pattern ( (Lexicographic__Byte__Order.__default.lte (Lexicographic__Byte__Order.__default.minimum $ly@@539 |s#0@@225|) |y#0@@11|))
 :pattern ( (MapType0Select |s#0@@225| ($Box |y#0@@11|)))
))) ($Is (Lexicographic__Byte__Order.__default.minimum $ly@@539 |s#0@@225|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |6077|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum $ly@@539 |s#0@@225|))
))))
(assert (forall (($ly@@540 T@U) ($Heap@@74 T@U) (|s#0@@226| T@U) ) (!  (=> (and (and (and (= (type $ly@@540) LayerTypeType) (= (type $Heap@@74) (MapType0Type refType MapType1Type))) (= (type |s#0@@226|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@74) ($Is |s#0@@226| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.minimum#requires| $ly@@540 |s#0@@226|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@226|) 1)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |6078|
 :pattern ( (|Lexicographic__Byte__Order.__default.minimum#requires| $ly@@540 |s#0@@226|) ($IsGoodHeap $Heap@@74))
)))
(assert (forall ((arg0@@612 T@U) ) (! (= (type (|$let#34_a| arg0@@612)) (SeqType BoxType))
 :qid |funType:$let#34_a|
 :pattern ( (|$let#34_a| arg0@@612))
)))
(assert (forall ((s@@54 T@U) ) (!  (=> (and (= (type s@@54) (MapType0Type BoxType boolType)) (|$let#34$canCall| s@@54)) (and ($Is (|$let#34_a| s@@54) (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select s@@54 ($Box (|$let#34_a| s@@54))))))
 :qid |totalorderidfyLexicographicByteOrder.881:5|
 :skolemid |6079|
 :pattern ( (|$let#34_a| s@@54))
)))
(assert  (=> true (forall (($ly@@541 T@U) ($Heap@@75 T@U) (|s#0@@227| T@U) ) (!  (=> (and (and (and (= (type $ly@@541) LayerTypeType) (= (type $Heap@@75) (MapType0Type refType MapType1Type))) (= (type |s#0@@227|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@227|) (and (and ($IsGoodHeap $Heap@@75) ($Is |s#0@@227| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@227|) 1)))) (and (and (|$let#34$canCall| |s#0@@227|) (let ((|s'#1@@1| (|Set#Difference| |s#0@@227| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#34_a| |s#0@@227|))))))
 (=> (not (|Set#Equal| |s'#1@@1| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.minimum#canCall| |s'#1@@1|) (let ((|m'#1@@3| (Lexicographic__Byte__Order.__default.minimum $ly@@541 |s'#1@@1|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| (|$let#34_a| |s#0@@227|) |m'#1@@3|)))))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@541) |s#0@@227|) (let ((|a#0@@167| (|$let#34_a| |s#0@@227|)))
(let ((|s'#0@@1| (|Set#Difference| |s#0@@227| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@167|)))))
(ite (|Set#Equal| |s'#0@@1| (|Set#Empty| BoxType)) |a#0@@167| (let ((|m'#0@@12| (Lexicographic__Byte__Order.__default.minimum $ly@@541 |s'#0@@1|)))
(ite (Lexicographic__Byte__Order.__default.lt |a#0@@167| |m'#0@@12|) |a#0@@167| |m'#0@@12|))))))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |6080|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@541) |s#0@@227|) ($IsGoodHeap $Heap@@75))
))))
(assert  (=> true (forall (($ly@@542 T@U) ($Heap@@76 T@U) (|s#0@@228| T@U) ) (!  (=> (and (and (and (= (type $ly@@542) LayerTypeType) (= (type $Heap@@76) (MapType0Type refType MapType1Type))) (= (type |s#0@@228|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@228|)) (and (and ($IsGoodHeap $Heap@@76) ($Is |s#0@@228| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@228|)) 1)))) (and (and (|$let#34$canCall| (Lit |s#0@@228|)) (let ((|s'#3@@1| (|Set#Difference| |s#0@@228| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#34_a| (Lit |s#0@@228|)))))))
 (=> (not (|Set#Equal| |s'#3@@1| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.minimum#canCall| |s'#3@@1|) (let ((|m'#3@@1| (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@542) |s'#3@@1|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| (|$let#34_a| (Lit |s#0@@228|)) |m'#3@@1|)))))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@542) (Lit |s#0@@228|)) (let ((|a#1@@4| (|$let#34_a| (Lit |s#0@@228|))))
(let ((|s'#2@@1| (|Set#Difference| |s#0@@228| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@4|)))))
(ite (|Set#Equal| |s'#2@@1| (|Set#Empty| BoxType)) |a#1@@4| (let ((|m'#2@@2| (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@542) |s'#2@@1|)))
(ite (Lexicographic__Byte__Order.__default.lt |a#1@@4| |m'#2@@2|) |a#1@@4| |m'#2@@2|))))))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :weight 3
 :skolemid |6081|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@542) (Lit |s#0@@228|)) ($IsGoodHeap $Heap@@76))
))))
(assert (forall ((arg0@@613 T@U) (arg1@@313 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.minimumOpt arg0@@613 arg1@@313)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.minimumOpt|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt arg0@@613 arg1@@313))
)))
(assert (forall (($ly@@543 T@U) (|s#0@@229| T@U) ) (!  (=> (and (= (type $ly@@543) LayerTypeType) (= (type |s#0@@229|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@543) |s#0@@229|) (Lexicographic__Byte__Order.__default.minimumOpt $ly@@543 |s#0@@229|)))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |6082|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@543) |s#0@@229|))
)))
(assert (forall (($ly@@544 T@U) (|s#0@@230| T@U) ) (!  (=> (and (= (type $ly@@544) LayerTypeType) (= (type |s#0@@230|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimumOpt $ly@@544 |s#0@@230|) (Lexicographic__Byte__Order.__default.minimumOpt $LZ |s#0@@230|)))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |6083|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@544) |s#0@@230|))
)))
(assert  (=> true (forall (($ly@@545 T@U) (|s#0@@231| T@U) ) (!  (=> (and (and (= (type $ly@@545) LayerTypeType) (= (type |s#0@@231|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@231|) ($Is |s#0@@231| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|)) (U_2_bool (MapType0Select |s#0@@231| (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|))))) (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|)) (forall ((|y#0@@12| T@U) ) (!  (=> (= (type |y#0@@12|) (SeqType BoxType)) (=> (and ($Is |y#0@@12| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@231| ($Box |y#0@@12|)))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|))) |y#0@@12|)))
 :qid |totalorderidfyLexicographicByteOrder.899:30|
 :skolemid |6084|
 :pattern ( (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|))) |y#0@@12|))
 :pattern ( (MapType0Select |s#0@@231| ($Box |y#0@@12|)))
)))) (=> (Options.Option.None_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|)) (|Set#Equal| |s#0@@231| (|Set#Empty| BoxType)))) ($Is (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |6085|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt $ly@@545 |s#0@@231|))
))))
(assert (forall (($ly@@546 T@U) (|s#0@@232| T@U) ) (!  (=> (and (and (= (type $ly@@546) LayerTypeType) (= (type |s#0@@232|) (MapType0Type BoxType boolType))) ($Is |s#0@@232| (TSet (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@546 |s#0@@232|) true))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |6086|
 :pattern ( (|Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@546 |s#0@@232|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@547 T@U) (|s#0@@233| T@U) ) (!  (=> (and (and (= (type $ly@@547) LayerTypeType) (= (type |s#0@@233|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@233|) ($Is |s#0@@233| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@233| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@233|)) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@547) |s#0@@233|) (ite (|Set#Equal| |s#0@@233| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.minimum StartFuel_Lexicographic_Byte_Order._default.minimum |s#0@@233|)))))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |6087|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@547) |s#0@@233|))
))))
(assert  (=> true (forall (($ly@@548 T@U) (|s#0@@234| T@U) ) (!  (=> (and (and (= (type $ly@@548) LayerTypeType) (= (type |s#0@@234|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@234|)) ($Is |s#0@@234| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@234| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@234|))) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@548) (Lit |s#0@@234|)) (ite (|Set#Equal| |s#0@@234| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.minimum StartFuel_Lexicographic_Byte_Order._default.minimum (Lit |s#0@@234|))))))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :weight 3
 :skolemid |6088|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@548) (Lit |s#0@@234|)))
))))
(assert (forall ((arg0@@614 T@U) (arg1@@314 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.maximum arg0@@614 arg1@@314)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.maximum|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum arg0@@614 arg1@@314))
)))
(assert (forall (($ly@@549 T@U) (|s#0@@235| T@U) ) (!  (=> (and (= (type $ly@@549) LayerTypeType) (= (type |s#0@@235|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@549) |s#0@@235|) (Lexicographic__Byte__Order.__default.maximum $ly@@549 |s#0@@235|)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |6089|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@549) |s#0@@235|))
)))
(assert (forall (($ly@@550 T@U) (|s#0@@236| T@U) ) (!  (=> (and (= (type $ly@@550) LayerTypeType) (= (type |s#0@@236|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximum $ly@@550 |s#0@@236|) (Lexicographic__Byte__Order.__default.maximum $LZ |s#0@@236|)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |6090|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum (AsFuelBottom $ly@@550) |s#0@@236|))
)))
(assert  (=> true (forall (($ly@@551 T@U) (|s#0@@237| T@U) ) (!  (=> (and (and (= (type $ly@@551) LayerTypeType) (= (type |s#0@@237|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@237|) (and ($Is |s#0@@237| (TSet (TSeq Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@237|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@237| ($Box (Lexicographic__Byte__Order.__default.maximum $ly@@551 |s#0@@237|)))) (forall ((|y#0@@13| T@U) ) (!  (=> (= (type |y#0@@13|) (SeqType BoxType)) (=> (and ($Is |y#0@@13| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@237| ($Box |y#0@@13|)))) (Lexicographic__Byte__Order.__default.lte |y#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@551 |s#0@@237|))))
 :qid |totalorderidfyLexicographicByteOrder.908:18|
 :skolemid |6091|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |y#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@551 |s#0@@237|)))
 :pattern ( (MapType0Select |s#0@@237| ($Box |y#0@@13|)))
))) ($Is (Lexicographic__Byte__Order.__default.maximum $ly@@551 |s#0@@237|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |6092|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum $ly@@551 |s#0@@237|))
))))
(assert (forall (($ly@@552 T@U) ($Heap@@77 T@U) (|s#0@@238| T@U) ) (!  (=> (and (and (and (= (type $ly@@552) LayerTypeType) (= (type $Heap@@77) (MapType0Type refType MapType1Type))) (= (type |s#0@@238|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@77) ($Is |s#0@@238| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.maximum#requires| $ly@@552 |s#0@@238|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@238|) 1)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |6093|
 :pattern ( (|Lexicographic__Byte__Order.__default.maximum#requires| $ly@@552 |s#0@@238|) ($IsGoodHeap $Heap@@77))
)))
(assert (forall ((arg0@@615 T@U) ) (! (= (type (|$let#37_a| arg0@@615)) (SeqType BoxType))
 :qid |funType:$let#37_a|
 :pattern ( (|$let#37_a| arg0@@615))
)))
(assert (forall ((s@@55 T@U) ) (!  (=> (and (= (type s@@55) (MapType0Type BoxType boolType)) (|$let#37$canCall| s@@55)) (and ($Is (|$let#37_a| s@@55) (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select s@@55 ($Box (|$let#37_a| s@@55))))))
 :qid |totalorderidfyLexicographicByteOrder.911:5|
 :skolemid |6094|
 :pattern ( (|$let#37_a| s@@55))
)))
(assert  (=> true (forall (($ly@@553 T@U) ($Heap@@78 T@U) (|s#0@@239| T@U) ) (!  (=> (and (and (and (= (type $ly@@553) LayerTypeType) (= (type $Heap@@78) (MapType0Type refType MapType1Type))) (= (type |s#0@@239|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@239|) (and (and ($IsGoodHeap $Heap@@78) ($Is |s#0@@239| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@239|) 1)))) (and (and (|$let#37$canCall| |s#0@@239|) (let ((|s'#1@@2| (|Set#Difference| |s#0@@239| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#37_a| |s#0@@239|))))))
 (=> (not (|Set#Equal| |s'#1@@2| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.maximum#canCall| |s'#1@@2|) (let ((|m'#1@@4| (Lexicographic__Byte__Order.__default.maximum $ly@@553 |s'#1@@2|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| |m'#1@@4| (|$let#37_a| |s#0@@239|))))))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@553) |s#0@@239|) (let ((|a#0@@168| (|$let#37_a| |s#0@@239|)))
(let ((|s'#0@@2| (|Set#Difference| |s#0@@239| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@168|)))))
(ite (|Set#Equal| |s'#0@@2| (|Set#Empty| BoxType)) |a#0@@168| (let ((|m'#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@553 |s'#0@@2|)))
(ite (Lexicographic__Byte__Order.__default.lt |m'#0@@13| |a#0@@168|) |a#0@@168| |m'#0@@13|))))))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |6095|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@553) |s#0@@239|) ($IsGoodHeap $Heap@@78))
))))
(assert  (=> true (forall (($ly@@554 T@U) ($Heap@@79 T@U) (|s#0@@240| T@U) ) (!  (=> (and (and (and (= (type $ly@@554) LayerTypeType) (= (type $Heap@@79) (MapType0Type refType MapType1Type))) (= (type |s#0@@240|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@240|)) (and (and ($IsGoodHeap $Heap@@79) ($Is |s#0@@240| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@240|)) 1)))) (and (and (|$let#37$canCall| (Lit |s#0@@240|)) (let ((|s'#3@@2| (|Set#Difference| |s#0@@240| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#37_a| (Lit |s#0@@240|)))))))
 (=> (not (|Set#Equal| |s'#3@@2| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.maximum#canCall| |s'#3@@2|) (let ((|m'#3@@2| (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@554) |s'#3@@2|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| |m'#3@@2| (|$let#37_a| (Lit |s#0@@240|)))))))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@554) (Lit |s#0@@240|)) (let ((|a#1@@5| (|$let#37_a| (Lit |s#0@@240|))))
(let ((|s'#2@@2| (|Set#Difference| |s#0@@240| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@5|)))))
(ite (|Set#Equal| |s'#2@@2| (|Set#Empty| BoxType)) |a#1@@5| (let ((|m'#2@@3| (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@554) |s'#2@@2|)))
(ite (Lexicographic__Byte__Order.__default.lt |m'#2@@3| |a#1@@5|) |a#1@@5| |m'#2@@3|))))))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :weight 3
 :skolemid |6096|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@554) (Lit |s#0@@240|)) ($IsGoodHeap $Heap@@79))
))))
(assert (forall ((arg0@@616 T@U) (arg1@@315 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.maximumOpt arg0@@616 arg1@@315)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.maximumOpt|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt arg0@@616 arg1@@315))
)))
(assert (forall (($ly@@555 T@U) (|s#0@@241| T@U) ) (!  (=> (and (= (type $ly@@555) LayerTypeType) (= (type |s#0@@241|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@555) |s#0@@241|) (Lexicographic__Byte__Order.__default.maximumOpt $ly@@555 |s#0@@241|)))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |6097|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@555) |s#0@@241|))
)))
(assert (forall (($ly@@556 T@U) (|s#0@@242| T@U) ) (!  (=> (and (= (type $ly@@556) LayerTypeType) (= (type |s#0@@242|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximumOpt $ly@@556 |s#0@@242|) (Lexicographic__Byte__Order.__default.maximumOpt $LZ |s#0@@242|)))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |6098|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@556) |s#0@@242|))
)))
(assert  (=> true (forall (($ly@@557 T@U) (|s#0@@243| T@U) ) (!  (=> (and (and (= (type $ly@@557) LayerTypeType) (= (type |s#0@@243|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@243|) ($Is |s#0@@243| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|)) (U_2_bool (MapType0Select |s#0@@243| (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|))))) (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|)) (forall ((|y#0@@14| T@U) ) (!  (=> (= (type |y#0@@14|) (SeqType BoxType)) (=> (and ($Is |y#0@@14| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@243| ($Box |y#0@@14|)))) (Lexicographic__Byte__Order.__default.lte |y#0@@14| ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|))))))
 :qid |totalorderidfyLexicographicByteOrder.929:30|
 :skolemid |6099|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |y#0@@14| ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|)))))
 :pattern ( (MapType0Select |s#0@@243| ($Box |y#0@@14|)))
)))) (=> (Options.Option.None_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|)) (|Set#Equal| |s#0@@243| (|Set#Empty| BoxType)))) ($Is (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |6100|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt $ly@@557 |s#0@@243|))
))))
(assert (forall (($ly@@558 T@U) (|s#0@@244| T@U) ) (!  (=> (and (and (= (type $ly@@558) LayerTypeType) (= (type |s#0@@244|) (MapType0Type BoxType boolType))) ($Is |s#0@@244| (TSet (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@558 |s#0@@244|) true))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |6101|
 :pattern ( (|Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@558 |s#0@@244|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@559 T@U) (|s#0@@245| T@U) ) (!  (=> (and (and (= (type $ly@@559) LayerTypeType) (= (type |s#0@@245|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@245|) ($Is |s#0@@245| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@245| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@245|)) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@559) |s#0@@245|) (ite (|Set#Equal| |s#0@@245| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.maximum StartFuel_Lexicographic_Byte_Order._default.maximum |s#0@@245|)))))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |6102|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@559) |s#0@@245|))
))))
(assert  (=> true (forall (($ly@@560 T@U) (|s#0@@246| T@U) ) (!  (=> (and (and (= (type $ly@@560) LayerTypeType) (= (type |s#0@@246|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@246|)) ($Is |s#0@@246| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@246| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@246|))) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@560) (Lit |s#0@@246|)) (ite (|Set#Equal| |s#0@@246| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.maximum StartFuel_Lexicographic_Byte_Order._default.maximum (Lit |s#0@@246|))))))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :weight 3
 :skolemid |6103|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@560) (Lit |s#0@@246|)))
))))
(assert  (=> true (forall ((|a#0@@169| T@U) (|b#0@@119| T@U) ) (!  (=> (and (and (= (type |a#0@@169|) (SeqType BoxType)) (= (type |b#0@@119|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@169| |b#0@@119|) (and ($Is |a#0@@169| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@119| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |6104|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |a#0@@169| |b#0@@119|))
))))
(assert (forall ((|a#0@@170| T@U) (|b#0@@120| T@U) ) (!  (=> (and (and (= (type |a#0@@170|) (SeqType BoxType)) (= (type |b#0@@120|) (SeqType BoxType))) (and ($Is |a#0@@170| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@120| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.lt#requires| |a#0@@170| |b#0@@120|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |6105|
 :pattern ( (|Lexicographic__Byte__Order.__default.lt#requires| |a#0@@170| |b#0@@120|))
)))
(assert  (=> true (forall ((|a#0@@171| T@U) (|b#0@@121| T@U) ) (!  (=> (and (and (= (type |a#0@@171|) (SeqType BoxType)) (= (type |b#0@@121|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@171| |b#0@@121|) (and ($Is |a#0@@171| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@121| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@171| |b#0@@121|) (= (Lexicographic__Byte__Order.__default.lt |a#0@@171| |b#0@@121|)  (and (Lexicographic__Byte__Order.__default.lte |a#0@@171| |b#0@@121|) (not (|Seq#Equal| |a#0@@171| |b#0@@121|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |6106|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |a#0@@171| |b#0@@121|))
))))
(assert  (=> true (forall ((|a#0@@172| T@U) (|b#0@@122| T@U) ) (!  (=> (and (and (= (type |a#0@@172|) (SeqType BoxType)) (= (type |b#0@@122|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |a#0@@172|) (Lit |b#0@@122|)) (and ($Is |a#0@@172| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@122| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@172|) (Lit |b#0@@122|)) (= (Lexicographic__Byte__Order.__default.lt (Lit |a#0@@172|) (Lit |b#0@@122|))  (and (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@172|) (Lit |b#0@@122|)) (not (|Seq#Equal| |a#0@@172| |b#0@@122|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :weight 3
 :skolemid |6107|
 :pattern ( (Lexicographic__Byte__Order.__default.lt (Lit |a#0@@172|) (Lit |b#0@@122|)))
))))
(assert (forall ((arg0@@617 T@U) (arg1@@316 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.Min arg0@@617 arg1@@316)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.Min|
 :pattern ( (Lexicographic__Byte__Order.__default.Min arg0@@617 arg1@@316))
)))
(assert  (=> true (forall ((|a#0@@173| T@U) (|b#0@@123| T@U) ) (!  (=> (and (and (= (type |a#0@@173|) (SeqType BoxType)) (= (type |b#0@@123|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@173| |b#0@@123|) (and ($Is |a#0@@173| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@123| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.Min |a#0@@173| |b#0@@123|) (TSeq Tclass.NativeTypes.byte)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |6108|
 :pattern ( (Lexicographic__Byte__Order.__default.Min |a#0@@173| |b#0@@123|))
))))
(assert (forall ((|a#0@@174| T@U) (|b#0@@124| T@U) ) (!  (=> (and (and (= (type |a#0@@174|) (SeqType BoxType)) (= (type |b#0@@124|) (SeqType BoxType))) (and ($Is |a#0@@174| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@124| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.Min#requires| |a#0@@174| |b#0@@124|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |6109|
 :pattern ( (|Lexicographic__Byte__Order.__default.Min#requires| |a#0@@174| |b#0@@124|))
)))
(assert  (=> true (forall ((|a#0@@175| T@U) (|b#0@@125| T@U) ) (!  (=> (and (and (= (type |a#0@@175|) (SeqType BoxType)) (= (type |b#0@@125|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@175| |b#0@@125|) (and ($Is |a#0@@175| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@125| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@175| |b#0@@125|) (= (Lexicographic__Byte__Order.__default.Min |a#0@@175| |b#0@@125|) (ite (Lexicographic__Byte__Order.__default.lte |a#0@@175| |b#0@@125|) |a#0@@175| |b#0@@125|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |6110|
 :pattern ( (Lexicographic__Byte__Order.__default.Min |a#0@@175| |b#0@@125|))
))))
(assert  (=> true (forall ((|a#0@@176| T@U) (|b#0@@126| T@U) ) (!  (=> (and (and (= (type |a#0@@176|) (SeqType BoxType)) (= (type |b#0@@126|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| (Lit |a#0@@176|) (Lit |b#0@@126|)) (and ($Is |a#0@@176| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@126| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@176|) (Lit |b#0@@126|)) (= (Lexicographic__Byte__Order.__default.Min (Lit |a#0@@176|) (Lit |b#0@@126|)) (ite (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@176|) (Lit |b#0@@126|)) |a#0@@176| |b#0@@126|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :weight 3
 :skolemid |6111|
 :pattern ( (Lexicographic__Byte__Order.__default.Min (Lit |a#0@@176|) (Lit |b#0@@126|)))
))))
(assert (forall ((arg0@@618 T@U) (arg1@@317 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.Max arg0@@618 arg1@@317)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.Max|
 :pattern ( (Lexicographic__Byte__Order.__default.Max arg0@@618 arg1@@317))
)))
(assert  (=> true (forall ((|a#0@@177| T@U) (|b#0@@127| T@U) ) (!  (=> (and (and (= (type |a#0@@177|) (SeqType BoxType)) (= (type |b#0@@127|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@177| |b#0@@127|) (and ($Is |a#0@@177| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@127| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.Max |a#0@@177| |b#0@@127|) (TSeq Tclass.NativeTypes.byte)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |6112|
 :pattern ( (Lexicographic__Byte__Order.__default.Max |a#0@@177| |b#0@@127|))
))))
(assert (forall ((|a#0@@178| T@U) (|b#0@@128| T@U) ) (!  (=> (and (and (= (type |a#0@@178|) (SeqType BoxType)) (= (type |b#0@@128|) (SeqType BoxType))) (and ($Is |a#0@@178| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@128| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.Max#requires| |a#0@@178| |b#0@@128|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |6113|
 :pattern ( (|Lexicographic__Byte__Order.__default.Max#requires| |a#0@@178| |b#0@@128|))
)))
(assert  (=> true (forall ((|a#0@@179| T@U) (|b#0@@129| T@U) ) (!  (=> (and (and (= (type |a#0@@179|) (SeqType BoxType)) (= (type |b#0@@129|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@179| |b#0@@129|) (and ($Is |a#0@@179| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@129| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@179| |b#0@@129|) (= (Lexicographic__Byte__Order.__default.Max |a#0@@179| |b#0@@129|) (ite (Lexicographic__Byte__Order.__default.lte |a#0@@179| |b#0@@129|) |b#0@@129| |a#0@@179|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |6114|
 :pattern ( (Lexicographic__Byte__Order.__default.Max |a#0@@179| |b#0@@129|))
))))
(assert  (=> true (forall ((|a#0@@180| T@U) (|b#0@@130| T@U) ) (!  (=> (and (and (= (type |a#0@@180|) (SeqType BoxType)) (= (type |b#0@@130|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| (Lit |a#0@@180|) (Lit |b#0@@130|)) (and ($Is |a#0@@180| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@130| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@180|) (Lit |b#0@@130|)) (= (Lexicographic__Byte__Order.__default.Max (Lit |a#0@@180|) (Lit |b#0@@130|)) (ite (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@180|) (Lit |b#0@@130|)) |b#0@@130| |a#0@@180|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :weight 3
 :skolemid |6115|
 :pattern ( (Lexicographic__Byte__Order.__default.Max (Lit |a#0@@180|) (Lit |b#0@@130|)))
))))
(assert (forall (($ly@@561 T@U) (|run#0@@157| T@U) ) (!  (=> (and (= (type $ly@@561) LayerTypeType) (= (type |run#0@@157|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@561) |run#0@@157|) (Lexicographic__Byte__Order.__default.IsSorted $ly@@561 |run#0@@157|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |6116|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@561) |run#0@@157|))
)))
(assert (forall (($ly@@562 T@U) (|run#0@@158| T@U) ) (!  (=> (and (= (type $ly@@562) LayerTypeType) (= (type |run#0@@158|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsSorted $ly@@562 |run#0@@158|) (Lexicographic__Byte__Order.__default.IsSorted $LZ |run#0@@158|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |6117|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted (AsFuelBottom $ly@@562) |run#0@@158|))
)))
(assert  (=> true (forall (($ly@@563 T@U) (|run#0@@159| T@U) ) (!  (=> (and (and (= (type $ly@@563) LayerTypeType) (= (type |run#0@@159|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@159|) ($Is |run#0@@159| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (=> (= (|Seq#Length| |run#0@@159|) (LitInt 0)) (Lexicographic__Byte__Order.__default.IsSorted $ly@@563 |run#0@@159|)) (=> (= (|Seq#Length| |run#0@@159|) (LitInt 1)) (Lexicographic__Byte__Order.__default.IsSorted $ly@@563 |run#0@@159|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |6118|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted $ly@@563 |run#0@@159|))
))))
(assert (forall (($ly@@564 T@U) (|run#0@@160| T@U) ) (!  (=> (and (and (= (type $ly@@564) LayerTypeType) (= (type |run#0@@160|) (SeqType BoxType))) ($Is |run#0@@160| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@564 |run#0@@160|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |6119|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@564 |run#0@@160|))
)))
(assert  (=> true (forall (($ly@@565 T@U) (|run#0@@161| T@U) ) (!  (=> (and (and (= (type $ly@@565) LayerTypeType) (= (type |run#0@@161|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@161|) ($Is |run#0@@161| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@123| Int) (|j#0@@18| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@123|) (=> (INTERNAL_le_boogie |i#0@@123| |j#0@@18|) (=> (INTERNAL_lt_boogie |j#0@@18| (|Seq#Length| |run#0@@161|)) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@123|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@18|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |6121|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@18|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@123|)))
)) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@565) |run#0@@161|) (forall ((|i#0@@124| Int) (|j#0@@19| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@124|) (INTERNAL_le_boogie |i#0@@124| |j#0@@19|)) (INTERNAL_lt_boogie |j#0@@19| (|Seq#Length| |run#0@@161|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@124|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@19|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |6120|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@19|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@124|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |6122|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@565) |run#0@@161|))
))))
(assert  (=> true (forall (($ly@@566 T@U) (|run#0@@162| T@U) ) (!  (=> (and (and (= (type $ly@@566) LayerTypeType) (= (type |run#0@@162|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@162|)) ($Is |run#0@@162| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1@@36| Int) (|j#1@@7| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@36|) (=> (INTERNAL_le_boogie |i#1@@36| |j#1@@7|) (=> (INTERNAL_lt_boogie |j#1@@7| (|Seq#Length| (Lit |run#0@@162|))) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |i#1@@36|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |j#1@@7|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |6124|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |j#1@@7|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |i#1@@36|)))
)) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@566) (Lit |run#0@@162|)) (forall ((|i#1@@37| Int) (|j#1@@8| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@37|) (INTERNAL_le_boogie |i#1@@37| |j#1@@8|)) (INTERNAL_lt_boogie |j#1@@8| (|Seq#Length| (Lit |run#0@@162|)))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |i#1@@37|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |j#1@@8|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |6123|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |j#1@@8|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |i#1@@37|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :weight 3
 :skolemid |6125|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@566) (Lit |run#0@@162|)))
))))
(assert  (=> true (forall ((|run#0@@163| T@U) ) (!  (=> (and (= (type |run#0@@163|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@163|) ($Is |run#0@@163| (TSeq (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |6126|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@163|))
))))
(assert (forall ((|run#0@@164| T@U) ) (!  (=> (and (= (type |run#0@@164|) (SeqType BoxType)) ($Is |run#0@@164| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@164|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |6127|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@164|))
)))
(assert  (=> true (forall ((|run#0@@165| T@U) ) (!  (=> (and (= (type |run#0@@165|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@165|) ($Is |run#0@@165| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@125| Int) (|j#0@@20| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@125|) (=> (INTERNAL_lt_boogie |i#0@@125| |j#0@@20|) (=> (INTERNAL_lt_boogie |j#0@@20| (|Seq#Length| |run#0@@165|)) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@125|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@20|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |6129|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@20|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@125|)))
)) (= (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@165|) (forall ((|i#0@@126| Int) (|j#0@@21| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@126|) (INTERNAL_lt_boogie |i#0@@126| |j#0@@21|)) (INTERNAL_lt_boogie |j#0@@21| (|Seq#Length| |run#0@@165|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@126|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@21|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |6128|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@21|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@126|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |6130|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@165|))
))))
(assert  (=> true (forall ((|run#0@@166| T@U) ) (!  (=> (and (= (type |run#0@@166|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@166|)) ($Is |run#0@@166| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1@@38| Int) (|j#1@@9| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@38|) (=> (INTERNAL_lt_boogie |i#1@@38| |j#1@@9|) (=> (INTERNAL_lt_boogie |j#1@@9| (|Seq#Length| (Lit |run#0@@166|))) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |i#1@@38|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |j#1@@9|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |6132|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |j#1@@9|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |i#1@@38|)))
)) (= (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@166|)) (forall ((|i#1@@39| Int) (|j#1@@10| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@39|) (INTERNAL_lt_boogie |i#1@@39| |j#1@@10|)) (INTERNAL_lt_boogie |j#1@@10| (|Seq#Length| (Lit |run#0@@166|)))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |i#1@@39|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |j#1@@10|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |6131|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |j#1@@10|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |i#1@@39|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :weight 3
 :skolemid |6133|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@166|)))
))))
(assert (forall (($ly@@567 T@U) (|run#0@@167| T@U) ) (!  (=> (and (= (type $ly@@567) LayerTypeType) (= (type |run#0@@167|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@567) |run#0@@167|) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@567 |run#0@@167|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |6134|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@567) |run#0@@167|))
)))
(assert (forall (($ly@@568 T@U) (|run#0@@168| T@U) ) (!  (=> (and (= (type $ly@@568) LayerTypeType) (= (type |run#0@@168|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@568 |run#0@@168|) (Lexicographic__Byte__Order.__default.IsStrictlySorted $LZ |run#0@@168|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |6135|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@568) |run#0@@168|))
)))
(assert  (=> true (forall (($ly@@569 T@U) (|run#0@@169| T@U) ) (!  (=> (and (and (= (type $ly@@569) LayerTypeType) (= (type |run#0@@169|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@169|) ($Is |run#0@@169| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (and (=> (= (|Seq#Length| |run#0@@169|) (LitInt 0)) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@569 |run#0@@169|)) (=> (= (|Seq#Length| |run#0@@169|) (LitInt 1)) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@569 |run#0@@169|))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@569 |run#0@@169|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@169|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |6136|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@569 |run#0@@169|))
))))
(assert (forall (($ly@@570 T@U) (|run#0@@170| T@U) ) (!  (=> (and (and (= (type $ly@@570) LayerTypeType) (= (type |run#0@@170|) (SeqType BoxType))) ($Is |run#0@@170| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@570 |run#0@@170|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |6137|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@570 |run#0@@170|))
)))
(assert  (=> true (forall (($ly@@571 T@U) (|run#0@@171| T@U) ) (!  (=> (and (and (= (type $ly@@571) LayerTypeType) (= (type |run#0@@171|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@171|) ($Is |run#0@@171| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@171|) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@571) |run#0@@171|) (let ((|b#0@@131| (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@171|)))
(ite |b#0@@131| |b#0@@131| |b#0@@131|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |6138|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@571) |run#0@@171|))
))))
(assert  (=> true (forall (($ly@@572 T@U) (|run#0@@172| T@U) ) (!  (=> (and (and (= (type $ly@@572) LayerTypeType) (= (type |run#0@@172|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@172|)) ($Is |run#0@@172| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@172|)) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@572) (Lit |run#0@@172|)) (let ((|b#1@@6| (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@172|)))))))
(ite |b#1@@6| |b#1@@6| |b#1@@6|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :weight 3
 :skolemid |6139|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@572) (Lit |run#0@@172|)))
))))
(assert  (=> true (forall ((|e#0@@10| T@U) (|s#0@@247| T@U) ) (!  (=> (and (and (= (type |e#0@@10|) (SeqType BoxType)) (= (type |s#0@@247|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@10| |s#0@@247|) (and (and ($Is |e#0@@10| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@247| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@247|))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |6140|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@10| |s#0@@247|))
))))
(assert (forall ((|e#0@@11| T@U) (|s#0@@248| T@U) ) (!  (=> (and (and (= (type |e#0@@11|) (SeqType BoxType)) (= (type |s#0@@248|) (MapType0Type BoxType boolType))) (and ($Is |e#0@@11| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@248| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@11| |s#0@@248|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@248|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |6141|
 :pattern ( (|Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@11| |s#0@@248|))
)))
(assert  (=> true (forall ((|e#0@@12| T@U) (|s#0@@249| T@U) ) (!  (=> (and (and (= (type |e#0@@12|) (SeqType BoxType)) (= (type |s#0@@249|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@12| |s#0@@249|) (and (and ($Is |e#0@@12| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@249| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@249|))))) (and (=> (U_2_bool (MapType0Select |s#0@@249| ($Box |e#0@@12|))) (forall ((|e2#0@@1| T@U) ) (!  (=> (and (and (= (type |e2#0@@1|) (SeqType BoxType)) ($Is |e2#0@@1| (TSeq Tclass.NativeTypes.byte))) (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e2#0@@1|))) (not (|Seq#Equal| |e2#0@@1| |e#0@@12|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |e2#0@@1| |e#0@@12|))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |6143|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#0@@1| |e#0@@12|))
 :pattern ( (MapType0Select |s#0@@249| ($Box |e2#0@@1|)))
))) (= (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@12| |s#0@@249|)  (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e#0@@12|))) (forall ((|e2#0@@2| T@U) ) (!  (=> (= (type |e2#0@@2|) (SeqType BoxType)) (=> (and ($Is |e2#0@@2| (TSeq Tclass.NativeTypes.byte)) (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e2#0@@2|))) (not (|Seq#Equal| |e2#0@@2| |e#0@@12|)))) (Lexicographic__Byte__Order.__default.lt |e2#0@@2| |e#0@@12|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |6142|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#0@@2| |e#0@@12|))
 :pattern ( (MapType0Select |s#0@@249| ($Box |e2#0@@2|)))
))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |6144|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@12| |s#0@@249|))
))))
(assert  (=> true (forall ((|e#0@@13| T@U) (|s#0@@250| T@U) ) (!  (=> (and (and (= (type |e#0@@13|) (SeqType BoxType)) (= (type |s#0@@250|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (Lit |e#0@@13|) (Lit |s#0@@250|)) (and (and ($Is |e#0@@13| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@250| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@250|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box (Lit |e#0@@13|)))) (forall ((|e2#1@@1| T@U) ) (!  (=> (and (and (= (type |e2#1@@1|) (SeqType BoxType)) ($Is |e2#1@@1| (TSeq Tclass.NativeTypes.byte))) (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box |e2#1@@1|))) (not (|Seq#Equal| |e2#1@@1| |e#0@@13|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |e2#1@@1| (Lit |e#0@@13|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |6146|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#1@@1| |e#0@@13|))
 :pattern ( (MapType0Select |s#0@@250| ($Box |e2#1@@1|)))
))) (= (Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@13|) (Lit |s#0@@250|))  (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box (Lit |e#0@@13|)))) (forall ((|e2#1@@2| T@U) ) (!  (=> (= (type |e2#1@@2|) (SeqType BoxType)) (=> (and ($Is |e2#1@@2| (TSeq Tclass.NativeTypes.byte)) (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box |e2#1@@2|))) (not (|Seq#Equal| |e2#1@@2| |e#0@@13|)))) (Lexicographic__Byte__Order.__default.lt |e2#1@@2| (Lit |e#0@@13|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |6145|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#1@@2| |e#0@@13|))
 :pattern ( (MapType0Select |s#0@@250| ($Box |e2#1@@2|)))
))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :weight 3
 :skolemid |6147|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@13|) (Lit |s#0@@250|)))
))))
(assert (forall ((arg0@@619 T@U) (arg1@@318 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SortSet arg0@@619 arg1@@318)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.SortSet|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet arg0@@619 arg1@@318))
)))
(assert (forall (($ly@@573 T@U) (|s#0@@251| T@U) ) (!  (=> (and (= (type $ly@@573) LayerTypeType) (= (type |s#0@@251|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@573) |s#0@@251|) (Lexicographic__Byte__Order.__default.SortSet $ly@@573 |s#0@@251|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |6148|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@573) |s#0@@251|))
)))
(assert (forall (($ly@@574 T@U) (|s#0@@252| T@U) ) (!  (=> (and (= (type $ly@@574) LayerTypeType) (= (type |s#0@@252|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.SortSet $ly@@574 |s#0@@252|) (Lexicographic__Byte__Order.__default.SortSet $LZ |s#0@@252|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |6149|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet (AsFuelBottom $ly@@574) |s#0@@252|))
)))
(assert  (=> true (forall (($ly@@575 T@U) (|s#0@@253| T@U) ) (!  (=> (and (and (= (type $ly@@575) LayerTypeType) (= (type |s#0@@253|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@253|) ($Is |s#0@@253| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (= (|Set#Card| |s#0@@253|) (|Seq#Length| (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|))) (forall ((|t#0@@14| T@U) ) (!  (=> (and (= (type |t#0@@14|) (SeqType BoxType)) ($Is |t#0@@14| (TSeq Tclass.NativeTypes.byte))) (= (U_2_bool (MapType0Select |s#0@@253| ($Box |t#0@@14|))) (|Seq#Contains| (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|) ($Box |t#0@@14|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.239:20|
 :skolemid |6150|
 :pattern ( (|Seq#Contains| (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|) ($Box |t#0@@14|)))
 :pattern ( (MapType0Select |s#0@@253| ($Box |t#0@@14|)))
))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|))) ($Is (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|) (TSeq (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |6151|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet $ly@@575 |s#0@@253|))
))))
(assert (forall (($ly@@576 T@U) ($Heap@@80 T@U) (|s#0@@254| T@U) ) (!  (=> (and (and (and (= (type $ly@@576) LayerTypeType) (= (type $Heap@@80) (MapType0Type refType MapType1Type))) (= (type |s#0@@254|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@80) ($Is |s#0@@254| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@576 |s#0@@254|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |6152|
 :pattern ( (|Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@576 |s#0@@254|) ($IsGoodHeap $Heap@@80))
)))
(assert (forall ((arg0@@620 T@U) ) (! (= (type (|$let#40_e| arg0@@620)) (SeqType BoxType))
 :qid |funType:$let#40_e|
 :pattern ( (|$let#40_e| arg0@@620))
)))
(assert (forall ((s@@56 T@U) ) (!  (=> (and (= (type s@@56) (MapType0Type BoxType boolType)) (|$let#40$canCall| s@@56)) (and ($Is (|$let#40_e| s@@56) (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.BiggestInSet (|$let#40_e| s@@56) s@@56)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.249:7|
 :skolemid |6153|
 :pattern ( (|$let#40_e| s@@56))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@577 T@U) ($Heap@@81 T@U) (|s#0@@255| T@U) ) (!  (=> (and (and (and (= (type $ly@@577) LayerTypeType) (= (type $Heap@@81) (MapType0Type refType MapType1Type))) (= (type |s#0@@255|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@255|) (and ($IsGoodHeap $Heap@@81) ($Is |s#0@@255| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (=> (not (= (|Set#Card| |s#0@@255|) (LitInt 0))) (and (|$let#40$canCall| |s#0@@255|) (|Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@255| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#40_e| |s#0@@255|))))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted6) MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@577) |s#0@@255|) (ite (= (|Set#Card| |s#0@@255|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@14| (|$let#40_e| |s#0@@255|)))
(|Seq#Append| (Lexicographic__Byte__Order.__default.SortSet $ly@@577 (|Set#Difference| |s#0@@255| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#0@@14|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#0@@14|)))))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |6154|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@577) |s#0@@255|) ($IsGoodHeap $Heap@@81))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@578 T@U) ($Heap@@82 T@U) (|s#0@@256| T@U) ) (!  (=> (and (and (and (= (type $ly@@578) LayerTypeType) (= (type $Heap@@82) (MapType0Type refType MapType1Type))) (= (type |s#0@@256|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| (Lit |s#0@@256|)) (and ($IsGoodHeap $Heap@@82) ($Is |s#0@@256| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@256|)) (LitInt 0))) (and (|$let#40$canCall| (Lit |s#0@@256|)) (|Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@256| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#40_e| (Lit |s#0@@256|)))))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted7) MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@578) (Lit |s#0@@256|)) (ite (= (|Set#Card| (Lit |s#0@@256|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@1| (|$let#40_e| (Lit |s#0@@256|))))
(|Seq#Append| (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@578) (|Set#Difference| |s#0@@256| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#1@@1|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#1@@1|)))))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :weight 3
 :skolemid |6155|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@578) (Lit |s#0@@256|)) ($IsGoodHeap $Heap@@82))
))))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order.__default) Tagclass.Upperbounded__Lexicographic__Byte__Order.__default))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@175 T@U) ) (!  (=> (and (= (type bx@@175) BoxType) ($IsBox bx@@175 Tclass.Upperbounded__Lexicographic__Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@175)) bx@@175) ($Is ($Unbox refType bx@@175) Tclass.Upperbounded__Lexicographic__Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |6156|
 :pattern ( ($IsBox bx@@175 Tclass.Upperbounded__Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@61 T@U) ) (!  (=> (= (type $o@@61) refType) (= ($Is $o@@61 Tclass.Upperbounded__Lexicographic__Byte__Order.__default)  (or (= $o@@61 null) (= (dtype $o@@61) Tclass.Upperbounded__Lexicographic__Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |6157|
 :pattern ( ($Is $o@@61 Tclass.Upperbounded__Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@62 T@U) ($h@@115 T@U) ) (!  (=> (and (= (type $o@@62) refType) (= (type $h@@115) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@62 Tclass.Upperbounded__Lexicographic__Byte__Order.__default $h@@115)  (or (= $o@@62 null) (U_2_bool (MapType1Select (MapType0Select $h@@115 $o@@62) alloc)))))
 :qid |unknown.0:0|
 :skolemid |6158|
 :pattern ( ($IsAlloc $o@@62 Tclass.Upperbounded__Lexicographic__Byte__Order.__default $h@@115))
)))
(assert  (=> true (forall ((|b#0@@132| T@U) ) (!  (=> (and (= (type |b#0@@132|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@132|) ($Is |b#0@@132| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |totalorderidfy.1212:31|
 :skolemid |6159|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@132|))
))))
(assert (forall ((|b#0@@133| T@U) ) (!  (=> (and (= (type |b#0@@133|) DatatypeTypeType) ($Is |b#0@@133| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@133|) true))
 :qid |totalorderidfy.1212:31|
 :skolemid |6160|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@133|))
)))
(assert  (and (forall ((arg0@@621 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.Element.e arg0@@621)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.Element.e|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.e arg0@@621))
)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType)))
(assert  (=> true (forall ((|b#0@@134| T@U) ) (!  (=> (and (= (type |b#0@@134|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@134|) ($Is |b#0@@134| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@134|) (=> (= (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@134|)) (LitInt 0)) (forall ((|a#0@@181| T@U) ) (!  (=> (and (= (type |a#0@@181|) DatatypeTypeType) ($Is |a#0@@181| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@181|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@181|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@134| |a#0@@181|))))
 :qid |totalorderidfy.1216:16|
 :skolemid |6162|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@181|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@181|))
)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@134|)  (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@134|) (= (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@134|)) (LitInt 0))) (forall ((|a#0@@182| T@U) ) (!  (=> (= (type |a#0@@182|) DatatypeTypeType) (=> (and ($Is |a#0@@182| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@182|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@182|)))
 :qid |totalorderidfy.1216:16|
 :skolemid |6161|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@182|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@182|))
))))))
 :qid |totalorderidfy.1212:31|
 :skolemid |6163|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@134|))
))))
(assert  (=> true (forall ((|b#0@@135| T@U) ) (!  (=> (and (= (type |b#0@@135|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (Lit |b#0@@135|)) ($Is |b#0@@135| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@135|))))) (=> (= (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@135|)))) (LitInt 0)) (forall ((|a#1@@6| T@U) ) (!  (=> (and (= (type |a#1@@6|) DatatypeTypeType) ($Is |a#1@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#1@@6|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@6|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |b#0@@135|) |a#1@@6|))))
 :qid |totalorderidfy.1216:16|
 :skolemid |6165|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@135| |a#1@@6|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@6|))
)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@135|))  (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@135|)) (= (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@135|)))) (LitInt 0))) (forall ((|a#1@@7| T@U) ) (!  (=> (= (type |a#1@@7|) DatatypeTypeType) (=> (and ($Is |a#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@7|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |b#0@@135|) |a#1@@7|)))
 :qid |totalorderidfy.1216:16|
 :skolemid |6164|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@135| |a#1@@7|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@7|))
))))))
 :qid |totalorderidfy.1212:31|
 :weight 3
 :skolemid |6166|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@135|)))
))))
(assert (= (type Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) DatatypeTypeType))
(assert  (=> true (=> true (and (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) ($Is Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))))
(assert (forall (($Heap@@83 T@U) ) (!  (=> (and (= (type $Heap@@83) (MapType0Type refType MapType1Type)) ($IsGoodHeap $Heap@@83)) (= |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| true))
 :qid |totalorderidfy.1247:12|
 :skolemid |6167|
 :pattern ( |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| ($IsGoodHeap $Heap@@83))
)))
(assert (= (type |$let#43_b|) DatatypeTypeType))
(assert  (=> |$let#43$canCall| (and ($Is |$let#43_b| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |$let#43_b|))))
(assert  (=> true (forall (($Heap@@84 T@U) ) (!  (=> (and (= (type $Heap@@84) (MapType0Type refType MapType1Type)) (or |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@84))) (and |$let#43$canCall| (= Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#0@@136| |$let#43_b|))
|b#0@@136|))))
 :qid |totalorderidfy.1247:12|
 :skolemid |6168|
 :pattern ( Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@84))
))))
(assert  (=> true (forall (($Heap@@85 T@U) ) (!  (=> (and (= (type $Heap@@85) (MapType0Type refType MapType1Type)) (or |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@85))) (and |$let#43$canCall| (= Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#1@@7| |$let#43_b|))
|b#1@@7|))))
 :qid |totalorderidfy.1247:12|
 :weight 3
 :skolemid |6169|
 :pattern ( Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@85))
))))
(assert (= (type Upperbounded__Lexicographic__Byte__Order.__default.SomeElement) DatatypeTypeType))
(assert  (=> true (=> true ($Is Upperbounded__Lexicographic__Byte__Order.__default.SomeElement Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
(assert (= |Upperbounded__Lexicographic__Byte__Order.__default.SomeElement#requires| true))
(assert (= (type |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) DatatypeTypeType))
(assert  (=> true (=> true (= Upperbounded__Lexicographic__Byte__Order.__default.SomeElement (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
(assert  (=> true (=> true (= Upperbounded__Lexicographic__Byte__Order.__default.SomeElement (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
(assert (forall ((arg0@@622 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.ToElements arg0@@622)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.ToElements|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements arg0@@622))
)))
(assert  (=> true (forall ((|es#0| T@U) ) (!  (=> (and (= (type |es#0|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| |es#0|) ($Is |es#0| (TSeq (TSeq Tclass.NativeTypes.byte))))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:23|
 :skolemid |6170|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0|))
))))
(assert (forall (($Heap@@86 T@U) (|es#0@@0| T@U) ) (!  (=> (and (and (= (type $Heap@@86) (MapType0Type refType MapType1Type)) (= (type |es#0@@0|) (SeqType BoxType))) (and ($IsGoodHeap $Heap@@86) ($Is |es#0@@0| (TSeq (TSeq Tclass.NativeTypes.byte))))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| |es#0@@0|) true))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :skolemid |6171|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| |es#0@@0|) ($IsGoodHeap $Heap@@86))
)))
(assert (forall ((arg0@@623 T@U) ) (! (= (type (|lambda#327| arg0@@623)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#327|
 :pattern ( (|lambda#327| arg0@@623))
)))
(assert  (=> true (forall (($Heap@@87 T@U) (|es#0@@1| T@U) ) (!  (=> (and (and (= (type $Heap@@87) (MapType0Type refType MapType1Type)) (= (type |es#0@@1|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| |es#0@@1|) (and ($IsGoodHeap $Heap@@87) ($Is |es#0@@1| (TSeq (TSeq Tclass.NativeTypes.byte)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0@@1|) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@87 (|Seq#Length| |es#0@@1|) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#327| |es#0@@1|) (|lambda#32| TInt 0 (|Seq#Length| |es#0@@1|)) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :skolemid |6172|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0@@1|) ($IsGoodHeap $Heap@@87))
))))
(assert  (=> true (forall (($Heap@@88 T@U) (|es#0@@2| T@U) ) (!  (=> (and (and (= (type $Heap@@88) (MapType0Type refType MapType1Type)) (= (type |es#0@@2|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| (Lit |es#0@@2|)) (and ($IsGoodHeap $Heap@@88) ($Is |es#0@@2| (TSeq (TSeq Tclass.NativeTypes.byte)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ToElements (Lit |es#0@@2|)) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@88 (|Seq#Length| (Lit |es#0@@2|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#327| (Lit |es#0@@2|)) (|lambda#32| TInt 0 (|Seq#Length| (Lit |es#0@@2|))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :weight 3
 :skolemid |6173|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements (Lit |es#0@@2|)) ($IsGoodHeap $Heap@@88))
))))
(assert  (=> true (forall ((|a#0@@183| T@U) (|b#0@@137| T@U) ) (!  (=> (and (and (= (type |a#0@@183|) DatatypeTypeType) (= (type |b#0@@137|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@183| |b#0@@137|) (and ($Is |a#0@@183| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@137| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (and (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|)) (or (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|))) (=> (and (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@183| |b#0@@137|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |6174|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|))
))))
(assert (forall ((|a#0@@184| T@U) (|b#0@@138| T@U) ) (!  (=> (and (and (= (type |a#0@@184|) DatatypeTypeType) (= (type |b#0@@138|) DatatypeTypeType)) (and ($Is |a#0@@184| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@138| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| |a#0@@184| |b#0@@138|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |6175|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| |a#0@@184| |b#0@@138|))
)))
(assert  (=> true (forall ((|a#0@@185| T@U) (|b#0@@139| T@U) ) (!  (=> (and (and (= (type |a#0@@185|) DatatypeTypeType) (= (type |b#0@@139|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@185| |b#0@@139|) (and ($Is |a#0@@185| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@139| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@139|)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@185|) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@139|) (|Lexicographic__Byte__Order.__default.lte#canCall| (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@139|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@185| |b#0@@139|)  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@139|) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@139|)) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@139|)))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |6176|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@185| |b#0@@139|))
))))
(assert  (=> true (forall ((|a#0@@186| T@U) (|b#0@@140| T@U) ) (!  (=> (and (and (= (type |a#0@@186|) DatatypeTypeType) (= (type |b#0@@140|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@186|) (Lit |b#0@@140|)) (and ($Is |a#0@@186| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@140| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@140|)))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@186|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@140|))))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@186|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@140|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@186|) (Lit |b#0@@140|)) (U_2_bool (Lit (bool_2_U  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@140|)) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@186|)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@140|))) (Lexicographic__Byte__Order.__default.lte (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@186|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@140|))))))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :weight 3
 :skolemid |6177|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@186|) (Lit |b#0@@140|)))
))))
(assert  (=> true (forall ((|a#0@@187| T@U) (|b#0@@141| T@U) ) (!  (=> (and (and (= (type |a#0@@187|) DatatypeTypeType) (= (type |b#0@@141|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@187| |b#0@@141|) (and ($Is |a#0@@187| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@141| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |6178|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@187| |b#0@@141|))
))))
(assert (forall ((|a#0@@188| T@U) (|b#0@@142| T@U) ) (!  (=> (and (and (= (type |a#0@@188|) DatatypeTypeType) (= (type |b#0@@142|) DatatypeTypeType)) (and ($Is |a#0@@188| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@142| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@188| |b#0@@142|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |6179|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@188| |b#0@@142|))
)))
(assert  (=> true (forall ((|a#0@@189| T@U) (|b#0@@143| T@U) ) (!  (=> (and (and (= (type |a#0@@189|) DatatypeTypeType) (= (type |b#0@@143|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@189| |b#0@@143|) (and ($Is |a#0@@189| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@143| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@143|)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@189|) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@143|) (|Lexicographic__Byte__Order.__default.lte#canCall| (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@143|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@189| |b#0@@143|)  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@143|) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@143|)) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@143|)))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |6180|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@189| |b#0@@143|))
))))
(assert  (=> true (forall ((|a#0@@190| T@U) (|b#0@@144| T@U) ) (!  (=> (and (and (= (type |a#0@@190|) DatatypeTypeType) (= (type |b#0@@144|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| (Lit |a#0@@190|) (Lit |b#0@@144|)) (and ($Is |a#0@@190| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@144| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@144|)))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@190|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@144|))))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@190|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@144|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@190|) (Lit |b#0@@144|)) (U_2_bool (Lit (bool_2_U  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@144|)) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@190|)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@144|))) (Lexicographic__Byte__Order.__default.lte (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@190|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@144|))))))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :weight 3
 :skolemid |6181|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@190|) (Lit |b#0@@144|)))
))))
(assert (forall (($ly@@579 T@U) (|run#0@@173| T@U) (|needle#0@@69| T@U) ) (!  (=> (and (and (= (type $ly@@579) LayerTypeType) (= (type |run#0@@173|) (SeqType BoxType))) (= (type |needle#0@@69|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@579) |run#0@@173| |needle#0@@69|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@579 |run#0@@173| |needle#0@@69|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |6182|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@579) |run#0@@173| |needle#0@@69|))
)))
(assert (forall (($ly@@580 T@U) (|run#0@@174| T@U) (|needle#0@@70| T@U) ) (!  (=> (and (and (= (type $ly@@580) LayerTypeType) (= (type |run#0@@174|) (SeqType BoxType))) (= (type |needle#0@@70|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@580 |run#0@@174| |needle#0@@70|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $LZ |run#0@@174| |needle#0@@70|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |6183|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@580) |run#0@@174| |needle#0@@70|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@581 T@U) (|run#0@@175| T@U) (|needle#0@@71| T@U) ) (!  (=> (and (and (and (= (type $ly@@581) LayerTypeType) (= (type |run#0@@175|) (SeqType BoxType))) (= (type |needle#0@@71|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@175| |needle#0@@71|) (and (and ($Is |run#0@@175| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@71| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@175|)))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |6184|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@581 |run#0@@175| |needle#0@@71|))
))))
(assert (forall (($ly@@582 T@U) (|run#0@@176| T@U) (|needle#0@@72| T@U) ) (!  (=> (and (and (and (= (type $ly@@582) LayerTypeType) (= (type |run#0@@176|) (SeqType BoxType))) (= (type |needle#0@@72|) DatatypeTypeType)) (and ($Is |run#0@@176| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@72| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@582 |run#0@@176| |needle#0@@72|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@176|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |6185|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@582 |run#0@@176| |needle#0@@72|))
)))
(assert  (=> true (forall (($ly@@583 T@U) (|run#0@@177| T@U) (|needle#0@@73| T@U) ) (!  (=> (and (and (and (= (type $ly@@583) LayerTypeType) (= (type |run#0@@177|) (SeqType BoxType))) (= (type |needle#0@@73|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@177| |needle#0@@73|) (and (and ($Is |run#0@@177| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@73| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@177|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@177|) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@177|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@177| (LitInt 1)) |needle#0@@73|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@583) |run#0@@177| |needle#0@@73|) (ite  (or (= (|Seq#Length| |run#0@@177|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@583 (|Seq#Drop| |run#0@@177| (LitInt 1)) |needle#0@@73|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |6186|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@583) |run#0@@177| |needle#0@@73|))
))))
(assert  (=> true (forall (($ly@@584 T@U) (|run#0@@178| T@U) (|needle#0@@74| T@U) ) (!  (=> (and (and (and (= (type $ly@@584) LayerTypeType) (= (type |run#0@@178|) (SeqType BoxType))) (= (type |needle#0@@74|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@178|) (Lit |needle#0@@74|)) (and (and ($Is |run#0@@178| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@74| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@178|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@178|) (LitInt 1))) (Lit |needle#0@@74|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@584) (Lit |run#0@@178|) (Lit |needle#0@@74|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@584) (Lit (|Seq#Drop| (Lit |run#0@@178|) (LitInt 1))) (Lit |needle#0@@74|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :weight 3
 :skolemid |6187|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@584) (Lit |run#0@@178|) (Lit |needle#0@@74|)))
))))
(assert  (=> true (forall ((|run#0@@179| T@U) (|needle#0@@75| T@U) ) (!  (=> (and (and (= (type |run#0@@179|) (SeqType BoxType)) (= (type |needle#0@@75|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@179| |needle#0@@75|) (and (and ($Is |run#0@@179| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@75| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@179|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|) (|Seq#Length| |run#0@@179|))) (forall ((|i#0@@127| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@127|) (INTERNAL_le_boogie |i#0@@127| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#0@@127|)) |needle#0@@75|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.362:20|
 :skolemid |6188|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#0@@127|)))
))) (forall ((|i#1@@40| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|) |i#1@@40|) (INTERNAL_lt_boogie |i#1@@40| (|Seq#Length| |run#0@@179|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@75| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#1@@40|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.363:20|
 :skolemid |6189|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#1@@40|)))
))) (=> (|Seq#Contains| |run#0@@179| ($Box |needle#0@@75|)) (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))) |needle#0@@75|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |6190|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))
))))
(assert (forall ((|run#0@@180| T@U) (|needle#0@@76| T@U) ) (!  (=> (and (and (= (type |run#0@@180|) (SeqType BoxType)) (= (type |needle#0@@76|) DatatypeTypeType)) (and ($Is |run#0@@180| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@76| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@180| |needle#0@@76|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@180|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |6191|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@180| |needle#0@@76|))
)))
(assert  (=> true (forall ((|run#0@@181| T@U) (|needle#0@@77| T@U) ) (!  (=> (and (and (= (type |run#0@@181|) (SeqType BoxType)) (= (type |needle#0@@77|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@181| |needle#0@@77|) (and (and ($Is |run#0@@181| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@77| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@181|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@181| |needle#0@@77|) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@181| |needle#0@@77|) (let ((|out#0@@3| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@181| |needle#0@@77|)))
|out#0@@3|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |6192|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@181| |needle#0@@77|))
))))
(assert  (=> true (forall ((|run#0@@182| T@U) (|needle#0@@78| T@U) ) (!  (=> (and (and (= (type |run#0@@182|) (SeqType BoxType)) (= (type |needle#0@@78|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@182|) (Lit |needle#0@@78|)) (and (and ($Is |run#0@@182| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@78| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@182|))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@182|) (Lit |needle#0@@78|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@182|) (Lit |needle#0@@78|)) (let ((|out#1@@1| (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@182|) (Lit |needle#0@@78|)))))
|out#1@@1|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :weight 3
 :skolemid |6193|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@182|) (Lit |needle#0@@78|)))
))))
(assert (forall (($ly@@585 T@U) (|run#0@@183| T@U) (|needle#0@@79| T@U) ) (!  (=> (and (and (= (type $ly@@585) LayerTypeType) (= (type |run#0@@183|) (SeqType BoxType))) (= (type |needle#0@@79|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@585) |run#0@@183| |needle#0@@79|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@585 |run#0@@183| |needle#0@@79|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |6194|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@585) |run#0@@183| |needle#0@@79|))
)))
(assert (forall (($ly@@586 T@U) (|run#0@@184| T@U) (|needle#0@@80| T@U) ) (!  (=> (and (and (= (type $ly@@586) LayerTypeType) (= (type |run#0@@184|) (SeqType BoxType))) (= (type |needle#0@@80|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@586 |run#0@@184| |needle#0@@80|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $LZ |run#0@@184| |needle#0@@80|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |6195|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt (AsFuelBottom $ly@@586) |run#0@@184| |needle#0@@80|))
)))
(assert  (=> true (forall (($ly@@587 T@U) (|run#0@@185| T@U) (|needle#0@@81| T@U) ) (!  (=> (and (and (and (= (type $ly@@587) LayerTypeType) (= (type |run#0@@185|) (SeqType BoxType))) (= (type |needle#0@@81|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@185| |needle#0@@81|) (and (and ($Is |run#0@@185| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@81| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@185|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|) (|Seq#Length| |run#0@@185|))) (forall ((|i#0@@128| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@128|) (INTERNAL_le_boogie |i#0@@128| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#0@@128|)) |needle#0@@81|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.461:20|
 :skolemid |6196|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#0@@128|)))
))) (forall ((|i#1@@41| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|) |i#1@@41|) (INTERNAL_lt_boogie |i#1@@41| (|Seq#Length| |run#0@@185|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@81| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#1@@41|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.462:20|
 :skolemid |6197|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#1@@41|)))
))) (=> (|Seq#Contains| |run#0@@185| ($Box |needle#0@@81|)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|) 1) (|Seq#Length| |run#0@@185|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| (INTERNAL_add_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|) 1))) |needle#0@@81|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |6198|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@587 |run#0@@185| |needle#0@@81|))
))))
(assert (forall (($ly@@588 T@U) (|run#0@@186| T@U) (|needle#0@@82| T@U) ) (!  (=> (and (and (and (= (type $ly@@588) LayerTypeType) (= (type |run#0@@186|) (SeqType BoxType))) (= (type |needle#0@@82|) DatatypeTypeType)) (and ($Is |run#0@@186| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@82| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@588 |run#0@@186| |needle#0@@82|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@186|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |6199|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@588 |run#0@@186| |needle#0@@82|))
)))
(assert  (and (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@589 T@U) (|run#0@@187| T@U) (|needle#0@@83| T@U) ) (!  (=> (and (and (and (= (type $ly@@589) LayerTypeType) (= (type |run#0@@187|) (SeqType BoxType))) (= (type |needle#0@@83|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@187| |needle#0@@83|) (and (and ($Is |run#0@@187| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@83| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@187|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@187|) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@187|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@187| (LitInt 1)) |needle#0@@83|))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@589) |run#0@@187| |needle#0@@83|) (ite  (or (= (|Seq#Length| |run#0@@187|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@589 (|Seq#Drop| |run#0@@187| (LitInt 1)) |needle#0@@83|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |6200|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@589) |run#0@@187| |needle#0@@83|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@590 T@U) (|run#0@@188| T@U) (|needle#0@@84| T@U) ) (!  (=> (and (and (and (= (type $ly@@590) LayerTypeType) (= (type |run#0@@188|) (SeqType BoxType))) (= (type |needle#0@@84|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@188|) (Lit |needle#0@@84|)) (and (and ($Is |run#0@@188| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@84| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@188|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@188|) (LitInt 1))) (Lit |needle#0@@84|)))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@590) (Lit |run#0@@188|) (Lit |needle#0@@84|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@590) (Lit (|Seq#Drop| (Lit |run#0@@188|) (LitInt 1))) (Lit |needle#0@@84|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :weight 3
 :skolemid |6201|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@590) (Lit |run#0@@188|) (Lit |needle#0@@84|)))
))))
(assert (forall (($ly@@591 T@U) (|run#0@@189| T@U) (|needle#0@@85| T@U) ) (!  (=> (and (and (= (type $ly@@591) LayerTypeType) (= (type |run#0@@189|) (SeqType BoxType))) (= (type |needle#0@@85|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@591) |run#0@@189| |needle#0@@85|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@591 |run#0@@189| |needle#0@@85|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |6202|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@591) |run#0@@189| |needle#0@@85|))
)))
(assert (forall (($ly@@592 T@U) (|run#0@@190| T@U) (|needle#0@@86| T@U) ) (!  (=> (and (and (= (type $ly@@592) LayerTypeType) (= (type |run#0@@190|) (SeqType BoxType))) (= (type |needle#0@@86|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@592 |run#0@@190| |needle#0@@86|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@190| |needle#0@@86|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |6203|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@592) |run#0@@190| |needle#0@@86|))
)))
(assert  (=> true (forall (($ly@@593 T@U) (|run#0@@191| T@U) (|needle#0@@87| T@U) ) (!  (=> (and (and (and (= (type $ly@@593) LayerTypeType) (= (type |run#0@@191|) (SeqType BoxType))) (= (type |needle#0@@87|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@191| |needle#0@@87|) (and (and ($Is |run#0@@191| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@87| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@191|)))) (and (and (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@593 |run#0@@191| |needle#0@@87|) (|Seq#Length| |run#0@@191|)) (forall ((|i#0@@129| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@129|) (INTERNAL_lt_boogie |i#0@@129| (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@593 |run#0@@191| |needle#0@@87|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#0@@129|)) |needle#0@@87|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.495:20|
 :skolemid |6204|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#0@@129|)))
))) (forall ((|i#1@@42| Int) ) (!  (=> (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@593 |run#0@@191| |needle#0@@87|) |i#1@@42|) (INTERNAL_lt_boogie |i#1@@42| (|Seq#Length| |run#0@@191|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@87| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#1@@42|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.496:20|
 :skolemid |6205|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#1@@42|)))
))) (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@593 |run#0@@191| |needle#0@@87|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |6206|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@593 |run#0@@191| |needle#0@@87|))
))))
(assert (forall (($ly@@594 T@U) (|run#0@@192| T@U) (|needle#0@@88| T@U) ) (!  (=> (and (and (and (= (type $ly@@594) LayerTypeType) (= (type |run#0@@192|) (SeqType BoxType))) (= (type |needle#0@@88|) DatatypeTypeType)) (and ($Is |run#0@@192| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@88| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@594 |run#0@@192| |needle#0@@88|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@192|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |6207|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@594 |run#0@@192| |needle#0@@88|))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@595 T@U) (|run#0@@193| T@U) (|needle#0@@89| T@U) ) (!  (=> (and (and (and (= (type $ly@@595) LayerTypeType) (= (type |run#0@@193|) (SeqType BoxType))) (= (type |needle#0@@89|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@193| |needle#0@@89|) (and (and ($Is |run#0@@193| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@89| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@193|)))) (and (=> (not (= (|Seq#Length| |run#0@@193|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|)) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|)) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) |needle#0@@89|))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@595) |run#0@@193| |needle#0@@89|) (ite (= (|Seq#Length| |run#0@@193|) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|) (|Seq#Length| |run#0@@193|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@595 (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) |needle#0@@89|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |6208|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@595) |run#0@@193| |needle#0@@89|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@596 T@U) (|run#0@@194| T@U) (|needle#0@@90| T@U) ) (!  (=> (and (and (and (= (type $ly@@596) LayerTypeType) (= (type |run#0@@194|) (SeqType BoxType))) (= (type |needle#0@@90|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@194|) (Lit |needle#0@@90|)) (and (and ($Is |run#0@@194| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@90| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@194|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@194|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|))) (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|))) (Lit |needle#0@@90|)))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@596) (Lit |run#0@@194|) (Lit |needle#0@@90|)) (ite (= (|Seq#Length| (Lit |run#0@@194|)) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|)) (|Seq#Length| (Lit |run#0@@194|)) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@596) (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|))) (Lit |needle#0@@90|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :weight 3
 :skolemid |6209|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@596) (Lit |run#0@@194|) (Lit |needle#0@@90|)))
))))
(assert (forall (($ly@@597 T@U) (|s#0@@257| T@U) (|key#0@@138| T@U) (|lo#0@@39| Int) (|hi#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@597) LayerTypeType) (= (type |s#0@@257|) (SeqType BoxType))) (= (type |key#0@@138|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@597) |s#0@@257| |key#0@@138| |lo#0@@39| |hi#0@@27|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@597 |s#0@@257| |key#0@@138| |lo#0@@39| |hi#0@@27|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |6210|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@597) |s#0@@257| |key#0@@138| |lo#0@@39| |hi#0@@27|))
)))
(assert (forall (($ly@@598 T@U) (|s#0@@258| T@U) (|key#0@@139| T@U) (|lo#0@@40| Int) (|hi#0@@28| Int) ) (!  (=> (and (and (= (type $ly@@598) LayerTypeType) (= (type |s#0@@258|) (SeqType BoxType))) (= (type |key#0@@139|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@598 |s#0@@258| |key#0@@139| |lo#0@@40| |hi#0@@28|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@258| |key#0@@139| |lo#0@@40| |hi#0@@28|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |6211|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@598) |s#0@@258| |key#0@@139| |lo#0@@40| |hi#0@@28|))
)))
(assert  (=> true (forall (($ly@@599 T@U) (|s#0@@259| T@U) (|key#0@@140| T@U) (|lo#0@@41| Int) (|hi#0@@29| Int) ) (!  (=> (and (and (and (= (type $ly@@599) LayerTypeType) (= (type |s#0@@259|) (SeqType BoxType))) (= (type |key#0@@140|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) (and (and ($Is |s#0@@259| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@140| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@41|) (INTERNAL_lt_boogie |lo#0@@41| |hi#0@@29|)) (INTERNAL_le_boogie |hi#0@@29| (INTERNAL_add_boogie (|Seq#Length| |s#0@@259|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@41| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie |lo#0@@41| 1))) |key#0@@140|))) (=> (INTERNAL_le_boogie |hi#0@@29| (|Seq#Length| |s#0@@259|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@140| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie |hi#0@@29| 1))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) (|Seq#Length| |s#0@@259|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) 1))) |key#0@@140|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) (|Seq#Length| |s#0@@259|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@140| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|)))))) (and (INTERNAL_le_boogie |lo#0@@41| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|) |hi#0@@29|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |6212|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@599 |s#0@@259| |key#0@@140| |lo#0@@41| |hi#0@@29|))
))))
(assert (forall (($ly@@600 T@U) (|s#0@@260| T@U) (|key#0@@141| T@U) (|lo#0@@42| Int) (|hi#0@@30| Int) ) (!  (=> (and (and (and (= (type $ly@@600) LayerTypeType) (= (type |s#0@@260|) (SeqType BoxType))) (= (type |key#0@@141|) DatatypeTypeType)) (and ($Is |s#0@@260| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@141| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@600 |s#0@@260| |key#0@@141| |lo#0@@42| |hi#0@@30|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@42|) (INTERNAL_lt_boogie |lo#0@@42| |hi#0@@30|)) (INTERNAL_le_boogie |hi#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@260|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@42| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@260| (INTERNAL_sub_boogie |lo#0@@42| 1))) |key#0@@141|))) (=> (INTERNAL_le_boogie |hi#0@@30| (|Seq#Length| |s#0@@260|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@141| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@260| (INTERNAL_sub_boogie |hi#0@@30| 1))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |6213|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@600 |s#0@@260| |key#0@@141| |lo#0@@42| |hi#0@@30|))
)))
(assert  (=> true (forall (($ly@@601 T@U) (|s#0@@261| T@U) (|key#0@@142| T@U) (|lo#0@@43| Int) (|hi#0@@31| Int) ) (!  (=> (and (and (and (= (type $ly@@601) LayerTypeType) (= (type |s#0@@261|) (SeqType BoxType))) (= (type |key#0@@142|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@142| |lo#0@@43| |hi#0@@31|) (and (and ($Is |s#0@@261| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@142| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@43|) (INTERNAL_lt_boogie |lo#0@@43| |hi#0@@31|)) (INTERNAL_le_boogie |hi#0@@31| (INTERNAL_add_boogie (|Seq#Length| |s#0@@261|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@43| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |lo#0@@43| 1))) |key#0@@142|))) (=> (INTERNAL_le_boogie |hi#0@@31| (|Seq#Length| |s#0@@261|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@142| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |hi#0@@31| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@43| 1) |hi#0@@31|) (let ((|mid#0@@7| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@43| |hi#0@@31|) 2)))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@142|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@142|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@142| |mid#0@@7| |hi#0@@31|))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@142|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@142| |lo#0@@43| |mid#0@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@601) |s#0@@261| |key#0@@142| |lo#0@@43| |hi#0@@31|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@43| 1) |hi#0@@31|) (let ((|mid#0@@8| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@43| |hi#0@@31|) 2)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@8| 1))) |key#0@@142|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@601 |s#0@@261| |key#0@@142| |mid#0@@8| |hi#0@@31|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@601 |s#0@@261| |key#0@@142| |lo#0@@43| |mid#0@@8|))) |lo#0@@43|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |6214|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@601) |s#0@@261| |key#0@@142| |lo#0@@43| |hi#0@@31|))
))))
(assert  (=> true (forall (($ly@@602 T@U) (|s#0@@262| T@U) (|key#0@@143| T@U) (|lo#0@@44| Int) (|hi#0@@32| Int) ) (!  (=> (and (and (and (= (type $ly@@602) LayerTypeType) (= (type |s#0@@262|) (SeqType BoxType))) (= (type |key#0@@143|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@143| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)) (and (and ($Is |s#0@@262| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@143| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@44|) (INTERNAL_lt_boogie |lo#0@@44| |hi#0@@32|)) (INTERNAL_le_boogie |hi#0@@32| (INTERNAL_add_boogie (|Seq#Length| |s#0@@262|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@44| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |lo#0@@44| 1)))) |key#0@@143|))) (=> (INTERNAL_le_boogie |hi#0@@32| (|Seq#Length| |s#0@@262|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@143| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |hi#0@@32| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@44| 1) |hi#0@@32|)))) (let ((|mid#1@@7| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@44| |hi#0@@32|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@143|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@143|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@143| |mid#1@@7| (LitInt |hi#0@@32|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@143|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@143| (LitInt |lo#0@@44|) |mid#1@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@602) |s#0@@262| |key#0@@143| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@44| 1) |hi#0@@32|) (let ((|mid#1@@8| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@44| |hi#0@@32|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |mid#1@@8| 1)))) |key#0@@143|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@602) |s#0@@262| |key#0@@143| |mid#1@@8| (LitInt |hi#0@@32|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@602) |s#0@@262| |key#0@@143| (LitInt |lo#0@@44|) |mid#1@@8|))) |lo#0@@44|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |6215|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@602) |s#0@@262| |key#0@@143| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)))
))))
(assert  (=> true (forall (($ly@@603 T@U) (|s#0@@263| T@U) (|key#0@@144| T@U) (|lo#0@@45| Int) (|hi#0@@33| Int) ) (!  (=> (and (and (and (= (type $ly@@603) LayerTypeType) (= (type |s#0@@263|) (SeqType BoxType))) (= (type |key#0@@144|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@144|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)) (and (and ($Is |s#0@@263| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@144| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@45|) (INTERNAL_lt_boogie |lo#0@@45| |hi#0@@33|)) (INTERNAL_le_boogie |hi#0@@33| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@263|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@45| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |lo#0@@45| 1)))) (Lit |key#0@@144|)))) (=> (INTERNAL_le_boogie |hi#0@@33| (|Seq#Length| (Lit |s#0@@263|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |key#0@@144|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |hi#0@@33| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@45| 1) |hi#0@@33|)))) (let ((|mid#2@@7| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@45| |hi#0@@33|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@144|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@144|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@144|) |mid#2@@7| (LitInt |hi#0@@33|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@144|))) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@144|) (LitInt |lo#0@@45|) |mid#2@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@603) (Lit |s#0@@263|) (Lit |key#0@@144|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@45| 1) |hi#0@@33|) (let ((|mid#2@@8| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@45| |hi#0@@33|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |mid#2@@8| 1)))) (Lit |key#0@@144|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@603) (Lit |s#0@@263|) (Lit |key#0@@144|) |mid#2@@8| (LitInt |hi#0@@33|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@603) (Lit |s#0@@263|) (Lit |key#0@@144|) (LitInt |lo#0@@45|) |mid#2@@8|))) |lo#0@@45|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |6216|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@603) (Lit |s#0@@263|) (Lit |key#0@@144|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)))
))))
(assert (forall (($ly@@604 T@U) (|s#0@@264| T@U) (|key#0@@145| T@U) ) (!  (=> (and (and (= (type $ly@@604) LayerTypeType) (= (type |s#0@@264|) (SeqType BoxType))) (= (type |key#0@@145|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@604) |s#0@@264| |key#0@@145|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@604 |s#0@@264| |key#0@@145|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |6217|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@604) |s#0@@264| |key#0@@145|))
)))
(assert (forall (($ly@@605 T@U) (|s#0@@265| T@U) (|key#0@@146| T@U) ) (!  (=> (and (and (= (type $ly@@605) LayerTypeType) (= (type |s#0@@265|) (SeqType BoxType))) (= (type |key#0@@146|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@605 |s#0@@265| |key#0@@146|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@265| |key#0@@146|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |6218|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@605) |s#0@@265| |key#0@@146|))
)))
(assert  (=> true (forall (($ly@@606 T@U) (|s#0@@266| T@U) (|key#0@@147| T@U) ) (!  (=> (and (and (and (= (type $ly@@606) LayerTypeType) (= (type |s#0@@266|) (SeqType BoxType))) (= (type |key#0@@147|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@266| |key#0@@147|) (and ($Is |s#0@@266| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@147| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|) (|Seq#Length| |s#0@@266|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@266| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|) 1))) |key#0@@147|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|) (|Seq#Length| |s#0@@266|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@147| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@266| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |6219|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@606 |s#0@@266| |key#0@@147|))
))))
(assert (forall (($ly@@607 T@U) (|s#0@@267| T@U) (|key#0@@148| T@U) ) (!  (=> (and (and (and (= (type $ly@@607) LayerTypeType) (= (type |s#0@@267|) (SeqType BoxType))) (= (type |key#0@@148|) DatatypeTypeType)) (and ($Is |s#0@@267| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@148| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@607 |s#0@@267| |key#0@@148|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |6220|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@607 |s#0@@267| |key#0@@148|))
)))
(assert  (=> true (forall (($ly@@608 T@U) (|s#0@@268| T@U) (|key#0@@149| T@U) ) (!  (=> (and (and (and (= (type $ly@@608) LayerTypeType) (= (type |s#0@@268|) (SeqType BoxType))) (= (type |key#0@@149|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@268| |key#0@@149|) (and ($Is |s#0@@268| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@149| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@268| |key#0@@149| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@268|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@608) |s#0@@268| |key#0@@149|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@268| |key#0@@149| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@268|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |6221|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@608) |s#0@@268| |key#0@@149|))
))))
(assert  (=> true (forall (($ly@@609 T@U) (|s#0@@269| T@U) (|key#0@@150| T@U) ) (!  (=> (and (and (and (= (type $ly@@609) LayerTypeType) (= (type |s#0@@269|) (SeqType BoxType))) (= (type |key#0@@150|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@269|) (Lit |key#0@@150|)) (and ($Is |s#0@@269| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@150| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@269|) (Lit |key#0@@150|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@269|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@609) (Lit |s#0@@269|) (Lit |key#0@@150|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@269|) (Lit |key#0@@150|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@269|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :weight 3
 :skolemid |6222|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@609) (Lit |s#0@@269|) (Lit |key#0@@150|)))
))))
(assert (forall (($ly@@610 T@U) (|s#0@@270| T@U) (|key#0@@151| T@U) (|lo#0@@46| Int) ) (!  (=> (and (and (= (type $ly@@610) LayerTypeType) (= (type |s#0@@270|) (SeqType BoxType))) (= (type |key#0@@151|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@610) |s#0@@270| |key#0@@151| |lo#0@@46|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@610 |s#0@@270| |key#0@@151| |lo#0@@46|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |6223|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@610) |s#0@@270| |key#0@@151| |lo#0@@46|))
)))
(assert (forall (($ly@@611 T@U) (|s#0@@271| T@U) (|key#0@@152| T@U) (|lo#0@@47| Int) ) (!  (=> (and (and (= (type $ly@@611) LayerTypeType) (= (type |s#0@@271|) (SeqType BoxType))) (= (type |key#0@@152|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@611 |s#0@@271| |key#0@@152| |lo#0@@47|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@271| |key#0@@152| |lo#0@@47|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |6224|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@611) |s#0@@271| |key#0@@152| |lo#0@@47|))
)))
(assert  (=> true (forall (($ly@@612 T@U) (|s#0@@272| T@U) (|key#0@@153| T@U) (|lo#0@@48| Int) ) (!  (=> (and (and (and (= (type $ly@@612) LayerTypeType) (= (type |s#0@@272|) (SeqType BoxType))) (= (type |key#0@@153|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@272| |key#0@@153| |lo#0@@48|) (and (and ($Is |s#0@@272| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@153| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@48|) (INTERNAL_le_boogie |lo#0@@48| (|Seq#Length| |s#0@@272|))) (=> (INTERNAL_gt_boogie |lo#0@@48| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (INTERNAL_sub_boogie |lo#0@@48| 1))) |key#0@@153|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@48| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|) (|Seq#Length| |s#0@@272|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|) 1))) |key#0@@153|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|) (|Seq#Length| |s#0@@272|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@153| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |6225|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@612 |s#0@@272| |key#0@@153| |lo#0@@48|))
))))
(assert (forall (($ly@@613 T@U) (|s#0@@273| T@U) (|key#0@@154| T@U) (|lo#0@@49| Int) ) (!  (=> (and (and (and (= (type $ly@@613) LayerTypeType) (= (type |s#0@@273|) (SeqType BoxType))) (= (type |key#0@@154|) DatatypeTypeType)) (and ($Is |s#0@@273| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@154| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@613 |s#0@@273| |key#0@@154| |lo#0@@49|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@49|) (INTERNAL_le_boogie |lo#0@@49| (|Seq#Length| |s#0@@273|))) (=> (INTERNAL_gt_boogie |lo#0@@49| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@273| (INTERNAL_sub_boogie |lo#0@@49| 1))) |key#0@@154|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |6226|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@613 |s#0@@273| |key#0@@154| |lo#0@@49|))
)))
(assert  (=> true (forall (($ly@@614 T@U) (|s#0@@274| T@U) (|key#0@@155| T@U) (|lo#0@@50| Int) ) (!  (=> (and (and (and (= (type $ly@@614) LayerTypeType) (= (type |s#0@@274|) (SeqType BoxType))) (= (type |key#0@@155|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@274| |key#0@@155| |lo#0@@50|) (and (and ($Is |s#0@@274| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@155| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@50|) (INTERNAL_le_boogie |lo#0@@50| (|Seq#Length| |s#0@@274|))) (=> (INTERNAL_gt_boogie |lo#0@@50| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@274| (INTERNAL_sub_boogie |lo#0@@50| 1))) |key#0@@155|)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@274| |key#0@@155| |lo#0@@50| (INTERNAL_add_boogie (|Seq#Length| |s#0@@274|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@614) |s#0@@274| |key#0@@155| |lo#0@@50|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@274| |key#0@@155| |lo#0@@50| (INTERNAL_add_boogie (|Seq#Length| |s#0@@274|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |6227|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@614) |s#0@@274| |key#0@@155| |lo#0@@50|))
))))
(assert  (=> true (forall (($ly@@615 T@U) (|s#0@@275| T@U) (|key#0@@156| T@U) (|lo#0@@51| Int) ) (!  (=> (and (and (and (= (type $ly@@615) LayerTypeType) (= (type |s#0@@275|) (SeqType BoxType))) (= (type |key#0@@156|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@275|) (Lit |key#0@@156|) (LitInt |lo#0@@51|)) (and (and ($Is |s#0@@275| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@156| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@51|) (INTERNAL_le_boogie |lo#0@@51| (|Seq#Length| (Lit |s#0@@275|)))) (=> (INTERNAL_gt_boogie |lo#0@@51| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@275|) (LitInt (INTERNAL_sub_boogie |lo#0@@51| 1)))) (Lit |key#0@@156|))))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@275|) (Lit |key#0@@156|) (LitInt |lo#0@@51|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@275|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@615) (Lit |s#0@@275|) (Lit |key#0@@156|) (LitInt |lo#0@@51|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@275|) (Lit |key#0@@156|) (LitInt |lo#0@@51|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@275|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :weight 3
 :skolemid |6228|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@615) (Lit |s#0@@275|) (Lit |key#0@@156|) (LitInt |lo#0@@51|)))
))))
(assert (forall (($ly@@616 T@U) (|run#0@@195| T@U) (|needle#0@@91| T@U) ) (!  (=> (and (and (= (type $ly@@616) LayerTypeType) (= (type |run#0@@195|) (SeqType BoxType))) (= (type |needle#0@@91|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@616) |run#0@@195| |needle#0@@91|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@616 |run#0@@195| |needle#0@@91|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |6229|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@616) |run#0@@195| |needle#0@@91|))
)))
(assert (forall (($ly@@617 T@U) (|run#0@@196| T@U) (|needle#0@@92| T@U) ) (!  (=> (and (and (= (type $ly@@617) LayerTypeType) (= (type |run#0@@196|) (SeqType BoxType))) (= (type |needle#0@@92|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@617 |run#0@@196| |needle#0@@92|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@196| |needle#0@@92|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |6230|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@617) |run#0@@196| |needle#0@@92|))
)))
(assert  (=> true (forall (($ly@@618 T@U) (|run#0@@197| T@U) (|needle#0@@93| T@U) ) (!  (=> (and (and (and (= (type $ly@@618) LayerTypeType) (= (type |run#0@@197|) (SeqType BoxType))) (= (type |needle#0@@93|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@197| |needle#0@@93|) (and (and ($Is |run#0@@197| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@93| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@197|)))) (and (and (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@618 |run#0@@197| |needle#0@@93|) (|Seq#Length| |run#0@@197|)) (forall ((|i#0@@130| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@130|) (INTERNAL_lt_boogie |i#0@@130| (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@618 |run#0@@197| |needle#0@@93|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#0@@130|)) |needle#0@@93|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.595:20|
 :skolemid |6231|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#0@@130|)))
))) (forall ((|i#1@@43| Int) ) (!  (=> (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@618 |run#0@@197| |needle#0@@93|) |i#1@@43|) (INTERNAL_lt_boogie |i#1@@43| (|Seq#Length| |run#0@@197|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@93| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#1@@43|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.596:20|
 :skolemid |6232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#1@@43|)))
))) (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@618 |run#0@@197| |needle#0@@93|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |6233|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@618 |run#0@@197| |needle#0@@93|))
))))
(assert (forall (($ly@@619 T@U) (|run#0@@198| T@U) (|needle#0@@94| T@U) ) (!  (=> (and (and (and (= (type $ly@@619) LayerTypeType) (= (type |run#0@@198|) (SeqType BoxType))) (= (type |needle#0@@94|) DatatypeTypeType)) (and ($Is |run#0@@198| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@94| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@619 |run#0@@198| |needle#0@@94|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@198|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |6234|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@619 |run#0@@198| |needle#0@@94|))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@620 T@U) (|run#0@@199| T@U) (|needle#0@@95| T@U) ) (!  (=> (and (and (and (= (type $ly@@620) LayerTypeType) (= (type |run#0@@199|) (SeqType BoxType))) (= (type |needle#0@@95|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@199| |needle#0@@95|) (and (and ($Is |run#0@@199| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@95| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@199|)))) (and (=> (not (= (|Seq#Length| |run#0@@199|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|)) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|)) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) |needle#0@@95|))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@620) |run#0@@199| |needle#0@@95|) (ite (= (|Seq#Length| |run#0@@199|) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|) (|Seq#Length| |run#0@@199|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@620 (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) |needle#0@@95|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |6235|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@620) |run#0@@199| |needle#0@@95|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@621 T@U) (|run#0@@200| T@U) (|needle#0@@96| T@U) ) (!  (=> (and (and (and (= (type $ly@@621) LayerTypeType) (= (type |run#0@@200|) (SeqType BoxType))) (= (type |needle#0@@96|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@200|) (Lit |needle#0@@96|)) (and (and ($Is |run#0@@200| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@96| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@200|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@200|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|))) (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|))) (Lit |needle#0@@96|)))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@621) (Lit |run#0@@200|) (Lit |needle#0@@96|)) (ite (= (|Seq#Length| (Lit |run#0@@200|)) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|)) (|Seq#Length| (Lit |run#0@@200|)) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@621) (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|))) (Lit |needle#0@@96|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :weight 3
 :skolemid |6236|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@621) (Lit |run#0@@200|) (Lit |needle#0@@96|)))
))))
(assert (forall (($ly@@622 T@U) (|s#0@@276| T@U) (|key#0@@157| T@U) (|lo#0@@52| Int) (|hi#0@@34| Int) ) (!  (=> (and (and (= (type $ly@@622) LayerTypeType) (= (type |s#0@@276|) (SeqType BoxType))) (= (type |key#0@@157|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@622) |s#0@@276| |key#0@@157| |lo#0@@52| |hi#0@@34|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@622 |s#0@@276| |key#0@@157| |lo#0@@52| |hi#0@@34|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |6237|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@622) |s#0@@276| |key#0@@157| |lo#0@@52| |hi#0@@34|))
)))
(assert (forall (($ly@@623 T@U) (|s#0@@277| T@U) (|key#0@@158| T@U) (|lo#0@@53| Int) (|hi#0@@35| Int) ) (!  (=> (and (and (= (type $ly@@623) LayerTypeType) (= (type |s#0@@277|) (SeqType BoxType))) (= (type |key#0@@158|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@623 |s#0@@277| |key#0@@158| |lo#0@@53| |hi#0@@35|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@277| |key#0@@158| |lo#0@@53| |hi#0@@35|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |6238|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@623) |s#0@@277| |key#0@@158| |lo#0@@53| |hi#0@@35|))
)))
(assert  (=> true (forall (($ly@@624 T@U) (|s#0@@278| T@U) (|key#0@@159| T@U) (|lo#0@@54| Int) (|hi#0@@36| Int) ) (!  (=> (and (and (and (= (type $ly@@624) LayerTypeType) (= (type |s#0@@278|) (SeqType BoxType))) (= (type |key#0@@159|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|) (and (and ($Is |s#0@@278| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@159| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@54|) (INTERNAL_lt_boogie |lo#0@@54| |hi#0@@36|)) (INTERNAL_le_boogie |hi#0@@36| (INTERNAL_add_boogie (|Seq#Length| |s#0@@278|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@54| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie |lo#0@@54| 1))) |key#0@@159|))) (=> (INTERNAL_le_boogie |hi#0@@36| (|Seq#Length| |s#0@@278|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@159| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie |hi#0@@36| 1))))))))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|) (|Seq#Length| |s#0@@278|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|) 1))) |key#0@@159|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|) (|Seq#Length| |s#0@@278|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@159| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |6239|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@624 |s#0@@278| |key#0@@159| |lo#0@@54| |hi#0@@36|))
))))
(assert (forall (($ly@@625 T@U) (|s#0@@279| T@U) (|key#0@@160| T@U) (|lo#0@@55| Int) (|hi#0@@37| Int) ) (!  (=> (and (and (and (= (type $ly@@625) LayerTypeType) (= (type |s#0@@279|) (SeqType BoxType))) (= (type |key#0@@160|) DatatypeTypeType)) (and ($Is |s#0@@279| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@160| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@625 |s#0@@279| |key#0@@160| |lo#0@@55| |hi#0@@37|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@55|) (INTERNAL_lt_boogie |lo#0@@55| |hi#0@@37|)) (INTERNAL_le_boogie |hi#0@@37| (INTERNAL_add_boogie (|Seq#Length| |s#0@@279|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@55| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@279| (INTERNAL_sub_boogie |lo#0@@55| 1))) |key#0@@160|))) (=> (INTERNAL_le_boogie |hi#0@@37| (|Seq#Length| |s#0@@279|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@160| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@279| (INTERNAL_sub_boogie |hi#0@@37| 1))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |6240|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@625 |s#0@@279| |key#0@@160| |lo#0@@55| |hi#0@@37|))
)))
(assert  (=> true (forall (($ly@@626 T@U) (|s#0@@280| T@U) (|key#0@@161| T@U) (|lo#0@@56| Int) (|hi#0@@38| Int) ) (!  (=> (and (and (and (= (type $ly@@626) LayerTypeType) (= (type |s#0@@280|) (SeqType BoxType))) (= (type |key#0@@161|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@161| |lo#0@@56| |hi#0@@38|) (and (and ($Is |s#0@@280| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@161| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@56|) (INTERNAL_lt_boogie |lo#0@@56| |hi#0@@38|)) (INTERNAL_le_boogie |hi#0@@38| (INTERNAL_add_boogie (|Seq#Length| |s#0@@280|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@56| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |lo#0@@56| 1))) |key#0@@161|))) (=> (INTERNAL_le_boogie |hi#0@@38| (|Seq#Length| |s#0@@280|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@161| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |hi#0@@38| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@56| 1) |hi#0@@38|) (let ((|mid#0@@9| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@56| |hi#0@@38|) 2)))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@161|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@161|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@161| |mid#0@@9| |hi#0@@38|))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@161|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@161| |lo#0@@56| |mid#0@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@626) |s#0@@280| |key#0@@161| |lo#0@@56| |hi#0@@38|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@56| 1) |hi#0@@38|) (let ((|mid#0@@10| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@56| |hi#0@@38|) 2)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@10| 1))) |key#0@@161|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@626 |s#0@@280| |key#0@@161| |mid#0@@10| |hi#0@@38|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@626 |s#0@@280| |key#0@@161| |lo#0@@56| |mid#0@@10|))) |lo#0@@56|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |6241|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@626) |s#0@@280| |key#0@@161| |lo#0@@56| |hi#0@@38|))
))))
(assert  (=> true (forall (($ly@@627 T@U) (|s#0@@281| T@U) (|key#0@@162| T@U) (|lo#0@@57| Int) (|hi#0@@39| Int) ) (!  (=> (and (and (and (= (type $ly@@627) LayerTypeType) (= (type |s#0@@281|) (SeqType BoxType))) (= (type |key#0@@162|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@162| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)) (and (and ($Is |s#0@@281| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@162| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@57|) (INTERNAL_lt_boogie |lo#0@@57| |hi#0@@39|)) (INTERNAL_le_boogie |hi#0@@39| (INTERNAL_add_boogie (|Seq#Length| |s#0@@281|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@57| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |lo#0@@57| 1)))) |key#0@@162|))) (=> (INTERNAL_le_boogie |hi#0@@39| (|Seq#Length| |s#0@@281|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@162| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |hi#0@@39| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@57| 1) |hi#0@@39|)))) (let ((|mid#1@@9| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@57| |hi#0@@39|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@162|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@162|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@162| |mid#1@@9| (LitInt |hi#0@@39|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@162|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@162| (LitInt |lo#0@@57|) |mid#1@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@627) |s#0@@281| |key#0@@162| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@57| 1) |hi#0@@39|) (let ((|mid#1@@10| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@57| |hi#0@@39|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |mid#1@@10| 1)))) |key#0@@162|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@627) |s#0@@281| |key#0@@162| |mid#1@@10| (LitInt |hi#0@@39|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@627) |s#0@@281| |key#0@@162| (LitInt |lo#0@@57|) |mid#1@@10|))) |lo#0@@57|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |6242|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@627) |s#0@@281| |key#0@@162| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)))
))))
(assert  (=> true (forall (($ly@@628 T@U) (|s#0@@282| T@U) (|key#0@@163| T@U) (|lo#0@@58| Int) (|hi#0@@40| Int) ) (!  (=> (and (and (and (= (type $ly@@628) LayerTypeType) (= (type |s#0@@282|) (SeqType BoxType))) (= (type |key#0@@163|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@163|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)) (and (and ($Is |s#0@@282| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@163| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@58|) (INTERNAL_lt_boogie |lo#0@@58| |hi#0@@40|)) (INTERNAL_le_boogie |hi#0@@40| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@282|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@58| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |lo#0@@58| 1)))) (Lit |key#0@@163|)))) (=> (INTERNAL_le_boogie |hi#0@@40| (|Seq#Length| (Lit |s#0@@282|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@163|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |hi#0@@40| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@58| 1) |hi#0@@40|)))) (let ((|mid#2@@9| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@58| |hi#0@@40|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@163|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@163|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@163|) |mid#2@@9| (LitInt |hi#0@@40|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@163|))) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@163|) (LitInt |lo#0@@58|) |mid#2@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@628) (Lit |s#0@@282|) (Lit |key#0@@163|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@58| 1) |hi#0@@40|) (let ((|mid#2@@10| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@58| |hi#0@@40|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |mid#2@@10| 1)))) (Lit |key#0@@163|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@628) (Lit |s#0@@282|) (Lit |key#0@@163|) |mid#2@@10| (LitInt |hi#0@@40|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@628) (Lit |s#0@@282|) (Lit |key#0@@163|) (LitInt |lo#0@@58|) |mid#2@@10|))) |lo#0@@58|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |6243|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@628) (Lit |s#0@@282|) (Lit |key#0@@163|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)))
))))
(assert (forall (($ly@@629 T@U) (|s#0@@283| T@U) (|key#0@@164| T@U) ) (!  (=> (and (and (= (type $ly@@629) LayerTypeType) (= (type |s#0@@283|) (SeqType BoxType))) (= (type |key#0@@164|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@629) |s#0@@283| |key#0@@164|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@629 |s#0@@283| |key#0@@164|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |6244|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@629) |s#0@@283| |key#0@@164|))
)))
(assert (forall (($ly@@630 T@U) (|s#0@@284| T@U) (|key#0@@165| T@U) ) (!  (=> (and (and (= (type $ly@@630) LayerTypeType) (= (type |s#0@@284|) (SeqType BoxType))) (= (type |key#0@@165|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@630 |s#0@@284| |key#0@@165|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@284| |key#0@@165|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |6245|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@630) |s#0@@284| |key#0@@165|))
)))
(assert  (=> true (forall (($ly@@631 T@U) (|s#0@@285| T@U) (|key#0@@166| T@U) ) (!  (=> (and (and (and (= (type $ly@@631) LayerTypeType) (= (type |s#0@@285|) (SeqType BoxType))) (= (type |key#0@@166|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@285| |key#0@@166|) (and ($Is |s#0@@285| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@166| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|) (|Seq#Length| |s#0@@285|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@285| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|) 1))) |key#0@@166|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|) (|Seq#Length| |s#0@@285|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@166| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@285| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |6246|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@631 |s#0@@285| |key#0@@166|))
))))
(assert (forall (($ly@@632 T@U) (|s#0@@286| T@U) (|key#0@@167| T@U) ) (!  (=> (and (and (and (= (type $ly@@632) LayerTypeType) (= (type |s#0@@286|) (SeqType BoxType))) (= (type |key#0@@167|) DatatypeTypeType)) (and ($Is |s#0@@286| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@167| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@632 |s#0@@286| |key#0@@167|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |6247|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@632 |s#0@@286| |key#0@@167|))
)))
(assert  (=> true (forall (($ly@@633 T@U) (|s#0@@287| T@U) (|key#0@@168| T@U) ) (!  (=> (and (and (and (= (type $ly@@633) LayerTypeType) (= (type |s#0@@287|) (SeqType BoxType))) (= (type |key#0@@168|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@287| |key#0@@168|) (and ($Is |s#0@@287| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@168| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@287| |key#0@@168| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@287|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@633) |s#0@@287| |key#0@@168|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@287| |key#0@@168| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@287|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |6248|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@633) |s#0@@287| |key#0@@168|))
))))
(assert  (=> true (forall (($ly@@634 T@U) (|s#0@@288| T@U) (|key#0@@169| T@U) ) (!  (=> (and (and (and (= (type $ly@@634) LayerTypeType) (= (type |s#0@@288|) (SeqType BoxType))) (= (type |key#0@@169|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@288|) (Lit |key#0@@169|)) (and ($Is |s#0@@288| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@169| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@288|) (Lit |key#0@@169|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@288|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@634) (Lit |s#0@@288|) (Lit |key#0@@169|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@288|) (Lit |key#0@@169|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@288|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :weight 3
 :skolemid |6249|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@634) (Lit |s#0@@288|) (Lit |key#0@@169|)))
))))
(assert  (=> true (forall ((|a#0@@191| T@U) (|b#0@@145| T@U) ) (!  (=> (and (and (= (type |a#0@@191|) (MapType0Type BoxType boolType)) (= (type |b#0@@145|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@191| |b#0@@145|) (and ($Is |a#0@@191| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@145| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |6250|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@191| |b#0@@145|))
))))
(assert (forall ((|a#0@@192| T@U) (|b#0@@146| T@U) ) (!  (=> (and (and (= (type |a#0@@192|) (MapType0Type BoxType boolType)) (= (type |b#0@@146|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@192| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@146| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@192| |b#0@@146|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |6251|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@192| |b#0@@146|))
)))
(assert  (=> true (forall ((|a#0@@193| T@U) (|b#0@@147| T@U) ) (!  (=> (and (and (= (type |a#0@@193|) (MapType0Type BoxType boolType)) (= (type |b#0@@147|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@193| |b#0@@147|) (and ($Is |a#0@@193| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@147| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#0@@10| T@U) (|y#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@10|) DatatypeTypeType) (= (type |y#0@@15|) DatatypeTypeType)) (and ($Is |x#0@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select |a#0@@193| ($Box |x#0@@10|)))) (U_2_bool (MapType0Select |b#0@@147| ($Box |y#0@@15|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |x#0@@10| |y#0@@15|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |6253|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@10| |y#0@@15|))
 :pattern ( (MapType0Select |b#0@@147| ($Box |y#0@@15|)) (MapType0Select |a#0@@193| ($Box |x#0@@10|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@193| |b#0@@147|) (forall ((|x#0@@11| T@U) (|y#0@@16| T@U) ) (!  (=> (and (and (and (= (type |x#0@@11|) DatatypeTypeType) (= (type |y#0@@16|) DatatypeTypeType)) (and ($Is |x#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select |a#0@@193| ($Box |x#0@@11|))) (U_2_bool (MapType0Select |b#0@@147| ($Box |y#0@@16|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@11| |y#0@@16|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |6252|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@11| |y#0@@16|))
 :pattern ( (MapType0Select |b#0@@147| ($Box |y#0@@16|)) (MapType0Select |a#0@@193| ($Box |x#0@@11|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |6254|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@193| |b#0@@147|))
))))
(assert  (=> true (forall ((|a#0@@194| T@U) (|b#0@@148| T@U) ) (!  (=> (and (and (= (type |a#0@@194|) (MapType0Type BoxType boolType)) (= (type |b#0@@148|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@194|) (Lit |b#0@@148|)) (and ($Is |a#0@@194| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@148| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#1@@7| T@U) (|y#1@@7| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@7|) DatatypeTypeType) (= (type |y#1@@7|) DatatypeTypeType)) (and ($Is |x#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select (Lit |a#0@@194|) ($Box |x#1@@7|)))) (U_2_bool (MapType0Select (Lit |b#0@@148|) ($Box |y#1@@7|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |x#1@@7| |y#1@@7|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |6256|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@7| |y#1@@7|))
 :pattern ( (MapType0Select |b#0@@148| ($Box |y#1@@7|)) (MapType0Select |a#0@@194| ($Box |x#1@@7|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@194|) (Lit |b#0@@148|)) (forall ((|x#1@@8| T@U) (|y#1@@8| T@U) ) (!  (=> (and (and (and (= (type |x#1@@8|) DatatypeTypeType) (= (type |y#1@@8|) DatatypeTypeType)) (and ($Is |x#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select (Lit |a#0@@194|) ($Box |x#1@@8|))) (U_2_bool (MapType0Select (Lit |b#0@@148|) ($Box |y#1@@8|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@8| |y#1@@8|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |6255|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@8| |y#1@@8|))
 :pattern ( (MapType0Select |b#0@@148| ($Box |y#1@@8|)) (MapType0Select |a#0@@194| ($Box |x#1@@8|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :weight 3
 :skolemid |6257|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@194|) (Lit |b#0@@148|)))
))))
(assert  (=> true (forall ((|a#0@@195| T@U) (|b#0@@149| T@U) ) (!  (=> (and (and (= (type |a#0@@195|) (MapType0Type BoxType boolType)) (= (type |b#0@@149|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@195| |b#0@@149|) (and ($Is |a#0@@195| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@149| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |6258|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@195| |b#0@@149|))
))))
(assert (forall ((|a#0@@196| T@U) (|b#0@@150| T@U) ) (!  (=> (and (and (= (type |a#0@@196|) (MapType0Type BoxType boolType)) (= (type |b#0@@150|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@196| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@150| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@196| |b#0@@150|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |6259|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@196| |b#0@@150|))
)))
(assert  (=> true (forall ((|a#0@@197| T@U) (|b#0@@151| T@U) ) (!  (=> (and (and (= (type |a#0@@197|) (MapType0Type BoxType boolType)) (= (type |b#0@@151|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@197| |b#0@@151|) (and ($Is |a#0@@197| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@151| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#0@@12| T@U) (|y#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@12|) DatatypeTypeType) (= (type |y#0@@17|) DatatypeTypeType)) (and ($Is |x#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select |a#0@@197| ($Box |x#0@@12|)))) (U_2_bool (MapType0Select |b#0@@151| ($Box |y#0@@17|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |x#0@@12| |y#0@@17|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |6261|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@12| |y#0@@17|))
 :pattern ( (MapType0Select |b#0@@151| ($Box |y#0@@17|)) (MapType0Select |a#0@@197| ($Box |x#0@@12|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@197| |b#0@@151|) (forall ((|x#0@@13| T@U) (|y#0@@18| T@U) ) (!  (=> (and (and (and (= (type |x#0@@13|) DatatypeTypeType) (= (type |y#0@@18|) DatatypeTypeType)) (and ($Is |x#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select |a#0@@197| ($Box |x#0@@13|))) (U_2_bool (MapType0Select |b#0@@151| ($Box |y#0@@18|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@13| |y#0@@18|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |6260|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@13| |y#0@@18|))
 :pattern ( (MapType0Select |b#0@@151| ($Box |y#0@@18|)) (MapType0Select |a#0@@197| ($Box |x#0@@13|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |6262|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@197| |b#0@@151|))
))))
(assert  (=> true (forall ((|a#0@@198| T@U) (|b#0@@152| T@U) ) (!  (=> (and (and (= (type |a#0@@198|) (MapType0Type BoxType boolType)) (= (type |b#0@@152|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@198|) (Lit |b#0@@152|)) (and ($Is |a#0@@198| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@152| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#1@@9| T@U) (|y#1@@9| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@9|) DatatypeTypeType) (= (type |y#1@@9|) DatatypeTypeType)) (and ($Is |x#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select (Lit |a#0@@198|) ($Box |x#1@@9|)))) (U_2_bool (MapType0Select (Lit |b#0@@152|) ($Box |y#1@@9|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |x#1@@9| |y#1@@9|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |6264|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@9| |y#1@@9|))
 :pattern ( (MapType0Select |b#0@@152| ($Box |y#1@@9|)) (MapType0Select |a#0@@198| ($Box |x#1@@9|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@198|) (Lit |b#0@@152|)) (forall ((|x#1@@10| T@U) (|y#1@@10| T@U) ) (!  (=> (and (and (and (= (type |x#1@@10|) DatatypeTypeType) (= (type |y#1@@10|) DatatypeTypeType)) (and ($Is |x#1@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select (Lit |a#0@@198|) ($Box |x#1@@10|))) (U_2_bool (MapType0Select (Lit |b#0@@152|) ($Box |y#1@@10|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@10| |y#1@@10|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |6263|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@10| |y#1@@10|))
 :pattern ( (MapType0Select |b#0@@152| ($Box |y#1@@10|)) (MapType0Select |a#0@@198| ($Box |x#1@@10|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :weight 3
 :skolemid |6265|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@198|) (Lit |b#0@@152|)))
))))
(assert (forall (($ly@@635 T@U) (|a#0@@199| T@U) ) (!  (=> (and (= (type $ly@@635) LayerTypeType) (= (type |a#0@@199|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@635) |a#0@@199|) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@635 |a#0@@199|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |6266|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@635) |a#0@@199|))
)))
(assert (forall (($ly@@636 T@U) (|a#0@@200| T@U) ) (!  (=> (and (= (type $ly@@636) LayerTypeType) (= (type |a#0@@200|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@636 |a#0@@200|) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $LZ |a#0@@200|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |6267|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@636) |a#0@@200|))
)))
(assert  (=> true (forall (($ly@@637 T@U) (|a#0@@201| T@U) ) (!  (=> (and (and (= (type $ly@@637) LayerTypeType) (= (type |a#0@@201|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@201|) ($Is |a#0@@201| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |6268|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@637 |a#0@@201|))
))))
(assert (forall (($ly@@638 T@U) (|a#0@@202| T@U) ) (!  (=> (and (and (= (type $ly@@638) LayerTypeType) (= (type |a#0@@202|) DatatypeTypeType)) ($Is |a#0@@202| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@638 |a#0@@202|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |6269|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@638 |a#0@@202|))
)))
(assert  (=> true (forall (($ly@@639 T@U) (|a#0@@203| T@U) ) (!  (=> (and (and (= (type $ly@@639) LayerTypeType) (= (type |a#0@@203|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@203|) ($Is |a#0@@203| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (forall ((|b#0@@153| T@U) ) (!  (=> (and (= (type |b#0@@153|) DatatypeTypeType) ($Is |b#0@@153| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@153| |a#0@@203|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |6271|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@153| |a#0@@203|))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@639) |a#0@@203|) (exists ((|b#0@@154| T@U) ) (!  (and (= (type |b#0@@154|) DatatypeTypeType) (and ($Is |b#0@@154| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@154| |a#0@@203|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |6270|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@154| |a#0@@203|))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |6272|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@639) |a#0@@203|))
))))
(assert  (=> true (forall (($ly@@640 T@U) (|a#0@@204| T@U) ) (!  (=> (and (and (= (type $ly@@640) LayerTypeType) (= (type |a#0@@204|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| (Lit |a#0@@204|)) ($Is |a#0@@204| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (forall ((|b#1@@8| T@U) ) (!  (=> (and (= (type |b#1@@8|) DatatypeTypeType) ($Is |b#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#1@@8| (Lit |a#0@@204|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |6274|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@8| |a#0@@204|))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@640) (Lit |a#0@@204|)) (exists ((|b#1@@9| T@U) ) (!  (and (= (type |b#1@@9|) DatatypeTypeType) (and ($Is |b#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@9| (Lit |a#0@@204|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |6273|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@9| |a#0@@204|))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :weight 3
 :skolemid |6275|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@640) (Lit |a#0@@204|)))
))))
(assert (forall ((arg0@@624 T@U) (arg1@@319 T@U) (arg2@@168 T@U) (arg3@@99 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@624 arg1@@319 arg2@@168 arg3@@99)) (MapType BoxType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@624 arg1@@319 arg2@@168 arg3@@99))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0@@7| T@U) (|pivot#0@@7| T@U) (|right#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0@@7|) (MapType BoxType BoxType))) (= (type |pivot#0@@7|) DatatypeTypeType)) (= (type |right#0@@7|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|) (and (and ($Is |left#0@@7| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value)) ($Is |pivot#0@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@7| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|) (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |6276|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@8| T@U) (|pivot#0@@8| T@U) (|right#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@8|) (MapType BoxType BoxType))) (= (type |pivot#0@@8|) DatatypeTypeType)) (= (type |right#0@@8|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@8| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)) ($Is |pivot#0@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@8| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@8| |pivot#0@@8| |right#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |6277|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@8| |pivot#0@@8| |right#0@@8|))
)))
(assert  (and (forall ((arg0@@625 T@U) (arg1@@320 T@U) ) (! (= (type (|lambda#337| arg0@@625 arg1@@320)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#337|
 :pattern ( (|lambda#337| arg0@@625 arg1@@320))
)) (forall ((arg0@@626 T@U) (arg1@@321 T@U) ) (! (= (type (|lambda#339| arg0@@626 arg1@@321)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#339|
 :pattern ( (|lambda#339| arg0@@626 arg1@@321))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@9| T@U) (|pivot#0@@9| T@U) (|right#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@9|) (MapType BoxType BoxType))) (= (type |pivot#0@@9|) DatatypeTypeType)) (= (type |right#0@@9|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|) (and (and ($Is |left#0@@9| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1)) ($Is |pivot#0@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@9| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@79| T@U) ) (!  (=> (and (= (type |k#0@@79|) DatatypeTypeType) ($Is |k#0@@79| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |k#0@@79| |pivot#0@@9|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.840:57|
 :skolemid |6278|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |k#0@@79| |pivot#0@@9|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))) (let ((|restricted_left#0@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
 (and (and (forall ((|k#1@@17| T@U) ) (!  (=> (and (= (type |k#1@@17|) DatatypeTypeType) ($Is |k#1@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |pivot#0@@9| |k#1@@17|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.841:59|
 :skolemid |6279|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |pivot#0@@9| |k#1@@17|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))) (let ((|restricted_right#0@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0@@3| |restricted_right#0@@3|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|) (let ((|restricted_left#0@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(let ((|restricted_right#0@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(Maps.__default.MapDisjointUnion Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@4| |restricted_right#0@@4|))))))
 :qid |unknown.0:0|
 :skolemid |6280|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@10| T@U) (|pivot#0@@10| T@U) (|right#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@10|) (MapType BoxType BoxType))) (= (type |pivot#0@@10|) DatatypeTypeType)) (= (type |right#0@@10|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)) (and (and ($Is |left#0@@10| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2)) ($Is |pivot#0@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@10| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@8| T@U) ) (!  (=> (and (= (type |k#2@@8|) DatatypeTypeType) ($Is |k#2@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |k#2@@8| (Lit |pivot#0@@10|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.840:57|
 :skolemid |6281|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |k#2@@8| |pivot#0@@10|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))) (let ((|restricted_left#1@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
 (and (and (forall ((|k#3@@1| T@U) ) (!  (=> (and (= (type |k#3@@1|) DatatypeTypeType) ($Is |k#3@@1| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |pivot#0@@10|) |k#3@@1|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.841:59|
 :skolemid |6282|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |pivot#0@@10| |k#3@@1|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))) (let ((|restricted_right#1@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1@@3| |restricted_right#1@@3|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)) (let ((|restricted_left#1@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#337| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(let ((|restricted_right#1@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#339| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(Maps.__default.MapDisjointUnion Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@4| |restricted_right#1@@4|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6283|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)))
))))
(assert (forall ((arg0@@627 T@U) (arg1@@322 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor arg0@@627 arg1@@322)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor arg0@@627 arg1@@322))
)))
(assert  (=> true (forall ((|m#0@@146| T@U) (|key#0@@170| T@U) ) (!  (=> (and (and (= (type |m#0@@146|) (MapType0Type BoxType boolType)) (= (type |key#0@@170|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@146| |key#0@@170|) (and ($Is |m#0@@146| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@170| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@146| |key#0@@170|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:25|
 :skolemid |6284|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@146| |key#0@@170|))
))))
(assert (forall (($Heap@@89 T@U) (|m#0@@147| T@U) (|key#0@@171| T@U) ) (!  (=> (and (and (and (= (type $Heap@@89) (MapType0Type refType MapType1Type)) (= (type |m#0@@147|) (MapType0Type BoxType boolType))) (= (type |key#0@@171|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap@@89) ($Is |m#0@@147| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@171| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@147| |key#0@@171|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :skolemid |6285|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@147| |key#0@@171|) ($IsGoodHeap $Heap@@89))
)))
(assert (forall ((arg0@@628 T@U) (arg1@@323 T@U) ) (! (= (type (|$let#46_next| arg0@@628 arg1@@323)) DatatypeTypeType)
 :qid |funType:$let#46_next|
 :pattern ( (|$let#46_next| arg0@@628 arg1@@323))
)))
(assert (forall ((m@@70 T@U) (key@@1 T@U) ) (!  (=> (and (and (= (type m@@70) (MapType0Type BoxType boolType)) (= (type key@@1) DatatypeTypeType)) (|$let#46$canCall| m@@70 key@@1)) (and ($Is (|$let#46_next| m@@70 key@@1) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select m@@70 ($Box (|$let#46_next| m@@70 key@@1)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 (|$let#46_next| m@@70 key@@1))) (forall ((|other#1@@1| T@U) ) (!  (=> (and (= (type |other#1@@1|) DatatypeTypeType) ($Is |other#1@@1| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select m@@70 ($Box |other#1@@1|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#1@@1| (|$let#46_next| m@@70 key@@1)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 |other#1@@1|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (|$let#46_next| m@@70 key@@1) |other#1@@1|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6288|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt (|$let#46_next| m@@70 key@@1) |other#1@@1|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 |other#1@@1|))
 :pattern ( (MapType0Select m@@70 ($Box |other#1@@1|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6289|
 :pattern ( (|$let#46_next| m@@70 key@@1))
)))
(assert  (=> true (forall (($Heap@@90 T@U) (|m#0@@148| T@U) (|key#0@@172| T@U) ) (!  (=> (and (and (and (= (type $Heap@@90) (MapType0Type refType MapType1Type)) (= (type |m#0@@148|) (MapType0Type BoxType boolType))) (= (type |key#0@@172|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@148| |key#0@@172|) (and (and ($IsGoodHeap $Heap@@90) ($Is |m#0@@148| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@172| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (forall ((|next#0@@5| T@U) ) (!  (=> (and (and (= (type |next#0@@5|) DatatypeTypeType) ($Is |next#0@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@5|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@172| |next#0@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@5|) (forall ((|other#0@@21| T@U) ) (!  (=> (and (and (= (type |other#0@@21|) DatatypeTypeType) ($Is |other#0@@21| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@21|)))) (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |other#0@@21|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |next#0@@5|)) (=> (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@21| |next#0@@5|)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@172| |other#0@@21|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@21|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |next#0@@5| |other#0@@21|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6290|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@5| |other#0@@21|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@21|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@21|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6291|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@5|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@5|)))
)) (=> (exists ((|next#0@@6| T@U) ) (!  (and (= (type |next#0@@6|) DatatypeTypeType) (and ($Is |next#0@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@6|)) (forall ((|other#0@@22| T@U) ) (!  (=> (and (= (type |other#0@@22|) DatatypeTypeType) ($Is |other#0@@22| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@22|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@22| |next#0@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@22|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@6| |other#0@@22|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6292|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@6| |other#0@@22|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@22|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@22|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6293|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@6|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@6|)))
)) (|$let#46$canCall| |m#0@@148| |key#0@@172|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@148| |key#0@@172|) (ite (exists ((|next#0@@7| T@U) ) (!  (and (= (type |next#0@@7|) DatatypeTypeType) (and ($Is |next#0@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@7|)) (forall ((|other#0@@23| T@U) ) (!  (=> (and (= (type |other#0@@23|) DatatypeTypeType) ($Is |other#0@@23| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@23|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@23| |next#0@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@23|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@7| |other#0@@23|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6286|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@7| |other#0@@23|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |other#0@@23|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@23|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6287|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@172| |next#0@@7|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@7|)))
)) (let ((|next#1@@1| (|$let#46_next| |m#0@@148| |key#0@@172|)))
(|#Options.Option.Some| ($Box |next#1@@1|))) |#Options.Option.None|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :skolemid |6294|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@148| |key#0@@172|) ($IsGoodHeap $Heap@@90))
))))
(assert  (=> true (forall (($Heap@@91 T@U) (|m#0@@149| T@U) (|key#0@@173| T@U) ) (!  (=> (and (and (and (= (type $Heap@@91) (MapType0Type refType MapType1Type)) (= (type |m#0@@149|) (MapType0Type BoxType boolType))) (= (type |key#0@@173|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@149|) (Lit |key#0@@173|)) (and (and ($IsGoodHeap $Heap@@91) ($Is |m#0@@149| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@173| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (forall ((|next#2@@5| T@U) ) (!  (=> (and (and (= (type |next#2@@5|) DatatypeTypeType) ($Is |next#2@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@5|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@173|) |next#2@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |next#2@@5|) (forall ((|other#2@@5| T@U) ) (!  (=> (and (and (= (type |other#2@@5|) DatatypeTypeType) ($Is |other#2@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@5|)))) (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |other#2@@5|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |next#2@@5|)) (=> (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@5| |next#2@@5|)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@173|) |other#2@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |other#2@@5|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |next#2@@5| |other#2@@5|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6297|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@5| |other#2@@5|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |other#2@@5|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@5|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6298|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |next#2@@5|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@5|)))
)) (=> (exists ((|next#2@@6| T@U) ) (!  (and (= (type |next#2@@6|) DatatypeTypeType) (and ($Is |next#2@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |next#2@@6|)) (forall ((|other#2@@6| T@U) ) (!  (=> (and (= (type |other#2@@6|) DatatypeTypeType) ($Is |other#2@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@6|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@6| |next#2@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |other#2@@6|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@6| |other#2@@6|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6299|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@6| |other#2@@6|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |other#2@@6|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@6|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6300|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |next#2@@6|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@6|)))
)) (|$let#46$canCall| (Lit |m#0@@149|) (Lit |key#0@@173|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@149|) (Lit |key#0@@173|)) (ite (exists ((|next#2@@7| T@U) ) (!  (and (= (type |next#2@@7|) DatatypeTypeType) (and ($Is |next#2@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |next#2@@7|)) (forall ((|other#2@@7| T@U) ) (!  (=> (and (= (type |other#2@@7|) DatatypeTypeType) ($Is |other#2@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@7|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@7| |next#2@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@173|) |other#2@@7|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@7| |other#2@@7|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |6295|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@7| |other#2@@7|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |other#2@@7|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@7|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |6296|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@173| |next#2@@7|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@7|)))
)) (let ((|next#3@@1| (|$let#46_next| (Lit |m#0@@149|) (Lit |key#0@@173|))))
(|#Options.Option.Some| ($Box |next#3@@1|))) |#Options.Option.None|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :weight 3
 :skolemid |6301|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@149|) (Lit |key#0@@173|)) ($IsGoodHeap $Heap@@91))
))))
(assert (forall ((arg0@@629 T@U) (arg1@@324 T@U) (arg2@@169 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor arg0@@629 arg1@@324 arg2@@169)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor arg0@@629 arg1@@324 arg2@@169))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V T@U) (|m#0@@150| T@U) (|key#0@@174| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@150|) (MapType BoxType BoxType))) (= (type |key#0@@174|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@174|) (and ($Is |m#0@@150| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V)) ($Is |key#0@@174| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@174|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |unknown.0:0|
 :skolemid |6302|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@174|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@151| T@U) (|key#0@@175| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@151|) (MapType BoxType BoxType))) (= (type |key#0@@175|) DatatypeTypeType)) (and ($Is |m#0@@151| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0)) ($Is |key#0@@175| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@151| |key#0@@175|) true))
 :qid |unknown.0:0|
 :skolemid |6303|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@151| |key#0@@175|))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@152| T@U) (|key#0@@176| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@152|) (MapType BoxType BoxType))) (= (type |key#0@@176|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@176|) (and ($Is |m#0@@152| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1)) ($Is |key#0@@176| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@152|) |key#0@@176|) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@176|) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@152|) |key#0@@176|))))
 :qid |unknown.0:0|
 :skolemid |6304|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@176|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@153| T@U) (|key#0@@177| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@153|) (MapType BoxType BoxType))) (= (type |key#0@@177|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@177|)) (and ($Is |m#0@@153| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2)) ($Is |key#0@@177| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@153|))) (Lit |key#0@@177|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@177|)) (Lit (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@153|))) (Lit |key#0@@177|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6305|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@177|)))
))))
(assert (forall ((arg0@@630 T@U) (arg1@@325 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@630 arg1@@325)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@630 arg1@@325))
)))
(assert  (=> true (forall ((|m#0@@154| T@U) (|key#0@@178| T@U) ) (!  (=> (and (and (= (type |m#0@@154|) (SeqType BoxType)) (= (type |key#0@@178|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@154| |key#0@@178|) (and ($Is |m#0@@154| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@178| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@154| |key#0@@178|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |6306|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@154| |key#0@@178|))
))))
(assert (forall ((|m#0@@155| T@U) (|key#0@@179| T@U) ) (!  (=> (and (and (= (type |m#0@@155|) (SeqType BoxType)) (= (type |key#0@@179|) DatatypeTypeType)) (and ($Is |m#0@@155| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@179| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@155| |key#0@@179|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |6307|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@155| |key#0@@179|))
)))
(assert  (=> true (forall ((|m#0@@156| T@U) (|key#0@@180| T@U) ) (!  (=> (and (and (= (type |m#0@@156|) (SeqType BoxType)) (= (type |key#0@@180|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@156| |key#0@@180|) (and ($Is |m#0@@156| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@180| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@156|) |key#0@@180|) (= (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@156| |key#0@@180|) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#307| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@156|) |key#0@@180|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |6308|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@156| |key#0@@180|))
))))
(assert  (=> true (forall ((|m#0@@157| T@U) (|key#0@@181| T@U) ) (!  (=> (and (and (= (type |m#0@@157|) (SeqType BoxType)) (= (type |key#0@@181|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@157|) (Lit |key#0@@181|)) (and ($Is |m#0@@157| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@181| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#307| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@157|) (Lit |key#0@@181|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@157|) (Lit |key#0@@181|)) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#307| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@157|) (Lit |key#0@@181|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :weight 3
 :skolemid |6309|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@157|) (Lit |key#0@@181|)))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@641 T@U) (|s#0@@289| T@U) (|m#0@@158| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@641) LayerTypeType)) (= (type |s#0@@289|) (SeqType BoxType))) (= (type |m#0@@158|) (MapType BoxType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@641) |s#0@@289| |m#0@@158|) (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V $ly@@641 |s#0@@289| |m#0@@158|)))
 :qid |unknown.0:0|
 :skolemid |6310|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@641) |s#0@@289| |m#0@@158|))
)))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@642 T@U) (|s#0@@290| T@U) (|m#0@@159| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@642) LayerTypeType)) (= (type |s#0@@290|) (SeqType BoxType))) (= (type |m#0@@159|) (MapType BoxType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $ly@@642 |s#0@@290| |m#0@@159|) (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@290| |m#0@@159|)))
 :qid |unknown.0:0|
 :skolemid |6311|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@642) |s#0@@290| |m#0@@159|))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@643 T@U) (|s#0@@291| T@U) (|m#0@@160| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@643) LayerTypeType)) (= (type |s#0@@291|) (SeqType BoxType))) (= (type |m#0@@160|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@291| |m#0@@160|) (and ($Is |s#0@@291| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@160| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |6312|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 $ly@@643 |s#0@@291| |m#0@@160|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@644 T@U) (|s#0@@292| T@U) (|m#0@@161| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@644) LayerTypeType)) (= (type |s#0@@292|) (SeqType BoxType))) (= (type |m#0@@161|) (MapType BoxType BoxType))) (and ($Is |s#0@@292| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@161| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@644 |s#0@@292| |m#0@@161|) true))
 :qid |unknown.0:0|
 :skolemid |6313|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@644 |s#0@@292| |m#0@@161|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@645 T@U) (|s#0@@293| T@U) (|m#0@@162| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@645) LayerTypeType)) (= (type |s#0@@293|) (SeqType BoxType))) (= (type |m#0@@162|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@293| |m#0@@162|) (and ($Is |s#0@@293| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@162| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@293|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|))) (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|)))) (and (forall ((|i#0@@131| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@131|) (=> (INTERNAL_lt_boogie |i#0@@131| (|Seq#Length| |s#0@@293|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@131|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@131|) (INTERNAL_lt_boogie |i#0@@131| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@131|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@131|) (=> (INTERNAL_lt_boogie |i#0@@131| (|Seq#Length| |s#0@@293|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@131|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@131|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6317|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@131|)))
)) (=> (forall ((|i#0@@132| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@132|) (INTERNAL_lt_boogie |i#0@@132| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@132|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@132|) (INTERNAL_lt_boogie |i#0@@132| (|Seq#Length| |s#0@@293|))) (= (MapType0Select (|Map#Elements| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@132|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@132|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6320|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@132|)))
)) (forall ((|key#0@@182| T@U) ) (!  (=> (and (and (= (type |key#0@@182|) DatatypeTypeType) ($Is |key#0@@182| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@182|)))) (forall ((|i#1@@44| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@44|) (=> (INTERNAL_lt_boogie |i#1@@44| (|Seq#Length| |s#0@@293|)) (and (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@44|))))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |key#0@@182|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@44|)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@44|)))) |key#0@@182|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@44|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |6318|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@44|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |6319|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@182|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@182|)))
)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@645) |s#0@@293| |m#0@@162|)  (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|)))) (forall ((|i#0@@133| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@133|) (INTERNAL_lt_boogie |i#0@@133| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@133|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@133|) (INTERNAL_lt_boogie |i#0@@133| (|Seq#Length| |s#0@@293|))) (= (MapType0Select (|Map#Elements| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@133|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@133|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6314|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@133|)))
))) (forall ((|key#0@@183| T@U) ) (!  (=> (and (and (= (type |key#0@@183|) DatatypeTypeType) ($Is |key#0@@183| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@183|)))) (exists ((|i#1@@45| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@45|) (INTERNAL_lt_boogie |i#1@@45| (|Seq#Length| |s#0@@293|))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@45|)))) |key#0@@183|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@45|))) (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@183|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |6315|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@45|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |6316|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@183|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@183|)))
))))))
 :qid |unknown.0:0|
 :skolemid |6321|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@645) |s#0@@293| |m#0@@162|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@646 T@U) (|s#0@@294| T@U) (|m#0@@163| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@646) LayerTypeType)) (= (type |s#0@@294|) (SeqType BoxType))) (= (type |m#0@@163|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@294|) (Lit |m#0@@163|)) (and ($Is |s#0@@294| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@163| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@294|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|)))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|))))) (and (forall ((|i#2@@12| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@12|) (=> (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@294|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@12|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@12|) (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@12|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@12|) (=> (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@294|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@12|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@12|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6325|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@12|)))
)) (=> (forall ((|i#2@@13| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@13|) (INTERNAL_lt_boogie |i#2@@13| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@13|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@13|) (INTERNAL_lt_boogie |i#2@@13| (|Seq#Length| (Lit |s#0@@294|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@13|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@13|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6328|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@13|)))
)) (forall ((|key#1@@12| T@U) ) (!  (=> (and (and (= (type |key#1@@12|) DatatypeTypeType) ($Is |key#1@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@12|)))) (forall ((|i#3@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@5|) (=> (INTERNAL_lt_boogie |i#3@@5| (|Seq#Length| (Lit |s#0@@294|))) (and (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@5|))))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |key#1@@12|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@5|)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@5|)))) |key#1@@12|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@5|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |6326|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#3@@5|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |6327|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@163|) ($Box |key#1@@12|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@12|)))
)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@646) (Lit |s#0@@294|) (Lit |m#0@@163|))  (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|))))) (forall ((|i#2@@14| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@14|) (INTERNAL_lt_boogie |i#2@@14| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@14|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@14|) (INTERNAL_lt_boogie |i#2@@14| (|Seq#Length| (Lit |s#0@@294|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@14|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@14|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |6322|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@14|)))
))) (forall ((|key#1@@13| T@U) ) (!  (=> (and (and (= (type |key#1@@13|) DatatypeTypeType) ($Is |key#1@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@13|)))) (exists ((|i#3@@6| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@6|) (INTERNAL_lt_boogie |i#3@@6| (|Seq#Length| (Lit |s#0@@294|)))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@6|)))) |key#1@@13|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@6|))) (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) ($Box |key#1@@13|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |6323|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#3@@6|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |6324|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@163|) ($Box |key#1@@13|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@13|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |6329|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@646) (Lit |s#0@@294|) (Lit |m#0@@163|)))
))))
(assert (forall ((arg0@@631 T@U) (arg1@@326 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.minimum arg0@@631 arg1@@326)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.minimum|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum arg0@@631 arg1@@326))
)))
(assert (forall (($ly@@647 T@U) (|s#0@@295| T@U) ) (!  (=> (and (= (type $ly@@647) LayerTypeType) (= (type |s#0@@295|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@647) |s#0@@295|) (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@647 |s#0@@295|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |6330|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@647) |s#0@@295|))
)))
(assert (forall (($ly@@648 T@U) (|s#0@@296| T@U) ) (!  (=> (and (= (type $ly@@648) LayerTypeType) (= (type |s#0@@296|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@648 |s#0@@296|) (Upperbounded__Lexicographic__Byte__Order.__default.minimum $LZ |s#0@@296|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |6331|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum (AsFuelBottom $ly@@648) |s#0@@296|))
)))
(assert  (=> true (forall (($ly@@649 T@U) (|s#0@@297| T@U) ) (!  (=> (and (and (= (type $ly@@649) LayerTypeType) (= (type |s#0@@297|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@297|) (and ($Is |s#0@@297| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@297|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@297| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@649 |s#0@@297|)))) (forall ((|y#0@@19| T@U) ) (!  (=> (= (type |y#0@@19|) DatatypeTypeType) (=> (and ($Is |y#0@@19| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@297| ($Box |y#0@@19|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@649 |s#0@@297|) |y#0@@19|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.876:18|
 :skolemid |6332|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@649 |s#0@@297|) |y#0@@19|))
 :pattern ( (MapType0Select |s#0@@297| ($Box |y#0@@19|)))
))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@649 |s#0@@297|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |6333|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@649 |s#0@@297|))
))))
(assert (forall (($ly@@650 T@U) ($Heap@@92 T@U) (|s#0@@298| T@U) ) (!  (=> (and (and (and (= (type $ly@@650) LayerTypeType) (= (type $Heap@@92) (MapType0Type refType MapType1Type))) (= (type |s#0@@298|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@92) ($Is |s#0@@298| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| $ly@@650 |s#0@@298|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@298|) 1)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |6334|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| $ly@@650 |s#0@@298|) ($IsGoodHeap $Heap@@92))
)))
(assert (forall ((arg0@@632 T@U) ) (! (= (type (|$let#49_a| arg0@@632)) DatatypeTypeType)
 :qid |funType:$let#49_a|
 :pattern ( (|$let#49_a| arg0@@632))
)))
(assert (forall ((s@@57 T@U) ) (!  (=> (and (= (type s@@57) (MapType0Type BoxType boolType)) (|$let#49$canCall| s@@57)) (and ($Is (|$let#49_a| s@@57) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select s@@57 ($Box (|$let#49_a| s@@57))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.881:5|
 :skolemid |6335|
 :pattern ( (|$let#49_a| s@@57))
)))
(assert  (=> true (forall (($ly@@651 T@U) ($Heap@@93 T@U) (|s#0@@299| T@U) ) (!  (=> (and (and (and (= (type $ly@@651) LayerTypeType) (= (type $Heap@@93) (MapType0Type refType MapType1Type))) (= (type |s#0@@299|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@299|) (and (and ($IsGoodHeap $Heap@@93) ($Is |s#0@@299| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@299|) 1)))) (and (and (|$let#49$canCall| |s#0@@299|) (let ((|s'#1@@3| (|Set#Difference| |s#0@@299| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#49_a| |s#0@@299|))))))
 (=> (not (|Set#Equal| |s'#1@@3| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s'#1@@3|) (let ((|m'#1@@5| (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@651 |s'#1@@3|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|$let#49_a| |s#0@@299|) |m'#1@@5|)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@651) |s#0@@299|) (let ((|a#0@@205| (|$let#49_a| |s#0@@299|)))
(let ((|s'#0@@3| (|Set#Difference| |s#0@@299| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@205|)))))
(ite (|Set#Equal| |s'#0@@3| (|Set#Empty| BoxType)) |a#0@@205| (let ((|m'#0@@14| (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@651 |s'#0@@3|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@205| |m'#0@@14|) |a#0@@205| |m'#0@@14|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |6336|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@651) |s#0@@299|) ($IsGoodHeap $Heap@@93))
))))
(assert  (=> true (forall (($ly@@652 T@U) ($Heap@@94 T@U) (|s#0@@300| T@U) ) (!  (=> (and (and (and (= (type $ly@@652) LayerTypeType) (= (type $Heap@@94) (MapType0Type refType MapType1Type))) (= (type |s#0@@300|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@300|)) (and (and ($IsGoodHeap $Heap@@94) ($Is |s#0@@300| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@300|)) 1)))) (and (and (|$let#49$canCall| (Lit |s#0@@300|)) (let ((|s'#3@@3| (|Set#Difference| |s#0@@300| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#49_a| (Lit |s#0@@300|)))))))
 (=> (not (|Set#Equal| |s'#3@@3| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s'#3@@3|) (let ((|m'#3@@3| (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@652) |s'#3@@3|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|$let#49_a| (Lit |s#0@@300|)) |m'#3@@3|)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@652) (Lit |s#0@@300|)) (let ((|a#1@@8| (|$let#49_a| (Lit |s#0@@300|))))
(let ((|s'#2@@3| (|Set#Difference| |s#0@@300| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@8|)))))
(ite (|Set#Equal| |s'#2@@3| (|Set#Empty| BoxType)) |a#1@@8| (let ((|m'#2@@4| (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@652) |s'#2@@3|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#1@@8| |m'#2@@4|) |a#1@@8| |m'#2@@4|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :weight 3
 :skolemid |6337|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@652) (Lit |s#0@@300|)) ($IsGoodHeap $Heap@@94))
))))
(assert (forall ((arg0@@633 T@U) (arg1@@327 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt arg0@@633 arg1@@327)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt arg0@@633 arg1@@327))
)))
(assert (forall (($ly@@653 T@U) (|s#0@@301| T@U) ) (!  (=> (and (= (type $ly@@653) LayerTypeType) (= (type |s#0@@301|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@653) |s#0@@301|) (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@653 |s#0@@301|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |6338|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@653) |s#0@@301|))
)))
(assert (forall (($ly@@654 T@U) (|s#0@@302| T@U) ) (!  (=> (and (= (type $ly@@654) LayerTypeType) (= (type |s#0@@302|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@654 |s#0@@302|) (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $LZ |s#0@@302|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |6339|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@654) |s#0@@302|))
)))
(assert  (=> true (forall (($ly@@655 T@U) (|s#0@@303| T@U) ) (!  (=> (and (and (= (type $ly@@655) LayerTypeType) (= (type |s#0@@303|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@303|) ($Is |s#0@@303| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|)) (U_2_bool (MapType0Select |s#0@@303| (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|))))) (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|)) (forall ((|y#0@@20| T@U) ) (!  (=> (= (type |y#0@@20|) DatatypeTypeType) (=> (and ($Is |y#0@@20| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@303| ($Box |y#0@@20|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|))) |y#0@@20|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.899:30|
 :skolemid |6340|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|))) |y#0@@20|))
 :pattern ( (MapType0Select |s#0@@303| ($Box |y#0@@20|)))
)))) (=> (Options.Option.None_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|)) (|Set#Equal| |s#0@@303| (|Set#Empty| BoxType)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |6341|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@655 |s#0@@303|))
))))
(assert (forall (($ly@@656 T@U) (|s#0@@304| T@U) ) (!  (=> (and (and (= (type $ly@@656) LayerTypeType) (= (type |s#0@@304|) (MapType0Type BoxType boolType))) ($Is |s#0@@304| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@656 |s#0@@304|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |6342|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@656 |s#0@@304|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@657 T@U) (|s#0@@305| T@U) ) (!  (=> (and (and (= (type $ly@@657) LayerTypeType) (= (type |s#0@@305|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@305|) ($Is |s#0@@305| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@305| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@305|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@657) |s#0@@305|) (ite (|Set#Equal| |s#0@@305| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum |s#0@@305|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |6343|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@657) |s#0@@305|))
))))
(assert  (=> true (forall (($ly@@658 T@U) (|s#0@@306| T@U) ) (!  (=> (and (and (= (type $ly@@658) LayerTypeType) (= (type |s#0@@306|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@306|)) ($Is |s#0@@306| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@306| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@306|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@658) (Lit |s#0@@306|)) (ite (|Set#Equal| |s#0@@306| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum (Lit |s#0@@306|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :weight 3
 :skolemid |6344|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@658) (Lit |s#0@@306|)))
))))
(assert (forall ((arg0@@634 T@U) (arg1@@328 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.maximum arg0@@634 arg1@@328)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.maximum|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum arg0@@634 arg1@@328))
)))
(assert (forall (($ly@@659 T@U) (|s#0@@307| T@U) ) (!  (=> (and (= (type $ly@@659) LayerTypeType) (= (type |s#0@@307|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@659) |s#0@@307|) (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@659 |s#0@@307|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |6345|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@659) |s#0@@307|))
)))
(assert (forall (($ly@@660 T@U) (|s#0@@308| T@U) ) (!  (=> (and (= (type $ly@@660) LayerTypeType) (= (type |s#0@@308|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@660 |s#0@@308|) (Upperbounded__Lexicographic__Byte__Order.__default.maximum $LZ |s#0@@308|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |6346|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum (AsFuelBottom $ly@@660) |s#0@@308|))
)))
(assert  (=> true (forall (($ly@@661 T@U) (|s#0@@309| T@U) ) (!  (=> (and (and (= (type $ly@@661) LayerTypeType) (= (type |s#0@@309|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@309|) (and ($Is |s#0@@309| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@309|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@309| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@661 |s#0@@309|)))) (forall ((|y#0@@21| T@U) ) (!  (=> (= (type |y#0@@21|) DatatypeTypeType) (=> (and ($Is |y#0@@21| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@309| ($Box |y#0@@21|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@21| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@661 |s#0@@309|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.908:18|
 :skolemid |6347|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@21| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@661 |s#0@@309|)))
 :pattern ( (MapType0Select |s#0@@309| ($Box |y#0@@21|)))
))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@661 |s#0@@309|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |6348|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@661 |s#0@@309|))
))))
(assert (forall (($ly@@662 T@U) ($Heap@@95 T@U) (|s#0@@310| T@U) ) (!  (=> (and (and (and (= (type $ly@@662) LayerTypeType) (= (type $Heap@@95) (MapType0Type refType MapType1Type))) (= (type |s#0@@310|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@95) ($Is |s#0@@310| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| $ly@@662 |s#0@@310|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@310|) 1)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |6349|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| $ly@@662 |s#0@@310|) ($IsGoodHeap $Heap@@95))
)))
(assert (forall ((arg0@@635 T@U) ) (! (= (type (|$let#52_a| arg0@@635)) DatatypeTypeType)
 :qid |funType:$let#52_a|
 :pattern ( (|$let#52_a| arg0@@635))
)))
(assert (forall ((s@@58 T@U) ) (!  (=> (and (= (type s@@58) (MapType0Type BoxType boolType)) (|$let#52$canCall| s@@58)) (and ($Is (|$let#52_a| s@@58) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select s@@58 ($Box (|$let#52_a| s@@58))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.911:5|
 :skolemid |6350|
 :pattern ( (|$let#52_a| s@@58))
)))
(assert  (=> true (forall (($ly@@663 T@U) ($Heap@@96 T@U) (|s#0@@311| T@U) ) (!  (=> (and (and (and (= (type $ly@@663) LayerTypeType) (= (type $Heap@@96) (MapType0Type refType MapType1Type))) (= (type |s#0@@311|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@311|) (and (and ($IsGoodHeap $Heap@@96) ($Is |s#0@@311| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@311|) 1)))) (and (and (|$let#52$canCall| |s#0@@311|) (let ((|s'#1@@4| (|Set#Difference| |s#0@@311| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#52_a| |s#0@@311|))))))
 (=> (not (|Set#Equal| |s'#1@@4| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s'#1@@4|) (let ((|m'#1@@6| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@663 |s'#1@@4|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |m'#1@@6| (|$let#52_a| |s#0@@311|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@663) |s#0@@311|) (let ((|a#0@@206| (|$let#52_a| |s#0@@311|)))
(let ((|s'#0@@4| (|Set#Difference| |s#0@@311| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@206|)))))
(ite (|Set#Equal| |s'#0@@4| (|Set#Empty| BoxType)) |a#0@@206| (let ((|m'#0@@15| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@663 |s'#0@@4|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |m'#0@@15| |a#0@@206|) |a#0@@206| |m'#0@@15|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |6351|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@663) |s#0@@311|) ($IsGoodHeap $Heap@@96))
))))
(assert  (=> true (forall (($ly@@664 T@U) ($Heap@@97 T@U) (|s#0@@312| T@U) ) (!  (=> (and (and (and (= (type $ly@@664) LayerTypeType) (= (type $Heap@@97) (MapType0Type refType MapType1Type))) (= (type |s#0@@312|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@312|)) (and (and ($IsGoodHeap $Heap@@97) ($Is |s#0@@312| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@312|)) 1)))) (and (and (|$let#52$canCall| (Lit |s#0@@312|)) (let ((|s'#3@@4| (|Set#Difference| |s#0@@312| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#52_a| (Lit |s#0@@312|)))))))
 (=> (not (|Set#Equal| |s'#3@@4| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s'#3@@4|) (let ((|m'#3@@4| (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@664) |s'#3@@4|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |m'#3@@4| (|$let#52_a| (Lit |s#0@@312|)))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@664) (Lit |s#0@@312|)) (let ((|a#1@@9| (|$let#52_a| (Lit |s#0@@312|))))
(let ((|s'#2@@4| (|Set#Difference| |s#0@@312| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@9|)))))
(ite (|Set#Equal| |s'#2@@4| (|Set#Empty| BoxType)) |a#1@@9| (let ((|m'#2@@5| (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@664) |s'#2@@4|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |m'#2@@5| |a#1@@9|) |a#1@@9| |m'#2@@5|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :weight 3
 :skolemid |6352|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@664) (Lit |s#0@@312|)) ($IsGoodHeap $Heap@@97))
))))
(assert (forall ((arg0@@636 T@U) (arg1@@329 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt arg0@@636 arg1@@329)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt arg0@@636 arg1@@329))
)))
(assert (forall (($ly@@665 T@U) (|s#0@@313| T@U) ) (!  (=> (and (= (type $ly@@665) LayerTypeType) (= (type |s#0@@313|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@665) |s#0@@313|) (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@665 |s#0@@313|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |6353|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@665) |s#0@@313|))
)))
(assert (forall (($ly@@666 T@U) (|s#0@@314| T@U) ) (!  (=> (and (= (type $ly@@666) LayerTypeType) (= (type |s#0@@314|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@666 |s#0@@314|) (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $LZ |s#0@@314|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |6354|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@666) |s#0@@314|))
)))
(assert  (=> true (forall (($ly@@667 T@U) (|s#0@@315| T@U) ) (!  (=> (and (and (= (type $ly@@667) LayerTypeType) (= (type |s#0@@315|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@315|) ($Is |s#0@@315| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|)) (U_2_bool (MapType0Select |s#0@@315| (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|))))) (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|)) (forall ((|y#0@@22| T@U) ) (!  (=> (= (type |y#0@@22|) DatatypeTypeType) (=> (and ($Is |y#0@@22| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@315| ($Box |y#0@@22|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@22| ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.929:30|
 :skolemid |6355|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@22| ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|)))))
 :pattern ( (MapType0Select |s#0@@315| ($Box |y#0@@22|)))
)))) (=> (Options.Option.None_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|)) (|Set#Equal| |s#0@@315| (|Set#Empty| BoxType)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |6356|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@667 |s#0@@315|))
))))
(assert (forall (($ly@@668 T@U) (|s#0@@316| T@U) ) (!  (=> (and (and (= (type $ly@@668) LayerTypeType) (= (type |s#0@@316|) (MapType0Type BoxType boolType))) ($Is |s#0@@316| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@668 |s#0@@316|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |6357|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@668 |s#0@@316|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@669 T@U) (|s#0@@317| T@U) ) (!  (=> (and (and (= (type $ly@@669) LayerTypeType) (= (type |s#0@@317|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@317|) ($Is |s#0@@317| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@317| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@317|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@669) |s#0@@317|) (ite (|Set#Equal| |s#0@@317| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum |s#0@@317|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |6358|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@669) |s#0@@317|))
))))
(assert  (=> true (forall (($ly@@670 T@U) (|s#0@@318| T@U) ) (!  (=> (and (and (= (type $ly@@670) LayerTypeType) (= (type |s#0@@318|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@318|)) ($Is |s#0@@318| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@318| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@318|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@670) (Lit |s#0@@318|)) (ite (|Set#Equal| |s#0@@318| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum (Lit |s#0@@318|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :weight 3
 :skolemid |6359|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@670) (Lit |s#0@@318|)))
))))
(assert  (=> true (forall ((|a#0@@207| T@U) (|b#0@@155| T@U) ) (!  (=> (and (and (= (type |a#0@@207|) DatatypeTypeType) (= (type |b#0@@155|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@207| |b#0@@155|) (and ($Is |a#0@@207| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@155| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |6360|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@207| |b#0@@155|))
))))
(assert (forall ((|a#0@@208| T@U) (|b#0@@156| T@U) ) (!  (=> (and (and (= (type |a#0@@208|) DatatypeTypeType) (= (type |b#0@@156|) DatatypeTypeType)) (and ($Is |a#0@@208| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@156| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| |a#0@@208| |b#0@@156|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |6361|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| |a#0@@208| |b#0@@156|))
)))
(assert  (=> true (forall ((|a#0@@209| T@U) (|b#0@@157| T@U) ) (!  (=> (and (and (= (type |a#0@@209|) DatatypeTypeType) (= (type |b#0@@157|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@209| |b#0@@157|) (and ($Is |a#0@@209| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@157| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@209| |b#0@@157|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@209| |b#0@@157|) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |a#0@@209|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |b#0@@157|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@209| |b#0@@157|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@209| |b#0@@157|) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@209| |b#0@@157|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |6362|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@209| |b#0@@157|))
))))
(assert  (=> true (forall ((|a#0@@210| T@U) (|b#0@@158| T@U) ) (!  (=> (and (and (= (type |a#0@@210|) DatatypeTypeType) (= (type |b#0@@158|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |a#0@@210|) (Lit |b#0@@158|)) (and ($Is |a#0@@210| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@158| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@210|) (Lit |b#0@@158|)) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@210|) (Lit |b#0@@158|))))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |a#0@@210|)) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |b#0@@158|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |a#0@@210|) (Lit |b#0@@158|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@210|) (Lit |b#0@@158|)) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@210| |b#0@@158|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :weight 3
 :skolemid |6363|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |a#0@@210|) (Lit |b#0@@158|)))
))))
(assert (forall ((arg0@@637 T@U) (arg1@@330 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.Min arg0@@637 arg1@@330)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.Min|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min arg0@@637 arg1@@330))
)))
(assert  (=> true (forall ((|a#0@@211| T@U) (|b#0@@159| T@U) ) (!  (=> (and (and (= (type |a#0@@211|) DatatypeTypeType) (= (type |b#0@@159|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@211| |b#0@@159|) (and ($Is |a#0@@211| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@159| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@211| |b#0@@159|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |6366|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@211| |b#0@@159|))
))))
(assert (forall ((|a#0@@212| T@U) (|b#0@@160| T@U) ) (!  (=> (and (and (= (type |a#0@@212|) DatatypeTypeType) (= (type |b#0@@160|) DatatypeTypeType)) (and ($Is |a#0@@212| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@160| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| |a#0@@212| |b#0@@160|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |6367|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| |a#0@@212| |b#0@@160|))
)))
(assert  (=> true (forall ((|a#0@@213| T@U) (|b#0@@161| T@U) ) (!  (=> (and (and (= (type |a#0@@213|) DatatypeTypeType) (= (type |b#0@@161|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@213| |b#0@@161|) (and ($Is |a#0@@213| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@161| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@213| |b#0@@161|) (= (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@213| |b#0@@161|) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@213| |b#0@@161|) |a#0@@213| |b#0@@161|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |6368|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@213| |b#0@@161|))
))))
(assert  (=> true (forall ((|a#0@@214| T@U) (|b#0@@162| T@U) ) (!  (=> (and (and (= (type |a#0@@214|) DatatypeTypeType) (= (type |b#0@@162|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| (Lit |a#0@@214|) (Lit |b#0@@162|)) (and ($Is |a#0@@214| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@162| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@214|) (Lit |b#0@@162|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.Min (Lit |a#0@@214|) (Lit |b#0@@162|)) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@214|) (Lit |b#0@@162|)) |a#0@@214| |b#0@@162|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :weight 3
 :skolemid |6369|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min (Lit |a#0@@214|) (Lit |b#0@@162|)))
))))
(assert (forall ((arg0@@638 T@U) (arg1@@331 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.Max arg0@@638 arg1@@331)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.Max|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max arg0@@638 arg1@@331))
)))
(assert  (=> true (forall ((|a#0@@215| T@U) (|b#0@@163| T@U) ) (!  (=> (and (and (= (type |a#0@@215|) DatatypeTypeType) (= (type |b#0@@163|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@215| |b#0@@163|) (and ($Is |a#0@@215| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@163| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@215| |b#0@@163|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |6370|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@215| |b#0@@163|))
))))
(assert (forall ((|a#0@@216| T@U) (|b#0@@164| T@U) ) (!  (=> (and (and (= (type |a#0@@216|) DatatypeTypeType) (= (type |b#0@@164|) DatatypeTypeType)) (and ($Is |a#0@@216| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@164| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| |a#0@@216| |b#0@@164|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |6371|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| |a#0@@216| |b#0@@164|))
)))
(assert  (=> true (forall ((|a#0@@217| T@U) (|b#0@@165| T@U) ) (!  (=> (and (and (= (type |a#0@@217|) DatatypeTypeType) (= (type |b#0@@165|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@217| |b#0@@165|) (and ($Is |a#0@@217| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@165| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@217| |b#0@@165|) (= (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@217| |b#0@@165|) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@217| |b#0@@165|) |b#0@@165| |a#0@@217|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |6372|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@217| |b#0@@165|))
))))
(assert  (=> true (forall ((|a#0@@218| T@U) (|b#0@@166| T@U) ) (!  (=> (and (and (= (type |a#0@@218|) DatatypeTypeType) (= (type |b#0@@166|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| (Lit |a#0@@218|) (Lit |b#0@@166|)) (and ($Is |a#0@@218| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@166| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@218|) (Lit |b#0@@166|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.Max (Lit |a#0@@218|) (Lit |b#0@@166|)) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@218|) (Lit |b#0@@166|)) |b#0@@166| |a#0@@218|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :weight 3
 :skolemid |6373|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max (Lit |a#0@@218|) (Lit |b#0@@166|)))
))))
(assert (forall (($ly@@671 T@U) (|run#0@@201| T@U) ) (!  (=> (and (= (type $ly@@671) LayerTypeType) (= (type |run#0@@201|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@671) |run#0@@201|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@671 |run#0@@201|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |6374|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@671) |run#0@@201|))
)))
(assert (forall (($ly@@672 T@U) (|run#0@@202| T@U) ) (!  (=> (and (= (type $ly@@672) LayerTypeType) (= (type |run#0@@202|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@672 |run#0@@202|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $LZ |run#0@@202|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |6375|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted (AsFuelBottom $ly@@672) |run#0@@202|))
)))
(assert  (=> true (forall (($ly@@673 T@U) (|run#0@@203| T@U) ) (!  (=> (and (and (= (type $ly@@673) LayerTypeType) (= (type |run#0@@203|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@203|) ($Is |run#0@@203| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (= (|Seq#Length| |run#0@@203|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@673 |run#0@@203|)) (=> (= (|Seq#Length| |run#0@@203|) (LitInt 1)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@673 |run#0@@203|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |6376|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@673 |run#0@@203|))
))))
(assert (forall (($ly@@674 T@U) (|run#0@@204| T@U) ) (!  (=> (and (and (= (type $ly@@674) LayerTypeType) (= (type |run#0@@204|) (SeqType BoxType))) ($Is |run#0@@204| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@674 |run#0@@204|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |6377|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@674 |run#0@@204|))
)))
(assert  (=> true (forall (($ly@@675 T@U) (|run#0@@205| T@U) ) (!  (=> (and (and (= (type $ly@@675) LayerTypeType) (= (type |run#0@@205|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@205|) ($Is |run#0@@205| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#0@@134| Int) (|j#0@@22| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@134|) (=> (INTERNAL_le_boogie |i#0@@134| |j#0@@22|) (=> (INTERNAL_lt_boogie |j#0@@22| (|Seq#Length| |run#0@@205|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@134|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@22|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |6379|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@22|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@134|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@675) |run#0@@205|) (forall ((|i#0@@135| Int) (|j#0@@23| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@135|) (INTERNAL_le_boogie |i#0@@135| |j#0@@23|)) (INTERNAL_lt_boogie |j#0@@23| (|Seq#Length| |run#0@@205|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@135|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@23|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |6378|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@23|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@135|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |6380|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@675) |run#0@@205|))
))))
(assert  (=> true (forall (($ly@@676 T@U) (|run#0@@206| T@U) ) (!  (=> (and (and (= (type $ly@@676) LayerTypeType) (= (type |run#0@@206|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@206|)) ($Is |run#0@@206| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#1@@46| Int) (|j#1@@11| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@46|) (=> (INTERNAL_le_boogie |i#1@@46| |j#1@@11|) (=> (INTERNAL_lt_boogie |j#1@@11| (|Seq#Length| (Lit |run#0@@206|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |i#1@@46|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |j#1@@11|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |6382|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |j#1@@11|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |i#1@@46|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@676) (Lit |run#0@@206|)) (forall ((|i#1@@47| Int) (|j#1@@12| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@47|) (INTERNAL_le_boogie |i#1@@47| |j#1@@12|)) (INTERNAL_lt_boogie |j#1@@12| (|Seq#Length| (Lit |run#0@@206|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |i#1@@47|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |j#1@@12|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |6381|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |j#1@@12|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |i#1@@47|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :weight 3
 :skolemid |6383|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@676) (Lit |run#0@@206|)))
))))
(assert  (=> true (forall ((|run#0@@207| T@U) ) (!  (=> (and (= (type |run#0@@207|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@207|) ($Is |run#0@@207| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |6384|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@207|))
))))
(assert (forall ((|run#0@@208| T@U) ) (!  (=> (and (= (type |run#0@@208|) (SeqType BoxType)) ($Is |run#0@@208| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@208|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |6385|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@208|))
)))
(assert  (=> true (forall ((|run#0@@209| T@U) ) (!  (=> (and (= (type |run#0@@209|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@209|) ($Is |run#0@@209| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#0@@136| Int) (|j#0@@24| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@136|) (=> (INTERNAL_lt_boogie |i#0@@136| |j#0@@24|) (=> (INTERNAL_lt_boogie |j#0@@24| (|Seq#Length| |run#0@@209|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@136|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@24|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |6387|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@24|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@136|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@209|) (forall ((|i#0@@137| Int) (|j#0@@25| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@137|) (INTERNAL_lt_boogie |i#0@@137| |j#0@@25|)) (INTERNAL_lt_boogie |j#0@@25| (|Seq#Length| |run#0@@209|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@137|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@25|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |6386|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@25|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@137|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |6388|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@209|))
))))
(assert  (=> true (forall ((|run#0@@210| T@U) ) (!  (=> (and (= (type |run#0@@210|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@210|)) ($Is |run#0@@210| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#1@@48| Int) (|j#1@@13| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@48|) (=> (INTERNAL_lt_boogie |i#1@@48| |j#1@@13|) (=> (INTERNAL_lt_boogie |j#1@@13| (|Seq#Length| (Lit |run#0@@210|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |i#1@@48|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |j#1@@13|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |6390|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |j#1@@13|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |i#1@@48|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@210|)) (forall ((|i#1@@49| Int) (|j#1@@14| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@49|) (INTERNAL_lt_boogie |i#1@@49| |j#1@@14|)) (INTERNAL_lt_boogie |j#1@@14| (|Seq#Length| (Lit |run#0@@210|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |i#1@@49|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |j#1@@14|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |6389|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |j#1@@14|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |i#1@@49|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :weight 3
 :skolemid |6391|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@210|)))
))))
(assert (forall (($ly@@677 T@U) (|run#0@@211| T@U) ) (!  (=> (and (= (type $ly@@677) LayerTypeType) (= (type |run#0@@211|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@677) |run#0@@211|) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@677 |run#0@@211|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |6392|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@677) |run#0@@211|))
)))
(assert (forall (($ly@@678 T@U) (|run#0@@212| T@U) ) (!  (=> (and (= (type $ly@@678) LayerTypeType) (= (type |run#0@@212|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@678 |run#0@@212|) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $LZ |run#0@@212|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |6393|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@678) |run#0@@212|))
)))
(assert  (=> true (forall (($ly@@679 T@U) (|run#0@@213| T@U) ) (!  (=> (and (and (= (type $ly@@679) LayerTypeType) (= (type |run#0@@213|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@213|) ($Is |run#0@@213| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (=> (= (|Seq#Length| |run#0@@213|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@679 |run#0@@213|)) (=> (= (|Seq#Length| |run#0@@213|) (LitInt 1)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@679 |run#0@@213|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@679 |run#0@@213|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@213|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |6394|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@679 |run#0@@213|))
))))
(assert (forall (($ly@@680 T@U) (|run#0@@214| T@U) ) (!  (=> (and (and (= (type $ly@@680) LayerTypeType) (= (type |run#0@@214|) (SeqType BoxType))) ($Is |run#0@@214| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@680 |run#0@@214|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |6395|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@680 |run#0@@214|))
)))
(assert  (=> true (forall (($ly@@681 T@U) (|run#0@@215| T@U) ) (!  (=> (and (and (= (type $ly@@681) LayerTypeType) (= (type |run#0@@215|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@215|) ($Is |run#0@@215| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@215|) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@681) |run#0@@215|) (let ((|b#0@@167| (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@215|)))
(ite |b#0@@167| |b#0@@167| |b#0@@167|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |6396|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@681) |run#0@@215|))
))))
(assert  (=> true (forall (($ly@@682 T@U) (|run#0@@216| T@U) ) (!  (=> (and (and (= (type $ly@@682) LayerTypeType) (= (type |run#0@@216|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@216|)) ($Is |run#0@@216| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@216|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@682) (Lit |run#0@@216|)) (let ((|b#1@@10| (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@216|)))))))
(ite |b#1@@10| |b#1@@10| |b#1@@10|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :weight 3
 :skolemid |6397|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@682) (Lit |run#0@@216|)))
))))
(assert  (=> true (forall ((|e#0@@15| T@U) (|s#0@@319| T@U) ) (!  (=> (and (and (= (type |e#0@@15|) DatatypeTypeType) (= (type |s#0@@319|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@15| |s#0@@319|) (and (and ($Is |e#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@319| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@319|))))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |6398|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@15| |s#0@@319|))
))))
(assert (forall ((|e#0@@16| T@U) (|s#0@@320| T@U) ) (!  (=> (and (and (= (type |e#0@@16|) DatatypeTypeType) (= (type |s#0@@320|) (MapType0Type BoxType boolType))) (and ($Is |e#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@320| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@16| |s#0@@320|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@320|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |6399|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@16| |s#0@@320|))
)))
(assert  (=> true (forall ((|e#0@@17| T@U) (|s#0@@321| T@U) ) (!  (=> (and (and (= (type |e#0@@17|) DatatypeTypeType) (= (type |s#0@@321|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@17| |s#0@@321|) (and (and ($Is |e#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@321| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@321|))))) (and (=> (U_2_bool (MapType0Select |s#0@@321| ($Box |e#0@@17|))) (forall ((|e2#0@@3| T@U) ) (!  (=> (and (= (type |e2#0@@3|) DatatypeTypeType) ($Is |e2#0@@3| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (=> (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@3|))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e2#0@@3|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e#0@@17|))) (=> (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@3|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#0@@3| |e#0@@17|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |e2#0@@3| |e#0@@17|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |6401|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@3| |e#0@@17|))
 :pattern ( (MapType0Select |s#0@@321| ($Box |e2#0@@3|)))
))) (= (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@17| |s#0@@321|)  (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e#0@@17|))) (forall ((|e2#0@@4| T@U) ) (!  (=> (= (type |e2#0@@4|) DatatypeTypeType) (=> (and ($Is |e2#0@@4| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@4|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#0@@4| |e#0@@17|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@4| |e#0@@17|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |6400|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@4| |e#0@@17|))
 :pattern ( (MapType0Select |s#0@@321| ($Box |e2#0@@4|)))
))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |6402|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@17| |s#0@@321|))
))))
(assert  (=> true (forall ((|e#0@@18| T@U) (|s#0@@322| T@U) ) (!  (=> (and (and (= (type |e#0@@18|) DatatypeTypeType) (= (type |s#0@@322|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (Lit |e#0@@18|) (Lit |s#0@@322|)) (and (and ($Is |e#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@322| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@322|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box (Lit |e#0@@18|)))) (forall ((|e2#1@@3| T@U) ) (!  (=> (and (= (type |e2#1@@3|) DatatypeTypeType) ($Is |e2#1@@3| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@3|))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e2#1@@3|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |e#0@@18|)))) (=> (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@3|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#1@@3| |e#0@@18|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |e2#1@@3| (Lit |e#0@@18|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |6404|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@3| |e#0@@18|))
 :pattern ( (MapType0Select |s#0@@322| ($Box |e2#1@@3|)))
))) (= (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@18|) (Lit |s#0@@322|))  (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box (Lit |e#0@@18|)))) (forall ((|e2#1@@4| T@U) ) (!  (=> (= (type |e2#1@@4|) DatatypeTypeType) (=> (and ($Is |e2#1@@4| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@4|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#1@@4| |e#0@@18|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@4| (Lit |e#0@@18|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |6403|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@4| |e#0@@18|))
 :pattern ( (MapType0Select |s#0@@322| ($Box |e2#1@@4|)))
))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :weight 3
 :skolemid |6405|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@18|) (Lit |s#0@@322|)))
))))
(assert (forall ((arg0@@639 T@U) (arg1@@332 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SortSet arg0@@639 arg1@@332)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SortSet|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet arg0@@639 arg1@@332))
)))
(assert (forall (($ly@@683 T@U) (|s#0@@323| T@U) ) (!  (=> (and (= (type $ly@@683) LayerTypeType) (= (type |s#0@@323|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@683) |s#0@@323|) (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@683 |s#0@@323|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |6406|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@683) |s#0@@323|))
)))
(assert (forall (($ly@@684 T@U) (|s#0@@324| T@U) ) (!  (=> (and (= (type $ly@@684) LayerTypeType) (= (type |s#0@@324|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@684 |s#0@@324|) (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $LZ |s#0@@324|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |6407|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet (AsFuelBottom $ly@@684) |s#0@@324|))
)))
(assert  (=> true (forall (($ly@@685 T@U) (|s#0@@325| T@U) ) (!  (=> (and (and (= (type $ly@@685) LayerTypeType) (= (type |s#0@@325|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@325|) ($Is |s#0@@325| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (= (|Set#Card| |s#0@@325|) (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|))) (forall ((|t#0@@15| T@U) ) (!  (=> (and (= (type |t#0@@15|) DatatypeTypeType) ($Is |t#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (U_2_bool (MapType0Select |s#0@@325| ($Box |t#0@@15|))) (|Seq#Contains| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|) ($Box |t#0@@15|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.239:20|
 :skolemid |6408|
 :pattern ( (|Seq#Contains| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|) ($Box |t#0@@15|)))
 :pattern ( (MapType0Select |s#0@@325| ($Box |t#0@@15|)))
))) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |6409|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@685 |s#0@@325|))
))))
(assert (forall (($ly@@686 T@U) ($Heap@@98 T@U) (|s#0@@326| T@U) ) (!  (=> (and (and (and (= (type $ly@@686) LayerTypeType) (= (type $Heap@@98) (MapType0Type refType MapType1Type))) (= (type |s#0@@326|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@98) ($Is |s#0@@326| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@686 |s#0@@326|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |6410|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@686 |s#0@@326|) ($IsGoodHeap $Heap@@98))
)))
(assert (forall ((arg0@@640 T@U) ) (! (= (type (|$let#55_e| arg0@@640)) DatatypeTypeType)
 :qid |funType:$let#55_e|
 :pattern ( (|$let#55_e| arg0@@640))
)))
(assert (forall ((s@@59 T@U) ) (!  (=> (and (= (type s@@59) (MapType0Type BoxType boolType)) (|$let#55$canCall| s@@59)) (and ($Is (|$let#55_e| s@@59) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (|$let#55_e| s@@59) s@@59)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.249:7|
 :skolemid |6411|
 :pattern ( (|$let#55_e| s@@59))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@687 T@U) ($Heap@@99 T@U) (|s#0@@327| T@U) ) (!  (=> (and (and (and (= (type $ly@@687) LayerTypeType) (= (type $Heap@@99) (MapType0Type refType MapType1Type))) (= (type |s#0@@327|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@327|) (and ($IsGoodHeap $Heap@@99) ($Is |s#0@@327| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (=> (not (= (|Set#Card| |s#0@@327|) (LitInt 0))) (and (|$let#55$canCall| |s#0@@327|) (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@327| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#55_e| |s#0@@327|))))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@687) |s#0@@327|) (ite (= (|Set#Card| |s#0@@327|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@19| (|$let#55_e| |s#0@@327|)))
(|Seq#Append| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@687 (|Set#Difference| |s#0@@327| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#0@@19|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#0@@19|)))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |6412|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@687) |s#0@@327|) ($IsGoodHeap $Heap@@99))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@688 T@U) ($Heap@@100 T@U) (|s#0@@328| T@U) ) (!  (=> (and (and (and (= (type $ly@@688) LayerTypeType) (= (type $Heap@@100) (MapType0Type refType MapType1Type))) (= (type |s#0@@328|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (Lit |s#0@@328|)) (and ($IsGoodHeap $Heap@@100) ($Is |s#0@@328| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@328|)) (LitInt 0))) (and (|$let#55$canCall| (Lit |s#0@@328|)) (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@328| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#55_e| (Lit |s#0@@328|)))))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@688) (Lit |s#0@@328|)) (ite (= (|Set#Card| (Lit |s#0@@328|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@2| (|$let#55_e| (Lit |s#0@@328|))))
(|Seq#Append| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@688) (|Set#Difference| |s#0@@328| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#1@@2|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#1@@2|)))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :weight 3
 :skolemid |6413|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@688) (Lit |s#0@@328|)) ($IsGoodHeap $Heap@@100))
))))
(assert (forall ((|a#0#0#0@@6| T@U) ) (!  (=> (= (type |a#0#0#0@@6|) (SeqType BoxType)) (= (DatatypeCtorId (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#0#0#0@@6|)) |##Upperbounded_Lexicographic_Byte_Order.Element.Element|))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6414|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#0#0#0@@6|))
)))
(assert (forall ((d@@73 T@U) ) (!  (=> (= (type d@@73) DatatypeTypeType) (= (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@73) (= (DatatypeCtorId d@@73) |##Upperbounded_Lexicographic_Byte_Order.Element.Element|)))
 :qid |unknown.0:0|
 :skolemid |6415|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@73))
)))
(assert (forall ((d@@74 T@U) ) (!  (=> (and (= (type d@@74) DatatypeTypeType) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@74)) (exists ((|a#1#0#0@@6| T@U) ) (!  (and (= (type |a#1#0#0@@6|) (SeqType BoxType)) (= d@@74 (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#1#0#0@@6|)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6416|
 :no-pattern (type |a#1#0#0@@6|)
 :no-pattern (U_2_int |a#1#0#0@@6|)
 :no-pattern (U_2_bool |a#1#0#0@@6|)
)))
 :qid |unknown.0:0|
 :skolemid |6417|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@74))
)))
(assert (forall ((|a#2#0#0@@6| T@U) ) (!  (=> (= (type |a#2#0#0@@6|) (SeqType BoxType)) (= ($Is (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#2#0#0@@6|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |a#2#0#0@@6| (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6418|
 :pattern ( ($Is (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#2#0#0@@6|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (forall ((|a#3#0#0@@6| T@U) ($h@@116 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@6|) (SeqType BoxType)) (= (type $h@@116) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@116)) (= ($IsAlloc (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#3#0#0@@6|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@116) ($IsAlloc |a#3#0#0@@6| (TSeq Tclass.NativeTypes.byte) $h@@116)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6419|
 :pattern ( ($IsAlloc (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#3#0#0@@6|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@116))
)))
(assert (forall ((d@@75 T@U) ($h@@117 T@U) ) (!  (=> (and (and (= (type d@@75) DatatypeTypeType) (= (type $h@@117) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@117) (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@75) ($IsAlloc d@@75 Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@117)))) ($IsAlloc (Upperbounded__Lexicographic__Byte__Order.Element.e d@@75) (TSeq Tclass.NativeTypes.byte) $h@@117))
 :qid |unknown.0:0|
 :skolemid |6420|
 :pattern ( ($IsAlloc (Upperbounded__Lexicographic__Byte__Order.Element.e d@@75) (TSeq Tclass.NativeTypes.byte) $h@@117))
)))
(assert (forall ((|a#4#0#0@@6| T@U) ) (!  (=> (= (type |a#4#0#0@@6|) (SeqType BoxType)) (= (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |a#4#0#0@@6|)) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#4#0#0@@6|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6421|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |a#4#0#0@@6|)))
)))
(assert (forall ((|a#5#0#0@@7| T@U) ) (!  (=> (= (type |a#5#0#0@@7|) (SeqType BoxType)) (= (Upperbounded__Lexicographic__Byte__Order.Element.e (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#5#0#0@@7|)) |a#5#0#0@@7|))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6422|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#5#0#0@@7|))
)))
(assert (forall ((|a#6#0#0@@7| T@U) (i@@26 Int) ) (!  (=> (= (type |a#6#0#0@@7|) (SeqType BoxType)) (=> (and (<= 0 i@@26) (< i@@26 (|Seq#Length| |a#6#0#0@@7|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#6#0#0@@7| i@@26))) (DtRank (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#6#0#0@@7|)))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6423|
 :pattern ( (|Seq#Index| |a#6#0#0@@7| i@@26) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#6#0#0@@7|))
)))
(assert (forall ((|a#7#0#0@@7| T@U) ) (!  (=> (= (type |a#7#0#0@@7|) (SeqType BoxType)) (< (|Seq#Rank| |a#7#0#0@@7|) (DtRank (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#7#0#0@@7|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |6424|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#7#0#0@@7|))
)))
(assert (= (DatatypeCtorId |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))
(assert (forall ((d@@76 T@U) ) (!  (=> (= (type d@@76) DatatypeTypeType) (= (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@76) (= (DatatypeCtorId d@@76) |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))
 :qid |unknown.0:0|
 :skolemid |6425|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@76))
)))
(assert (forall ((d@@77 T@U) ) (!  (=> (and (= (type d@@77) DatatypeTypeType) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@77)) (= d@@77 |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))
 :qid |unknown.0:0|
 :skolemid |6426|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@77))
)))
(assert ($Is |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
(assert (forall (($h@@118 T@U) ) (!  (=> (and (= (type $h@@118) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@118)) ($IsAlloc |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@118))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |6427|
 :pattern ( ($IsAlloc |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@118))
)))
(assert (= |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))
(assert (forall ((d@@78 T@U) ) (!  (=> (and (= (type d@@78) DatatypeTypeType) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| d@@78)) (or (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@78) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@78)))
 :qid |unknown.0:0|
 :skolemid |6428|
 :pattern ( (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| d@@78))
)))
(assert (forall ((d@@79 T@U) ) (!  (=> (and (= (type d@@79) DatatypeTypeType) ($Is d@@79 Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (or (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@79) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@79)))
 :qid |unknown.0:0|
 :skolemid |6429|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@79) ($Is d@@79 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@79) ($Is d@@79 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (forall ((a@@139 T@U) (b@@88 T@U) ) (!  (=> (and (and (= (type a@@139) DatatypeTypeType) (= (type b@@88) DatatypeTypeType)) (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q a@@139) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q b@@88))) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@139 b@@88) (|Seq#Equal| (Upperbounded__Lexicographic__Byte__Order.Element.e a@@139) (Upperbounded__Lexicographic__Byte__Order.Element.e b@@88))))
 :qid |unknown.0:0|
 :skolemid |6430|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@139 b@@88) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q a@@139))
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@139 b@@88) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q b@@88))
)))
(assert (forall ((a@@140 T@U) (b@@89 T@U) ) (!  (=> (and (and (= (type a@@140) DatatypeTypeType) (= (type b@@89) DatatypeTypeType)) (and (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q a@@140) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q b@@89))) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@140 b@@89) true))
 :qid |unknown.0:0|
 :skolemid |6431|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@140 b@@89) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q a@@140))
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@140 b@@89) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q b@@89))
)))
(assert (forall ((a@@141 T@U) (b@@90 T@U) ) (!  (=> (and (= (type a@@141) DatatypeTypeType) (= (type b@@90) DatatypeTypeType)) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@141 b@@90) (= a@@141 b@@90)))
 :qid |unknown.0:0|
 :skolemid |6432|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@141 b@@90))
)))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) tytagFamily$_default))
(assert (forall ((bx@@176 T@U) ) (!  (=> (and (= (type bx@@176) BoxType) ($IsBox bx@@176 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)) (and (= ($Box ($Unbox refType bx@@176)) bx@@176) ($Is ($Unbox refType bx@@176) Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)))
 :qid |unknown.0:0|
 :skolemid |6433|
 :pattern ( ($IsBox bx@@176 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
)))
(assert (forall (($o@@63 T@U) ) (!  (=> (= (type $o@@63) refType) (= ($Is $o@@63 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)  (or (= $o@@63 null) (= (dtype $o@@63) Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))))
 :qid |unknown.0:0|
 :skolemid |6434|
 :pattern ( ($Is $o@@63 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
)))
(assert (forall (($o@@64 T@U) ($h@@119 T@U) ) (!  (=> (and (= (type $o@@64) refType) (= (type $h@@119) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@64 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default $h@@119)  (or (= $o@@64 null) (U_2_bool (MapType1Select (MapType0Select $h@@119 $o@@64) alloc)))))
 :qid |unknown.0:0|
 :skolemid |6435|
 :pattern ( ($IsAlloc $o@@64 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default $h@@119))
)))
(assert (= (type Tclass.BoundedPivotsLib.__default) TyType))
(assert (= (Tag Tclass.BoundedPivotsLib.__default) Tagclass.BoundedPivotsLib.__default))
(assert (= (TagFamily Tclass.BoundedPivotsLib.__default) tytagFamily$_default))
(assert (forall ((bx@@177 T@U) ) (!  (=> (and (= (type bx@@177) BoxType) ($IsBox bx@@177 Tclass.BoundedPivotsLib.__default)) (and (= ($Box ($Unbox refType bx@@177)) bx@@177) ($Is ($Unbox refType bx@@177) Tclass.BoundedPivotsLib.__default)))
 :qid |unknown.0:0|
 :skolemid |6436|
 :pattern ( ($IsBox bx@@177 Tclass.BoundedPivotsLib.__default))
)))
(assert (forall (($o@@65 T@U) ) (!  (=> (= (type $o@@65) refType) (= ($Is $o@@65 Tclass.BoundedPivotsLib.__default)  (or (= $o@@65 null) (= (dtype $o@@65) Tclass.BoundedPivotsLib.__default))))
 :qid |unknown.0:0|
 :skolemid |6437|
 :pattern ( ($Is $o@@65 Tclass.BoundedPivotsLib.__default))
)))
(assert (forall (($o@@66 T@U) ($h@@120 T@U) ) (!  (=> (and (= (type $o@@66) refType) (= (type $h@@120) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@66 Tclass.BoundedPivotsLib.__default $h@@120)  (or (= $o@@66 null) (U_2_bool (MapType1Select (MapType0Select $h@@120 $o@@66) alloc)))))
 :qid |unknown.0:0|
 :skolemid |6438|
 :pattern ( ($IsAlloc $o@@66 Tclass.BoundedPivotsLib.__default $h@@120))
)))
(assert  (=> true (forall ((|e#0@@20| T@U) ) (!  (=> (and (= (type |e#0@@20|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| |e#0@@20|) ($Is |e#0@@20| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |6439|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey |e#0@@20|))
))))
(assert (forall ((|e#0@@21| T@U) ) (!  (=> (and (= (type |e#0@@21|) DatatypeTypeType) ($Is |e#0@@21| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|BoundedPivotsLib.__default.ElementIsKey#requires| |e#0@@21|) true))
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |6440|
 :pattern ( (|BoundedPivotsLib.__default.ElementIsKey#requires| |e#0@@21|))
)))
(assert  (=> true (forall ((|e#0@@22| T@U) ) (!  (=> (and (= (type |e#0@@22|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| |e#0@@22|) ($Is |e#0@@22| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@22|) |KeyType.__default.MaxLen#canCall|) (= (BoundedPivotsLib.__default.ElementIsKey |e#0@@22|)  (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@22|) (INTERNAL_le_boogie (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |e#0@@22|)) KeyType.__default.MaxLen)))))
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |6441|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey |e#0@@22|))
))))
(assert  (=> true (forall ((|e#0@@23| T@U) ) (!  (=> (and (= (type |e#0@@23|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit |e#0@@23|)) ($Is |e#0@@23| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@23|))))) |KeyType.__default.MaxLen#canCall|) (= (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@23|))  (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@23|)) (INTERNAL_le_boogie (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |e#0@@23|)))) KeyType.__default.MaxLen)))))
 :qid |BoundedPivotsLibidfy.30:26|
 :weight 3
 :skolemid |6442|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@23|)))
))))
(assert  (=> true (forall ((|pt#0| T@U) ) (!  (=> (and (= (type |pt#0|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0|) ($Is |pt#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |6443|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys |pt#0|))
))))
(assert (forall ((|pt#0@@0| T@U) ) (!  (=> (and (= (type |pt#0@@0|) (SeqType BoxType)) ($Is |pt#0@@0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ElementsAreKeys#requires| |pt#0@@0|) true))
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |6444|
 :pattern ( (|BoundedPivotsLib.__default.ElementsAreKeys#requires| |pt#0@@0|))
)))
(assert  (=> true (forall ((|pt#0@@1| T@U) ) (!  (=> (and (= (type |pt#0@@1|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0@@1|) ($Is |pt#0@@1| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@138| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0@@138|) (INTERNAL_lt_boogie |i#0@@138| (|Seq#Length| |pt#0@@1|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@138|)))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@138|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |6446|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@138|)))
))) (= (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@1|)  (and true (forall ((|i#0@@139| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0@@139|) (INTERNAL_lt_boogie |i#0@@139| (|Seq#Length| |pt#0@@1|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@139|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@139|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |6445|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@139|)))
))))))
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |6447|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@1|))
))))
(assert  (=> true (forall ((|pt#0@@2| T@U) ) (!  (=> (and (= (type |pt#0@@2|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (Lit |pt#0@@2|)) ($Is |pt#0@@2| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@50| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#1@@50|) (INTERNAL_lt_boogie |i#1@@50| (|Seq#Length| (Lit |pt#0@@2|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@50|)))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@50|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |6449|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@2| |i#1@@50|)))
))) (= (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@2|))  (and true (forall ((|i#1@@51| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#1@@51|) (INTERNAL_lt_boogie |i#1@@51| (|Seq#Length| (Lit |pt#0@@2|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@51|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@51|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |6448|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@2| |i#1@@51|)))
))))))
 :qid |BoundedPivotsLibidfy.37:29|
 :weight 3
 :skolemid |6450|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@2|)))
))))
(assert (forall ((arg0@@641 T@U) ) (! (= (type (BoundedPivotsLib.__default.KeyToElement arg0@@641)) DatatypeTypeType)
 :qid |funType:BoundedPivotsLib.__default.KeyToElement|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement arg0@@641))
)))
(assert  (=> true (forall ((|key#0@@184| T@U) ) (!  (=> (and (= (type |key#0@@184|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@184|) ($Is |key#0@@184| Tclass.KeyType.Key))) ($Is (BoundedPivotsLib.__default.KeyToElement |key#0@@184|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |6451|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement |key#0@@184|))
))))
(assert (forall ((|key#0@@185| T@U) ) (!  (=> (and (= (type |key#0@@185|) (SeqType BoxType)) ($Is |key#0@@185| Tclass.KeyType.Key)) (= (|BoundedPivotsLib.__default.KeyToElement#requires| |key#0@@185|) true))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |6452|
 :pattern ( (|BoundedPivotsLib.__default.KeyToElement#requires| |key#0@@185|))
)))
(assert  (=> true (forall ((|key#0@@186| T@U) ) (!  (=> (and (= (type |key#0@@186|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@186|) ($Is |key#0@@186| Tclass.KeyType.Key))) (= (BoundedPivotsLib.__default.KeyToElement |key#0@@186|) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@186|)))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |6453|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement |key#0@@186|))
))))
(assert  (=> true (forall ((|key#0@@187| T@U) ) (!  (=> (and (= (type |key#0@@187|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@187|)) ($Is |key#0@@187| Tclass.KeyType.Key))) (= (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@187|)) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@187|)))))
 :qid |BoundedPivotsLibidfy.42:25|
 :weight 3
 :skolemid |6454|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@187|)))
))))
(assert (forall ((arg0@@642 T@U) ) (! (= (type (BoundedPivotsLib.__default.KeysToElements arg0@@642)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.KeysToElements|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements arg0@@642))
)))
(assert  (=> true (forall ((|keys#0@@4| T@U) ) (!  (=> (and (= (type |keys#0@@4|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| |keys#0@@4|) ($Is |keys#0@@4| (TSeq Tclass.KeyType.Key)))) (and (= (|Seq#Length| |keys#0@@4|) (|Seq#Length| (BoundedPivotsLib.__default.KeysToElements |keys#0@@4|))) ($Is (BoundedPivotsLib.__default.KeysToElements |keys#0@@4|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.47:27|
 :skolemid |6455|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements |keys#0@@4|))
))))
(assert (forall (($Heap@@101 T@U) (|keys#0@@5| T@U) ) (!  (=> (and (and (= (type $Heap@@101) (MapType0Type refType MapType1Type)) (= (type |keys#0@@5|) (SeqType BoxType))) (and ($IsGoodHeap $Heap@@101) ($Is |keys#0@@5| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.KeysToElements#requires| |keys#0@@5|) true))
 :qid |BoundedPivotsLibidfy.47:12|
 :skolemid |6456|
 :pattern ( (|BoundedPivotsLib.__default.KeysToElements#requires| |keys#0@@5|) ($IsGoodHeap $Heap@@101))
)))
(assert  (=> true (forall (($Heap@@102 T@U) (|keys#0@@6| T@U) ) (!  (=> (and (and (= (type $Heap@@102) (MapType0Type refType MapType1Type)) (= (type |keys#0@@6|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| |keys#0@@6|) (and ($IsGoodHeap $Heap@@102) ($Is |keys#0@@6| (TSeq Tclass.KeyType.Key))))) (= (BoundedPivotsLib.__default.KeysToElements |keys#0@@6|) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@102 (|Seq#Length| |keys#0@@6|) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#327| |keys#0@@6|) (|lambda#32| TInt 0 (|Seq#Length| |keys#0@@6|)) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))
 :qid |BoundedPivotsLibidfy.47:12|
 :skolemid |6457|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements |keys#0@@6|) ($IsGoodHeap $Heap@@102))
))))
(assert  (=> true (forall (($Heap@@103 T@U) (|keys#0@@7| T@U) ) (!  (=> (and (and (= (type $Heap@@103) (MapType0Type refType MapType1Type)) (= (type |keys#0@@7|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| (Lit |keys#0@@7|)) (and ($IsGoodHeap $Heap@@103) ($Is |keys#0@@7| (TSeq Tclass.KeyType.Key))))) (= (BoundedPivotsLib.__default.KeysToElements (Lit |keys#0@@7|)) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@103 (|Seq#Length| (Lit |keys#0@@7|)) (Lit (AtLayer (|lambda#35| (Handle1 (|lambda#327| (Lit |keys#0@@7|)) (|lambda#32| TInt 0 (|Seq#Length| (Lit |keys#0@@7|))) (|lambda#34| (SetRef_to_SetBox (|lambda#33| false))))) ($LS $LZ))))))
 :qid |BoundedPivotsLibidfy.47:12|
 :weight 3
 :skolemid |6458|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements (Lit |keys#0@@7|)) ($IsGoodHeap $Heap@@103))
))))
(assert  (=> true (forall ((|pt#0@@3| T@U) ) (!  (=> (and (= (type |pt#0@@3|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@3|) ($Is |pt#0@@3| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |6459|
 :pattern ( (BoundedPivotsLib.__default.WFPivots |pt#0@@3|))
))))
(assert (forall ((|pt#0@@4| T@U) ) (!  (=> (and (= (type |pt#0@@4|) (SeqType BoxType)) ($Is |pt#0@@4| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.WFPivots#requires| |pt#0@@4|) true))
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |6460|
 :pattern ( (|BoundedPivotsLib.__default.WFPivots#requires| |pt#0@@4|))
)))
(assert  (=> true (forall ((|pt#0@@5| T@U) ) (!  (=> (and (= (type |pt#0@@5|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@5|) ($Is |pt#0@@5| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |pt#0@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted |pt#0@@5|) (and (forall ((|i#0@@140| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@140|) (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@5|))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6462|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@140|)))
)) (=> (forall ((|i#0@@141| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@141|) (INTERNAL_lt_boogie |i#0@@141| (BoundedPivotsLib.__default.NumBuckets |pt#0@@5|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@141|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6463|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@141|)))
)) (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0@@5|))))) (= (BoundedPivotsLib.__default.WFPivots |pt#0@@5|)  (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted |pt#0@@5|) (forall ((|i#0@@142| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@142|) (INTERNAL_lt_boogie |i#0@@142| (BoundedPivotsLib.__default.NumBuckets |pt#0@@5|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@142|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6461|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@142|)))
))) (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@5|)) (INTERNAL_ge_boogie (|Seq#Length| |pt#0@@5|) 2)))))
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |6464|
 :pattern ( (BoundedPivotsLib.__default.WFPivots |pt#0@@5|))
))))
(assert  (=> true (forall ((|pt#0@@6| T@U) ) (!  (=> (and (= (type |pt#0@@6|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit |pt#0@@6|)) ($Is |pt#0@@6| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |pt#0@@6|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |pt#0@@6|)) (and (forall ((|i#1@@52| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@52|) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit |pt#0@@6|)))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6466|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@52|)))
)) (=> (forall ((|i#1@@53| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@53|) (INTERNAL_lt_boogie |i#1@@53| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@6|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@6|) |i#1@@53|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6467|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@53|)))
)) (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (Lit |pt#0@@6|)))))) (= (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@6|))  (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |pt#0@@6|)) (forall ((|i#1@@54| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@54|) (INTERNAL_lt_boogie |i#1@@54| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@6|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@6|) |i#1@@54|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |6465|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@54|)))
))) (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@6|))) (INTERNAL_ge_boogie (|Seq#Length| (Lit |pt#0@@6|)) 2)))))
 :qid |BoundedPivotsLibidfy.53:22|
 :weight 3
 :skolemid |6468|
 :pattern ( (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@6|)))
))))
(assert  (=> true (forall ((|pt#0@@7| T@U) ) (!  (=> (and (= (type |pt#0@@7|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| |pt#0@@7|) ($Is |pt#0@@7| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |6469|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@7|))
))))
(assert (forall ((|pt#0@@8| T@U) ) (!  (=> (and (= (type |pt#0@@8|) (SeqType BoxType)) ($Is |pt#0@@8| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ContainsAllKeys#requires| |pt#0@@8|) true))
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |6470|
 :pattern ( (|BoundedPivotsLib.__default.ContainsAllKeys#requires| |pt#0@@8|))
)))
(assert  (=> true (forall ((|pt#0@@9| T@U) ) (!  (=> (and (= (type |pt#0@@9|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| |pt#0@@9|) ($Is |pt#0@@9| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@9|) (=> (BoundedPivotsLib.__default.WFPivots |pt#0@@9|) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@9|) 1)))))))) (= (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@9|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@9|) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType))))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@9|) 1))) |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |6471|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@9|))
))))
(assert  (=> true (forall ((|pt#0@@10| T@U) ) (!  (=> (and (= (type |pt#0@@10|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| (Lit |pt#0@@10|)) ($Is |pt#0@@10| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit |pt#0@@10|)) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@10|))))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@10|)) 1)))))))) (= (BoundedPivotsLib.__default.ContainsAllKeys (Lit |pt#0@@10|))  (and (and (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@10|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType))))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@10|)) 1))) |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
 :qid |BoundedPivotsLibidfy.61:29|
 :weight 3
 :skolemid |6472|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys (Lit |pt#0@@10|)))
))))
(assert  (=> true (forall ((|pt#0@@11| T@U) (|left#0@@11| T@U) (|right#0@@11| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@11|) (SeqType BoxType)) (= (type |left#0@@11|) DatatypeTypeType)) (= (type |right#0@@11|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| |pt#0@@11| |left#0@@11| |right#0@@11|) (and (and (and ($Is |pt#0@@11| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@11|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@11|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@11| |right#0@@11|))))) true)
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |6473|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange |pt#0@@11| |left#0@@11| |right#0@@11|))
))))
(assert (forall ((|pt#0@@12| T@U) (|left#0@@12| T@U) (|right#0@@12| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@12|) (SeqType BoxType)) (= (type |left#0@@12|) DatatypeTypeType)) (= (type |right#0@@12|) DatatypeTypeType)) (and (and ($Is |pt#0@@12| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ContainsRange#requires| |pt#0@@12| |left#0@@12| |right#0@@12|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@12|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@12|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@12| |right#0@@12|))))
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |6474|
 :pattern ( (|BoundedPivotsLib.__default.ContainsRange#requires| |pt#0@@12| |left#0@@12| |right#0@@12|))
)))
(assert  (=> true (forall ((|pt#0@@13| T@U) (|left#0@@13| T@U) (|right#0@@13| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@13|) (SeqType BoxType)) (= (type |left#0@@13|) DatatypeTypeType)) (= (type |right#0@@13|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| |pt#0@@13| |left#0@@13| |right#0@@13|) (and (and (and ($Is |pt#0@@13| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@13|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@13|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@13| |right#0@@13|))))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |right#0@@13| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@13|) 1)))))) (= (BoundedPivotsLib.__default.ContainsRange |pt#0@@13| |left#0@@13| |right#0@@13|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (Upperbounded__Lexicographic__Byte__Order.__default.lte |right#0@@13| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@13|) 1))))))))
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |6475|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange |pt#0@@13| |left#0@@13| |right#0@@13|))
))))
(assert  (=> true (forall ((|pt#0@@14| T@U) (|left#0@@14| T@U) (|right#0@@14| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@14|) (SeqType BoxType)) (= (type |left#0@@14|) DatatypeTypeType)) (= (type |right#0@@14|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|)) (and (and (and ($Is |pt#0@@14| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@14| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@14| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@14|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ElementIsKey (Lit |left#0@@14|)))))) (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |left#0@@14|) (Lit |right#0@@14|))))))))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |right#0@@14|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@14|)) 1)))))) (= (BoundedPivotsLib.__default.ContainsRange (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |right#0@@14|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@14|)) 1))))))))
 :qid |BoundedPivotsLibidfy.88:27|
 :weight 3
 :skolemid |6476|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|)))
))))
(assert  (=> true (forall ((|pt#0@@15| T@U) (|key#0@@188| T@U) ) (!  (=> (and (and (= (type |pt#0@@15|) (SeqType BoxType)) (= (type |key#0@@188|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@15| |key#0@@188|) (and (and ($Is |pt#0@@15| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@188| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@15|)))) true)
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |6477|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@15| |key#0@@188|))
))))
(assert (forall ((|pt#0@@16| T@U) (|key#0@@189| T@U) ) (!  (=> (and (and (= (type |pt#0@@16|) (SeqType BoxType)) (= (type |key#0@@189|) (SeqType BoxType))) (and ($Is |pt#0@@16| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@189| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.BoundedKey#requires| |pt#0@@16| |key#0@@189|) (BoundedPivotsLib.__default.WFPivots |pt#0@@16|)))
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |6478|
 :pattern ( (|BoundedPivotsLib.__default.BoundedKey#requires| |pt#0@@16| |key#0@@189|))
)))
(assert  (=> true (forall ((|pt#0@@17| T@U) (|key#0@@190| T@U) ) (!  (=> (and (and (= (type |pt#0@@17|) (SeqType BoxType)) (= (type |key#0@@190|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@17| |key#0@@190|) (and (and ($Is |pt#0@@17| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@190| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@17|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@190|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@190|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@190|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@190|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@190|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@17|) 1))))))) (= (BoundedPivotsLib.__default.BoundedKey |pt#0@@17| |key#0@@190|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@190|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@190|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@17|) 1))))))))
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |6479|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@17| |key#0@@190|))
))))
(assert  (=> true (forall ((|pt#0@@18| T@U) (|key#0@@191| T@U) ) (!  (=> (and (and (= (type |pt#0@@18|) (SeqType BoxType)) (= (type |key#0@@191|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@18|) (Lit |key#0@@191|)) (and (and ($Is |pt#0@@18| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@191| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@18|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@191|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@191|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@191|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@191|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@191|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@18|)) 1))))))) (= (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@18|) (Lit |key#0@@191|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@191|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@191|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@18|)) 1))))))))
 :qid |BoundedPivotsLibidfy.124:24|
 :weight 3
 :skolemid |6480|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@18|) (Lit |key#0@@191|)))
))))
(assert  (=> true (forall ((|pt#0@@19| T@U) (|keys#0@@8| T@U) ) (!  (=> (and (and (= (type |pt#0@@19|) (SeqType BoxType)) (= (type |keys#0@@8|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| |pt#0@@19| |keys#0@@8|) (and (and ($Is |pt#0@@19| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@8| (TSeq Tclass.KeyType.Key))) (BoundedPivotsLib.__default.WFPivots |pt#0@@19|)))) true)
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |6481|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@19| |keys#0@@8|))
))))
(assert (forall ((|pt#0@@20| T@U) (|keys#0@@9| T@U) ) (!  (=> (and (and (= (type |pt#0@@20|) (SeqType BoxType)) (= (type |keys#0@@9|) (SeqType BoxType))) (and ($Is |pt#0@@20| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@9| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.BoundedKeySeq#requires| |pt#0@@20| |keys#0@@9|) (BoundedPivotsLib.__default.WFPivots |pt#0@@20|)))
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |6482|
 :pattern ( (|BoundedPivotsLib.__default.BoundedKeySeq#requires| |pt#0@@20| |keys#0@@9|))
)))
(assert  (=> true (forall ((|pt#0@@21| T@U) (|keys#0@@10| T@U) ) (!  (=> (and (and (= (type |pt#0@@21|) (SeqType BoxType)) (= (type |keys#0@@10|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| |pt#0@@21| |keys#0@@10|) (and (and ($Is |pt#0@@21| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@10| (TSeq Tclass.KeyType.Key))) (BoundedPivotsLib.__default.WFPivots |pt#0@@21|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@143| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@143|) (INTERNAL_lt_boogie |i#0@@143| (|Seq#Length| |keys#0@@10|))) (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@21| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#0@@143|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |6484|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#0@@143|)))
))) (= (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@21| |keys#0@@10|)  (and true (forall ((|i#0@@144| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@144|) (INTERNAL_lt_boogie |i#0@@144| (|Seq#Length| |keys#0@@10|))) (BoundedPivotsLib.__default.BoundedKey |pt#0@@21| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#0@@144|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |6483|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#0@@144|)))
))))))
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |6485|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@21| |keys#0@@10|))
))))
(assert  (=> true (forall ((|pt#0@@22| T@U) (|keys#0@@11| T@U) ) (!  (=> (and (and (= (type |pt#0@@22|) (SeqType BoxType)) (= (type |keys#0@@11|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| (Lit |pt#0@@22|) (Lit |keys#0@@11|)) (and (and ($Is |pt#0@@22| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@11| (TSeq Tclass.KeyType.Key))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@22|)))))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@55| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@55|) (INTERNAL_lt_boogie |i#1@@55| (|Seq#Length| (Lit |keys#0@@11|)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@22|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@11|) |i#1@@55|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |6487|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@11| |i#1@@55|)))
))) (= (BoundedPivotsLib.__default.BoundedKeySeq (Lit |pt#0@@22|) (Lit |keys#0@@11|))  (and true (forall ((|i#1@@56| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@56|) (INTERNAL_lt_boogie |i#1@@56| (|Seq#Length| (Lit |keys#0@@11|)))) (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@22|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@11|) |i#1@@56|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |6486|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@11| |i#1@@56|)))
))))))
 :qid |BoundedPivotsLibidfy.131:27|
 :weight 3
 :skolemid |6488|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq (Lit |pt#0@@22|) (Lit |keys#0@@11|)))
))))
(assert  (=> true (forall ((|pt#0@@23| T@U) (|keys#0@@12| T@U) ) (!  (=> (and (and (= (type |pt#0@@23|) (SeqType BoxType)) (= (type |keys#0@@12|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| |pt#0@@23| |keys#0@@12|) (and (and ($Is |pt#0@@23| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@12| (TSeq Tclass.KeyType.Key))) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@23|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@12|))))) true)
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |6489|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@23| |keys#0@@12|))
))))
(assert (forall ((|pt#0@@24| T@U) (|keys#0@@13| T@U) ) (!  (=> (and (and (= (type |pt#0@@24|) (SeqType BoxType)) (= (type |keys#0@@13|) (SeqType BoxType))) (and ($Is |pt#0@@24| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@13| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| |pt#0@@24| |keys#0@@13|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@24|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@13|))))
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |6490|
 :pattern ( (|BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| |pt#0@@24| |keys#0@@13|))
)))
(assert  (=> true (forall ((|pt#0@@25| T@U) (|keys#0@@14| T@U) ) (!  (=> (and (and (= (type |pt#0@@25|) (SeqType BoxType)) (= (type |keys#0@@14|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| |pt#0@@25| |keys#0@@14|) (and (and ($Is |pt#0@@25| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@14| (TSeq Tclass.KeyType.Key))) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@25|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@14|))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (INTERNAL_gt_boogie (|Seq#Length| |keys#0@@14|) 0) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@14| (LitInt 0)))) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@14| (LitInt 0)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@14| (INTERNAL_sub_boogie (|Seq#Length| |keys#0@@14|) 1)))))))) (= (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@25| |keys#0@@14|)  (and true (=> (INTERNAL_gt_boogie (|Seq#Length| |keys#0@@14|) 0) (and (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@14| (LitInt 0)))) (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@14| (INTERNAL_sub_boogie (|Seq#Length| |keys#0@@14|) 1))))))))))
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |6491|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@25| |keys#0@@14|))
))))
(assert  (=> true (forall ((|pt#0@@26| T@U) (|keys#0@@15| T@U) ) (!  (=> (and (and (= (type |pt#0@@26|) (SeqType BoxType)) (= (type |keys#0@@15|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| (Lit |pt#0@@26|) (Lit |keys#0@@15|)) (and (and ($Is |pt#0@@26| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@15| (TSeq Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@26|))))) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |keys#0@@15|)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (INTERNAL_gt_boogie (|Seq#Length| (Lit |keys#0@@15|)) 0) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@15|) (LitInt 0)))) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@15|) (LitInt 0)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@15|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |keys#0@@15|)) 1)))))))) (= (BoundedPivotsLib.__default.BoundedSortedKeySeq (Lit |pt#0@@26|) (Lit |keys#0@@15|))  (and true (=> (INTERNAL_gt_boogie (|Seq#Length| (Lit |keys#0@@15|)) 0) (and (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@15|) (LitInt 0)))) (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@15|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |keys#0@@15|)) 1))))))))))
 :qid |BoundedPivotsLibidfy.137:33|
 :weight 3
 :skolemid |6492|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq (Lit |pt#0@@26|) (Lit |keys#0@@15|)))
))))
(assert  (=> true (forall ((|pt#0@@27| T@U) (|key#0@@192| T@U) ) (!  (=> (and (and (= (type |pt#0@@27|) (SeqType BoxType)) (= (type |key#0@@192|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| |pt#0@@27| |key#0@@192|) (and (and ($Is |pt#0@@27| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@192| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@27|)))) true)
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |6493|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@27| |key#0@@192|))
))))
(assert (forall ((|pt#0@@28| T@U) (|key#0@@193| T@U) ) (!  (=> (and (and (= (type |pt#0@@28|) (SeqType BoxType)) (= (type |key#0@@193|) (SeqType BoxType))) (and ($Is |pt#0@@28| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@193| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| |pt#0@@28| |key#0@@193|) (BoundedPivotsLib.__default.WFPivots |pt#0@@28|)))
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |6494|
 :pattern ( (|BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| |pt#0@@28| |key#0@@193|))
)))
(assert  (=> true (forall ((|pt#0@@29| T@U) (|key#0@@194| T@U) ) (!  (=> (and (and (= (type |pt#0@@29|) (SeqType BoxType)) (= (type |key#0@@194|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| |pt#0@@29| |key#0@@194|) (and (and ($Is |pt#0@@29| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@194| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@29|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@194|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@194|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@194|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@194|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@194|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@29|) 1))))))) (= (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@29| |key#0@@194|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@194|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement |key#0@@194|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@29|) 1))))))))
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |6495|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@29| |key#0@@194|))
))))
(assert  (=> true (forall ((|pt#0@@30| T@U) (|key#0@@195| T@U) ) (!  (=> (and (and (= (type |pt#0@@30|) (SeqType BoxType)) (= (type |key#0@@195|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| (Lit |pt#0@@30|) (Lit |key#0@@195|)) (and (and ($Is |pt#0@@30| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@195| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@30|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@195|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@195|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@195|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@195|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@195|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@30|)) 1))))))) (= (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@30|) (Lit |key#0@@195|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@195|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@195|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@30|)) 1))))))))
 :qid |BoundedPivotsLibidfy.168:32|
 :weight 3
 :skolemid |6496|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@30|) (Lit |key#0@@195|)))
))))
(assert  (=> true (forall ((|pt#0@@31| T@U) ) (!  (=> (and (= (type |pt#0@@31|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@31|) ($Is |pt#0@@31| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |6497|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets |pt#0@@31|))
))))
(assert (forall ((|pt#0@@32| T@U) ) (!  (=> (and (= (type |pt#0@@32|) (SeqType BoxType)) ($Is |pt#0@@32| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.NumBuckets#requires| |pt#0@@32|) true))
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |6498|
 :pattern ( (|BoundedPivotsLib.__default.NumBuckets#requires| |pt#0@@32|))
)))
(assert  (=> true (forall ((|pt#0@@33| T@U) ) (!  (=> (and (= (type |pt#0@@33|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@33|) ($Is |pt#0@@33| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (BoundedPivotsLib.__default.NumBuckets |pt#0@@33|) (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@33|) 1)))
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |6499|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets |pt#0@@33|))
))))
(assert  (=> true (forall ((|pt#0@@34| T@U) ) (!  (=> (and (= (type |pt#0@@34|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit |pt#0@@34|)) ($Is |pt#0@@34| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@34|)) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@34|)) 1)))
 :qid |BoundedPivotsLibidfy.199:23|
 :weight 3
 :skolemid |6500|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@34|)))
))))
(assert  (=> true (forall ((|e#0@@24| T@U) ) (!  (=> (and (= (type |e#0@@24|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| |e#0@@24|) (and ($Is |e#0@@24| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@24|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@24|))))) (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.PivotSize |e#0@@24|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.PivotSize |e#0@@24|) 18446744073709551616)))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |6501|
 :pattern ( (BoundedPivotsLib.__default.PivotSize |e#0@@24|))
))))
(assert (forall ((|e#0@@25| T@U) ) (!  (=> (and (= (type |e#0@@25|) DatatypeTypeType) ($Is |e#0@@25| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|BoundedPivotsLib.__default.PivotSize#requires| |e#0@@25|)  (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@25|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@25|))))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |6502|
 :pattern ( (|BoundedPivotsLib.__default.PivotSize#requires| |e#0@@25|))
)))
(assert  (=> true (forall ((|e#0@@26| T@U) ) (!  (=> (and (= (type |e#0@@26|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| |e#0@@26|) (and ($Is |e#0@@26| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@26|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@26|))))) (= (BoundedPivotsLib.__default.PivotSize |e#0@@26|) (ite (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@26|) (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |e#0@@26|)) 0)))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |6503|
 :pattern ( (BoundedPivotsLib.__default.PivotSize |e#0@@26|))
))))
(assert  (=> true (forall ((|e#0@@27| T@U) ) (!  (=> (and (= (type |e#0@@27|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| (Lit |e#0@@27|)) (and ($Is |e#0@@27| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (Lit (bool_2_U  (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@27|)) (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@27|))))))))) (= (BoundedPivotsLib.__default.PivotSize (Lit |e#0@@27|)) (ite (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@27|)) (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |e#0@@27|)))) 0)))
 :qid |BoundedPivotsLibidfy.204:29|
 :weight 3
 :skolemid |6504|
 :pattern ( (BoundedPivotsLib.__default.PivotSize (Lit |e#0@@27|)))
))))
(assert  (=> true (forall ((|left#0@@15| T@U) (|right#0@@15| T@U) (|key#0@@196| T@U) ) (!  (=> (and (and (and (= (type |left#0@@15|) DatatypeTypeType) (= (type |right#0@@15|) DatatypeTypeType)) (= (type |key#0@@196|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| |left#0@@15| |right#0@@15| |key#0@@196|) (and (and (and ($Is |left#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@196| Tclass.KeyType.Key)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@15| |right#0@@15|)))) true)
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |6505|
 :pattern ( (BoundedPivotsLib.__default.InBetween |left#0@@15| |right#0@@15| |key#0@@196|))
))))
(assert (forall ((|left#0@@16| T@U) (|right#0@@16| T@U) (|key#0@@197| T@U) ) (!  (=> (and (and (and (= (type |left#0@@16|) DatatypeTypeType) (= (type |right#0@@16|) DatatypeTypeType)) (= (type |key#0@@197|) (SeqType BoxType))) (and (and ($Is |left#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@197| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.InBetween#requires| |left#0@@16| |right#0@@16| |key#0@@197|) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@16| |right#0@@16|)))
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |6506|
 :pattern ( (|BoundedPivotsLib.__default.InBetween#requires| |left#0@@16| |right#0@@16| |key#0@@197|))
)))
(assert  (=> true (forall ((|left#0@@17| T@U) (|right#0@@17| T@U) (|key#0@@198| T@U) ) (!  (=> (and (and (and (= (type |left#0@@17|) DatatypeTypeType) (= (type |right#0@@17|) DatatypeTypeType)) (= (type |key#0@@198|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| |left#0@@17| |right#0@@17| |key#0@@198|) (and (and (and ($Is |left#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@198| Tclass.KeyType.Key)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@17| |right#0@@17|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@198|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@198|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@198|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@198|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@198|) |right#0@@17|)))) (= (BoundedPivotsLib.__default.InBetween |left#0@@17| |right#0@@17| |key#0@@198|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@198|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@198|) |right#0@@17|)))))
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |6507|
 :pattern ( (BoundedPivotsLib.__default.InBetween |left#0@@17| |right#0@@17| |key#0@@198|))
))))
(assert  (=> true (forall ((|left#0@@18| T@U) (|right#0@@18| T@U) (|key#0@@199| T@U) ) (!  (=> (and (and (and (= (type |left#0@@18|) DatatypeTypeType) (= (type |right#0@@18|) DatatypeTypeType)) (= (type |key#0@@199|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@199|)) (and (and (and ($Is |left#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@199| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |left#0@@18|) (Lit |right#0@@18|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@199|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@199|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@199|))))))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@199|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@199|))) (Lit |right#0@@18|))))) (= (BoundedPivotsLib.__default.InBetween (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@199|)) (U_2_bool (Lit (bool_2_U  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@199|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@199|))) (Lit |right#0@@18|)))))))))
 :qid |BoundedPivotsLibidfy.212:23|
 :weight 3
 :skolemid |6508|
 :pattern ( (BoundedPivotsLib.__default.InBetween (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@199|)))
))))
(assert  (=> true (forall ((|pt#0@@35| T@U) (|key#0@@200| T@U) ) (!  (=> (and (and (= (type |pt#0@@35|) (SeqType BoxType)) (= (type |key#0@@200|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@35| |key#0@@200|) (and (and ($Is |pt#0@@35| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@200| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@35|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@35| |key#0@@200|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|) (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@35|) 1))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|))) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|) 1))))) (BoundedPivotsLib.__default.InBetween ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|))) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|) 1))) |key#0@@200|)))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |6509|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@200|))
))))
(assert (forall ((|pt#0@@36| T@U) (|key#0@@201| T@U) ) (!  (=> (and (and (= (type |pt#0@@36|) (SeqType BoxType)) (= (type |key#0@@201|) (SeqType BoxType))) (and ($Is |pt#0@@36| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@201| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.Route#requires| |pt#0@@36| |key#0@@201|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@36|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@36| |key#0@@201|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |6510|
 :pattern ( (|BoundedPivotsLib.__default.Route#requires| |pt#0@@36| |key#0@@201|))
)))
(assert  (=> true (forall ((|pt#0@@37| T@U) (|key#0@@202| T@U) ) (!  (=> (and (and (= (type |pt#0@@37|) (SeqType BoxType)) (= (type |key#0@@202|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@37| |key#0@@202|) (and (and ($Is |pt#0@@37| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@202| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@37|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@37| |key#0@@202|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@202|) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |pt#0@@37| (BoundedPivotsLib.__default.KeyToElement |key#0@@202|))) (= (BoundedPivotsLib.__default.Route |pt#0@@37| |key#0@@202|) (let ((|i#0@@145| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |pt#0@@37| (BoundedPivotsLib.__default.KeyToElement |key#0@@202|))))
|i#0@@145|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |6511|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@37| |key#0@@202|))
))))
(assert  (=> true (forall ((|pt#0@@38| T@U) (|key#0@@203| T@U) ) (!  (=> (and (and (= (type |pt#0@@38|) (SeqType BoxType)) (= (type |key#0@@203|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@38|) (Lit |key#0@@203|)) (and (and ($Is |pt#0@@38| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@203| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@38|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@38|) (Lit |key#0@@203|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@203|)) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |pt#0@@38|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@203|))))) (= (BoundedPivotsLib.__default.Route (Lit |pt#0@@38|) (Lit |key#0@@203|)) (let ((|i#1@@57| (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |pt#0@@38|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@203|)))))))
|i#1@@57|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :weight 3
 :skolemid |6512|
 :pattern ( (BoundedPivotsLib.__default.Route (Lit |pt#0@@38|) (Lit |key#0@@203|)))
))))
(assert (= (type BoundedPivotsLib.__default.InitPivotTable) (SeqType BoxType)))
(assert  (=> true (=> true (and (BoundedPivotsLib.__default.WFPivots BoundedPivotsLib.__default.InitPivotTable) ($Is BoundedPivotsLib.__default.InitPivotTable (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))))
(assert (= |BoundedPivotsLib.__default.InitPivotTable#requires| true))
(assert  (=> true (=> true (= BoundedPivotsLib.__default.InitPivotTable (let ((|pt#0@@39| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))))) ($Box (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))))))
|pt#0@@39|)))))
(assert  (=> true (=> true (= BoundedPivotsLib.__default.InitPivotTable (let ((|pt#1| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))))) ($Box (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))))))
|pt#1|)))))
(assert (forall ((arg0@@643 T@U) (arg1@@333 Int) ) (! (= (type (BoundedPivotsLib.__default.GetKey arg0@@643 arg1@@333)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.GetKey|
 :pattern ( (BoundedPivotsLib.__default.GetKey arg0@@643 arg1@@333))
)))
(assert  (=> true (forall ((|pt#0@@40| T@U) (|idx#0| Int) ) (!  (=> (and (= (type |pt#0@@40|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| |pt#0@@40| |idx#0|) (and ($Is |pt#0@@40| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@40|) (and (INTERNAL_le_boogie 0 |idx#0|) (INTERNAL_lt_boogie |idx#0| (|Seq#Length| |pt#0@@40|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@40| |idx#0|))))))) (and (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|)) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@40| |idx#0|))) ($Is (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|) Tclass.KeyType.Key)))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |6513|
 :pattern ( (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|))
))))
(assert (forall ((|pt#0@@41| T@U) (|idx#0@@0| Int) ) (!  (=> (and (= (type |pt#0@@41|) (SeqType BoxType)) ($Is |pt#0@@41| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.GetKey#requires| |pt#0@@41| |idx#0@@0|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@41|) (and (INTERNAL_le_boogie 0 |idx#0@@0|) (INTERNAL_lt_boogie |idx#0@@0| (|Seq#Length| |pt#0@@41|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@41| |idx#0@@0|))))))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |6514|
 :pattern ( (|BoundedPivotsLib.__default.GetKey#requires| |pt#0@@41| |idx#0@@0|))
)))
(assert  (=> true (forall ((|pt#0@@42| T@U) (|idx#0@@1| Int) ) (!  (=> (and (= (type |pt#0@@42|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| |pt#0@@42| |idx#0@@1|) (and ($Is |pt#0@@42| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@42|) (and (INTERNAL_le_boogie 0 |idx#0@@1|) (INTERNAL_lt_boogie |idx#0@@1| (|Seq#Length| |pt#0@@42|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@42| |idx#0@@1|))))))) (= (BoundedPivotsLib.__default.GetKey |pt#0@@42| |idx#0@@1|) (let ((|k#0@@80| (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@42| |idx#0@@1|)))))
|k#0@@80|)))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |6515|
 :pattern ( (BoundedPivotsLib.__default.GetKey |pt#0@@42| |idx#0@@1|))
))))
(assert  (=> true (forall ((|pt#0@@43| T@U) (|idx#0@@2| Int) ) (!  (=> (and (= (type |pt#0@@43|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| (Lit |pt#0@@43|) (LitInt |idx#0@@2|)) (and ($Is |pt#0@@43| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@43|))))) (and (INTERNAL_le_boogie 0 |idx#0@@2|) (INTERNAL_lt_boogie |idx#0@@2| (|Seq#Length| (Lit |pt#0@@43|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@43|) (LitInt |idx#0@@2|)))))))) (= (BoundedPivotsLib.__default.GetKey (Lit |pt#0@@43|) (LitInt |idx#0@@2|)) (let ((|k#1@@18| (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@43|) (LitInt |idx#0@@2|))))))
|k#1@@18|)))
 :qid |BoundedPivotsLibidfy.274:19|
 :weight 3
 :skolemid |6516|
 :pattern ( (BoundedPivotsLib.__default.GetKey (Lit |pt#0@@43|) (LitInt |idx#0@@2|)))
))))
(assert  (=> true (forall ((|pt#0@@44| T@U) (|idx#0@@3| Int) (|key#0@@204| T@U) ) (!  (=> (and (and (= (type |pt#0@@44|) (SeqType BoxType)) (= (type |key#0@@204|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| |pt#0@@44| |idx#0@@3| |key#0@@204|) (and (and ($Is |pt#0@@44| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@204| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@44|)))) true)
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |6517|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable |pt#0@@44| |idx#0@@3| |key#0@@204|))
))))
(assert (forall ((|pt#0@@45| T@U) (|idx#0@@4| Int) (|key#0@@205| T@U) ) (!  (=> (and (and (= (type |pt#0@@45|) (SeqType BoxType)) (= (type |key#0@@205|) (SeqType BoxType))) (and ($Is |pt#0@@45| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@205| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.PivotInsertable#requires| |pt#0@@45| |idx#0@@4| |key#0@@205|) (BoundedPivotsLib.__default.WFPivots |pt#0@@45|)))
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |6518|
 :pattern ( (|BoundedPivotsLib.__default.PivotInsertable#requires| |pt#0@@45| |idx#0@@4| |key#0@@205|))
)))
(assert  (=> true (forall ((|pt#0@@46| T@U) (|idx#0@@5| Int) (|key#0@@206| T@U) ) (!  (=> (and (and (= (type |pt#0@@46|) (SeqType BoxType)) (= (type |key#0@@206|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| |pt#0@@46| |idx#0@@5| |key#0@@206|) (and (and ($Is |pt#0@@46| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@206| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@46|)))) (and (=> (INTERNAL_le_boogie 0 |idx#0@@5|) (=> (INTERNAL_le_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (=> (= |idx#0@@5| (LitInt 0)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@206|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0)))))) (=> (=> (= |idx#0@@5| (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0))))) (and (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@206|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|)))) (=> (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|))) (and (=> (INTERNAL_gt_boogie |idx#0@@5| 0) (=> (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@206|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@206|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|)))))))) (=> (=> (and (INTERNAL_gt_boogie |idx#0@@5| 0) (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|))))) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@46| |key#0@@206|) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@46| |key#0@@206|) (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@46| |key#0@@206|))))))))))) (= (BoundedPivotsLib.__default.PivotInsertable |pt#0@@46| |idx#0@@5| |key#0@@206|)  (and (and (and (and (and (INTERNAL_le_boogie 0 |idx#0@@5|) (INTERNAL_le_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (=> (= |idx#0@@5| (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0)))))) (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|)))) (=> (and (INTERNAL_gt_boogie |idx#0@@5| 0) (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@206|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@206|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|)))))) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@46| |key#0@@206|) (= (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@46| |key#0@@206|) 1) |idx#0@@5|))))))
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |6519|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable |pt#0@@46| |idx#0@@5| |key#0@@206|))
))))
(assert  (=> true (forall ((|pt#0@@47| T@U) (|idx#0@@6| Int) (|key#0@@207| T@U) ) (!  (=> (and (and (= (type |pt#0@@47|) (SeqType BoxType)) (= (type |key#0@@207|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@207|)) (and (and ($Is |pt#0@@47| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@207| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@47|)))))))) (and (=> (INTERNAL_le_boogie 0 |idx#0@@6|) (=> (INTERNAL_le_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|))) (and (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@207|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0)))))) (=> (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0))))) (and (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@207|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|)))))) (=> (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_gt_boogie |idx#0@@6| 0)))) (=> (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@207|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@207|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|))))))))) (=> (=> (and (INTERNAL_gt_boogie |idx#0@@6| 0) (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|)))))) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@47|) (Lit |key#0@@207|)) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@47|) (Lit |key#0@@207|))))) (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@47|) (Lit |key#0@@207|)))))))))))) (= (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@207|))  (and (and (and (and (and (INTERNAL_le_boogie 0 |idx#0@@6|) (INTERNAL_le_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0)))))) (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|)))))) (=> (and (INTERNAL_gt_boogie |idx#0@@6| 0) (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@207|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|))))))) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@47|) (Lit |key#0@@207|)) (= (LitInt (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route (Lit |pt#0@@47|) (Lit |key#0@@207|)) 1)) (LitInt |idx#0@@6|)))))))
 :qid |BoundedPivotsLibidfy.330:29|
 :weight 3
 :skolemid |6520|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@207|)))
))))
(assert (forall ((arg0@@644 T@U) (arg1@@334 Int) (arg2@@170 T@U) ) (! (= (type (BoundedPivotsLib.__default.InsertPivot arg0@@644 arg1@@334 arg2@@170)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.InsertPivot|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot arg0@@644 arg1@@334 arg2@@170))
)))
(assert  (=> true (forall ((|pt#0@@48| T@U) (|idx#0@@7| Int) (|key#0@@208| T@U) ) (!  (=> (and (and (= (type |pt#0@@48|) (SeqType BoxType)) (= (type |key#0@@208|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| |pt#0@@48| |idx#0@@7| |key#0@@208|) (and (and ($Is |pt#0@@48| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@208| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@48|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@48| |idx#0@@7| |key#0@@208|))))) ($Is (BoundedPivotsLib.__default.InsertPivot |pt#0@@48| |idx#0@@7| |key#0@@208|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |6521|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot |pt#0@@48| |idx#0@@7| |key#0@@208|))
))))
(assert (forall ((|pt#0@@49| T@U) (|idx#0@@8| Int) (|key#0@@209| T@U) ) (!  (=> (and (and (= (type |pt#0@@49|) (SeqType BoxType)) (= (type |key#0@@209|) (SeqType BoxType))) (and ($Is |pt#0@@49| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@209| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.InsertPivot#requires| |pt#0@@49| |idx#0@@8| |key#0@@209|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@49|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@49| |idx#0@@8| |key#0@@209|))))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |6522|
 :pattern ( (|BoundedPivotsLib.__default.InsertPivot#requires| |pt#0@@49| |idx#0@@8| |key#0@@209|))
)))
(assert (= (type StartFuel_Sequences._default.insert) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@50| T@U) (|idx#0@@9| Int) (|key#0@@210| T@U) ) (!  (=> (and (and (= (type |pt#0@@50|) (SeqType BoxType)) (= (type |key#0@@210|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| |pt#0@@50| |idx#0@@9| |key#0@@210|) (and (and ($Is |pt#0@@50| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@210| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@50|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@50| |idx#0@@9| |key#0@@210|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@210|) (|Sequences.__default.insert#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pt#0@@50| ($Box (BoundedPivotsLib.__default.KeyToElement |key#0@@210|)) |idx#0@@9|)) (= (BoundedPivotsLib.__default.InsertPivot |pt#0@@50| |idx#0@@9| |key#0@@210|) (Sequences.__default.insert Tclass.Upperbounded__Lexicographic__Byte__Order.Element StartFuel_Sequences._default.insert |pt#0@@50| ($Box (BoundedPivotsLib.__default.KeyToElement |key#0@@210|)) |idx#0@@9|))))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |6523|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot |pt#0@@50| |idx#0@@9| |key#0@@210|))
))))
(assert  (=> true (forall ((|pt#0@@51| T@U) (|idx#0@@10| Int) (|key#0@@211| T@U) ) (!  (=> (and (and (= (type |pt#0@@51|) (SeqType BoxType)) (= (type |key#0@@211|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@211|)) (and (and ($Is |pt#0@@51| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@211| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@51|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@211|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@211|)) (|Sequences.__default.insert#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pt#0@@51|) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@211|)))) (LitInt |idx#0@@10|))) (= (BoundedPivotsLib.__default.InsertPivot (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@211|)) (Sequences.__default.insert Tclass.Upperbounded__Lexicographic__Byte__Order.Element StartFuel_Sequences._default.insert (Lit |pt#0@@51|) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@211|)))) (LitInt |idx#0@@10|)))))
 :qid |BoundedPivotsLibidfy.380:24|
 :weight 3
 :skolemid |6524|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@211|)))
))))
(assert (forall (($ly@@689 T@U) (|pt#0@@52| T@U) (|pivot#0@@11| T@U) ) (!  (=> (and (and (= (type $ly@@689) LayerTypeType) (= (type |pt#0@@52|) (SeqType BoxType))) (= (type |pivot#0@@11|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@689) |pt#0@@52| |pivot#0@@11|) (BoundedPivotsLib.__default.CutoffForLeft $ly@@689 |pt#0@@52| |pivot#0@@11|)))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |6525|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@689) |pt#0@@52| |pivot#0@@11|))
)))
(assert (forall (($ly@@690 T@U) (|pt#0@@53| T@U) (|pivot#0@@12| T@U) ) (!  (=> (and (and (= (type $ly@@690) LayerTypeType) (= (type |pt#0@@53|) (SeqType BoxType))) (= (type |pivot#0@@12|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForLeft $ly@@690 |pt#0@@53| |pivot#0@@12|) (BoundedPivotsLib.__default.CutoffForLeft $LZ |pt#0@@53| |pivot#0@@12|)))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |6526|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft (AsFuelBottom $ly@@690) |pt#0@@53| |pivot#0@@12|))
)))
(assert  (=> true (forall (($ly@@691 T@U) (|pt#0@@54| T@U) (|pivot#0@@13| T@U) ) (!  (=> (and (and (and (= (type $ly@@691) LayerTypeType) (= (type |pt#0@@54|) (SeqType BoxType))) (= (type |pivot#0@@13|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@54| |pivot#0@@13|) (and (and ($Is |pt#0@@54| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@13| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@54|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@54| |pivot#0@@13|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.CutoffForLeft $ly@@691 |pt#0@@54| |pivot#0@@13|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForLeft $ly@@691 |pt#0@@54| |pivot#0@@13|) (BoundedPivotsLib.__default.NumBuckets |pt#0@@54|))) (forall ((|i#0@@146| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@146|) (INTERNAL_le_boogie |i#0@@146| (BoundedPivotsLib.__default.CutoffForLeft $ly@@691 |pt#0@@54| |pivot#0@@13|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#0@@146|)) (BoundedPivotsLib.__default.KeyToElement |pivot#0@@13|)))
 :qid |BoundedPivotsLibidfy.439:18|
 :skolemid |6527|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#0@@146|)))
))) (forall ((|i#1@@58| Int) ) (!  (=> (and (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForLeft $ly@@691 |pt#0@@54| |pivot#0@@13|) |i#1@@58|) (INTERNAL_lt_boogie |i#1@@58| (|Seq#Length| |pt#0@@54|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement |pivot#0@@13|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#1@@58|))))
 :qid |BoundedPivotsLibidfy.440:18|
 :skolemid |6528|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#1@@58|)))
))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |6529|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft $ly@@691 |pt#0@@54| |pivot#0@@13|))
))))
(assert (forall (($ly@@692 T@U) (|pt#0@@55| T@U) (|pivot#0@@14| T@U) ) (!  (=> (and (and (and (= (type $ly@@692) LayerTypeType) (= (type |pt#0@@55|) (SeqType BoxType))) (= (type |pivot#0@@14|) (SeqType BoxType))) (and ($Is |pt#0@@55| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@14| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.CutoffForLeft#requires| $ly@@692 |pt#0@@55| |pivot#0@@14|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@55|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@55| |pivot#0@@14|))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |6530|
 :pattern ( (|BoundedPivotsLib.__default.CutoffForLeft#requires| $ly@@692 |pt#0@@55| |pivot#0@@14|))
)))
(assert  (=> true (forall (($ly@@693 T@U) (|pt#0@@56| T@U) (|pivot#0@@15| T@U) ) (!  (=> (and (and (and (= (type $ly@@693) LayerTypeType) (= (type |pt#0@@56|) (SeqType BoxType))) (= (type |pivot#0@@15|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@56| |pivot#0@@15|) (and (and ($Is |pt#0@@56| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@15| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@56|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@56| |pivot#0@@15|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@15|) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |pt#0@@56| (BoundedPivotsLib.__default.KeyToElement |pivot#0@@15|))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@693) |pt#0@@56| |pivot#0@@15|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $LZ) |pt#0@@56| (BoundedPivotsLib.__default.KeyToElement |pivot#0@@15|)))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |6531|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@693) |pt#0@@56| |pivot#0@@15|))
))))
(assert  (=> true (forall (($ly@@694 T@U) (|pt#0@@57| T@U) (|pivot#0@@16| T@U) ) (!  (=> (and (and (and (= (type $ly@@694) LayerTypeType) (= (type |pt#0@@57|) (SeqType BoxType))) (= (type |pivot#0@@16|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| (Lit |pt#0@@57|) (Lit |pivot#0@@16|)) (and (and ($Is |pt#0@@57| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@16| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@57|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@57|) (Lit |pivot#0@@16|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@16|)) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |pt#0@@57|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@16|))))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@694) (Lit |pt#0@@57|) (Lit |pivot#0@@16|)) (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $LZ) (Lit |pt#0@@57|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@16|))))))))
 :qid |BoundedPivotsLibidfy.435:22|
 :weight 3
 :skolemid |6532|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@694) (Lit |pt#0@@57|) (Lit |pivot#0@@16|)))
))))
(assert (forall ((arg0@@645 T@U) (arg1@@335 T@U) ) (! (= (type (BoundedPivotsLib.__default.SplitLeft arg0@@645 arg1@@335)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.SplitLeft|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft arg0@@645 arg1@@335))
)))
(assert  (=> true (forall ((|pt#0@@58| T@U) (|pivot#0@@17| T@U) ) (!  (=> (and (and (= (type |pt#0@@58|) (SeqType BoxType)) (= (type |pivot#0@@17|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| |pt#0@@58| |pivot#0@@17|) (and (and ($Is |pt#0@@58| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@17| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@58|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@58| |pivot#0@@17|))))) (and (BoundedPivotsLib.__default.WFPivots (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|)) ($Is (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |6533|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|))
))))
(assert (forall ((|pt#0@@59| T@U) (|pivot#0@@18| T@U) ) (!  (=> (and (and (= (type |pt#0@@59|) (SeqType BoxType)) (= (type |pivot#0@@18|) (SeqType BoxType))) (and ($Is |pt#0@@59| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@18| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.SplitLeft#requires| |pt#0@@59| |pivot#0@@18|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@59|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@59| |pivot#0@@18|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |6534|
 :pattern ( (|BoundedPivotsLib.__default.SplitLeft#requires| |pt#0@@59| |pivot#0@@18|))
)))
(assert (= (type StartFuel_BoundedPivotsLib._default.CutoffForLeft) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@60| T@U) (|pivot#0@@19| T@U) ) (!  (=> (and (and (= (type |pt#0@@60|) (SeqType BoxType)) (= (type |pivot#0@@19|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| |pt#0@@60| |pivot#0@@19|) (and (and ($Is |pt#0@@60| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@19| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@60|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@60| |pivot#0@@19|))))) (and (and (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@60| |pivot#0@@19|) (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@19|)) (= (BoundedPivotsLib.__default.SplitLeft |pt#0@@60| |pivot#0@@19|) (let ((|ret#0| (|Seq#Append| (|Seq#Take| |pt#0@@60| (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForLeft StartFuel_BoundedPivotsLib._default.CutoffForLeft |pt#0@@60| |pivot#0@@19|) 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (BoundedPivotsLib.__default.KeyToElement |pivot#0@@19|))))))
|ret#0|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |6535|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft |pt#0@@60| |pivot#0@@19|))
))))
(assert  (=> true (forall ((|pt#0@@61| T@U) (|pivot#0@@20| T@U) ) (!  (=> (and (and (= (type |pt#0@@61|) (SeqType BoxType)) (= (type |pivot#0@@20|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (and (and ($Is |pt#0@@61| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@20| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@61|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@61|) (Lit |pivot#0@@20|))))))))) (and (and (|BoundedPivotsLib.__default.CutoffForLeft#canCall| (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@20|))) (= (BoundedPivotsLib.__default.SplitLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (let ((|ret#1| (|Seq#Append| (|Seq#Take| (Lit |pt#0@@61|) (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForLeft StartFuel_BoundedPivotsLib._default.CutoffForLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@20|))))))))
|ret#1|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :weight 3
 :skolemid |6536|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)))
))))
(assert (forall (($ly@@695 T@U) (|pt#0@@62| T@U) (|pivot#0@@21| T@U) ) (!  (=> (and (and (= (type $ly@@695) LayerTypeType) (= (type |pt#0@@62|) (SeqType BoxType))) (= (type |pivot#0@@21|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@695) |pt#0@@62| |pivot#0@@21|) (BoundedPivotsLib.__default.CutoffForRight $ly@@695 |pt#0@@62| |pivot#0@@21|)))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |6537|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@695) |pt#0@@62| |pivot#0@@21|))
)))
(assert (forall (($ly@@696 T@U) (|pt#0@@63| T@U) (|pivot#0@@22| T@U) ) (!  (=> (and (and (= (type $ly@@696) LayerTypeType) (= (type |pt#0@@63|) (SeqType BoxType))) (= (type |pivot#0@@22|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForRight $ly@@696 |pt#0@@63| |pivot#0@@22|) (BoundedPivotsLib.__default.CutoffForRight $LZ |pt#0@@63| |pivot#0@@22|)))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |6538|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight (AsFuelBottom $ly@@696) |pt#0@@63| |pivot#0@@22|))
)))
(assert  (=> true (forall (($ly@@697 T@U) (|pt#0@@64| T@U) (|pivot#0@@23| T@U) ) (!  (=> (and (and (and (= (type $ly@@697) LayerTypeType) (= (type |pt#0@@64|) (SeqType BoxType))) (= (type |pivot#0@@23|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@64| |pivot#0@@23|) (and (and ($Is |pt#0@@64| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@23| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@64|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@64| |pivot#0@@23|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.CutoffForRight $ly@@697 |pt#0@@64| |pivot#0@@23|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForRight $ly@@697 |pt#0@@64| |pivot#0@@23|) (BoundedPivotsLib.__default.NumBuckets |pt#0@@64|))) (forall ((|i#0@@147| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@147|) (INTERNAL_le_boogie |i#0@@147| (BoundedPivotsLib.__default.CutoffForRight $ly@@697 |pt#0@@64| |pivot#0@@23|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#0@@147|)) (BoundedPivotsLib.__default.KeyToElement |pivot#0@@23|)))
 :qid |BoundedPivotsLibidfy.481:18|
 :skolemid |6539|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#0@@147|)))
))) (forall ((|i#1@@59| Int) ) (!  (=> (and (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForRight $ly@@697 |pt#0@@64| |pivot#0@@23|) |i#1@@59|) (INTERNAL_lt_boogie |i#1@@59| (|Seq#Length| |pt#0@@64|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |pivot#0@@23|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#1@@59|))))
 :qid |BoundedPivotsLibidfy.482:18|
 :skolemid |6540|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#1@@59|)))
))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |6541|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight $ly@@697 |pt#0@@64| |pivot#0@@23|))
))))
(assert (forall (($ly@@698 T@U) (|pt#0@@65| T@U) (|pivot#0@@24| T@U) ) (!  (=> (and (and (and (= (type $ly@@698) LayerTypeType) (= (type |pt#0@@65|) (SeqType BoxType))) (= (type |pivot#0@@24|) (SeqType BoxType))) (and ($Is |pt#0@@65| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@24| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.CutoffForRight#requires| $ly@@698 |pt#0@@65| |pivot#0@@24|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@65|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@65| |pivot#0@@24|))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |6542|
 :pattern ( (|BoundedPivotsLib.__default.CutoffForRight#requires| $ly@@698 |pt#0@@65| |pivot#0@@24|))
)))
(assert  (=> true (forall (($ly@@699 T@U) (|pt#0@@66| T@U) (|pivot#0@@25| T@U) ) (!  (=> (and (and (and (= (type $ly@@699) LayerTypeType) (= (type |pt#0@@66|) (SeqType BoxType))) (= (type |pivot#0@@25|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@66| |pivot#0@@25|) (and (and ($Is |pt#0@@66| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@25| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@66|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@66| |pivot#0@@25|))))) (and (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@66| |pivot#0@@25|) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@699) |pt#0@@66| |pivot#0@@25|) (BoundedPivotsLib.__default.Route |pt#0@@66| |pivot#0@@25|))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |6543|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@699) |pt#0@@66| |pivot#0@@25|))
))))
(assert  (=> true (forall (($ly@@700 T@U) (|pt#0@@67| T@U) (|pivot#0@@26| T@U) ) (!  (=> (and (and (and (= (type $ly@@700) LayerTypeType) (= (type |pt#0@@67|) (SeqType BoxType))) (= (type |pivot#0@@26|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (and (and ($Is |pt#0@@67| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@26| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@67|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@67|) (Lit |pivot#0@@26|))))))))) (and (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@700) (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (LitInt (BoundedPivotsLib.__default.Route (Lit |pt#0@@67|) (Lit |pivot#0@@26|))))))
 :qid |BoundedPivotsLibidfy.477:22|
 :weight 3
 :skolemid |6544|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@700) (Lit |pt#0@@67|) (Lit |pivot#0@@26|)))
))))
(assert (forall ((arg0@@646 T@U) (arg1@@336 T@U) ) (! (= (type (BoundedPivotsLib.__default.SplitRight arg0@@646 arg1@@336)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.SplitRight|
 :pattern ( (BoundedPivotsLib.__default.SplitRight arg0@@646 arg1@@336))
)))
(assert  (=> true (forall ((|pt#0@@68| T@U) (|pivot#0@@27| T@U) ) (!  (=> (and (and (= (type |pt#0@@68|) (SeqType BoxType)) (= (type |pivot#0@@27|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| |pt#0@@68| |pivot#0@@27|) (and (and ($Is |pt#0@@68| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@27| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@68|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@68| |pivot#0@@27|))))) (and (BoundedPivotsLib.__default.WFPivots (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|)) ($Is (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |6545|
 :pattern ( (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|))
))))
(assert (forall ((|pt#0@@69| T@U) (|pivot#0@@28| T@U) ) (!  (=> (and (and (= (type |pt#0@@69|) (SeqType BoxType)) (= (type |pivot#0@@28|) (SeqType BoxType))) (and ($Is |pt#0@@69| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@28| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.SplitRight#requires| |pt#0@@69| |pivot#0@@28|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@69|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@69| |pivot#0@@28|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |6546|
 :pattern ( (|BoundedPivotsLib.__default.SplitRight#requires| |pt#0@@69| |pivot#0@@28|))
)))
(assert (= (type StartFuel_BoundedPivotsLib._default.CutoffForRight) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@70| T@U) (|pivot#0@@29| T@U) ) (!  (=> (and (and (= (type |pt#0@@70|) (SeqType BoxType)) (= (type |pivot#0@@29|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| |pt#0@@70| |pivot#0@@29|) (and (and ($Is |pt#0@@70| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@29| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@70|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@70| |pivot#0@@29|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@29|) (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@70| |pivot#0@@29|)) (= (BoundedPivotsLib.__default.SplitRight |pt#0@@70| |pivot#0@@29|) (let ((|ret#0@@0| (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (BoundedPivotsLib.__default.KeyToElement |pivot#0@@29|))) (|Seq#Drop| |pt#0@@70| (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForRight StartFuel_BoundedPivotsLib._default.CutoffForRight |pt#0@@70| |pivot#0@@29|) 1)))))
|ret#0@@0|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |6547|
 :pattern ( (BoundedPivotsLib.__default.SplitRight |pt#0@@70| |pivot#0@@29|))
))))
(assert  (=> true (forall ((|pt#0@@71| T@U) (|pivot#0@@30| T@U) ) (!  (=> (and (and (= (type |pt#0@@71|) (SeqType BoxType)) (= (type |pivot#0@@30|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) (and (and ($Is |pt#0@@71| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@30| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@71|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@71|) (Lit |pivot#0@@30|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@30|)) (|BoundedPivotsLib.__default.CutoffForRight#canCall| (Lit |pt#0@@71|) (Lit |pivot#0@@30|))) (= (BoundedPivotsLib.__default.SplitRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) (let ((|ret#1@@0| (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@30|))))) (|Seq#Drop| (Lit |pt#0@@71|) (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForRight StartFuel_BoundedPivotsLib._default.CutoffForRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) 1)))))
|ret#1@@0|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :weight 3
 :skolemid |6548|
 :pattern ( (BoundedPivotsLib.__default.SplitRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)))
))))
(assert  (=> true (forall ((|pt#0@@72| T@U) (|i#0@@148| Int) ) (!  (=> (and (= (type |pt#0@@72|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| |pt#0@@72| |i#0@@148|) (and ($Is |pt#0@@72| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@72|) (and (INTERNAL_le_boogie 0 |i#0@@148|) (INTERNAL_lt_boogie |i#0@@148| (BoundedPivotsLib.__default.NumBuckets |pt#0@@72|))))))) ($Is (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@72| |i#0@@148|) (TISet Tclass.KeyType.Key)))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |6549|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@72| |i#0@@148|))
))))
(assert (forall ((|pt#0@@73| T@U) (|i#0@@149| Int) ) (!  (=> (and (= (type |pt#0@@73|) (SeqType BoxType)) ($Is |pt#0@@73| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| |pt#0@@73| |i#0@@149|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@73|) (and (INTERNAL_le_boogie 0 |i#0@@149|) (INTERNAL_lt_boogie |i#0@@149| (BoundedPivotsLib.__default.NumBuckets |pt#0@@73|))))))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |6550|
 :pattern ( (|BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| |pt#0@@73| |i#0@@149|))
)))
(assert (forall ((arg0@@647 T@U) (arg1@@337 T@U) (arg2@@171 T@U) (arg3@@100 Int) ) (! (= (type (|lambda#363| arg0@@647 arg1@@337 arg2@@171 arg3@@100)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#363|
 :pattern ( (|lambda#363| arg0@@647 arg1@@337 arg2@@171 arg3@@100))
)))
(assert  (=> true (forall ((|pt#0@@74| T@U) (|i#0@@150| Int) ) (!  (=> (and (= (type |pt#0@@74|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| |pt#0@@74| |i#0@@150|) (and ($Is |pt#0@@74| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@74|) (and (INTERNAL_le_boogie 0 |i#0@@150|) (INTERNAL_lt_boogie |i#0@@150| (BoundedPivotsLib.__default.NumBuckets |pt#0@@74|))))))) (and (forall ((|key#0@@212| T@U) ) (!  (=> (and (= (type |key#0@@212|) (SeqType BoxType)) ($Is |key#0@@212| Tclass.KeyType.Key)) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@74| |key#0@@212|) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@74| |key#0@@212|) (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@74| |key#0@@212|))))
 :qid |BoundedPivotsLibidfy.523:10|
 :skolemid |6551|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@74| |key#0@@212|))
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@74| |key#0@@212|))
)) (= (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@74| |i#0@@150|) (|lambda#363| Tclass.KeyType.Key |pt#0@@74| |pt#0@@74| |i#0@@150|))))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |6552|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@74| |i#0@@150|))
))))
(assert  (=> true (forall ((|pt#0@@75| T@U) (|i#0@@151| Int) ) (!  (=> (and (= (type |pt#0@@75|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (Lit |pt#0@@75|) (LitInt |i#0@@151|)) (and ($Is |pt#0@@75| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@75|))))) (and (INTERNAL_le_boogie 0 |i#0@@151|) (INTERNAL_lt_boogie |i#0@@151| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@75|)))))))) (and (forall ((|key#1@@14| T@U) ) (!  (=> (and (= (type |key#1@@14|) (SeqType BoxType)) ($Is |key#1@@14| Tclass.KeyType.Key)) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@75|) |key#1@@14|) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@75|) |key#1@@14|) (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@75|) |key#1@@14|))))
 :qid |BoundedPivotsLibidfy.523:10|
 :skolemid |6553|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@75| |key#1@@14|))
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@75| |key#1@@14|))
)) (= (BoundedPivotsLib.__default.PivotTableBucketKeySet (Lit |pt#0@@75|) (LitInt |i#0@@151|)) (|lambda#363| Tclass.KeyType.Key (Lit |pt#0@@75|) (Lit |pt#0@@75|) (LitInt |i#0@@151|)))))
 :qid |BoundedPivotsLibidfy.519:35|
 :weight 3
 :skolemid |6554|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet (Lit |pt#0@@75|) (LitInt |i#0@@151|)))
))))
(assert (= (type |#DomainMod.Domain.EmptyDomain|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#DomainMod.Domain.EmptyDomain|) |##DomainMod.Domain.EmptyDomain|))
(assert (forall ((d@@80 T@U) ) (!  (=> (= (type d@@80) DatatypeTypeType) (= (DomainMod.Domain.EmptyDomain_q d@@80) (= (DatatypeCtorId d@@80) |##DomainMod.Domain.EmptyDomain|)))
 :qid |unknown.0:0|
 :skolemid |6555|
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@80))
)))
(assert (forall ((d@@81 T@U) ) (!  (=> (and (= (type d@@81) DatatypeTypeType) (DomainMod.Domain.EmptyDomain_q d@@81)) (= d@@81 |#DomainMod.Domain.EmptyDomain|))
 :qid |unknown.0:0|
 :skolemid |6556|
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@81))
)))
(assert ($Is |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain))
(assert (forall (($h@@121 T@U) ) (!  (=> (and (= (type $h@@121) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@121)) ($IsAlloc |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain $h@@121))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |6557|
 :pattern ( ($IsAlloc |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain $h@@121))
)))
(assert (= |#DomainMod.Domain.EmptyDomain| (Lit |#DomainMod.Domain.EmptyDomain|)))
(assert (forall ((arg0@@648 T@U) (arg1@@338 T@U) ) (! (= (type (|#DomainMod.Domain.Domain| arg0@@648 arg1@@338)) DatatypeTypeType)
 :qid |funType:#DomainMod.Domain.Domain|
 :pattern ( (|#DomainMod.Domain.Domain| arg0@@648 arg1@@338))
)))
(assert (forall ((|a#5#0#0@@8| T@U) (|a#5#1#0@@3| T@U) ) (!  (=> (and (= (type |a#5#0#0@@8|) DatatypeTypeType) (= (type |a#5#1#0@@3|) DatatypeTypeType)) (= (DatatypeCtorId (|#DomainMod.Domain.Domain| |a#5#0#0@@8| |a#5#1#0@@3|)) |##DomainMod.Domain.Domain|))
 :qid |Domainidfy.17:42|
 :skolemid |6558|
 :pattern ( (|#DomainMod.Domain.Domain| |a#5#0#0@@8| |a#5#1#0@@3|))
)))
(assert (forall ((d@@82 T@U) ) (!  (=> (= (type d@@82) DatatypeTypeType) (= (DomainMod.Domain.Domain_q d@@82) (= (DatatypeCtorId d@@82) |##DomainMod.Domain.Domain|)))
 :qid |unknown.0:0|
 :skolemid |6559|
 :pattern ( (DomainMod.Domain.Domain_q d@@82))
)))
(assert (forall ((d@@83 T@U) ) (!  (=> (and (= (type d@@83) DatatypeTypeType) (DomainMod.Domain.Domain_q d@@83)) (exists ((|a#6#0#0@@8| T@U) (|a#6#1#0@@3| T@U) ) (!  (and (and (= (type |a#6#0#0@@8|) DatatypeTypeType) (= (type |a#6#1#0@@3|) DatatypeTypeType)) (= d@@83 (|#DomainMod.Domain.Domain| |a#6#0#0@@8| |a#6#1#0@@3|)))
 :qid |Domainidfy.17:42|
 :skolemid |6560|
 :no-pattern (type |a#6#0#0@@8|)
 :no-pattern (type |a#6#1#0@@3|)
 :no-pattern (U_2_int |a#6#0#0@@8|)
 :no-pattern (U_2_bool |a#6#0#0@@8|)
 :no-pattern (U_2_int |a#6#1#0@@3|)
 :no-pattern (U_2_bool |a#6#1#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |6561|
 :pattern ( (DomainMod.Domain.Domain_q d@@83))
)))
(assert (forall ((|a#7#0#0@@8| T@U) (|a#7#1#0@@3| T@U) ) (!  (=> (and (= (type |a#7#0#0@@8|) DatatypeTypeType) (= (type |a#7#1#0@@3|) DatatypeTypeType)) (= ($Is (|#DomainMod.Domain.Domain| |a#7#0#0@@8| |a#7#1#0@@3|) Tclass.DomainMod.Domain)  (and ($Is |a#7#0#0@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |a#7#1#0@@3| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |Domainidfy.17:42|
 :skolemid |6562|
 :pattern ( ($Is (|#DomainMod.Domain.Domain| |a#7#0#0@@8| |a#7#1#0@@3|) Tclass.DomainMod.Domain))
)))
(assert (forall ((|a#8#0#0@@4| T@U) (|a#8#1#0@@2| T@U) ($h@@122 T@U) ) (!  (=> (and (and (and (= (type |a#8#0#0@@4|) DatatypeTypeType) (= (type |a#8#1#0@@2|) DatatypeTypeType)) (= (type $h@@122) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@122)) (= ($IsAlloc (|#DomainMod.Domain.Domain| |a#8#0#0@@4| |a#8#1#0@@2|) Tclass.DomainMod.Domain $h@@122)  (and ($IsAlloc |a#8#0#0@@4| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@122) ($IsAlloc |a#8#1#0@@2| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@122))))
 :qid |Domainidfy.17:42|
 :skolemid |6563|
 :pattern ( ($IsAlloc (|#DomainMod.Domain.Domain| |a#8#0#0@@4| |a#8#1#0@@2|) Tclass.DomainMod.Domain $h@@122))
)))
(assert (forall ((arg0@@649 T@U) ) (! (= (type (DomainMod.Domain.start arg0@@649)) DatatypeTypeType)
 :qid |funType:DomainMod.Domain.start|
 :pattern ( (DomainMod.Domain.start arg0@@649))
)))
(assert (forall ((d@@84 T@U) ($h@@123 T@U) ) (!  (=> (and (and (= (type d@@84) DatatypeTypeType) (= (type $h@@123) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@123) (and (DomainMod.Domain.Domain_q d@@84) ($IsAlloc d@@84 Tclass.DomainMod.Domain $h@@123)))) ($IsAlloc (DomainMod.Domain.start d@@84) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@123))
 :qid |unknown.0:0|
 :skolemid |6564|
 :pattern ( ($IsAlloc (DomainMod.Domain.start d@@84) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@123))
)))
(assert (forall ((arg0@@650 T@U) ) (! (= (type (DomainMod.Domain.end arg0@@650)) DatatypeTypeType)
 :qid |funType:DomainMod.Domain.end|
 :pattern ( (DomainMod.Domain.end arg0@@650))
)))
(assert (forall ((d@@85 T@U) ($h@@124 T@U) ) (!  (=> (and (and (= (type d@@85) DatatypeTypeType) (= (type $h@@124) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@124) (and (DomainMod.Domain.Domain_q d@@85) ($IsAlloc d@@85 Tclass.DomainMod.Domain $h@@124)))) ($IsAlloc (DomainMod.Domain.end d@@85) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@124))
 :qid |unknown.0:0|
 :skolemid |6565|
 :pattern ( ($IsAlloc (DomainMod.Domain.end d@@85) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@124))
)))
(assert (forall ((|a#9#0#0@@2| T@U) (|a#9#1#0@@0| T@U) ) (!  (=> (and (= (type |a#9#0#0@@2|) DatatypeTypeType) (= (type |a#9#1#0@@0|) DatatypeTypeType)) (= (|#DomainMod.Domain.Domain| (Lit |a#9#0#0@@2|) (Lit |a#9#1#0@@0|)) (Lit (|#DomainMod.Domain.Domain| |a#9#0#0@@2| |a#9#1#0@@0|))))
 :qid |Domainidfy.17:42|
 :skolemid |6566|
 :pattern ( (|#DomainMod.Domain.Domain| (Lit |a#9#0#0@@2|) (Lit |a#9#1#0@@0|)))
)))
(assert (forall ((|a#10#0#0@@2| T@U) (|a#10#1#0@@0| T@U) ) (!  (=> (and (= (type |a#10#0#0@@2|) DatatypeTypeType) (= (type |a#10#1#0@@0|) DatatypeTypeType)) (= (DomainMod.Domain.start (|#DomainMod.Domain.Domain| |a#10#0#0@@2| |a#10#1#0@@0|)) |a#10#0#0@@2|))
 :qid |Domainidfy.17:42|
 :skolemid |6567|
 :pattern ( (|#DomainMod.Domain.Domain| |a#10#0#0@@2| |a#10#1#0@@0|))
)))
(assert (forall ((|a#11#0#0@@2| T@U) (|a#11#1#0@@0| T@U) ) (!  (=> (and (= (type |a#11#0#0@@2|) DatatypeTypeType) (= (type |a#11#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#11#0#0@@2|) (DtRank (|#DomainMod.Domain.Domain| |a#11#0#0@@2| |a#11#1#0@@0|))))
 :qid |Domainidfy.17:42|
 :skolemid |6568|
 :pattern ( (|#DomainMod.Domain.Domain| |a#11#0#0@@2| |a#11#1#0@@0|))
)))
(assert (forall ((|a#12#0#0@@1| T@U) (|a#12#1#0@@0| T@U) ) (!  (=> (and (= (type |a#12#0#0@@1|) DatatypeTypeType) (= (type |a#12#1#0@@0|) DatatypeTypeType)) (= (DomainMod.Domain.end (|#DomainMod.Domain.Domain| |a#12#0#0@@1| |a#12#1#0@@0|)) |a#12#1#0@@0|))
 :qid |Domainidfy.17:42|
 :skolemid |6569|
 :pattern ( (|#DomainMod.Domain.Domain| |a#12#0#0@@1| |a#12#1#0@@0|))
)))
(assert (forall ((|a#13#0#0@@0| T@U) (|a#13#1#0@@0| T@U) ) (!  (=> (and (= (type |a#13#0#0@@0|) DatatypeTypeType) (= (type |a#13#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#13#1#0@@0|) (DtRank (|#DomainMod.Domain.Domain| |a#13#0#0@@0| |a#13#1#0@@0|))))
 :qid |Domainidfy.17:42|
 :skolemid |6570|
 :pattern ( (|#DomainMod.Domain.Domain| |a#13#0#0@@0| |a#13#1#0@@0|))
)))
(assert (forall ((d@@86 T@U) ) (!  (=> (and (= (type d@@86) DatatypeTypeType) (|$IsA#DomainMod.Domain| d@@86)) (or (DomainMod.Domain.EmptyDomain_q d@@86) (DomainMod.Domain.Domain_q d@@86)))
 :qid |unknown.0:0|
 :skolemid |6571|
 :pattern ( (|$IsA#DomainMod.Domain| d@@86))
)))
(assert (forall ((d@@87 T@U) ) (!  (=> (and (= (type d@@87) DatatypeTypeType) ($Is d@@87 Tclass.DomainMod.Domain)) (or (DomainMod.Domain.EmptyDomain_q d@@87) (DomainMod.Domain.Domain_q d@@87)))
 :qid |unknown.0:0|
 :skolemid |6572|
 :pattern ( (DomainMod.Domain.Domain_q d@@87) ($Is d@@87 Tclass.DomainMod.Domain))
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@87) ($Is d@@87 Tclass.DomainMod.Domain))
)))
(assert (forall ((a@@142 T@U) (b@@91 T@U) ) (!  (=> (and (and (= (type a@@142) DatatypeTypeType) (= (type b@@91) DatatypeTypeType)) (and (DomainMod.Domain.EmptyDomain_q a@@142) (DomainMod.Domain.EmptyDomain_q b@@91))) (= (|DomainMod.Domain#Equal| a@@142 b@@91) true))
 :qid |unknown.0:0|
 :skolemid |6573|
 :pattern ( (|DomainMod.Domain#Equal| a@@142 b@@91) (DomainMod.Domain.EmptyDomain_q a@@142))
 :pattern ( (|DomainMod.Domain#Equal| a@@142 b@@91) (DomainMod.Domain.EmptyDomain_q b@@91))
)))
(assert (forall ((a@@143 T@U) (b@@92 T@U) ) (!  (=> (and (and (= (type a@@143) DatatypeTypeType) (= (type b@@92) DatatypeTypeType)) (and (DomainMod.Domain.Domain_q a@@143) (DomainMod.Domain.Domain_q b@@92))) (= (|DomainMod.Domain#Equal| a@@143 b@@92)  (and (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (DomainMod.Domain.start a@@143) (DomainMod.Domain.start b@@92)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (DomainMod.Domain.end a@@143) (DomainMod.Domain.end b@@92)))))
 :qid |unknown.0:0|
 :skolemid |6574|
 :pattern ( (|DomainMod.Domain#Equal| a@@143 b@@92) (DomainMod.Domain.Domain_q a@@143))
 :pattern ( (|DomainMod.Domain#Equal| a@@143 b@@92) (DomainMod.Domain.Domain_q b@@92))
)))
(assert (forall ((a@@144 T@U) (b@@93 T@U) ) (!  (=> (and (= (type a@@144) DatatypeTypeType) (= (type b@@93) DatatypeTypeType)) (= (|DomainMod.Domain#Equal| a@@144 b@@93) (= a@@144 b@@93)))
 :qid |unknown.0:0|
 :skolemid |6575|
 :pattern ( (|DomainMod.Domain#Equal| a@@144 b@@93))
)))
(assert (forall (($ly@@701 T@U) (this@@123 T@U) ) (!  (=> (and (= (type $ly@@701) LayerTypeType) (= (type this@@123) DatatypeTypeType)) (= (DomainMod.Domain.SaneKeys ($LS $ly@@701) this@@123) (DomainMod.Domain.SaneKeys $ly@@701 this@@123)))
 :qid |Domainidfy.21:25|
 :skolemid |6576|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@701) this@@123))
)))
(assert (forall (($ly@@702 T@U) (this@@124 T@U) ) (!  (=> (and (= (type $ly@@702) LayerTypeType) (= (type this@@124) DatatypeTypeType)) (= (DomainMod.Domain.SaneKeys $ly@@702 this@@124) (DomainMod.Domain.SaneKeys $LZ this@@124)))
 :qid |Domainidfy.21:25|
 :skolemid |6577|
 :pattern ( (DomainMod.Domain.SaneKeys (AsFuelBottom $ly@@702) this@@124))
)))
(assert  (=> true (forall (($ly@@703 T@U) (this@@125 T@U) ) (!  (=> (and (and (= (type $ly@@703) LayerTypeType) (= (type this@@125) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| this@@125) ($Is this@@125 Tclass.DomainMod.Domain))) true)
 :qid |Domainidfy.21:25|
 :skolemid |6578|
 :pattern ( (DomainMod.Domain.SaneKeys $ly@@703 this@@125))
))))
(assert (forall (($ly@@704 T@U) (this@@126 T@U) ) (!  (=> (and (and (= (type $ly@@704) LayerTypeType) (= (type this@@126) DatatypeTypeType)) ($Is this@@126 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.SaneKeys#requires| $ly@@704 this@@126) true))
 :qid |Domainidfy.21:25|
 :skolemid |6579|
 :pattern ( (|DomainMod.Domain.SaneKeys#requires| $ly@@704 this@@126))
)))
(assert  (=> true (forall (($ly@@705 T@U) (this@@127 T@U) ) (!  (=> (and (and (= (type $ly@@705) LayerTypeType) (= (type this@@127) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| this@@127) ($Is this@@127 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (not (DomainMod.Domain.EmptyDomain_q this@@127)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (DomainMod.Domain.start this@@127) (DomainMod.Domain.end this@@127)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (DomainMod.Domain.start this@@127) (DomainMod.Domain.end this@@127)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.start this@@127)) (and (|BoundedPivotsLib.__default.ElementIsKey#canCall| (DomainMod.Domain.start this@@127)) (=> (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.start this@@127)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.end this@@127)) (|BoundedPivotsLib.__default.ElementIsKey#canCall| (DomainMod.Domain.end this@@127)))))))))) (= (DomainMod.Domain.SaneKeys ($LS $ly@@705) this@@127)  (and true (=> (not (DomainMod.Domain.EmptyDomain_q this@@127)) (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.lt (DomainMod.Domain.start this@@127) (DomainMod.Domain.end this@@127)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.start this@@127))) (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.start this@@127))) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.end this@@127)) (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.end this@@127)))))))))
 :qid |Domainidfy.21:25|
 :skolemid |6580|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@705) this@@127))
))))
(assert  (=> true (forall (($ly@@706 T@U) (this@@128 T@U) ) (!  (=> (and (and (= (type $ly@@706) LayerTypeType) (= (type this@@128) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| (Lit this@@128)) ($Is this@@128 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@128)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (DomainMod.Domain.start (Lit this@@128))) (Lit (DomainMod.Domain.end (Lit this@@128)))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (DomainMod.Domain.start (Lit this@@128))) (Lit (DomainMod.Domain.end (Lit this@@128))))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.start (Lit this@@128))))))) (and (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit (DomainMod.Domain.start (Lit this@@128)))) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.start (Lit this@@128))))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.end (Lit this@@128))))))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit (DomainMod.Domain.end (Lit this@@128)))))))))))) (= (DomainMod.Domain.SaneKeys ($LS $ly@@706) (Lit this@@128))  (and true (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@128)))))) (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (DomainMod.Domain.start (Lit this@@128))) (Lit (DomainMod.Domain.end (Lit this@@128)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.start (Lit this@@128))))) (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.start (Lit this@@128))))) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.end (Lit this@@128)))) (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.end (Lit this@@128)))))))))))
 :qid |Domainidfy.21:25|
 :weight 3
 :skolemid |6581|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@706) (Lit this@@128)))
))))
(assert  (=> true (forall ((this@@129 T@U) ) (!  (=> (and (= (type this@@129) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| this@@129) ($Is this@@129 Tclass.DomainMod.Domain))) true)
 :qid |Domainidfy.31:15|
 :skolemid |6582|
 :pattern ( (DomainMod.Domain.WF this@@129))
))))
(assert (forall ((this@@130 T@U) ) (!  (=> (and (= (type this@@130) DatatypeTypeType) ($Is this@@130 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.WF#requires| this@@130) true))
 :qid |Domainidfy.31:15|
 :skolemid |6583|
 :pattern ( (|DomainMod.Domain.WF#requires| this@@130))
)))
(assert (= (type StartFuel_DomainMod.Domain.SaneKeys) LayerTypeType))
(assert  (=> true (forall ((this@@131 T@U) ) (!  (=> (and (= (type this@@131) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| this@@131) ($Is this@@131 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|DomainMod.Domain.SaneKeys#canCall| this@@131)) (= (DomainMod.Domain.WF this@@131)  (and true (DomainMod.Domain.SaneKeys StartFuel_DomainMod.Domain.SaneKeys this@@131)))))
 :qid |Domainidfy.31:15|
 :skolemid |6584|
 :pattern ( (DomainMod.Domain.WF this@@131))
))))
(assert  (=> true (forall ((this@@132 T@U) ) (!  (=> (and (= (type this@@132) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| (Lit this@@132)) ($Is this@@132 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|DomainMod.Domain.SaneKeys#canCall| (Lit this@@132))) (= (DomainMod.Domain.WF (Lit this@@132))  (and true (DomainMod.Domain.SaneKeys StartFuel_DomainMod.Domain.SaneKeys (Lit this@@132))))))
 :qid |Domainidfy.31:15|
 :weight 3
 :skolemid |6585|
 :pattern ( (DomainMod.Domain.WF (Lit this@@132)))
))))
(assert  (=> true (forall ((this@@133 T@U) (|key#0@@213| T@U) ) (!  (=> (and (and (= (type this@@133) DatatypeTypeType) (= (type |key#0@@213|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| this@@133 |key#0@@213|) (and ($Is this@@133 Tclass.DomainMod.Domain) ($Is |key#0@@213| Tclass.KeyType.Key)))) true)
 :qid |Domainidfy.35:15|
 :skolemid |6586|
 :pattern ( (DomainMod.Domain.Contains this@@133 |key#0@@213|))
))))
(assert (forall ((this@@134 T@U) (|key#0@@214| T@U) ) (!  (=> (and (and (= (type this@@134) DatatypeTypeType) (= (type |key#0@@214|) (SeqType BoxType))) (and ($Is this@@134 Tclass.DomainMod.Domain) ($Is |key#0@@214| Tclass.KeyType.Key))) (= (|DomainMod.Domain.Contains#requires| this@@134 |key#0@@214|) true))
 :qid |Domainidfy.35:15|
 :skolemid |6587|
 :pattern ( (|DomainMod.Domain.Contains#requires| this@@134 |key#0@@214|))
)))
(assert  (=> true (forall ((this@@135 T@U) (|key#0@@215| T@U) ) (!  (=> (and (and (= (type this@@135) DatatypeTypeType) (= (type |key#0@@215|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| this@@135 |key#0@@215|) (and ($Is this@@135 Tclass.DomainMod.Domain) ($Is |key#0@@215| Tclass.KeyType.Key)))) (and (=> (not (DomainMod.Domain.EmptyDomain_q this@@135)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (DomainMod.Domain.start this@@135) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@215|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte (DomainMod.Domain.start this@@135) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@215|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@215|) (DomainMod.Domain.end this@@135))))) (= (DomainMod.Domain.Contains this@@135 |key#0@@215|)  (and (and (not (DomainMod.Domain.EmptyDomain_q this@@135)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (DomainMod.Domain.start this@@135) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@215|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@215|) (DomainMod.Domain.end this@@135))))))
 :qid |Domainidfy.35:15|
 :skolemid |6588|
 :pattern ( (DomainMod.Domain.Contains this@@135 |key#0@@215|))
))))
(assert  (=> true (forall ((this@@136 T@U) (|key#0@@216| T@U) ) (!  (=> (and (and (= (type this@@136) DatatypeTypeType) (= (type |key#0@@216|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| (Lit this@@136) (Lit |key#0@@216|)) (and ($Is this@@136 Tclass.DomainMod.Domain) ($Is |key#0@@216| Tclass.KeyType.Key)))) (and (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@136)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit (DomainMod.Domain.start (Lit this@@136))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@216|)))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (DomainMod.Domain.start (Lit this@@136))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@216|))))))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@216|))) (Lit (DomainMod.Domain.end (Lit this@@136))))))) (= (DomainMod.Domain.Contains (Lit this@@136) (Lit |key#0@@216|))  (and (and (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@136)))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (DomainMod.Domain.start (Lit this@@136))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@216|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@216|))) (Lit (DomainMod.Domain.end (Lit this@@136))))))))
 :qid |Domainidfy.35:15|
 :weight 3
 :skolemid |6589|
 :pattern ( (DomainMod.Domain.Contains (Lit this@@136) (Lit |key#0@@216|)))
))))
(assert  (=> true (forall ((this@@137 T@U) ) (!  (=> (and (= (type this@@137) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| this@@137) ($Is this@@137 Tclass.DomainMod.Domain))) ($Is (DomainMod.Domain.KeySet this@@137) (TISet Tclass.KeyType.Key)))
 :qid |Domainidfy.64:14|
 :skolemid |6590|
 :pattern ( (DomainMod.Domain.KeySet this@@137))
))))
(assert (forall ((this@@138 T@U) ) (!  (=> (and (= (type this@@138) DatatypeTypeType) ($Is this@@138 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.KeySet#requires| this@@138) true))
 :qid |Domainidfy.64:14|
 :skolemid |6591|
 :pattern ( (|DomainMod.Domain.KeySet#requires| this@@138))
)))
(assert (forall ((arg0@@651 T@U) (arg1@@339 T@U) ) (! (= (type (|lambda#365| arg0@@651 arg1@@339)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#365|
 :pattern ( (|lambda#365| arg0@@651 arg1@@339))
)))
(assert  (=> true (forall ((this@@139 T@U) ) (!  (=> (and (= (type this@@139) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| this@@139) ($Is this@@139 Tclass.DomainMod.Domain))) (and (forall ((|key#0@@217| T@U) ) (!  (=> (and (= (type |key#0@@217|) (SeqType BoxType)) ($Is |key#0@@217| Tclass.KeyType.Key)) (|DomainMod.Domain.Contains#canCall| this@@139 |key#0@@217|))
 :qid |Domainidfy.66:12|
 :skolemid |6592|
 :pattern ( (DomainMod.Domain.Contains this@@139 |key#0@@217|))
)) (= (DomainMod.Domain.KeySet this@@139) (|lambda#365| Tclass.KeyType.Key this@@139))))
 :qid |Domainidfy.64:14|
 :skolemid |6593|
 :pattern ( (DomainMod.Domain.KeySet this@@139))
))))
(assert  (=> true (forall ((this@@140 T@U) ) (!  (=> (and (= (type this@@140) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| (Lit this@@140)) ($Is this@@140 Tclass.DomainMod.Domain))) (and (forall ((|key#1@@15| T@U) ) (!  (=> (and (= (type |key#1@@15|) (SeqType BoxType)) ($Is |key#1@@15| Tclass.KeyType.Key)) (|DomainMod.Domain.Contains#canCall| (Lit this@@140) |key#1@@15|))
 :qid |Domainidfy.66:12|
 :skolemid |6594|
 :pattern ( (DomainMod.Domain.Contains this@@140 |key#1@@15|))
)) (= (DomainMod.Domain.KeySet (Lit this@@140)) (|lambda#365| Tclass.KeyType.Key (Lit this@@140)))))
 :qid |Domainidfy.64:14|
 :weight 3
 :skolemid |6595|
 :pattern ( (DomainMod.Domain.KeySet (Lit this@@140)))
))))
(assert (= (type Tclass.DomainMod.__default) TyType))
(assert (= (Tag Tclass.DomainMod.__default) Tagclass.DomainMod.__default))
(assert (= (TagFamily Tclass.DomainMod.__default) tytagFamily$_default))
(assert (forall ((bx@@178 T@U) ) (!  (=> (and (= (type bx@@178) BoxType) ($IsBox bx@@178 Tclass.DomainMod.__default)) (and (= ($Box ($Unbox refType bx@@178)) bx@@178) ($Is ($Unbox refType bx@@178) Tclass.DomainMod.__default)))
 :qid |unknown.0:0|
 :skolemid |6596|
 :pattern ( ($IsBox bx@@178 Tclass.DomainMod.__default))
)))
(assert (forall (($o@@67 T@U) ) (!  (=> (= (type $o@@67) refType) (= ($Is $o@@67 Tclass.DomainMod.__default)  (or (= $o@@67 null) (= (dtype $o@@67) Tclass.DomainMod.__default))))
 :qid |unknown.0:0|
 :skolemid |6597|
 :pattern ( ($Is $o@@67 Tclass.DomainMod.__default))
)))
(assert (forall (($o@@68 T@U) ($h@@125 T@U) ) (!  (=> (and (= (type $o@@68) refType) (= (type $h@@125) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@68 Tclass.DomainMod.__default $h@@125)  (or (= $o@@68 null) (U_2_bool (MapType1Select (MapType0Select $h@@125 $o@@68) alloc)))))
 :qid |unknown.0:0|
 :skolemid |6598|
 :pattern ( ($IsAlloc $o@@68 Tclass.DomainMod.__default $h@@125))
)))
(assert  (=> true (=> true (and (and (DomainMod.Domain.WF DomainMod.__default.TotalDomain) (DomainMod.Domain.Domain_q DomainMod.__default.TotalDomain)) ($Is DomainMod.__default.TotalDomain Tclass.DomainMod.Domain)))))
(assert (= |DomainMod.__default.TotalDomain#requires| true))
(assert  (=> true (=> true (and |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| (= DomainMod.__default.TotalDomain (let ((|out#0@@4| (Lit (|#DomainMod.Domain.Domain| (Lit Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
|out#0@@4|))))))
(assert  (=> true (=> true (and |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| (= DomainMod.__default.TotalDomain (let ((|out#1@@2| (Lit (|#DomainMod.Domain.Domain| (Lit Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
|out#1@@2|))))))
(assert (forall ((arg0@@652 Int) (arg1@@340 T@U) ) (! (= (type (|#SplitRequestMod.SplitRequest.SplitLeaf| arg0@@652 arg1@@340)) DatatypeTypeType)
 :qid |funType:#SplitRequestMod.SplitRequest.SplitLeaf|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| arg0@@652 arg1@@340))
)))
(assert (forall ((|a#0#0#0@@7| Int) (|a#0#1#0@@3| T@U) ) (!  (=> (= (type |a#0#1#0@@3|) (SeqType BoxType)) (= (DatatypeCtorId (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#0#0#0@@7| |a#0#1#0@@3|)) |##SplitRequestMod.SplitRequest.SplitLeaf|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6599|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#0#0#0@@7| |a#0#1#0@@3|))
)))
(assert (forall ((d@@88 T@U) ) (!  (=> (= (type d@@88) DatatypeTypeType) (= (SplitRequestMod.SplitRequest.SplitLeaf_q d@@88) (= (DatatypeCtorId d@@88) |##SplitRequestMod.SplitRequest.SplitLeaf|)))
 :qid |unknown.0:0|
 :skolemid |6600|
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@88))
)))
(assert (forall ((d@@89 T@U) ) (!  (=> (and (= (type d@@89) DatatypeTypeType) (SplitRequestMod.SplitRequest.SplitLeaf_q d@@89)) (exists ((|a#1#0#0@@7| Int) (|a#1#1#0@@3| T@U) ) (!  (and (= (type |a#1#1#0@@3|) (SeqType BoxType)) (= d@@89 (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#1#0#0@@7| |a#1#1#0@@3|)))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6601|
 :no-pattern (type |a#1#1#0@@3|)
 :no-pattern (U_2_int |a#1#1#0@@3|)
 :no-pattern (U_2_bool |a#1#1#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |6602|
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@89))
)))
(assert (forall ((|a#2#0#0@@7| Int) (|a#2#1#0@@3| T@U) ) (!  (=> (= (type |a#2#1#0@@3|) (SeqType BoxType)) (= ($Is (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#2#0#0@@7| |a#2#1#0@@3|) Tclass.SplitRequestMod.SplitRequest)  (and ($Is (int_2_U |a#2#0#0@@7|) Tclass._System.nat) ($Is |a#2#1#0@@3| Tclass.KeyType.Key))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6603|
 :pattern ( ($Is (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#2#0#0@@7| |a#2#1#0@@3|) Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((|a#3#0#0@@7| Int) (|a#3#1#0@@3| T@U) ($h@@126 T@U) ) (!  (=> (and (and (= (type |a#3#1#0@@3|) (SeqType BoxType)) (= (type $h@@126) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@126)) (= ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#3#0#0@@7| |a#3#1#0@@3|) Tclass.SplitRequestMod.SplitRequest $h@@126)  (and ($IsAlloc (int_2_U |a#3#0#0@@7|) Tclass._System.nat $h@@126) ($IsAlloc |a#3#1#0@@3| Tclass.KeyType.Key $h@@126))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6604|
 :pattern ( ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#3#0#0@@7| |a#3#1#0@@3|) Tclass.SplitRequestMod.SplitRequest $h@@126))
)))
(assert (forall ((d@@90 T@U) ($h@@127 T@U) ) (!  (=> (and (and (= (type d@@90) DatatypeTypeType) (= (type $h@@127) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@127) (and (SplitRequestMod.SplitRequest.SplitLeaf_q d@@90) ($IsAlloc d@@90 Tclass.SplitRequestMod.SplitRequest $h@@127)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@90)) Tclass._System.nat $h@@127))
 :qid |unknown.0:0|
 :skolemid |6605|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@90)) Tclass._System.nat $h@@127))
)))
(assert (forall ((arg0@@653 T@U) ) (! (= (type (SplitRequestMod.SplitRequest.splitKey arg0@@653)) (SeqType BoxType))
 :qid |funType:SplitRequestMod.SplitRequest.splitKey|
 :pattern ( (SplitRequestMod.SplitRequest.splitKey arg0@@653))
)))
(assert (forall ((d@@91 T@U) ($h@@128 T@U) ) (!  (=> (and (and (= (type d@@91) DatatypeTypeType) (= (type $h@@128) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@128) (and (SplitRequestMod.SplitRequest.SplitLeaf_q d@@91) ($IsAlloc d@@91 Tclass.SplitRequestMod.SplitRequest $h@@128)))) ($IsAlloc (SplitRequestMod.SplitRequest.splitKey d@@91) Tclass.KeyType.Key $h@@128))
 :qid |unknown.0:0|
 :skolemid |6606|
 :pattern ( ($IsAlloc (SplitRequestMod.SplitRequest.splitKey d@@91) Tclass.KeyType.Key $h@@128))
)))
(assert (forall ((|a#4#0#0@@7| Int) (|a#4#1#0@@3| T@U) ) (!  (=> (= (type |a#4#1#0@@3|) (SeqType BoxType)) (= (|#SplitRequestMod.SplitRequest.SplitLeaf| (LitInt |a#4#0#0@@7|) (Lit |a#4#1#0@@3|)) (Lit (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#4#0#0@@7| |a#4#1#0@@3|))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6607|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| (LitInt |a#4#0#0@@7|) (Lit |a#4#1#0@@3|)))
)))
(assert (forall ((|a#5#0#0@@9| Int) (|a#5#1#0@@4| T@U) ) (!  (=> (= (type |a#5#1#0@@4|) (SeqType BoxType)) (= (SplitRequestMod.SplitRequest.childIdx (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#5#0#0@@9| |a#5#1#0@@4|)) |a#5#0#0@@9|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6608|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#5#0#0@@9| |a#5#1#0@@4|))
)))
(assert (forall ((|a#6#0#0@@9| Int) (|a#6#1#0@@4| T@U) ) (!  (=> (= (type |a#6#1#0@@4|) (SeqType BoxType)) (= (SplitRequestMod.SplitRequest.splitKey (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#6#0#0@@9| |a#6#1#0@@4|)) |a#6#1#0@@4|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |6609|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#6#0#0@@9| |a#6#1#0@@4|))
)))
(assert (forall ((arg0@@654 Int) (arg1@@341 Int) ) (! (= (type (|#SplitRequestMod.SplitRequest.SplitIndex| arg0@@654 arg1@@341)) DatatypeTypeType)
 :qid |funType:#SplitRequestMod.SplitRequest.SplitIndex|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| arg0@@654 arg1@@341))
)))
(assert (forall ((|a#7#0#0@@9| Int) (|a#7#1#0@@4| Int) ) (! (= (DatatypeCtorId (|#SplitRequestMod.SplitRequest.SplitIndex| |a#7#0#0@@9| |a#7#1#0@@4|)) |##SplitRequestMod.SplitRequest.SplitIndex|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |6610|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#7#0#0@@9| |a#7#1#0@@4|))
)))
(assert (forall ((d@@92 T@U) ) (!  (=> (= (type d@@92) DatatypeTypeType) (= (SplitRequestMod.SplitRequest.SplitIndex_q d@@92) (= (DatatypeCtorId d@@92) |##SplitRequestMod.SplitRequest.SplitIndex|)))
 :qid |unknown.0:0|
 :skolemid |6611|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@92))
)))
(assert (forall ((d@@93 T@U) ) (!  (=> (and (= (type d@@93) DatatypeTypeType) (SplitRequestMod.SplitRequest.SplitIndex_q d@@93)) (exists ((|a#8#0#0@@5| Int) (|a#8#1#0@@3| Int) ) (! (= d@@93 (|#SplitRequestMod.SplitRequest.SplitIndex| |a#8#0#0@@5| |a#8#1#0@@3|))
 :qid |SplitRequestidfy.11:18|
 :skolemid |6612|
)))
 :qid |unknown.0:0|
 :skolemid |6613|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@93))
)))
(assert (forall ((|a#9#0#0@@3| Int) (|a#9#1#0@@1| Int) ) (! (= ($Is (|#SplitRequestMod.SplitRequest.SplitIndex| |a#9#0#0@@3| |a#9#1#0@@1|) Tclass.SplitRequestMod.SplitRequest)  (and ($Is (int_2_U |a#9#0#0@@3|) Tclass._System.nat) ($Is (int_2_U |a#9#1#0@@1|) Tclass._System.nat)))
 :qid |SplitRequestidfy.11:18|
 :skolemid |6614|
 :pattern ( ($Is (|#SplitRequestMod.SplitRequest.SplitIndex| |a#9#0#0@@3| |a#9#1#0@@1|) Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((|a#10#0#0@@3| Int) (|a#10#1#0@@1| Int) ($h@@129 T@U) ) (!  (=> (and (= (type $h@@129) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@129)) (= ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitIndex| |a#10#0#0@@3| |a#10#1#0@@1|) Tclass.SplitRequestMod.SplitRequest $h@@129)  (and ($IsAlloc (int_2_U |a#10#0#0@@3|) Tclass._System.nat $h@@129) ($IsAlloc (int_2_U |a#10#1#0@@1|) Tclass._System.nat $h@@129))))
 :qid |SplitRequestidfy.11:18|
 :skolemid |6615|
 :pattern ( ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitIndex| |a#10#0#0@@3| |a#10#1#0@@1|) Tclass.SplitRequestMod.SplitRequest $h@@129))
)))
(assert (forall ((d@@94 T@U) ($h@@130 T@U) ) (!  (=> (and (and (= (type d@@94) DatatypeTypeType) (= (type $h@@130) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@130) (and (SplitRequestMod.SplitRequest.SplitIndex_q d@@94) ($IsAlloc d@@94 Tclass.SplitRequestMod.SplitRequest $h@@130)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@94)) Tclass._System.nat $h@@130))
 :qid |unknown.0:0|
 :skolemid |6616|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@94)) Tclass._System.nat $h@@130))
)))
(assert (forall ((d@@95 T@U) ($h@@131 T@U) ) (!  (=> (and (and (= (type d@@95) DatatypeTypeType) (= (type $h@@131) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@131) (and (SplitRequestMod.SplitRequest.SplitIndex_q d@@95) ($IsAlloc d@@95 Tclass.SplitRequestMod.SplitRequest $h@@131)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childPivotIdx d@@95)) Tclass._System.nat $h@@131))
 :qid |unknown.0:0|
 :skolemid |6617|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childPivotIdx d@@95)) Tclass._System.nat $h@@131))
)))
(assert (forall ((|a#11#0#0@@3| Int) (|a#11#1#0@@1| Int) ) (! (= (|#SplitRequestMod.SplitRequest.SplitIndex| (LitInt |a#11#0#0@@3|) (LitInt |a#11#1#0@@1|)) (Lit (|#SplitRequestMod.SplitRequest.SplitIndex| |a#11#0#0@@3| |a#11#1#0@@1|)))
 :qid |SplitRequestidfy.11:18|
 :skolemid |6618|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| (LitInt |a#11#0#0@@3|) (LitInt |a#11#1#0@@1|)))
)))
(assert (forall ((|a#12#0#0@@2| Int) (|a#12#1#0@@1| Int) ) (! (= (SplitRequestMod.SplitRequest.childIdx (|#SplitRequestMod.SplitRequest.SplitIndex| |a#12#0#0@@2| |a#12#1#0@@1|)) |a#12#0#0@@2|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |6619|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#12#0#0@@2| |a#12#1#0@@1|))
)))
(assert (forall ((|a#13#0#0@@1| Int) (|a#13#1#0@@1| Int) ) (! (= (SplitRequestMod.SplitRequest.childPivotIdx (|#SplitRequestMod.SplitRequest.SplitIndex| |a#13#0#0@@1| |a#13#1#0@@1|)) |a#13#1#0@@1|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |6620|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#13#0#0@@1| |a#13#1#0@@1|))
)))
(assert (forall ((d@@96 T@U) ) (!  (=> (and (= (type d@@96) DatatypeTypeType) (|$IsA#SplitRequestMod.SplitRequest| d@@96)) (or (SplitRequestMod.SplitRequest.SplitLeaf_q d@@96) (SplitRequestMod.SplitRequest.SplitIndex_q d@@96)))
 :qid |unknown.0:0|
 :skolemid |6621|
 :pattern ( (|$IsA#SplitRequestMod.SplitRequest| d@@96))
)))
(assert (forall ((d@@97 T@U) ) (!  (=> (and (= (type d@@97) DatatypeTypeType) ($Is d@@97 Tclass.SplitRequestMod.SplitRequest)) (or (SplitRequestMod.SplitRequest.SplitLeaf_q d@@97) (SplitRequestMod.SplitRequest.SplitIndex_q d@@97)))
 :qid |unknown.0:0|
 :skolemid |6622|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@97) ($Is d@@97 Tclass.SplitRequestMod.SplitRequest))
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@97) ($Is d@@97 Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((a@@145 T@U) (b@@94 T@U) ) (!  (=> (and (and (= (type a@@145) DatatypeTypeType) (= (type b@@94) DatatypeTypeType)) (and (SplitRequestMod.SplitRequest.SplitLeaf_q a@@145) (SplitRequestMod.SplitRequest.SplitLeaf_q b@@94))) (= (|SplitRequestMod.SplitRequest#Equal| a@@145 b@@94)  (and (= (SplitRequestMod.SplitRequest.childIdx a@@145) (SplitRequestMod.SplitRequest.childIdx b@@94)) (|Seq#Equal| (SplitRequestMod.SplitRequest.splitKey a@@145) (SplitRequestMod.SplitRequest.splitKey b@@94)))))
 :qid |unknown.0:0|
 :skolemid |6623|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@145 b@@94) (SplitRequestMod.SplitRequest.SplitLeaf_q a@@145))
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@145 b@@94) (SplitRequestMod.SplitRequest.SplitLeaf_q b@@94))
)))
(assert (forall ((a@@146 T@U) (b@@95 T@U) ) (!  (=> (and (and (= (type a@@146) DatatypeTypeType) (= (type b@@95) DatatypeTypeType)) (and (SplitRequestMod.SplitRequest.SplitIndex_q a@@146) (SplitRequestMod.SplitRequest.SplitIndex_q b@@95))) (= (|SplitRequestMod.SplitRequest#Equal| a@@146 b@@95)  (and (= (SplitRequestMod.SplitRequest.childIdx a@@146) (SplitRequestMod.SplitRequest.childIdx b@@95)) (= (SplitRequestMod.SplitRequest.childPivotIdx a@@146) (SplitRequestMod.SplitRequest.childPivotIdx b@@95)))))
 :qid |unknown.0:0|
 :skolemid |6624|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@146 b@@95) (SplitRequestMod.SplitRequest.SplitIndex_q a@@146))
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@146 b@@95) (SplitRequestMod.SplitRequest.SplitIndex_q b@@95))
)))
(assert (forall ((a@@147 T@U) (b@@96 T@U) ) (!  (=> (and (= (type a@@147) DatatypeTypeType) (= (type b@@96) DatatypeTypeType)) (= (|SplitRequestMod.SplitRequest#Equal| a@@147 b@@96) (= a@@147 b@@96)))
 :qid |unknown.0:0|
 :skolemid |6625|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@147 b@@96))
)))
(assert (= (type Tclass.SplitRequestMod.__default) TyType))
(assert (= (Tag Tclass.SplitRequestMod.__default) Tagclass.SplitRequestMod.__default))
(assert (= (TagFamily Tclass.SplitRequestMod.__default) tytagFamily$_default))
(assert (forall ((bx@@179 T@U) ) (!  (=> (and (= (type bx@@179) BoxType) ($IsBox bx@@179 Tclass.SplitRequestMod.__default)) (and (= ($Box ($Unbox refType bx@@179)) bx@@179) ($Is ($Unbox refType bx@@179) Tclass.SplitRequestMod.__default)))
 :qid |unknown.0:0|
 :skolemid |6626|
 :pattern ( ($IsBox bx@@179 Tclass.SplitRequestMod.__default))
)))
(assert (forall (($o@@69 T@U) ) (!  (=> (= (type $o@@69) refType) (= ($Is $o@@69 Tclass.SplitRequestMod.__default)  (or (= $o@@69 null) (= (dtype $o@@69) Tclass.SplitRequestMod.__default))))
 :qid |unknown.0:0|
 :skolemid |6627|
 :pattern ( ($Is $o@@69 Tclass.SplitRequestMod.__default))
)))
(assert (forall (($o@@70 T@U) ($h@@132 T@U) ) (!  (=> (and (= (type $o@@70) refType) (= (type $h@@132) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@70 Tclass.SplitRequestMod.__default $h@@132)  (or (= $o@@70 null) (U_2_bool (MapType1Select (MapType0Select $h@@132 $o@@70) alloc)))))
 :qid |unknown.0:0|
 :skolemid |6628|
 :pattern ( ($IsAlloc $o@@70 Tclass.SplitRequestMod.__default $h@@132))
)))
(assert (forall ((arg0@@655 Int) (arg1@@342 T@U) (arg2@@172 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.QueryLabel| arg0@@655 arg1@@342 arg2@@172)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.QueryLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| arg0@@655 arg1@@342 arg2@@172))
)))
(assert (forall ((|a#14#0#0@@1| Int) (|a#14#1#0@@1| T@U) (|a#14#2#0@@0| T@U) ) (!  (=> (and (= (type |a#14#1#0@@1|) (SeqType BoxType)) (= (type |a#14#2#0@@0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.QueryLabel| |a#14#0#0@@1| |a#14#1#0@@1| |a#14#2#0@@0|)) |##PivotBetree.TransitionLabel.QueryLabel|))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6629|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#14#0#0@@1| |a#14#1#0@@1| |a#14#2#0@@0|))
)))
(assert (forall ((d@@98 T@U) ) (!  (=> (= (type d@@98) DatatypeTypeType) (= (PivotBetree.TransitionLabel.QueryLabel_q d@@98) (= (DatatypeCtorId d@@98) |##PivotBetree.TransitionLabel.QueryLabel|)))
 :qid |unknown.0:0|
 :skolemid |6630|
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@98))
)))
(assert (forall ((d@@99 T@U) ) (!  (=> (and (= (type d@@99) DatatypeTypeType) (PivotBetree.TransitionLabel.QueryLabel_q d@@99)) (exists ((|a#15#0#0@@1| Int) (|a#15#1#0@@1| T@U) (|a#15#2#0@@0| T@U) ) (!  (and (and (= (type |a#15#1#0@@1|) (SeqType BoxType)) (= (type |a#15#2#0@@0|) (SeqType BoxType))) (= d@@99 (|#PivotBetree.TransitionLabel.QueryLabel| |a#15#0#0@@1| |a#15#1#0@@1| |a#15#2#0@@0|)))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6631|
 :no-pattern (type |a#15#1#0@@1|)
 :no-pattern (type |a#15#2#0@@0|)
 :no-pattern (U_2_int |a#15#1#0@@1|)
 :no-pattern (U_2_bool |a#15#1#0@@1|)
 :no-pattern (U_2_int |a#15#2#0@@0|)
 :no-pattern (U_2_bool |a#15#2#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |6632|
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@99))
)))
(assert (forall ((|a#16#0#0@@1| Int) (|a#16#1#0@@1| T@U) (|a#16#2#0@@0| T@U) ) (!  (=> (and (= (type |a#16#1#0@@1|) (SeqType BoxType)) (= (type |a#16#2#0@@0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.TransitionLabel.QueryLabel| |a#16#0#0@@1| |a#16#1#0@@1| |a#16#2#0@@0|) Tclass.PivotBetree.TransitionLabel)  (and (and ($Is (int_2_U |a#16#0#0@@1|) Tclass._System.nat) ($Is |a#16#1#0@@1| Tclass.KeyType.Key)) ($Is |a#16#2#0@@0| Tclass.ValueType.Value))))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6633|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.QueryLabel| |a#16#0#0@@1| |a#16#1#0@@1| |a#16#2#0@@0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#17#0#0@@1| Int) (|a#17#1#0@@1| T@U) (|a#17#2#0@@0| T@U) ($h@@133 T@U) ) (!  (=> (and (and (and (= (type |a#17#1#0@@1|) (SeqType BoxType)) (= (type |a#17#2#0@@0|) (SeqType BoxType))) (= (type $h@@133) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@133)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.QueryLabel| |a#17#0#0@@1| |a#17#1#0@@1| |a#17#2#0@@0|) Tclass.PivotBetree.TransitionLabel $h@@133)  (and (and ($IsAlloc (int_2_U |a#17#0#0@@1|) Tclass._System.nat $h@@133) ($IsAlloc |a#17#1#0@@1| Tclass.KeyType.Key $h@@133)) ($IsAlloc |a#17#2#0@@0| Tclass.ValueType.Value $h@@133))))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6634|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.QueryLabel| |a#17#0#0@@1| |a#17#1#0@@1| |a#17#2#0@@0|) Tclass.PivotBetree.TransitionLabel $h@@133))
)))
(assert (forall ((d@@100 T@U) ($h@@134 T@U) ) (!  (=> (and (and (= (type d@@100) DatatypeTypeType) (= (type $h@@134) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@134) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@100) ($IsAlloc d@@100 Tclass.PivotBetree.TransitionLabel $h@@134)))) ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@100)) Tclass._System.nat $h@@134))
 :qid |unknown.0:0|
 :skolemid |6635|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@100)) Tclass._System.nat $h@@134))
)))
(assert (forall ((d@@101 T@U) ($h@@135 T@U) ) (!  (=> (and (and (= (type d@@101) DatatypeTypeType) (= (type $h@@135) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@135) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@101) ($IsAlloc d@@101 Tclass.PivotBetree.TransitionLabel $h@@135)))) ($IsAlloc (PivotBetree.TransitionLabel.key d@@101) Tclass.KeyType.Key $h@@135))
 :qid |unknown.0:0|
 :skolemid |6636|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.key d@@101) Tclass.KeyType.Key $h@@135))
)))
(assert (forall ((d@@102 T@U) ($h@@136 T@U) ) (!  (=> (and (and (= (type d@@102) DatatypeTypeType) (= (type $h@@136) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@136) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@102) ($IsAlloc d@@102 Tclass.PivotBetree.TransitionLabel $h@@136)))) ($IsAlloc (PivotBetree.TransitionLabel.value d@@102) Tclass.ValueType.Value $h@@136))
 :qid |unknown.0:0|
 :skolemid |6637|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.value d@@102) Tclass.ValueType.Value $h@@136))
)))
(assert (forall ((|a#18#0#0@@0| Int) (|a#18#1#0@@0| T@U) (|a#18#2#0| T@U) ) (!  (=> (and (= (type |a#18#1#0@@0|) (SeqType BoxType)) (= (type |a#18#2#0|) (SeqType BoxType))) (= (|#PivotBetree.TransitionLabel.QueryLabel| (LitInt |a#18#0#0@@0|) (Lit |a#18#1#0@@0|) (Lit |a#18#2#0|)) (Lit (|#PivotBetree.TransitionLabel.QueryLabel| |a#18#0#0@@0| |a#18#1#0@@0| |a#18#2#0|))))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6638|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| (LitInt |a#18#0#0@@0|) (Lit |a#18#1#0@@0|) (Lit |a#18#2#0|)))
)))
(assert (forall ((|a#19#0#0@@0| Int) (|a#19#1#0@@0| T@U) (|a#19#2#0| T@U) ) (!  (=> (and (= (type |a#19#1#0@@0|) (SeqType BoxType)) (= (type |a#19#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.endLsn (|#PivotBetree.TransitionLabel.QueryLabel| |a#19#0#0@@0| |a#19#1#0@@0| |a#19#2#0|)) |a#19#0#0@@0|))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6639|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#19#0#0@@0| |a#19#1#0@@0| |a#19#2#0|))
)))
(assert (forall ((|a#20#0#0@@0| Int) (|a#20#1#0@@0| T@U) (|a#20#2#0| T@U) ) (!  (=> (and (= (type |a#20#1#0@@0|) (SeqType BoxType)) (= (type |a#20#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.key (|#PivotBetree.TransitionLabel.QueryLabel| |a#20#0#0@@0| |a#20#1#0@@0| |a#20#2#0|)) |a#20#1#0@@0|))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6640|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#20#0#0@@0| |a#20#1#0@@0| |a#20#2#0|))
)))
(assert (forall ((|a#21#0#0@@0| Int) (|a#21#1#0@@0| T@U) (|a#21#2#0| T@U) ) (!  (=> (and (= (type |a#21#1#0@@0|) (SeqType BoxType)) (= (type |a#21#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.value (|#PivotBetree.TransitionLabel.QueryLabel| |a#21#0#0@@0| |a#21#1#0@@0| |a#21#2#0|)) |a#21#2#0|))
 :qid |PivotBetreeidfy.30:16|
 :skolemid |6641|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#21#0#0@@0| |a#21#1#0@@0| |a#21#2#0|))
)))
(assert (forall ((arg0@@656 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.PutLabel| arg0@@656)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.PutLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| arg0@@656))
)))
(assert (forall ((|a#22#0#0@@0| T@U) ) (!  (=> (= (type |a#22#0#0@@0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.PutLabel| |a#22#0#0@@0|)) |##PivotBetree.TransitionLabel.PutLabel|))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6642|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#22#0#0@@0|))
)))
(assert (forall ((d@@103 T@U) ) (!  (=> (= (type d@@103) DatatypeTypeType) (= (PivotBetree.TransitionLabel.PutLabel_q d@@103) (= (DatatypeCtorId d@@103) |##PivotBetree.TransitionLabel.PutLabel|)))
 :qid |unknown.0:0|
 :skolemid |6643|
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@103))
)))
(assert (forall ((d@@104 T@U) ) (!  (=> (and (= (type d@@104) DatatypeTypeType) (PivotBetree.TransitionLabel.PutLabel_q d@@104)) (exists ((|a#23#0#0| T@U) ) (!  (and (= (type |a#23#0#0|) DatatypeTypeType) (= d@@104 (|#PivotBetree.TransitionLabel.PutLabel| |a#23#0#0|)))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6644|
 :no-pattern (type |a#23#0#0|)
 :no-pattern (U_2_int |a#23#0#0|)
 :no-pattern (U_2_bool |a#23#0#0|)
)))
 :qid |unknown.0:0|
 :skolemid |6645|
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@104))
)))
(assert (forall ((|a#24#0#0| T@U) ) (!  (=> (= (type |a#24#0#0|) DatatypeTypeType) (= ($Is (|#PivotBetree.TransitionLabel.PutLabel| |a#24#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is |a#24#0#0| Tclass.MsgHistoryMod.MsgHistory)))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6646|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.PutLabel| |a#24#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#25#0#0| T@U) ($h@@137 T@U) ) (!  (=> (and (and (= (type |a#25#0#0|) DatatypeTypeType) (= (type $h@@137) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@137)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.PutLabel| |a#25#0#0|) Tclass.PivotBetree.TransitionLabel $h@@137) ($IsAlloc |a#25#0#0| Tclass.MsgHistoryMod.MsgHistory $h@@137)))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6647|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.PutLabel| |a#25#0#0|) Tclass.PivotBetree.TransitionLabel $h@@137))
)))
(assert (forall ((d@@105 T@U) ($h@@138 T@U) ) (!  (=> (and (and (= (type d@@105) DatatypeTypeType) (= (type $h@@138) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@138) (and (PivotBetree.TransitionLabel.PutLabel_q d@@105) ($IsAlloc d@@105 Tclass.PivotBetree.TransitionLabel $h@@138)))) ($IsAlloc (PivotBetree.TransitionLabel.puts d@@105) Tclass.MsgHistoryMod.MsgHistory $h@@138))
 :qid |unknown.0:0|
 :skolemid |6648|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.puts d@@105) Tclass.MsgHistoryMod.MsgHistory $h@@138))
)))
(assert (forall ((|a#26#0#0| T@U) ) (!  (=> (= (type |a#26#0#0|) DatatypeTypeType) (= (|#PivotBetree.TransitionLabel.PutLabel| (Lit |a#26#0#0|)) (Lit (|#PivotBetree.TransitionLabel.PutLabel| |a#26#0#0|))))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6649|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| (Lit |a#26#0#0|)))
)))
(assert (forall ((|a#27#0#0| T@U) ) (!  (=> (= (type |a#27#0#0|) DatatypeTypeType) (= (PivotBetree.TransitionLabel.puts (|#PivotBetree.TransitionLabel.PutLabel| |a#27#0#0|)) |a#27#0#0|))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6650|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#27#0#0|))
)))
(assert (forall ((|a#28#0#0| T@U) ) (!  (=> (= (type |a#28#0#0|) DatatypeTypeType) (< (DtRank |a#28#0#0|) (DtRank (|#PivotBetree.TransitionLabel.PutLabel| |a#28#0#0|))))
 :qid |PivotBetreeidfy.31:14|
 :skolemid |6651|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#28#0#0|))
)))
(assert (forall ((arg0@@657 Int) ) (! (= (type (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| arg0@@657)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.QueryEndLsnLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| arg0@@657))
)))
(assert (forall ((|a#29#0#0| Int) ) (! (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#29#0#0|)) |##PivotBetree.TransitionLabel.QueryEndLsnLabel|)
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6652|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#29#0#0|))
)))
(assert (forall ((d@@106 T@U) ) (!  (=> (= (type d@@106) DatatypeTypeType) (= (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@106) (= (DatatypeCtorId d@@106) |##PivotBetree.TransitionLabel.QueryEndLsnLabel|)))
 :qid |unknown.0:0|
 :skolemid |6653|
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@106))
)))
(assert (forall ((d@@107 T@U) ) (!  (=> (and (= (type d@@107) DatatypeTypeType) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@107)) (exists ((|a#30#0#0| Int) ) (! (= d@@107 (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#30#0#0|))
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6654|
)))
 :qid |unknown.0:0|
 :skolemid |6655|
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@107))
)))
(assert (forall ((|a#31#0#0| Int) ) (! (= ($Is (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#31#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is (int_2_U |a#31#0#0|) Tclass._System.nat))
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6656|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#31#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#32#0#0| Int) ($h@@139 T@U) ) (!  (=> (and (= (type $h@@139) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@139)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#32#0#0|) Tclass.PivotBetree.TransitionLabel $h@@139) ($IsAlloc (int_2_U |a#32#0#0|) Tclass._System.nat $h@@139)))
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6657|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#32#0#0|) Tclass.PivotBetree.TransitionLabel $h@@139))
)))
(assert (forall ((d@@108 T@U) ($h@@140 T@U) ) (!  (=> (and (and (= (type d@@108) DatatypeTypeType) (= (type $h@@140) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@140) (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@108) ($IsAlloc d@@108 Tclass.PivotBetree.TransitionLabel $h@@140)))) ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@108)) Tclass._System.nat $h@@140))
 :qid |unknown.0:0|
 :skolemid |6658|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@108)) Tclass._System.nat $h@@140))
)))
(assert (forall ((|a#33#0#0| Int) ) (! (= (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#33#0#0|)) (Lit (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#33#0#0|)))
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6659|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#33#0#0|)))
)))
(assert (forall ((|a#34#0#0| Int) ) (! (= (PivotBetree.TransitionLabel.endLsn (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#34#0#0|)) |a#34#0#0|)
 :qid |PivotBetreeidfy.32:22|
 :skolemid |6660|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#34#0#0|))
)))
(assert (forall ((arg0@@658 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.FreezeAsLabel| arg0@@658)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.FreezeAsLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| arg0@@658))
)))
(assert (forall ((|a#35#0#0| T@U) ) (!  (=> (= (type |a#35#0#0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#35#0#0|)) |##PivotBetree.TransitionLabel.FreezeAsLabel|))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6661|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#35#0#0|))
)))
(assert (forall ((d@@109 T@U) ) (!  (=> (= (type d@@109) DatatypeTypeType) (= (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@109) (= (DatatypeCtorId d@@109) |##PivotBetree.TransitionLabel.FreezeAsLabel|)))
 :qid |unknown.0:0|
 :skolemid |6662|
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@109))
)))
(assert (forall ((d@@110 T@U) ) (!  (=> (and (= (type d@@110) DatatypeTypeType) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@110)) (exists ((|a#36#0#0| T@U) ) (!  (and (= (type |a#36#0#0|) DatatypeTypeType) (= d@@110 (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#36#0#0|)))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6663|
 :no-pattern (type |a#36#0#0|)
 :no-pattern (U_2_int |a#36#0#0|)
 :no-pattern (U_2_bool |a#36#0#0|)
)))
 :qid |unknown.0:0|
 :skolemid |6664|
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@110))
)))
(assert (forall ((|a#37#0#0| T@U) ) (!  (=> (= (type |a#37#0#0|) DatatypeTypeType) (= ($Is (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#37#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is |a#37#0#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6665|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#37#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#38#0#0| T@U) ($h@@141 T@U) ) (!  (=> (and (and (= (type |a#38#0#0|) DatatypeTypeType) (= (type $h@@141) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@141)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#38#0#0|) Tclass.PivotBetree.TransitionLabel $h@@141) ($IsAlloc |a#38#0#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@141)))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6666|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#38#0#0|) Tclass.PivotBetree.TransitionLabel $h@@141))
)))
(assert (forall ((d@@111 T@U) ($h@@142 T@U) ) (!  (=> (and (and (= (type d@@111) DatatypeTypeType) (= (type $h@@142) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@142) (and (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@111) ($IsAlloc d@@111 Tclass.PivotBetree.TransitionLabel $h@@142)))) ($IsAlloc (PivotBetree.TransitionLabel.stampedBetree d@@111) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@142))
 :qid |unknown.0:0|
 :skolemid |6667|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.stampedBetree d@@111) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@142))
)))
(assert (forall ((|a#39#0#0| T@U) ) (!  (=> (= (type |a#39#0#0|) DatatypeTypeType) (= (|#PivotBetree.TransitionLabel.FreezeAsLabel| (Lit |a#39#0#0|)) (Lit (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#39#0#0|))))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6668|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| (Lit |a#39#0#0|)))
)))
(assert (forall ((|a#40#0#0| T@U) ) (!  (=> (= (type |a#40#0#0|) DatatypeTypeType) (= (PivotBetree.TransitionLabel.stampedBetree (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#40#0#0|)) |a#40#0#0|))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6669|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#40#0#0|))
)))
(assert (forall ((|a#41#0#0| T@U) ) (!  (=> (= (type |a#41#0#0|) DatatypeTypeType) (< (DtRank |a#41#0#0|) (DtRank (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#41#0#0|))))
 :qid |PivotBetreeidfy.33:19|
 :skolemid |6670|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#41#0#0|))
)))
(assert (= (type |#PivotBetree.TransitionLabel.InternalLabel|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.TransitionLabel.InternalLabel|) |##PivotBetree.TransitionLabel.InternalLabel|))
(assert (forall ((d@@112 T@U) ) (!  (=> (= (type d@@112) DatatypeTypeType) (= (PivotBetree.TransitionLabel.InternalLabel_q d@@112) (= (DatatypeCtorId d@@112) |##PivotBetree.TransitionLabel.InternalLabel|)))
 :qid |unknown.0:0|
 :skolemid |6671|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@112))
)))
(assert (forall ((d@@113 T@U) ) (!  (=> (and (= (type d@@113) DatatypeTypeType) (PivotBetree.TransitionLabel.InternalLabel_q d@@113)) (= d@@113 |#PivotBetree.TransitionLabel.InternalLabel|))
 :qid |unknown.0:0|
 :skolemid |6672|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@113))
)))
(assert ($Is |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel))
(assert (forall (($h@@143 T@U) ) (!  (=> (and (= (type $h@@143) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@143)) ($IsAlloc |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel $h@@143))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |6673|
 :pattern ( ($IsAlloc |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel $h@@143))
)))
(assert (= |#PivotBetree.TransitionLabel.InternalLabel| (Lit |#PivotBetree.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@114 T@U) ) (!  (=> (and (= (type d@@114) DatatypeTypeType) (|$IsA#PivotBetree.TransitionLabel| d@@114)) (or (or (or (or (PivotBetree.TransitionLabel.QueryLabel_q d@@114) (PivotBetree.TransitionLabel.PutLabel_q d@@114)) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@114)) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@114)) (PivotBetree.TransitionLabel.InternalLabel_q d@@114)))
 :qid |unknown.0:0|
 :skolemid |6674|
 :pattern ( (|$IsA#PivotBetree.TransitionLabel| d@@114))
)))
(assert (forall ((d@@115 T@U) ) (!  (=> (and (= (type d@@115) DatatypeTypeType) ($Is d@@115 Tclass.PivotBetree.TransitionLabel)) (or (or (or (or (PivotBetree.TransitionLabel.QueryLabel_q d@@115) (PivotBetree.TransitionLabel.PutLabel_q d@@115)) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@115)) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@115)) (PivotBetree.TransitionLabel.InternalLabel_q d@@115)))
 :qid |unknown.0:0|
 :skolemid |6675|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@115) ($Is d@@115 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@115) ($Is d@@115 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@115) ($Is d@@115 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@115) ($Is d@@115 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@115) ($Is d@@115 Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((a@@148 T@U) (b@@97 T@U) ) (!  (=> (and (and (= (type a@@148) DatatypeTypeType) (= (type b@@97) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.QueryLabel_q a@@148) (PivotBetree.TransitionLabel.QueryLabel_q b@@97))) (= (|PivotBetree.TransitionLabel#Equal| a@@148 b@@97)  (and (and (= (PivotBetree.TransitionLabel.endLsn a@@148) (PivotBetree.TransitionLabel.endLsn b@@97)) (|Seq#Equal| (PivotBetree.TransitionLabel.key a@@148) (PivotBetree.TransitionLabel.key b@@97))) (|Seq#Equal| (PivotBetree.TransitionLabel.value a@@148) (PivotBetree.TransitionLabel.value b@@97)))))
 :qid |unknown.0:0|
 :skolemid |6676|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@148 b@@97) (PivotBetree.TransitionLabel.QueryLabel_q a@@148))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@148 b@@97) (PivotBetree.TransitionLabel.QueryLabel_q b@@97))
)))
(assert (forall ((a@@149 T@U) (b@@98 T@U) ) (!  (=> (and (and (= (type a@@149) DatatypeTypeType) (= (type b@@98) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.PutLabel_q a@@149) (PivotBetree.TransitionLabel.PutLabel_q b@@98))) (= (|PivotBetree.TransitionLabel#Equal| a@@149 b@@98) (|MsgHistoryMod.MsgHistory#Equal| (PivotBetree.TransitionLabel.puts a@@149) (PivotBetree.TransitionLabel.puts b@@98))))
 :qid |unknown.0:0|
 :skolemid |6677|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@149 b@@98) (PivotBetree.TransitionLabel.PutLabel_q a@@149))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@149 b@@98) (PivotBetree.TransitionLabel.PutLabel_q b@@98))
)))
(assert (forall ((a@@150 T@U) (b@@99 T@U) ) (!  (=> (and (and (= (type a@@150) DatatypeTypeType) (= (type b@@99) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q a@@150) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q b@@99))) (= (|PivotBetree.TransitionLabel#Equal| a@@150 b@@99) (= (PivotBetree.TransitionLabel.endLsn a@@150) (PivotBetree.TransitionLabel.endLsn b@@99))))
 :qid |unknown.0:0|
 :skolemid |6678|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@150 b@@99) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q a@@150))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@150 b@@99) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q b@@99))
)))
(assert (forall ((a@@151 T@U) (b@@100 T@U) ) (!  (=> (and (and (= (type a@@151) DatatypeTypeType) (= (type b@@100) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.FreezeAsLabel_q a@@151) (PivotBetree.TransitionLabel.FreezeAsLabel_q b@@100))) (= (|PivotBetree.TransitionLabel#Equal| a@@151 b@@100) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree a@@151) (PivotBetree.TransitionLabel.stampedBetree b@@100))))
 :qid |unknown.0:0|
 :skolemid |6679|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@151 b@@100) (PivotBetree.TransitionLabel.FreezeAsLabel_q a@@151))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@151 b@@100) (PivotBetree.TransitionLabel.FreezeAsLabel_q b@@100))
)))
(assert (forall ((a@@152 T@U) (b@@101 T@U) ) (!  (=> (and (and (= (type a@@152) DatatypeTypeType) (= (type b@@101) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.InternalLabel_q a@@152) (PivotBetree.TransitionLabel.InternalLabel_q b@@101))) (= (|PivotBetree.TransitionLabel#Equal| a@@152 b@@101) true))
 :qid |unknown.0:0|
 :skolemid |6680|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@152 b@@101) (PivotBetree.TransitionLabel.InternalLabel_q a@@152))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@152 b@@101) (PivotBetree.TransitionLabel.InternalLabel_q b@@101))
)))
(assert (forall ((a@@153 T@U) (b@@102 T@U) ) (!  (=> (and (= (type a@@153) DatatypeTypeType) (= (type b@@102) DatatypeTypeType)) (= (|PivotBetree.TransitionLabel#Equal| a@@153 b@@102) (= a@@153 b@@102)))
 :qid |unknown.0:0|
 :skolemid |6681|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@153 b@@102))
)))
(assert (= (type |#PivotBetree.BetreeNode.Nil|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.BetreeNode.Nil|) |##PivotBetree.BetreeNode.Nil|))
(assert (forall ((d@@116 T@U) ) (!  (=> (= (type d@@116) DatatypeTypeType) (= (PivotBetree.BetreeNode.Nil_q d@@116) (= (DatatypeCtorId d@@116) |##PivotBetree.BetreeNode.Nil|)))
 :qid |unknown.0:0|
 :skolemid |6682|
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@116))
)))
(assert (forall ((d@@117 T@U) ) (!  (=> (and (= (type d@@117) DatatypeTypeType) (PivotBetree.BetreeNode.Nil_q d@@117)) (= d@@117 |#PivotBetree.BetreeNode.Nil|))
 :qid |unknown.0:0|
 :skolemid |6683|
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@117))
)))
(assert ($Is |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode))
(assert (forall (($h@@144 T@U) ) (!  (=> (and (= (type $h@@144) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@144)) ($IsAlloc |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode $h@@144))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |6684|
 :pattern ( ($IsAlloc |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode $h@@144))
)))
(assert (= |#PivotBetree.BetreeNode.Nil| (Lit |#PivotBetree.BetreeNode.Nil|)))
(assert (forall ((arg0@@659 T@U) (arg1@@343 T@U) (arg2@@173 T@U) ) (! (= (type (|#PivotBetree.BetreeNode.BetreeNode| arg0@@659 arg1@@343 arg2@@173)) DatatypeTypeType)
 :qid |funType:#PivotBetree.BetreeNode.BetreeNode|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| arg0@@659 arg1@@343 arg2@@173))
)))
(assert (forall ((|a#52#0#0| T@U) (|a#52#1#0| T@U) (|a#52#2#0| T@U) ) (!  (=> (and (and (= (type |a#52#0#0|) DatatypeTypeType) (= (type |a#52#1#0|) (SeqType BoxType))) (= (type |a#52#2#0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.BetreeNode.BetreeNode| |a#52#0#0| |a#52#1#0| |a#52#2#0|)) |##PivotBetree.BetreeNode.BetreeNode|))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6685|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#52#0#0| |a#52#1#0| |a#52#2#0|))
)))
(assert (forall ((d@@118 T@U) ) (!  (=> (= (type d@@118) DatatypeTypeType) (= (PivotBetree.BetreeNode.BetreeNode_q d@@118) (= (DatatypeCtorId d@@118) |##PivotBetree.BetreeNode.BetreeNode|)))
 :qid |unknown.0:0|
 :skolemid |6686|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@118))
)))
(assert (forall ((d@@119 T@U) ) (!  (=> (and (= (type d@@119) DatatypeTypeType) (PivotBetree.BetreeNode.BetreeNode_q d@@119)) (exists ((|a#53#0#0| T@U) (|a#53#1#0| T@U) (|a#53#2#0| T@U) ) (!  (and (and (and (= (type |a#53#0#0|) DatatypeTypeType) (= (type |a#53#1#0|) (SeqType BoxType))) (= (type |a#53#2#0|) (SeqType BoxType))) (= d@@119 (|#PivotBetree.BetreeNode.BetreeNode| |a#53#0#0| |a#53#1#0| |a#53#2#0|)))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6687|
 :no-pattern (type |a#53#0#0|)
 :no-pattern (type |a#53#1#0|)
 :no-pattern (type |a#53#2#0|)
 :no-pattern (U_2_int |a#53#0#0|)
 :no-pattern (U_2_bool |a#53#0#0|)
 :no-pattern (U_2_int |a#53#1#0|)
 :no-pattern (U_2_bool |a#53#1#0|)
 :no-pattern (U_2_int |a#53#2#0|)
 :no-pattern (U_2_bool |a#53#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |6688|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@119))
)))
(assert (forall ((|a#54#0#0| T@U) (|a#54#1#0| T@U) (|a#54#2#0| T@U) ) (!  (=> (and (and (= (type |a#54#0#0|) DatatypeTypeType) (= (type |a#54#1#0|) (SeqType BoxType))) (= (type |a#54#2#0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.BetreeNode.BetreeNode| |a#54#0#0| |a#54#1#0| |a#54#2#0|) Tclass.PivotBetree.BetreeNode)  (and (and ($Is |a#54#0#0| Tclass.Buffers.BufferStack) ($Is |a#54#1#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |a#54#2#0| (TSeq Tclass.PivotBetree.BetreeNode)))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6689|
 :pattern ( ($Is (|#PivotBetree.BetreeNode.BetreeNode| |a#54#0#0| |a#54#1#0| |a#54#2#0|) Tclass.PivotBetree.BetreeNode))
)))
(assert (forall ((|a#55#0#0| T@U) (|a#55#1#0| T@U) (|a#55#2#0| T@U) ($h@@145 T@U) ) (!  (=> (and (and (and (and (= (type |a#55#0#0|) DatatypeTypeType) (= (type |a#55#1#0|) (SeqType BoxType))) (= (type |a#55#2#0|) (SeqType BoxType))) (= (type $h@@145) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@145)) (= ($IsAlloc (|#PivotBetree.BetreeNode.BetreeNode| |a#55#0#0| |a#55#1#0| |a#55#2#0|) Tclass.PivotBetree.BetreeNode $h@@145)  (and (and ($IsAlloc |a#55#0#0| Tclass.Buffers.BufferStack $h@@145) ($IsAlloc |a#55#1#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@145)) ($IsAlloc |a#55#2#0| (TSeq Tclass.PivotBetree.BetreeNode) $h@@145))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6690|
 :pattern ( ($IsAlloc (|#PivotBetree.BetreeNode.BetreeNode| |a#55#0#0| |a#55#1#0| |a#55#2#0|) Tclass.PivotBetree.BetreeNode $h@@145))
)))
(assert (forall ((d@@120 T@U) ($h@@146 T@U) ) (!  (=> (and (and (= (type d@@120) DatatypeTypeType) (= (type $h@@146) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@146) (and (PivotBetree.BetreeNode.BetreeNode_q d@@120) ($IsAlloc d@@120 Tclass.PivotBetree.BetreeNode $h@@146)))) ($IsAlloc (PivotBetree.BetreeNode.buffers d@@120) Tclass.Buffers.BufferStack $h@@146))
 :qid |unknown.0:0|
 :skolemid |6691|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.buffers d@@120) Tclass.Buffers.BufferStack $h@@146))
)))
(assert (forall ((d@@121 T@U) ($h@@147 T@U) ) (!  (=> (and (and (= (type d@@121) DatatypeTypeType) (= (type $h@@147) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@147) (and (PivotBetree.BetreeNode.BetreeNode_q d@@121) ($IsAlloc d@@121 Tclass.PivotBetree.BetreeNode $h@@147)))) ($IsAlloc (PivotBetree.BetreeNode.pivotTable d@@121) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@147))
 :qid |unknown.0:0|
 :skolemid |6692|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.pivotTable d@@121) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@147))
)))
(assert (forall ((d@@122 T@U) ($h@@148 T@U) ) (!  (=> (and (and (= (type d@@122) DatatypeTypeType) (= (type $h@@148) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@148) (and (PivotBetree.BetreeNode.BetreeNode_q d@@122) ($IsAlloc d@@122 Tclass.PivotBetree.BetreeNode $h@@148)))) ($IsAlloc (PivotBetree.BetreeNode.children d@@122) (TSeq Tclass.PivotBetree.BetreeNode) $h@@148))
 :qid |unknown.0:0|
 :skolemid |6693|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.children d@@122) (TSeq Tclass.PivotBetree.BetreeNode) $h@@148))
)))
(assert (forall ((|a#56#0#0| T@U) (|a#56#1#0| T@U) (|a#56#2#0| T@U) ) (!  (=> (and (and (= (type |a#56#0#0|) DatatypeTypeType) (= (type |a#56#1#0|) (SeqType BoxType))) (= (type |a#56#2#0|) (SeqType BoxType))) (= (|#PivotBetree.BetreeNode.BetreeNode| (Lit |a#56#0#0|) (Lit |a#56#1#0|) (Lit |a#56#2#0|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| |a#56#0#0| |a#56#1#0| |a#56#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6694|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| (Lit |a#56#0#0|) (Lit |a#56#1#0|) (Lit |a#56#2#0|)))
)))
(assert (forall ((|a#57#0#0| T@U) (|a#57#1#0| T@U) (|a#57#2#0| T@U) ) (!  (=> (and (and (= (type |a#57#0#0|) DatatypeTypeType) (= (type |a#57#1#0|) (SeqType BoxType))) (= (type |a#57#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.buffers (|#PivotBetree.BetreeNode.BetreeNode| |a#57#0#0| |a#57#1#0| |a#57#2#0|)) |a#57#0#0|))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6695|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#57#0#0| |a#57#1#0| |a#57#2#0|))
)))
(assert (forall ((|a#58#0#0| T@U) (|a#58#1#0| T@U) (|a#58#2#0| T@U) ) (!  (=> (and (and (= (type |a#58#0#0|) DatatypeTypeType) (= (type |a#58#1#0|) (SeqType BoxType))) (= (type |a#58#2#0|) (SeqType BoxType))) (< (DtRank |a#58#0#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#58#0#0| |a#58#1#0| |a#58#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6696|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#58#0#0| |a#58#1#0| |a#58#2#0|))
)))
(assert (forall ((|a#59#0#0| T@U) (|a#59#1#0| T@U) (|a#59#2#0| T@U) ) (!  (=> (and (and (= (type |a#59#0#0|) DatatypeTypeType) (= (type |a#59#1#0|) (SeqType BoxType))) (= (type |a#59#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.pivotTable (|#PivotBetree.BetreeNode.BetreeNode| |a#59#0#0| |a#59#1#0| |a#59#2#0|)) |a#59#1#0|))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6697|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#59#0#0| |a#59#1#0| |a#59#2#0|))
)))
(assert (forall ((|a#60#0#0| T@U) (|a#60#1#0| T@U) (|a#60#2#0| T@U) (i@@27 Int) ) (!  (=> (and (and (and (= (type |a#60#0#0|) DatatypeTypeType) (= (type |a#60#1#0|) (SeqType BoxType))) (= (type |a#60#2#0|) (SeqType BoxType))) (and (<= 0 i@@27) (< i@@27 (|Seq#Length| |a#60#1#0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#60#1#0| i@@27))) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#60#0#0| |a#60#1#0| |a#60#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6698|
 :pattern ( (|Seq#Index| |a#60#1#0| i@@27) (|#PivotBetree.BetreeNode.BetreeNode| |a#60#0#0| |a#60#1#0| |a#60#2#0|))
)))
(assert (forall ((|a#61#0#0| T@U) (|a#61#1#0| T@U) (|a#61#2#0| T@U) ) (!  (=> (and (and (= (type |a#61#0#0|) DatatypeTypeType) (= (type |a#61#1#0|) (SeqType BoxType))) (= (type |a#61#2#0|) (SeqType BoxType))) (< (|Seq#Rank| |a#61#1#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#61#0#0| |a#61#1#0| |a#61#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6699|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#61#0#0| |a#61#1#0| |a#61#2#0|))
)))
(assert (forall ((|a#62#0#0| T@U) (|a#62#1#0| T@U) (|a#62#2#0| T@U) ) (!  (=> (and (and (= (type |a#62#0#0|) DatatypeTypeType) (= (type |a#62#1#0|) (SeqType BoxType))) (= (type |a#62#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.children (|#PivotBetree.BetreeNode.BetreeNode| |a#62#0#0| |a#62#1#0| |a#62#2#0|)) |a#62#2#0|))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6700|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#62#0#0| |a#62#1#0| |a#62#2#0|))
)))
(assert (forall ((|a#63#0#0| T@U) (|a#63#1#0| T@U) (|a#63#2#0| T@U) (i@@28 Int) ) (!  (=> (and (and (and (= (type |a#63#0#0|) DatatypeTypeType) (= (type |a#63#1#0|) (SeqType BoxType))) (= (type |a#63#2#0|) (SeqType BoxType))) (and (<= 0 i@@28) (< i@@28 (|Seq#Length| |a#63#2#0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#63#2#0| i@@28))) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#63#0#0| |a#63#1#0| |a#63#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6701|
 :pattern ( (|Seq#Index| |a#63#2#0| i@@28) (|#PivotBetree.BetreeNode.BetreeNode| |a#63#0#0| |a#63#1#0| |a#63#2#0|))
)))
(assert (forall ((|a#64#0#0| T@U) (|a#64#1#0| T@U) (|a#64#2#0| T@U) ) (!  (=> (and (and (= (type |a#64#0#0|) DatatypeTypeType) (= (type |a#64#1#0|) (SeqType BoxType))) (= (type |a#64#2#0|) (SeqType BoxType))) (< (|Seq#Rank| |a#64#2#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#64#0#0| |a#64#1#0| |a#64#2#0|))))
 :qid |PivotBetreeidfy.44:5|
 :skolemid |6702|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#64#0#0| |a#64#1#0| |a#64#2#0|))
)))
(assert (forall ((d@@123 T@U) ) (!  (=> (and (= (type d@@123) DatatypeTypeType) (|$IsA#PivotBetree.BetreeNode| d@@123)) (or (PivotBetree.BetreeNode.Nil_q d@@123) (PivotBetree.BetreeNode.BetreeNode_q d@@123)))
 :qid |unknown.0:0|
 :skolemid |6703|
 :pattern ( (|$IsA#PivotBetree.BetreeNode| d@@123))
)))
(assert (forall ((d@@124 T@U) ) (!  (=> (and (= (type d@@124) DatatypeTypeType) ($Is d@@124 Tclass.PivotBetree.BetreeNode)) (or (PivotBetree.BetreeNode.Nil_q d@@124) (PivotBetree.BetreeNode.BetreeNode_q d@@124)))
 :qid |unknown.0:0|
 :skolemid |6704|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@124) ($Is d@@124 Tclass.PivotBetree.BetreeNode))
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@124) ($Is d@@124 Tclass.PivotBetree.BetreeNode))
)))
(assert (forall ((a@@154 T@U) (b@@103 T@U) ) (!  (=> (and (and (= (type a@@154) DatatypeTypeType) (= (type b@@103) DatatypeTypeType)) (and (PivotBetree.BetreeNode.Nil_q a@@154) (PivotBetree.BetreeNode.Nil_q b@@103))) (= (|PivotBetree.BetreeNode#Equal| a@@154 b@@103) true))
 :qid |unknown.0:0|
 :skolemid |6705|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@154 b@@103) (PivotBetree.BetreeNode.Nil_q a@@154))
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@154 b@@103) (PivotBetree.BetreeNode.Nil_q b@@103))
)))
(assert (forall ((a@@155 T@U) (b@@104 T@U) ) (!  (=> (and (and (= (type a@@155) DatatypeTypeType) (= (type b@@104) DatatypeTypeType)) (and (PivotBetree.BetreeNode.BetreeNode_q a@@155) (PivotBetree.BetreeNode.BetreeNode_q b@@104))) (= (|PivotBetree.BetreeNode#Equal| a@@155 b@@104)  (and (and (|Buffers.BufferStack#Equal| (PivotBetree.BetreeNode.buffers a@@155) (PivotBetree.BetreeNode.buffers b@@104)) (|Seq#Equal| (PivotBetree.BetreeNode.pivotTable a@@155) (PivotBetree.BetreeNode.pivotTable b@@104))) (|Seq#Equal| (PivotBetree.BetreeNode.children a@@155) (PivotBetree.BetreeNode.children b@@104)))))
 :qid |unknown.0:0|
 :skolemid |6706|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@155 b@@104) (PivotBetree.BetreeNode.BetreeNode_q a@@155))
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@155 b@@104) (PivotBetree.BetreeNode.BetreeNode_q b@@104))
)))
(assert (forall ((a@@156 T@U) (b@@105 T@U) ) (!  (=> (and (= (type a@@156) DatatypeTypeType) (= (type b@@105) DatatypeTypeType)) (= (|PivotBetree.BetreeNode#Equal| a@@156 b@@105) (= a@@156 b@@105)))
 :qid |unknown.0:0|
 :skolemid |6707|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@156 b@@105))
)))
(assert  (=> true (forall ((this@@141 T@U) ) (!  (=> (and (= (type this@@141) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| this@@141) ($Is this@@141 Tclass.PivotBetree.BetreeNode))) true)
 :qid |PivotBetreeidfy.48:15|
 :skolemid |6708|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure this@@141))
))))
(assert (forall ((this@@142 T@U) ) (!  (=> (and (= (type this@@142) DatatypeTypeType) ($Is this@@142 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.LocalStructure#requires| this@@142) true))
 :qid |PivotBetreeidfy.48:15|
 :skolemid |6709|
 :pattern ( (|PivotBetree.BetreeNode.LocalStructure#requires| this@@142))
)))
(assert  (=> true (forall ((this@@143 T@U) ) (!  (=> (and (= (type this@@143) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| this@@143) ($Is this@@143 Tclass.PivotBetree.BetreeNode))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@143) (and (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable this@@143)) (=> (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable this@@143)) (|BoundedPivotsLib.__default.NumBuckets#canCall| (PivotBetree.BetreeNode.pivotTable this@@143)))))) (= (PivotBetree.BetreeNode.LocalStructure this@@143)  (and true (=> (PivotBetree.BetreeNode.BetreeNode_q this@@143) (and (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable this@@143)) (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@143)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable this@@143)))))))))
 :qid |PivotBetreeidfy.48:15|
 :skolemid |6710|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure this@@143))
))))
(assert  (=> true (forall ((this@@144 T@U) ) (!  (=> (and (= (type this@@144) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| (Lit this@@144)) ($Is this@@144 Tclass.PivotBetree.BetreeNode))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@144))))) (and (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@144)))) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@144))))))) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@144)))))))) (= (PivotBetree.BetreeNode.LocalStructure (Lit this@@144))  (and true (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@144)) (and (BoundedPivotsLib.__default.WFPivots (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@144)))) (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@144)))) (LitInt (BoundedPivotsLib.__default.NumBuckets (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@144))))))))))))
 :qid |PivotBetreeidfy.48:15|
 :weight 3
 :skolemid |6711|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure (Lit this@@144)))
))))
(assert  (=> true (forall ((this@@145 T@U) (|childIdx#0@@0| Int) ) (!  (=> (and (= (type this@@145) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@145 |childIdx#0@@0|) (and ($Is this@@145 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@0|)))) true)
 :qid |PivotBetreeidfy.56:15|
 :skolemid |6712|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@145 |childIdx#0@@0|))
))))
(assert (forall ((this@@146 T@U) (|childIdx#0@@1| Int) ) (!  (=> (= (type this@@146) DatatypeTypeType) (=> (and ($Is this@@146 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@1|)) (= (|PivotBetree.BetreeNode.ValidChildIndex#requires| this@@146 |childIdx#0@@1|) true)))
 :qid |PivotBetreeidfy.56:15|
 :skolemid |6713|
 :pattern ( (|PivotBetree.BetreeNode.ValidChildIndex#requires| this@@146 |childIdx#0@@1|))
)))
(assert  (=> true (forall ((this@@147 T@U) (|childIdx#0@@2| Int) ) (!  (=> (and (= (type this@@147) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@147 |childIdx#0@@2|) (and ($Is this@@147 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@2|)))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@147) (|BoundedPivotsLib.__default.NumBuckets#canCall| (PivotBetree.BetreeNode.pivotTable this@@147))) (= (PivotBetree.BetreeNode.ValidChildIndex this@@147 |childIdx#0@@2|)  (and (PivotBetree.BetreeNode.BetreeNode_q this@@147) (INTERNAL_lt_boogie |childIdx#0@@2| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable this@@147)))))))
 :qid |PivotBetreeidfy.56:15|
 :skolemid |6714|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@147 |childIdx#0@@2|))
))))
(assert  (=> true (forall ((this@@148 T@U) (|childIdx#0@@3| Int) ) (!  (=> (and (= (type this@@148) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@148) (LitInt |childIdx#0@@3|)) (and ($Is this@@148 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@3|)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@148))))) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@148))))) (= (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@148) (LitInt |childIdx#0@@3|)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@148)) (INTERNAL_lt_boogie |childIdx#0@@3| (BoundedPivotsLib.__default.NumBuckets (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@148))))))))))))
 :qid |PivotBetreeidfy.56:15|
 :weight 3
 :skolemid |6715|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@148) (LitInt |childIdx#0@@3|)))
))))
(assert  (=> true (forall ((this@@149 T@U) ) (!  (=> (and (= (type this@@149) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@149) (and ($Is this@@149 Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.LocalStructure this@@149)))) true)
 :qid |PivotBetreeidfy.62:15|
 :skolemid |6716|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren this@@149))
))))
(assert (forall ((this@@150 T@U) ) (!  (=> (and (= (type this@@150) DatatypeTypeType) ($Is this@@150 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.LinkedChildren#requires| this@@150) (PivotBetree.BetreeNode.LocalStructure this@@150)))
 :qid |PivotBetreeidfy.62:15|
 :skolemid |6717|
 :pattern ( (|PivotBetree.BetreeNode.LinkedChildren#requires| this@@150))
)))
(assert  (=> true (forall ((this@@151 T@U) ) (!  (=> (and (= (type this@@151) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@151) (and ($Is this@@151 Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.LocalStructure this@@151)))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@151) (forall ((|i#0@@152| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@152|) (and (and (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@151 |i#0@@152|) (=> (PivotBetree.BetreeNode.ValidChildIndex this@@151 |i#0@@152|) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|))) (|PivotBetree.BetreeNode.LocalStructure#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|)))))) (=> (and (and (PivotBetree.BetreeNode.ValidChildIndex this@@151 |i#0@@152|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|)))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.DomainRoutedToChild this@@151 |i#0@@152|))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@151 |i#0@@152|))))))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |6719|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@151 |i#0@@152|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@152|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@151 |i#0@@152|))
))) (= (PivotBetree.BetreeNode.LinkedChildren this@@151)  (=> (PivotBetree.BetreeNode.BetreeNode_q this@@151) (forall ((|i#0@@153| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@153|) (and (and (PivotBetree.BetreeNode.ValidChildIndex this@@151 |i#0@@153|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@153|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@153|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@153|))) (PivotBetree.BetreeNode.DomainRoutedToChild this@@151 |i#0@@153|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |6718|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@151 |i#0@@153|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@151) |i#0@@153|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@151 |i#0@@153|))
))))))
 :qid |PivotBetreeidfy.62:15|
 :skolemid |6720|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren this@@151))
))))
(assert  (=> true (forall ((this@@152 T@U) ) (!  (=> (and (= (type this@@152) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| (Lit this@@152)) (and ($Is this@@152 Tclass.PivotBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@152)))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@152))))) (forall ((|i#1@@60| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@60|) (and (and (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@152) |i#1@@60|) (=> (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@152) |i#1@@60|) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|))) (|PivotBetree.BetreeNode.LocalStructure#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|)))))) (=> (and (and (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@152) |i#1@@60|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|)))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@152) |i#1@@60|))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@60|))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@152) |i#1@@60|))))))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |6722|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@152 |i#1@@60|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@152) |i#1@@60|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@152 |i#1@@60|))
))) (= (PivotBetree.BetreeNode.LinkedChildren (Lit this@@152))  (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@152)) (forall ((|i#1@@61| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@61|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@152) |i#1@@61|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@61|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@61|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@152))) |i#1@@61|))) (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@152) |i#1@@61|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |6721|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@152 |i#1@@61|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@152) |i#1@@61|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@152 |i#1@@61|))
))))))
 :qid |PivotBetreeidfy.62:15|
 :weight 3
 :skolemid |6723|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren (Lit this@@152)))
))))
(assert (forall (($ly@@707 T@U) (this@@153 T@U) ) (!  (=> (and (= (type $ly@@707) LayerTypeType) (= (type this@@153) DatatypeTypeType)) (= (PivotBetree.BetreeNode.WF ($LS $ly@@707) this@@153) (PivotBetree.BetreeNode.WF $ly@@707 this@@153)))
 :qid |PivotBetreeidfy.73:15|
 :skolemid |6724|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly@@707) this@@153))
)))
(assert (forall (($ly@@708 T@U) (this@@154 T@U) ) (!  (=> (and (= (type $ly@@708) LayerTypeType) (= (type this@@154) DatatypeTypeType)) (= (PivotBetree.BetreeNode.WF $ly@@708 this@@154) (PivotBetree.BetreeNode.WF $LZ this@@154)))
 :qid |PivotBetreeidfy.73:15|
 :skolemid |6725|
 :pattern ( (PivotBetree.BetreeNode.WF (AsFuelBottom $ly@@708) this@@154))
)))
(assert  (=> true (forall (($ly@@709 T@U) (this@@155 T@U) ) (!  (=> (and (and (= (type $ly@@709) LayerTypeType) (= (type this@@155) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| this@@155) ($Is this@@155 Tclass.PivotBetree.BetreeNode))) true)
 :qid |PivotBetreeidfy.73:15|
 :skolemid |6726|
 :pattern ( (PivotBetree.BetreeNode.WF $ly@@709 this@@155))
))))
(assert (forall (($ly@@710 T@U) (this@@156 T@U) ) (!  (=> (and (and (= (type $ly@@710) LayerTypeType) (= (type this@@156) DatatypeTypeType)) ($Is this@@156 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.WF#requires| $ly@@710 this@@156) true))
 :qid |PivotBetreeidfy.73:15|
 :skolemid |6727|
 :pattern ( (|PivotBetree.BetreeNode.WF#requires| $ly@@710 this@@156))
)))
(assert  (=> true (forall (($ly@@711 T@U) (this@@157 T@U) ) (!  (=> (and (and (= (type $ly@@711) LayerTypeType) (= (type this@@157) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| this@@157) ($Is this@@157 Tclass.PivotBetree.BetreeNode))) (and (and (|PivotBetree.BetreeNode.LocalStructure#canCall| this@@157) (=> (PivotBetree.BetreeNode.LocalStructure this@@157) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@157) (and (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children this@@157)) (=> (PivotBetree.__default.WFChildren $ly@@711 (PivotBetree.BetreeNode.children this@@157)) (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@157)))))) (= (PivotBetree.BetreeNode.WF ($LS $ly@@711) this@@157)  (and (PivotBetree.BetreeNode.LocalStructure this@@157) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@157) (and (PivotBetree.__default.WFChildren $ly@@711 (PivotBetree.BetreeNode.children this@@157)) (PivotBetree.BetreeNode.LinkedChildren this@@157)))))))
 :qid |PivotBetreeidfy.73:15|
 :skolemid |6728|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly@@711) this@@157))
))))
(assert  (=> true (forall (($ly@@712 T@U) (this@@158 T@U) ) (!  (=> (and (and (= (type $ly@@712) LayerTypeType) (= (type this@@158) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@158)) ($Is this@@158 Tclass.PivotBetree.BetreeNode))) (and (and (|PivotBetree.BetreeNode.LocalStructure#canCall| (Lit this@@158)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@158))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@158))))) (and (|PivotBetree.__default.WFChildren#canCall| (Lit (PivotBetree.BetreeNode.children (Lit this@@158)))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.__default.WFChildren ($LS $ly@@712) (Lit (PivotBetree.BetreeNode.children (Lit this@@158))))))) (|PivotBetree.BetreeNode.LinkedChildren#canCall| (Lit this@@158))))))) (= (PivotBetree.BetreeNode.WF ($LS $ly@@712) (Lit this@@158)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.LocalStructure (Lit this@@158)) (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@158)) (and (PivotBetree.__default.WFChildren ($LS $ly@@712) (Lit (PivotBetree.BetreeNode.children (Lit this@@158)))) (PivotBetree.BetreeNode.LinkedChildren (Lit this@@158)))))))))))
 :qid |PivotBetreeidfy.73:15|
 :weight 3
 :skolemid |6729|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly@@712) (Lit this@@158)))
))))
(assert (forall ((arg0@@660 T@U) (arg1@@344 T@U) ) (! (= (type (PivotBetree.BetreeNode.PushBufferStack arg0@@660 arg1@@344)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.PushBufferStack|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack arg0@@660 arg1@@344))
)))
(assert  (=> true (forall ((this@@159 T@U) (|bufferStack#0| T@U) ) (!  (=> (and (and (= (type this@@159) DatatypeTypeType) (= (type |bufferStack#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| this@@159 |bufferStack#0|) (and (and ($Is this@@159 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@159) (PivotBetree.BetreeNode.BetreeNode_q this@@159))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.PushBufferStack this@@159 |bufferStack#0|)) ($Is (PivotBetree.BetreeNode.PushBufferStack this@@159 |bufferStack#0|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.81:14|
 :skolemid |6730|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack this@@159 |bufferStack#0|))
))))
(assert (forall ((this@@160 T@U) (|bufferStack#0@@0| T@U) ) (!  (=> (and (and (= (type this@@160) DatatypeTypeType) (= (type |bufferStack#0@@0|) DatatypeTypeType)) (and ($Is this@@160 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@0| Tclass.Buffers.BufferStack))) (= (|PivotBetree.BetreeNode.PushBufferStack#requires| this@@160 |bufferStack#0@@0|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@160) (PivotBetree.BetreeNode.BetreeNode_q this@@160))))
 :qid |PivotBetreeidfy.81:14|
 :skolemid |6731|
 :pattern ( (|PivotBetree.BetreeNode.PushBufferStack#requires| this@@160 |bufferStack#0@@0|))
)))
(assert  (=> true (forall ((this@@161 T@U) (|bufferStack#0@@1| T@U) ) (!  (=> (and (and (= (type this@@161) DatatypeTypeType) (= (type |bufferStack#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| this@@161 |bufferStack#0@@1|) (and (and ($Is this@@161 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@1| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@161) (PivotBetree.BetreeNode.BetreeNode_q this@@161))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (PivotBetree.BetreeNode.buffers this@@161) |bufferStack#0@@1|) (= (PivotBetree.BetreeNode.PushBufferStack this@@161 |bufferStack#0@@1|) (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.PushBufferStack (PivotBetree.BetreeNode.buffers this@@161) |bufferStack#0@@1|) (PivotBetree.BetreeNode.pivotTable this@@161) (PivotBetree.BetreeNode.children this@@161)))))
 :qid |PivotBetreeidfy.81:14|
 :skolemid |6732|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack this@@161 |bufferStack#0@@1|))
))))
(assert  (=> true (forall ((this@@162 T@U) (|bufferStack#0@@2| T@U) ) (!  (=> (and (and (= (type this@@162) DatatypeTypeType) (= (type |bufferStack#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| (Lit this@@162) (Lit |bufferStack#0@@2|)) (and (and ($Is this@@162 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@2| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@162))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@162))))))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@162))) (Lit |bufferStack#0@@2|)) (= (PivotBetree.BetreeNode.PushBufferStack (Lit this@@162) (Lit |bufferStack#0@@2|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.PushBufferStack (Lit (PivotBetree.BetreeNode.buffers (Lit this@@162))) (Lit |bufferStack#0@@2|))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@162))) (Lit (PivotBetree.BetreeNode.children (Lit this@@162))))))))
 :qid |PivotBetreeidfy.81:14|
 :weight 3
 :skolemid |6733|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack (Lit this@@162) (Lit |bufferStack#0@@2|)))
))))
(assert  (=> true (forall ((this@@163 T@U) ) (!  (=> (and (= (type this@@163) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| this@@163) ($Is this@@163 Tclass.PivotBetree.BetreeNode))) true)
 :qid |PivotBetreeidfy.89:15|
 :skolemid |6734|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf this@@163))
))))
(assert (forall ((this@@164 T@U) ) (!  (=> (and (= (type this@@164) DatatypeTypeType) ($Is this@@164 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.IsLeaf#requires| this@@164) true))
 :qid |PivotBetreeidfy.89:15|
 :skolemid |6735|
 :pattern ( (|PivotBetree.BetreeNode.IsLeaf#requires| this@@164))
)))
(assert  (=> true (forall ((this@@165 T@U) ) (!  (=> (and (= (type this@@165) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| this@@165) ($Is this@@165 Tclass.PivotBetree.BetreeNode))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@165) (=> (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@165)) (LitInt 1)) (|$IsA#PivotBetree.BetreeNode| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@165) (LitInt 0)))))) (= (PivotBetree.BetreeNode.IsLeaf this@@165)  (and (and (PivotBetree.BetreeNode.BetreeNode_q this@@165) (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@165)) (LitInt 1))) (|PivotBetree.BetreeNode#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@165) (LitInt 0))) |#PivotBetree.BetreeNode.Nil|)))))
 :qid |PivotBetreeidfy.89:15|
 :skolemid |6736|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf this@@165))
))))
(assert  (=> true (forall ((this@@166 T@U) ) (!  (=> (and (= (type this@@166) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| (Lit this@@166)) ($Is this@@166 Tclass.PivotBetree.BetreeNode))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@166))))) (=> (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@166)))) (LitInt 1)) (|$IsA#PivotBetree.BetreeNode| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@166))) (LitInt 0)))))) (= (PivotBetree.BetreeNode.IsLeaf (Lit this@@166))  (and (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@166)) (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@166)))) (LitInt 1))) (|PivotBetree.BetreeNode#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@166))) (LitInt 0))) |#PivotBetree.BetreeNode.Nil|)))))
 :qid |PivotBetreeidfy.89:15|
 :weight 3
 :skolemid |6737|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf (Lit this@@166)))
))))
(assert  (=> true (forall ((this@@167 T@U) ) (!  (=> (and (= (type this@@167) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| this@@167) ($Is this@@167 Tclass.PivotBetree.BetreeNode))) true)
 :qid |PivotBetreeidfy.96:15|
 :skolemid |6738|
 :pattern ( (PivotBetree.BetreeNode.IsIndex this@@167))
))))
(assert (forall ((this@@168 T@U) ) (!  (=> (and (= (type this@@168) DatatypeTypeType) ($Is this@@168 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.IsIndex#requires| this@@168) true))
 :qid |PivotBetreeidfy.96:15|
 :skolemid |6739|
 :pattern ( (|PivotBetree.BetreeNode.IsIndex#requires| this@@168))
)))
(assert  (=> true (forall ((this@@169 T@U) ) (!  (=> (and (= (type this@@169) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| this@@169) ($Is this@@169 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.IsIndex this@@169)  (and (PivotBetree.BetreeNode.BetreeNode_q this@@169) (forall ((|i#0@@154| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@154|) (INTERNAL_lt_boogie |i#0@@154| (|Seq#Length| (PivotBetree.BetreeNode.children this@@169)))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@169) |i#0@@154|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |6740|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@169) |i#0@@154|)))
)))))
 :qid |PivotBetreeidfy.96:15|
 :skolemid |6741|
 :pattern ( (PivotBetree.BetreeNode.IsIndex this@@169))
))))
(assert  (=> true (forall ((this@@170 T@U) ) (!  (=> (and (= (type this@@170) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| (Lit this@@170)) ($Is this@@170 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.IsIndex (Lit this@@170))  (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@170)) (forall ((|i#1@@62| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@62|) (INTERNAL_lt_boogie |i#1@@62| (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@170)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@170))) |i#1@@62|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |6742|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@170) |i#1@@62|)))
)))))
 :qid |PivotBetreeidfy.96:15|
 :weight 3
 :skolemid |6743|
 :pattern ( (PivotBetree.BetreeNode.IsIndex (Lit this@@170)))
))))
(assert  (=> true (forall ((this@@171 T@U) (|splitKey#0| T@U) ) (!  (=> (and (and (= (type this@@171) DatatypeTypeType) (= (type |splitKey#0|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| this@@171 |splitKey#0|) (and (and ($Is this@@171 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0| Tclass.KeyType.Key)) (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@171) (PivotBetree.BetreeNode.IsLeaf this@@171)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@171) |splitKey#0|)) (not (|Seq#Equal| |splitKey#0| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@171))))))))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._0 (PivotBetree.BetreeNode.SplitLeaf this@@171 |splitKey#0|)))) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._1 (PivotBetree.BetreeNode.SplitLeaf this@@171 |splitKey#0|))))) ($Is (PivotBetree.BetreeNode.SplitLeaf this@@171 |splitKey#0|) (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreeidfy.103:14|
 :skolemid |6744|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf this@@171 |splitKey#0|))
))))
(assert (forall ((this@@172 T@U) (|splitKey#0@@0| T@U) ) (!  (=> (and (and (= (type this@@172) DatatypeTypeType) (= (type |splitKey#0@@0|) (SeqType BoxType))) (and ($Is this@@172 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@0| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.SplitLeaf#requires| this@@172 |splitKey#0@@0|)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@172) (PivotBetree.BetreeNode.IsLeaf this@@172)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@172) |splitKey#0@@0|)) (not (|Seq#Equal| |splitKey#0@@0| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@172))))))))
 :qid |PivotBetreeidfy.103:14|
 :skolemid |6745|
 :pattern ( (|PivotBetree.BetreeNode.SplitLeaf#requires| this@@172 |splitKey#0@@0|))
)))
(assert  (=> true (forall ((this@@173 T@U) (|splitKey#0@@1| T@U) ) (!  (=> (and (and (= (type this@@173) DatatypeTypeType) (= (type |splitKey#0@@1|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| this@@173 |splitKey#0@@1|) (and (and ($Is this@@173 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@1| Tclass.KeyType.Key)) (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@173) (PivotBetree.BetreeNode.IsLeaf this@@173)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@173) |splitKey#0@@1|)) (not (|Seq#Equal| |splitKey#0@@1| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@173))))))))) (and (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@173) (let ((|leftFilter#0| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@173)) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@173) (let ((|rightFilter#0| (|#DomainMod.Domain.Domain| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|) (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@173)))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#0|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@173) (DomainMod.Domain.KeySet |leftFilter#0|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#0|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@173) (DomainMod.Domain.KeySet |rightFilter#0|)))))))) (= (PivotBetree.BetreeNode.SplitLeaf this@@173 |splitKey#0@@1|) (let ((|leftFilter#0@@0| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@173)) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))))
(let ((|rightFilter#0@@0| (|#DomainMod.Domain.Domain| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|) (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@173)))))
(let ((|newLeft#0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@173) (DomainMod.Domain.KeySet |leftFilter#0@@0|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@173) (LitInt 0))) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(let ((|newRight#0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@173) (DomainMod.Domain.KeySet |rightFilter#0@@0|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))) (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@173) (LitInt 1))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#0|) ($Box |newRight#0|)))))))))
 :qid |PivotBetreeidfy.103:14|
 :skolemid |6746|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf this@@173 |splitKey#0@@1|))
))))
(assert  (=> true (forall ((this@@174 T@U) (|splitKey#0@@2| T@U) ) (!  (=> (and (and (= (type this@@174) DatatypeTypeType) (= (type |splitKey#0@@2|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| (Lit this@@174) (Lit |splitKey#0@@2|)) (and (and ($Is this@@174 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@2| Tclass.KeyType.Key)) (and (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@174))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.IsLeaf (Lit this@@174)))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Contains (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174))) (Lit |splitKey#0@@2|)))))) (not (|Seq#Equal| |splitKey#0@@2| (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174)))))))))))) (and (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@174)) (let ((|leftFilter#1| (Lit (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174))))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|)))))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@174)) (let ((|rightFilter#1| (Lit (|#DomainMod.Domain.Domain| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))) (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174)))))))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@174))) (DomainMod.Domain.KeySet |leftFilter#1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@174))) (DomainMod.Domain.KeySet |rightFilter#1|)))))))) (= (PivotBetree.BetreeNode.SplitLeaf (Lit this@@174) (Lit |splitKey#0@@2|)) (let ((|leftFilter#1@@0| (Lit (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174))))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|)))))))
(let ((|rightFilter#1@@0| (Lit (|#DomainMod.Domain.Domain| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))) (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@174)))))))))
(let ((|newLeft#1| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@174))) (Lit (DomainMod.Domain.KeySet |leftFilter#1@@0|)))) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@174))) (LitInt 0))) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(let ((|newRight#1| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@174))) (Lit (DomainMod.Domain.KeySet |rightFilter#1@@0|)))) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))))) (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@174))) (LitInt 1))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#1|) ($Box |newRight#1|)))))))))
 :qid |PivotBetreeidfy.103:14|
 :weight 3
 :skolemid |6747|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf (Lit this@@174) (Lit |splitKey#0@@2|)))
))))
(assert  (=> true (forall ((this@@175 T@U) (|pivotIdx#0| Int) ) (!  (=> (and (= (type this@@175) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| this@@175 |pivotIdx#0|) (and (and ($Is this@@175 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@175) (PivotBetree.BetreeNode.IsIndex this@@175)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0|) (INTERNAL_lt_boogie |pivotIdx#0| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@175)) 1))))))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._0 (PivotBetree.BetreeNode.SplitIndex this@@175 |pivotIdx#0|)))) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._1 (PivotBetree.BetreeNode.SplitIndex this@@175 |pivotIdx#0|))))) ($Is (PivotBetree.BetreeNode.SplitIndex this@@175 |pivotIdx#0|) (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreeidfy.121:14|
 :skolemid |6748|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex this@@175 |pivotIdx#0|))
))))
(assert (forall ((this@@176 T@U) (|pivotIdx#0@@0| Int) ) (!  (=> (= (type this@@176) DatatypeTypeType) (=> (and ($Is this@@176 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@0|)) (= (|PivotBetree.BetreeNode.SplitIndex#requires| this@@176 |pivotIdx#0@@0|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@176) (PivotBetree.BetreeNode.IsIndex this@@176)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@0|) (INTERNAL_lt_boogie |pivotIdx#0@@0| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@176)) 1)))))))
 :qid |PivotBetreeidfy.121:14|
 :skolemid |6749|
 :pattern ( (|PivotBetree.BetreeNode.SplitIndex#requires| this@@176 |pivotIdx#0@@0|))
)))
(assert  (=> true (forall ((this@@177 T@U) (|pivotIdx#0@@1| Int) ) (!  (=> (and (= (type this@@177) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| this@@177 |pivotIdx#0@@1|) (and (and ($Is this@@177 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@1|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@177) (PivotBetree.BetreeNode.IsIndex this@@177)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@1|) (INTERNAL_lt_boogie |pivotIdx#0@@1| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@177)) 1))))))) (and (let ((|splitElt#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@177) |pivotIdx#0@@1|))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@177) (let ((|leftFilter#0@@1| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@177)) |splitElt#0|)))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@177) (let ((|rightFilter#0@@1| (|#DomainMod.Domain.Domain| |splitElt#0| (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@177)))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#0@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@177) (DomainMod.Domain.KeySet |leftFilter#0@@1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#0@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@177) (DomainMod.Domain.KeySet |rightFilter#0@@1|))))))))) (= (PivotBetree.BetreeNode.SplitIndex this@@177 |pivotIdx#0@@1|) (let ((|splitElt#0@@0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@177) |pivotIdx#0@@1|))))
(let ((|leftFilter#0@@2| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@177)) |splitElt#0@@0|)))
(let ((|rightFilter#0@@2| (|#DomainMod.Domain.Domain| |splitElt#0@@0| (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@177)))))
(let ((|newLeft#0@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@177) (DomainMod.Domain.KeySet |leftFilter#0@@2|)) (|Seq#Take| (PivotBetree.BetreeNode.pivotTable this@@177) (INTERNAL_add_boogie |pivotIdx#0@@1| 1)) (|Seq#Take| (PivotBetree.BetreeNode.children this@@177) |pivotIdx#0@@1|))))
(let ((|newRight#0@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@177) (DomainMod.Domain.KeySet |rightFilter#0@@2|)) (|Seq#Drop| (PivotBetree.BetreeNode.pivotTable this@@177) |pivotIdx#0@@1|) (|Seq#Drop| (PivotBetree.BetreeNode.children this@@177) |pivotIdx#0@@1|))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#0@@0|) ($Box |newRight#0@@0|))))))))))
 :qid |PivotBetreeidfy.121:14|
 :skolemid |6750|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex this@@177 |pivotIdx#0@@1|))
))))
(assert  (=> true (forall ((this@@178 T@U) (|pivotIdx#0@@2| Int) ) (!  (=> (and (= (type this@@178) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| (Lit this@@178) (LitInt |pivotIdx#0@@2|)) (and (and ($Is this@@178 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@2|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@178))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.IsIndex (Lit this@@178)))))) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@2|) (INTERNAL_lt_boogie |pivotIdx#0@@2| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@178)))) 1))))))) (and (let ((|splitElt#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@178))) (LitInt |pivotIdx#0@@2|)))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@178)) (let ((|leftFilter#1@@1| (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@178))))) |splitElt#1|)))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@178)) (let ((|rightFilter#1@@1| (|#DomainMod.Domain.Domain| |splitElt#1| (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@178))))))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#1@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@178))) (DomainMod.Domain.KeySet |leftFilter#1@@1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#1@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@178))) (DomainMod.Domain.KeySet |rightFilter#1@@1|))))))))) (= (PivotBetree.BetreeNode.SplitIndex (Lit this@@178) (LitInt |pivotIdx#0@@2|)) (let ((|splitElt#1@@0| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@178))) (LitInt |pivotIdx#0@@2|)))))
(let ((|leftFilter#1@@2| (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@178))))) |splitElt#1@@0|)))
(let ((|rightFilter#1@@2| (|#DomainMod.Domain.Domain| |splitElt#1@@0| (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@178))))))))
(let ((|newLeft#1@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@178))) (DomainMod.Domain.KeySet |leftFilter#1@@2|)) (Lit (|Seq#Take| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@178))) (LitInt (INTERNAL_add_boogie |pivotIdx#0@@2| 1)))) (Lit (|Seq#Take| (Lit (PivotBetree.BetreeNode.children (Lit this@@178))) (LitInt |pivotIdx#0@@2|))))))
(let ((|newRight#1@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@178))) (DomainMod.Domain.KeySet |rightFilter#1@@2|)) (Lit (|Seq#Drop| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@178))) (LitInt |pivotIdx#0@@2|))) (Lit (|Seq#Drop| (Lit (PivotBetree.BetreeNode.children (Lit this@@178))) (LitInt |pivotIdx#0@@2|))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#1@@0|) ($Box |newRight#1@@0|))))))))))
 :qid |PivotBetreeidfy.121:14|
 :weight 3
 :skolemid |6751|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex (Lit this@@178) (LitInt |pivotIdx#0@@2|)))
))))
(assert  (=> true (forall ((this@@179 T@U) (|request#0| T@U) ) (!  (=> (and (and (= (type this@@179) DatatypeTypeType) (= (type |request#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| this@@179 |request#0|) (and ($Is this@@179 Tclass.PivotBetree.BetreeNode) ($Is |request#0| Tclass.SplitRequestMod.SplitRequest)))) true)
 :qid |PivotBetreeidfy.141:15|
 :skolemid |6752|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent this@@179 |request#0|))
))))
(assert (forall (($Heap@@104 T@U) (this@@180 T@U) (|request#0@@0| T@U) ) (!  (=> (and (and (and (= (type $Heap@@104) (MapType0Type refType MapType1Type)) (= (type this@@180) DatatypeTypeType)) (= (type |request#0@@0|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap@@104) (and ($Is this@@180 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@180 Tclass.PivotBetree.BetreeNode $Heap@@104))) ($Is |request#0@@0| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.CanSplitParent#requires| this@@180 |request#0@@0|) true))
 :qid |PivotBetreeidfy.141:15|
 :skolemid |6753|
 :pattern ( (|PivotBetree.BetreeNode.CanSplitParent#requires| this@@180 |request#0@@0|) ($IsGoodHeap $Heap@@104))
)))
(assert  (=> true (forall (($Heap@@105 T@U) (this@@181 T@U) (|request#0@@1| T@U) ) (!  (=> (and (and (and (= (type $Heap@@105) (MapType0Type refType MapType1Type)) (= (type this@@181) DatatypeTypeType)) (= (type |request#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| this@@181 |request#0@@1|) (and (and ($IsGoodHeap $Heap@@105) (and ($Is this@@181 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@181 Tclass.PivotBetree.BetreeNode $Heap@@105))) ($Is |request#0@@1| Tclass.SplitRequestMod.SplitRequest)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@181) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@181) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@181) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@1|)) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@181 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|))) (=> (PivotBetree.BetreeNode.ValidChildIndex this@@181 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|)) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@1|)) (=> (U_2_bool (Lit (bool_2_U true))) (and (=> (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) true) (=> (not (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|)) true))))))))) (= (PivotBetree.BetreeNode.CanSplitParent this@@181 |request#0@@1|)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@181) (PivotBetree.BetreeNode.BetreeNode_q this@@181)) (PivotBetree.BetreeNode.ValidChildIndex this@@181 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|))) (let ((|child#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@181) (SplitRequestMod.SplitRequest.childIdx |request#0@@1|)))))
 (and true (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (let ((|splitKey#0@@3| (SplitRequestMod.SplitRequest.splitKey |request#0@@1|)))
(Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@105 (|PivotBetree.BetreeNode.SplitLeaf#Handle| |child#0|) ($Box |splitKey#0@@3|))) (let ((|childPivotIdx#0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@1|)))
(Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@105 (|PivotBetree.BetreeNode.SplitIndex#Handle| |child#0|) ($Box (int_2_U |childPivotIdx#0|)))))))))))
 :qid |PivotBetreeidfy.141:15|
 :skolemid |6754|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent this@@181 |request#0@@1|) ($IsGoodHeap $Heap@@105))
))))
(assert  (=> true (forall (($Heap@@106 T@U) (this@@182 T@U) (|request#0@@2| T@U) ) (!  (=> (and (and (and (= (type $Heap@@106) (MapType0Type refType MapType1Type)) (= (type this@@182) DatatypeTypeType)) (= (type |request#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| (Lit this@@182) (Lit |request#0@@2|)) (and (and ($IsGoodHeap $Heap@@106) (and ($Is this@@182 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@182 Tclass.PivotBetree.BetreeNode $Heap@@106))) ($Is |request#0@@2| Tclass.SplitRequestMod.SplitRequest)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@182)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@182))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@182))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@2|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@182) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@182) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@2|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (=> (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|))))) true) (=> (not (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)))))) true))))))))) (= (PivotBetree.BetreeNode.CanSplitParent (Lit this@@182) (Lit |request#0@@2|))  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@182)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@182))) (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@182) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))) (let ((|child#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@182))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|)))))))
 (and true (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (let ((|splitKey#2| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@2|)))))
(Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@106 (|PivotBetree.BetreeNode.SplitLeaf#Handle| |child#1|) ($Box |splitKey#2|))) (let ((|childPivotIdx#2| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@2|)))))
(Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@106 (|PivotBetree.BetreeNode.SplitIndex#Handle| |child#1|) ($Box (int_2_U |childPivotIdx#2|)))))))))))
 :qid |PivotBetreeidfy.141:15|
 :weight 3
 :skolemid |6755|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent (Lit this@@182) (Lit |request#0@@2|)) ($IsGoodHeap $Heap@@106))
))))
(assert (forall ((arg0@@661 T@U) (arg1@@345 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitKey arg0@@661 arg1@@345)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.SplitKey|
 :pattern ( (PivotBetree.BetreeNode.SplitKey arg0@@661 arg1@@345))
)))
(assert  (=> true (forall ((this@@183 T@U) (|request#0@@3| T@U) ) (!  (=> (and (and (= (type this@@183) DatatypeTypeType) (= (type |request#0@@3|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| this@@183 |request#0@@3|) (and (and ($Is this@@183 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@3| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@183) (PivotBetree.BetreeNode.CanSplitParent this@@183 |request#0@@3|))))) (and (BoundedPivotsLib.__default.PivotInsertable (PivotBetree.BetreeNode.pivotTable this@@183) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@3|) 1) (PivotBetree.BetreeNode.SplitKey this@@183 |request#0@@3|)) ($Is (PivotBetree.BetreeNode.SplitKey this@@183 |request#0@@3|) Tclass.KeyType.Key)))
 :qid |PivotBetreeidfy.153:14|
 :skolemid |6756|
 :pattern ( (PivotBetree.BetreeNode.SplitKey this@@183 |request#0@@3|))
))))
(assert (forall ((this@@184 T@U) (|request#0@@4| T@U) ) (!  (=> (and (and (= (type this@@184) DatatypeTypeType) (= (type |request#0@@4|) DatatypeTypeType)) (and ($Is this@@184 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@4| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitKey#requires| this@@184 |request#0@@4|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@184) (PivotBetree.BetreeNode.CanSplitParent this@@184 |request#0@@4|))))
 :qid |PivotBetreeidfy.153:14|
 :skolemid |6757|
 :pattern ( (|PivotBetree.BetreeNode.SplitKey#requires| this@@184 |request#0@@4|))
)))
(assert  (=> true (forall ((this@@185 T@U) (|request#0@@5| T@U) ) (!  (=> (and (and (= (type this@@185) DatatypeTypeType) (= (type |request#0@@5|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| this@@185 |request#0@@5|) (and (and ($Is this@@185 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@5| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@185) (PivotBetree.BetreeNode.CanSplitParent this@@185 |request#0@@5|))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@5|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@5|)) (= (PivotBetree.BetreeNode.SplitKey this@@185 |request#0@@5|) (let ((|oldChild#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@185) (SplitRequestMod.SplitRequest.childIdx |request#0@@5|)))))
(let ((|out#0@@5| (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@5|) (SplitRequestMod.SplitRequest.splitKey |request#0@@5|) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |oldChild#0|) (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@5|)))))))
|out#0@@5|)))))
 :qid |PivotBetreeidfy.153:14|
 :skolemid |6758|
 :pattern ( (PivotBetree.BetreeNode.SplitKey this@@185 |request#0@@5|))
))))
(assert  (=> true (forall ((this@@186 T@U) (|request#0@@6| T@U) ) (!  (=> (and (and (= (type this@@186) DatatypeTypeType) (= (type |request#0@@6|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit this@@186) (Lit |request#0@@6|)) (and (and ($Is this@@186 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@6| Tclass.SplitRequestMod.SplitRequest)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@186))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanSplitParent (Lit this@@186) (Lit |request#0@@6|))))))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@6|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@6|))) (= (PivotBetree.BetreeNode.SplitKey (Lit this@@186) (Lit |request#0@@6|)) (let ((|oldChild#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@186))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@6|)))))))
(let ((|out#1@@3| (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@6|)) (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@6|)) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |oldChild#1|) (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@6|)))))))))
|out#1@@3|)))))
 :qid |PivotBetreeidfy.153:14|
 :weight 3
 :skolemid |6759|
 :pattern ( (PivotBetree.BetreeNode.SplitKey (Lit this@@186) (Lit |request#0@@6|)))
))))
(assert  (=> true (forall ((this@@187 T@U) (|request#0@@7| T@U) ) (!  (=> (and (and (= (type this@@187) DatatypeTypeType) (= (type |request#0@@7|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@187 |request#0@@7|) (and (and ($Is this@@187 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@7| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@187) (PivotBetree.BetreeNode.CanSplitParent this@@187 |request#0@@7|))))) ($Is (PivotBetree.BetreeNode.SplitParentDefn this@@187 |request#0@@7|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreeidfy.169:14|
 :skolemid |6760|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn this@@187 |request#0@@7|))
))))
(assert (forall ((this@@188 T@U) (|request#0@@8| T@U) ) (!  (=> (and (and (= (type this@@188) DatatypeTypeType) (= (type |request#0@@8|) DatatypeTypeType)) (and ($Is this@@188 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@8| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitParentDefn#requires| this@@188 |request#0@@8|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@188) (PivotBetree.BetreeNode.CanSplitParent this@@188 |request#0@@8|))))
 :qid |PivotBetreeidfy.169:14|
 :skolemid |6761|
 :pattern ( (|PivotBetree.BetreeNode.SplitParentDefn#requires| this@@188 |request#0@@8|))
)))
(assert (= (type StartFuel_Sequences._default.replace1with2) LayerTypeType))
(assert  (=> true (forall ((this@@189 T@U) (|request#0@@9| T@U) ) (!  (=> (and (and (= (type this@@189) DatatypeTypeType) (= (type |request#0@@9|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@189 |request#0@@9|) (and (and ($Is this@@189 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@9| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@189) (PivotBetree.BetreeNode.CanSplitParent this@@189 |request#0@@9|))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (let ((|oldChild#0@@0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@189) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|)))))
 (and (and (=> (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (|PivotBetree.BetreeNode.SplitLeaf#canCall| |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|))) (=> (not (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|)) (|PivotBetree.BetreeNode.SplitIndex#canCall| |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))) (let ((|newRightChild#0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newLeftChild#0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
 (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (|Sequences.__default.replace1with2#canCall| Tclass.PivotBetree.BetreeNode (PivotBetree.BetreeNode.children this@@189) ($Box |newLeftChild#0|) ($Box |newRightChild#0|) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (|PivotBetree.BetreeNode.SplitKey#canCall| this@@189 |request#0@@9|)) (|BoundedPivotsLib.__default.InsertPivot#canCall| (PivotBetree.BetreeNode.pivotTable this@@189) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@9|) 1) (PivotBetree.BetreeNode.SplitKey this@@189 |request#0@@9|))))))))) (= (PivotBetree.BetreeNode.SplitParentDefn this@@189 |request#0@@9|) (let ((|oldChild#0@@1| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@189) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|)))))
(let ((|newRightChild#0@@0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@1| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@1| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newLeftChild#0@@0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@1| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@1| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newChildren#0| (Sequences.__default.replace1with2 Tclass.PivotBetree.BetreeNode StartFuel_Sequences._default.replace1with2 (PivotBetree.BetreeNode.children this@@189) ($Box |newLeftChild#0@@0|) ($Box |newRightChild#0@@0|) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|))))
(|#PivotBetree.BetreeNode.BetreeNode| (PivotBetree.BetreeNode.buffers this@@189) (BoundedPivotsLib.__default.InsertPivot (PivotBetree.BetreeNode.pivotTable this@@189) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@9|) 1) (PivotBetree.BetreeNode.SplitKey this@@189 |request#0@@9|)) |newChildren#0|))))))))
 :qid |PivotBetreeidfy.169:14|
 :skolemid |6762|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn this@@189 |request#0@@9|))
))))
(assert  (=> true (forall ((this@@190 T@U) (|request#0@@10| T@U) ) (!  (=> (and (and (= (type this@@190) DatatypeTypeType) (= (type |request#0@@10|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| (Lit this@@190) (Lit |request#0@@10|)) (and (and ($Is this@@190 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@10| Tclass.SplitRequestMod.SplitRequest)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@190))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanSplitParent (Lit this@@190) (Lit |request#0@@10|))))))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (let ((|oldChild#1@@0| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@190))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)))))))
 (and (and (=> (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|))))) (|PivotBetree.BetreeNode.SplitLeaf#canCall| |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|))))) (=> (not (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)))))) (|PivotBetree.BetreeNode.SplitIndex#canCall| |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))) (let ((|newRightChild#1| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newLeftChild#1| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
 (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (|Sequences.__default.replace1with2#canCall| Tclass.PivotBetree.BetreeNode (Lit (PivotBetree.BetreeNode.children (Lit this@@190))) ($Box |newLeftChild#1|) ($Box |newRightChild#1|) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit this@@190) (Lit |request#0@@10|))) (|BoundedPivotsLib.__default.InsertPivot#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@190))) (LitInt (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)) 1)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit this@@190) (Lit |request#0@@10|))))))))))) (= (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@190) (Lit |request#0@@10|)) (let ((|oldChild#1@@1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@190))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)))))))
(let ((|newRightChild#1@@0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@1| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@1| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newLeftChild#1@@0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@1| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@1| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newChildren#1| (Sequences.__default.replace1with2 Tclass.PivotBetree.BetreeNode StartFuel_Sequences._default.replace1with2 (Lit (PivotBetree.BetreeNode.children (Lit this@@190))) ($Box |newLeftChild#1@@0|) ($Box |newRightChild#1@@0|) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|))))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@190))) (Lit (BoundedPivotsLib.__default.InsertPivot (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@190))) (LitInt (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)) 1)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit this@@190) (Lit |request#0@@10|))))) |newChildren#1|))))))))
 :qid |PivotBetreeidfy.169:14|
 :weight 3
 :skolemid |6763|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@190) (Lit |request#0@@10|)))
))))
(assert (forall ((arg0@@662 T@U) (arg1@@346 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitParent arg0@@662 arg1@@346)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParent|
 :pattern ( (PivotBetree.BetreeNode.SplitParent arg0@@662 arg1@@346))
)))
(assert  (=> true (forall (($Heap@@107 T@U) (this@@191 T@U) (|request#0@@11| T@U) ) (!  (=> (and (and (and (= (type $Heap@@107) (MapType0Type refType MapType1Type)) (= (type this@@191) DatatypeTypeType)) (= (type |request#0@@11|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| this@@191 |request#0@@11|) (and (and (and ($IsGoodHeap $Heap@@107) (and ($Is this@@191 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@191 Tclass.PivotBetree.BetreeNode $Heap@@107))) ($Is |request#0@@11| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@107 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@191) ($Box |request#0@@11|))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.SplitParent this@@191 |request#0@@11|)) ($Is (PivotBetree.BetreeNode.SplitParent this@@191 |request#0@@11|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.206:14|
 :skolemid |6782|
 :pattern ( (PivotBetree.BetreeNode.SplitParent this@@191 |request#0@@11|) ($IsGoodHeap $Heap@@107))
))))
(assert (forall (($Heap@@108 T@U) (this@@192 T@U) (|request#0@@12| T@U) ) (!  (=> (and (and (and (= (type $Heap@@108) (MapType0Type refType MapType1Type)) (= (type this@@192) DatatypeTypeType)) (= (type |request#0@@12|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap@@108) (and ($Is this@@192 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@192 Tclass.PivotBetree.BetreeNode $Heap@@108))) ($Is |request#0@@12| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitParent#requires| this@@192 |request#0@@12|) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@108 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@192) ($Box |request#0@@12|))))
 :qid |PivotBetreeidfy.206:14|
 :skolemid |6783|
 :pattern ( (|PivotBetree.BetreeNode.SplitParent#requires| this@@192 |request#0@@12|) ($IsGoodHeap $Heap@@108))
)))
(assert  (=> true (forall (($Heap@@109 T@U) (this@@193 T@U) (|request#0@@13| T@U) ) (!  (=> (and (and (and (= (type $Heap@@109) (MapType0Type refType MapType1Type)) (= (type this@@193) DatatypeTypeType)) (= (type |request#0@@13|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| this@@193 |request#0@@13|) (and (and (and ($IsGoodHeap $Heap@@109) (and ($Is this@@193 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@193 Tclass.PivotBetree.BetreeNode $Heap@@109))) ($Is |request#0@@13| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@109 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@193) ($Box |request#0@@13|))))) (and (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@193 |request#0@@13|) (= (PivotBetree.BetreeNode.SplitParent this@@193 |request#0@@13|) (PivotBetree.BetreeNode.SplitParentDefn this@@193 |request#0@@13|))))
 :qid |PivotBetreeidfy.206:14|
 :skolemid |6784|
 :pattern ( (PivotBetree.BetreeNode.SplitParent this@@193 |request#0@@13|) ($IsGoodHeap $Heap@@109))
))))
(assert  (=> true (forall (($Heap@@110 T@U) (this@@194 T@U) (|request#0@@14| T@U) ) (!  (=> (and (and (and (= (type $Heap@@110) (MapType0Type refType MapType1Type)) (= (type this@@194) DatatypeTypeType)) (= (type |request#0@@14|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| (Lit this@@194) (Lit |request#0@@14|)) (and (and (and ($IsGoodHeap $Heap@@110) (and ($Is this@@194 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@194 Tclass.PivotBetree.BetreeNode $Heap@@110))) ($Is |request#0@@14| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@110 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| (Lit this@@194)) ($Box (Lit |request#0@@14|)))))) (and (|PivotBetree.BetreeNode.SplitParentDefn#canCall| (Lit this@@194) (Lit |request#0@@14|)) (= (PivotBetree.BetreeNode.SplitParent (Lit this@@194) (Lit |request#0@@14|)) (Lit (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@194) (Lit |request#0@@14|))))))
 :qid |PivotBetreeidfy.206:14|
 :weight 3
 :skolemid |6785|
 :pattern ( (PivotBetree.BetreeNode.SplitParent (Lit this@@194) (Lit |request#0@@14|)) ($IsGoodHeap $Heap@@110))
))))
(assert (forall ((arg0@@663 T@U) (arg1@@347 T@U) ) (! (= (type (PivotBetree.BetreeNode.Promote arg0@@663 arg1@@347)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Promote|
 :pattern ( (PivotBetree.BetreeNode.Promote arg0@@663 arg1@@347))
)))
(assert  (=> true (forall ((this@@195 T@U) (|domain#0| T@U) ) (!  (=> (and (and (= (type this@@195) DatatypeTypeType) (= (type |domain#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| this@@195 |domain#0|) (and (and ($Is this@@195 Tclass.PivotBetree.BetreeNode) ($Is |domain#0| Tclass.DomainMod.Domain)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@195) (DomainMod.Domain.WF |domain#0|)) (DomainMod.Domain.Domain_q |domain#0|))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.Promote this@@195 |domain#0|)) ($Is (PivotBetree.BetreeNode.Promote this@@195 |domain#0|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.214:14|
 :skolemid |6786|
 :pattern ( (PivotBetree.BetreeNode.Promote this@@195 |domain#0|))
))))
(assert (forall ((this@@196 T@U) (|domain#0@@0| T@U) ) (!  (=> (and (and (= (type this@@196) DatatypeTypeType) (= (type |domain#0@@0|) DatatypeTypeType)) (and ($Is this@@196 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@0| Tclass.DomainMod.Domain))) (= (|PivotBetree.BetreeNode.Promote#requires| this@@196 |domain#0@@0|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@196) (DomainMod.Domain.WF |domain#0@@0|)) (DomainMod.Domain.Domain_q |domain#0@@0|))))
 :qid |PivotBetreeidfy.214:14|
 :skolemid |6787|
 :pattern ( (|PivotBetree.BetreeNode.Promote#requires| this@@196 |domain#0@@0|))
)))
(assert (forall ((arg0@@664 T@U) ) (! (= (type (PivotBetree.__default.EmptyRoot arg0@@664)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.EmptyRoot|
 :pattern ( (PivotBetree.__default.EmptyRoot arg0@@664))
)))
(assert  (=> true (forall ((this@@197 T@U) (|domain#0@@1| T@U) ) (!  (=> (and (and (= (type this@@197) DatatypeTypeType) (= (type |domain#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| this@@197 |domain#0@@1|) (and (and ($Is this@@197 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@1| Tclass.DomainMod.Domain)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@197) (DomainMod.Domain.WF |domain#0@@1|)) (DomainMod.Domain.Domain_q |domain#0@@1|))))) (and (=> (PivotBetree.BetreeNode.Nil_q this@@197) (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@1|)) (= (PivotBetree.BetreeNode.Promote this@@197 |domain#0@@1|) (ite (PivotBetree.BetreeNode.Nil_q this@@197) (PivotBetree.__default.EmptyRoot |domain#0@@1|) this@@197))))
 :qid |PivotBetreeidfy.214:14|
 :skolemid |6788|
 :pattern ( (PivotBetree.BetreeNode.Promote this@@197 |domain#0@@1|))
))))
(assert  (=> true (forall ((this@@198 T@U) (|domain#0@@2| T@U) ) (!  (=> (and (and (= (type this@@198) DatatypeTypeType) (= (type |domain#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| (Lit this@@198) (Lit |domain#0@@2|)) (and (and ($Is this@@198 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@2| Tclass.DomainMod.Domain)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@198))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.WF (Lit |domain#0@@2|)))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Domain_q (Lit |domain#0@@2|))))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit this@@198))))) (|PivotBetree.__default.EmptyRoot#canCall| (Lit |domain#0@@2|))) (= (PivotBetree.BetreeNode.Promote (Lit this@@198) (Lit |domain#0@@2|)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@198)) (PivotBetree.__default.EmptyRoot (Lit |domain#0@@2|)) this@@198))))
 :qid |PivotBetreeidfy.214:14|
 :weight 3
 :skolemid |6789|
 :pattern ( (PivotBetree.BetreeNode.Promote (Lit this@@198) (Lit |domain#0@@2|)))
))))
(assert  (=> true (forall ((this@@199 T@U) ) (!  (=> (and (= (type this@@199) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| this@@199) (and ($Is this@@199 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.LocalStructure this@@199) (PivotBetree.BetreeNode.BetreeNode_q this@@199))))) ($Is (PivotBetree.BetreeNode.MyDomain this@@199) Tclass.DomainMod.Domain))
 :qid |PivotBetreeidfy.223:14|
 :skolemid |6790|
 :pattern ( (PivotBetree.BetreeNode.MyDomain this@@199))
))))
(assert (forall ((this@@200 T@U) ) (!  (=> (and (= (type this@@200) DatatypeTypeType) ($Is this@@200 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.MyDomain#requires| this@@200)  (and (PivotBetree.BetreeNode.LocalStructure this@@200) (PivotBetree.BetreeNode.BetreeNode_q this@@200))))
 :qid |PivotBetreeidfy.223:14|
 :skolemid |6791|
 :pattern ( (|PivotBetree.BetreeNode.MyDomain#requires| this@@200))
)))
(assert  (=> true (forall ((this@@201 T@U) ) (!  (=> (and (= (type this@@201) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| this@@201) (and ($Is this@@201 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.LocalStructure this@@201) (PivotBetree.BetreeNode.BetreeNode_q this@@201))))) (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (PivotBetree.BetreeNode.pivotTable this@@201)) (= (PivotBetree.BetreeNode.MyDomain this@@201) (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@201) (LitInt 0))) ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (PivotBetree.BetreeNode.pivotTable this@@201)))))))
 :qid |PivotBetreeidfy.223:14|
 :skolemid |6792|
 :pattern ( (PivotBetree.BetreeNode.MyDomain this@@201))
))))
(assert  (=> true (forall ((this@@202 T@U) ) (!  (=> (and (= (type this@@202) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@202)) (and ($Is this@@202 Tclass.PivotBetree.BetreeNode) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@202))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@202))))))))) (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@202)))) (= (PivotBetree.BetreeNode.MyDomain (Lit this@@202)) (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@202))) (LitInt 0))) (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@202))))))))))
 :qid |PivotBetreeidfy.223:14|
 :weight 3
 :skolemid |6793|
 :pattern ( (PivotBetree.BetreeNode.MyDomain (Lit this@@202)))
))))
(assert  (=> true (forall ((this@@203 T@U) (|childIdx#0@@4| Int) ) (!  (=> (and (= (type this@@203) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@203 |childIdx#0@@4|) (and (and ($Is this@@203 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@4|)) (and (and (PivotBetree.BetreeNode.LocalStructure this@@203) (PivotBetree.BetreeNode.BetreeNode_q this@@203)) (PivotBetree.BetreeNode.ValidChildIndex this@@203 |childIdx#0@@4|))))) (and (DomainMod.Domain.WF (PivotBetree.BetreeNode.DomainRoutedToChild this@@203 |childIdx#0@@4|)) ($Is (PivotBetree.BetreeNode.DomainRoutedToChild this@@203 |childIdx#0@@4|) Tclass.DomainMod.Domain)))
 :qid |PivotBetreeidfy.230:14|
 :skolemid |6794|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@203 |childIdx#0@@4|))
))))
(assert (forall ((this@@204 T@U) (|childIdx#0@@5| Int) ) (!  (=> (= (type this@@204) DatatypeTypeType) (=> (and ($Is this@@204 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@5|)) (= (|PivotBetree.BetreeNode.DomainRoutedToChild#requires| this@@204 |childIdx#0@@5|)  (and (and (PivotBetree.BetreeNode.LocalStructure this@@204) (PivotBetree.BetreeNode.BetreeNode_q this@@204)) (PivotBetree.BetreeNode.ValidChildIndex this@@204 |childIdx#0@@5|)))))
 :qid |PivotBetreeidfy.230:14|
 :skolemid |6795|
 :pattern ( (|PivotBetree.BetreeNode.DomainRoutedToChild#requires| this@@204 |childIdx#0@@5|))
)))
(assert  (=> true (forall ((this@@205 T@U) (|childIdx#0@@6| Int) ) (!  (=> (and (= (type this@@205) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@205 |childIdx#0@@6|) (and (and ($Is this@@205 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@6|)) (and (and (PivotBetree.BetreeNode.LocalStructure this@@205) (PivotBetree.BetreeNode.BetreeNode_q this@@205)) (PivotBetree.BetreeNode.ValidChildIndex this@@205 |childIdx#0@@6|))))) (= (PivotBetree.BetreeNode.DomainRoutedToChild this@@205 |childIdx#0@@6|) (let ((|out#0@@6| (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@205) |childIdx#0@@6|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@205) (INTERNAL_add_boogie |childIdx#0@@6| 1))))))
|out#0@@6|)))
 :qid |PivotBetreeidfy.230:14|
 :skolemid |6796|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@205 |childIdx#0@@6|))
))))
(assert  (=> true (forall ((this@@206 T@U) (|childIdx#0@@7| Int) ) (!  (=> (and (= (type this@@206) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@206) (LitInt |childIdx#0@@7|)) (and (and ($Is this@@206 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@7|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@206))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@206)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@206) (LitInt |childIdx#0@@7|))))))))) (= (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@206) (LitInt |childIdx#0@@7|)) (let ((|out#1@@4| (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@206))) (LitInt |childIdx#0@@7|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@206))) (LitInt (INTERNAL_add_boogie |childIdx#0@@7| 1)))))))
|out#1@@4|)))
 :qid |PivotBetreeidfy.230:14|
 :weight 3
 :skolemid |6797|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@206) (LitInt |childIdx#0@@7|)))
))))
(assert  (=> true (forall ((this@@207 T@U) (|childIdx#0@@8| Int) ) (!  (=> (and (= (type this@@207) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| this@@207 |childIdx#0@@8|) (and ($Is this@@207 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@8|)))) true)
 :qid |PivotBetreeidfy.242:15|
 :skolemid |6798|
 :pattern ( (PivotBetree.BetreeNode.CanFlush this@@207 |childIdx#0@@8|))
))))
(assert (forall ((this@@208 T@U) (|childIdx#0@@9| Int) ) (!  (=> (= (type this@@208) DatatypeTypeType) (=> (and ($Is this@@208 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@9|)) (= (|PivotBetree.BetreeNode.CanFlush#requires| this@@208 |childIdx#0@@9|) true)))
 :qid |PivotBetreeidfy.242:15|
 :skolemid |6799|
 :pattern ( (|PivotBetree.BetreeNode.CanFlush#requires| this@@208 |childIdx#0@@9|))
)))
(assert  (=> true (forall ((this@@209 T@U) (|childIdx#0@@10| Int) ) (!  (=> (and (= (type this@@209) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| this@@209 |childIdx#0@@10|) (and ($Is this@@209 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@10|)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@209) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@209) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@209) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@209 |childIdx#0@@10|)))) (= (PivotBetree.BetreeNode.CanFlush this@@209 |childIdx#0@@10|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@209) (PivotBetree.BetreeNode.BetreeNode_q this@@209)) (PivotBetree.BetreeNode.ValidChildIndex this@@209 |childIdx#0@@10|)))))
 :qid |PivotBetreeidfy.242:15|
 :skolemid |6800|
 :pattern ( (PivotBetree.BetreeNode.CanFlush this@@209 |childIdx#0@@10|))
))))
(assert  (=> true (forall ((this@@210 T@U) (|childIdx#0@@11| Int) ) (!  (=> (and (= (type this@@210) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| (Lit this@@210) (LitInt |childIdx#0@@11|)) (and ($Is this@@210 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@11|)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@210)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@210))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@210))))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@210) (LitInt |childIdx#0@@11|))))) (= (PivotBetree.BetreeNode.CanFlush (Lit this@@210) (LitInt |childIdx#0@@11|)) (U_2_bool (Lit (bool_2_U  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@210)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@210))) (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@210) (LitInt |childIdx#0@@11|)))))))))
 :qid |PivotBetreeidfy.242:15|
 :weight 3
 :skolemid |6801|
 :pattern ( (PivotBetree.BetreeNode.CanFlush (Lit this@@210) (LitInt |childIdx#0@@11|)))
))))
(assert (forall ((arg0@@665 T@U) (arg1@@348 Int) ) (! (= (type (PivotBetree.BetreeNode.Flush arg0@@665 arg1@@348)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Flush|
 :pattern ( (PivotBetree.BetreeNode.Flush arg0@@665 arg1@@348))
)))
(assert  (=> true (forall ((this@@211 T@U) (|childIdx#0@@12| Int) ) (!  (=> (and (= (type this@@211) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| this@@211 |childIdx#0@@12|) (and (and ($Is this@@211 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@12|)) (PivotBetree.BetreeNode.CanFlush this@@211 |childIdx#0@@12|)))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.Flush this@@211 |childIdx#0@@12|)) ($Is (PivotBetree.BetreeNode.Flush this@@211 |childIdx#0@@12|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.249:14|
 :skolemid |6802|
 :pattern ( (PivotBetree.BetreeNode.Flush this@@211 |childIdx#0@@12|))
))))
(assert (forall ((this@@212 T@U) (|childIdx#0@@13| Int) ) (!  (=> (= (type this@@212) DatatypeTypeType) (=> (and ($Is this@@212 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@13|)) (= (|PivotBetree.BetreeNode.Flush#requires| this@@212 |childIdx#0@@13|) (PivotBetree.BetreeNode.CanFlush this@@212 |childIdx#0@@13|))))
 :qid |PivotBetreeidfy.249:14|
 :skolemid |6803|
 :pattern ( (|PivotBetree.BetreeNode.Flush#requires| this@@212 |childIdx#0@@13|))
)))
(assert  (=> true (forall ((this@@213 T@U) (|childIdx#0@@14| Int) ) (!  (=> (and (= (type this@@213) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| this@@213 |childIdx#0@@14|) (and (and ($Is this@@213 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@14|)) (PivotBetree.BetreeNode.CanFlush this@@213 |childIdx#0@@14|)))) (and (and (and |Buffers.__default.AllKeys#canCall| (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@213 |childIdx#0@@14|) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))) (let ((|keepKeys#0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))))
 (and (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@213) |keepKeys#0|) (and (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@213 |childIdx#0@@14|) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|))) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@213) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))) (let ((|movedBuffers#0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@213) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))))
 (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@213 |childIdx#0@@14|) (|PivotBetree.BetreeNode.Promote#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@213) |childIdx#0@@14|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@213) |childIdx#0@@14|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)) |movedBuffers#0|))))))) (= (PivotBetree.BetreeNode.Flush this@@213 |childIdx#0@@14|) (let ((|keepKeys#0@@0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))))
(let ((|keptBuffers#0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@213) |keepKeys#0@@0|)))
(let ((|movedBuffers#0@@0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@213) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)))))
(let ((|newChild#0| (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@213) |childIdx#0@@14|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@213 |childIdx#0@@14|)) |movedBuffers#0@@0|)))
(|#PivotBetree.BetreeNode.BetreeNode| |keptBuffers#0| (PivotBetree.BetreeNode.pivotTable this@@213) (|Seq#Update| (PivotBetree.BetreeNode.children this@@213) |childIdx#0@@14| ($Box |newChild#0|))))))))))
 :qid |PivotBetreeidfy.249:14|
 :skolemid |6804|
 :pattern ( (PivotBetree.BetreeNode.Flush this@@213 |childIdx#0@@14|))
))))
(assert  (=> true (forall ((this@@214 T@U) (|childIdx#0@@15| Int) ) (!  (=> (and (= (type this@@214) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| (Lit this@@214) (LitInt |childIdx#0@@15|)) (and (and ($Is this@@214 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@15|)) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanFlush (Lit this@@214) (LitInt |childIdx#0@@15|)))))))) (and (and (and |Buffers.__default.AllKeys#canCall| (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@214) (LitInt |childIdx#0@@15|)) (|DomainMod.Domain.KeySet#canCall| (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))))) (let ((|keepKeys#1| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))))))
 (and (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@214))) |keepKeys#1|) (and (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@214) (LitInt |childIdx#0@@15|)) (|DomainMod.Domain.KeySet#canCall| (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|))))) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@214))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|))))))) (let ((|movedBuffers#1| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@214))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))))))))
 (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@214) (LitInt |childIdx#0@@15|)) (|PivotBetree.BetreeNode.Promote#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@214))) (LitInt |childIdx#0@@15|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|))))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@214))) (LitInt |childIdx#0@@15|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))) |movedBuffers#1|))))))) (= (PivotBetree.BetreeNode.Flush (Lit this@@214) (LitInt |childIdx#0@@15|)) (let ((|keepKeys#1@@0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))))))
(let ((|keptBuffers#1| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@214))) |keepKeys#1@@0|)))
(let ((|movedBuffers#1@@0| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@214))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))))))))
(let ((|newChild#1| (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@214))) (LitInt |childIdx#0@@15|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@214) (LitInt |childIdx#0@@15|)))) |movedBuffers#1@@0|)))
(|#PivotBetree.BetreeNode.BetreeNode| |keptBuffers#1| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@214))) (|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit this@@214))) (LitInt |childIdx#0@@15|) ($Box |newChild#1|))))))))))
 :qid |PivotBetreeidfy.249:14|
 :weight 3
 :skolemid |6805|
 :pattern ( (PivotBetree.BetreeNode.Flush (Lit this@@214) (LitInt |childIdx#0@@15|)))
))))
(assert (forall ((arg0@@666 T@U) ) (! (= (type (PivotBetree.BetreeNode.Buffers arg0@@666)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Buffers|
 :pattern ( (PivotBetree.BetreeNode.Buffers arg0@@666))
)))
(assert  (=> true (forall ((this@@215 T@U) ) (!  (=> (and (= (type this@@215) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| this@@215) ($Is this@@215 Tclass.PivotBetree.BetreeNode))) ($Is (PivotBetree.BetreeNode.Buffers this@@215) Tclass.Buffers.BufferStack))
 :qid |PivotBetreeidfy.261:14|
 :skolemid |6806|
 :pattern ( (PivotBetree.BetreeNode.Buffers this@@215))
))))
(assert (forall ((this@@216 T@U) ) (!  (=> (and (= (type this@@216) DatatypeTypeType) ($Is this@@216 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.Buffers#requires| this@@216) true))
 :qid |PivotBetreeidfy.261:14|
 :skolemid |6807|
 :pattern ( (|PivotBetree.BetreeNode.Buffers#requires| this@@216))
)))
(assert  (=> true (forall ((this@@217 T@U) ) (!  (=> (and (= (type this@@217) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| this@@217) ($Is this@@217 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.Buffers this@@217) (ite (PivotBetree.BetreeNode.Nil_q this@@217) (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType))) (PivotBetree.BetreeNode.buffers this@@217))))
 :qid |PivotBetreeidfy.261:14|
 :skolemid |6808|
 :pattern ( (PivotBetree.BetreeNode.Buffers this@@217))
))))
(assert  (=> true (forall ((this@@218 T@U) ) (!  (=> (and (= (type this@@218) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| (Lit this@@218)) ($Is this@@218 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.Buffers (Lit this@@218)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@218)) (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType))) (PivotBetree.BetreeNode.buffers (Lit this@@218)))))
 :qid |PivotBetreeidfy.261:14|
 :weight 3
 :skolemid |6809|
 :pattern ( (PivotBetree.BetreeNode.Buffers (Lit this@@218)))
))))
(assert (forall ((arg0@@667 T@U) ) (! (= (type (PivotBetree.BetreeNode.Children arg0@@667)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.Children|
 :pattern ( (PivotBetree.BetreeNode.Children arg0@@667))
)))
(assert  (=> true (forall ((this@@219 T@U) ) (!  (=> (and (= (type this@@219) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| this@@219) ($Is this@@219 Tclass.PivotBetree.BetreeNode))) ($Is (PivotBetree.BetreeNode.Children this@@219) (TSeq Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.266:14|
 :skolemid |6810|
 :pattern ( (PivotBetree.BetreeNode.Children this@@219))
))))
(assert (forall ((this@@220 T@U) ) (!  (=> (and (= (type this@@220) DatatypeTypeType) ($Is this@@220 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.Children#requires| this@@220) true))
 :qid |PivotBetreeidfy.266:14|
 :skolemid |6811|
 :pattern ( (|PivotBetree.BetreeNode.Children#requires| this@@220))
)))
(assert  (=> true (forall ((this@@221 T@U) ) (!  (=> (and (= (type this@@221) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| this@@221) ($Is this@@221 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.Children this@@221) (ite (PivotBetree.BetreeNode.Nil_q this@@221) (|Seq#Empty| BoxType) (PivotBetree.BetreeNode.children this@@221))))
 :qid |PivotBetreeidfy.266:14|
 :skolemid |6812|
 :pattern ( (PivotBetree.BetreeNode.Children this@@221))
))))
(assert  (=> true (forall ((this@@222 T@U) ) (!  (=> (and (= (type this@@222) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| (Lit this@@222)) ($Is this@@222 Tclass.PivotBetree.BetreeNode))) (= (PivotBetree.BetreeNode.Children (Lit this@@222)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@222)) (|Seq#Empty| BoxType) (PivotBetree.BetreeNode.children (Lit this@@222)))))
 :qid |PivotBetreeidfy.266:14|
 :weight 3
 :skolemid |6813|
 :pattern ( (PivotBetree.BetreeNode.Children (Lit this@@222)))
))))
(assert  (=> true (forall ((this@@223 T@U) (|key#0@@218| T@U) ) (!  (=> (and (and (= (type this@@223) DatatypeTypeType) (= (type |key#0@@218|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@223 |key#0@@218|) (and ($Is this@@223 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@218| Tclass.KeyType.Key)))) true)
 :qid |PivotBetreeidfy.271:15|
 :skolemid |6814|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@223 |key#0@@218|))
))))
(assert (forall ((this@@224 T@U) (|key#0@@219| T@U) ) (!  (=> (and (and (= (type this@@224) DatatypeTypeType) (= (type |key#0@@219|) (SeqType BoxType))) (and ($Is this@@224 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@219| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.KeyInDomain#requires| this@@224 |key#0@@219|) true))
 :qid |PivotBetreeidfy.271:15|
 :skolemid |6815|
 :pattern ( (|PivotBetree.BetreeNode.KeyInDomain#requires| this@@224 |key#0@@219|))
)))
(assert  (=> true (forall ((this@@225 T@U) (|key#0@@220| T@U) ) (!  (=> (and (and (= (type this@@225) DatatypeTypeType) (= (type |key#0@@220|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@225 |key#0@@220|) (and ($Is this@@225 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@220| Tclass.KeyType.Key)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@225) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@225) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@225) (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable this@@225) |key#0@@220|)))) (= (PivotBetree.BetreeNode.KeyInDomain this@@225 |key#0@@220|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@225) (PivotBetree.BetreeNode.BetreeNode_q this@@225)) (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable this@@225) |key#0@@220|)))))
 :qid |PivotBetreeidfy.271:15|
 :skolemid |6816|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@225 |key#0@@220|))
))))
(assert  (=> true (forall ((this@@226 T@U) (|key#0@@221| T@U) ) (!  (=> (and (and (= (type this@@226) DatatypeTypeType) (= (type |key#0@@221|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit this@@226) (Lit |key#0@@221|)) (and ($Is this@@226 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@221| Tclass.KeyType.Key)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@226)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@226))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@226))))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@226))) (Lit |key#0@@221|))))) (= (PivotBetree.BetreeNode.KeyInDomain (Lit this@@226) (Lit |key#0@@221|)) (U_2_bool (Lit (bool_2_U  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@226)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@226))) (BoundedPivotsLib.__default.BoundedKey (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@226))) (Lit |key#0@@221|)))))))))
 :qid |PivotBetreeidfy.271:15|
 :weight 3
 :skolemid |6817|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain (Lit this@@226) (Lit |key#0@@221|)))
))))
(assert  (=> true (forall ((this@@227 T@U) ) (!  (=> (and (= (type this@@227) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| this@@227) (and ($Is this@@227 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@227) (PivotBetree.BetreeNode.BetreeNode_q this@@227))))) ($Is (PivotBetree.BetreeNode.KeySet this@@227) (TISet Tclass.KeyType.Key)))
 :qid |PivotBetreeidfy.279:14|
 :skolemid |6818|
 :pattern ( (PivotBetree.BetreeNode.KeySet this@@227))
))))
(assert (forall ((this@@228 T@U) ) (!  (=> (and (= (type this@@228) DatatypeTypeType) ($Is this@@228 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.KeySet#requires| this@@228)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@228) (PivotBetree.BetreeNode.BetreeNode_q this@@228))))
 :qid |PivotBetreeidfy.279:14|
 :skolemid |6819|
 :pattern ( (|PivotBetree.BetreeNode.KeySet#requires| this@@228))
)))
(assert (forall ((arg0@@668 T@U) (arg1@@349 T@U) ) (! (= (type (|lambda#367| arg0@@668 arg1@@349)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#367|
 :pattern ( (|lambda#367| arg0@@668 arg1@@349))
)))
(assert  (=> true (forall ((this@@229 T@U) ) (!  (=> (and (= (type this@@229) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| this@@229) (and ($Is this@@229 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@229) (PivotBetree.BetreeNode.BetreeNode_q this@@229))))) (and (forall ((|key#0@@222| T@U) ) (!  (=> (and (= (type |key#0@@222|) (SeqType BoxType)) ($Is |key#0@@222| Tclass.KeyType.Key)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@229 |key#0@@222|))
 :qid |PivotBetreeidfy.283:12|
 :skolemid |6820|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@229 |key#0@@222|))
)) (= (PivotBetree.BetreeNode.KeySet this@@229) (|lambda#367| Tclass.KeyType.Key this@@229))))
 :qid |PivotBetreeidfy.279:14|
 :skolemid |6821|
 :pattern ( (PivotBetree.BetreeNode.KeySet this@@229))
))))
(assert  (=> true (forall ((this@@230 T@U) ) (!  (=> (and (= (type this@@230) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| (Lit this@@230)) (and ($Is this@@230 Tclass.PivotBetree.BetreeNode) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@230))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@230))))))))) (and (forall ((|key#1@@16| T@U) ) (!  (=> (and (= (type |key#1@@16|) (SeqType BoxType)) ($Is |key#1@@16| Tclass.KeyType.Key)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit this@@230) |key#1@@16|))
 :qid |PivotBetreeidfy.283:12|
 :skolemid |6822|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@230 |key#1@@16|))
)) (= (PivotBetree.BetreeNode.KeySet (Lit this@@230)) (|lambda#367| Tclass.KeyType.Key (Lit this@@230)))))
 :qid |PivotBetreeidfy.279:14|
 :weight 3
 :skolemid |6823|
 :pattern ( (PivotBetree.BetreeNode.KeySet (Lit this@@230)))
))))
(assert  (=> true (forall ((this@@231 T@U) (|key#0@@223| T@U) ) (!  (=> (and (and (= (type this@@231) DatatypeTypeType) (= (type |key#0@@223|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| this@@231 |key#0@@223|) (and (and ($Is this@@231 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@223| Tclass.KeyType.Key)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@231) (PivotBetree.BetreeNode.BetreeNode_q this@@231)) (PivotBetree.BetreeNode.KeyInDomain this@@231 |key#0@@223|))))) ($Is (PivotBetree.BetreeNode.Child this@@231 |key#0@@223|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreeidfy.286:14|
 :skolemid |6824|
 :pattern ( (PivotBetree.BetreeNode.Child this@@231 |key#0@@223|))
))))
(assert (forall ((this@@232 T@U) (|key#0@@224| T@U) ) (!  (=> (and (and (= (type this@@232) DatatypeTypeType) (= (type |key#0@@224|) (SeqType BoxType))) (and ($Is this@@232 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@224| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.Child#requires| this@@232 |key#0@@224|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@232) (PivotBetree.BetreeNode.BetreeNode_q this@@232)) (PivotBetree.BetreeNode.KeyInDomain this@@232 |key#0@@224|))))
 :qid |PivotBetreeidfy.286:14|
 :skolemid |6825|
 :pattern ( (|PivotBetree.BetreeNode.Child#requires| this@@232 |key#0@@224|))
)))
(assert  (=> true (forall ((this@@233 T@U) (|key#0@@225| T@U) ) (!  (=> (and (and (= (type this@@233) DatatypeTypeType) (= (type |key#0@@225|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| this@@233 |key#0@@225|) (and (and ($Is this@@233 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@225| Tclass.KeyType.Key)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@233) (PivotBetree.BetreeNode.BetreeNode_q this@@233)) (PivotBetree.BetreeNode.KeyInDomain this@@233 |key#0@@225|))))) (and (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable this@@233) |key#0@@225|) (= (PivotBetree.BetreeNode.Child this@@233 |key#0@@225|) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@233) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable this@@233) |key#0@@225|))))))
 :qid |PivotBetreeidfy.286:14|
 :skolemid |6826|
 :pattern ( (PivotBetree.BetreeNode.Child this@@233 |key#0@@225|))
))))
(assert  (=> true (forall ((this@@234 T@U) (|key#0@@226| T@U) ) (!  (=> (and (and (= (type this@@234) DatatypeTypeType) (= (type |key#0@@226|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| (Lit this@@234) (Lit |key#0@@226|)) (and (and ($Is this@@234 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@226| Tclass.KeyType.Key)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@234))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@234)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit this@@234) (Lit |key#0@@226|))))))))) (and (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@234))) (Lit |key#0@@226|)) (= (PivotBetree.BetreeNode.Child (Lit this@@234) (Lit |key#0@@226|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@234))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@234))) (Lit |key#0@@226|))))))))
 :qid |PivotBetreeidfy.286:14|
 :weight 3
 :skolemid |6827|
 :pattern ( (PivotBetree.BetreeNode.Child (Lit this@@234) (Lit |key#0@@226|)))
))))
(assert (forall ((arg0@@669 T@U) (arg1@@350 T@U) ) (! (= (type (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| arg0@@669 arg1@@350)) DatatypeTypeType)
 :qid |funType:#PivotBetree.QueryReceiptLine.QueryReceiptLine|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| arg0@@669 arg1@@350))
)))
(assert (forall ((|a#0#0#0@@8| T@U) (|a#0#1#0@@4| T@U) ) (!  (=> (and (= (type |a#0#0#0@@8|) DatatypeTypeType) (= (type |a#0#1#0@@4|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@8| |a#0#1#0@@4|)) |##PivotBetree.QueryReceiptLine.QueryReceiptLine|))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6828|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@8| |a#0#1#0@@4|))
)))
(assert (forall ((d@@125 T@U) ) (!  (=> (= (type d@@125) DatatypeTypeType) (= (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@125) (= (DatatypeCtorId d@@125) |##PivotBetree.QueryReceiptLine.QueryReceiptLine|)))
 :qid |unknown.0:0|
 :skolemid |6829|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@125))
)))
(assert (forall ((d@@126 T@U) ) (!  (=> (and (= (type d@@126) DatatypeTypeType) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@126)) (exists ((|a#1#0#0@@8| T@U) (|a#1#1#0@@4| T@U) ) (!  (and (and (= (type |a#1#0#0@@8|) DatatypeTypeType) (= (type |a#1#1#0@@4|) DatatypeTypeType)) (= d@@126 (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#1#0#0@@8| |a#1#1#0@@4|)))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6830|
 :no-pattern (type |a#1#0#0@@8|)
 :no-pattern (type |a#1#1#0@@4|)
 :no-pattern (U_2_int |a#1#0#0@@8|)
 :no-pattern (U_2_bool |a#1#0#0@@8|)
 :no-pattern (U_2_int |a#1#1#0@@4|)
 :no-pattern (U_2_bool |a#1#1#0@@4|)
)))
 :qid |unknown.0:0|
 :skolemid |6831|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@126))
)))
(assert (forall ((|a#2#0#0@@8| T@U) (|a#2#1#0@@4| T@U) ) (!  (=> (and (= (type |a#2#0#0@@8|) DatatypeTypeType) (= (type |a#2#1#0@@4|) DatatypeTypeType)) (= ($Is (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@8| |a#2#1#0@@4|) Tclass.PivotBetree.QueryReceiptLine)  (and ($Is |a#2#0#0@@8| Tclass.PivotBetree.BetreeNode) ($Is |a#2#1#0@@4| Tclass.ValueMessage.Message))))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6832|
 :pattern ( ($Is (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@8| |a#2#1#0@@4|) Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (forall ((|a#3#0#0@@8| T@U) (|a#3#1#0@@4| T@U) ($h@@149 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@8|) DatatypeTypeType) (= (type |a#3#1#0@@4|) DatatypeTypeType)) (= (type $h@@149) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@149)) (= ($IsAlloc (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@8| |a#3#1#0@@4|) Tclass.PivotBetree.QueryReceiptLine $h@@149)  (and ($IsAlloc |a#3#0#0@@8| Tclass.PivotBetree.BetreeNode $h@@149) ($IsAlloc |a#3#1#0@@4| Tclass.ValueMessage.Message $h@@149))))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6833|
 :pattern ( ($IsAlloc (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@8| |a#3#1#0@@4|) Tclass.PivotBetree.QueryReceiptLine $h@@149))
)))
(assert (forall ((d@@127 T@U) ($h@@150 T@U) ) (!  (=> (and (and (= (type d@@127) DatatypeTypeType) (= (type $h@@150) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@150) (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@127) ($IsAlloc d@@127 Tclass.PivotBetree.QueryReceiptLine $h@@150)))) ($IsAlloc (PivotBetree.QueryReceiptLine.node d@@127) Tclass.PivotBetree.BetreeNode $h@@150))
 :qid |unknown.0:0|
 :skolemid |6834|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceiptLine.node d@@127) Tclass.PivotBetree.BetreeNode $h@@150))
)))
(assert (forall ((d@@128 T@U) ($h@@151 T@U) ) (!  (=> (and (and (= (type d@@128) DatatypeTypeType) (= (type $h@@151) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@151) (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@128) ($IsAlloc d@@128 Tclass.PivotBetree.QueryReceiptLine $h@@151)))) ($IsAlloc (PivotBetree.QueryReceiptLine.result d@@128) Tclass.ValueMessage.Message $h@@151))
 :qid |unknown.0:0|
 :skolemid |6835|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceiptLine.result d@@128) Tclass.ValueMessage.Message $h@@151))
)))
(assert (forall ((|a#4#0#0@@8| T@U) (|a#4#1#0@@4| T@U) ) (!  (=> (and (= (type |a#4#0#0@@8|) DatatypeTypeType) (= (type |a#4#1#0@@4|) DatatypeTypeType)) (= (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@8|) (Lit |a#4#1#0@@4|)) (Lit (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#4#0#0@@8| |a#4#1#0@@4|))))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6836|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@8|) (Lit |a#4#1#0@@4|)))
)))
(assert (forall ((|a#5#0#0@@10| T@U) (|a#5#1#0@@5| T@U) ) (!  (=> (and (= (type |a#5#0#0@@10|) DatatypeTypeType) (= (type |a#5#1#0@@5|) DatatypeTypeType)) (= (PivotBetree.QueryReceiptLine.node (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@10| |a#5#1#0@@5|)) |a#5#0#0@@10|))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6837|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@10| |a#5#1#0@@5|))
)))
(assert (forall ((|a#6#0#0@@10| T@U) (|a#6#1#0@@5| T@U) ) (!  (=> (and (= (type |a#6#0#0@@10|) DatatypeTypeType) (= (type |a#6#1#0@@5|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@10|) (DtRank (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@10| |a#6#1#0@@5|))))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6838|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@10| |a#6#1#0@@5|))
)))
(assert (forall ((|a#7#0#0@@10| T@U) (|a#7#1#0@@5| T@U) ) (!  (=> (and (= (type |a#7#0#0@@10|) DatatypeTypeType) (= (type |a#7#1#0@@5|) DatatypeTypeType)) (= (PivotBetree.QueryReceiptLine.result (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@10| |a#7#1#0@@5|)) |a#7#1#0@@5|))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6839|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@10| |a#7#1#0@@5|))
)))
(assert (forall ((|a#8#0#0@@6| T@U) (|a#8#1#0@@4| T@U) ) (!  (=> (and (= (type |a#8#0#0@@6|) DatatypeTypeType) (= (type |a#8#1#0@@4|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@4|) (DtRank (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@6| |a#8#1#0@@4|))))
 :qid |PivotBetreeidfy.310:5|
 :skolemid |6840|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@6| |a#8#1#0@@4|))
)))
(assert (forall ((d@@129 T@U) ) (!  (=> (and (= (type d@@129) DatatypeTypeType) (|$IsA#PivotBetree.QueryReceiptLine| d@@129)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@129))
 :qid |unknown.0:0|
 :skolemid |6841|
 :pattern ( (|$IsA#PivotBetree.QueryReceiptLine| d@@129))
)))
(assert (forall ((d@@130 T@U) ) (!  (=> (and (= (type d@@130) DatatypeTypeType) ($Is d@@130 Tclass.PivotBetree.QueryReceiptLine)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@130))
 :qid |unknown.0:0|
 :skolemid |6842|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@130) ($Is d@@130 Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (forall ((a@@157 T@U) (b@@106 T@U) ) (!  (=> (and (and (= (type a@@157) DatatypeTypeType) (= (type b@@106) DatatypeTypeType)) true) (= (|PivotBetree.QueryReceiptLine#Equal| a@@157 b@@106)  (and (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node a@@157) (PivotBetree.QueryReceiptLine.node b@@106)) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result a@@157) (PivotBetree.QueryReceiptLine.result b@@106)))))
 :qid |unknown.0:0|
 :skolemid |6843|
 :pattern ( (|PivotBetree.QueryReceiptLine#Equal| a@@157 b@@106))
)))
(assert (forall ((a@@158 T@U) (b@@107 T@U) ) (!  (=> (and (= (type a@@158) DatatypeTypeType) (= (type b@@107) DatatypeTypeType)) (= (|PivotBetree.QueryReceiptLine#Equal| a@@158 b@@107) (= a@@158 b@@107)))
 :qid |unknown.0:0|
 :skolemid |6844|
 :pattern ( (|PivotBetree.QueryReceiptLine#Equal| a@@158 b@@107))
)))
(assert  (=> true (forall ((this@@235 T@U) ) (!  (=> (and (= (type this@@235) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| this@@235) ($Is this@@235 Tclass.PivotBetree.QueryReceiptLine))) true)
 :qid |PivotBetreeidfy.313:15|
 :skolemid |6845|
 :pattern ( (PivotBetree.QueryReceiptLine.WF this@@235))
))))
(assert (forall ((this@@236 T@U) ) (!  (=> (and (= (type this@@236) DatatypeTypeType) ($Is this@@236 Tclass.PivotBetree.QueryReceiptLine)) (= (|PivotBetree.QueryReceiptLine.WF#requires| this@@236) true))
 :qid |PivotBetreeidfy.313:15|
 :skolemid |6846|
 :pattern ( (|PivotBetree.QueryReceiptLine.WF#requires| this@@236))
)))
(assert  (=> true (forall ((this@@237 T@U) ) (!  (=> (and (= (type this@@237) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| this@@237) ($Is this@@237 Tclass.PivotBetree.QueryReceiptLine))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q this@@237) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.QueryReceiptLine.node this@@237))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.QueryReceiptLine.node this@@237)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q this@@237))) (= (PivotBetree.QueryReceiptLine.WF this@@237)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.QueryReceiptLine.node this@@237)) (ValueMessage.Message.Define_q (PivotBetree.QueryReceiptLine.result this@@237))))))
 :qid |PivotBetreeidfy.313:15|
 :skolemid |6847|
 :pattern ( (PivotBetree.QueryReceiptLine.WF this@@237))
))))
(assert  (=> true (forall ((this@@238 T@U) ) (!  (=> (and (= (type this@@238) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| (Lit this@@238)) ($Is this@@238 Tclass.PivotBetree.QueryReceiptLine))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@238)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@238))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@238))))))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@238)))) (= (PivotBetree.QueryReceiptLine.WF (Lit this@@238)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@238)))) (ValueMessage.Message.Define_q (Lit (PivotBetree.QueryReceiptLine.result (Lit this@@238)))))))))))
 :qid |PivotBetreeidfy.313:15|
 :weight 3
 :skolemid |6848|
 :pattern ( (PivotBetree.QueryReceiptLine.WF (Lit this@@238)))
))))
(assert (forall ((arg0@@670 T@U) (arg1@@351 T@U) (arg2@@174 T@U) ) (! (= (type (|#PivotBetree.QueryReceipt.QueryReceipt| arg0@@670 arg1@@351 arg2@@174)) DatatypeTypeType)
 :qid |funType:#PivotBetree.QueryReceipt.QueryReceipt|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| arg0@@670 arg1@@351 arg2@@174))
)))
(assert (forall ((|a#0#0#0@@9| T@U) (|a#0#1#0@@5| T@U) (|a#0#2#0| T@U) ) (!  (=> (and (and (= (type |a#0#0#0@@9|) (SeqType BoxType)) (= (type |a#0#1#0@@5|) DatatypeTypeType)) (= (type |a#0#2#0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@9| |a#0#1#0@@5| |a#0#2#0|)) |##PivotBetree.QueryReceipt.QueryReceipt|))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6849|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@9| |a#0#1#0@@5| |a#0#2#0|))
)))
(assert (forall ((d@@131 T@U) ) (!  (=> (= (type d@@131) DatatypeTypeType) (= (PivotBetree.QueryReceipt.QueryReceipt_q d@@131) (= (DatatypeCtorId d@@131) |##PivotBetree.QueryReceipt.QueryReceipt|)))
 :qid |unknown.0:0|
 :skolemid |6850|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@131))
)))
(assert (forall ((d@@132 T@U) ) (!  (=> (and (= (type d@@132) DatatypeTypeType) (PivotBetree.QueryReceipt.QueryReceipt_q d@@132)) (exists ((|a#1#0#0@@9| T@U) (|a#1#1#0@@5| T@U) (|a#1#2#0| T@U) ) (!  (and (and (and (= (type |a#1#0#0@@9|) (SeqType BoxType)) (= (type |a#1#1#0@@5|) DatatypeTypeType)) (= (type |a#1#2#0|) (SeqType BoxType))) (= d@@132 (|#PivotBetree.QueryReceipt.QueryReceipt| |a#1#0#0@@9| |a#1#1#0@@5| |a#1#2#0|)))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6851|
 :no-pattern (type |a#1#0#0@@9|)
 :no-pattern (type |a#1#1#0@@5|)
 :no-pattern (type |a#1#2#0|)
 :no-pattern (U_2_int |a#1#0#0@@9|)
 :no-pattern (U_2_bool |a#1#0#0@@9|)
 :no-pattern (U_2_int |a#1#1#0@@5|)
 :no-pattern (U_2_bool |a#1#1#0@@5|)
 :no-pattern (U_2_int |a#1#2#0|)
 :no-pattern (U_2_bool |a#1#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |6852|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@132))
)))
(assert (forall ((|a#2#0#0@@9| T@U) (|a#2#1#0@@5| T@U) (|a#2#2#0| T@U) ) (!  (=> (and (and (= (type |a#2#0#0@@9|) (SeqType BoxType)) (= (type |a#2#1#0@@5|) DatatypeTypeType)) (= (type |a#2#2#0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@9| |a#2#1#0@@5| |a#2#2#0|) Tclass.PivotBetree.QueryReceipt)  (and (and ($Is |a#2#0#0@@9| Tclass.KeyType.Key) ($Is |a#2#1#0@@5| Tclass.PivotBetree.BetreeNode)) ($Is |a#2#2#0| (TSeq Tclass.PivotBetree.QueryReceiptLine)))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6853|
 :pattern ( ($Is (|#PivotBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@9| |a#2#1#0@@5| |a#2#2#0|) Tclass.PivotBetree.QueryReceipt))
)))
(assert (forall ((|a#3#0#0@@9| T@U) (|a#3#1#0@@5| T@U) (|a#3#2#0| T@U) ($h@@152 T@U) ) (!  (=> (and (and (and (and (= (type |a#3#0#0@@9|) (SeqType BoxType)) (= (type |a#3#1#0@@5|) DatatypeTypeType)) (= (type |a#3#2#0|) (SeqType BoxType))) (= (type $h@@152) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@152)) (= ($IsAlloc (|#PivotBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@9| |a#3#1#0@@5| |a#3#2#0|) Tclass.PivotBetree.QueryReceipt $h@@152)  (and (and ($IsAlloc |a#3#0#0@@9| Tclass.KeyType.Key $h@@152) ($IsAlloc |a#3#1#0@@5| Tclass.PivotBetree.BetreeNode $h@@152)) ($IsAlloc |a#3#2#0| (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@152))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6854|
 :pattern ( ($IsAlloc (|#PivotBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@9| |a#3#1#0@@5| |a#3#2#0|) Tclass.PivotBetree.QueryReceipt $h@@152))
)))
(assert (forall ((d@@133 T@U) ($h@@153 T@U) ) (!  (=> (and (and (= (type d@@133) DatatypeTypeType) (= (type $h@@153) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@153) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@133) ($IsAlloc d@@133 Tclass.PivotBetree.QueryReceipt $h@@153)))) ($IsAlloc (PivotBetree.QueryReceipt.key d@@133) Tclass.KeyType.Key $h@@153))
 :qid |unknown.0:0|
 :skolemid |6855|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.key d@@133) Tclass.KeyType.Key $h@@153))
)))
(assert (forall ((d@@134 T@U) ($h@@154 T@U) ) (!  (=> (and (and (= (type d@@134) DatatypeTypeType) (= (type $h@@154) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@154) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@134) ($IsAlloc d@@134 Tclass.PivotBetree.QueryReceipt $h@@154)))) ($IsAlloc (PivotBetree.QueryReceipt.root d@@134) Tclass.PivotBetree.BetreeNode $h@@154))
 :qid |unknown.0:0|
 :skolemid |6856|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.root d@@134) Tclass.PivotBetree.BetreeNode $h@@154))
)))
(assert (forall ((d@@135 T@U) ($h@@155 T@U) ) (!  (=> (and (and (= (type d@@135) DatatypeTypeType) (= (type $h@@155) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@155) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@135) ($IsAlloc d@@135 Tclass.PivotBetree.QueryReceipt $h@@155)))) ($IsAlloc (PivotBetree.QueryReceipt.lines d@@135) (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@155))
 :qid |unknown.0:0|
 :skolemid |6857|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.lines d@@135) (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@155))
)))
(assert (forall ((|a#4#0#0@@9| T@U) (|a#4#1#0@@5| T@U) (|a#4#2#0| T@U) ) (!  (=> (and (and (= (type |a#4#0#0@@9|) (SeqType BoxType)) (= (type |a#4#1#0@@5|) DatatypeTypeType)) (= (type |a#4#2#0|) (SeqType BoxType))) (= (|#PivotBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@9|) (Lit |a#4#1#0@@5|) (Lit |a#4#2#0|)) (Lit (|#PivotBetree.QueryReceipt.QueryReceipt| |a#4#0#0@@9| |a#4#1#0@@5| |a#4#2#0|))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6858|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@9|) (Lit |a#4#1#0@@5|) (Lit |a#4#2#0|)))
)))
(assert (forall ((|a#5#0#0@@11| T@U) (|a#5#1#0@@6| T@U) (|a#5#2#0| T@U) ) (!  (=> (and (and (= (type |a#5#0#0@@11|) (SeqType BoxType)) (= (type |a#5#1#0@@6|) DatatypeTypeType)) (= (type |a#5#2#0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.key (|#PivotBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@11| |a#5#1#0@@6| |a#5#2#0|)) |a#5#0#0@@11|))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6859|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@11| |a#5#1#0@@6| |a#5#2#0|))
)))
(assert (forall ((|a#6#0#0@@11| T@U) (|a#6#1#0@@6| T@U) (|a#6#2#0| T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@11|) (SeqType BoxType)) (= (type |a#6#1#0@@6|) DatatypeTypeType)) (= (type |a#6#2#0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.root (|#PivotBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@11| |a#6#1#0@@6| |a#6#2#0|)) |a#6#1#0@@6|))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6860|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@11| |a#6#1#0@@6| |a#6#2#0|))
)))
(assert (forall ((|a#7#0#0@@11| T@U) (|a#7#1#0@@6| T@U) (|a#7#2#0| T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@11|) (SeqType BoxType)) (= (type |a#7#1#0@@6|) DatatypeTypeType)) (= (type |a#7#2#0|) (SeqType BoxType))) (< (DtRank |a#7#1#0@@6|) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@11| |a#7#1#0@@6| |a#7#2#0|))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6861|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@11| |a#7#1#0@@6| |a#7#2#0|))
)))
(assert (forall ((|a#8#0#0@@7| T@U) (|a#8#1#0@@5| T@U) (|a#8#2#0@@0| T@U) ) (!  (=> (and (and (= (type |a#8#0#0@@7|) (SeqType BoxType)) (= (type |a#8#1#0@@5|) DatatypeTypeType)) (= (type |a#8#2#0@@0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.lines (|#PivotBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@7| |a#8#1#0@@5| |a#8#2#0@@0|)) |a#8#2#0@@0|))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6862|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@7| |a#8#1#0@@5| |a#8#2#0@@0|))
)))
(assert (forall ((|a#9#0#0@@4| T@U) (|a#9#1#0@@2| T@U) (|a#9#2#0@@0| T@U) (i@@29 Int) ) (!  (=> (and (and (and (= (type |a#9#0#0@@4|) (SeqType BoxType)) (= (type |a#9#1#0@@2|) DatatypeTypeType)) (= (type |a#9#2#0@@0|) (SeqType BoxType))) (and (<= 0 i@@29) (< i@@29 (|Seq#Length| |a#9#2#0@@0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#9#2#0@@0| i@@29))) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#9#0#0@@4| |a#9#1#0@@2| |a#9#2#0@@0|))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6863|
 :pattern ( (|Seq#Index| |a#9#2#0@@0| i@@29) (|#PivotBetree.QueryReceipt.QueryReceipt| |a#9#0#0@@4| |a#9#1#0@@2| |a#9#2#0@@0|))
)))
(assert (forall ((|a#10#0#0@@4| T@U) (|a#10#1#0@@2| T@U) (|a#10#2#0@@0| T@U) ) (!  (=> (and (and (= (type |a#10#0#0@@4|) (SeqType BoxType)) (= (type |a#10#1#0@@2|) DatatypeTypeType)) (= (type |a#10#2#0@@0|) (SeqType BoxType))) (< (|Seq#Rank| |a#10#2#0@@0|) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#10#0#0@@4| |a#10#1#0@@2| |a#10#2#0@@0|))))
 :qid |PivotBetreeidfy.321:5|
 :skolemid |6864|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#10#0#0@@4| |a#10#1#0@@2| |a#10#2#0@@0|))
)))
(assert (forall ((d@@136 T@U) ) (!  (=> (and (= (type d@@136) DatatypeTypeType) (|$IsA#PivotBetree.QueryReceipt| d@@136)) (PivotBetree.QueryReceipt.QueryReceipt_q d@@136))
 :qid |unknown.0:0|
 :skolemid |6865|
 :pattern ( (|$IsA#PivotBetree.QueryReceipt| d@@136))
)))
(assert (forall ((d@@137 T@U) ) (!  (=> (and (= (type d@@137) DatatypeTypeType) ($Is d@@137 Tclass.PivotBetree.QueryReceipt)) (PivotBetree.QueryReceipt.QueryReceipt_q d@@137))
 :qid |unknown.0:0|
 :skolemid |6866|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@137) ($Is d@@137 Tclass.PivotBetree.QueryReceipt))
)))
(assert (forall ((a@@159 T@U) (b@@108 T@U) ) (!  (=> (and (and (= (type a@@159) DatatypeTypeType) (= (type b@@108) DatatypeTypeType)) true) (= (|PivotBetree.QueryReceipt#Equal| a@@159 b@@108)  (and (and (|Seq#Equal| (PivotBetree.QueryReceipt.key a@@159) (PivotBetree.QueryReceipt.key b@@108)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root a@@159) (PivotBetree.QueryReceipt.root b@@108))) (|Seq#Equal| (PivotBetree.QueryReceipt.lines a@@159) (PivotBetree.QueryReceipt.lines b@@108)))))
 :qid |unknown.0:0|
 :skolemid |6867|
 :pattern ( (|PivotBetree.QueryReceipt#Equal| a@@159 b@@108))
)))
(assert (forall ((a@@160 T@U) (b@@109 T@U) ) (!  (=> (and (= (type a@@160) DatatypeTypeType) (= (type b@@109) DatatypeTypeType)) (= (|PivotBetree.QueryReceipt#Equal| a@@160 b@@109) (= a@@160 b@@109)))
 :qid |unknown.0:0|
 :skolemid |6868|
 :pattern ( (|PivotBetree.QueryReceipt#Equal| a@@160 b@@109))
)))
(assert  (=> true (forall ((this@@239 T@U) ) (!  (=> (and (= (type this@@239) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| this@@239) ($Is this@@239 Tclass.PivotBetree.QueryReceipt))) true)
 :qid |PivotBetreeidfy.325:15|
 :skolemid |6869|
 :pattern ( (PivotBetree.QueryReceipt.Structure this@@239))
))))
(assert (forall ((this@@240 T@U) ) (!  (=> (and (= (type this@@240) DatatypeTypeType) ($Is this@@240 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Structure#requires| this@@240) true))
 :qid |PivotBetreeidfy.325:15|
 :skolemid |6870|
 :pattern ( (|PivotBetree.QueryReceipt.Structure#requires| this@@240))
)))
(assert  (=> true (forall ((this@@241 T@U) ) (!  (=> (and (= (type this@@241) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| this@@241) ($Is this@@241 Tclass.PivotBetree.QueryReceipt))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@241) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) (LitInt 0))))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.root this@@241))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@241) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) (LitInt 0))))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@241))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) (LitInt 0)))) (PivotBetree.QueryReceipt.root this@@241)) (and (forall ((|i#0@@155| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@155|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@241) (=> (INTERNAL_lt_boogie |i#0@@155| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@241) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@155|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@241)))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6872|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@155|)))
)) (=> (forall ((|i#0@@156| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@156|) (INTERNAL_lt_boogie |i#0@@156| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241)))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@156|)))) (INTERNAL_lt_boogie |i#0@@156| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241)) 1))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6873|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@156|)))
)) (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@241))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@241) (|Sequences.__default.Last#canCall| Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@241))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@241))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PivotBetree.QueryReceipt.Structure this@@241)  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) (LitInt 0)))) (PivotBetree.QueryReceipt.root this@@241))) (forall ((|i#0@@157| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@157|) (INTERNAL_lt_boogie |i#0@@157| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241)))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@157|)))) (INTERNAL_lt_boogie |i#0@@157| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@241)) 1))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6871|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@241) |i#0@@157|)))
))) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@241)))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PivotBetreeidfy.325:15|
 :skolemid |6874|
 :pattern ( (PivotBetree.QueryReceipt.Structure this@@241))
))))
(assert  (=> true (forall ((this@@242 T@U) ) (!  (=> (and (= (type this@@242) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| (Lit this@@242)) ($Is this@@242 Tclass.PivotBetree.QueryReceipt))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) (LitInt 0))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.root (Lit this@@242))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) (LitInt 0))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) (LitInt 0)))) (PivotBetree.QueryReceipt.root (Lit this@@242))) (and (forall ((|i#1@@63| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@63|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)) (=> (INTERNAL_lt_boogie |i#1@@63| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) |i#1@@63|)))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242))))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6876|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@242) |i#1@@63|)))
)) (=> (forall ((|i#1@@64| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@64|) (INTERNAL_lt_boogie |i#1@@64| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242)))))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) |i#1@@64|)))) (INTERNAL_lt_boogie |i#1@@64| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242)))) 1))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6877|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@242) |i#1@@64|)))
)) (and (|$IsA#ValueMessage.Message| (Lit (PivotBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@242)) (|Sequences.__default.Last#canCall| Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242)))))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PivotBetree.QueryReceipt.Structure (Lit this@@242))  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) (LitInt 0)))) (PivotBetree.QueryReceipt.root (Lit this@@242)))) (forall ((|i#1@@65| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@65|) (INTERNAL_lt_boogie |i#1@@65| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242)))))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))) |i#1@@65|)))) (INTERNAL_lt_boogie |i#1@@65| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242)))) 1))))
 :qid |PivotBetreeidfy.329:18|
 :skolemid |6875|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@242) |i#1@@65|)))
))) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@242))))))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PivotBetreeidfy.325:15|
 :weight 3
 :skolemid |6878|
 :pattern ( (PivotBetree.QueryReceipt.Structure (Lit this@@242)))
))))
(assert  (=> true (forall ((this@@243 T@U) ) (!  (=> (and (= (type this@@243) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@243) ($Is this@@243 Tclass.PivotBetree.QueryReceipt))) true)
 :qid |PivotBetreeidfy.333:15|
 :skolemid |6879|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF this@@243))
))))
(assert (forall ((this@@244 T@U) ) (!  (=> (and (= (type this@@244) DatatypeTypeType) ($Is this@@244 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.AllLinesWF#requires| this@@244) true))
 :qid |PivotBetreeidfy.333:15|
 :skolemid |6880|
 :pattern ( (|PivotBetree.QueryReceipt.AllLinesWF#requires| this@@244))
)))
(assert  (=> true (forall ((this@@245 T@U) ) (!  (=> (and (= (type this@@245) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@245) ($Is this@@245 Tclass.PivotBetree.QueryReceipt))) (and (and (forall ((|i#0@@158| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@158|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@245) (=> (INTERNAL_lt_boogie |i#0@@158| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@245))) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@245) (|PivotBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@158|)))))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6883|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@158|)))
)) (=> (forall ((|i#0@@159| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@159|) (INTERNAL_lt_boogie |i#0@@159| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@245)))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@159|))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6885|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@159|)))
)) (forall ((|i#1@@66| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@66|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@245) (=> (INTERNAL_lt_boogie |i#1@@66| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@245)) 1)) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@245) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#1@@66|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@245)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#1@@66|))) (PivotBetree.QueryReceipt.key this@@245))))))
 :qid |PivotBetreeidfy.336:18|
 :skolemid |6884|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#1@@66|)))
)))) (= (PivotBetree.QueryReceipt.AllLinesWF this@@245)  (and (forall ((|i#0@@160| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@160|) (INTERNAL_lt_boogie |i#0@@160| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@245)))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@160|))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6881|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#0@@160|)))
)) (forall ((|i#1@@67| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@67|) (INTERNAL_lt_boogie |i#1@@67| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@245)) 1))) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#1@@67|))) (PivotBetree.QueryReceipt.key this@@245)))
 :qid |PivotBetreeidfy.336:18|
 :skolemid |6882|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@245) |i#1@@67|)))
))))))
 :qid |PivotBetreeidfy.333:15|
 :skolemid |6886|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF this@@245))
))))
(assert  (=> true (forall ((this@@246 T@U) ) (!  (=> (and (= (type this@@246) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@246)) ($Is this@@246 Tclass.PivotBetree.QueryReceipt))) (and (and (forall ((|i#2@@15| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#2@@15|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@246)) (=> (INTERNAL_lt_boogie |i#2@@15| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))))) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@246)) (|PivotBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#2@@15|)))))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6889|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@246) |i#2@@15|)))
)) (=> (forall ((|i#2@@16| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@16|) (INTERNAL_lt_boogie |i#2@@16| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246)))))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#2@@16|))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6891|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@246) |i#2@@16|)))
)) (forall ((|i#3@@7| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@7|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@246)) (=> (INTERNAL_lt_boogie |i#3@@7| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246)))) 1)) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@246)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#3@@7|)))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@246))) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#3@@7|))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@246))))))))
 :qid |PivotBetreeidfy.336:18|
 :skolemid |6890|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@246) |i#3@@7|)))
)))) (= (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@246))  (and (forall ((|i#2@@17| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@17|) (INTERNAL_lt_boogie |i#2@@17| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246)))))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#2@@17|))))
 :qid |PivotBetreeidfy.335:18|
 :skolemid |6887|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@246) |i#2@@17|)))
)) (forall ((|i#3@@8| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@8|) (INTERNAL_lt_boogie |i#3@@8| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246)))) 1))) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@246))) |i#3@@8|))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@246)))))
 :qid |PivotBetreeidfy.336:18|
 :skolemid |6888|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@246) |i#3@@8|)))
))))))
 :qid |PivotBetreeidfy.333:15|
 :weight 3
 :skolemid |6892|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@246)))
))))
(assert (forall ((arg0@@671 T@U) (arg1@@352 Int) ) (! (= (type (PivotBetree.QueryReceipt.ChildAt arg0@@671 arg1@@352)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.ChildAt|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt arg0@@671 arg1@@352))
)))
(assert  (=> true (forall ((this@@247 T@U) (|i#0@@161| Int) ) (!  (=> (and (= (type this@@247) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@247 |i#0@@161|) (and (and ($Is this@@247 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@161|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@247) (PivotBetree.QueryReceipt.Structure this@@247)) (INTERNAL_lt_boogie |i#0@@161| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@247)) 1)))))) ($Is (PivotBetree.QueryReceipt.ChildAt this@@247 |i#0@@161|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreeidfy.339:14|
 :skolemid |6893|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt this@@247 |i#0@@161|))
))))
(assert (forall ((this@@248 T@U) (|i#0@@162| Int) ) (!  (=> (= (type this@@248) DatatypeTypeType) (=> (and ($Is this@@248 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@162|)) (= (|PivotBetree.QueryReceipt.ChildAt#requires| this@@248 |i#0@@162|)  (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@248) (PivotBetree.QueryReceipt.Structure this@@248)) (INTERNAL_lt_boogie |i#0@@162| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@248)) 1))))))
 :qid |PivotBetreeidfy.339:14|
 :skolemid |6894|
 :pattern ( (|PivotBetree.QueryReceipt.ChildAt#requires| this@@248 |i#0@@162|))
)))
(assert  (=> true (forall ((this@@249 T@U) (|i#0@@163| Int) ) (!  (=> (and (= (type this@@249) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@249 |i#0@@163|) (and (and ($Is this@@249 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@163|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@249) (PivotBetree.QueryReceipt.Structure this@@249)) (INTERNAL_lt_boogie |i#0@@163| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@249)) 1)))))) (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@249) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@249) |i#0@@163|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@249)) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@249) |i#0@@163|))) (PivotBetree.QueryReceipt.key this@@249))) (= (PivotBetree.QueryReceipt.ChildAt this@@249 |i#0@@163|) (PivotBetree.BetreeNode.Child (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@249) |i#0@@163|))) (PivotBetree.QueryReceipt.key this@@249)))))
 :qid |PivotBetreeidfy.339:14|
 :skolemid |6895|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt this@@249 |i#0@@163|))
))))
(assert  (=> true (forall ((this@@250 T@U) (|i#0@@164| Int) ) (!  (=> (and (= (type this@@250) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| (Lit this@@250) (LitInt |i#0@@164|)) (and (and ($Is this@@250 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@164|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@250))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@250)))))) (INTERNAL_lt_boogie |i#0@@164| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@250)))) 1)))))) (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@250)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@250))) (LitInt |i#0@@164|))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@250))) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@250))) (LitInt |i#0@@164|)))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@250))))) (= (PivotBetree.QueryReceipt.ChildAt (Lit this@@250) (LitInt |i#0@@164|)) (PivotBetree.BetreeNode.Child (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@250))) (LitInt |i#0@@164|)))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@250)))))))
 :qid |PivotBetreeidfy.339:14|
 :weight 3
 :skolemid |6896|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt (Lit this@@250) (LitInt |i#0@@164|)))
))))
(assert  (=> true (forall ((this@@251 T@U) (|i#0@@165| Int) ) (!  (=> (and (= (type this@@251) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@251 |i#0@@165|) (and (and ($Is this@@251 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@165|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@251) (PivotBetree.QueryReceipt.Structure this@@251)) (INTERNAL_lt_boogie |i#0@@165| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@251)) 1)))))) true)
 :qid |PivotBetreeidfy.347:15|
 :skolemid |6897|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@251 |i#0@@165|))
))))
(assert (forall ((this@@252 T@U) (|i#0@@166| Int) ) (!  (=> (= (type this@@252) DatatypeTypeType) (=> (and ($Is this@@252 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@166|)) (= (|PivotBetree.QueryReceipt.ChildLinkedAt#requires| this@@252 |i#0@@166|)  (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@252) (PivotBetree.QueryReceipt.Structure this@@252)) (INTERNAL_lt_boogie |i#0@@166| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@252)) 1))))))
 :qid |PivotBetreeidfy.347:15|
 :skolemid |6898|
 :pattern ( (|PivotBetree.QueryReceipt.ChildLinkedAt#requires| this@@252 |i#0@@166|))
)))
(assert  (=> true (forall ((this@@253 T@U) (|i#0@@167| Int) ) (!  (=> (and (= (type this@@253) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@253 |i#0@@167|) (and (and ($Is this@@253 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@167|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@253) (PivotBetree.QueryReceipt.Structure this@@253)) (INTERNAL_lt_boogie |i#0@@167| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@253)) 1)))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@253) (INTERNAL_add_boogie |i#0@@167| 1))))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.ChildAt this@@253 |i#0@@167|))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@253) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@253) (INTERNAL_add_boogie |i#0@@167| 1))))) (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@253 |i#0@@167|))) (= (PivotBetree.QueryReceipt.ChildLinkedAt this@@253 |i#0@@167|) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@253) (INTERNAL_add_boogie |i#0@@167| 1)))) (PivotBetree.QueryReceipt.ChildAt this@@253 |i#0@@167|)))))
 :qid |PivotBetreeidfy.347:15|
 :skolemid |6899|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@253 |i#0@@167|))
))))
(assert  (=> true (forall ((this@@254 T@U) (|i#0@@168| Int) ) (!  (=> (and (= (type this@@254) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@254) (LitInt |i#0@@168|)) (and (and ($Is this@@254 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@168|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@254))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@254)))))) (INTERNAL_lt_boogie |i#0@@168| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@254)))) 1)))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@254))) (LitInt (INTERNAL_add_boogie |i#0@@168| 1)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.ChildAt (Lit this@@254) (LitInt |i#0@@168|))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@254)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@254))) (LitInt (INTERNAL_add_boogie |i#0@@168| 1)))))) (|PivotBetree.QueryReceipt.ChildAt#canCall| (Lit this@@254) (LitInt |i#0@@168|)))) (= (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@254) (LitInt |i#0@@168|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@254))) (LitInt (INTERNAL_add_boogie |i#0@@168| 1))))) (PivotBetree.QueryReceipt.ChildAt (Lit this@@254) (LitInt |i#0@@168|))))))
 :qid |PivotBetreeidfy.347:15|
 :weight 3
 :skolemid |6900|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@254) (LitInt |i#0@@168|)))
))))
(assert (forall ((arg0@@672 T@U) (arg1@@353 Int) ) (! (= (type (PivotBetree.QueryReceipt.ResultAt arg0@@672 arg1@@353)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.ResultAt|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt arg0@@672 arg1@@353))
)))
(assert  (=> true (forall ((this@@255 T@U) (|i#0@@169| Int) ) (!  (=> (and (= (type this@@255) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@255 |i#0@@169|) (and (and ($Is this@@255 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@169|)) (INTERNAL_lt_boogie |i#0@@169| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@255)))))) ($Is (PivotBetree.QueryReceipt.ResultAt this@@255 |i#0@@169|) Tclass.ValueMessage.Message))
 :qid |PivotBetreeidfy.355:14|
 :skolemid |6901|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt this@@255 |i#0@@169|))
))))
(assert (forall ((this@@256 T@U) (|i#0@@170| Int) ) (!  (=> (= (type this@@256) DatatypeTypeType) (=> (and ($Is this@@256 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@170|)) (= (|PivotBetree.QueryReceipt.ResultAt#requires| this@@256 |i#0@@170|) (INTERNAL_lt_boogie |i#0@@170| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@256))))))
 :qid |PivotBetreeidfy.355:14|
 :skolemid |6902|
 :pattern ( (|PivotBetree.QueryReceipt.ResultAt#requires| this@@256 |i#0@@170|))
)))
(assert  (=> true (forall ((this@@257 T@U) (|i#0@@171| Int) ) (!  (=> (and (= (type this@@257) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@257 |i#0@@171|) (and (and ($Is this@@257 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@171|)) (INTERNAL_lt_boogie |i#0@@171| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@257)))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@257) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@257) |i#0@@171|)))) (= (PivotBetree.QueryReceipt.ResultAt this@@257 |i#0@@171|) (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@257) |i#0@@171|))))))
 :qid |PivotBetreeidfy.355:14|
 :skolemid |6903|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt this@@257 |i#0@@171|))
))))
(assert  (=> true (forall ((this@@258 T@U) (|i#0@@172| Int) ) (!  (=> (and (= (type this@@258) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@258) (LitInt |i#0@@172|)) (and (and ($Is this@@258 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@172|)) (INTERNAL_lt_boogie |i#0@@172| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@258)))))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@258)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@258))) (LitInt |i#0@@172|))))) (= (PivotBetree.QueryReceipt.ResultAt (Lit this@@258) (LitInt |i#0@@172|)) (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@258))) (LitInt |i#0@@172|)))))))
 :qid |PivotBetreeidfy.355:14|
 :weight 3
 :skolemid |6904|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt (Lit this@@258) (LitInt |i#0@@172|)))
))))
(assert  (=> true (forall ((this@@259 T@U) (|i#0@@173| Int) ) (!  (=> (and (= (type this@@259) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@259 |i#0@@173|) (and (and ($Is this@@259 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@173|)) (and (and (PivotBetree.QueryReceipt.Structure this@@259) (PivotBetree.QueryReceipt.AllLinesWF this@@259)) (INTERNAL_lt_boogie |i#0@@173| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@259)) 1)))))) true)
 :qid |PivotBetreeidfy.361:15|
 :skolemid |6905|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@259 |i#0@@173|))
))))
(assert (forall ((this@@260 T@U) (|i#0@@174| Int) ) (!  (=> (= (type this@@260) DatatypeTypeType) (=> (and ($Is this@@260 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@174|)) (= (|PivotBetree.QueryReceipt.ResultLinkedAt#requires| this@@260 |i#0@@174|)  (and (and (PivotBetree.QueryReceipt.Structure this@@260) (PivotBetree.QueryReceipt.AllLinesWF this@@260)) (INTERNAL_lt_boogie |i#0@@174| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@260)) 1))))))
 :qid |PivotBetreeidfy.361:15|
 :skolemid |6906|
 :pattern ( (|PivotBetree.QueryReceipt.ResultLinkedAt#requires| this@@260 |i#0@@174|))
)))
(assert  (=> true (forall ((this@@261 T@U) (|i#0@@175| Int) ) (!  (=> (and (= (type this@@261) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@261 |i#0@@175|) (and (and ($Is this@@261 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@175|)) (and (and (PivotBetree.QueryReceipt.Structure this@@261) (PivotBetree.QueryReceipt.AllLinesWF this@@261)) (INTERNAL_lt_boogie |i#0@@175| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@261)) 1)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (PivotBetree.QueryReceipt.key this@@261)) (PivotBetree.QueryReceipt.ResultAt this@@261 (INTERNAL_add_boogie |i#0@@175| 1))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@261) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (and (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@261) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@261)) (|Buffers.BufferStack.Query#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (PivotBetree.QueryReceipt.key this@@261))) (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@261 (INTERNAL_add_boogie |i#0@@175| 1))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (PivotBetree.QueryReceipt.key this@@261)) (PivotBetree.QueryReceipt.ResultAt this@@261 (INTERNAL_add_boogie |i#0@@175| 1))))))) (= (PivotBetree.QueryReceipt.ResultLinkedAt this@@261 |i#0@@175|)  (and true (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@261) |i#0@@175|)))) (PivotBetree.QueryReceipt.key this@@261)) (PivotBetree.QueryReceipt.ResultAt this@@261 (INTERNAL_add_boogie |i#0@@175| 1))))))))
 :qid |PivotBetreeidfy.361:15|
 :skolemid |6907|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@261 |i#0@@175|))
))))
(assert  (=> true (forall ((this@@262 T@U) (|i#0@@176| Int) ) (!  (=> (and (= (type this@@262) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@262) (LitInt |i#0@@176|)) (and (and ($Is this@@262 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@176|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@262))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@262)))))) (INTERNAL_lt_boogie |i#0@@176| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262)))) 1)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@262)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@262) (LitInt (INTERNAL_add_boogie |i#0@@176| 1))))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@262)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (and (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@262)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@262))) (|Buffers.BufferStack.Query#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@262))))) (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@262) (LitInt (INTERNAL_add_boogie |i#0@@176| 1)))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@262)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@262) (LitInt (INTERNAL_add_boogie |i#0@@176| 1))))))))) (= (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@262) (LitInt |i#0@@176|))  (and true (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|)))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@262))) (LitInt |i#0@@176|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@262)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@262) (LitInt (INTERNAL_add_boogie |i#0@@176| 1))))))))))
 :qid |PivotBetreeidfy.361:15|
 :weight 3
 :skolemid |6908|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@262) (LitInt |i#0@@176|)))
))))
(assert  (=> true (forall ((this@@263 T@U) ) (!  (=> (and (= (type this@@263) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| this@@263) ($Is this@@263 Tclass.PivotBetree.QueryReceipt))) true)
 :qid |PivotBetreeidfy.369:15|
 :skolemid |6909|
 :pattern ( (PivotBetree.QueryReceipt.Valid this@@263))
))))
(assert (forall ((this@@264 T@U) ) (!  (=> (and (= (type this@@264) DatatypeTypeType) ($Is this@@264 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Valid#requires| this@@264) true))
 :qid |PivotBetreeidfy.369:15|
 :skolemid |6910|
 :pattern ( (|PivotBetree.QueryReceipt.Valid#requires| this@@264))
)))
(assert  (=> true (forall ((this@@265 T@U) ) (!  (=> (and (= (type this@@265) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| this@@265) ($Is this@@265 Tclass.PivotBetree.QueryReceipt))) (and (and (|PivotBetree.QueryReceipt.Structure#canCall| this@@265) (=> (PivotBetree.QueryReceipt.Structure this@@265) (and (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@265) (=> (PivotBetree.QueryReceipt.AllLinesWF this@@265) (and (forall ((|i#0@@177| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@177|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@265) (=> (INTERNAL_lt_boogie |i#0@@177| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@265)) 1)) (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@265 |i#0@@177|))))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6913|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@265 |i#0@@177|))
)) (=> (forall ((|i#0@@178| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@178|) (INTERNAL_lt_boogie |i#0@@178| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@265)) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt this@@265 |i#0@@178|))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6915|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@265 |i#0@@178|))
)) (forall ((|i#1@@68| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@68|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@265) (=> (INTERNAL_lt_boogie |i#1@@68| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@265)) 1)) (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@265 |i#1@@68|))))
 :qid |PivotBetreeidfy.374:18|
 :skolemid |6914|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@265 |i#1@@68|))
)))))))) (= (PivotBetree.QueryReceipt.Valid this@@265)  (and (and (and (PivotBetree.QueryReceipt.Structure this@@265) (PivotBetree.QueryReceipt.AllLinesWF this@@265)) (forall ((|i#0@@179| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@179|) (INTERNAL_lt_boogie |i#0@@179| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@265)) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt this@@265 |i#0@@179|))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6911|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@265 |i#0@@179|))
))) (forall ((|i#1@@69| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@69|) (INTERNAL_lt_boogie |i#1@@69| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@265)) 1))) (PivotBetree.QueryReceipt.ResultLinkedAt this@@265 |i#1@@69|))
 :qid |PivotBetreeidfy.374:18|
 :skolemid |6912|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@265 |i#1@@69|))
))))))
 :qid |PivotBetreeidfy.369:15|
 :skolemid |6916|
 :pattern ( (PivotBetree.QueryReceipt.Valid this@@265))
))))
(assert  (=> true (forall ((this@@266 T@U) ) (!  (=> (and (= (type this@@266) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| (Lit this@@266)) ($Is this@@266 Tclass.PivotBetree.QueryReceipt))) (and (and (|PivotBetree.QueryReceipt.Structure#canCall| (Lit this@@266)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@266))))) (and (|PivotBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@266)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@266))))) (and (forall ((|i#2@@18| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#2@@18|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@266)) (=> (INTERNAL_lt_boogie |i#2@@18| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@266)))) 1)) (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@266) |i#2@@18|))))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6919|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@266 |i#2@@18|))
)) (=> (forall ((|i#2@@19| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@19|) (INTERNAL_lt_boogie |i#2@@19| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@266)))) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@266) |i#2@@19|))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6921|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@266 |i#2@@19|))
)) (forall ((|i#3@@9| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@9|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@266)) (=> (INTERNAL_lt_boogie |i#3@@9| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@266)))) 1)) (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@266) |i#3@@9|))))
 :qid |PivotBetreeidfy.374:18|
 :skolemid |6920|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@266 |i#3@@9|))
)))))))) (= (PivotBetree.QueryReceipt.Valid (Lit this@@266))  (and (and (and (PivotBetree.QueryReceipt.Structure (Lit this@@266)) (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@266))) (forall ((|i#2@@20| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@20|) (INTERNAL_lt_boogie |i#2@@20| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@266)))) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@266) |i#2@@20|))
 :qid |PivotBetreeidfy.373:18|
 :skolemid |6917|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@266 |i#2@@20|))
))) (forall ((|i#3@@10| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@10|) (INTERNAL_lt_boogie |i#3@@10| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@266)))) 1))) (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@266) |i#3@@10|))
 :qid |PivotBetreeidfy.374:18|
 :skolemid |6918|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@266 |i#3@@10|))
))))))
 :qid |PivotBetreeidfy.369:15|
 :weight 3
 :skolemid |6922|
 :pattern ( (PivotBetree.QueryReceipt.Valid (Lit this@@266)))
))))
(assert (forall ((arg0@@673 T@U) ) (! (= (type (PivotBetree.QueryReceipt.Result arg0@@673)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.Result|
 :pattern ( (PivotBetree.QueryReceipt.Result arg0@@673))
)))
(assert  (=> true (forall ((this@@267 T@U) ) (!  (=> (and (= (type this@@267) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| this@@267) (and ($Is this@@267 Tclass.PivotBetree.QueryReceipt) (PivotBetree.QueryReceipt.Structure this@@267)))) ($Is (PivotBetree.QueryReceipt.Result this@@267) Tclass.ValueMessage.Message))
 :qid |PivotBetreeidfy.377:14|
 :skolemid |6923|
 :pattern ( (PivotBetree.QueryReceipt.Result this@@267))
))))
(assert (forall ((this@@268 T@U) ) (!  (=> (and (= (type this@@268) DatatypeTypeType) ($Is this@@268 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Result#requires| this@@268) (PivotBetree.QueryReceipt.Structure this@@268)))
 :qid |PivotBetreeidfy.377:14|
 :skolemid |6924|
 :pattern ( (|PivotBetree.QueryReceipt.Result#requires| this@@268))
)))
(assert  (=> true (forall ((this@@269 T@U) ) (!  (=> (and (= (type this@@269) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| this@@269) (and ($Is this@@269 Tclass.PivotBetree.QueryReceipt) (PivotBetree.QueryReceipt.Structure this@@269)))) (and (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@269 (LitInt 0)) (= (PivotBetree.QueryReceipt.Result this@@269) (PivotBetree.QueryReceipt.ResultAt this@@269 (LitInt 0)))))
 :qid |PivotBetreeidfy.377:14|
 :skolemid |6925|
 :pattern ( (PivotBetree.QueryReceipt.Result this@@269))
))))
(assert  (=> true (forall ((this@@270 T@U) ) (!  (=> (and (= (type this@@270) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| (Lit this@@270)) (and ($Is this@@270 Tclass.PivotBetree.QueryReceipt) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@270)))))))) (and (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@270) (LitInt 0)) (= (PivotBetree.QueryReceipt.Result (Lit this@@270)) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@270) (LitInt 0))))))
 :qid |PivotBetreeidfy.377:14|
 :weight 3
 :skolemid |6926|
 :pattern ( (PivotBetree.QueryReceipt.Result (Lit this@@270)))
))))
(assert  (=> true (forall ((this@@271 T@U) (|root#0| T@U) (|key#0@@227| T@U) ) (!  (=> (and (and (and (= (type this@@271) DatatypeTypeType) (= (type |root#0|) DatatypeTypeType)) (= (type |key#0@@227|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| this@@271 |root#0| |key#0@@227|) (and (and ($Is this@@271 Tclass.PivotBetree.QueryReceipt) ($Is |root#0| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@227| Tclass.KeyType.Key)))) true)
 :qid |PivotBetreeidfy.383:15|
 :skolemid |6927|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor this@@271 |root#0| |key#0@@227|))
))))
(assert (forall ((this@@272 T@U) (|root#0@@0| T@U) (|key#0@@228| T@U) ) (!  (=> (and (and (and (= (type this@@272) DatatypeTypeType) (= (type |root#0@@0|) DatatypeTypeType)) (= (type |key#0@@228|) (SeqType BoxType))) (and (and ($Is this@@272 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@0| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@228| Tclass.KeyType.Key))) (= (|PivotBetree.QueryReceipt.ValidFor#requires| this@@272 |root#0@@0| |key#0@@228|) true))
 :qid |PivotBetreeidfy.383:15|
 :skolemid |6928|
 :pattern ( (|PivotBetree.QueryReceipt.ValidFor#requires| this@@272 |root#0@@0| |key#0@@228|))
)))
(assert  (=> true (forall ((this@@273 T@U) (|root#0@@1| T@U) (|key#0@@229| T@U) ) (!  (=> (and (and (and (= (type this@@273) DatatypeTypeType) (= (type |root#0@@1|) DatatypeTypeType)) (= (type |key#0@@229|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| this@@273 |root#0@@1| |key#0@@229|) (and (and ($Is this@@273 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@1| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@229| Tclass.KeyType.Key)))) (and (and (|PivotBetree.QueryReceipt.Valid#canCall| this@@273) (=> (PivotBetree.QueryReceipt.Valid this@@273) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.root this@@273)) (|$IsA#PivotBetree.BetreeNode| |root#0@@1|)) (PivotBetree.QueryReceipt.QueryReceipt_q this@@273)) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root this@@273) |root#0@@1|) (PivotBetree.QueryReceipt.QueryReceipt_q this@@273))))) (= (PivotBetree.QueryReceipt.ValidFor this@@273 |root#0@@1| |key#0@@229|)  (and (and (PivotBetree.QueryReceipt.Valid this@@273) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root this@@273) |root#0@@1|)) (|Seq#Equal| (PivotBetree.QueryReceipt.key this@@273) |key#0@@229|)))))
 :qid |PivotBetreeidfy.383:15|
 :skolemid |6929|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor this@@273 |root#0@@1| |key#0@@229|))
))))
(assert  (=> true (forall ((this@@274 T@U) (|root#0@@2| T@U) (|key#0@@230| T@U) ) (!  (=> (and (and (and (= (type this@@274) DatatypeTypeType) (= (type |root#0@@2|) DatatypeTypeType)) (= (type |key#0@@230|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| (Lit this@@274) (Lit |root#0@@2|) (Lit |key#0@@230|)) (and (and ($Is this@@274 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@2| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@230| Tclass.KeyType.Key)))) (and (and (|PivotBetree.QueryReceipt.Valid#canCall| (Lit this@@274)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Valid (Lit this@@274))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.root (Lit this@@274)))) (|$IsA#PivotBetree.BetreeNode| (Lit |root#0@@2|))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@274))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root (Lit this@@274)) |root#0@@2|) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@274)))))) (= (PivotBetree.QueryReceipt.ValidFor (Lit this@@274) (Lit |root#0@@2|) (Lit |key#0@@230|))  (and (and (PivotBetree.QueryReceipt.Valid (Lit this@@274)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root (Lit this@@274)) |root#0@@2|)) (|Seq#Equal| (PivotBetree.QueryReceipt.key (Lit this@@274)) |key#0@@230|)))))
 :qid |PivotBetreeidfy.383:15|
 :weight 3
 :skolemid |6930|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor (Lit this@@274) (Lit |root#0@@2|) (Lit |key#0@@230|)))
))))
(assert (forall ((arg0@@674 T@U) (arg1@@354 T@U) ) (! (= (type (|#PivotBetree.Variables.Variables| arg0@@674 arg1@@354)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Variables.Variables|
 :pattern ( (|#PivotBetree.Variables.Variables| arg0@@674 arg1@@354))
)))
(assert (forall ((|a#0#0#0@@10| T@U) (|a#0#1#0@@6| T@U) ) (!  (=> (and (= (type |a#0#0#0@@10|) DatatypeTypeType) (= (type |a#0#1#0@@6|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Variables.Variables| |a#0#0#0@@10| |a#0#1#0@@6|)) |##PivotBetree.Variables.Variables|))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6931|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#0#0#0@@10| |a#0#1#0@@6|))
)))
(assert (forall ((d@@138 T@U) ) (!  (=> (= (type d@@138) DatatypeTypeType) (= (PivotBetree.Variables.Variables_q d@@138) (= (DatatypeCtorId d@@138) |##PivotBetree.Variables.Variables|)))
 :qid |unknown.0:0|
 :skolemid |6932|
 :pattern ( (PivotBetree.Variables.Variables_q d@@138))
)))
(assert (forall ((d@@139 T@U) ) (!  (=> (and (= (type d@@139) DatatypeTypeType) (PivotBetree.Variables.Variables_q d@@139)) (exists ((|a#1#0#0@@10| T@U) (|a#1#1#0@@6| T@U) ) (!  (and (and (= (type |a#1#0#0@@10|) DatatypeTypeType) (= (type |a#1#1#0@@6|) DatatypeTypeType)) (= d@@139 (|#PivotBetree.Variables.Variables| |a#1#0#0@@10| |a#1#1#0@@6|)))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6933|
 :no-pattern (type |a#1#0#0@@10|)
 :no-pattern (type |a#1#1#0@@6|)
 :no-pattern (U_2_int |a#1#0#0@@10|)
 :no-pattern (U_2_bool |a#1#0#0@@10|)
 :no-pattern (U_2_int |a#1#1#0@@6|)
 :no-pattern (U_2_bool |a#1#1#0@@6|)
)))
 :qid |unknown.0:0|
 :skolemid |6934|
 :pattern ( (PivotBetree.Variables.Variables_q d@@139))
)))
(assert (forall ((|a#2#0#0@@10| T@U) (|a#2#1#0@@6| T@U) ) (!  (=> (and (= (type |a#2#0#0@@10|) DatatypeTypeType) (= (type |a#2#1#0@@6|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Variables.Variables| |a#2#0#0@@10| |a#2#1#0@@6|) Tclass.PivotBetree.Variables)  (and ($Is |a#2#0#0@@10| Tclass.MemtableMod.Memtable) ($Is |a#2#1#0@@6| Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6935|
 :pattern ( ($Is (|#PivotBetree.Variables.Variables| |a#2#0#0@@10| |a#2#1#0@@6|) Tclass.PivotBetree.Variables))
)))
(assert (forall ((|a#3#0#0@@10| T@U) (|a#3#1#0@@6| T@U) ($h@@156 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@10|) DatatypeTypeType) (= (type |a#3#1#0@@6|) DatatypeTypeType)) (= (type $h@@156) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@156)) (= ($IsAlloc (|#PivotBetree.Variables.Variables| |a#3#0#0@@10| |a#3#1#0@@6|) Tclass.PivotBetree.Variables $h@@156)  (and ($IsAlloc |a#3#0#0@@10| Tclass.MemtableMod.Memtable $h@@156) ($IsAlloc |a#3#1#0@@6| Tclass.PivotBetree.BetreeNode $h@@156))))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6936|
 :pattern ( ($IsAlloc (|#PivotBetree.Variables.Variables| |a#3#0#0@@10| |a#3#1#0@@6|) Tclass.PivotBetree.Variables $h@@156))
)))
(assert (forall ((d@@140 T@U) ($h@@157 T@U) ) (!  (=> (and (and (= (type d@@140) DatatypeTypeType) (= (type $h@@157) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@157) (and (PivotBetree.Variables.Variables_q d@@140) ($IsAlloc d@@140 Tclass.PivotBetree.Variables $h@@157)))) ($IsAlloc (PivotBetree.Variables.memtable d@@140) Tclass.MemtableMod.Memtable $h@@157))
 :qid |unknown.0:0|
 :skolemid |6937|
 :pattern ( ($IsAlloc (PivotBetree.Variables.memtable d@@140) Tclass.MemtableMod.Memtable $h@@157))
)))
(assert (forall ((d@@141 T@U) ($h@@158 T@U) ) (!  (=> (and (and (= (type d@@141) DatatypeTypeType) (= (type $h@@158) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@158) (and (PivotBetree.Variables.Variables_q d@@141) ($IsAlloc d@@141 Tclass.PivotBetree.Variables $h@@158)))) ($IsAlloc (PivotBetree.Variables.root d@@141) Tclass.PivotBetree.BetreeNode $h@@158))
 :qid |unknown.0:0|
 :skolemid |6938|
 :pattern ( ($IsAlloc (PivotBetree.Variables.root d@@141) Tclass.PivotBetree.BetreeNode $h@@158))
)))
(assert (forall ((|a#4#0#0@@10| T@U) (|a#4#1#0@@6| T@U) ) (!  (=> (and (= (type |a#4#0#0@@10|) DatatypeTypeType) (= (type |a#4#1#0@@6|) DatatypeTypeType)) (= (|#PivotBetree.Variables.Variables| (Lit |a#4#0#0@@10|) (Lit |a#4#1#0@@6|)) (Lit (|#PivotBetree.Variables.Variables| |a#4#0#0@@10| |a#4#1#0@@6|))))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6939|
 :pattern ( (|#PivotBetree.Variables.Variables| (Lit |a#4#0#0@@10|) (Lit |a#4#1#0@@6|)))
)))
(assert (forall ((|a#5#0#0@@12| T@U) (|a#5#1#0@@7| T@U) ) (!  (=> (and (= (type |a#5#0#0@@12|) DatatypeTypeType) (= (type |a#5#1#0@@7|) DatatypeTypeType)) (= (PivotBetree.Variables.memtable (|#PivotBetree.Variables.Variables| |a#5#0#0@@12| |a#5#1#0@@7|)) |a#5#0#0@@12|))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6940|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#5#0#0@@12| |a#5#1#0@@7|))
)))
(assert (forall ((|a#6#0#0@@12| T@U) (|a#6#1#0@@7| T@U) ) (!  (=> (and (= (type |a#6#0#0@@12|) DatatypeTypeType) (= (type |a#6#1#0@@7|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@12|) (DtRank (|#PivotBetree.Variables.Variables| |a#6#0#0@@12| |a#6#1#0@@7|))))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6941|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#6#0#0@@12| |a#6#1#0@@7|))
)))
(assert (forall ((|a#7#0#0@@12| T@U) (|a#7#1#0@@7| T@U) ) (!  (=> (and (= (type |a#7#0#0@@12|) DatatypeTypeType) (= (type |a#7#1#0@@7|) DatatypeTypeType)) (= (PivotBetree.Variables.root (|#PivotBetree.Variables.Variables| |a#7#0#0@@12| |a#7#1#0@@7|)) |a#7#1#0@@7|))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6942|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#7#0#0@@12| |a#7#1#0@@7|))
)))
(assert (forall ((|a#8#0#0@@8| T@U) (|a#8#1#0@@6| T@U) ) (!  (=> (and (= (type |a#8#0#0@@8|) DatatypeTypeType) (= (type |a#8#1#0@@6|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@6|) (DtRank (|#PivotBetree.Variables.Variables| |a#8#0#0@@8| |a#8#1#0@@6|))))
 :qid |PivotBetreeidfy.407:5|
 :skolemid |6943|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#8#0#0@@8| |a#8#1#0@@6|))
)))
(assert (forall ((d@@142 T@U) ) (!  (=> (and (= (type d@@142) DatatypeTypeType) (|$IsA#PivotBetree.Variables| d@@142)) (PivotBetree.Variables.Variables_q d@@142))
 :qid |unknown.0:0|
 :skolemid |6944|
 :pattern ( (|$IsA#PivotBetree.Variables| d@@142))
)))
(assert (forall ((d@@143 T@U) ) (!  (=> (and (= (type d@@143) DatatypeTypeType) ($Is d@@143 Tclass.PivotBetree.Variables)) (PivotBetree.Variables.Variables_q d@@143))
 :qid |unknown.0:0|
 :skolemid |6945|
 :pattern ( (PivotBetree.Variables.Variables_q d@@143) ($Is d@@143 Tclass.PivotBetree.Variables))
)))
(assert (forall ((a@@161 T@U) (b@@110 T@U) ) (!  (=> (and (and (= (type a@@161) DatatypeTypeType) (= (type b@@110) DatatypeTypeType)) true) (= (|PivotBetree.Variables#Equal| a@@161 b@@110)  (and (|MemtableMod.Memtable#Equal| (PivotBetree.Variables.memtable a@@161) (PivotBetree.Variables.memtable b@@110)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Variables.root a@@161) (PivotBetree.Variables.root b@@110)))))
 :qid |unknown.0:0|
 :skolemid |6946|
 :pattern ( (|PivotBetree.Variables#Equal| a@@161 b@@110))
)))
(assert (forall ((a@@162 T@U) (b@@111 T@U) ) (!  (=> (and (= (type a@@162) DatatypeTypeType) (= (type b@@111) DatatypeTypeType)) (= (|PivotBetree.Variables#Equal| a@@162 b@@111) (= a@@162 b@@111)))
 :qid |unknown.0:0|
 :skolemid |6947|
 :pattern ( (|PivotBetree.Variables#Equal| a@@162 b@@111))
)))
(assert  (=> true (forall ((this@@275 T@U) ) (!  (=> (and (= (type this@@275) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| this@@275) ($Is this@@275 Tclass.PivotBetree.Variables))) true)
 :qid |PivotBetreeidfy.410:15|
 :skolemid |6948|
 :pattern ( (PivotBetree.Variables.WF this@@275))
))))
(assert (forall ((this@@276 T@U) ) (!  (=> (and (= (type this@@276) DatatypeTypeType) ($Is this@@276 Tclass.PivotBetree.Variables)) (= (|PivotBetree.Variables.WF#requires| this@@276) true))
 :qid |PivotBetreeidfy.410:15|
 :skolemid |6949|
 :pattern ( (|PivotBetree.Variables.WF#requires| this@@276))
)))
(assert  (=> true (forall ((this@@277 T@U) ) (!  (=> (and (= (type this@@277) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| this@@277) ($Is this@@277 Tclass.PivotBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PivotBetree.Variables.Variables_q this@@277) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Variables.root this@@277)))) (= (PivotBetree.Variables.WF this@@277)  (and true (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Variables.root this@@277))))))
 :qid |PivotBetreeidfy.410:15|
 :skolemid |6950|
 :pattern ( (PivotBetree.Variables.WF this@@277))
))))
(assert  (=> true (forall ((this@@278 T@U) ) (!  (=> (and (= (type this@@278) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| (Lit this@@278)) ($Is this@@278 Tclass.PivotBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PivotBetree.Variables.Variables_q (Lit this@@278)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.Variables.root (Lit this@@278)))))) (= (PivotBetree.Variables.WF (Lit this@@278)) (U_2_bool (Lit (bool_2_U  (and true (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Variables.root (Lit this@@278)))))))))))
 :qid |PivotBetreeidfy.410:15|
 :weight 3
 :skolemid |6951|
 :pattern ( (PivotBetree.Variables.WF (Lit this@@278)))
))))
(assert (forall ((arg0@@675 T@U) (arg1@@355 T@U) (arg2@@175 Int) ) (! (= (type (|#PivotBetree.Path.Path| arg0@@675 arg1@@355 arg2@@175)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Path.Path|
 :pattern ( (|#PivotBetree.Path.Path| arg0@@675 arg1@@355 arg2@@175))
)))
(assert (forall ((|a#0#0#0@@11| T@U) (|a#0#1#0@@7| T@U) (|a#0#2#0@@0| Int) ) (!  (=> (and (= (type |a#0#0#0@@11|) DatatypeTypeType) (= (type |a#0#1#0@@7|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.Path.Path| |a#0#0#0@@11| |a#0#1#0@@7| |a#0#2#0@@0|)) |##PivotBetree.Path.Path|))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6952|
 :pattern ( (|#PivotBetree.Path.Path| |a#0#0#0@@11| |a#0#1#0@@7| |a#0#2#0@@0|))
)))
(assert (forall ((d@@144 T@U) ) (!  (=> (= (type d@@144) DatatypeTypeType) (= (PivotBetree.Path.Path_q d@@144) (= (DatatypeCtorId d@@144) |##PivotBetree.Path.Path|)))
 :qid |unknown.0:0|
 :skolemid |6953|
 :pattern ( (PivotBetree.Path.Path_q d@@144))
)))
(assert (forall ((d@@145 T@U) ) (!  (=> (and (= (type d@@145) DatatypeTypeType) (PivotBetree.Path.Path_q d@@145)) (exists ((|a#1#0#0@@11| T@U) (|a#1#1#0@@7| T@U) (|a#1#2#0@@0| Int) ) (!  (and (and (= (type |a#1#0#0@@11|) DatatypeTypeType) (= (type |a#1#1#0@@7|) (SeqType BoxType))) (= d@@145 (|#PivotBetree.Path.Path| |a#1#0#0@@11| |a#1#1#0@@7| |a#1#2#0@@0|)))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6954|
 :no-pattern (type |a#1#0#0@@11|)
 :no-pattern (type |a#1#1#0@@7|)
 :no-pattern (U_2_int |a#1#0#0@@11|)
 :no-pattern (U_2_bool |a#1#0#0@@11|)
 :no-pattern (U_2_int |a#1#1#0@@7|)
 :no-pattern (U_2_bool |a#1#1#0@@7|)
)))
 :qid |unknown.0:0|
 :skolemid |6955|
 :pattern ( (PivotBetree.Path.Path_q d@@145))
)))
(assert (forall ((|a#2#0#0@@11| T@U) (|a#2#1#0@@7| T@U) (|a#2#2#0@@0| Int) ) (!  (=> (and (= (type |a#2#0#0@@11|) DatatypeTypeType) (= (type |a#2#1#0@@7|) (SeqType BoxType))) (= ($Is (|#PivotBetree.Path.Path| |a#2#0#0@@11| |a#2#1#0@@7| |a#2#2#0@@0|) Tclass.PivotBetree.Path)  (and (and ($Is |a#2#0#0@@11| Tclass.PivotBetree.BetreeNode) ($Is |a#2#1#0@@7| Tclass.KeyType.Key)) ($Is (int_2_U |a#2#2#0@@0|) Tclass._System.nat))))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6956|
 :pattern ( ($Is (|#PivotBetree.Path.Path| |a#2#0#0@@11| |a#2#1#0@@7| |a#2#2#0@@0|) Tclass.PivotBetree.Path))
)))
(assert (forall ((|a#3#0#0@@11| T@U) (|a#3#1#0@@7| T@U) (|a#3#2#0@@0| Int) ($h@@159 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@11|) DatatypeTypeType) (= (type |a#3#1#0@@7|) (SeqType BoxType))) (= (type $h@@159) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@159)) (= ($IsAlloc (|#PivotBetree.Path.Path| |a#3#0#0@@11| |a#3#1#0@@7| |a#3#2#0@@0|) Tclass.PivotBetree.Path $h@@159)  (and (and ($IsAlloc |a#3#0#0@@11| Tclass.PivotBetree.BetreeNode $h@@159) ($IsAlloc |a#3#1#0@@7| Tclass.KeyType.Key $h@@159)) ($IsAlloc (int_2_U |a#3#2#0@@0|) Tclass._System.nat $h@@159))))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6957|
 :pattern ( ($IsAlloc (|#PivotBetree.Path.Path| |a#3#0#0@@11| |a#3#1#0@@7| |a#3#2#0@@0|) Tclass.PivotBetree.Path $h@@159))
)))
(assert (forall ((d@@146 T@U) ($h@@160 T@U) ) (!  (=> (and (and (= (type d@@146) DatatypeTypeType) (= (type $h@@160) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@160) (and (PivotBetree.Path.Path_q d@@146) ($IsAlloc d@@146 Tclass.PivotBetree.Path $h@@160)))) ($IsAlloc (PivotBetree.Path.node d@@146) Tclass.PivotBetree.BetreeNode $h@@160))
 :qid |unknown.0:0|
 :skolemid |6958|
 :pattern ( ($IsAlloc (PivotBetree.Path.node d@@146) Tclass.PivotBetree.BetreeNode $h@@160))
)))
(assert (forall ((d@@147 T@U) ($h@@161 T@U) ) (!  (=> (and (and (= (type d@@147) DatatypeTypeType) (= (type $h@@161) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@161) (and (PivotBetree.Path.Path_q d@@147) ($IsAlloc d@@147 Tclass.PivotBetree.Path $h@@161)))) ($IsAlloc (PivotBetree.Path.key d@@147) Tclass.KeyType.Key $h@@161))
 :qid |unknown.0:0|
 :skolemid |6959|
 :pattern ( ($IsAlloc (PivotBetree.Path.key d@@147) Tclass.KeyType.Key $h@@161))
)))
(assert (forall ((d@@148 T@U) ($h@@162 T@U) ) (!  (=> (and (and (= (type d@@148) DatatypeTypeType) (= (type $h@@162) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@162) (and (PivotBetree.Path.Path_q d@@148) ($IsAlloc d@@148 Tclass.PivotBetree.Path $h@@162)))) ($IsAlloc (int_2_U (PivotBetree.Path.depth d@@148)) Tclass._System.nat $h@@162))
 :qid |unknown.0:0|
 :skolemid |6960|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.Path.depth d@@148)) Tclass._System.nat $h@@162))
)))
(assert (forall ((|a#4#0#0@@11| T@U) (|a#4#1#0@@7| T@U) (|a#4#2#0@@0| Int) ) (!  (=> (and (= (type |a#4#0#0@@11|) DatatypeTypeType) (= (type |a#4#1#0@@7|) (SeqType BoxType))) (= (|#PivotBetree.Path.Path| (Lit |a#4#0#0@@11|) (Lit |a#4#1#0@@7|) (LitInt |a#4#2#0@@0|)) (Lit (|#PivotBetree.Path.Path| |a#4#0#0@@11| |a#4#1#0@@7| |a#4#2#0@@0|))))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6961|
 :pattern ( (|#PivotBetree.Path.Path| (Lit |a#4#0#0@@11|) (Lit |a#4#1#0@@7|) (LitInt |a#4#2#0@@0|)))
)))
(assert (forall ((|a#5#0#0@@13| T@U) (|a#5#1#0@@8| T@U) (|a#5#2#0@@0| Int) ) (!  (=> (and (= (type |a#5#0#0@@13|) DatatypeTypeType) (= (type |a#5#1#0@@8|) (SeqType BoxType))) (= (PivotBetree.Path.node (|#PivotBetree.Path.Path| |a#5#0#0@@13| |a#5#1#0@@8| |a#5#2#0@@0|)) |a#5#0#0@@13|))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6962|
 :pattern ( (|#PivotBetree.Path.Path| |a#5#0#0@@13| |a#5#1#0@@8| |a#5#2#0@@0|))
)))
(assert (forall ((|a#6#0#0@@13| T@U) (|a#6#1#0@@8| T@U) (|a#6#2#0@@0| Int) ) (!  (=> (and (= (type |a#6#0#0@@13|) DatatypeTypeType) (= (type |a#6#1#0@@8|) (SeqType BoxType))) (< (DtRank |a#6#0#0@@13|) (DtRank (|#PivotBetree.Path.Path| |a#6#0#0@@13| |a#6#1#0@@8| |a#6#2#0@@0|))))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6963|
 :pattern ( (|#PivotBetree.Path.Path| |a#6#0#0@@13| |a#6#1#0@@8| |a#6#2#0@@0|))
)))
(assert (forall ((|a#7#0#0@@13| T@U) (|a#7#1#0@@8| T@U) (|a#7#2#0@@0| Int) ) (!  (=> (and (= (type |a#7#0#0@@13|) DatatypeTypeType) (= (type |a#7#1#0@@8|) (SeqType BoxType))) (= (PivotBetree.Path.key (|#PivotBetree.Path.Path| |a#7#0#0@@13| |a#7#1#0@@8| |a#7#2#0@@0|)) |a#7#1#0@@8|))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6964|
 :pattern ( (|#PivotBetree.Path.Path| |a#7#0#0@@13| |a#7#1#0@@8| |a#7#2#0@@0|))
)))
(assert (forall ((|a#8#0#0@@9| T@U) (|a#8#1#0@@7| T@U) (|a#8#2#0@@1| Int) ) (!  (=> (and (= (type |a#8#0#0@@9|) DatatypeTypeType) (= (type |a#8#1#0@@7|) (SeqType BoxType))) (= (PivotBetree.Path.depth (|#PivotBetree.Path.Path| |a#8#0#0@@9| |a#8#1#0@@7| |a#8#2#0@@1|)) |a#8#2#0@@1|))
 :qid |PivotBetreeidfy.462:24|
 :skolemid |6965|
 :pattern ( (|#PivotBetree.Path.Path| |a#8#0#0@@9| |a#8#1#0@@7| |a#8#2#0@@1|))
)))
(assert (forall ((d@@149 T@U) ) (!  (=> (and (= (type d@@149) DatatypeTypeType) (|$IsA#PivotBetree.Path| d@@149)) (PivotBetree.Path.Path_q d@@149))
 :qid |unknown.0:0|
 :skolemid |6966|
 :pattern ( (|$IsA#PivotBetree.Path| d@@149))
)))
(assert (forall ((d@@150 T@U) ) (!  (=> (and (= (type d@@150) DatatypeTypeType) ($Is d@@150 Tclass.PivotBetree.Path)) (PivotBetree.Path.Path_q d@@150))
 :qid |unknown.0:0|
 :skolemid |6967|
 :pattern ( (PivotBetree.Path.Path_q d@@150) ($Is d@@150 Tclass.PivotBetree.Path))
)))
(assert (forall ((a@@163 T@U) (b@@112 T@U) ) (!  (=> (and (and (= (type a@@163) DatatypeTypeType) (= (type b@@112) DatatypeTypeType)) true) (= (|PivotBetree.Path#Equal| a@@163 b@@112)  (and (and (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node a@@163) (PivotBetree.Path.node b@@112)) (|Seq#Equal| (PivotBetree.Path.key a@@163) (PivotBetree.Path.key b@@112))) (= (PivotBetree.Path.depth a@@163) (PivotBetree.Path.depth b@@112)))))
 :qid |unknown.0:0|
 :skolemid |6968|
 :pattern ( (|PivotBetree.Path#Equal| a@@163 b@@112))
)))
(assert (forall ((a@@164 T@U) (b@@113 T@U) ) (!  (=> (and (= (type a@@164) DatatypeTypeType) (= (type b@@113) DatatypeTypeType)) (= (|PivotBetree.Path#Equal| a@@164 b@@113) (= a@@164 b@@113)))
 :qid |unknown.0:0|
 :skolemid |6969|
 :pattern ( (|PivotBetree.Path#Equal| a@@164 b@@113))
)))
(assert  (=> true (forall ((this@@279 T@U) ) (!  (=> (and (= (type this@@279) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| this@@279) (and ($Is this@@279 Tclass.PivotBetree.Path) (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@279)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@279) (PivotBetree.Path.key this@@279)))))) ($Is (PivotBetree.Path.Subpath this@@279) Tclass.PivotBetree.Path))
 :qid |PivotBetreeidfy.464:14|
 :skolemid |6970|
 :pattern ( (PivotBetree.Path.Subpath this@@279))
))))
(assert (forall ((this@@280 T@U) ) (!  (=> (and (= (type this@@280) DatatypeTypeType) ($Is this@@280 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Subpath#requires| this@@280)  (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@280)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@280) (PivotBetree.Path.key this@@280)))))
 :qid |PivotBetreeidfy.464:14|
 :skolemid |6971|
 :pattern ( (|PivotBetree.Path.Subpath#requires| this@@280))
)))
(assert  (=> true (forall ((this@@281 T@U) ) (!  (=> (and (= (type this@@281) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| this@@281) (and ($Is this@@281 Tclass.PivotBetree.Path) (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@281)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@281) (PivotBetree.Path.key this@@281)))))) (and (and (and (and (and (PivotBetree.Path.Path_q this@@281) (PivotBetree.Path.Path_q this@@281)) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.Path.node this@@281) (PivotBetree.Path.key this@@281))) (PivotBetree.Path.Path_q this@@281)) (PivotBetree.Path.Path_q this@@281)) (= (PivotBetree.Path.Subpath this@@281) (|#PivotBetree.Path.Path| (PivotBetree.BetreeNode.Child (PivotBetree.Path.node this@@281) (PivotBetree.Path.key this@@281)) (PivotBetree.Path.key this@@281) (INTERNAL_sub_boogie (PivotBetree.Path.depth this@@281) 1)))))
 :qid |PivotBetreeidfy.464:14|
 :skolemid |6972|
 :pattern ( (PivotBetree.Path.Subpath this@@281))
))))
(assert  (=> true (forall ((this@@282 T@U) ) (!  (=> (and (= (type this@@282) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| (Lit this@@282)) (and ($Is this@@282 Tclass.PivotBetree.Path) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@282)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@282))) (Lit (PivotBetree.Path.key (Lit this@@282))))))))))) (and (and (and (and (and (PivotBetree.Path.Path_q (Lit this@@282)) (PivotBetree.Path.Path_q (Lit this@@282))) (|PivotBetree.BetreeNode.Child#canCall| (Lit (PivotBetree.Path.node (Lit this@@282))) (Lit (PivotBetree.Path.key (Lit this@@282))))) (PivotBetree.Path.Path_q (Lit this@@282))) (PivotBetree.Path.Path_q (Lit this@@282))) (= (PivotBetree.Path.Subpath (Lit this@@282)) (Lit (|#PivotBetree.Path.Path| (Lit (PivotBetree.BetreeNode.Child (Lit (PivotBetree.Path.node (Lit this@@282))) (Lit (PivotBetree.Path.key (Lit this@@282))))) (Lit (PivotBetree.Path.key (Lit this@@282))) (LitInt (INTERNAL_sub_boogie (PivotBetree.Path.depth (Lit this@@282)) 1)))))))
 :qid |PivotBetreeidfy.464:14|
 :weight 3
 :skolemid |6973|
 :pattern ( (PivotBetree.Path.Subpath (Lit this@@282)))
))))
(assert (forall (($ly@@713 T@U) (this@@283 T@U) ) (!  (=> (and (= (type $ly@@713) LayerTypeType) (= (type this@@283) DatatypeTypeType)) (= (PivotBetree.Path.Valid ($LS $ly@@713) this@@283) (PivotBetree.Path.Valid $ly@@713 this@@283)))
 :qid |PivotBetreeidfy.471:15|
 :skolemid |6974|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@713) this@@283))
)))
(assert (forall (($ly@@714 T@U) (this@@284 T@U) ) (!  (=> (and (= (type $ly@@714) LayerTypeType) (= (type this@@284) DatatypeTypeType)) (= (PivotBetree.Path.Valid $ly@@714 this@@284) (PivotBetree.Path.Valid $LZ this@@284)))
 :qid |PivotBetreeidfy.471:15|
 :skolemid |6975|
 :pattern ( (PivotBetree.Path.Valid (AsFuelBottom $ly@@714) this@@284))
)))
(assert  (=> true (forall (($ly@@715 T@U) (this@@285 T@U) ) (!  (=> (and (and (= (type $ly@@715) LayerTypeType) (= (type this@@285) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| this@@285) ($Is this@@285 Tclass.PivotBetree.Path))) true)
 :qid |PivotBetreeidfy.471:15|
 :skolemid |6976|
 :pattern ( (PivotBetree.Path.Valid $ly@@715 this@@285))
))))
(assert (forall (($ly@@716 T@U) (this@@286 T@U) ) (!  (=> (and (and (= (type $ly@@716) LayerTypeType) (= (type this@@286) DatatypeTypeType)) ($Is this@@286 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Valid#requires| $ly@@716 this@@286) true))
 :qid |PivotBetreeidfy.471:15|
 :skolemid |6977|
 :pattern ( (|PivotBetree.Path.Valid#requires| $ly@@716 this@@286))
)))
(assert  (=> true (forall (($ly@@717 T@U) (this@@287 T@U) ) (!  (=> (and (and (= (type $ly@@717) LayerTypeType) (= (type this@@287) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| this@@287) ($Is this@@287 Tclass.PivotBetree.Path))) (and (and (and (PivotBetree.Path.Path_q this@@287) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@287))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@287)) (and (and (and (PivotBetree.Path.Path_q this@@287) (PivotBetree.Path.Path_q this@@287)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@287) (PivotBetree.Path.key this@@287))) (=> (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@287) (PivotBetree.Path.key this@@287)) (and (and (PivotBetree.Path.Path_q this@@287) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@287)) (and (PivotBetree.Path.Path_q this@@287) (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@287))))) (=> (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@287)) (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@287))) (and (PivotBetree.Path.Path_q this@@287) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@287)) (and (|PivotBetree.Path.Subpath#canCall| this@@287) (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@287))))))))))) (= (PivotBetree.Path.Valid ($LS $ly@@717) this@@287)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@287)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@287) (PivotBetree.Path.key this@@287))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@287)) (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@287)))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@287)) (PivotBetree.Path.Valid $ly@@717 (PivotBetree.Path.Subpath this@@287)))))))
 :qid |PivotBetreeidfy.471:15|
 :skolemid |6978|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@717) this@@287))
))))
(assert  (=> true (forall (($ly@@718 T@U) (this@@288 T@U) ) (!  (=> (and (and (= (type $ly@@718) LayerTypeType) (= (type this@@288) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| (Lit this@@288)) ($Is this@@288 Tclass.PivotBetree.Path))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@288)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.Path.node (Lit this@@288))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Path.node (Lit this@@288))))))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@288)) (PivotBetree.Path.Path_q (Lit this@@288))) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit (PivotBetree.Path.node (Lit this@@288))) (Lit (PivotBetree.Path.key (Lit this@@288))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@288))) (Lit (PivotBetree.Path.key (Lit this@@288))))))) (and (and (PivotBetree.Path.Path_q (Lit this@@288)) (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@288)))))) (and (PivotBetree.Path.Path_q (Lit this@@288)) (|PivotBetree.BetreeNode.IsIndex#canCall| (Lit (PivotBetree.Path.node (Lit this@@288))))))) (=> (U_2_bool (Lit (bool_2_U  (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@288))) (PivotBetree.BetreeNode.IsIndex (Lit (PivotBetree.Path.node (Lit this@@288)))))))) (and (PivotBetree.Path.Path_q (Lit this@@288)) (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@288)))))) (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@288)) (|PivotBetree.Path.Valid#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@288))))))))))))) (= (PivotBetree.Path.Valid ($LS $ly@@718) (Lit this@@288)) (U_2_bool (Lit (bool_2_U  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Path.node (Lit this@@288)))) (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@288))) (Lit (PivotBetree.Path.key (Lit this@@288))))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@288))) (PivotBetree.BetreeNode.IsIndex (Lit (PivotBetree.Path.node (Lit this@@288)))))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@288))) (PivotBetree.Path.Valid ($LS $ly@@718) (Lit (PivotBetree.Path.Subpath (Lit this@@288))))))))))))
 :qid |PivotBetreeidfy.471:15|
 :weight 3
 :skolemid |6979|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@718) (Lit this@@288)))
))))
(assert (forall (($ly@@719 T@U) (this@@289 T@U) ) (!  (=> (and (= (type $ly@@719) LayerTypeType) (= (type this@@289) DatatypeTypeType)) (= (PivotBetree.Path.Target ($LS $ly@@719) this@@289) (PivotBetree.Path.Target $ly@@719 this@@289)))
 :qid |PivotBetreeidfy.480:14|
 :skolemid |6980|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@719) this@@289))
)))
(assert (forall (($ly@@720 T@U) (this@@290 T@U) ) (!  (=> (and (= (type $ly@@720) LayerTypeType) (= (type this@@290) DatatypeTypeType)) (= (PivotBetree.Path.Target $ly@@720 this@@290) (PivotBetree.Path.Target $LZ this@@290)))
 :qid |PivotBetreeidfy.480:14|
 :skolemid |6981|
 :pattern ( (PivotBetree.Path.Target (AsFuelBottom $ly@@720) this@@290))
)))
(assert  (=> true (forall (($ly@@721 T@U) (this@@291 T@U) ) (!  (=> (and (and (= (type $ly@@721) LayerTypeType) (= (type this@@291) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| this@@291) (and ($Is this@@291 Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) this@@291)))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target $ly@@721 this@@291)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target $ly@@721 this@@291))) ($Is (PivotBetree.Path.Target $ly@@721 this@@291) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.480:14|
 :skolemid |6982|
 :pattern ( (PivotBetree.Path.Target $ly@@721 this@@291))
))))
(assert (forall (($ly@@722 T@U) (this@@292 T@U) ) (!  (=> (and (and (= (type $ly@@722) LayerTypeType) (= (type this@@292) DatatypeTypeType)) ($Is this@@292 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Target#requires| $ly@@722 this@@292) (PivotBetree.Path.Valid ($LS $LZ) this@@292)))
 :qid |PivotBetreeidfy.480:14|
 :skolemid |6983|
 :pattern ( (|PivotBetree.Path.Target#requires| $ly@@722 this@@292))
)))
(assert  (=> true (forall (($ly@@723 T@U) (this@@293 T@U) ) (!  (=> (and (and (= (type $ly@@723) LayerTypeType) (= (type this@@293) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| this@@293) (and ($Is this@@293 Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) this@@293)))) (and (and (and (PivotBetree.Path.Path_q this@@293) (=> (= (LitInt 0) (PivotBetree.Path.depth this@@293)) (PivotBetree.Path.Path_q this@@293))) (=> (not (= (LitInt 0) (PivotBetree.Path.depth this@@293))) (and (|PivotBetree.Path.Subpath#canCall| this@@293) (|PivotBetree.Path.Target#canCall| (PivotBetree.Path.Subpath this@@293))))) (= (PivotBetree.Path.Target ($LS $ly@@723) this@@293) (ite (= (LitInt 0) (PivotBetree.Path.depth this@@293)) (PivotBetree.Path.node this@@293) (PivotBetree.Path.Target $ly@@723 (PivotBetree.Path.Subpath this@@293))))))
 :qid |PivotBetreeidfy.480:14|
 :skolemid |6984|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@723) this@@293))
))))
(assert  (=> true (forall (($ly@@724 T@U) (this@@294 T@U) ) (!  (=> (and (and (= (type $ly@@724) LayerTypeType) (= (type this@@294) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| (Lit this@@294)) (and ($Is this@@294 Tclass.PivotBetree.Path) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@294)))))))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@294)) (=> (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@294)))) (PivotBetree.Path.Path_q (Lit this@@294)))) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@294))))) (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@294)) (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@294))))))) (= (PivotBetree.Path.Target ($LS $ly@@724) (Lit this@@294)) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@294)))) (PivotBetree.Path.node (Lit this@@294)) (PivotBetree.Path.Target ($LS $ly@@724) (Lit (PivotBetree.Path.Subpath (Lit this@@294))))))))
 :qid |PivotBetreeidfy.480:14|
 :weight 3
 :skolemid |6985|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@724) (Lit this@@294)))
))))
(assert  (=> true (forall ((this@@295 T@U) (|otherChildren#0| T@U) ) (!  (=> (and (and (= (type this@@295) DatatypeTypeType) (= (type |otherChildren#0|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@295 |otherChildren#0|) (and (and ($Is this@@295 Tclass.PivotBetree.Path) ($Is |otherChildren#0| (TSeq Tclass.PivotBetree.BetreeNode))) (and (PivotBetree.Path.Valid ($LS $LZ) this@@295) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@295)))))) true)
 :qid |PivotBetreeidfy.491:15|
 :skolemid |6986|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains this@@295 |otherChildren#0|))
))))
(assert (forall ((this@@296 T@U) (|otherChildren#0@@0| T@U) ) (!  (=> (and (and (= (type this@@296) DatatypeTypeType) (= (type |otherChildren#0@@0|) (SeqType BoxType))) (and ($Is this@@296 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@0| (TSeq Tclass.PivotBetree.BetreeNode)))) (= (|PivotBetree.Path.ChildrenHaveMatchingDomains#requires| this@@296 |otherChildren#0@@0|)  (and (PivotBetree.Path.Valid ($LS $LZ) this@@296) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@296)))))
 :qid |PivotBetreeidfy.491:15|
 :skolemid |6987|
 :pattern ( (|PivotBetree.Path.ChildrenHaveMatchingDomains#requires| this@@296 |otherChildren#0@@0|))
)))
(assert  (=> true (forall ((this@@297 T@U) (|otherChildren#0@@1| T@U) ) (!  (=> (and (and (= (type this@@297) DatatypeTypeType) (= (type |otherChildren#0@@1|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@297 |otherChildren#0@@1|) (and (and ($Is this@@297 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@1| (TSeq Tclass.PivotBetree.BetreeNode))) (and (PivotBetree.Path.Valid ($LS $LZ) this@@297) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@297)))))) (and (and (|PivotBetree.__default.WFChildren#canCall| |otherChildren#0@@1|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) |otherChildren#0@@1|) (and (PivotBetree.Path.Path_q this@@297) (=> (= (|Seq#Length| |otherChildren#0@@1|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)))) (forall ((|i#0@@180| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@180|) (and (and (PivotBetree.Path.Path_q this@@297) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.node this@@297) |i#0@@180|)) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@297) |i#0@@180|) (and (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|))) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)) |i#0@@180|))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|))) (and (PivotBetree.Path.Path_q this@@297) (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)) |i#0@@180|))))))))))))
 :qid |PivotBetreeidfy.498:18|
 :skolemid |6989|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)) |i#0@@180|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@180|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@297) |i#0@@180|))
)))))) (= (PivotBetree.Path.ChildrenHaveMatchingDomains this@@297 |otherChildren#0@@1|)  (and (and (PivotBetree.__default.WFChildren ($LS $LZ) |otherChildren#0@@1|) (= (|Seq#Length| |otherChildren#0@@1|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297))))) (forall ((|i#0@@181| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@181|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@297) |i#0@@181|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@181|))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@181|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@181|))) (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)) |i#0@@181|))))))
 :qid |PivotBetreeidfy.498:18|
 :skolemid |6988|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@297)) |i#0@@181|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@181|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@297) |i#0@@181|))
))))))
 :qid |PivotBetreeidfy.491:15|
 :skolemid |6990|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains this@@297 |otherChildren#0@@1|))
))))
(assert  (=> true (forall ((this@@298 T@U) (|otherChildren#0@@2| T@U) ) (!  (=> (and (and (= (type this@@298) DatatypeTypeType) (= (type |otherChildren#0@@2|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| (Lit this@@298) (Lit |otherChildren#0@@2|)) (and (and ($Is this@@298 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@2| (TSeq Tclass.PivotBetree.BetreeNode))) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@298))))) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@298)))))))))) (and (and (|PivotBetree.__default.WFChildren#canCall| (Lit |otherChildren#0@@2|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.__default.WFChildren ($LS $LZ) (Lit |otherChildren#0@@2|))))) (and (PivotBetree.Path.Path_q (Lit this@@298)) (=> (= (|Seq#Length| (Lit |otherChildren#0@@2|)) (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@298))))))) (forall ((|i#1@@70| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@70|) (and (and (PivotBetree.Path.Path_q (Lit this@@298)) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit (PivotBetree.Path.node (Lit this@@298))) |i#1@@70|)) (=> (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.node (Lit this@@298))) |i#1@@70|) (and (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@70|))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@70|))) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@70|))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@70|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@298))))) |i#1@@70|))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@70|))) (and (PivotBetree.Path.Path_q (Lit this@@298)) (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@298))))) |i#1@@70|))))))))))))
 :qid |PivotBetreeidfy.498:18|
 :skolemid |6992|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@298)) |i#1@@70|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@2| |i#1@@70|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@298) |i#1@@70|))
)))))) (= (PivotBetree.Path.ChildrenHaveMatchingDomains (Lit this@@298) (Lit |otherChildren#0@@2|))  (and (and (PivotBetree.__default.WFChildren ($LS $LZ) (Lit |otherChildren#0@@2|)) (= (|Seq#Length| (Lit |otherChildren#0@@2|)) (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@298)))))))) (forall ((|i#1@@71| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@71|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.node (Lit this@@298))) |i#1@@71|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@71|))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@71|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@71|))) (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@298))))) |i#1@@71|))))))
 :qid |PivotBetreeidfy.498:18|
 :skolemid |6991|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@298)) |i#1@@71|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@2| |i#1@@71|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@298) |i#1@@71|))
))))))
 :qid |PivotBetreeidfy.491:15|
 :weight 3
 :skolemid |6993|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains (Lit this@@298) (Lit |otherChildren#0@@2|)))
))))
(assert (forall ((arg0@@676 T@U) (arg1@@356 T@U) (arg2@@176 T@U) ) (! (= (type (PivotBetree.Path.ReplacedChildren arg0@@676 arg1@@356 arg2@@176)) (SeqType BoxType))
 :qid |funType:PivotBetree.Path.ReplacedChildren|
 :pattern ( (PivotBetree.Path.ReplacedChildren arg0@@676 arg1@@356 arg2@@176))
)))
(assert (forall (($ly@@725 T@U) (this@@299 T@U) (|replacement#0| T@U) ) (!  (=> (and (and (= (type $ly@@725) LayerTypeType) (= (type this@@299) DatatypeTypeType)) (= (type |replacement#0|) DatatypeTypeType)) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@725) this@@299 |replacement#0|) (PivotBetree.Path.ReplacedChildren $ly@@725 this@@299 |replacement#0|)))
 :qid |PivotBetreeidfy.505:14|
 :skolemid |6994|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@725) this@@299 |replacement#0|))
)))
(assert (forall (($ly@@726 T@U) (this@@300 T@U) (|replacement#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@726) LayerTypeType) (= (type this@@300) DatatypeTypeType)) (= (type |replacement#0@@0|) DatatypeTypeType)) (= (PivotBetree.Path.ReplacedChildren $ly@@726 this@@300 |replacement#0@@0|) (PivotBetree.Path.ReplacedChildren $LZ this@@300 |replacement#0@@0|)))
 :qid |PivotBetreeidfy.505:14|
 :skolemid |6995|
 :pattern ( (PivotBetree.Path.ReplacedChildren (AsFuelBottom $ly@@726) this@@300 |replacement#0@@0|))
)))
(assert  (=> true (forall (($ly@@727 T@U) (this@@301 T@U) (|replacement#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@727) LayerTypeType) (= (type this@@301) DatatypeTypeType)) (= (type |replacement#0@@1|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| this@@301 |replacement#0@@1|) (and (and ($Is this@@301 Tclass.PivotBetree.Path) ($Is |replacement#0@@1| Tclass.PivotBetree.BetreeNode)) (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@301) (PivotBetree.Path.ValidReplacement this@@301 |replacement#0@@1|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@301)))))) (and (PivotBetree.Path.ChildrenHaveMatchingDomains this@@301 (PivotBetree.Path.ReplacedChildren $ly@@727 this@@301 |replacement#0@@1|)) ($Is (PivotBetree.Path.ReplacedChildren $ly@@727 this@@301 |replacement#0@@1|) (TSeq Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreeidfy.505:14|
 :skolemid |6996|
 :pattern ( (PivotBetree.Path.ReplacedChildren $ly@@727 this@@301 |replacement#0@@1|))
))))
(assert (forall (($ly@@728 T@U) (this@@302 T@U) (|replacement#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@728) LayerTypeType) (= (type this@@302) DatatypeTypeType)) (= (type |replacement#0@@2|) DatatypeTypeType)) (and ($Is this@@302 Tclass.PivotBetree.Path) ($Is |replacement#0@@2| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.ReplacedChildren#requires| $ly@@728 this@@302 |replacement#0@@2|)  (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@302) (PivotBetree.Path.ValidReplacement this@@302 |replacement#0@@2|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@302)))))
 :qid |PivotBetreeidfy.505:14|
 :skolemid |6997|
 :pattern ( (|PivotBetree.Path.ReplacedChildren#requires| $ly@@728 this@@302 |replacement#0@@2|))
)))
(assert (forall ((arg0@@677 T@U) (arg1@@357 T@U) (arg2@@177 T@U) ) (! (= (type (PivotBetree.Path.Substitute arg0@@677 arg1@@357 arg2@@177)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Substitute|
 :pattern ( (PivotBetree.Path.Substitute arg0@@677 arg1@@357 arg2@@177))
)))
(assert  (=> true (forall (($ly@@729 T@U) (this@@303 T@U) (|replacement#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@729) LayerTypeType) (= (type this@@303) DatatypeTypeType)) (= (type |replacement#0@@3|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| this@@303 |replacement#0@@3|) (and (and ($Is this@@303 Tclass.PivotBetree.Path) ($Is |replacement#0@@3| Tclass.PivotBetree.BetreeNode)) (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@303) (PivotBetree.Path.ValidReplacement this@@303 |replacement#0@@3|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@303)))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| this@@303) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Path.Subpath this@@303) |replacement#0@@3|)) (and (PivotBetree.Path.Path_q this@@303) (and (and (PivotBetree.Path.Path_q this@@303) (PivotBetree.Path.Path_q this@@303)) (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@303)) (PivotBetree.Path.key this@@303))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@729) this@@303 |replacement#0@@3|) (let ((|newChild#0@@0| (PivotBetree.Path.Substitute $ly@@729 (PivotBetree.Path.Subpath this@@303) |replacement#0@@3|)))
(|Seq#Update| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@303)) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@303)) (PivotBetree.Path.key this@@303)) ($Box |newChild#0@@0|))))))
 :qid |PivotBetreeidfy.505:14|
 :skolemid |6998|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@729) this@@303 |replacement#0@@3|))
))))
(assert  (=> true (forall (($ly@@730 T@U) (this@@304 T@U) (|replacement#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@730) LayerTypeType) (= (type this@@304) DatatypeTypeType)) (= (type |replacement#0@@4|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@304) |replacement#0@@4|) (and (and ($Is this@@304 Tclass.PivotBetree.Path) ($Is |replacement#0@@4| Tclass.PivotBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@304))))) (PivotBetree.Path.ValidReplacement (Lit this@@304) |replacement#0@@4|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@304)))))))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@304)) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@304))) |replacement#0@@4|)) (and (PivotBetree.Path.Path_q (Lit this@@304)) (and (and (PivotBetree.Path.Path_q (Lit this@@304)) (PivotBetree.Path.Path_q (Lit this@@304))) (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@304))))) (Lit (PivotBetree.Path.key (Lit this@@304))))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@730) (Lit this@@304) |replacement#0@@4|) (let ((|newChild#1@@0| (PivotBetree.Path.Substitute ($LS $ly@@730) (Lit (PivotBetree.Path.Subpath (Lit this@@304))) |replacement#0@@4|)))
(|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@304))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@304))))) (Lit (PivotBetree.Path.key (Lit this@@304))))) ($Box |newChild#1@@0|))))))
 :qid |PivotBetreeidfy.505:14|
 :weight 3
 :skolemid |6999|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@730) (Lit this@@304) |replacement#0@@4|))
))))
(assert  (=> true (forall (($ly@@731 T@U) (this@@305 T@U) (|replacement#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@731) LayerTypeType) (= (type this@@305) DatatypeTypeType)) (= (type |replacement#0@@5|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@305) (Lit |replacement#0@@5|)) (and (and ($Is this@@305 Tclass.PivotBetree.Path) ($Is |replacement#0@@5| Tclass.PivotBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@305))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.ValidReplacement (Lit this@@305) (Lit |replacement#0@@5|)))))) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@305)))))))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@305)) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@305))) (Lit |replacement#0@@5|))) (and (PivotBetree.Path.Path_q (Lit this@@305)) (and (and (PivotBetree.Path.Path_q (Lit this@@305)) (PivotBetree.Path.Path_q (Lit this@@305))) (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@305))))) (Lit (PivotBetree.Path.key (Lit this@@305))))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@731) (Lit this@@305) (Lit |replacement#0@@5|)) (let ((|newChild#2| (Lit (PivotBetree.Path.Substitute ($LS $ly@@731) (Lit (PivotBetree.Path.Subpath (Lit this@@305))) (Lit |replacement#0@@5|)))))
(|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@305))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@305))))) (Lit (PivotBetree.Path.key (Lit this@@305))))) ($Box |newChild#2|))))))
 :qid |PivotBetreeidfy.505:14|
 :weight 3
 :skolemid |7000|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@731) (Lit this@@305) (Lit |replacement#0@@5|)))
))))
(assert  (=> true (forall ((this@@306 T@U) (|replacement#0@@6| T@U) ) (!  (=> (and (and (= (type this@@306) DatatypeTypeType) (= (type |replacement#0@@6|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| this@@306 |replacement#0@@6|) (and (and ($Is this@@306 Tclass.PivotBetree.Path) ($Is |replacement#0@@6| Tclass.PivotBetree.BetreeNode)) (PivotBetree.Path.Valid ($LS $LZ) this@@306)))) true)
 :qid |PivotBetreeidfy.519:15|
 :skolemid |7001|
 :pattern ( (PivotBetree.Path.ValidReplacement this@@306 |replacement#0@@6|))
))))
(assert (forall ((this@@307 T@U) (|replacement#0@@7| T@U) ) (!  (=> (and (and (= (type this@@307) DatatypeTypeType) (= (type |replacement#0@@7|) DatatypeTypeType)) (and ($Is this@@307 Tclass.PivotBetree.Path) ($Is |replacement#0@@7| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.ValidReplacement#requires| this@@307 |replacement#0@@7|) (PivotBetree.Path.Valid ($LS $LZ) this@@307)))
 :qid |PivotBetreeidfy.519:15|
 :skolemid |7002|
 :pattern ( (|PivotBetree.Path.ValidReplacement#requires| this@@307 |replacement#0@@7|))
)))
(assert  (=> true (forall ((this@@308 T@U) (|replacement#0@@8| T@U) ) (!  (=> (and (and (= (type this@@308) DatatypeTypeType) (= (type |replacement#0@@8|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| this@@308 |replacement#0@@8|) (and (and ($Is this@@308 Tclass.PivotBetree.Path) ($Is |replacement#0@@8| Tclass.PivotBetree.BetreeNode)) (PivotBetree.Path.Valid ($LS $LZ) this@@308)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@8|) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@8|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@8|) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain |replacement#0@@8|)) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS $LZ) this@@308)))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| |replacement#0@@8|) (and (|PivotBetree.Path.Target#canCall| this@@308) (|PivotBetree.BetreeNode.MyDomain#canCall| (PivotBetree.Path.Target ($LS $LZ) this@@308)))))))) (= (PivotBetree.Path.ValidReplacement this@@308 |replacement#0@@8|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@8|) (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@8|)) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |replacement#0@@8|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS $LZ) this@@308)))))))
 :qid |PivotBetreeidfy.519:15|
 :skolemid |7003|
 :pattern ( (PivotBetree.Path.ValidReplacement this@@308 |replacement#0@@8|))
))))
(assert  (=> true (forall ((this@@309 T@U) (|replacement#0@@9| T@U) ) (!  (=> (and (and (= (type this@@309) DatatypeTypeType) (= (type |replacement#0@@9|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| (Lit this@@309) (Lit |replacement#0@@9|)) (and (and ($Is this@@309 Tclass.PivotBetree.Path) ($Is |replacement#0@@9| Tclass.PivotBetree.BetreeNode)) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@309)))))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit |replacement#0@@9|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@9|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |replacement#0@@9|))))) (and (and (|$IsA#DomainMod.Domain| (Lit (PivotBetree.BetreeNode.MyDomain (Lit |replacement#0@@9|)))) (|$IsA#DomainMod.Domain| (Lit (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@309))))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit |replacement#0@@9|)) (and (|PivotBetree.Path.Target#canCall| (Lit this@@309)) (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@309)))))))))) (= (PivotBetree.Path.ValidReplacement (Lit this@@309) (Lit |replacement#0@@9|))  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@9|)) (PivotBetree.BetreeNode.BetreeNode_q (Lit |replacement#0@@9|))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (Lit |replacement#0@@9|)) (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@309)))))))))
 :qid |PivotBetreeidfy.519:15|
 :weight 3
 :skolemid |7004|
 :pattern ( (PivotBetree.Path.ValidReplacement (Lit this@@309) (Lit |replacement#0@@9|)))
))))
(assert (forall (($ly@@732 T@U) (this@@310 T@U) (|replacement#0@@10| T@U) ) (!  (=> (and (and (= (type $ly@@732) LayerTypeType) (= (type this@@310) DatatypeTypeType)) (= (type |replacement#0@@10|) DatatypeTypeType)) (= (PivotBetree.Path.Substitute ($LS $ly@@732) this@@310 |replacement#0@@10|) (PivotBetree.Path.Substitute $ly@@732 this@@310 |replacement#0@@10|)))
 :qid |PivotBetreeidfy.527:14|
 :skolemid |7005|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@732) this@@310 |replacement#0@@10|))
)))
(assert (forall (($ly@@733 T@U) (this@@311 T@U) (|replacement#0@@11| T@U) ) (!  (=> (and (and (= (type $ly@@733) LayerTypeType) (= (type this@@311) DatatypeTypeType)) (= (type |replacement#0@@11|) DatatypeTypeType)) (= (PivotBetree.Path.Substitute $ly@@733 this@@311 |replacement#0@@11|) (PivotBetree.Path.Substitute $LZ this@@311 |replacement#0@@11|)))
 :qid |PivotBetreeidfy.527:14|
 :skolemid |7006|
 :pattern ( (PivotBetree.Path.Substitute (AsFuelBottom $ly@@733) this@@311 |replacement#0@@11|))
)))
(assert  (=> true (forall (($ly@@734 T@U) (this@@312 T@U) (|replacement#0@@12| T@U) ) (!  (=> (and (and (and (= (type $ly@@734) LayerTypeType) (= (type this@@312) DatatypeTypeType)) (= (type |replacement#0@@12|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| this@@312 |replacement#0@@12|) (and (and ($Is this@@312 Tclass.PivotBetree.Path) ($Is |replacement#0@@12| Tclass.PivotBetree.BetreeNode)) (and (PivotBetree.Path.Valid ($LS $LZ) this@@312) (PivotBetree.Path.ValidReplacement this@@312 |replacement#0@@12|))))) ($Is (PivotBetree.Path.Substitute $ly@@734 this@@312 |replacement#0@@12|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreeidfy.527:14|
 :skolemid |7007|
 :pattern ( (PivotBetree.Path.Substitute $ly@@734 this@@312 |replacement#0@@12|))
))))
(assert (forall (($ly@@735 T@U) (this@@313 T@U) (|replacement#0@@13| T@U) ) (!  (=> (and (and (and (= (type $ly@@735) LayerTypeType) (= (type this@@313) DatatypeTypeType)) (= (type |replacement#0@@13|) DatatypeTypeType)) (and ($Is this@@313 Tclass.PivotBetree.Path) ($Is |replacement#0@@13| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.Substitute#requires| $ly@@735 this@@313 |replacement#0@@13|)  (and (PivotBetree.Path.Valid ($LS $LZ) this@@313) (PivotBetree.Path.ValidReplacement this@@313 |replacement#0@@13|))))
 :qid |PivotBetreeidfy.527:14|
 :skolemid |7008|
 :pattern ( (|PivotBetree.Path.Substitute#requires| $ly@@735 this@@313 |replacement#0@@13|))
)))
(assert  (=> true (forall (($ly@@736 T@U) (this@@314 T@U) (|replacement#0@@14| T@U) ) (!  (=> (and (and (and (= (type $ly@@736) LayerTypeType) (= (type this@@314) DatatypeTypeType)) (= (type |replacement#0@@14|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| this@@314 |replacement#0@@14|) (and (and ($Is this@@314 Tclass.PivotBetree.Path) ($Is |replacement#0@@14| Tclass.PivotBetree.BetreeNode)) (and (PivotBetree.Path.Valid ($LS $LZ) this@@314) (PivotBetree.Path.ValidReplacement this@@314 |replacement#0@@14|))))) (and (and (PivotBetree.Path.Path_q this@@314) (=> (not (= (LitInt 0) (PivotBetree.Path.depth this@@314))) (and (and (PivotBetree.Path.Path_q this@@314) (PivotBetree.Path.Path_q this@@314)) (|PivotBetree.Path.ReplacedChildren#canCall| this@@314 |replacement#0@@14|)))) (= (PivotBetree.Path.Substitute ($LS $ly@@736) this@@314 |replacement#0@@14|) (ite (= (LitInt 0) (PivotBetree.Path.depth this@@314)) |replacement#0@@14| (|#PivotBetree.BetreeNode.BetreeNode| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.node this@@314)) (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@314)) (PivotBetree.Path.ReplacedChildren $ly@@736 this@@314 |replacement#0@@14|))))))
 :qid |PivotBetreeidfy.527:14|
 :skolemid |7009|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@736) this@@314 |replacement#0@@14|))
))))
(assert  (=> true (forall (($ly@@737 T@U) (this@@315 T@U) (|replacement#0@@15| T@U) ) (!  (=> (and (and (and (= (type $ly@@737) LayerTypeType) (= (type this@@315) DatatypeTypeType)) (= (type |replacement#0@@15|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| (Lit this@@315) |replacement#0@@15|) (and (and ($Is this@@315 Tclass.PivotBetree.Path) ($Is |replacement#0@@15| Tclass.PivotBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@315))))) (PivotBetree.Path.ValidReplacement (Lit this@@315) |replacement#0@@15|))))) (and (and (PivotBetree.Path.Path_q (Lit this@@315)) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@315))))) (and (and (PivotBetree.Path.Path_q (Lit this@@315)) (PivotBetree.Path.Path_q (Lit this@@315))) (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@315) |replacement#0@@15|)))) (= (PivotBetree.Path.Substitute ($LS $ly@@737) (Lit this@@315) |replacement#0@@15|) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@315)))) |replacement#0@@15| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.node (Lit this@@315))))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@315))))) (PivotBetree.Path.ReplacedChildren ($LS $ly@@737) (Lit this@@315) |replacement#0@@15|))))))
 :qid |PivotBetreeidfy.527:14|
 :weight 3
 :skolemid |7010|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@737) (Lit this@@315) |replacement#0@@15|))
))))
(assert  (=> true (forall (($ly@@738 T@U) (this@@316 T@U) (|replacement#0@@16| T@U) ) (!  (=> (and (and (and (= (type $ly@@738) LayerTypeType) (= (type this@@316) DatatypeTypeType)) (= (type |replacement#0@@16|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| (Lit this@@316) (Lit |replacement#0@@16|)) (and (and ($Is this@@316 Tclass.PivotBetree.Path) ($Is |replacement#0@@16| Tclass.PivotBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@316))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.ValidReplacement (Lit this@@316) (Lit |replacement#0@@16|))))))))) (and (and (PivotBetree.Path.Path_q (Lit this@@316)) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@316))))) (and (and (PivotBetree.Path.Path_q (Lit this@@316)) (PivotBetree.Path.Path_q (Lit this@@316))) (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@316) (Lit |replacement#0@@16|))))) (= (PivotBetree.Path.Substitute ($LS $ly@@738) (Lit this@@316) (Lit |replacement#0@@16|)) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@316)))) |replacement#0@@16| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.node (Lit this@@316))))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@316))))) (Lit (PivotBetree.Path.ReplacedChildren ($LS $ly@@738) (Lit this@@316) (Lit |replacement#0@@16|))))))))
 :qid |PivotBetreeidfy.527:14|
 :weight 3
 :skolemid |7011|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@738) (Lit this@@316) (Lit |replacement#0@@16|)))
))))
(assert (forall ((arg0@@678 T@U) ) (! (= (type (|#PivotBetree.Step.QueryStep| arg0@@678)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.QueryStep|
 :pattern ( (|#PivotBetree.Step.QueryStep| arg0@@678))
)))
(assert (forall ((|a#0#0#0@@12| T@U) ) (!  (=> (= (type |a#0#0#0@@12|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.Step.QueryStep| |a#0#0#0@@12|)) |##PivotBetree.Step.QueryStep|))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7012|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#0#0#0@@12|))
)))
(assert (forall ((d@@151 T@U) ) (!  (=> (= (type d@@151) DatatypeTypeType) (= (PivotBetree.Step.QueryStep_q d@@151) (= (DatatypeCtorId d@@151) |##PivotBetree.Step.QueryStep|)))
 :qid |unknown.0:0|
 :skolemid |7013|
 :pattern ( (PivotBetree.Step.QueryStep_q d@@151))
)))
(assert (forall ((d@@152 T@U) ) (!  (=> (and (= (type d@@152) DatatypeTypeType) (PivotBetree.Step.QueryStep_q d@@152)) (exists ((|a#1#0#0@@12| T@U) ) (!  (and (= (type |a#1#0#0@@12|) DatatypeTypeType) (= d@@152 (|#PivotBetree.Step.QueryStep| |a#1#0#0@@12|)))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7014|
 :no-pattern (type |a#1#0#0@@12|)
 :no-pattern (U_2_int |a#1#0#0@@12|)
 :no-pattern (U_2_bool |a#1#0#0@@12|)
)))
 :qid |unknown.0:0|
 :skolemid |7015|
 :pattern ( (PivotBetree.Step.QueryStep_q d@@152))
)))
(assert (forall ((|a#2#0#0@@12| T@U) ) (!  (=> (= (type |a#2#0#0@@12|) DatatypeTypeType) (= ($Is (|#PivotBetree.Step.QueryStep| |a#2#0#0@@12|) Tclass.PivotBetree.Step) ($Is |a#2#0#0@@12| Tclass.PivotBetree.QueryReceipt)))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7016|
 :pattern ( ($Is (|#PivotBetree.Step.QueryStep| |a#2#0#0@@12|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#3#0#0@@12| T@U) ($h@@163 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@12|) DatatypeTypeType) (= (type $h@@163) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@163)) (= ($IsAlloc (|#PivotBetree.Step.QueryStep| |a#3#0#0@@12|) Tclass.PivotBetree.Step $h@@163) ($IsAlloc |a#3#0#0@@12| Tclass.PivotBetree.QueryReceipt $h@@163)))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7017|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.QueryStep| |a#3#0#0@@12|) Tclass.PivotBetree.Step $h@@163))
)))
(assert (forall ((d@@153 T@U) ($h@@164 T@U) ) (!  (=> (and (and (= (type d@@153) DatatypeTypeType) (= (type $h@@164) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@164) (and (PivotBetree.Step.QueryStep_q d@@153) ($IsAlloc d@@153 Tclass.PivotBetree.Step $h@@164)))) ($IsAlloc (PivotBetree.Step.receipt d@@153) Tclass.PivotBetree.QueryReceipt $h@@164))
 :qid |unknown.0:0|
 :skolemid |7018|
 :pattern ( ($IsAlloc (PivotBetree.Step.receipt d@@153) Tclass.PivotBetree.QueryReceipt $h@@164))
)))
(assert (forall ((|a#4#0#0@@12| T@U) ) (!  (=> (= (type |a#4#0#0@@12|) DatatypeTypeType) (= (|#PivotBetree.Step.QueryStep| (Lit |a#4#0#0@@12|)) (Lit (|#PivotBetree.Step.QueryStep| |a#4#0#0@@12|))))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7019|
 :pattern ( (|#PivotBetree.Step.QueryStep| (Lit |a#4#0#0@@12|)))
)))
(assert (forall ((|a#5#0#0@@14| T@U) ) (!  (=> (= (type |a#5#0#0@@14|) DatatypeTypeType) (= (PivotBetree.Step.receipt (|#PivotBetree.Step.QueryStep| |a#5#0#0@@14|)) |a#5#0#0@@14|))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7020|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#5#0#0@@14|))
)))
(assert (forall ((|a#6#0#0@@14| T@U) ) (!  (=> (= (type |a#6#0#0@@14|) DatatypeTypeType) (< (DtRank |a#6#0#0@@14|) (DtRank (|#PivotBetree.Step.QueryStep| |a#6#0#0@@14|))))
 :qid |PivotBetreeidfy.604:17|
 :skolemid |7021|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#6#0#0@@14|))
)))
(assert (= (type |#PivotBetree.Step.PutStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.PutStep|) |##PivotBetree.Step.PutStep|))
(assert (forall ((d@@154 T@U) ) (!  (=> (= (type d@@154) DatatypeTypeType) (= (PivotBetree.Step.PutStep_q d@@154) (= (DatatypeCtorId d@@154) |##PivotBetree.Step.PutStep|)))
 :qid |unknown.0:0|
 :skolemid |7022|
 :pattern ( (PivotBetree.Step.PutStep_q d@@154))
)))
(assert (forall ((d@@155 T@U) ) (!  (=> (and (= (type d@@155) DatatypeTypeType) (PivotBetree.Step.PutStep_q d@@155)) (= d@@155 |#PivotBetree.Step.PutStep|))
 :qid |unknown.0:0|
 :skolemid |7023|
 :pattern ( (PivotBetree.Step.PutStep_q d@@155))
)))
(assert ($Is |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@165 T@U) ) (!  (=> (and (= (type $h@@165) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@165)) ($IsAlloc |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step $h@@165))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7024|
 :pattern ( ($IsAlloc |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step $h@@165))
)))
(assert (= |#PivotBetree.Step.PutStep| (Lit |#PivotBetree.Step.PutStep|)))
(assert (= (type |#PivotBetree.Step.QueryEndLsnStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.QueryEndLsnStep|) |##PivotBetree.Step.QueryEndLsnStep|))
(assert (forall ((d@@156 T@U) ) (!  (=> (= (type d@@156) DatatypeTypeType) (= (PivotBetree.Step.QueryEndLsnStep_q d@@156) (= (DatatypeCtorId d@@156) |##PivotBetree.Step.QueryEndLsnStep|)))
 :qid |unknown.0:0|
 :skolemid |7025|
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@156))
)))
(assert (forall ((d@@157 T@U) ) (!  (=> (and (= (type d@@157) DatatypeTypeType) (PivotBetree.Step.QueryEndLsnStep_q d@@157)) (= d@@157 |#PivotBetree.Step.QueryEndLsnStep|))
 :qid |unknown.0:0|
 :skolemid |7026|
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@157))
)))
(assert ($Is |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@166 T@U) ) (!  (=> (and (= (type $h@@166) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@166)) ($IsAlloc |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step $h@@166))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7027|
 :pattern ( ($IsAlloc |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step $h@@166))
)))
(assert (= |#PivotBetree.Step.QueryEndLsnStep| (Lit |#PivotBetree.Step.QueryEndLsnStep|)))
(assert (= (type |#PivotBetree.Step.FreezeAsStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.FreezeAsStep|) |##PivotBetree.Step.FreezeAsStep|))
(assert (forall ((d@@158 T@U) ) (!  (=> (= (type d@@158) DatatypeTypeType) (= (PivotBetree.Step.FreezeAsStep_q d@@158) (= (DatatypeCtorId d@@158) |##PivotBetree.Step.FreezeAsStep|)))
 :qid |unknown.0:0|
 :skolemid |7028|
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@158))
)))
(assert (forall ((d@@159 T@U) ) (!  (=> (and (= (type d@@159) DatatypeTypeType) (PivotBetree.Step.FreezeAsStep_q d@@159)) (= d@@159 |#PivotBetree.Step.FreezeAsStep|))
 :qid |unknown.0:0|
 :skolemid |7029|
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@159))
)))
(assert ($Is |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@167 T@U) ) (!  (=> (and (= (type $h@@167) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@167)) ($IsAlloc |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step $h@@167))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7030|
 :pattern ( ($IsAlloc |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step $h@@167))
)))
(assert (= |#PivotBetree.Step.FreezeAsStep| (Lit |#PivotBetree.Step.FreezeAsStep|)))
(assert (= (type |#PivotBetree.Step.InternalGrowStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalGrowStep|) |##PivotBetree.Step.InternalGrowStep|))
(assert (forall ((d@@160 T@U) ) (!  (=> (= (type d@@160) DatatypeTypeType) (= (PivotBetree.Step.InternalGrowStep_q d@@160) (= (DatatypeCtorId d@@160) |##PivotBetree.Step.InternalGrowStep|)))
 :qid |unknown.0:0|
 :skolemid |7031|
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@160))
)))
(assert (forall ((d@@161 T@U) ) (!  (=> (and (= (type d@@161) DatatypeTypeType) (PivotBetree.Step.InternalGrowStep_q d@@161)) (= d@@161 |#PivotBetree.Step.InternalGrowStep|))
 :qid |unknown.0:0|
 :skolemid |7032|
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@161))
)))
(assert ($Is |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@168 T@U) ) (!  (=> (and (= (type $h@@168) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@168)) ($IsAlloc |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step $h@@168))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7033|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step $h@@168))
)))
(assert (= |#PivotBetree.Step.InternalGrowStep| (Lit |#PivotBetree.Step.InternalGrowStep|)))
(assert (forall ((arg0@@679 T@U) (arg1@@358 T@U) ) (! (= (type (|#PivotBetree.Step.InternalSplitStep| arg0@@679 arg1@@358)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalSplitStep|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| arg0@@679 arg1@@358))
)))
(assert (forall ((|a#27#0#0@@0| T@U) (|a#27#1#0| T@U) ) (!  (=> (and (= (type |a#27#0#0@@0|) DatatypeTypeType) (= (type |a#27#1#0|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Step.InternalSplitStep| |a#27#0#0@@0| |a#27#1#0|)) |##PivotBetree.Step.InternalSplitStep|))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7034|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#27#0#0@@0| |a#27#1#0|))
)))
(assert (forall ((d@@162 T@U) ) (!  (=> (= (type d@@162) DatatypeTypeType) (= (PivotBetree.Step.InternalSplitStep_q d@@162) (= (DatatypeCtorId d@@162) |##PivotBetree.Step.InternalSplitStep|)))
 :qid |unknown.0:0|
 :skolemid |7035|
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@162))
)))
(assert (forall ((d@@163 T@U) ) (!  (=> (and (= (type d@@163) DatatypeTypeType) (PivotBetree.Step.InternalSplitStep_q d@@163)) (exists ((|a#28#0#0@@0| T@U) (|a#28#1#0| T@U) ) (!  (and (and (= (type |a#28#0#0@@0|) DatatypeTypeType) (= (type |a#28#1#0|) DatatypeTypeType)) (= d@@163 (|#PivotBetree.Step.InternalSplitStep| |a#28#0#0@@0| |a#28#1#0|)))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7036|
 :no-pattern (type |a#28#0#0@@0|)
 :no-pattern (type |a#28#1#0|)
 :no-pattern (U_2_int |a#28#0#0@@0|)
 :no-pattern (U_2_bool |a#28#0#0@@0|)
 :no-pattern (U_2_int |a#28#1#0|)
 :no-pattern (U_2_bool |a#28#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |7037|
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@163))
)))
(assert (forall ((|a#29#0#0@@0| T@U) (|a#29#1#0| T@U) ) (!  (=> (and (= (type |a#29#0#0@@0|) DatatypeTypeType) (= (type |a#29#1#0|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Step.InternalSplitStep| |a#29#0#0@@0| |a#29#1#0|) Tclass.PivotBetree.Step)  (and ($Is |a#29#0#0@@0| Tclass.PivotBetree.Path) ($Is |a#29#1#0| Tclass.SplitRequestMod.SplitRequest))))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7038|
 :pattern ( ($Is (|#PivotBetree.Step.InternalSplitStep| |a#29#0#0@@0| |a#29#1#0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#30#0#0@@0| T@U) (|a#30#1#0| T@U) ($h@@169 T@U) ) (!  (=> (and (and (and (= (type |a#30#0#0@@0|) DatatypeTypeType) (= (type |a#30#1#0|) DatatypeTypeType)) (= (type $h@@169) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@169)) (= ($IsAlloc (|#PivotBetree.Step.InternalSplitStep| |a#30#0#0@@0| |a#30#1#0|) Tclass.PivotBetree.Step $h@@169)  (and ($IsAlloc |a#30#0#0@@0| Tclass.PivotBetree.Path $h@@169) ($IsAlloc |a#30#1#0| Tclass.SplitRequestMod.SplitRequest $h@@169))))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7039|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalSplitStep| |a#30#0#0@@0| |a#30#1#0|) Tclass.PivotBetree.Step $h@@169))
)))
(assert (forall ((d@@164 T@U) ($h@@170 T@U) ) (!  (=> (and (and (= (type d@@164) DatatypeTypeType) (= (type $h@@170) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@170) (and (PivotBetree.Step.InternalSplitStep_q d@@164) ($IsAlloc d@@164 Tclass.PivotBetree.Step $h@@170)))) ($IsAlloc (PivotBetree.Step.path d@@164) Tclass.PivotBetree.Path $h@@170))
 :qid |unknown.0:0|
 :skolemid |7040|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@164) Tclass.PivotBetree.Path $h@@170))
)))
(assert (forall ((d@@165 T@U) ($h@@171 T@U) ) (!  (=> (and (and (= (type d@@165) DatatypeTypeType) (= (type $h@@171) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@171) (and (PivotBetree.Step.InternalSplitStep_q d@@165) ($IsAlloc d@@165 Tclass.PivotBetree.Step $h@@171)))) ($IsAlloc (PivotBetree.Step.request d@@165) Tclass.SplitRequestMod.SplitRequest $h@@171))
 :qid |unknown.0:0|
 :skolemid |7041|
 :pattern ( ($IsAlloc (PivotBetree.Step.request d@@165) Tclass.SplitRequestMod.SplitRequest $h@@171))
)))
(assert (forall ((|a#31#0#0@@0| T@U) (|a#31#1#0| T@U) ) (!  (=> (and (= (type |a#31#0#0@@0|) DatatypeTypeType) (= (type |a#31#1#0|) DatatypeTypeType)) (= (|#PivotBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@0|) (Lit |a#31#1#0|)) (Lit (|#PivotBetree.Step.InternalSplitStep| |a#31#0#0@@0| |a#31#1#0|))))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7042|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@0|) (Lit |a#31#1#0|)))
)))
(assert (forall ((|a#32#0#0@@0| T@U) (|a#32#1#0| T@U) ) (!  (=> (and (= (type |a#32#0#0@@0|) DatatypeTypeType) (= (type |a#32#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalSplitStep| |a#32#0#0@@0| |a#32#1#0|)) |a#32#0#0@@0|))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7043|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#32#0#0@@0| |a#32#1#0|))
)))
(assert (forall ((|a#33#0#0@@0| T@U) (|a#33#1#0| T@U) ) (!  (=> (and (= (type |a#33#0#0@@0|) DatatypeTypeType) (= (type |a#33#1#0|) DatatypeTypeType)) (< (DtRank |a#33#0#0@@0|) (DtRank (|#PivotBetree.Step.InternalSplitStep| |a#33#0#0@@0| |a#33#1#0|))))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7044|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#33#0#0@@0| |a#33#1#0|))
)))
(assert (forall ((|a#34#0#0@@0| T@U) (|a#34#1#0| T@U) ) (!  (=> (and (= (type |a#34#0#0@@0|) DatatypeTypeType) (= (type |a#34#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.request (|#PivotBetree.Step.InternalSplitStep| |a#34#0#0@@0| |a#34#1#0|)) |a#34#1#0|))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7045|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#34#0#0@@0| |a#34#1#0|))
)))
(assert (forall ((|a#35#0#0@@0| T@U) (|a#35#1#0| T@U) ) (!  (=> (and (= (type |a#35#0#0@@0|) DatatypeTypeType) (= (type |a#35#1#0|) DatatypeTypeType)) (< (DtRank |a#35#1#0|) (DtRank (|#PivotBetree.Step.InternalSplitStep| |a#35#0#0@@0| |a#35#1#0|))))
 :qid |PivotBetreeidfy.609:25|
 :skolemid |7046|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#35#0#0@@0| |a#35#1#0|))
)))
(assert (= (type |#PivotBetree.Step.InternalFlushMemtableStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalFlushMemtableStep|) |##PivotBetree.Step.InternalFlushMemtableStep|))
(assert (forall ((d@@166 T@U) ) (!  (=> (= (type d@@166) DatatypeTypeType) (= (PivotBetree.Step.InternalFlushMemtableStep_q d@@166) (= (DatatypeCtorId d@@166) |##PivotBetree.Step.InternalFlushMemtableStep|)))
 :qid |unknown.0:0|
 :skolemid |7047|
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@166))
)))
(assert (forall ((d@@167 T@U) ) (!  (=> (and (= (type d@@167) DatatypeTypeType) (PivotBetree.Step.InternalFlushMemtableStep_q d@@167)) (= d@@167 |#PivotBetree.Step.InternalFlushMemtableStep|))
 :qid |unknown.0:0|
 :skolemid |7048|
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@167))
)))
(assert ($Is |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@172 T@U) ) (!  (=> (and (= (type $h@@172) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@172)) ($IsAlloc |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step $h@@172))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7049|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step $h@@172))
)))
(assert (= |#PivotBetree.Step.InternalFlushMemtableStep| (Lit |#PivotBetree.Step.InternalFlushMemtableStep|)))
(assert (forall ((arg0@@680 T@U) (arg1@@359 Int) ) (! (= (type (|#PivotBetree.Step.InternalFlushStep| arg0@@680 arg1@@359)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalFlushStep|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| arg0@@680 arg1@@359))
)))
(assert (forall ((|a#41#0#0@@0| T@U) (|a#41#1#0| Int) ) (!  (=> (= (type |a#41#0#0@@0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.Step.InternalFlushStep| |a#41#0#0@@0| |a#41#1#0|)) |##PivotBetree.Step.InternalFlushStep|))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7050|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#41#0#0@@0| |a#41#1#0|))
)))
(assert (forall ((d@@168 T@U) ) (!  (=> (= (type d@@168) DatatypeTypeType) (= (PivotBetree.Step.InternalFlushStep_q d@@168) (= (DatatypeCtorId d@@168) |##PivotBetree.Step.InternalFlushStep|)))
 :qid |unknown.0:0|
 :skolemid |7051|
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@168))
)))
(assert (forall ((d@@169 T@U) ) (!  (=> (and (= (type d@@169) DatatypeTypeType) (PivotBetree.Step.InternalFlushStep_q d@@169)) (exists ((|a#42#0#0| T@U) (|a#42#1#0| Int) ) (!  (and (= (type |a#42#0#0|) DatatypeTypeType) (= d@@169 (|#PivotBetree.Step.InternalFlushStep| |a#42#0#0| |a#42#1#0|)))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7052|
 :no-pattern (type |a#42#0#0|)
 :no-pattern (U_2_int |a#42#0#0|)
 :no-pattern (U_2_bool |a#42#0#0|)
)))
 :qid |unknown.0:0|
 :skolemid |7053|
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@169))
)))
(assert (forall ((|a#43#0#0| T@U) (|a#43#1#0| Int) ) (!  (=> (= (type |a#43#0#0|) DatatypeTypeType) (= ($Is (|#PivotBetree.Step.InternalFlushStep| |a#43#0#0| |a#43#1#0|) Tclass.PivotBetree.Step)  (and ($Is |a#43#0#0| Tclass.PivotBetree.Path) ($Is (int_2_U |a#43#1#0|) Tclass._System.nat))))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7054|
 :pattern ( ($Is (|#PivotBetree.Step.InternalFlushStep| |a#43#0#0| |a#43#1#0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#44#0#0| T@U) (|a#44#1#0| Int) ($h@@173 T@U) ) (!  (=> (and (and (= (type |a#44#0#0|) DatatypeTypeType) (= (type $h@@173) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@173)) (= ($IsAlloc (|#PivotBetree.Step.InternalFlushStep| |a#44#0#0| |a#44#1#0|) Tclass.PivotBetree.Step $h@@173)  (and ($IsAlloc |a#44#0#0| Tclass.PivotBetree.Path $h@@173) ($IsAlloc (int_2_U |a#44#1#0|) Tclass._System.nat $h@@173))))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7055|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalFlushStep| |a#44#0#0| |a#44#1#0|) Tclass.PivotBetree.Step $h@@173))
)))
(assert (forall ((d@@170 T@U) ($h@@174 T@U) ) (!  (=> (and (and (= (type d@@170) DatatypeTypeType) (= (type $h@@174) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@174) (and (PivotBetree.Step.InternalFlushStep_q d@@170) ($IsAlloc d@@170 Tclass.PivotBetree.Step $h@@174)))) ($IsAlloc (PivotBetree.Step.path d@@170) Tclass.PivotBetree.Path $h@@174))
 :qid |unknown.0:0|
 :skolemid |7056|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@170) Tclass.PivotBetree.Path $h@@174))
)))
(assert (forall ((d@@171 T@U) ($h@@175 T@U) ) (!  (=> (and (and (= (type d@@171) DatatypeTypeType) (= (type $h@@175) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@175) (and (PivotBetree.Step.InternalFlushStep_q d@@171) ($IsAlloc d@@171 Tclass.PivotBetree.Step $h@@175)))) ($IsAlloc (int_2_U (PivotBetree.Step.childIdx d@@171)) Tclass._System.nat $h@@175))
 :qid |unknown.0:0|
 :skolemid |7057|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.Step.childIdx d@@171)) Tclass._System.nat $h@@175))
)))
(assert (forall ((|a#45#0#0| T@U) (|a#45#1#0| Int) ) (!  (=> (= (type |a#45#0#0|) DatatypeTypeType) (= (|#PivotBetree.Step.InternalFlushStep| (Lit |a#45#0#0|) (LitInt |a#45#1#0|)) (Lit (|#PivotBetree.Step.InternalFlushStep| |a#45#0#0| |a#45#1#0|))))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7058|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| (Lit |a#45#0#0|) (LitInt |a#45#1#0|)))
)))
(assert (forall ((|a#46#0#0| T@U) (|a#46#1#0| Int) ) (!  (=> (= (type |a#46#0#0|) DatatypeTypeType) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalFlushStep| |a#46#0#0| |a#46#1#0|)) |a#46#0#0|))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7059|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#46#0#0| |a#46#1#0|))
)))
(assert (forall ((|a#47#0#0| T@U) (|a#47#1#0| Int) ) (!  (=> (= (type |a#47#0#0|) DatatypeTypeType) (< (DtRank |a#47#0#0|) (DtRank (|#PivotBetree.Step.InternalFlushStep| |a#47#0#0| |a#47#1#0|))))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7060|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#47#0#0| |a#47#1#0|))
)))
(assert (forall ((|a#48#0#0| T@U) (|a#48#1#0| Int) ) (!  (=> (= (type |a#48#0#0|) DatatypeTypeType) (= (PivotBetree.Step.childIdx (|#PivotBetree.Step.InternalFlushStep| |a#48#0#0| |a#48#1#0|)) |a#48#1#0|))
 :qid |PivotBetreeidfy.611:25|
 :skolemid |7061|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#48#0#0| |a#48#1#0|))
)))
(assert (forall ((arg0@@681 T@U) (arg1@@360 T@U) ) (! (= (type (|#PivotBetree.Step.InternalCompactStep| arg0@@681 arg1@@360)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalCompactStep|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| arg0@@681 arg1@@360))
)))
(assert (forall ((|a#49#0#0| T@U) (|a#49#1#0| T@U) ) (!  (=> (and (= (type |a#49#0#0|) DatatypeTypeType) (= (type |a#49#1#0|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Step.InternalCompactStep| |a#49#0#0| |a#49#1#0|)) |##PivotBetree.Step.InternalCompactStep|))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7062|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#49#0#0| |a#49#1#0|))
)))
(assert (forall ((d@@172 T@U) ) (!  (=> (= (type d@@172) DatatypeTypeType) (= (PivotBetree.Step.InternalCompactStep_q d@@172) (= (DatatypeCtorId d@@172) |##PivotBetree.Step.InternalCompactStep|)))
 :qid |unknown.0:0|
 :skolemid |7063|
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@172))
)))
(assert (forall ((d@@173 T@U) ) (!  (=> (and (= (type d@@173) DatatypeTypeType) (PivotBetree.Step.InternalCompactStep_q d@@173)) (exists ((|a#50#0#0| T@U) (|a#50#1#0| T@U) ) (!  (and (and (= (type |a#50#0#0|) DatatypeTypeType) (= (type |a#50#1#0|) DatatypeTypeType)) (= d@@173 (|#PivotBetree.Step.InternalCompactStep| |a#50#0#0| |a#50#1#0|)))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7064|
 :no-pattern (type |a#50#0#0|)
 :no-pattern (type |a#50#1#0|)
 :no-pattern (U_2_int |a#50#0#0|)
 :no-pattern (U_2_bool |a#50#0#0|)
 :no-pattern (U_2_int |a#50#1#0|)
 :no-pattern (U_2_bool |a#50#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |7065|
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@173))
)))
(assert (forall ((|a#51#0#0| T@U) (|a#51#1#0| T@U) ) (!  (=> (and (= (type |a#51#0#0|) DatatypeTypeType) (= (type |a#51#1#0|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Step.InternalCompactStep| |a#51#0#0| |a#51#1#0|) Tclass.PivotBetree.Step)  (and ($Is |a#51#0#0| Tclass.PivotBetree.Path) ($Is |a#51#1#0| Tclass.Buffers.BufferStack))))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7066|
 :pattern ( ($Is (|#PivotBetree.Step.InternalCompactStep| |a#51#0#0| |a#51#1#0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#52#0#0@@0| T@U) (|a#52#1#0@@0| T@U) ($h@@176 T@U) ) (!  (=> (and (and (and (= (type |a#52#0#0@@0|) DatatypeTypeType) (= (type |a#52#1#0@@0|) DatatypeTypeType)) (= (type $h@@176) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@176)) (= ($IsAlloc (|#PivotBetree.Step.InternalCompactStep| |a#52#0#0@@0| |a#52#1#0@@0|) Tclass.PivotBetree.Step $h@@176)  (and ($IsAlloc |a#52#0#0@@0| Tclass.PivotBetree.Path $h@@176) ($IsAlloc |a#52#1#0@@0| Tclass.Buffers.BufferStack $h@@176))))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7067|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalCompactStep| |a#52#0#0@@0| |a#52#1#0@@0|) Tclass.PivotBetree.Step $h@@176))
)))
(assert (forall ((d@@174 T@U) ($h@@177 T@U) ) (!  (=> (and (and (= (type d@@174) DatatypeTypeType) (= (type $h@@177) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@177) (and (PivotBetree.Step.InternalCompactStep_q d@@174) ($IsAlloc d@@174 Tclass.PivotBetree.Step $h@@177)))) ($IsAlloc (PivotBetree.Step.path d@@174) Tclass.PivotBetree.Path $h@@177))
 :qid |unknown.0:0|
 :skolemid |7068|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@174) Tclass.PivotBetree.Path $h@@177))
)))
(assert (forall ((d@@175 T@U) ($h@@178 T@U) ) (!  (=> (and (and (= (type d@@175) DatatypeTypeType) (= (type $h@@178) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@178) (and (PivotBetree.Step.InternalCompactStep_q d@@175) ($IsAlloc d@@175 Tclass.PivotBetree.Step $h@@178)))) ($IsAlloc (PivotBetree.Step.compactedBuffers d@@175) Tclass.Buffers.BufferStack $h@@178))
 :qid |unknown.0:0|
 :skolemid |7069|
 :pattern ( ($IsAlloc (PivotBetree.Step.compactedBuffers d@@175) Tclass.Buffers.BufferStack $h@@178))
)))
(assert (forall ((|a#53#0#0@@0| T@U) (|a#53#1#0@@0| T@U) ) (!  (=> (and (= (type |a#53#0#0@@0|) DatatypeTypeType) (= (type |a#53#1#0@@0|) DatatypeTypeType)) (= (|#PivotBetree.Step.InternalCompactStep| (Lit |a#53#0#0@@0|) (Lit |a#53#1#0@@0|)) (Lit (|#PivotBetree.Step.InternalCompactStep| |a#53#0#0@@0| |a#53#1#0@@0|))))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7070|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| (Lit |a#53#0#0@@0|) (Lit |a#53#1#0@@0|)))
)))
(assert (forall ((|a#54#0#0@@0| T@U) (|a#54#1#0@@0| T@U) ) (!  (=> (and (= (type |a#54#0#0@@0|) DatatypeTypeType) (= (type |a#54#1#0@@0|) DatatypeTypeType)) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalCompactStep| |a#54#0#0@@0| |a#54#1#0@@0|)) |a#54#0#0@@0|))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7071|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#54#0#0@@0| |a#54#1#0@@0|))
)))
(assert (forall ((|a#55#0#0@@0| T@U) (|a#55#1#0@@0| T@U) ) (!  (=> (and (= (type |a#55#0#0@@0|) DatatypeTypeType) (= (type |a#55#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#55#0#0@@0|) (DtRank (|#PivotBetree.Step.InternalCompactStep| |a#55#0#0@@0| |a#55#1#0@@0|))))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7072|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#55#0#0@@0| |a#55#1#0@@0|))
)))
(assert (forall ((|a#56#0#0@@0| T@U) (|a#56#1#0@@0| T@U) ) (!  (=> (and (= (type |a#56#0#0@@0|) DatatypeTypeType) (= (type |a#56#1#0@@0|) DatatypeTypeType)) (= (PivotBetree.Step.compactedBuffers (|#PivotBetree.Step.InternalCompactStep| |a#56#0#0@@0| |a#56#1#0@@0|)) |a#56#1#0@@0|))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7073|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#56#0#0@@0| |a#56#1#0@@0|))
)))
(assert (forall ((|a#57#0#0@@0| T@U) (|a#57#1#0@@0| T@U) ) (!  (=> (and (= (type |a#57#0#0@@0|) DatatypeTypeType) (= (type |a#57#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#57#1#0@@0|) (DtRank (|#PivotBetree.Step.InternalCompactStep| |a#57#0#0@@0| |a#57#1#0@@0|))))
 :qid |PivotBetreeidfy.612:27|
 :skolemid |7074|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#57#0#0@@0| |a#57#1#0@@0|))
)))
(assert (= (type |#PivotBetree.Step.InternalNoOpStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalNoOpStep|) |##PivotBetree.Step.InternalNoOpStep|))
(assert (forall ((d@@176 T@U) ) (!  (=> (= (type d@@176) DatatypeTypeType) (= (PivotBetree.Step.InternalNoOpStep_q d@@176) (= (DatatypeCtorId d@@176) |##PivotBetree.Step.InternalNoOpStep|)))
 :qid |unknown.0:0|
 :skolemid |7075|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@176))
)))
(assert (forall ((d@@177 T@U) ) (!  (=> (and (= (type d@@177) DatatypeTypeType) (PivotBetree.Step.InternalNoOpStep_q d@@177)) (= d@@177 |#PivotBetree.Step.InternalNoOpStep|))
 :qid |unknown.0:0|
 :skolemid |7076|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@177))
)))
(assert ($Is |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@179 T@U) ) (!  (=> (and (= (type $h@@179) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@179)) ($IsAlloc |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step $h@@179))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7077|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step $h@@179))
)))
(assert (= |#PivotBetree.Step.InternalNoOpStep| (Lit |#PivotBetree.Step.InternalNoOpStep|)))
(assert (forall ((d@@178 T@U) ) (!  (=> (and (= (type d@@178) DatatypeTypeType) (|$IsA#PivotBetree.Step| d@@178)) (or (or (or (or (or (or (or (or (or (PivotBetree.Step.QueryStep_q d@@178) (PivotBetree.Step.PutStep_q d@@178)) (PivotBetree.Step.QueryEndLsnStep_q d@@178)) (PivotBetree.Step.FreezeAsStep_q d@@178)) (PivotBetree.Step.InternalGrowStep_q d@@178)) (PivotBetree.Step.InternalSplitStep_q d@@178)) (PivotBetree.Step.InternalFlushMemtableStep_q d@@178)) (PivotBetree.Step.InternalFlushStep_q d@@178)) (PivotBetree.Step.InternalCompactStep_q d@@178)) (PivotBetree.Step.InternalNoOpStep_q d@@178)))
 :qid |unknown.0:0|
 :skolemid |7078|
 :pattern ( (|$IsA#PivotBetree.Step| d@@178))
)))
(assert (forall ((d@@179 T@U) ) (!  (=> (and (= (type d@@179) DatatypeTypeType) ($Is d@@179 Tclass.PivotBetree.Step)) (or (or (or (or (or (or (or (or (or (PivotBetree.Step.QueryStep_q d@@179) (PivotBetree.Step.PutStep_q d@@179)) (PivotBetree.Step.QueryEndLsnStep_q d@@179)) (PivotBetree.Step.FreezeAsStep_q d@@179)) (PivotBetree.Step.InternalGrowStep_q d@@179)) (PivotBetree.Step.InternalSplitStep_q d@@179)) (PivotBetree.Step.InternalFlushMemtableStep_q d@@179)) (PivotBetree.Step.InternalFlushStep_q d@@179)) (PivotBetree.Step.InternalCompactStep_q d@@179)) (PivotBetree.Step.InternalNoOpStep_q d@@179)))
 :qid |unknown.0:0|
 :skolemid |7079|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.PutStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.QueryStep_q d@@179) ($Is d@@179 Tclass.PivotBetree.Step))
)))
(assert (forall ((a@@165 T@U) (b@@114 T@U) ) (!  (=> (and (and (= (type a@@165) DatatypeTypeType) (= (type b@@114) DatatypeTypeType)) (and (PivotBetree.Step.QueryStep_q a@@165) (PivotBetree.Step.QueryStep_q b@@114))) (= (|PivotBetree.Step#Equal| a@@165 b@@114) (|PivotBetree.QueryReceipt#Equal| (PivotBetree.Step.receipt a@@165) (PivotBetree.Step.receipt b@@114))))
 :qid |unknown.0:0|
 :skolemid |7080|
 :pattern ( (|PivotBetree.Step#Equal| a@@165 b@@114) (PivotBetree.Step.QueryStep_q a@@165))
 :pattern ( (|PivotBetree.Step#Equal| a@@165 b@@114) (PivotBetree.Step.QueryStep_q b@@114))
)))
(assert (forall ((a@@166 T@U) (b@@115 T@U) ) (!  (=> (and (and (= (type a@@166) DatatypeTypeType) (= (type b@@115) DatatypeTypeType)) (and (PivotBetree.Step.PutStep_q a@@166) (PivotBetree.Step.PutStep_q b@@115))) (= (|PivotBetree.Step#Equal| a@@166 b@@115) true))
 :qid |unknown.0:0|
 :skolemid |7081|
 :pattern ( (|PivotBetree.Step#Equal| a@@166 b@@115) (PivotBetree.Step.PutStep_q a@@166))
 :pattern ( (|PivotBetree.Step#Equal| a@@166 b@@115) (PivotBetree.Step.PutStep_q b@@115))
)))
(assert (forall ((a@@167 T@U) (b@@116 T@U) ) (!  (=> (and (and (= (type a@@167) DatatypeTypeType) (= (type b@@116) DatatypeTypeType)) (and (PivotBetree.Step.QueryEndLsnStep_q a@@167) (PivotBetree.Step.QueryEndLsnStep_q b@@116))) (= (|PivotBetree.Step#Equal| a@@167 b@@116) true))
 :qid |unknown.0:0|
 :skolemid |7082|
 :pattern ( (|PivotBetree.Step#Equal| a@@167 b@@116) (PivotBetree.Step.QueryEndLsnStep_q a@@167))
 :pattern ( (|PivotBetree.Step#Equal| a@@167 b@@116) (PivotBetree.Step.QueryEndLsnStep_q b@@116))
)))
(assert (forall ((a@@168 T@U) (b@@117 T@U) ) (!  (=> (and (and (= (type a@@168) DatatypeTypeType) (= (type b@@117) DatatypeTypeType)) (and (PivotBetree.Step.FreezeAsStep_q a@@168) (PivotBetree.Step.FreezeAsStep_q b@@117))) (= (|PivotBetree.Step#Equal| a@@168 b@@117) true))
 :qid |unknown.0:0|
 :skolemid |7083|
 :pattern ( (|PivotBetree.Step#Equal| a@@168 b@@117) (PivotBetree.Step.FreezeAsStep_q a@@168))
 :pattern ( (|PivotBetree.Step#Equal| a@@168 b@@117) (PivotBetree.Step.FreezeAsStep_q b@@117))
)))
(assert (forall ((a@@169 T@U) (b@@118 T@U) ) (!  (=> (and (and (= (type a@@169) DatatypeTypeType) (= (type b@@118) DatatypeTypeType)) (and (PivotBetree.Step.InternalGrowStep_q a@@169) (PivotBetree.Step.InternalGrowStep_q b@@118))) (= (|PivotBetree.Step#Equal| a@@169 b@@118) true))
 :qid |unknown.0:0|
 :skolemid |7084|
 :pattern ( (|PivotBetree.Step#Equal| a@@169 b@@118) (PivotBetree.Step.InternalGrowStep_q a@@169))
 :pattern ( (|PivotBetree.Step#Equal| a@@169 b@@118) (PivotBetree.Step.InternalGrowStep_q b@@118))
)))
(assert (forall ((a@@170 T@U) (b@@119 T@U) ) (!  (=> (and (and (= (type a@@170) DatatypeTypeType) (= (type b@@119) DatatypeTypeType)) (and (PivotBetree.Step.InternalSplitStep_q a@@170) (PivotBetree.Step.InternalSplitStep_q b@@119))) (= (|PivotBetree.Step#Equal| a@@170 b@@119)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@170) (PivotBetree.Step.path b@@119)) (|SplitRequestMod.SplitRequest#Equal| (PivotBetree.Step.request a@@170) (PivotBetree.Step.request b@@119)))))
 :qid |unknown.0:0|
 :skolemid |7085|
 :pattern ( (|PivotBetree.Step#Equal| a@@170 b@@119) (PivotBetree.Step.InternalSplitStep_q a@@170))
 :pattern ( (|PivotBetree.Step#Equal| a@@170 b@@119) (PivotBetree.Step.InternalSplitStep_q b@@119))
)))
(assert (forall ((a@@171 T@U) (b@@120 T@U) ) (!  (=> (and (and (= (type a@@171) DatatypeTypeType) (= (type b@@120) DatatypeTypeType)) (and (PivotBetree.Step.InternalFlushMemtableStep_q a@@171) (PivotBetree.Step.InternalFlushMemtableStep_q b@@120))) (= (|PivotBetree.Step#Equal| a@@171 b@@120) true))
 :qid |unknown.0:0|
 :skolemid |7086|
 :pattern ( (|PivotBetree.Step#Equal| a@@171 b@@120) (PivotBetree.Step.InternalFlushMemtableStep_q a@@171))
 :pattern ( (|PivotBetree.Step#Equal| a@@171 b@@120) (PivotBetree.Step.InternalFlushMemtableStep_q b@@120))
)))
(assert (forall ((a@@172 T@U) (b@@121 T@U) ) (!  (=> (and (and (= (type a@@172) DatatypeTypeType) (= (type b@@121) DatatypeTypeType)) (and (PivotBetree.Step.InternalFlushStep_q a@@172) (PivotBetree.Step.InternalFlushStep_q b@@121))) (= (|PivotBetree.Step#Equal| a@@172 b@@121)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@172) (PivotBetree.Step.path b@@121)) (= (PivotBetree.Step.childIdx a@@172) (PivotBetree.Step.childIdx b@@121)))))
 :qid |unknown.0:0|
 :skolemid |7087|
 :pattern ( (|PivotBetree.Step#Equal| a@@172 b@@121) (PivotBetree.Step.InternalFlushStep_q a@@172))
 :pattern ( (|PivotBetree.Step#Equal| a@@172 b@@121) (PivotBetree.Step.InternalFlushStep_q b@@121))
)))
(assert (forall ((a@@173 T@U) (b@@122 T@U) ) (!  (=> (and (and (= (type a@@173) DatatypeTypeType) (= (type b@@122) DatatypeTypeType)) (and (PivotBetree.Step.InternalCompactStep_q a@@173) (PivotBetree.Step.InternalCompactStep_q b@@122))) (= (|PivotBetree.Step#Equal| a@@173 b@@122)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@173) (PivotBetree.Step.path b@@122)) (|Buffers.BufferStack#Equal| (PivotBetree.Step.compactedBuffers a@@173) (PivotBetree.Step.compactedBuffers b@@122)))))
 :qid |unknown.0:0|
 :skolemid |7088|
 :pattern ( (|PivotBetree.Step#Equal| a@@173 b@@122) (PivotBetree.Step.InternalCompactStep_q a@@173))
 :pattern ( (|PivotBetree.Step#Equal| a@@173 b@@122) (PivotBetree.Step.InternalCompactStep_q b@@122))
)))
(assert (forall ((a@@174 T@U) (b@@123 T@U) ) (!  (=> (and (and (= (type a@@174) DatatypeTypeType) (= (type b@@123) DatatypeTypeType)) (and (PivotBetree.Step.InternalNoOpStep_q a@@174) (PivotBetree.Step.InternalNoOpStep_q b@@123))) (= (|PivotBetree.Step#Equal| a@@174 b@@123) true))
 :qid |unknown.0:0|
 :skolemid |7089|
 :pattern ( (|PivotBetree.Step#Equal| a@@174 b@@123) (PivotBetree.Step.InternalNoOpStep_q a@@174))
 :pattern ( (|PivotBetree.Step#Equal| a@@174 b@@123) (PivotBetree.Step.InternalNoOpStep_q b@@123))
)))
(assert (forall ((a@@175 T@U) (b@@124 T@U) ) (!  (=> (and (= (type a@@175) DatatypeTypeType) (= (type b@@124) DatatypeTypeType)) (= (|PivotBetree.Step#Equal| a@@175 b@@124) (= a@@175 b@@124)))
 :qid |unknown.0:0|
 :skolemid |7090|
 :pattern ( (|PivotBetree.Step#Equal| a@@175 b@@124))
)))
(assert  (=> true (forall ((this@@317 T@U) ) (!  (=> (and (= (type this@@317) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| this@@317) ($Is this@@317 Tclass.PivotBetree.Step))) true)
 :qid |PivotBetreeidfy.615:15|
 :skolemid |7091|
 :pattern ( (PivotBetree.Step.WF this@@317))
))))
(assert (forall ((this@@318 T@U) ) (!  (=> (and (= (type this@@318) DatatypeTypeType) ($Is this@@318 Tclass.PivotBetree.Step)) (= (|PivotBetree.Step.WF#requires| this@@318) true))
 :qid |PivotBetreeidfy.615:15|
 :skolemid |7092|
 :pattern ( (|PivotBetree.Step.WF#requires| this@@318))
)))
(assert  (=> true (forall ((this@@319 T@U) ) (!  (=> (and (= (type this@@319) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| this@@319) ($Is this@@319 Tclass.PivotBetree.Step))) (and (and (=> (PivotBetree.Step.QueryStep_q this@@319) (let ((|receipt#1@@0| (PivotBetree.Step.receipt this@@319)))
(|PivotBetree.QueryReceipt.Valid#canCall| |receipt#1@@0|))) (=> (not (PivotBetree.Step.QueryStep_q this@@319)) (=> (not (PivotBetree.Step.PutStep_q this@@319)) (=> (not (PivotBetree.Step.QueryEndLsnStep_q this@@319)) (=> (not (PivotBetree.Step.FreezeAsStep_q this@@319)) (=> (not (PivotBetree.Step.InternalGrowStep_q this@@319)) (and (=> (PivotBetree.Step.InternalSplitStep_q this@@319) (let ((|request#1| (PivotBetree.Step.request this@@319)))
(let ((|path#3@@0| (PivotBetree.Step.path this@@319)))
 (and (|PivotBetree.Path.Valid#canCall| |path#3@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#3@@0|) (and (and (and (|PivotBetree.Path.Target#canCall| |path#3@@0|) (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#1|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#3@@0|) (SplitRequestMod.SplitRequest.childIdx |request#1|))) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#3@@0|) (SplitRequestMod.SplitRequest.childIdx |request#1|)) (and (|PivotBetree.Path.Target#canCall| |path#3@@0|) (|PivotBetree.BetreeNode.CanSplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#3@@0|) |request#1|))))))))) (=> (not (PivotBetree.Step.InternalSplitStep_q this@@319)) (=> (not (PivotBetree.Step.InternalFlushMemtableStep_q this@@319)) (and (=> (PivotBetree.Step.InternalFlushStep_q this@@319) (let ((|childIdx#1@@0| (PivotBetree.Step.childIdx this@@319)))
(let ((|path#4@@0| (PivotBetree.Step.path this@@319)))
 (and (|PivotBetree.Path.Valid#canCall| |path#4@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#4@@0|) (and (|PivotBetree.Path.Target#canCall| |path#4@@0|) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#4@@0|) |childIdx#1@@0|))))))) (=> (not (PivotBetree.Step.InternalFlushStep_q this@@319)) (=> (PivotBetree.Step.InternalCompactStep_q this@@319) (let ((|compactedBuffers#1| (PivotBetree.Step.compactedBuffers this@@319)))
(let ((|path#5@@0| (PivotBetree.Step.path this@@319)))
 (and (|PivotBetree.Path.Valid#canCall| |path#5@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#5@@0|) (and (|PivotBetree.Path.Target#canCall| |path#5@@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#5@@0|)) (and (|PivotBetree.Path.Target#canCall| |path#5@@0|) (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#5@@0|)) |compactedBuffers#1|)))))))))))))))))))) (= (PivotBetree.Step.WF this@@319) (ite (PivotBetree.Step.QueryStep_q this@@319) (let ((|receipt#0@@4| (PivotBetree.Step.receipt this@@319)))
(PivotBetree.QueryReceipt.Valid |receipt#0@@4|)) (ite (PivotBetree.Step.PutStep_q this@@319) true (ite (PivotBetree.Step.QueryEndLsnStep_q this@@319) true (ite (PivotBetree.Step.FreezeAsStep_q this@@319) true (ite (PivotBetree.Step.InternalGrowStep_q this@@319) true (ite (PivotBetree.Step.InternalSplitStep_q this@@319) (let ((|request#0@@15| (PivotBetree.Step.request this@@319)))
(let ((|path#0@@10| (PivotBetree.Step.path this@@319)))
 (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#0@@10|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#0@@10|) (SplitRequestMod.SplitRequest.childIdx |request#0@@15|))) (PivotBetree.BetreeNode.CanSplitParent (PivotBetree.Path.Target ($LS $LZ) |path#0@@10|) |request#0@@15|)))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q this@@319) true (ite (PivotBetree.Step.InternalFlushStep_q this@@319) (let ((|childIdx#0@@16| (PivotBetree.Step.childIdx this@@319)))
(let ((|path#1@@0| (PivotBetree.Step.path this@@319)))
 (and (PivotBetree.Path.Valid ($LS $LZ) |path#1@@0|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#1@@0|) |childIdx#0@@16|)))) (ite (PivotBetree.Step.InternalCompactStep_q this@@319) (let ((|compactedBuffers#0@@0| (PivotBetree.Step.compactedBuffers this@@319)))
(let ((|path#2@@0| (PivotBetree.Step.path this@@319)))
 (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#2@@0|) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#2@@0|))) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#2@@0|)) |compactedBuffers#0@@0|)))) true))))))))))))
 :qid |PivotBetreeidfy.615:15|
 :skolemid |7093|
 :pattern ( (PivotBetree.Step.WF this@@319))
))))
(assert  (=> true (forall ((this@@320 T@U) ) (!  (=> (and (= (type this@@320) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| (Lit this@@320)) ($Is this@@320 Tclass.PivotBetree.Step))) (and (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit this@@320))))) (let ((|receipt#3@@0| (Lit (PivotBetree.Step.receipt (Lit this@@320)))))
(|PivotBetree.QueryReceipt.Valid#canCall| |receipt#3@@0|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit this@@320)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit this@@320)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit this@@320)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit this@@320)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit this@@320)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@320))))) (let ((|request#3| (Lit (PivotBetree.Step.request (Lit this@@320)))))
(let ((|path#9@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#9@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#9@@0|) (and (and (and (|PivotBetree.Path.Target#canCall| |path#9@@0|) (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#3|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#3|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#9@@0|) (SplitRequestMod.SplitRequest.childIdx |request#3|))) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#9@@0|) (SplitRequestMod.SplitRequest.childIdx |request#3|)) (and (|PivotBetree.Path.Target#canCall| |path#9@@0|) (|PivotBetree.BetreeNode.CanSplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#9@@0|) |request#3|))))))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@320)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit this@@320)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit this@@320))))) (let ((|childIdx#3@@0| (LitInt (PivotBetree.Step.childIdx (Lit this@@320)))))
(let ((|path#10@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#10@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#10@@0|) (and (|PivotBetree.Path.Target#canCall| |path#10@@0|) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#10@@0|) |childIdx#3@@0|))))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit this@@320)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit this@@320))))) (let ((|compactedBuffers#3| (Lit (PivotBetree.Step.compactedBuffers (Lit this@@320)))))
(let ((|path#11@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#11@@0|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#11@@0|) (and (|PivotBetree.Path.Target#canCall| |path#11@@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#11@@0|)) (and (|PivotBetree.Path.Target#canCall| |path#11@@0|) (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#11@@0|)) |compactedBuffers#3|)))))))))))))))))))) (= (PivotBetree.Step.WF (Lit this@@320)) (ite (PivotBetree.Step.QueryStep_q (Lit this@@320)) (U_2_bool (let ((|receipt#2@@0| (Lit (PivotBetree.Step.receipt (Lit this@@320)))))
(Lit (bool_2_U (PivotBetree.QueryReceipt.Valid |receipt#2@@0|))))) (ite (PivotBetree.Step.PutStep_q (Lit this@@320)) true (ite (PivotBetree.Step.QueryEndLsnStep_q (Lit this@@320)) true (ite (PivotBetree.Step.FreezeAsStep_q (Lit this@@320)) true (ite (PivotBetree.Step.InternalGrowStep_q (Lit this@@320)) true (ite (PivotBetree.Step.InternalSplitStep_q (Lit this@@320)) (U_2_bool (let ((|request#2| (Lit (PivotBetree.Step.request (Lit this@@320)))))
(let ((|path#6@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
(Lit (bool_2_U  (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#6@@0|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.Target ($LS $LZ) |path#6@@0|)) (LitInt (SplitRequestMod.SplitRequest.childIdx |request#2|)))) (PivotBetree.BetreeNode.CanSplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) |path#6@@0|)) |request#2|))))))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q (Lit this@@320)) true (ite (PivotBetree.Step.InternalFlushStep_q (Lit this@@320)) (U_2_bool (let ((|childIdx#2@@0| (LitInt (PivotBetree.Step.childIdx (Lit this@@320)))))
(let ((|path#7@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
(Lit (bool_2_U  (and (PivotBetree.Path.Valid ($LS $LZ) |path#7@@0|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.Target ($LS $LZ) |path#7@@0|)) |childIdx#2@@0|))))))) (ite (PivotBetree.Step.InternalCompactStep_q (Lit this@@320)) (U_2_bool (let ((|compactedBuffers#2@@0| (Lit (PivotBetree.Step.compactedBuffers (Lit this@@320)))))
(let ((|path#8@@0| (Lit (PivotBetree.Step.path (Lit this@@320)))))
(Lit (bool_2_U  (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#8@@0|) (PivotBetree.BetreeNode.BetreeNode_q (Lit (PivotBetree.Path.Target ($LS $LZ) |path#8@@0|)))) (Buffers.BufferStack.Equivalent (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.Target ($LS $LZ) |path#8@@0|)))) |compactedBuffers#2@@0|))))))) true))))))))))))
 :qid |PivotBetreeidfy.615:15|
 :weight 3
 :skolemid |7094|
 :pattern ( (PivotBetree.Step.WF (Lit this@@320)))
))))
(assert  (=> true (forall ((this@@321 T@U) ) (!  (=> (and (= (type this@@321) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| this@@321) (and ($Is this@@321 Tclass.PivotBetree.Step) (and (PivotBetree.Step.WF this@@321) (PivotBetree.Step.InternalSplitStep_q this@@321))))) ($Is (PivotBetree.Step.SplitKey this@@321) Tclass.KeyType.Key))
 :qid |PivotBetreeidfy.634:14|
 :skolemid |7095|
 :pattern ( (PivotBetree.Step.SplitKey this@@321))
))))
(assert (forall ((this@@322 T@U) ) (!  (=> (and (= (type this@@322) DatatypeTypeType) ($Is this@@322 Tclass.PivotBetree.Step)) (= (|PivotBetree.Step.SplitKey#requires| this@@322)  (and (PivotBetree.Step.WF this@@322) (PivotBetree.Step.InternalSplitStep_q this@@322))))
 :qid |PivotBetreeidfy.634:14|
 :skolemid |7096|
 :pattern ( (|PivotBetree.Step.SplitKey#requires| this@@322))
)))
(assert  (=> true (forall ((this@@323 T@U) ) (!  (=> (and (= (type this@@323) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| this@@323) (and ($Is this@@323 Tclass.PivotBetree.Step) (and (PivotBetree.Step.WF this@@323) (PivotBetree.Step.InternalSplitStep_q this@@323))))) (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path this@@323)) (|PivotBetree.BetreeNode.SplitKey#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path this@@323)) (PivotBetree.Step.request this@@323))) (= (PivotBetree.Step.SplitKey this@@323) (PivotBetree.BetreeNode.SplitKey (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path this@@323)) (PivotBetree.Step.request this@@323)))))
 :qid |PivotBetreeidfy.634:14|
 :skolemid |7097|
 :pattern ( (PivotBetree.Step.SplitKey this@@323))
))))
(assert  (=> true (forall ((this@@324 T@U) ) (!  (=> (and (= (type this@@324) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| (Lit this@@324)) (and ($Is this@@324 Tclass.PivotBetree.Step) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit this@@324))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@324))))))))) (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit this@@324)))) (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit this@@324))))) (Lit (PivotBetree.Step.request (Lit this@@324))))) (= (PivotBetree.Step.SplitKey (Lit this@@324)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit this@@324))))) (Lit (PivotBetree.Step.request (Lit this@@324))))))))
 :qid |PivotBetreeidfy.634:14|
 :weight 3
 :skolemid |7098|
 :pattern ( (PivotBetree.Step.SplitKey (Lit this@@324)))
))))
(assert (= (type Tclass.PivotBetree.__default) TyType))
(assert (= (Tag Tclass.PivotBetree.__default) Tagclass.PivotBetree.__default))
(assert (= (TagFamily Tclass.PivotBetree.__default) tytagFamily$_default))
(assert (forall ((bx@@180 T@U) ) (!  (=> (and (= (type bx@@180) BoxType) ($IsBox bx@@180 Tclass.PivotBetree.__default)) (and (= ($Box ($Unbox refType bx@@180)) bx@@180) ($Is ($Unbox refType bx@@180) Tclass.PivotBetree.__default)))
 :qid |unknown.0:0|
 :skolemid |7099|
 :pattern ( ($IsBox bx@@180 Tclass.PivotBetree.__default))
)))
(assert (forall (($o@@71 T@U) ) (!  (=> (= (type $o@@71) refType) (= ($Is $o@@71 Tclass.PivotBetree.__default)  (or (= $o@@71 null) (= (dtype $o@@71) Tclass.PivotBetree.__default))))
 :qid |unknown.0:0|
 :skolemid |7100|
 :pattern ( ($Is $o@@71 Tclass.PivotBetree.__default))
)))
(assert (forall (($o@@72 T@U) ($h@@180 T@U) ) (!  (=> (and (= (type $o@@72) refType) (= (type $h@@180) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@72 Tclass.PivotBetree.__default $h@@180)  (or (= $o@@72 null) (U_2_bool (MapType1Select (MapType0Select $h@@180 $o@@72) alloc)))))
 :qid |unknown.0:0|
 :skolemid |7101|
 :pattern ( ($IsAlloc $o@@72 Tclass.PivotBetree.__default $h@@180))
)))
(assert (forall (($ly@@739 T@U) (|children#0| T@U) ) (!  (=> (and (= (type $ly@@739) LayerTypeType) (= (type |children#0|) (SeqType BoxType))) (= (PivotBetree.__default.WFChildren ($LS $ly@@739) |children#0|) (PivotBetree.__default.WFChildren $ly@@739 |children#0|)))
 :qid |PivotBetreeidfy.38:13|
 :skolemid |7102|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@739) |children#0|))
)))
(assert (forall (($ly@@740 T@U) (|children#0@@0| T@U) ) (!  (=> (and (= (type $ly@@740) LayerTypeType) (= (type |children#0@@0|) (SeqType BoxType))) (= (PivotBetree.__default.WFChildren $ly@@740 |children#0@@0|) (PivotBetree.__default.WFChildren $LZ |children#0@@0|)))
 :qid |PivotBetreeidfy.38:13|
 :skolemid |7103|
 :pattern ( (PivotBetree.__default.WFChildren (AsFuelBottom $ly@@740) |children#0@@0|))
)))
(assert  (=> true (forall (($ly@@741 T@U) (|children#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@741) LayerTypeType) (= (type |children#0@@1|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| |children#0@@1|) ($Is |children#0@@1| (TSeq Tclass.PivotBetree.BetreeNode)))) true)
 :qid |PivotBetreeidfy.38:13|
 :skolemid |7104|
 :pattern ( (PivotBetree.__default.WFChildren $ly@@741 |children#0@@1|))
))))
(assert (forall (($ly@@742 T@U) (|children#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@742) LayerTypeType) (= (type |children#0@@2|) (SeqType BoxType))) ($Is |children#0@@2| (TSeq Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.__default.WFChildren#requires| $ly@@742 |children#0@@2|) true))
 :qid |PivotBetreeidfy.38:13|
 :skolemid |7105|
 :pattern ( (|PivotBetree.__default.WFChildren#requires| $ly@@742 |children#0@@2|))
)))
(assert  (=> true (forall (($ly@@743 T@U) (|children#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@743) LayerTypeType) (= (type |children#0@@3|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| |children#0@@3|) ($Is |children#0@@3| (TSeq Tclass.PivotBetree.BetreeNode)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@182| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@182|) (=> (INTERNAL_lt_boogie |i#0@@182| (|Seq#Length| |children#0@@3|)) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@182|)))))
 :qid |PivotBetreeidfy.40:16|
 :skolemid |7107|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@182|)))
))) (= (PivotBetree.__default.WFChildren ($LS $ly@@743) |children#0@@3|)  (and true (forall ((|i#0@@183| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@183|) (INTERNAL_lt_boogie |i#0@@183| (|Seq#Length| |children#0@@3|))) (PivotBetree.BetreeNode.WF $ly@@743 ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@183|))))
 :qid |PivotBetreeidfy.40:16|
 :skolemid |7106|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@183|)))
))))))
 :qid |PivotBetreeidfy.38:13|
 :skolemid |7108|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@743) |children#0@@3|))
))))
(assert  (=> true (forall (($ly@@744 T@U) (|children#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@744) LayerTypeType) (= (type |children#0@@4|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| (Lit |children#0@@4|)) ($Is |children#0@@4| (TSeq Tclass.PivotBetree.BetreeNode)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@72| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@72|) (=> (INTERNAL_lt_boogie |i#1@@72| (|Seq#Length| (Lit |children#0@@4|))) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |children#0@@4|) |i#1@@72|)))))
 :qid |PivotBetreeidfy.40:16|
 :skolemid |7110|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@4| |i#1@@72|)))
))) (= (PivotBetree.__default.WFChildren ($LS $ly@@744) (Lit |children#0@@4|))  (and true (forall ((|i#1@@73| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@73|) (INTERNAL_lt_boogie |i#1@@73| (|Seq#Length| (Lit |children#0@@4|)))) (PivotBetree.BetreeNode.WF ($LS $ly@@744) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |children#0@@4|) |i#1@@73|))))
 :qid |PivotBetreeidfy.40:16|
 :skolemid |7109|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@4| |i#1@@73|)))
))))))
 :qid |PivotBetreeidfy.38:13|
 :weight 3
 :skolemid |7111|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@744) (Lit |children#0@@4|)))
))))
(assert  (=> true (forall ((|domain#0@@3| T@U) ) (!  (=> (and (= (type |domain#0@@3|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@3|) (and ($Is |domain#0@@3| Tclass.DomainMod.Domain) (and (DomainMod.Domain.WF |domain#0@@3|) (DomainMod.Domain.Domain_q |domain#0@@3|))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.__default.EmptyRoot |domain#0@@3|)) ($Is (PivotBetree.__default.EmptyRoot |domain#0@@3|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.296:22|
 :skolemid |7112|
 :pattern ( (PivotBetree.__default.EmptyRoot |domain#0@@3|))
))))
(assert (forall ((|domain#0@@4| T@U) ) (!  (=> (and (= (type |domain#0@@4|) DatatypeTypeType) ($Is |domain#0@@4| Tclass.DomainMod.Domain)) (= (|PivotBetree.__default.EmptyRoot#requires| |domain#0@@4|)  (and (DomainMod.Domain.WF |domain#0@@4|) (DomainMod.Domain.Domain_q |domain#0@@4|))))
 :qid |PivotBetreeidfy.296:22|
 :skolemid |7113|
 :pattern ( (|PivotBetree.__default.EmptyRoot#requires| |domain#0@@4|))
)))
(assert  (=> true (forall ((|domain#0@@5| T@U) ) (!  (=> (and (= (type |domain#0@@5|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@5|) (and ($Is |domain#0@@5| Tclass.DomainMod.Domain) (and (DomainMod.Domain.WF |domain#0@@5|) (DomainMod.Domain.Domain_q |domain#0@@5|))))) (= (PivotBetree.__default.EmptyRoot |domain#0@@5|) (let ((|pivotTable#0| (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (DomainMod.Domain.start |domain#0@@5|))) ($Box (DomainMod.Domain.end |domain#0@@5|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) |pivotTable#0| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|))))))))
 :qid |PivotBetreeidfy.296:22|
 :skolemid |7114|
 :pattern ( (PivotBetree.__default.EmptyRoot |domain#0@@5|))
))))
(assert  (=> true (forall ((|domain#0@@6| T@U) ) (!  (=> (and (= (type |domain#0@@6|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| (Lit |domain#0@@6|)) (and ($Is |domain#0@@6| Tclass.DomainMod.Domain) (and (U_2_bool (Lit (bool_2_U (DomainMod.Domain.WF (Lit |domain#0@@6|))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Domain_q (Lit |domain#0@@6|))))))))) (= (PivotBetree.__default.EmptyRoot (Lit |domain#0@@6|)) (let ((|pivotTable#1| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (DomainMod.Domain.start (Lit |domain#0@@6|))))) ($Box (Lit (DomainMod.Domain.end (Lit |domain#0@@6|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) |pivotTable#1| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))))
 :qid |PivotBetreeidfy.296:22|
 :weight 3
 :skolemid |7115|
 :pattern ( (PivotBetree.__default.EmptyRoot (Lit |domain#0@@6|)))
))))
(assert (= (type PivotBetree.__default.EmptyImage) DatatypeTypeType))
(assert  (=> true (=> true ($Is PivotBetree.__default.EmptyImage (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))))
(assert (= |PivotBetree.__default.EmptyImage#requires| true))
(assert  (=> true (=> true (= PivotBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PivotBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert  (=> true (=> true (= PivotBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PivotBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert (forall ((arg0@@682 T@U) (arg1@@361 T@U) ) (! (= (type (PivotBetree.__default.PushMemtable arg0@@682 arg1@@361)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.PushMemtable|
 :pattern ( (PivotBetree.__default.PushMemtable arg0@@682 arg1@@361))
)))
(assert  (=> true (forall ((|root#0@@3| T@U) (|memtable#0| T@U) ) (!  (=> (and (and (= (type |root#0@@3|) DatatypeTypeType) (= (type |memtable#0|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| |root#0@@3| |memtable#0|) (and (and ($Is |root#0@@3| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0| Tclass.MemtableMod.Memtable)) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@3|)))) ($Is (PivotBetree.__default.PushMemtable |root#0@@3| |memtable#0|) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreeidfy.399:25|
 :skolemid |7116|
 :pattern ( (PivotBetree.__default.PushMemtable |root#0@@3| |memtable#0|))
))))
(assert (forall ((|root#0@@4| T@U) (|memtable#0@@0| T@U) ) (!  (=> (and (and (= (type |root#0@@4|) DatatypeTypeType) (= (type |memtable#0@@0|) DatatypeTypeType)) (and ($Is |root#0@@4| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@0| Tclass.MemtableMod.Memtable))) (= (|PivotBetree.__default.PushMemtable#requires| |root#0@@4| |memtable#0@@0|) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@4|)))
 :qid |PivotBetreeidfy.399:25|
 :skolemid |7117|
 :pattern ( (|PivotBetree.__default.PushMemtable#requires| |root#0@@4| |memtable#0@@0|))
)))
(assert  (=> true (forall ((|root#0@@5| T@U) (|memtable#0@@1| T@U) ) (!  (=> (and (and (= (type |root#0@@5|) DatatypeTypeType) (= (type |memtable#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| |root#0@@5| |memtable#0@@1|) (and (and ($Is |root#0@@5| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@1| Tclass.MemtableMod.Memtable)) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@5|)))) (and (and (MemtableMod.Memtable.Memtable_q |memtable#0@@1|) (let ((|newBuffer#0| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@1|))))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.BetreeNode.Promote#canCall| |root#0@@5| (Lit DomainMod.__default.TotalDomain))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote |root#0@@5| (Lit DomainMod.__default.TotalDomain)) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0|))))) (MemtableMod.Memtable.Memtable_q |memtable#0@@1|)))) (= (PivotBetree.__default.PushMemtable |root#0@@5| |memtable#0@@1|) (let ((|newBuffer#0@@0| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@1|))))
(|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote |root#0@@5| (Lit DomainMod.__default.TotalDomain)) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0@@0|))))) (MemtableMod.Memtable.seqEnd |memtable#0@@1|))))))
 :qid |PivotBetreeidfy.399:25|
 :skolemid |7118|
 :pattern ( (PivotBetree.__default.PushMemtable |root#0@@5| |memtable#0@@1|))
))))
(assert  (=> true (forall ((|root#0@@6| T@U) (|memtable#0@@2| T@U) ) (!  (=> (and (and (= (type |root#0@@6|) DatatypeTypeType) (= (type |memtable#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| (Lit |root#0@@6|) (Lit |memtable#0@@2|)) (and (and ($Is |root#0@@6| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@2| Tclass.MemtableMod.Memtable)) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |root#0@@6|)))))))) (and (and (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@2|)) (let ((|newBuffer#1| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@2|)))))))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.BetreeNode.Promote#canCall| (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (Lit (PivotBetree.BetreeNode.Promote (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1|))))) (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@2|))))) (= (PivotBetree.__default.PushMemtable (Lit |root#0@@6|) (Lit |memtable#0@@2|)) (let ((|newBuffer#1@@0| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@2|)))))))
(Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.BetreeNode.PushBufferStack (Lit (PivotBetree.BetreeNode.Promote (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1@@0|)))))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit |memtable#0@@2|)))))))))
 :qid |PivotBetreeidfy.399:25|
 :weight 3
 :skolemid |7119|
 :pattern ( (PivotBetree.__default.PushMemtable (Lit |root#0@@6|) (Lit |memtable#0@@2|)))
))))
(assert  (=> true (forall ((|v#0@@40| T@U) (|v'#0| T@U) (|lbl#0@@3| T@U) (|receipt#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@40|) DatatypeTypeType) (= (type |v'#0|) DatatypeTypeType)) (= (type |lbl#0@@3|) DatatypeTypeType)) (= (type |receipt#0@@5|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| |v#0@@40| |v'#0| |lbl#0@@3| |receipt#0@@5|) (and (and (and ($Is |v#0@@40| Tclass.PivotBetree.Variables) ($Is |v'#0| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@3| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@5| Tclass.PivotBetree.QueryReceipt)))) true)
 :qid |PivotBetreeidfy.415:19|
 :skolemid |7120|
 :pattern ( (PivotBetree.__default.Query |v#0@@40| |v'#0| |lbl#0@@3| |receipt#0@@5|))
))))
(assert (forall ((|v#0@@41| T@U) (|v'#0@@0| T@U) (|lbl#0@@4| T@U) (|receipt#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@41|) DatatypeTypeType) (= (type |v'#0@@0|) DatatypeTypeType)) (= (type |lbl#0@@4|) DatatypeTypeType)) (= (type |receipt#0@@6|) DatatypeTypeType)) (and (and (and ($Is |v#0@@41| Tclass.PivotBetree.Variables) ($Is |v'#0@@0| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@4| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@6| Tclass.PivotBetree.QueryReceipt))) (= (|PivotBetree.__default.Query#requires| |v#0@@41| |v'#0@@0| |lbl#0@@4| |receipt#0@@6|) true))
 :qid |PivotBetreeidfy.415:19|
 :skolemid |7121|
 :pattern ( (|PivotBetree.__default.Query#requires| |v#0@@41| |v'#0@@0| |lbl#0@@4| |receipt#0@@6|))
)))
(assert  (=> true (forall ((|v#0@@42| T@U) (|v'#0@@1| T@U) (|lbl#0@@5| T@U) (|receipt#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@42|) DatatypeTypeType) (= (type |v'#0@@1|) DatatypeTypeType)) (= (type |lbl#0@@5|) DatatypeTypeType)) (= (type |receipt#0@@7|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| |v#0@@42| |v'#0@@1| |lbl#0@@5| |receipt#0@@7|) (and (and (and ($Is |v#0@@42| Tclass.PivotBetree.Variables) ($Is |v'#0@@1| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@5| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@7| Tclass.PivotBetree.QueryReceipt)))) (and (=> (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@5|) (and (and (PivotBetree.Variables.Variables_q |v#0@@42|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@42|))) (=> (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@5|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@42|))) (and (and (PivotBetree.Variables.Variables_q |v#0@@42|) (|PivotBetree.QueryReceipt.ValidFor#canCall| |receipt#0@@7| (PivotBetree.Variables.root |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|))) (=> (PivotBetree.QueryReceipt.ValidFor |receipt#0@@7| (PivotBetree.Variables.root |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|)) (and (and (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|)) (PivotBetree.QueryReceipt.Result |receipt#0@@7|))) (and (and (and (PivotBetree.Variables.Variables_q |v#0@@42|) (|MemtableMod.Memtable.Query#canCall| (PivotBetree.Variables.memtable |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|))) (|PivotBetree.QueryReceipt.Result#canCall| |receipt#0@@7|)) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|)) (PivotBetree.QueryReceipt.Result |receipt#0@@7|)))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PivotBetree.TransitionLabel.value |lbl#0@@5|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|)) (PivotBetree.QueryReceipt.Result |receipt#0@@7|))) (and (|$IsA#PivotBetree.Variables| |v'#0@@1|) (|$IsA#PivotBetree.Variables| |v#0@@42|))))))))) (= (PivotBetree.__default.Query |v#0@@42| |v'#0@@1| |lbl#0@@5| |receipt#0@@7|)  (and (and (and (and (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@5|) (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@5|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@42|)))) (PivotBetree.QueryReceipt.ValidFor |receipt#0@@7| (PivotBetree.Variables.root |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PivotBetree.TransitionLabel.value |lbl#0@@5|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@42|) (PivotBetree.TransitionLabel.key |lbl#0@@5|)) (PivotBetree.QueryReceipt.Result |receipt#0@@7|)))) (|PivotBetree.Variables#Equal| |v'#0@@1| |v#0@@42|)))))
 :qid |PivotBetreeidfy.415:19|
 :skolemid |7122|
 :pattern ( (PivotBetree.__default.Query |v#0@@42| |v'#0@@1| |lbl#0@@5| |receipt#0@@7|))
))))
(assert  (=> true (forall ((|v#0@@43| T@U) (|v'#0@@2| T@U) (|lbl#0@@6| T@U) (|receipt#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@43|) DatatypeTypeType) (= (type |v'#0@@2|) DatatypeTypeType)) (= (type |lbl#0@@6|) DatatypeTypeType)) (= (type |receipt#0@@8|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| (Lit |v#0@@43|) (Lit |v'#0@@2|) (Lit |lbl#0@@6|) (Lit |receipt#0@@8|)) (and (and (and ($Is |v#0@@43| Tclass.PivotBetree.Variables) ($Is |v'#0@@2| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@6| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@8| Tclass.PivotBetree.QueryReceipt)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@6|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@43|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))))) (=> (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@6|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|)))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@43|)) (|PivotBetree.QueryReceipt.ValidFor#canCall| (Lit |receipt#0@@8|) (Lit (PivotBetree.Variables.root (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.ValidFor (Lit |receipt#0@@8|) (Lit (PivotBetree.Variables.root (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))))) (and (and (|$IsA#ValueMessage.Message| (Lit (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@8|)))))) (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@43|)) (|MemtableMod.Memtable.Query#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (|PivotBetree.QueryReceipt.Result#canCall| (Lit |receipt#0@@8|))) (|ValueMessage.__default.Merge#canCall| (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@8|)))))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PivotBetree.TransitionLabel.value (Lit |lbl#0@@6|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@8|))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@2|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@43|)))))))))) (= (PivotBetree.__default.Query (Lit |v#0@@43|) (Lit |v'#0@@2|) (Lit |lbl#0@@6|) (Lit |receipt#0@@8|))  (and (and (and (and (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@6|)) (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@6|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))))))) (PivotBetree.QueryReceipt.ValidFor (Lit |receipt#0@@8|) (Lit (PivotBetree.Variables.root (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PivotBetree.TransitionLabel.value (Lit |lbl#0@@6|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@43|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@6|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@8|)))))) (|PivotBetree.Variables#Equal| |v'#0@@2| |v#0@@43|)))))
 :qid |PivotBetreeidfy.415:19|
 :weight 3
 :skolemid |7123|
 :pattern ( (PivotBetree.__default.Query (Lit |v#0@@43|) (Lit |v'#0@@2|) (Lit |lbl#0@@6|) (Lit |receipt#0@@8|)))
))))
(assert  (=> true (forall ((|v#0@@44| T@U) (|v'#0@@3| T@U) (|lbl#0@@7| T@U) ) (!  (=> (and (and (and (= (type |v#0@@44|) DatatypeTypeType) (= (type |v'#0@@3|) DatatypeTypeType)) (= (type |lbl#0@@7|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| |v#0@@44| |v'#0@@3| |lbl#0@@7|) (and (and ($Is |v#0@@44| Tclass.PivotBetree.Variables) ($Is |v'#0@@3| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@7| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.424:17|
 :skolemid |7124|
 :pattern ( (PivotBetree.__default.Put |v#0@@44| |v'#0@@3| |lbl#0@@7|))
))))
(assert (forall ((|v#0@@45| T@U) (|v'#0@@4| T@U) (|lbl#0@@8| T@U) ) (!  (=> (and (and (and (= (type |v#0@@45|) DatatypeTypeType) (= (type |v'#0@@4|) DatatypeTypeType)) (= (type |lbl#0@@8|) DatatypeTypeType)) (and (and ($Is |v#0@@45| Tclass.PivotBetree.Variables) ($Is |v'#0@@4| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@8| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.Put#requires| |v#0@@45| |v'#0@@4| |lbl#0@@8|) true))
 :qid |PivotBetreeidfy.424:17|
 :skolemid |7125|
 :pattern ( (|PivotBetree.__default.Put#requires| |v#0@@45| |v'#0@@4| |lbl#0@@8|))
)))
(assert  (=> true (forall ((|v#0@@46| T@U) (|v'#0@@5| T@U) (|lbl#0@@9| T@U) ) (!  (=> (and (and (and (= (type |v#0@@46|) DatatypeTypeType) (= (type |v'#0@@5|) DatatypeTypeType)) (= (type |lbl#0@@9|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| |v#0@@46| |v'#0@@5| |lbl#0@@9|) (and (and ($Is |v#0@@46| Tclass.PivotBetree.Variables) ($Is |v'#0@@5| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@9| Tclass.PivotBetree.TransitionLabel)))) (and (=> (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@9|) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (PivotBetree.TransitionLabel.puts |lbl#0@@9|)) (=> (MsgHistoryMod.MsgHistory.WF (PivotBetree.TransitionLabel.puts |lbl#0@@9|)) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (PivotBetree.TransitionLabel.puts |lbl#0@@9|)) (and (PivotBetree.Variables.Variables_q |v#0@@46|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@46|)))) (=> (= (MsgHistoryMod.MsgHistory.seqStart (PivotBetree.TransitionLabel.puts |lbl#0@@9|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@46|))) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@5|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0| |v#0@@46|))
(let ((|dt_update#memtable#0#0| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PivotBetree.Variables.memtable |v#0@@46|) (PivotBetree.TransitionLabel.puts |lbl#0@@9|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0| (PivotBetree.Variables.root |dt_update_tmp#0#0|)))))) (let ((|dt_update_tmp#0#0@@0| |v#0@@46|))
 (and (and (PivotBetree.Variables.Variables_q |v#0@@46|) (|MemtableMod.Memtable.ApplyPuts#canCall| (PivotBetree.Variables.memtable |v#0@@46|) (PivotBetree.TransitionLabel.puts |lbl#0@@9|))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@0|))))))))) (= (PivotBetree.__default.Put |v#0@@46| |v'#0@@5| |lbl#0@@9|)  (and (and (and (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@9|) (MsgHistoryMod.MsgHistory.WF (PivotBetree.TransitionLabel.puts |lbl#0@@9|))) (= (MsgHistoryMod.MsgHistory.seqStart (PivotBetree.TransitionLabel.puts |lbl#0@@9|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@46|)))) (|PivotBetree.Variables#Equal| |v'#0@@5| (let ((|dt_update_tmp#0#0@@1| |v#0@@46|))
(let ((|dt_update#memtable#0#0@@0| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PivotBetree.Variables.memtable |v#0@@46|) (PivotBetree.TransitionLabel.puts |lbl#0@@9|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@0| (PivotBetree.Variables.root |dt_update_tmp#0#0@@1|)))))))))
 :qid |PivotBetreeidfy.424:17|
 :skolemid |7126|
 :pattern ( (PivotBetree.__default.Put |v#0@@46| |v'#0@@5| |lbl#0@@9|))
))))
(assert  (=> true (forall ((|v#0@@47| T@U) (|v'#0@@6| T@U) (|lbl#0@@10| T@U) ) (!  (=> (and (and (and (= (type |v#0@@47|) DatatypeTypeType) (= (type |v'#0@@6|) DatatypeTypeType)) (= (type |lbl#0@@10|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| (Lit |v#0@@47|) (Lit |v'#0@@6|) (Lit |lbl#0@@10|)) (and (and ($Is |v#0@@47| Tclass.PivotBetree.Variables) ($Is |v'#0@@6| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@10| Tclass.PivotBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@10|))))) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|)))) (=> (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|)))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@47|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|)))))) (=> (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|)))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@6|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1| (Lit |v#0@@47|)))
(let ((|dt_update#memtable#0#1| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1| (Lit (PivotBetree.Variables.root |dt_update_tmp#0#1|)))))))) (let ((|dt_update_tmp#0#1@@0| (Lit |v#0@@47|)))
 (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@47|)) (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@0|))))))))) (= (PivotBetree.__default.Put (Lit |v#0@@47|) (Lit |v'#0@@6|) (Lit |lbl#0@@10|))  (and (and (and (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@10|)) (MsgHistoryMod.MsgHistory.WF (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|))))))) (|PivotBetree.Variables#Equal| |v'#0@@6| (let ((|dt_update_tmp#0#1@@1| (Lit |v#0@@47|)))
(let ((|dt_update#memtable#0#1@@0| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@47|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@10|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@0| (Lit (PivotBetree.Variables.root |dt_update_tmp#0#1@@1|)))))))))))
 :qid |PivotBetreeidfy.424:17|
 :weight 3
 :skolemid |7127|
 :pattern ( (PivotBetree.__default.Put (Lit |v#0@@47|) (Lit |v'#0@@6|) (Lit |lbl#0@@10|)))
))))
(assert  (=> true (forall ((|v#0@@48| T@U) (|v'#0@@7| T@U) (|lbl#0@@11| T@U) ) (!  (=> (and (and (and (= (type |v#0@@48|) DatatypeTypeType) (= (type |v'#0@@7|) DatatypeTypeType)) (= (type |lbl#0@@11|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@48| |v'#0@@7| |lbl#0@@11|) (and (and ($Is |v#0@@48| Tclass.PivotBetree.Variables) ($Is |v'#0@@7| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@11| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.434:25|
 :skolemid |7128|
 :pattern ( (PivotBetree.__default.QueryEndLsn |v#0@@48| |v'#0@@7| |lbl#0@@11|))
))))
(assert (forall ((|v#0@@49| T@U) (|v'#0@@8| T@U) (|lbl#0@@12| T@U) ) (!  (=> (and (and (and (= (type |v#0@@49|) DatatypeTypeType) (= (type |v'#0@@8|) DatatypeTypeType)) (= (type |lbl#0@@12|) DatatypeTypeType)) (and (and ($Is |v#0@@49| Tclass.PivotBetree.Variables) ($Is |v'#0@@8| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@12| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.QueryEndLsn#requires| |v#0@@49| |v'#0@@8| |lbl#0@@12|) true))
 :qid |PivotBetreeidfy.434:25|
 :skolemid |7129|
 :pattern ( (|PivotBetree.__default.QueryEndLsn#requires| |v#0@@49| |v'#0@@8| |lbl#0@@12|))
)))
(assert  (=> true (forall ((|v#0@@50| T@U) (|v'#0@@9| T@U) (|lbl#0@@13| T@U) ) (!  (=> (and (and (and (= (type |v#0@@50|) DatatypeTypeType) (= (type |v'#0@@9|) DatatypeTypeType)) (= (type |lbl#0@@13|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@50| |v'#0@@9| |lbl#0@@13|) (and (and ($Is |v#0@@50| Tclass.PivotBetree.Variables) ($Is |v'#0@@9| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@13| Tclass.PivotBetree.TransitionLabel)))) (and (=> (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@13|) (and (and (PivotBetree.Variables.Variables_q |v#0@@50|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@50|))) (=> (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@13|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@50|))) (and (|$IsA#PivotBetree.Variables| |v'#0@@9|) (|$IsA#PivotBetree.Variables| |v#0@@50|))))) (= (PivotBetree.__default.QueryEndLsn |v#0@@50| |v'#0@@9| |lbl#0@@13|)  (and (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@13|) (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@13|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@50|)))) (|PivotBetree.Variables#Equal| |v'#0@@9| |v#0@@50|)))))
 :qid |PivotBetreeidfy.434:25|
 :skolemid |7130|
 :pattern ( (PivotBetree.__default.QueryEndLsn |v#0@@50| |v'#0@@9| |lbl#0@@13|))
))))
(assert  (=> true (forall ((|v#0@@51| T@U) (|v'#0@@10| T@U) (|lbl#0@@14| T@U) ) (!  (=> (and (and (and (= (type |v#0@@51|) DatatypeTypeType) (= (type |v'#0@@10|) DatatypeTypeType)) (= (type |lbl#0@@14|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@51|) (Lit |v'#0@@10|) (Lit |lbl#0@@14|)) (and (and ($Is |v#0@@51| Tclass.PivotBetree.Variables) ($Is |v'#0@@10| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@14| Tclass.PivotBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@14|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@51|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@51|))))) (=> (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@14|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@51|)))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@10|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@51|)))))) (= (PivotBetree.__default.QueryEndLsn (Lit |v#0@@51|) (Lit |v'#0@@10|) (Lit |lbl#0@@14|))  (and (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@14|)) (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@14|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@51|))))))) (|PivotBetree.Variables#Equal| |v'#0@@10| |v#0@@51|)))))
 :qid |PivotBetreeidfy.434:25|
 :weight 3
 :skolemid |7131|
 :pattern ( (PivotBetree.__default.QueryEndLsn (Lit |v#0@@51|) (Lit |v'#0@@10|) (Lit |lbl#0@@14|)))
))))
(assert  (=> true (forall ((|v#0@@52| T@U) (|v'#0@@11| T@U) (|lbl#0@@15| T@U) ) (!  (=> (and (and (and (= (type |v#0@@52|) DatatypeTypeType) (= (type |v'#0@@11|) DatatypeTypeType)) (= (type |lbl#0@@15|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| |v#0@@52| |v'#0@@11| |lbl#0@@15|) (and (and ($Is |v#0@@52| Tclass.PivotBetree.Variables) ($Is |v'#0@@11| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@15| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.441:22|
 :skolemid |7132|
 :pattern ( (PivotBetree.__default.FreezeAs |v#0@@52| |v'#0@@11| |lbl#0@@15|))
))))
(assert (forall ((|v#0@@53| T@U) (|v'#0@@12| T@U) (|lbl#0@@16| T@U) ) (!  (=> (and (and (and (= (type |v#0@@53|) DatatypeTypeType) (= (type |v'#0@@12|) DatatypeTypeType)) (= (type |lbl#0@@16|) DatatypeTypeType)) (and (and ($Is |v#0@@53| Tclass.PivotBetree.Variables) ($Is |v'#0@@12| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@16| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.FreezeAs#requires| |v#0@@53| |v'#0@@12| |lbl#0@@16|) true))
 :qid |PivotBetreeidfy.441:22|
 :skolemid |7133|
 :pattern ( (|PivotBetree.__default.FreezeAs#requires| |v#0@@53| |v'#0@@12| |lbl#0@@16|))
)))
(assert  (=> true (forall ((|v#0@@54| T@U) (|v'#0@@13| T@U) (|lbl#0@@17| T@U) ) (!  (=> (and (and (and (= (type |v#0@@54|) DatatypeTypeType) (= (type |v'#0@@13|) DatatypeTypeType)) (= (type |lbl#0@@17|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| |v#0@@54| |v'#0@@13| |lbl#0@@17|) (and (and ($Is |v#0@@54| Tclass.PivotBetree.Variables) ($Is |v'#0@@13| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@17| Tclass.PivotBetree.TransitionLabel)))) (and (=> (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@17|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@54|) (=> (PivotBetree.Variables.WF |v#0@@54|) (and (and (PivotBetree.Variables.Variables_q |v#0@@54|) (|MemtableMod.Memtable.IsEmpty#canCall| (PivotBetree.Variables.memtable |v#0@@54|))) (=> (MemtableMod.Memtable.IsEmpty (PivotBetree.Variables.memtable |v#0@@54|)) (and (and (|$IsA#StampedMod.Stamped| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@17|)) (and (PivotBetree.Variables.Variables_q |v#0@@54|) (and (PivotBetree.Variables.Variables_q |v#0@@54|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@54|))))) (=> (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@17|) (|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.Variables.root |v#0@@54|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@54|)))) (and (|$IsA#PivotBetree.Variables| |v'#0@@13|) (|$IsA#PivotBetree.Variables| |v#0@@54|))))))))) (= (PivotBetree.__default.FreezeAs |v#0@@54| |v'#0@@13| |lbl#0@@17|)  (and (and (and (and (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@17|) (PivotBetree.Variables.WF |v#0@@54|)) (MemtableMod.Memtable.IsEmpty (PivotBetree.Variables.memtable |v#0@@54|))) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@17|) (|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.Variables.root |v#0@@54|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@54|))))) (|PivotBetree.Variables#Equal| |v'#0@@13| |v#0@@54|)))))
 :qid |PivotBetreeidfy.441:22|
 :skolemid |7134|
 :pattern ( (PivotBetree.__default.FreezeAs |v#0@@54| |v'#0@@13| |lbl#0@@17|))
))))
(assert  (=> true (forall ((|v#0@@55| T@U) (|v'#0@@14| T@U) (|lbl#0@@18| T@U) ) (!  (=> (and (and (and (= (type |v#0@@55|) DatatypeTypeType) (= (type |v'#0@@14|) DatatypeTypeType)) (= (type |lbl#0@@18|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| (Lit |v#0@@55|) (Lit |v'#0@@14|) (Lit |lbl#0@@18|)) (and (and ($Is |v#0@@55| Tclass.PivotBetree.Variables) ($Is |v'#0@@14| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@18| Tclass.PivotBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@18|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@55|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@55|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@55|)) (|MemtableMod.Memtable.IsEmpty#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|))))) (=> (U_2_bool (Lit (bool_2_U (MemtableMod.Memtable.IsEmpty (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|))))))) (and (and (|$IsA#StampedMod.Stamped| (Lit (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@18|)))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@55|)) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@55|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|))))))) (=> (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@18|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@55|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|))))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@14|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@55|)))))))))) (= (PivotBetree.__default.FreezeAs (Lit |v#0@@55|) (Lit |v'#0@@14|) (Lit |lbl#0@@18|))  (and (and (and (and (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@18|)) (PivotBetree.Variables.WF (Lit |v#0@@55|))) (MemtableMod.Memtable.IsEmpty (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|))))) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@18|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@55|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@55|)))))))) (|PivotBetree.Variables#Equal| |v'#0@@14| |v#0@@55|)))))
 :qid |PivotBetreeidfy.441:22|
 :weight 3
 :skolemid |7135|
 :pattern ( (PivotBetree.__default.FreezeAs (Lit |v#0@@55|) (Lit |v'#0@@14|) (Lit |lbl#0@@18|)))
))))
(assert  (=> true (forall ((|v#0@@56| T@U) (|v'#0@@15| T@U) (|lbl#0@@19| T@U) ) (!  (=> (and (and (and (= (type |v#0@@56|) DatatypeTypeType) (= (type |v'#0@@15|) DatatypeTypeType)) (= (type |lbl#0@@19|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@56| |v'#0@@15| |lbl#0@@19|) (and (and ($Is |v#0@@56| Tclass.PivotBetree.Variables) ($Is |v'#0@@15| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@19| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.450:35|
 :skolemid |7136|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable |v#0@@56| |v'#0@@15| |lbl#0@@19|))
))))
(assert (forall ((|v#0@@57| T@U) (|v'#0@@16| T@U) (|lbl#0@@20| T@U) ) (!  (=> (and (and (and (= (type |v#0@@57|) DatatypeTypeType) (= (type |v'#0@@16|) DatatypeTypeType)) (= (type |lbl#0@@20|) DatatypeTypeType)) (and (and ($Is |v#0@@57| Tclass.PivotBetree.Variables) ($Is |v'#0@@16| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@20| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.InternalFlushMemtable#requires| |v#0@@57| |v'#0@@16| |lbl#0@@20|) true))
 :qid |PivotBetreeidfy.450:35|
 :skolemid |7137|
 :pattern ( (|PivotBetree.__default.InternalFlushMemtable#requires| |v#0@@57| |v'#0@@16| |lbl#0@@20|))
)))
(assert  (=> true (forall ((|v#0@@58| T@U) (|v'#0@@17| T@U) (|lbl#0@@21| T@U) ) (!  (=> (and (and (and (= (type |v#0@@58|) DatatypeTypeType) (= (type |v'#0@@17|) DatatypeTypeType)) (= (type |lbl#0@@21|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@58| |v'#0@@17| |lbl#0@@21|) (and (and ($Is |v#0@@58| Tclass.PivotBetree.Variables) ($Is |v'#0@@17| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@21| Tclass.PivotBetree.TransitionLabel)))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@21|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@58|) (=> (PivotBetree.Variables.WF |v#0@@58|) (and (and (PivotBetree.Variables.Variables_q |v#0@@58|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@58|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (and (PivotBetree.Variables.Variables_q |v#0@@58|) (=> (PivotBetree.BetreeNode.Nil_q (PivotBetree.Variables.root |v#0@@58|)) (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))))) (=> (not (PivotBetree.BetreeNode.Nil_q (PivotBetree.Variables.root |v#0@@58|))) (PivotBetree.Variables.Variables_q |v#0@@58|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@17|) (|$IsA#PivotBetree.Variables| (let ((|dt_update#root#0#0| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@58|) (PivotBetree.Variables.memtable |v#0@@58|))))))
(let ((|dt_update#memtable#0#0@@1| (MemtableMod.Memtable.Drain (PivotBetree.Variables.memtable |v#0@@58|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@1| |dt_update#root#0#0|))))) (and (and (and (and (PivotBetree.Variables.Variables_q |v#0@@58|) (PivotBetree.Variables.Variables_q |v#0@@58|)) (|PivotBetree.__default.PushMemtable#canCall| (PivotBetree.Variables.root |v#0@@58|) (PivotBetree.Variables.memtable |v#0@@58|))) (StampedMod.Stamped.Stamped_q (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@58|) (PivotBetree.Variables.memtable |v#0@@58|)))) (and (PivotBetree.Variables.Variables_q |v#0@@58|) (|MemtableMod.Memtable.Drain#canCall| (PivotBetree.Variables.memtable |v#0@@58|)))))))))))) (= (PivotBetree.__default.InternalFlushMemtable |v#0@@58| |v'#0@@17| |lbl#0@@21|)  (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@21|) (PivotBetree.Variables.WF |v#0@@58|)) (and true (and true (|PivotBetree.Variables#Equal| |v'#0@@17| (let ((|dt_update#root#0#0@@0| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@58|) (PivotBetree.Variables.memtable |v#0@@58|))))))
(let ((|dt_update#memtable#0#0@@2| (MemtableMod.Memtable.Drain (PivotBetree.Variables.memtable |v#0@@58|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@2| |dt_update#root#0#0@@0|))))))))))
 :qid |PivotBetreeidfy.450:35|
 :skolemid |7138|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable |v#0@@58| |v'#0@@17| |lbl#0@@21|))
))))
(assert  (=> true (forall ((|v#0@@59| T@U) (|v'#0@@18| T@U) (|lbl#0@@22| T@U) ) (!  (=> (and (and (and (= (type |v#0@@59|) DatatypeTypeType) (= (type |v'#0@@18|) DatatypeTypeType)) (= (type |lbl#0@@22|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@59|) (Lit |v'#0@@18|) (Lit |lbl#0@@22|)) (and (and ($Is |v#0@@59| Tclass.PivotBetree.Variables) ($Is |v'#0@@18| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@22| Tclass.PivotBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@22|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@59|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@59|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@59|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|))))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@59|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit (PivotBetree.Variables.root (Lit |v#0@@59|))))))) (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit (PivotBetree.Variables.root (Lit |v#0@@59|)))))))) (PivotBetree.Variables.Variables_q (Lit |v#0@@59|)))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@18|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update#root#0#1| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@59|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|))))))))))
(let ((|dt_update#memtable#0#1@@1| (Lit (MemtableMod.Memtable.Drain (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@1| |dt_update#root#0#1|)))))) (and (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@59|)) (PivotBetree.Variables.Variables_q (Lit |v#0@@59|))) (|PivotBetree.__default.PushMemtable#canCall| (Lit (PivotBetree.Variables.root (Lit |v#0@@59|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|))))) (StampedMod.Stamped.Stamped_q (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@59|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|))))))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@59|)) (|MemtableMod.Memtable.Drain#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|)))))))))))))) (= (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@59|) (Lit |v'#0@@18|) (Lit |lbl#0@@22|))  (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@22|)) (PivotBetree.Variables.WF (Lit |v#0@@59|))) (and true (and true (|PivotBetree.Variables#Equal| |v'#0@@18| (let ((|dt_update#root#0#1@@0| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@59|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|))))))))))
(let ((|dt_update#memtable#0#1@@2| (Lit (MemtableMod.Memtable.Drain (Lit (PivotBetree.Variables.memtable (Lit |v#0@@59|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@2| |dt_update#root#0#1@@0|)))))))))))
 :qid |PivotBetreeidfy.450:35|
 :weight 3
 :skolemid |7139|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@59|) (Lit |v'#0@@18|) (Lit |lbl#0@@22|)))
))))
(assert  (=> true (forall ((|v#0@@60| T@U) (|v'#0@@19| T@U) (|lbl#0@@23| T@U) (|step#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@60|) DatatypeTypeType) (= (type |v'#0@@19|) DatatypeTypeType)) (= (type |lbl#0@@23|) DatatypeTypeType)) (= (type |step#0@@11|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| |v#0@@60| |v'#0@@19| |lbl#0@@23| |step#0@@11|) (and (and (and ($Is |v#0@@60| Tclass.PivotBetree.Variables) ($Is |v'#0@@19| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@23| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@11| Tclass.PivotBetree.Step)))) true)
 :qid |PivotBetreeidfy.539:26|
 :skolemid |7140|
 :pattern ( (PivotBetree.__default.InternalGrow |v#0@@60| |v'#0@@19| |lbl#0@@23| |step#0@@11|))
))))
(assert (forall ((|v#0@@61| T@U) (|v'#0@@20| T@U) (|lbl#0@@24| T@U) (|step#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@61|) DatatypeTypeType) (= (type |v'#0@@20|) DatatypeTypeType)) (= (type |lbl#0@@24|) DatatypeTypeType)) (= (type |step#0@@12|) DatatypeTypeType)) (and (and (and ($Is |v#0@@61| Tclass.PivotBetree.Variables) ($Is |v'#0@@20| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@24| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@12| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalGrow#requires| |v#0@@61| |v'#0@@20| |lbl#0@@24| |step#0@@12|) true))
 :qid |PivotBetreeidfy.539:26|
 :skolemid |7141|
 :pattern ( (|PivotBetree.__default.InternalGrow#requires| |v#0@@61| |v'#0@@20| |lbl#0@@24| |step#0@@12|))
)))
(assert  (=> true (forall ((|v#0@@62| T@U) (|v'#0@@21| T@U) (|lbl#0@@25| T@U) (|step#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@62|) DatatypeTypeType) (= (type |v'#0@@21|) DatatypeTypeType)) (= (type |lbl#0@@25|) DatatypeTypeType)) (= (type |step#0@@13|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| |v#0@@62| |v'#0@@21| |lbl#0@@25| |step#0@@13|) (and (and (and ($Is |v#0@@62| Tclass.PivotBetree.Variables) ($Is |v'#0@@21| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@25| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@13| Tclass.PivotBetree.Step)))) (and (and (|PivotBetree.Variables.WF#canCall| |v#0@@62|) (=> (PivotBetree.Variables.WF |v#0@@62|) (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@25|) (=> (PivotBetree.Step.InternalGrowStep_q |step#0@@13|) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@21|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@2| |v#0@@62|))
(let ((|dt_update#root#0#0@@1| (let ((|dt_update_tmp#1#0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#0| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (PivotBetree.Variables.root |v#0@@62|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#0|)) |dt_update#children#0#0|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@2|) |dt_update#root#0#0@@1|))))) (let ((|dt_update_tmp#0#0@@3| |v#0@@62|))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))) (PivotBetree.Variables.Variables_q |v#0@@62|)) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@3|)))))))) (= (PivotBetree.__default.InternalGrow |v#0@@62| |v'#0@@21| |lbl#0@@25| |step#0@@13|)  (and (and (and (PivotBetree.Variables.WF |v#0@@62|) (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@25|)) (PivotBetree.Step.InternalGrowStep_q |step#0@@13|)) (|PivotBetree.Variables#Equal| |v'#0@@21| (let ((|dt_update_tmp#0#0@@4| |v#0@@62|))
(let ((|dt_update#root#0#0@@2| (let ((|dt_update_tmp#1#0@@0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#0@@0| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (PivotBetree.Variables.root |v#0@@62|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#0@@0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#0@@0|)) |dt_update#children#0#0@@0|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@4|) |dt_update#root#0#0@@2|))))))))
 :qid |PivotBetreeidfy.539:26|
 :skolemid |7142|
 :pattern ( (PivotBetree.__default.InternalGrow |v#0@@62| |v'#0@@21| |lbl#0@@25| |step#0@@13|))
))))
(assert  (=> true (forall ((|v#0@@63| T@U) (|v'#0@@22| T@U) (|lbl#0@@26| T@U) (|step#0@@14| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@63|) DatatypeTypeType) (= (type |v'#0@@22|) DatatypeTypeType)) (= (type |lbl#0@@26|) DatatypeTypeType)) (= (type |step#0@@14|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| (Lit |v#0@@63|) (Lit |v'#0@@22|) (Lit |lbl#0@@26|) (Lit |step#0@@14|)) (and (and (and ($Is |v#0@@63| Tclass.PivotBetree.Variables) ($Is |v'#0@@22| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@26| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@14| Tclass.PivotBetree.Step)))) (and (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@63|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@63|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@26|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@14|))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@22|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@2| (Lit |v#0@@63|)))
(let ((|dt_update#root#0#1@@1| (let ((|dt_update_tmp#1#1| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#1| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@63|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#1|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#1|)) |dt_update#children#0#1|))))))
(|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@2|)) |dt_update#root#0#1@@1|))))) (let ((|dt_update_tmp#0#1@@3| (Lit |v#0@@63|)))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))) (PivotBetree.Variables.Variables_q (Lit |v#0@@63|))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@3|)))))))) (= (PivotBetree.__default.InternalGrow (Lit |v#0@@63|) (Lit |v'#0@@22|) (Lit |lbl#0@@26|) (Lit |step#0@@14|))  (and (and (and (PivotBetree.Variables.WF (Lit |v#0@@63|)) (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@26|))) (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@14|))) (|PivotBetree.Variables#Equal| |v'#0@@22| (let ((|dt_update_tmp#0#1@@4| (Lit |v#0@@63|)))
(let ((|dt_update#root#0#1@@2| (let ((|dt_update_tmp#1#1@@0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#1@@0| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@63|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#1@@0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#1@@0|)) |dt_update#children#0#1@@0|))))))
(|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@4|)) |dt_update#root#0#1@@2|))))))))
 :qid |PivotBetreeidfy.539:26|
 :weight 3
 :skolemid |7143|
 :pattern ( (PivotBetree.__default.InternalGrow (Lit |v#0@@63|) (Lit |v'#0@@22|) (Lit |lbl#0@@26|) (Lit |step#0@@14|)))
))))
(assert  (=> true (forall ((|v#0@@64| T@U) (|v'#0@@23| T@U) (|lbl#0@@27| T@U) (|step#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@64|) DatatypeTypeType) (= (type |v'#0@@23|) DatatypeTypeType)) (= (type |lbl#0@@27|) DatatypeTypeType)) (= (type |step#0@@15|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| |v#0@@64| |v'#0@@23| |lbl#0@@27| |step#0@@15|) (and (and (and ($Is |v#0@@64| Tclass.PivotBetree.Variables) ($Is |v'#0@@23| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@27| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@15| Tclass.PivotBetree.Step)))) true)
 :qid |PivotBetreeidfy.547:27|
 :skolemid |7144|
 :pattern ( (PivotBetree.__default.InternalSplit |v#0@@64| |v'#0@@23| |lbl#0@@27| |step#0@@15|))
))))
(assert (forall ((|v#0@@65| T@U) (|v'#0@@24| T@U) (|lbl#0@@28| T@U) (|step#0@@16| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@65|) DatatypeTypeType) (= (type |v'#0@@24|) DatatypeTypeType)) (= (type |lbl#0@@28|) DatatypeTypeType)) (= (type |step#0@@16|) DatatypeTypeType)) (and (and (and ($Is |v#0@@65| Tclass.PivotBetree.Variables) ($Is |v'#0@@24| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@28| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@16| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalSplit#requires| |v#0@@65| |v'#0@@24| |lbl#0@@28| |step#0@@16|) true))
 :qid |PivotBetreeidfy.547:27|
 :skolemid |7145|
 :pattern ( (|PivotBetree.__default.InternalSplit#requires| |v#0@@65| |v'#0@@24| |lbl#0@@28| |step#0@@16|))
)))
(assert  (=> true (forall ((|v#0@@66| T@U) (|v'#0@@25| T@U) (|lbl#0@@29| T@U) (|step#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@66|) DatatypeTypeType) (= (type |v'#0@@25|) DatatypeTypeType)) (= (type |lbl#0@@29|) DatatypeTypeType)) (= (type |step#0@@17|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| |v#0@@66| |v'#0@@25| |lbl#0@@29| |step#0@@17|) (and (and (and ($Is |v#0@@66| Tclass.PivotBetree.Variables) ($Is |v'#0@@25| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@29| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@17| Tclass.PivotBetree.Step)))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@29|) (=> (PivotBetree.Step.InternalSplitStep_q |step#0@@17|) (and (|PivotBetree.Step.WF#canCall| |step#0@@17|) (=> (PivotBetree.Step.WF |step#0@@17|) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@17|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@66|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Variables.Variables_q |v#0@@66|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Variables.root |v#0@@66|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@25|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@5| |v#0@@66|))
(let ((|dt_update#root#0#0@@3| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@17|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Step.request |step#0@@17|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@5|) |dt_update#root#0#0@@3|))))) (let ((|dt_update_tmp#0#0@@6| |v#0@@66|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@17|)) (|PivotBetree.BetreeNode.SplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Step.request |step#0@@17|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@17|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Step.request |step#0@@17|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@6|)))))))))) (= (PivotBetree.__default.InternalSplit |v#0@@66| |v'#0@@25| |lbl#0@@29| |step#0@@17|)  (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@29|) (PivotBetree.Step.InternalSplitStep_q |step#0@@17|)) (PivotBetree.Step.WF |step#0@@17|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Variables.root |v#0@@66|))) (|PivotBetree.Variables#Equal| |v'#0@@25| (let ((|dt_update_tmp#0#0@@7| |v#0@@66|))
(let ((|dt_update#root#0#0@@4| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@17|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@17|)) (PivotBetree.Step.request |step#0@@17|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@7|) |dt_update#root#0#0@@4|))))))))
 :qid |PivotBetreeidfy.547:27|
 :skolemid |7146|
 :pattern ( (PivotBetree.__default.InternalSplit |v#0@@66| |v'#0@@25| |lbl#0@@29| |step#0@@17|))
))))
(assert  (=> true (forall ((|v#0@@67| T@U) (|v'#0@@26| T@U) (|lbl#0@@30| T@U) (|step#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@67|) DatatypeTypeType) (= (type |v'#0@@26|) DatatypeTypeType)) (= (type |lbl#0@@30|) DatatypeTypeType)) (= (type |step#0@@18|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| (Lit |v#0@@67|) (Lit |v'#0@@26|) (Lit |lbl#0@@30|) (Lit |step#0@@18|)) (and (and (and ($Is |v#0@@67| Tclass.PivotBetree.Variables) ($Is |v'#0@@26| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@30| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@18| Tclass.PivotBetree.Step)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@30|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@18|))))) (and (|PivotBetree.Step.WF#canCall| (Lit |step#0@@18|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@18|))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@18|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@67|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@18|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@67|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@18|)))) (PivotBetree.Variables.root (Lit |v#0@@67|))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@26|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@5| (Lit |v#0@@67|)))
(let ((|dt_update#root#0#1@@3| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@18|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@5|)) |dt_update#root#0#1@@3|)))))) (let ((|dt_update_tmp#0#1@@6| (Lit |v#0@@67|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@18|)))) (|PivotBetree.BetreeNode.SplitParent#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@18|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@18|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@18|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@6|)))))))))) (= (PivotBetree.__default.InternalSplit (Lit |v#0@@67|) (Lit |v'#0@@26|) (Lit |lbl#0@@30|) (Lit |step#0@@18|))  (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@30|)) (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@18|))) (PivotBetree.Step.WF (Lit |step#0@@18|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@18|)))) (PivotBetree.Variables.root (Lit |v#0@@67|)))) (|PivotBetree.Variables#Equal| |v'#0@@26| (let ((|dt_update_tmp#0#1@@7| (Lit |v#0@@67|)))
(let ((|dt_update#root#0#1@@4| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@18|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@18|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@7|)) |dt_update#root#0#1@@4|)))))))))
 :qid |PivotBetreeidfy.547:27|
 :weight 3
 :skolemid |7147|
 :pattern ( (PivotBetree.__default.InternalSplit (Lit |v#0@@67|) (Lit |v'#0@@26|) (Lit |lbl#0@@30|) (Lit |step#0@@18|)))
))))
(assert  (=> true (forall ((|v#0@@68| T@U) (|v'#0@@27| T@U) (|lbl#0@@31| T@U) (|step#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@68|) DatatypeTypeType) (= (type |v'#0@@27|) DatatypeTypeType)) (= (type |lbl#0@@31|) DatatypeTypeType)) (= (type |step#0@@19|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| |v#0@@68| |v'#0@@27| |lbl#0@@31| |step#0@@19|) (and (and (and ($Is |v#0@@68| Tclass.PivotBetree.Variables) ($Is |v'#0@@27| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@31| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@19| Tclass.PivotBetree.Step)))) true)
 :qid |PivotBetreeidfy.558:27|
 :skolemid |7148|
 :pattern ( (PivotBetree.__default.InternalFlush |v#0@@68| |v'#0@@27| |lbl#0@@31| |step#0@@19|))
))))
(assert (forall ((|v#0@@69| T@U) (|v'#0@@28| T@U) (|lbl#0@@32| T@U) (|step#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@69|) DatatypeTypeType) (= (type |v'#0@@28|) DatatypeTypeType)) (= (type |lbl#0@@32|) DatatypeTypeType)) (= (type |step#0@@20|) DatatypeTypeType)) (and (and (and ($Is |v#0@@69| Tclass.PivotBetree.Variables) ($Is |v'#0@@28| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@32| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@20| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalFlush#requires| |v#0@@69| |v'#0@@28| |lbl#0@@32| |step#0@@20|) true))
 :qid |PivotBetreeidfy.558:27|
 :skolemid |7149|
 :pattern ( (|PivotBetree.__default.InternalFlush#requires| |v#0@@69| |v'#0@@28| |lbl#0@@32| |step#0@@20|))
)))
(assert  (=> true (forall ((|v#0@@70| T@U) (|v'#0@@29| T@U) (|lbl#0@@33| T@U) (|step#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@70|) DatatypeTypeType) (= (type |v'#0@@29|) DatatypeTypeType)) (= (type |lbl#0@@33|) DatatypeTypeType)) (= (type |step#0@@21|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| |v#0@@70| |v'#0@@29| |lbl#0@@33| |step#0@@21|) (and (and (and ($Is |v#0@@70| Tclass.PivotBetree.Variables) ($Is |v'#0@@29| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@33| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@21| Tclass.PivotBetree.Step)))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@33|) (=> (PivotBetree.Step.InternalFlushStep_q |step#0@@21|) (and (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0@@21|)) (=> (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@21|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@70|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Variables.Variables_q |v#0@@70|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Variables.root |v#0@@70|)) (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@21|)) (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|))) (=> (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@29|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@8| |v#0@@70|))
(let ((|dt_update#root#0#0@@5| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@21|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@8|) |dt_update#root#0#0@@5|))))) (let ((|dt_update_tmp#0#0@@9| |v#0@@70|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@21|)) (|PivotBetree.BetreeNode.Flush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@21|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@9|)))))))))))) (= (PivotBetree.__default.InternalFlush |v#0@@70| |v'#0@@29| |lbl#0@@33| |step#0@@21|)  (and (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@33|) (PivotBetree.Step.InternalFlushStep_q |step#0@@21|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@21|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Variables.root |v#0@@70|))) (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|))) (|PivotBetree.Variables#Equal| |v'#0@@29| (let ((|dt_update_tmp#0#0@@10| |v#0@@70|))
(let ((|dt_update#root#0#0@@6| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@21|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@21|)) (PivotBetree.Step.childIdx |step#0@@21|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@10|) |dt_update#root#0#0@@6|))))))))
 :qid |PivotBetreeidfy.558:27|
 :skolemid |7150|
 :pattern ( (PivotBetree.__default.InternalFlush |v#0@@70| |v'#0@@29| |lbl#0@@33| |step#0@@21|))
))))
(assert  (=> true (forall ((|v#0@@71| T@U) (|v'#0@@30| T@U) (|lbl#0@@34| T@U) (|step#0@@22| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@71|) DatatypeTypeType) (= (type |v'#0@@30|) DatatypeTypeType)) (= (type |lbl#0@@34|) DatatypeTypeType)) (= (type |step#0@@22|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| (Lit |v#0@@71|) (Lit |v'#0@@30|) (Lit |lbl#0@@34|) (Lit |step#0@@22|)) (and (and (and ($Is |v#0@@71| Tclass.PivotBetree.Variables) ($Is |v'#0@@30| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@34| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@22| Tclass.PivotBetree.Step)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@34|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@22|))))) (and (|PivotBetree.Path.Valid#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@71|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@71|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (PivotBetree.Variables.root (Lit |v#0@@71|))) (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (|PivotBetree.BetreeNode.CanFlush#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanFlush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|))))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@30|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@8| (Lit |v#0@@71|)))
(let ((|dt_update#root#0#1@@5| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@8|)) |dt_update#root#0#1@@5|)))))) (let ((|dt_update_tmp#0#1@@9| (Lit |v#0@@71|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (|PivotBetree.BetreeNode.Flush#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@22|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@9|)))))))))))) (= (PivotBetree.__default.InternalFlush (Lit |v#0@@71|) (Lit |v'#0@@30|) (Lit |lbl#0@@34|) (Lit |step#0@@22|))  (and (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@34|)) (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@22|))) (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@22|)))) (PivotBetree.Variables.root (Lit |v#0@@71|)))) (PivotBetree.BetreeNode.CanFlush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|))))) (|PivotBetree.Variables#Equal| |v'#0@@30| (let ((|dt_update_tmp#0#1@@10| (Lit |v#0@@71|)))
(let ((|dt_update#root#0#1@@6| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@22|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@22|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@10|)) |dt_update#root#0#1@@6|)))))))))
 :qid |PivotBetreeidfy.558:27|
 :weight 3
 :skolemid |7151|
 :pattern ( (PivotBetree.__default.InternalFlush (Lit |v#0@@71|) (Lit |v'#0@@30|) (Lit |lbl#0@@34|) (Lit |step#0@@22|)))
))))
(assert (forall ((arg0@@683 T@U) (arg1@@362 T@U) ) (! (= (type (PivotBetree.__default.CompactedNode arg0@@683 arg1@@362)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.CompactedNode|
 :pattern ( (PivotBetree.__default.CompactedNode arg0@@683 arg1@@362))
)))
(assert  (=> true (forall ((|original#0| T@U) (|newBufs#0| T@U) ) (!  (=> (and (and (= (type |original#0|) DatatypeTypeType) (= (type |newBufs#0|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| |original#0| |newBufs#0|) (and (and ($Is |original#0| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.BetreeNode_q |original#0|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0|) |newBufs#0|))))) ($Is (PivotBetree.__default.CompactedNode |original#0| |newBufs#0|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreeidfy.570:26|
 :skolemid |7152|
 :pattern ( (PivotBetree.__default.CompactedNode |original#0| |newBufs#0|))
))))
(assert (forall ((|original#0@@0| T@U) (|newBufs#0@@0| T@U) ) (!  (=> (and (and (= (type |original#0@@0|) DatatypeTypeType) (= (type |newBufs#0@@0|) DatatypeTypeType)) (and ($Is |original#0@@0| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@0| Tclass.Buffers.BufferStack))) (= (|PivotBetree.__default.CompactedNode#requires| |original#0@@0| |newBufs#0@@0|)  (and (PivotBetree.BetreeNode.BetreeNode_q |original#0@@0|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0@@0|) |newBufs#0@@0|))))
 :qid |PivotBetreeidfy.570:26|
 :skolemid |7153|
 :pattern ( (|PivotBetree.__default.CompactedNode#requires| |original#0@@0| |newBufs#0@@0|))
)))
(assert  (=> true (forall ((|original#0@@1| T@U) (|newBufs#0@@1| T@U) ) (!  (=> (and (and (= (type |original#0@@1|) DatatypeTypeType) (= (type |newBufs#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| |original#0@@1| |newBufs#0@@1|) (and (and ($Is |original#0@@1| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@1| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.BetreeNode_q |original#0@@1|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0@@1|) |newBufs#0@@1|))))) (= (PivotBetree.__default.CompactedNode |original#0@@1| |newBufs#0@@1|) (|#PivotBetree.BetreeNode.BetreeNode| |newBufs#0@@1| (PivotBetree.BetreeNode.pivotTable |original#0@@1|) (PivotBetree.BetreeNode.children |original#0@@1|))))
 :qid |PivotBetreeidfy.570:26|
 :skolemid |7154|
 :pattern ( (PivotBetree.__default.CompactedNode |original#0@@1| |newBufs#0@@1|))
))))
(assert  (=> true (forall ((|original#0@@2| T@U) (|newBufs#0@@2| T@U) ) (!  (=> (and (and (= (type |original#0@@2|) DatatypeTypeType) (= (type |newBufs#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| (Lit |original#0@@2|) (Lit |newBufs#0@@2|)) (and (and ($Is |original#0@@2| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@2| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |original#0@@2|))))) (U_2_bool (Lit (bool_2_U (Buffers.BufferStack.Equivalent (Lit (PivotBetree.BetreeNode.buffers (Lit |original#0@@2|))) (Lit |newBufs#0@@2|))))))))) (= (PivotBetree.__default.CompactedNode (Lit |original#0@@2|) (Lit |newBufs#0@@2|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit |newBufs#0@@2|) (Lit (PivotBetree.BetreeNode.pivotTable (Lit |original#0@@2|))) (Lit (PivotBetree.BetreeNode.children (Lit |original#0@@2|)))))))
 :qid |PivotBetreeidfy.570:26|
 :weight 3
 :skolemid |7155|
 :pattern ( (PivotBetree.__default.CompactedNode (Lit |original#0@@2|) (Lit |newBufs#0@@2|)))
))))
(assert  (=> true (forall ((|v#0@@72| T@U) (|v'#0@@31| T@U) (|lbl#0@@35| T@U) (|step#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@72|) DatatypeTypeType) (= (type |v'#0@@31|) DatatypeTypeType)) (= (type |lbl#0@@35|) DatatypeTypeType)) (= (type |step#0@@23|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| |v#0@@72| |v'#0@@31| |lbl#0@@35| |step#0@@23|) (and (and (and (and ($Is |v#0@@72| Tclass.PivotBetree.Variables) ($Is |v'#0@@31| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@35| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@23| Tclass.PivotBetree.Step)) (PivotBetree.Step.WF |step#0@@23|)))) true)
 :qid |PivotBetreeidfy.577:29|
 :skolemid |7156|
 :pattern ( (PivotBetree.__default.InternalCompact |v#0@@72| |v'#0@@31| |lbl#0@@35| |step#0@@23|))
))))
(assert (forall ((|v#0@@73| T@U) (|v'#0@@32| T@U) (|lbl#0@@36| T@U) (|step#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@73|) DatatypeTypeType) (= (type |v'#0@@32|) DatatypeTypeType)) (= (type |lbl#0@@36|) DatatypeTypeType)) (= (type |step#0@@24|) DatatypeTypeType)) (and (and (and ($Is |v#0@@73| Tclass.PivotBetree.Variables) ($Is |v'#0@@32| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@36| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@24| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalCompact#requires| |v#0@@73| |v'#0@@32| |lbl#0@@36| |step#0@@24|) (PivotBetree.Step.WF |step#0@@24|)))
 :qid |PivotBetreeidfy.577:29|
 :skolemid |7157|
 :pattern ( (|PivotBetree.__default.InternalCompact#requires| |v#0@@73| |v'#0@@32| |lbl#0@@36| |step#0@@24|))
)))
(assert  (=> true (forall ((|v#0@@74| T@U) (|v'#0@@33| T@U) (|lbl#0@@37| T@U) (|step#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@74|) DatatypeTypeType) (= (type |v'#0@@33|) DatatypeTypeType)) (= (type |lbl#0@@37|) DatatypeTypeType)) (= (type |step#0@@25|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| |v#0@@74| |v'#0@@33| |lbl#0@@37| |step#0@@25|) (and (and (and (and ($Is |v#0@@74| Tclass.PivotBetree.Variables) ($Is |v'#0@@33| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@37| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@25| Tclass.PivotBetree.Step)) (PivotBetree.Step.WF |step#0@@25|)))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@37|) (=> (PivotBetree.Step.InternalCompactStep_q |step#0@@25|) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@25|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@74|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Variables.Variables_q |v#0@@74|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Variables.root |v#0@@74|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@33|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@11| |v#0@@74|))
(let ((|dt_update#root#0#0@@7| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@25|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Step.compactedBuffers |step#0@@25|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@11|) |dt_update#root#0#0@@7|))))) (let ((|dt_update_tmp#0#0@@12| |v#0@@74|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@25|)) (|PivotBetree.__default.CompactedNode#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Step.compactedBuffers |step#0@@25|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@25|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Step.compactedBuffers |step#0@@25|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@12|)))))))) (= (PivotBetree.__default.InternalCompact |v#0@@74| |v'#0@@33| |lbl#0@@37| |step#0@@25|)  (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@37|) (PivotBetree.Step.InternalCompactStep_q |step#0@@25|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Variables.root |v#0@@74|))) (|PivotBetree.Variables#Equal| |v'#0@@33| (let ((|dt_update_tmp#0#0@@13| |v#0@@74|))
(let ((|dt_update#root#0#0@@8| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@25|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@25|)) (PivotBetree.Step.compactedBuffers |step#0@@25|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@13|) |dt_update#root#0#0@@8|))))))))
 :qid |PivotBetreeidfy.577:29|
 :skolemid |7158|
 :pattern ( (PivotBetree.__default.InternalCompact |v#0@@74| |v'#0@@33| |lbl#0@@37| |step#0@@25|))
))))
(assert  (=> true (forall ((|v#0@@75| T@U) (|v'#0@@34| T@U) (|lbl#0@@38| T@U) (|step#0@@26| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@75|) DatatypeTypeType) (= (type |v'#0@@34|) DatatypeTypeType)) (= (type |lbl#0@@38|) DatatypeTypeType)) (= (type |step#0@@26|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| (Lit |v#0@@75|) (Lit |v'#0@@34|) (Lit |lbl#0@@38|) (Lit |step#0@@26|)) (and (and (and (and ($Is |v#0@@75| Tclass.PivotBetree.Variables) ($Is |v'#0@@34| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@38| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@26| Tclass.PivotBetree.Step)) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@26|)))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@38|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@26|))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@26|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@75|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@26|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@75|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@26|)))) (PivotBetree.Variables.root (Lit |v#0@@75|))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@34|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@11| (Lit |v#0@@75|)))
(let ((|dt_update#root#0#1@@7| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@26|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@11|)) |dt_update#root#0#1@@7|)))))) (let ((|dt_update_tmp#0#1@@12| (Lit |v#0@@75|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@26|)))) (|PivotBetree.__default.CompactedNode#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@26|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@26|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@26|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@12|)))))))) (= (PivotBetree.__default.InternalCompact (Lit |v#0@@75|) (Lit |v'#0@@34|) (Lit |lbl#0@@38|) (Lit |step#0@@26|))  (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@38|)) (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@26|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@26|)))) (PivotBetree.Variables.root (Lit |v#0@@75|)))) (|PivotBetree.Variables#Equal| |v'#0@@34| (let ((|dt_update_tmp#0#1@@13| (Lit |v#0@@75|)))
(let ((|dt_update#root#0#1@@8| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@26|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@26|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@13|)) |dt_update#root#0#1@@8|)))))))))
 :qid |PivotBetreeidfy.577:29|
 :weight 3
 :skolemid |7159|
 :pattern ( (PivotBetree.__default.InternalCompact (Lit |v#0@@75|) (Lit |v'#0@@34|) (Lit |lbl#0@@38|) (Lit |step#0@@26|)))
))))
(assert  (=> true (forall ((|v#0@@76| T@U) (|v'#0@@35| T@U) (|lbl#0@@39| T@U) ) (!  (=> (and (and (and (= (type |v#0@@76|) DatatypeTypeType) (= (type |v'#0@@35|) DatatypeTypeType)) (= (type |lbl#0@@39|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@76| |v'#0@@35| |lbl#0@@39|) (and (and ($Is |v#0@@76| Tclass.PivotBetree.Variables) ($Is |v'#0@@35| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@39| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.588:26|
 :skolemid |7160|
 :pattern ( (PivotBetree.__default.InternalNoOp |v#0@@76| |v'#0@@35| |lbl#0@@39|))
))))
(assert (forall ((|v#0@@77| T@U) (|v'#0@@36| T@U) (|lbl#0@@40| T@U) ) (!  (=> (and (and (and (= (type |v#0@@77|) DatatypeTypeType) (= (type |v'#0@@36|) DatatypeTypeType)) (= (type |lbl#0@@40|) DatatypeTypeType)) (and (and ($Is |v#0@@77| Tclass.PivotBetree.Variables) ($Is |v'#0@@36| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@40| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.InternalNoOp#requires| |v#0@@77| |v'#0@@36| |lbl#0@@40|) true))
 :qid |PivotBetreeidfy.588:26|
 :skolemid |7161|
 :pattern ( (|PivotBetree.__default.InternalNoOp#requires| |v#0@@77| |v'#0@@36| |lbl#0@@40|))
)))
(assert  (=> true (forall ((|v#0@@78| T@U) (|v'#0@@37| T@U) (|lbl#0@@41| T@U) ) (!  (=> (and (and (and (= (type |v#0@@78|) DatatypeTypeType) (= (type |v'#0@@37|) DatatypeTypeType)) (= (type |lbl#0@@41|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@78| |v'#0@@37| |lbl#0@@41|) (and (and ($Is |v#0@@78| Tclass.PivotBetree.Variables) ($Is |v'#0@@37| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@41| Tclass.PivotBetree.TransitionLabel)))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@41|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@78|) (=> (PivotBetree.Variables.WF |v#0@@78|) (and (|$IsA#PivotBetree.Variables| |v'#0@@37|) (|$IsA#PivotBetree.Variables| |v#0@@78|))))) (= (PivotBetree.__default.InternalNoOp |v#0@@78| |v'#0@@37| |lbl#0@@41|)  (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@41|) (PivotBetree.Variables.WF |v#0@@78|)) (|PivotBetree.Variables#Equal| |v'#0@@37| |v#0@@78|)))))
 :qid |PivotBetreeidfy.588:26|
 :skolemid |7162|
 :pattern ( (PivotBetree.__default.InternalNoOp |v#0@@78| |v'#0@@37| |lbl#0@@41|))
))))
(assert  (=> true (forall ((|v#0@@79| T@U) (|v'#0@@38| T@U) (|lbl#0@@42| T@U) ) (!  (=> (and (and (and (= (type |v#0@@79|) DatatypeTypeType) (= (type |v'#0@@38|) DatatypeTypeType)) (= (type |lbl#0@@42|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| (Lit |v#0@@79|) (Lit |v'#0@@38|) (Lit |lbl#0@@42|)) (and (and ($Is |v#0@@79| Tclass.PivotBetree.Variables) ($Is |v'#0@@38| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@42| Tclass.PivotBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@42|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@79|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@79|))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@38|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@79|)))))) (= (PivotBetree.__default.InternalNoOp (Lit |v#0@@79|) (Lit |v'#0@@38|) (Lit |lbl#0@@42|))  (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@42|)) (PivotBetree.Variables.WF (Lit |v#0@@79|))) (|PivotBetree.Variables#Equal| |v'#0@@38| |v#0@@79|)))))
 :qid |PivotBetreeidfy.588:26|
 :weight 3
 :skolemid |7163|
 :pattern ( (PivotBetree.__default.InternalNoOp (Lit |v#0@@79|) (Lit |v'#0@@38|) (Lit |lbl#0@@42|)))
))))
(assert  (=> true (forall ((|v#0@@80| T@U) (|stampedBetree#0@@4| T@U) ) (!  (=> (and (and (= (type |v#0@@80|) DatatypeTypeType) (= (type |stampedBetree#0@@4|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| |v#0@@80| |stampedBetree#0@@4|) (and ($Is |v#0@@80| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@4| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))))) true)
 :qid |PivotBetreeidfy.597:18|
 :skolemid |7164|
 :pattern ( (PivotBetree.__default.Init |v#0@@80| |stampedBetree#0@@4|))
))))
(assert (forall ((|v#0@@81| T@U) (|stampedBetree#0@@5| T@U) ) (!  (=> (and (and (= (type |v#0@@81|) DatatypeTypeType) (= (type |stampedBetree#0@@5|) DatatypeTypeType)) (and ($Is |v#0@@81| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@5| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))) (= (|PivotBetree.__default.Init#requires| |v#0@@81| |stampedBetree#0@@5|) true))
 :qid |PivotBetreeidfy.597:18|
 :skolemid |7165|
 :pattern ( (|PivotBetree.__default.Init#requires| |v#0@@81| |stampedBetree#0@@5|))
)))
(assert  (=> true (forall ((|v#0@@82| T@U) (|stampedBetree#0@@6| T@U) ) (!  (=> (and (and (= (type |v#0@@82|) DatatypeTypeType) (= (type |stampedBetree#0@@6|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| |v#0@@82| |stampedBetree#0@@6|) (and ($Is |v#0@@82| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@6| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))))) (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@6|) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@6|)))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@6|))) (and (|$IsA#PivotBetree.Variables| |v#0@@82|) (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@6|) (|MemtableMod.__default.EmptyMemtable#canCall| (StampedMod.Stamped.seqEnd |stampedBetree#0@@6|))) (StampedMod.Stamped.Stamped_q |stampedBetree#0@@6|))))) (= (PivotBetree.__default.Init |v#0@@82| |stampedBetree#0@@6|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@6|))) (|PivotBetree.Variables#Equal| |v#0@@82| (|#PivotBetree.Variables.Variables| (MemtableMod.__default.EmptyMemtable (StampedMod.Stamped.seqEnd |stampedBetree#0@@6|)) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@6|))))))))
 :qid |PivotBetreeidfy.597:18|
 :skolemid |7166|
 :pattern ( (PivotBetree.__default.Init |v#0@@82| |stampedBetree#0@@6|))
))))
(assert  (=> true (forall ((|v#0@@83| T@U) (|stampedBetree#0@@7| T@U) ) (!  (=> (and (and (= (type |v#0@@83|) DatatypeTypeType) (= (type |stampedBetree#0@@7|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| (Lit |v#0@@83|) (Lit |stampedBetree#0@@7|)) (and ($Is |v#0@@83| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@7| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))))) (and (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@7|)) (|PivotBetree.BetreeNode.WF#canCall| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@7|)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@7|)))))))) (and (|$IsA#PivotBetree.Variables| (Lit |v#0@@83|)) (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@7|)) (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@7|))))) (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@7|)))))) (= (PivotBetree.__default.Init (Lit |v#0@@83|) (Lit |stampedBetree#0@@7|))  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@7|))))) (|PivotBetree.Variables#Equal| |v#0@@83| (|#PivotBetree.Variables.Variables| (Lit (MemtableMod.__default.EmptyMemtable (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@7|))))) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@7|))))))))))
 :qid |PivotBetreeidfy.597:18|
 :weight 3
 :skolemid |7167|
 :pattern ( (PivotBetree.__default.Init (Lit |v#0@@83|) (Lit |stampedBetree#0@@7|)))
))))
(assert  (=> true (forall ((|v#0@@84| T@U) (|v'#0@@39| T@U) (|lbl#0@@43| T@U) (|step#0@@27| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@84|) DatatypeTypeType) (= (type |v'#0@@39|) DatatypeTypeType)) (= (type |lbl#0@@43|) DatatypeTypeType)) (= (type |step#0@@27|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| |v#0@@84| |v'#0@@39| |lbl#0@@43| |step#0@@27|) (and (and (and ($Is |v#0@@84| Tclass.PivotBetree.Variables) ($Is |v'#0@@39| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@43| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@27| Tclass.PivotBetree.Step)))) true)
 :qid |PivotBetreeidfy.642:22|
 :skolemid |7168|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@84| |v'#0@@39| |lbl#0@@43| |step#0@@27|))
))))
(assert (forall ((|v#0@@85| T@U) (|v'#0@@40| T@U) (|lbl#0@@44| T@U) (|step#0@@28| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@85|) DatatypeTypeType) (= (type |v'#0@@40|) DatatypeTypeType)) (= (type |lbl#0@@44|) DatatypeTypeType)) (= (type |step#0@@28|) DatatypeTypeType)) (and (and (and ($Is |v#0@@85| Tclass.PivotBetree.Variables) ($Is |v'#0@@40| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@44| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@28| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.NextStep#requires| |v#0@@85| |v'#0@@40| |lbl#0@@44| |step#0@@28|) true))
 :qid |PivotBetreeidfy.642:22|
 :skolemid |7169|
 :pattern ( (|PivotBetree.__default.NextStep#requires| |v#0@@85| |v'#0@@40| |lbl#0@@44| |step#0@@28|))
)))
(assert  (=> true (forall ((|v#0@@86| T@U) (|v'#0@@41| T@U) (|lbl#0@@45| T@U) (|step#0@@29| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@86|) DatatypeTypeType) (= (type |v'#0@@41|) DatatypeTypeType)) (= (type |lbl#0@@45|) DatatypeTypeType)) (= (type |step#0@@29|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|) (and (and (and ($Is |v#0@@86| Tclass.PivotBetree.Variables) ($Is |v'#0@@41| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@45| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@29| Tclass.PivotBetree.Step)))) (and (and (|PivotBetree.Step.WF#canCall| |step#0@@29|) (=> (PivotBetree.Step.WF |step#0@@29|) (and (=> (PivotBetree.Step.QueryStep_q |step#0@@29|) (let ((|receipt#1@@1| (PivotBetree.Step.receipt |step#0@@29|)))
(|PivotBetree.__default.Query#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |receipt#1@@1|))) (=> (not (PivotBetree.Step.QueryStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.PutStep_q |step#0@@29|) (|PivotBetree.__default.Put#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45|)) (=> (not (PivotBetree.Step.PutStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.QueryEndLsnStep_q |step#0@@29|) (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45|)) (=> (not (PivotBetree.Step.QueryEndLsnStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.FreezeAsStep_q |step#0@@29|) (|PivotBetree.__default.FreezeAs#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45|)) (=> (not (PivotBetree.Step.FreezeAsStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.InternalGrowStep_q |step#0@@29|) (|PivotBetree.__default.InternalGrow#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|)) (=> (not (PivotBetree.Step.InternalGrowStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.InternalSplitStep_q |step#0@@29|) (|PivotBetree.__default.InternalSplit#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|)) (=> (not (PivotBetree.Step.InternalSplitStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@29|) (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45|)) (=> (not (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.InternalFlushStep_q |step#0@@29|) (|PivotBetree.__default.InternalFlush#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|)) (=> (not (PivotBetree.Step.InternalFlushStep_q |step#0@@29|)) (and (=> (PivotBetree.Step.InternalCompactStep_q |step#0@@29|) (|PivotBetree.__default.InternalCompact#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|)) (=> (not (PivotBetree.Step.InternalCompactStep_q |step#0@@29|)) (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@86| |v'#0@@41| |lbl#0@@45|))))))))))))))))))))) (= (PivotBetree.__default.NextStep |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|)  (and (PivotBetree.Step.WF |step#0@@29|) (ite (PivotBetree.Step.QueryStep_q |step#0@@29|) (let ((|receipt#0@@9| (PivotBetree.Step.receipt |step#0@@29|)))
(PivotBetree.__default.Query |v#0@@86| |v'#0@@41| |lbl#0@@45| |receipt#0@@9|)) (ite (PivotBetree.Step.PutStep_q |step#0@@29|) (PivotBetree.__default.Put |v#0@@86| |v'#0@@41| |lbl#0@@45|) (ite (PivotBetree.Step.QueryEndLsnStep_q |step#0@@29|) (PivotBetree.__default.QueryEndLsn |v#0@@86| |v'#0@@41| |lbl#0@@45|) (ite (PivotBetree.Step.FreezeAsStep_q |step#0@@29|) (PivotBetree.__default.FreezeAs |v#0@@86| |v'#0@@41| |lbl#0@@45|) (ite (PivotBetree.Step.InternalGrowStep_q |step#0@@29|) (PivotBetree.__default.InternalGrow |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|) (ite (PivotBetree.Step.InternalSplitStep_q |step#0@@29|) (PivotBetree.__default.InternalSplit |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|) (ite (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@29|) (PivotBetree.__default.InternalFlushMemtable |v#0@@86| |v'#0@@41| |lbl#0@@45|) (ite (PivotBetree.Step.InternalFlushStep_q |step#0@@29|) (PivotBetree.__default.InternalFlush |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|) (ite (PivotBetree.Step.InternalCompactStep_q |step#0@@29|) (PivotBetree.__default.InternalCompact |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|) (PivotBetree.__default.InternalNoOp |v#0@@86| |v'#0@@41| |lbl#0@@45|))))))))))))))
 :qid |PivotBetreeidfy.642:22|
 :skolemid |7170|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@86| |v'#0@@41| |lbl#0@@45| |step#0@@29|))
))))
(assert  (=> true (forall ((|v#0@@87| T@U) (|v'#0@@42| T@U) (|lbl#0@@46| T@U) (|step#0@@30| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@87|) DatatypeTypeType) (= (type |v'#0@@42|) DatatypeTypeType)) (= (type |lbl#0@@46|) DatatypeTypeType)) (= (type |step#0@@30|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)) (and (and (and ($Is |v#0@@87| Tclass.PivotBetree.Variables) ($Is |v'#0@@42| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@46| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@30| Tclass.PivotBetree.Step)))) (and (and (|PivotBetree.Step.WF#canCall| (Lit |step#0@@30|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@30|))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@30|))))) (let ((|receipt#3@@1| (Lit (PivotBetree.Step.receipt (Lit |step#0@@30|)))))
(|PivotBetree.__default.Query#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) |receipt#3@@1|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.Put#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.FreezeAs#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.InternalGrow#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.InternalSplit#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.InternalFlush#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@30|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@30|))))) (|PivotBetree.__default.InternalCompact#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@30|)))))) (|PivotBetree.__default.InternalNoOp#canCall| (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)))))))))))))))))))))) (= (PivotBetree.__default.NextStep (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|))  (and (PivotBetree.Step.WF (Lit |step#0@@30|)) (ite (PivotBetree.Step.QueryStep_q (Lit |step#0@@30|)) (U_2_bool (let ((|receipt#2@@1| (Lit (PivotBetree.Step.receipt (Lit |step#0@@30|)))))
(Lit (bool_2_U (PivotBetree.__default.Query (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) |receipt#2@@1|))))) (ite (PivotBetree.Step.PutStep_q (Lit |step#0@@30|)) (PivotBetree.__default.Put (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)) (ite (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@30|)) (PivotBetree.__default.QueryEndLsn (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)) (ite (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@30|)) (PivotBetree.__default.FreezeAs (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)) (ite (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@30|)) (PivotBetree.__default.InternalGrow (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)) (ite (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@30|)) (PivotBetree.__default.InternalSplit (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)) (ite (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@30|)) (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)) (ite (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@30|)) (PivotBetree.__default.InternalFlush (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)) (ite (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@30|)) (PivotBetree.__default.InternalCompact (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)) (PivotBetree.__default.InternalNoOp (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|)))))))))))))))
 :qid |PivotBetreeidfy.642:22|
 :weight 3
 :skolemid |7171|
 :pattern ( (PivotBetree.__default.NextStep (Lit |v#0@@87|) (Lit |v'#0@@42|) (Lit |lbl#0@@46|) (Lit |step#0@@30|)))
))))
(assert  (=> true (forall ((|v#0@@88| T@U) (|v'#0@@43| T@U) (|lbl#0@@47| T@U) ) (!  (=> (and (and (and (= (type |v#0@@88|) DatatypeTypeType) (= (type |v'#0@@43|) DatatypeTypeType)) (= (type |lbl#0@@47|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| |v#0@@88| |v'#0@@43| |lbl#0@@47|) (and (and ($Is |v#0@@88| Tclass.PivotBetree.Variables) ($Is |v'#0@@43| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@47| Tclass.PivotBetree.TransitionLabel)))) true)
 :qid |PivotBetreeidfy.659:18|
 :skolemid |7172|
 :pattern ( (PivotBetree.__default.Next |v#0@@88| |v'#0@@43| |lbl#0@@47|))
))))
(assert (forall ((|v#0@@89| T@U) (|v'#0@@44| T@U) (|lbl#0@@48| T@U) ) (!  (=> (and (and (and (= (type |v#0@@89|) DatatypeTypeType) (= (type |v'#0@@44|) DatatypeTypeType)) (= (type |lbl#0@@48|) DatatypeTypeType)) (and (and ($Is |v#0@@89| Tclass.PivotBetree.Variables) ($Is |v'#0@@44| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@48| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.Next#requires| |v#0@@89| |v'#0@@44| |lbl#0@@48|) true))
 :qid |PivotBetreeidfy.659:18|
 :skolemid |7173|
 :pattern ( (|PivotBetree.__default.Next#requires| |v#0@@89| |v'#0@@44| |lbl#0@@48|))
)))
(assert  (=> true (forall ((|v#0@@90| T@U) (|v'#0@@45| T@U) (|lbl#0@@49| T@U) ) (!  (=> (and (and (and (= (type |v#0@@90|) DatatypeTypeType) (= (type |v'#0@@45|) DatatypeTypeType)) (= (type |lbl#0@@49|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| |v#0@@90| |v'#0@@45| |lbl#0@@49|) (and (and ($Is |v#0@@90| Tclass.PivotBetree.Variables) ($Is |v'#0@@45| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@49| Tclass.PivotBetree.TransitionLabel)))) (and (forall ((|step#0@@31| T@U) ) (!  (=> (and (= (type |step#0@@31|) DatatypeTypeType) ($Is |step#0@@31| Tclass.PivotBetree.Step)) (|PivotBetree.__default.NextStep#canCall| |v#0@@90| |v'#0@@45| |lbl#0@@49| |step#0@@31|))
 :qid |PivotBetreeidfy.660:12|
 :skolemid |7175|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@90| |v'#0@@45| |lbl#0@@49| |step#0@@31|))
)) (= (PivotBetree.__default.Next |v#0@@90| |v'#0@@45| |lbl#0@@49|) (exists ((|step#0@@32| T@U) ) (!  (and (= (type |step#0@@32|) DatatypeTypeType) (and ($Is |step#0@@32| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@90| |v'#0@@45| |lbl#0@@49| |step#0@@32|)))
 :qid |PivotBetreeidfy.660:12|
 :skolemid |7174|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@90| |v'#0@@45| |lbl#0@@49| |step#0@@32|))
)))))
 :qid |PivotBetreeidfy.659:18|
 :skolemid |7176|
 :pattern ( (PivotBetree.__default.Next |v#0@@90| |v'#0@@45| |lbl#0@@49|))
))))
(assert  (=> true (forall ((|v#0@@91| T@U) (|v'#0@@46| T@U) (|lbl#0@@50| T@U) ) (!  (=> (and (and (and (= (type |v#0@@91|) DatatypeTypeType) (= (type |v'#0@@46|) DatatypeTypeType)) (= (type |lbl#0@@50|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| (Lit |v#0@@91|) (Lit |v'#0@@46|) (Lit |lbl#0@@50|)) (and (and ($Is |v#0@@91| Tclass.PivotBetree.Variables) ($Is |v'#0@@46| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@50| Tclass.PivotBetree.TransitionLabel)))) (and (forall ((|step#1| T@U) ) (!  (=> (and (= (type |step#1|) DatatypeTypeType) ($Is |step#1| Tclass.PivotBetree.Step)) (|PivotBetree.__default.NextStep#canCall| (Lit |v#0@@91|) (Lit |v'#0@@46|) (Lit |lbl#0@@50|) |step#1|))
 :qid |PivotBetreeidfy.660:12|
 :skolemid |7178|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@91| |v'#0@@46| |lbl#0@@50| |step#1|))
)) (= (PivotBetree.__default.Next (Lit |v#0@@91|) (Lit |v'#0@@46|) (Lit |lbl#0@@50|)) (exists ((|step#1@@0| T@U) ) (!  (and (= (type |step#1@@0|) DatatypeTypeType) (and ($Is |step#1@@0| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep (Lit |v#0@@91|) (Lit |v'#0@@46|) (Lit |lbl#0@@50|) |step#1@@0|)))
 :qid |PivotBetreeidfy.660:12|
 :skolemid |7177|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@91| |v'#0@@46| |lbl#0@@50| |step#1@@0|))
)))))
 :qid |PivotBetreeidfy.659:18|
 :weight 3
 :skolemid |7179|
 :pattern ( (PivotBetree.__default.Next (Lit |v#0@@91|) (Lit |v'#0@@46|) (Lit |lbl#0@@50|)))
))))
(assert (forall ((|a#0#0#0@@13| Int) (|a#0#1#0@@8| T@U) (|a#0#2#0@@1| T@U) ) (!  (=> (and (= (type |a#0#1#0@@8|) (SeqType BoxType)) (= (type |a#0#2#0@@1|) (SeqType BoxType))) (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.QueryLabel| |a#0#0#0@@13| |a#0#1#0@@8| |a#0#2#0@@1|)) |##PagedBetree.TransitionLabel.QueryLabel|))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7180|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| |a#0#0#0@@13| |a#0#1#0@@8| |a#0#2#0@@1|))
)))
(assert (forall ((d@@180 T@U) ) (!  (=> (= (type d@@180) DatatypeTypeType) (= (PagedBetree.TransitionLabel.QueryLabel_q d@@180) (= (DatatypeCtorId d@@180) |##PagedBetree.TransitionLabel.QueryLabel|)))
 :qid |unknown.0:0|
 :skolemid |7181|
 :pattern ( (PagedBetree.TransitionLabel.QueryLabel_q d@@180))
)))
(assert (forall ((d@@181 T@U) ) (!  (=> (and (= (type d@@181) DatatypeTypeType) (PagedBetree.TransitionLabel.QueryLabel_q d@@181)) (exists ((|a#1#0#0@@13| Int) (|a#1#1#0@@8| T@U) (|a#1#2#0@@1| T@U) ) (!  (and (and (= (type |a#1#1#0@@8|) (SeqType BoxType)) (= (type |a#1#2#0@@1|) (SeqType BoxType))) (= d@@181 (|#PagedBetree.TransitionLabel.QueryLabel| |a#1#0#0@@13| |a#1#1#0@@8| |a#1#2#0@@1|)))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7182|
 :no-pattern (type |a#1#1#0@@8|)
 :no-pattern (type |a#1#2#0@@1|)
 :no-pattern (U_2_int |a#1#1#0@@8|)
 :no-pattern (U_2_bool |a#1#1#0@@8|)
 :no-pattern (U_2_int |a#1#2#0@@1|)
 :no-pattern (U_2_bool |a#1#2#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |7183|
 :pattern ( (PagedBetree.TransitionLabel.QueryLabel_q d@@181))
)))
(assert (forall ((|a#2#0#0@@13| Int) (|a#2#1#0@@8| T@U) (|a#2#2#0@@1| T@U) ) (!  (=> (and (= (type |a#2#1#0@@8|) (SeqType BoxType)) (= (type |a#2#2#0@@1|) (SeqType BoxType))) (= ($Is (|#PagedBetree.TransitionLabel.QueryLabel| |a#2#0#0@@13| |a#2#1#0@@8| |a#2#2#0@@1|) Tclass.PagedBetree.TransitionLabel)  (and (and ($Is (int_2_U |a#2#0#0@@13|) Tclass._System.nat) ($Is |a#2#1#0@@8| Tclass.KeyType.Key)) ($Is |a#2#2#0@@1| Tclass.ValueType.Value))))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7184|
 :pattern ( ($Is (|#PagedBetree.TransitionLabel.QueryLabel| |a#2#0#0@@13| |a#2#1#0@@8| |a#2#2#0@@1|) Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((|a#3#0#0@@13| Int) (|a#3#1#0@@8| T@U) (|a#3#2#0@@1| T@U) ($h@@181 T@U) ) (!  (=> (and (and (and (= (type |a#3#1#0@@8|) (SeqType BoxType)) (= (type |a#3#2#0@@1|) (SeqType BoxType))) (= (type $h@@181) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@181)) (= ($IsAlloc (|#PagedBetree.TransitionLabel.QueryLabel| |a#3#0#0@@13| |a#3#1#0@@8| |a#3#2#0@@1|) Tclass.PagedBetree.TransitionLabel $h@@181)  (and (and ($IsAlloc (int_2_U |a#3#0#0@@13|) Tclass._System.nat $h@@181) ($IsAlloc |a#3#1#0@@8| Tclass.KeyType.Key $h@@181)) ($IsAlloc |a#3#2#0@@1| Tclass.ValueType.Value $h@@181))))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7185|
 :pattern ( ($IsAlloc (|#PagedBetree.TransitionLabel.QueryLabel| |a#3#0#0@@13| |a#3#1#0@@8| |a#3#2#0@@1|) Tclass.PagedBetree.TransitionLabel $h@@181))
)))
(assert (forall ((d@@182 T@U) ($h@@182 T@U) ) (!  (=> (and (and (= (type d@@182) DatatypeTypeType) (= (type $h@@182) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@182) (and (PagedBetree.TransitionLabel.QueryLabel_q d@@182) ($IsAlloc d@@182 Tclass.PagedBetree.TransitionLabel $h@@182)))) ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@182)) Tclass._System.nat $h@@182))
 :qid |unknown.0:0|
 :skolemid |7186|
 :pattern ( ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@182)) Tclass._System.nat $h@@182))
)))
(assert (forall ((arg0@@684 T@U) ) (! (= (type (PagedBetree.TransitionLabel.key arg0@@684)) (SeqType BoxType))
 :qid |funType:PagedBetree.TransitionLabel.key|
 :pattern ( (PagedBetree.TransitionLabel.key arg0@@684))
)))
(assert (forall ((d@@183 T@U) ($h@@183 T@U) ) (!  (=> (and (and (= (type d@@183) DatatypeTypeType) (= (type $h@@183) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@183) (and (PagedBetree.TransitionLabel.QueryLabel_q d@@183) ($IsAlloc d@@183 Tclass.PagedBetree.TransitionLabel $h@@183)))) ($IsAlloc (PagedBetree.TransitionLabel.key d@@183) Tclass.KeyType.Key $h@@183))
 :qid |unknown.0:0|
 :skolemid |7187|
 :pattern ( ($IsAlloc (PagedBetree.TransitionLabel.key d@@183) Tclass.KeyType.Key $h@@183))
)))
(assert (forall ((arg0@@685 T@U) ) (! (= (type (PagedBetree.TransitionLabel.value arg0@@685)) (SeqType BoxType))
 :qid |funType:PagedBetree.TransitionLabel.value|
 :pattern ( (PagedBetree.TransitionLabel.value arg0@@685))
)))
(assert (forall ((d@@184 T@U) ($h@@184 T@U) ) (!  (=> (and (and (= (type d@@184) DatatypeTypeType) (= (type $h@@184) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@184) (and (PagedBetree.TransitionLabel.QueryLabel_q d@@184) ($IsAlloc d@@184 Tclass.PagedBetree.TransitionLabel $h@@184)))) ($IsAlloc (PagedBetree.TransitionLabel.value d@@184) Tclass.ValueType.Value $h@@184))
 :qid |unknown.0:0|
 :skolemid |7188|
 :pattern ( ($IsAlloc (PagedBetree.TransitionLabel.value d@@184) Tclass.ValueType.Value $h@@184))
)))
(assert (forall ((|a#4#0#0@@13| Int) (|a#4#1#0@@8| T@U) (|a#4#2#0@@1| T@U) ) (!  (=> (and (= (type |a#4#1#0@@8|) (SeqType BoxType)) (= (type |a#4#2#0@@1|) (SeqType BoxType))) (= (|#PagedBetree.TransitionLabel.QueryLabel| (LitInt |a#4#0#0@@13|) (Lit |a#4#1#0@@8|) (Lit |a#4#2#0@@1|)) (Lit (|#PagedBetree.TransitionLabel.QueryLabel| |a#4#0#0@@13| |a#4#1#0@@8| |a#4#2#0@@1|))))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7189|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| (LitInt |a#4#0#0@@13|) (Lit |a#4#1#0@@8|) (Lit |a#4#2#0@@1|)))
)))
(assert (forall ((|a#5#0#0@@15| Int) (|a#5#1#0@@9| T@U) (|a#5#2#0@@1| T@U) ) (!  (=> (and (= (type |a#5#1#0@@9|) (SeqType BoxType)) (= (type |a#5#2#0@@1|) (SeqType BoxType))) (= (PagedBetree.TransitionLabel.endLsn (|#PagedBetree.TransitionLabel.QueryLabel| |a#5#0#0@@15| |a#5#1#0@@9| |a#5#2#0@@1|)) |a#5#0#0@@15|))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7190|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| |a#5#0#0@@15| |a#5#1#0@@9| |a#5#2#0@@1|))
)))
(assert (forall ((|a#6#0#0@@15| Int) (|a#6#1#0@@9| T@U) (|a#6#2#0@@1| T@U) ) (!  (=> (and (= (type |a#6#1#0@@9|) (SeqType BoxType)) (= (type |a#6#2#0@@1|) (SeqType BoxType))) (= (PagedBetree.TransitionLabel.key (|#PagedBetree.TransitionLabel.QueryLabel| |a#6#0#0@@15| |a#6#1#0@@9| |a#6#2#0@@1|)) |a#6#1#0@@9|))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7191|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| |a#6#0#0@@15| |a#6#1#0@@9| |a#6#2#0@@1|))
)))
(assert (forall ((|a#7#0#0@@14| Int) (|a#7#1#0@@9| T@U) (|a#7#2#0@@1| T@U) ) (!  (=> (and (= (type |a#7#1#0@@9|) (SeqType BoxType)) (= (type |a#7#2#0@@1|) (SeqType BoxType))) (= (PagedBetree.TransitionLabel.value (|#PagedBetree.TransitionLabel.QueryLabel| |a#7#0#0@@14| |a#7#1#0@@9| |a#7#2#0@@1|)) |a#7#2#0@@1|))
 :qid |PagedBetreeidfy.42:18|
 :skolemid |7192|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryLabel| |a#7#0#0@@14| |a#7#1#0@@9| |a#7#2#0@@1|))
)))
(assert (forall ((|a#8#0#0@@10| T@U) ) (!  (=> (= (type |a#8#0#0@@10|) DatatypeTypeType) (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.PutLabel| |a#8#0#0@@10|)) |##PagedBetree.TransitionLabel.PutLabel|))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7193|
 :pattern ( (|#PagedBetree.TransitionLabel.PutLabel| |a#8#0#0@@10|))
)))
(assert (forall ((d@@185 T@U) ) (!  (=> (= (type d@@185) DatatypeTypeType) (= (PagedBetree.TransitionLabel.PutLabel_q d@@185) (= (DatatypeCtorId d@@185) |##PagedBetree.TransitionLabel.PutLabel|)))
 :qid |unknown.0:0|
 :skolemid |7194|
 :pattern ( (PagedBetree.TransitionLabel.PutLabel_q d@@185))
)))
(assert (forall ((d@@186 T@U) ) (!  (=> (and (= (type d@@186) DatatypeTypeType) (PagedBetree.TransitionLabel.PutLabel_q d@@186)) (exists ((|a#9#0#0@@5| T@U) ) (!  (and (= (type |a#9#0#0@@5|) DatatypeTypeType) (= d@@186 (|#PagedBetree.TransitionLabel.PutLabel| |a#9#0#0@@5|)))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7195|
 :no-pattern (type |a#9#0#0@@5|)
 :no-pattern (U_2_int |a#9#0#0@@5|)
 :no-pattern (U_2_bool |a#9#0#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |7196|
 :pattern ( (PagedBetree.TransitionLabel.PutLabel_q d@@186))
)))
(assert (forall ((|a#10#0#0@@5| T@U) ) (!  (=> (= (type |a#10#0#0@@5|) DatatypeTypeType) (= ($Is (|#PagedBetree.TransitionLabel.PutLabel| |a#10#0#0@@5|) Tclass.PagedBetree.TransitionLabel) ($Is |a#10#0#0@@5| Tclass.MsgHistoryMod.MsgHistory)))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7197|
 :pattern ( ($Is (|#PagedBetree.TransitionLabel.PutLabel| |a#10#0#0@@5|) Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((|a#11#0#0@@4| T@U) ($h@@185 T@U) ) (!  (=> (and (and (= (type |a#11#0#0@@4|) DatatypeTypeType) (= (type $h@@185) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@185)) (= ($IsAlloc (|#PagedBetree.TransitionLabel.PutLabel| |a#11#0#0@@4|) Tclass.PagedBetree.TransitionLabel $h@@185) ($IsAlloc |a#11#0#0@@4| Tclass.MsgHistoryMod.MsgHistory $h@@185)))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7198|
 :pattern ( ($IsAlloc (|#PagedBetree.TransitionLabel.PutLabel| |a#11#0#0@@4|) Tclass.PagedBetree.TransitionLabel $h@@185))
)))
(assert (forall ((arg0@@686 T@U) ) (! (= (type (PagedBetree.TransitionLabel.puts arg0@@686)) DatatypeTypeType)
 :qid |funType:PagedBetree.TransitionLabel.puts|
 :pattern ( (PagedBetree.TransitionLabel.puts arg0@@686))
)))
(assert (forall ((d@@187 T@U) ($h@@186 T@U) ) (!  (=> (and (and (= (type d@@187) DatatypeTypeType) (= (type $h@@186) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@186) (and (PagedBetree.TransitionLabel.PutLabel_q d@@187) ($IsAlloc d@@187 Tclass.PagedBetree.TransitionLabel $h@@186)))) ($IsAlloc (PagedBetree.TransitionLabel.puts d@@187) Tclass.MsgHistoryMod.MsgHistory $h@@186))
 :qid |unknown.0:0|
 :skolemid |7199|
 :pattern ( ($IsAlloc (PagedBetree.TransitionLabel.puts d@@187) Tclass.MsgHistoryMod.MsgHistory $h@@186))
)))
(assert (forall ((|a#12#0#0@@3| T@U) ) (!  (=> (= (type |a#12#0#0@@3|) DatatypeTypeType) (= (|#PagedBetree.TransitionLabel.PutLabel| (Lit |a#12#0#0@@3|)) (Lit (|#PagedBetree.TransitionLabel.PutLabel| |a#12#0#0@@3|))))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7200|
 :pattern ( (|#PagedBetree.TransitionLabel.PutLabel| (Lit |a#12#0#0@@3|)))
)))
(assert (forall ((|a#13#0#0@@2| T@U) ) (!  (=> (= (type |a#13#0#0@@2|) DatatypeTypeType) (= (PagedBetree.TransitionLabel.puts (|#PagedBetree.TransitionLabel.PutLabel| |a#13#0#0@@2|)) |a#13#0#0@@2|))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7201|
 :pattern ( (|#PagedBetree.TransitionLabel.PutLabel| |a#13#0#0@@2|))
)))
(assert (forall ((|a#14#0#0@@2| T@U) ) (!  (=> (= (type |a#14#0#0@@2|) DatatypeTypeType) (< (DtRank |a#14#0#0@@2|) (DtRank (|#PagedBetree.TransitionLabel.PutLabel| |a#14#0#0@@2|))))
 :qid |PagedBetreeidfy.43:16|
 :skolemid |7202|
 :pattern ( (|#PagedBetree.TransitionLabel.PutLabel| |a#14#0#0@@2|))
)))
(assert (forall ((|a#15#0#0@@2| Int) ) (! (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@2|)) |##PagedBetree.TransitionLabel.QueryEndLsnLabel|)
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7203|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@2|))
)))
(assert (forall ((d@@188 T@U) ) (!  (=> (= (type d@@188) DatatypeTypeType) (= (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@188) (= (DatatypeCtorId d@@188) |##PagedBetree.TransitionLabel.QueryEndLsnLabel|)))
 :qid |unknown.0:0|
 :skolemid |7204|
 :pattern ( (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@188))
)))
(assert (forall ((d@@189 T@U) ) (!  (=> (and (= (type d@@189) DatatypeTypeType) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@189)) (exists ((|a#16#0#0@@2| Int) ) (! (= d@@189 (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#16#0#0@@2|))
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7205|
)))
 :qid |unknown.0:0|
 :skolemid |7206|
 :pattern ( (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@189))
)))
(assert (forall ((|a#17#0#0@@2| Int) ) (! (= ($Is (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@2|) Tclass.PagedBetree.TransitionLabel) ($Is (int_2_U |a#17#0#0@@2|) Tclass._System.nat))
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7207|
 :pattern ( ($Is (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@2|) Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((|a#18#0#0@@1| Int) ($h@@187 T@U) ) (!  (=> (and (= (type $h@@187) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@187)) (= ($IsAlloc (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#18#0#0@@1|) Tclass.PagedBetree.TransitionLabel $h@@187) ($IsAlloc (int_2_U |a#18#0#0@@1|) Tclass._System.nat $h@@187)))
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7208|
 :pattern ( ($IsAlloc (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#18#0#0@@1|) Tclass.PagedBetree.TransitionLabel $h@@187))
)))
(assert (forall ((d@@190 T@U) ($h@@188 T@U) ) (!  (=> (and (and (= (type d@@190) DatatypeTypeType) (= (type $h@@188) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@188) (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@190) ($IsAlloc d@@190 Tclass.PagedBetree.TransitionLabel $h@@188)))) ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@190)) Tclass._System.nat $h@@188))
 :qid |unknown.0:0|
 :skolemid |7209|
 :pattern ( ($IsAlloc (int_2_U (PagedBetree.TransitionLabel.endLsn d@@190)) Tclass._System.nat $h@@188))
)))
(assert (forall ((|a#19#0#0@@1| Int) ) (! (= (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@1|)) (Lit (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#19#0#0@@1|)))
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7210|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@1|)))
)))
(assert (forall ((|a#20#0#0@@1| Int) ) (! (= (PagedBetree.TransitionLabel.endLsn (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@1|)) |a#20#0#0@@1|)
 :qid |PagedBetreeidfy.44:24|
 :skolemid |7211|
 :pattern ( (|#PagedBetree.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@1|))
)))
(assert (forall ((|a#21#0#0@@1| T@U) ) (!  (=> (= (type |a#21#0#0@@1|) DatatypeTypeType) (= (DatatypeCtorId (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#21#0#0@@1|)) |##PagedBetree.TransitionLabel.FreezeAsLabel|))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7212|
 :pattern ( (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#21#0#0@@1|))
)))
(assert (forall ((d@@191 T@U) ) (!  (=> (= (type d@@191) DatatypeTypeType) (= (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@191) (= (DatatypeCtorId d@@191) |##PagedBetree.TransitionLabel.FreezeAsLabel|)))
 :qid |unknown.0:0|
 :skolemid |7213|
 :pattern ( (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@191))
)))
(assert (forall ((d@@192 T@U) ) (!  (=> (and (= (type d@@192) DatatypeTypeType) (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@192)) (exists ((|a#22#0#0@@1| T@U) ) (!  (and (= (type |a#22#0#0@@1|) DatatypeTypeType) (= d@@192 (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#22#0#0@@1|)))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7214|
 :no-pattern (type |a#22#0#0@@1|)
 :no-pattern (U_2_int |a#22#0#0@@1|)
 :no-pattern (U_2_bool |a#22#0#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |7215|
 :pattern ( (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@192))
)))
(assert (forall ((|a#23#0#0@@0| T@U) ) (!  (=> (= (type |a#23#0#0@@0|) DatatypeTypeType) (= ($Is (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#23#0#0@@0|) Tclass.PagedBetree.TransitionLabel) ($Is |a#23#0#0@@0| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7216|
 :pattern ( ($Is (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#23#0#0@@0|) Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((|a#24#0#0@@0| T@U) ($h@@189 T@U) ) (!  (=> (and (and (= (type |a#24#0#0@@0|) DatatypeTypeType) (= (type $h@@189) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@189)) (= ($IsAlloc (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#24#0#0@@0|) Tclass.PagedBetree.TransitionLabel $h@@189) ($IsAlloc |a#24#0#0@@0| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode) $h@@189)))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7217|
 :pattern ( ($IsAlloc (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#24#0#0@@0|) Tclass.PagedBetree.TransitionLabel $h@@189))
)))
(assert (forall ((arg0@@687 T@U) ) (! (= (type (PagedBetree.TransitionLabel.stampedBetree arg0@@687)) DatatypeTypeType)
 :qid |funType:PagedBetree.TransitionLabel.stampedBetree|
 :pattern ( (PagedBetree.TransitionLabel.stampedBetree arg0@@687))
)))
(assert (forall ((d@@193 T@U) ($h@@190 T@U) ) (!  (=> (and (and (= (type d@@193) DatatypeTypeType) (= (type $h@@190) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@190) (and (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@193) ($IsAlloc d@@193 Tclass.PagedBetree.TransitionLabel $h@@190)))) ($IsAlloc (PagedBetree.TransitionLabel.stampedBetree d@@193) (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode) $h@@190))
 :qid |unknown.0:0|
 :skolemid |7218|
 :pattern ( ($IsAlloc (PagedBetree.TransitionLabel.stampedBetree d@@193) (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode) $h@@190))
)))
(assert (forall ((|a#25#0#0@@0| T@U) ) (!  (=> (= (type |a#25#0#0@@0|) DatatypeTypeType) (= (|#PagedBetree.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0@@0|)) (Lit (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#25#0#0@@0|))))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7219|
 :pattern ( (|#PagedBetree.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0@@0|)))
)))
(assert (forall ((|a#26#0#0@@0| T@U) ) (!  (=> (= (type |a#26#0#0@@0|) DatatypeTypeType) (= (PagedBetree.TransitionLabel.stampedBetree (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#26#0#0@@0|)) |a#26#0#0@@0|))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7220|
 :pattern ( (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#26#0#0@@0|))
)))
(assert (forall ((|a#27#0#0@@1| T@U) ) (!  (=> (= (type |a#27#0#0@@1|) DatatypeTypeType) (< (DtRank |a#27#0#0@@1|) (DtRank (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#27#0#0@@1|))))
 :qid |PagedBetreeidfy.45:21|
 :skolemid |7221|
 :pattern ( (|#PagedBetree.TransitionLabel.FreezeAsLabel| |a#27#0#0@@1|))
)))
(assert (= (DatatypeCtorId |#PagedBetree.TransitionLabel.InternalLabel|) |##PagedBetree.TransitionLabel.InternalLabel|))
(assert (forall ((d@@194 T@U) ) (!  (=> (= (type d@@194) DatatypeTypeType) (= (PagedBetree.TransitionLabel.InternalLabel_q d@@194) (= (DatatypeCtorId d@@194) |##PagedBetree.TransitionLabel.InternalLabel|)))
 :qid |unknown.0:0|
 :skolemid |7222|
 :pattern ( (PagedBetree.TransitionLabel.InternalLabel_q d@@194))
)))
(assert (forall ((d@@195 T@U) ) (!  (=> (and (= (type d@@195) DatatypeTypeType) (PagedBetree.TransitionLabel.InternalLabel_q d@@195)) (= d@@195 |#PagedBetree.TransitionLabel.InternalLabel|))
 :qid |unknown.0:0|
 :skolemid |7223|
 :pattern ( (PagedBetree.TransitionLabel.InternalLabel_q d@@195))
)))
(assert ($Is |#PagedBetree.TransitionLabel.InternalLabel| Tclass.PagedBetree.TransitionLabel))
(assert (forall (($h@@191 T@U) ) (!  (=> (and (= (type $h@@191) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@191)) ($IsAlloc |#PagedBetree.TransitionLabel.InternalLabel| Tclass.PagedBetree.TransitionLabel $h@@191))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7224|
 :pattern ( ($IsAlloc |#PagedBetree.TransitionLabel.InternalLabel| Tclass.PagedBetree.TransitionLabel $h@@191))
)))
(assert (= |#PagedBetree.TransitionLabel.InternalLabel| (Lit |#PagedBetree.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@196 T@U) ) (!  (=> (and (= (type d@@196) DatatypeTypeType) (|$IsA#PagedBetree.TransitionLabel| d@@196)) (or (or (or (or (PagedBetree.TransitionLabel.QueryLabel_q d@@196) (PagedBetree.TransitionLabel.PutLabel_q d@@196)) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@196)) (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@196)) (PagedBetree.TransitionLabel.InternalLabel_q d@@196)))
 :qid |unknown.0:0|
 :skolemid |7225|
 :pattern ( (|$IsA#PagedBetree.TransitionLabel| d@@196))
)))
(assert (forall ((d@@197 T@U) ) (!  (=> (and (= (type d@@197) DatatypeTypeType) ($Is d@@197 Tclass.PagedBetree.TransitionLabel)) (or (or (or (or (PagedBetree.TransitionLabel.QueryLabel_q d@@197) (PagedBetree.TransitionLabel.PutLabel_q d@@197)) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@197)) (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@197)) (PagedBetree.TransitionLabel.InternalLabel_q d@@197)))
 :qid |unknown.0:0|
 :skolemid |7226|
 :pattern ( (PagedBetree.TransitionLabel.InternalLabel_q d@@197) ($Is d@@197 Tclass.PagedBetree.TransitionLabel))
 :pattern ( (PagedBetree.TransitionLabel.FreezeAsLabel_q d@@197) ($Is d@@197 Tclass.PagedBetree.TransitionLabel))
 :pattern ( (PagedBetree.TransitionLabel.QueryEndLsnLabel_q d@@197) ($Is d@@197 Tclass.PagedBetree.TransitionLabel))
 :pattern ( (PagedBetree.TransitionLabel.PutLabel_q d@@197) ($Is d@@197 Tclass.PagedBetree.TransitionLabel))
 :pattern ( (PagedBetree.TransitionLabel.QueryLabel_q d@@197) ($Is d@@197 Tclass.PagedBetree.TransitionLabel))
)))
(assert (forall ((a@@176 T@U) (b@@125 T@U) ) (!  (=> (and (and (= (type a@@176) DatatypeTypeType) (= (type b@@125) DatatypeTypeType)) (and (PagedBetree.TransitionLabel.QueryLabel_q a@@176) (PagedBetree.TransitionLabel.QueryLabel_q b@@125))) (= (|PagedBetree.TransitionLabel#Equal| a@@176 b@@125)  (and (and (= (PagedBetree.TransitionLabel.endLsn a@@176) (PagedBetree.TransitionLabel.endLsn b@@125)) (|Seq#Equal| (PagedBetree.TransitionLabel.key a@@176) (PagedBetree.TransitionLabel.key b@@125))) (|Seq#Equal| (PagedBetree.TransitionLabel.value a@@176) (PagedBetree.TransitionLabel.value b@@125)))))
 :qid |unknown.0:0|
 :skolemid |7227|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@176 b@@125) (PagedBetree.TransitionLabel.QueryLabel_q a@@176))
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@176 b@@125) (PagedBetree.TransitionLabel.QueryLabel_q b@@125))
)))
(assert (forall ((a@@177 T@U) (b@@126 T@U) ) (!  (=> (and (and (= (type a@@177) DatatypeTypeType) (= (type b@@126) DatatypeTypeType)) (and (PagedBetree.TransitionLabel.PutLabel_q a@@177) (PagedBetree.TransitionLabel.PutLabel_q b@@126))) (= (|PagedBetree.TransitionLabel#Equal| a@@177 b@@126) (|MsgHistoryMod.MsgHistory#Equal| (PagedBetree.TransitionLabel.puts a@@177) (PagedBetree.TransitionLabel.puts b@@126))))
 :qid |unknown.0:0|
 :skolemid |7228|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@177 b@@126) (PagedBetree.TransitionLabel.PutLabel_q a@@177))
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@177 b@@126) (PagedBetree.TransitionLabel.PutLabel_q b@@126))
)))
(assert (forall ((a@@178 T@U) (b@@127 T@U) ) (!  (=> (and (and (= (type a@@178) DatatypeTypeType) (= (type b@@127) DatatypeTypeType)) (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q a@@178) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q b@@127))) (= (|PagedBetree.TransitionLabel#Equal| a@@178 b@@127) (= (PagedBetree.TransitionLabel.endLsn a@@178) (PagedBetree.TransitionLabel.endLsn b@@127))))
 :qid |unknown.0:0|
 :skolemid |7229|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@178 b@@127) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q a@@178))
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@178 b@@127) (PagedBetree.TransitionLabel.QueryEndLsnLabel_q b@@127))
)))
(assert (forall ((a@@179 T@U) (b@@128 T@U) ) (!  (=> (and (and (= (type a@@179) DatatypeTypeType) (= (type b@@128) DatatypeTypeType)) (and (PagedBetree.TransitionLabel.FreezeAsLabel_q a@@179) (PagedBetree.TransitionLabel.FreezeAsLabel_q b@@128))) (= (|PagedBetree.TransitionLabel#Equal| a@@179 b@@128) (|StampedMod.Stamped#Equal| (PagedBetree.TransitionLabel.stampedBetree a@@179) (PagedBetree.TransitionLabel.stampedBetree b@@128))))
 :qid |unknown.0:0|
 :skolemid |7230|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@179 b@@128) (PagedBetree.TransitionLabel.FreezeAsLabel_q a@@179))
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@179 b@@128) (PagedBetree.TransitionLabel.FreezeAsLabel_q b@@128))
)))
(assert (forall ((a@@180 T@U) (b@@129 T@U) ) (!  (=> (and (and (= (type a@@180) DatatypeTypeType) (= (type b@@129) DatatypeTypeType)) (and (PagedBetree.TransitionLabel.InternalLabel_q a@@180) (PagedBetree.TransitionLabel.InternalLabel_q b@@129))) (= (|PagedBetree.TransitionLabel#Equal| a@@180 b@@129) true))
 :qid |unknown.0:0|
 :skolemid |7231|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@180 b@@129) (PagedBetree.TransitionLabel.InternalLabel_q a@@180))
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@180 b@@129) (PagedBetree.TransitionLabel.InternalLabel_q b@@129))
)))
(assert (forall ((a@@181 T@U) (b@@130 T@U) ) (!  (=> (and (= (type a@@181) DatatypeTypeType) (= (type b@@130) DatatypeTypeType)) (= (|PagedBetree.TransitionLabel#Equal| a@@181 b@@130) (= a@@181 b@@130)))
 :qid |unknown.0:0|
 :skolemid |7232|
 :pattern ( (|PagedBetree.TransitionLabel#Equal| a@@181 b@@130))
)))
(assert (forall ((|a#33#0#0@@1| T@U) ) (!  (=> (= (type |a#33#0#0@@1|) (IMapType BoxType BoxType)) (= (DatatypeCtorId (|#PagedBetree.ChildMap.ChildMap| |a#33#0#0@@1|)) |##PagedBetree.ChildMap.ChildMap|))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7233|
 :pattern ( (|#PagedBetree.ChildMap.ChildMap| |a#33#0#0@@1|))
)))
(assert (forall ((d@@198 T@U) ) (!  (=> (= (type d@@198) DatatypeTypeType) (= (PagedBetree.ChildMap.ChildMap_q d@@198) (= (DatatypeCtorId d@@198) |##PagedBetree.ChildMap.ChildMap|)))
 :qid |unknown.0:0|
 :skolemid |7234|
 :pattern ( (PagedBetree.ChildMap.ChildMap_q d@@198))
)))
(assert (forall ((d@@199 T@U) ) (!  (=> (and (= (type d@@199) DatatypeTypeType) (PagedBetree.ChildMap.ChildMap_q d@@199)) (exists ((|a#34#0#0@@1| T@U) ) (!  (and (= (type |a#34#0#0@@1|) (IMapType BoxType BoxType)) (= d@@199 (|#PagedBetree.ChildMap.ChildMap| |a#34#0#0@@1|)))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7235|
 :no-pattern (type |a#34#0#0@@1|)
 :no-pattern (U_2_int |a#34#0#0@@1|)
 :no-pattern (U_2_bool |a#34#0#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |7236|
 :pattern ( (PagedBetree.ChildMap.ChildMap_q d@@199))
)))
(assert (forall ((|a#35#0#0@@1| T@U) ) (!  (=> (= (type |a#35#0#0@@1|) (IMapType BoxType BoxType)) (= ($Is (|#PagedBetree.ChildMap.ChildMap| |a#35#0#0@@1|) Tclass.PagedBetree.ChildMap) ($Is |a#35#0#0@@1| (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7237|
 :pattern ( ($Is (|#PagedBetree.ChildMap.ChildMap| |a#35#0#0@@1|) Tclass.PagedBetree.ChildMap))
)))
(assert (forall ((|a#36#0#0@@0| T@U) ($h@@192 T@U) ) (!  (=> (and (and (= (type |a#36#0#0@@0|) (IMapType BoxType BoxType)) (= (type $h@@192) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@192)) (= ($IsAlloc (|#PagedBetree.ChildMap.ChildMap| |a#36#0#0@@0|) Tclass.PagedBetree.ChildMap $h@@192) ($IsAlloc |a#36#0#0@@0| (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode) $h@@192)))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7238|
 :pattern ( ($IsAlloc (|#PagedBetree.ChildMap.ChildMap| |a#36#0#0@@0|) Tclass.PagedBetree.ChildMap $h@@192))
)))
(assert (forall ((arg0@@688 T@U) ) (! (= (type (PagedBetree.ChildMap.mapp arg0@@688)) (IMapType BoxType BoxType))
 :qid |funType:PagedBetree.ChildMap.mapp|
 :pattern ( (PagedBetree.ChildMap.mapp arg0@@688))
)))
(assert (forall ((d@@200 T@U) ($h@@193 T@U) ) (!  (=> (and (and (= (type d@@200) DatatypeTypeType) (= (type $h@@193) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@193) (and (PagedBetree.ChildMap.ChildMap_q d@@200) ($IsAlloc d@@200 Tclass.PagedBetree.ChildMap $h@@193)))) ($IsAlloc (PagedBetree.ChildMap.mapp d@@200) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode) $h@@193))
 :qid |unknown.0:0|
 :skolemid |7239|
 :pattern ( ($IsAlloc (PagedBetree.ChildMap.mapp d@@200) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode) $h@@193))
)))
(assert (forall ((|a#37#0#0@@0| T@U) ) (!  (=> (= (type |a#37#0#0@@0|) (IMapType BoxType BoxType)) (= (|#PagedBetree.ChildMap.ChildMap| (Lit |a#37#0#0@@0|)) (Lit (|#PagedBetree.ChildMap.ChildMap| |a#37#0#0@@0|))))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7240|
 :pattern ( (|#PagedBetree.ChildMap.ChildMap| (Lit |a#37#0#0@@0|)))
)))
(assert (forall ((|a#38#0#0@@0| T@U) ) (!  (=> (= (type |a#38#0#0@@0|) (IMapType BoxType BoxType)) (= (PagedBetree.ChildMap.mapp (|#PagedBetree.ChildMap.ChildMap| |a#38#0#0@@0|)) |a#38#0#0@@0|))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7241|
 :pattern ( (|#PagedBetree.ChildMap.ChildMap| |a#38#0#0@@0|))
)))
(assert (forall ((|a#39#0#0@@0| T@U) (d@@201 T@U) ) (!  (=> (and (and (= (type |a#39#0#0@@0|) (IMapType BoxType BoxType)) (= (type d@@201) DatatypeTypeType)) (U_2_bool (MapType0Select (|IMap#Domain| |a#39#0#0@@0|) ($Box d@@201)))) (< (DtRank d@@201) (DtRank (|#PagedBetree.ChildMap.ChildMap| |a#39#0#0@@0|))))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7242|
 :pattern ( (MapType0Select (|IMap#Domain| |a#39#0#0@@0|) ($Box d@@201)) (|#PagedBetree.ChildMap.ChildMap| |a#39#0#0@@0|))
)))
(assert (forall ((|a#40#0#0@@0| T@U) (bx@@181 T@U) ) (!  (=> (and (and (= (type |a#40#0#0@@0|) (IMapType BoxType BoxType)) (= (type bx@@181) BoxType)) (U_2_bool (MapType0Select (|IMap#Domain| |a#40#0#0@@0|) bx@@181))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |a#40#0#0@@0|) bx@@181))) (DtRank (|#PagedBetree.ChildMap.ChildMap| |a#40#0#0@@0|))))
 :qid |PagedBetreeidfy.48:32|
 :skolemid |7243|
 :pattern ( (MapType0Select (|IMap#Domain| |a#40#0#0@@0|) bx@@181) (|#PagedBetree.ChildMap.ChildMap| |a#40#0#0@@0|))
)))
(assert (forall ((d@@202 T@U) ) (!  (=> (and (= (type d@@202) DatatypeTypeType) (|$IsA#PagedBetree.ChildMap| d@@202)) (PagedBetree.ChildMap.ChildMap_q d@@202))
 :qid |unknown.0:0|
 :skolemid |7244|
 :pattern ( (|$IsA#PagedBetree.ChildMap| d@@202))
)))
(assert (forall ((d@@203 T@U) ) (!  (=> (and (= (type d@@203) DatatypeTypeType) ($Is d@@203 Tclass.PagedBetree.ChildMap)) (PagedBetree.ChildMap.ChildMap_q d@@203))
 :qid |unknown.0:0|
 :skolemid |7245|
 :pattern ( (PagedBetree.ChildMap.ChildMap_q d@@203) ($Is d@@203 Tclass.PagedBetree.ChildMap))
)))
(assert (forall ((a@@182 T@U) (b@@131 T@U) ) (!  (=> (and (and (= (type a@@182) DatatypeTypeType) (= (type b@@131) DatatypeTypeType)) true) (= (|PagedBetree.ChildMap#Equal| a@@182 b@@131) (|IMap#Equal| (PagedBetree.ChildMap.mapp a@@182) (PagedBetree.ChildMap.mapp b@@131))))
 :qid |unknown.0:0|
 :skolemid |7246|
 :pattern ( (|PagedBetree.ChildMap#Equal| a@@182 b@@131))
)))
(assert (forall ((a@@183 T@U) (b@@132 T@U) ) (!  (=> (and (= (type a@@183) DatatypeTypeType) (= (type b@@132) DatatypeTypeType)) (= (|PagedBetree.ChildMap#Equal| a@@183 b@@132) (= a@@183 b@@132)))
 :qid |unknown.0:0|
 :skolemid |7247|
 :pattern ( (|PagedBetree.ChildMap#Equal| a@@183 b@@132))
)))
(assert (forall (($ly@@745 T@U) (this@@325 T@U) ) (!  (=> (and (= (type $ly@@745) LayerTypeType) (= (type this@@325) DatatypeTypeType)) (= (PagedBetree.ChildMap.WF ($LS $ly@@745) this@@325) (PagedBetree.ChildMap.WF $ly@@745 this@@325)))
 :qid |PagedBetreeidfy.49:15|
 :skolemid |7248|
 :pattern ( (PagedBetree.ChildMap.WF ($LS $ly@@745) this@@325))
)))
(assert (forall (($ly@@746 T@U) (this@@326 T@U) ) (!  (=> (and (= (type $ly@@746) LayerTypeType) (= (type this@@326) DatatypeTypeType)) (= (PagedBetree.ChildMap.WF $ly@@746 this@@326) (PagedBetree.ChildMap.WF $LZ this@@326)))
 :qid |PagedBetreeidfy.49:15|
 :skolemid |7249|
 :pattern ( (PagedBetree.ChildMap.WF (AsFuelBottom $ly@@746) this@@326))
)))
(assert  (=> true (forall (($ly@@747 T@U) (this@@327 T@U) ) (!  (=> (and (and (= (type $ly@@747) LayerTypeType) (= (type this@@327) DatatypeTypeType)) (or (|PagedBetree.ChildMap.WF#canCall| this@@327) ($Is this@@327 Tclass.PagedBetree.ChildMap))) true)
 :qid |PagedBetreeidfy.49:15|
 :skolemid |7250|
 :pattern ( (PagedBetree.ChildMap.WF $ly@@747 this@@327))
))))
(assert (forall (($ly@@748 T@U) (this@@328 T@U) ) (!  (=> (and (and (= (type $ly@@748) LayerTypeType) (= (type this@@328) DatatypeTypeType)) ($Is this@@328 Tclass.PagedBetree.ChildMap)) (= (|PagedBetree.ChildMap.WF#requires| $ly@@748 this@@328) true))
 :qid |PagedBetreeidfy.49:15|
 :skolemid |7251|
 :pattern ( (|PagedBetree.ChildMap.WF#requires| $ly@@748 this@@328))
)))
(assert  (=> true (forall (($ly@@749 T@U) (this@@329 T@U) ) (!  (=> (and (and (= (type $ly@@749) LayerTypeType) (= (type this@@329) DatatypeTypeType)) (or (|PagedBetree.ChildMap.WF#canCall| this@@329) ($Is this@@329 Tclass.PagedBetree.ChildMap))) (and (and (and (PagedBetree.ChildMap.ChildMap_q this@@329) (|Buffers.__default.Total#canCall| (|IMap#Domain| (PagedBetree.ChildMap.mapp this@@329)))) (=> (Buffers.__default.Total (|IMap#Domain| (PagedBetree.ChildMap.mapp this@@329))) (forall ((|k#0@@81| T@U) ) (!  (=> (and (= (type |k#0@@81|) (SeqType BoxType)) ($Is |k#0@@81| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@81|) (=> (Buffers.__default.AnyKey |k#0@@81|) (and (PagedBetree.ChildMap.ChildMap_q this@@329) (|PagedBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@329)) ($Box |k#0@@81|))))))))
 :qid |PagedBetreeidfy.51:18|
 :skolemid |7253|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@329)) ($Box |k#0@@81|))))
 :pattern ( (Buffers.__default.AnyKey |k#0@@81|))
)))) (= (PagedBetree.ChildMap.WF ($LS $ly@@749) this@@329)  (and (Buffers.__default.Total (|IMap#Domain| (PagedBetree.ChildMap.mapp this@@329))) (forall ((|k#0@@82| T@U) ) (!  (=> (= (type |k#0@@82|) (SeqType BoxType)) (=> (and ($Is |k#0@@82| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0@@82|)) (PagedBetree.BetreeNode.WF $ly@@749 ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@329)) ($Box |k#0@@82|))))))
 :qid |PagedBetreeidfy.51:18|
 :skolemid |7252|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@329)) ($Box |k#0@@82|))))
 :pattern ( (Buffers.__default.AnyKey |k#0@@82|))
))))))
 :qid |PagedBetreeidfy.49:15|
 :skolemid |7254|
 :pattern ( (PagedBetree.ChildMap.WF ($LS $ly@@749) this@@329))
))))
(assert  (=> true (forall (($ly@@750 T@U) (this@@330 T@U) ) (!  (=> (and (and (= (type $ly@@750) LayerTypeType) (= (type this@@330) DatatypeTypeType)) (or (|PagedBetree.ChildMap.WF#canCall| (Lit this@@330)) ($Is this@@330 Tclass.PagedBetree.ChildMap))) (and (and (and (PagedBetree.ChildMap.ChildMap_q (Lit this@@330)) (|Buffers.__default.Total#canCall| (Lit (|IMap#Domain| (Lit (PagedBetree.ChildMap.mapp (Lit this@@330))))))) (=> (U_2_bool (Lit (bool_2_U (Buffers.__default.Total (Lit (|IMap#Domain| (Lit (PagedBetree.ChildMap.mapp (Lit this@@330))))))))) (forall ((|k#1@@19| T@U) ) (!  (=> (and (= (type |k#1@@19|) (SeqType BoxType)) ($Is |k#1@@19| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#1@@19|) (=> (Buffers.__default.AnyKey |k#1@@19|) (and (PagedBetree.ChildMap.ChildMap_q (Lit this@@330)) (|PagedBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit this@@330)))) ($Box |k#1@@19|))))))))
 :qid |PagedBetreeidfy.51:18|
 :skolemid |7256|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@330)) ($Box |k#1@@19|))))
 :pattern ( (Buffers.__default.AnyKey |k#1@@19|))
)))) (= (PagedBetree.ChildMap.WF ($LS $ly@@750) (Lit this@@330))  (and (Buffers.__default.Total (Lit (|IMap#Domain| (Lit (PagedBetree.ChildMap.mapp (Lit this@@330)))))) (forall ((|k#1@@20| T@U) ) (!  (=> (= (type |k#1@@20|) (SeqType BoxType)) (=> (and ($Is |k#1@@20| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#1@@20|)) (PagedBetree.BetreeNode.WF ($LS $ly@@750) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit this@@330)))) ($Box |k#1@@20|))))))
 :qid |PagedBetreeidfy.51:18|
 :skolemid |7255|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp this@@330)) ($Box |k#1@@20|))))
 :pattern ( (Buffers.__default.AnyKey |k#1@@20|))
))))))
 :qid |PagedBetreeidfy.49:15|
 :weight 3
 :skolemid |7257|
 :pattern ( (PagedBetree.ChildMap.WF ($LS $ly@@750) (Lit this@@330)))
))))
(assert (= (DatatypeCtorId |#PagedBetree.BetreeNode.Nil|) |##PagedBetree.BetreeNode.Nil|))
(assert (forall ((d@@204 T@U) ) (!  (=> (= (type d@@204) DatatypeTypeType) (= (PagedBetree.BetreeNode.Nil_q d@@204) (= (DatatypeCtorId d@@204) |##PagedBetree.BetreeNode.Nil|)))
 :qid |unknown.0:0|
 :skolemid |7258|
 :pattern ( (PagedBetree.BetreeNode.Nil_q d@@204))
)))
(assert (forall ((d@@205 T@U) ) (!  (=> (and (= (type d@@205) DatatypeTypeType) (PagedBetree.BetreeNode.Nil_q d@@205)) (= d@@205 |#PagedBetree.BetreeNode.Nil|))
 :qid |unknown.0:0|
 :skolemid |7259|
 :pattern ( (PagedBetree.BetreeNode.Nil_q d@@205))
)))
(assert ($Is |#PagedBetree.BetreeNode.Nil| Tclass.PagedBetree.BetreeNode))
(assert (forall (($h@@194 T@U) ) (!  (=> (and (= (type $h@@194) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@194)) ($IsAlloc |#PagedBetree.BetreeNode.Nil| Tclass.PagedBetree.BetreeNode $h@@194))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7260|
 :pattern ( ($IsAlloc |#PagedBetree.BetreeNode.Nil| Tclass.PagedBetree.BetreeNode $h@@194))
)))
(assert (= |#PagedBetree.BetreeNode.Nil| (Lit |#PagedBetree.BetreeNode.Nil|)))
(assert (forall ((|a#5#0#0@@16| T@U) (|a#5#1#0@@10| T@U) ) (!  (=> (and (= (type |a#5#0#0@@16|) DatatypeTypeType) (= (type |a#5#1#0@@10|) DatatypeTypeType)) (= (DatatypeCtorId (|#PagedBetree.BetreeNode.BetreeNode| |a#5#0#0@@16| |a#5#1#0@@10|)) |##PagedBetree.BetreeNode.BetreeNode|))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7261|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| |a#5#0#0@@16| |a#5#1#0@@10|))
)))
(assert (forall ((d@@206 T@U) ) (!  (=> (= (type d@@206) DatatypeTypeType) (= (PagedBetree.BetreeNode.BetreeNode_q d@@206) (= (DatatypeCtorId d@@206) |##PagedBetree.BetreeNode.BetreeNode|)))
 :qid |unknown.0:0|
 :skolemid |7262|
 :pattern ( (PagedBetree.BetreeNode.BetreeNode_q d@@206))
)))
(assert (forall ((d@@207 T@U) ) (!  (=> (and (= (type d@@207) DatatypeTypeType) (PagedBetree.BetreeNode.BetreeNode_q d@@207)) (exists ((|a#6#0#0@@16| T@U) (|a#6#1#0@@10| T@U) ) (!  (and (and (= (type |a#6#0#0@@16|) DatatypeTypeType) (= (type |a#6#1#0@@10|) DatatypeTypeType)) (= d@@207 (|#PagedBetree.BetreeNode.BetreeNode| |a#6#0#0@@16| |a#6#1#0@@10|)))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7263|
 :no-pattern (type |a#6#0#0@@16|)
 :no-pattern (type |a#6#1#0@@10|)
 :no-pattern (U_2_int |a#6#0#0@@16|)
 :no-pattern (U_2_bool |a#6#0#0@@16|)
 :no-pattern (U_2_int |a#6#1#0@@10|)
 :no-pattern (U_2_bool |a#6#1#0@@10|)
)))
 :qid |unknown.0:0|
 :skolemid |7264|
 :pattern ( (PagedBetree.BetreeNode.BetreeNode_q d@@207))
)))
(assert (forall ((|a#7#0#0@@15| T@U) (|a#7#1#0@@10| T@U) ) (!  (=> (and (= (type |a#7#0#0@@15|) DatatypeTypeType) (= (type |a#7#1#0@@10|) DatatypeTypeType)) (= ($Is (|#PagedBetree.BetreeNode.BetreeNode| |a#7#0#0@@15| |a#7#1#0@@10|) Tclass.PagedBetree.BetreeNode)  (and ($Is |a#7#0#0@@15| Tclass.Buffers.BufferStack) ($Is |a#7#1#0@@10| Tclass.PagedBetree.ChildMap))))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7265|
 :pattern ( ($Is (|#PagedBetree.BetreeNode.BetreeNode| |a#7#0#0@@15| |a#7#1#0@@10|) Tclass.PagedBetree.BetreeNode))
)))
(assert (forall ((|a#8#0#0@@11| T@U) (|a#8#1#0@@8| T@U) ($h@@195 T@U) ) (!  (=> (and (and (and (= (type |a#8#0#0@@11|) DatatypeTypeType) (= (type |a#8#1#0@@8|) DatatypeTypeType)) (= (type $h@@195) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@195)) (= ($IsAlloc (|#PagedBetree.BetreeNode.BetreeNode| |a#8#0#0@@11| |a#8#1#0@@8|) Tclass.PagedBetree.BetreeNode $h@@195)  (and ($IsAlloc |a#8#0#0@@11| Tclass.Buffers.BufferStack $h@@195) ($IsAlloc |a#8#1#0@@8| Tclass.PagedBetree.ChildMap $h@@195))))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7266|
 :pattern ( ($IsAlloc (|#PagedBetree.BetreeNode.BetreeNode| |a#8#0#0@@11| |a#8#1#0@@8|) Tclass.PagedBetree.BetreeNode $h@@195))
)))
(assert (forall ((arg0@@689 T@U) ) (! (= (type (PagedBetree.BetreeNode.buffers arg0@@689)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.buffers|
 :pattern ( (PagedBetree.BetreeNode.buffers arg0@@689))
)))
(assert (forall ((d@@208 T@U) ($h@@196 T@U) ) (!  (=> (and (and (= (type d@@208) DatatypeTypeType) (= (type $h@@196) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@196) (and (PagedBetree.BetreeNode.BetreeNode_q d@@208) ($IsAlloc d@@208 Tclass.PagedBetree.BetreeNode $h@@196)))) ($IsAlloc (PagedBetree.BetreeNode.buffers d@@208) Tclass.Buffers.BufferStack $h@@196))
 :qid |unknown.0:0|
 :skolemid |7267|
 :pattern ( ($IsAlloc (PagedBetree.BetreeNode.buffers d@@208) Tclass.Buffers.BufferStack $h@@196))
)))
(assert (forall ((arg0@@690 T@U) ) (! (= (type (PagedBetree.BetreeNode.children arg0@@690)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.children|
 :pattern ( (PagedBetree.BetreeNode.children arg0@@690))
)))
(assert (forall ((d@@209 T@U) ($h@@197 T@U) ) (!  (=> (and (and (= (type d@@209) DatatypeTypeType) (= (type $h@@197) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@197) (and (PagedBetree.BetreeNode.BetreeNode_q d@@209) ($IsAlloc d@@209 Tclass.PagedBetree.BetreeNode $h@@197)))) ($IsAlloc (PagedBetree.BetreeNode.children d@@209) Tclass.PagedBetree.ChildMap $h@@197))
 :qid |unknown.0:0|
 :skolemid |7268|
 :pattern ( ($IsAlloc (PagedBetree.BetreeNode.children d@@209) Tclass.PagedBetree.ChildMap $h@@197))
)))
(assert (forall ((|a#9#0#0@@6| T@U) (|a#9#1#0@@3| T@U) ) (!  (=> (and (= (type |a#9#0#0@@6|) DatatypeTypeType) (= (type |a#9#1#0@@3|) DatatypeTypeType)) (= (|#PagedBetree.BetreeNode.BetreeNode| (Lit |a#9#0#0@@6|) (Lit |a#9#1#0@@3|)) (Lit (|#PagedBetree.BetreeNode.BetreeNode| |a#9#0#0@@6| |a#9#1#0@@3|))))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7269|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| (Lit |a#9#0#0@@6|) (Lit |a#9#1#0@@3|)))
)))
(assert (forall ((|a#10#0#0@@6| T@U) (|a#10#1#0@@3| T@U) ) (!  (=> (and (= (type |a#10#0#0@@6|) DatatypeTypeType) (= (type |a#10#1#0@@3|) DatatypeTypeType)) (= (PagedBetree.BetreeNode.buffers (|#PagedBetree.BetreeNode.BetreeNode| |a#10#0#0@@6| |a#10#1#0@@3|)) |a#10#0#0@@6|))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7270|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| |a#10#0#0@@6| |a#10#1#0@@3|))
)))
(assert (forall ((|a#11#0#0@@5| T@U) (|a#11#1#0@@2| T@U) ) (!  (=> (and (= (type |a#11#0#0@@5|) DatatypeTypeType) (= (type |a#11#1#0@@2|) DatatypeTypeType)) (< (DtRank |a#11#0#0@@5|) (DtRank (|#PagedBetree.BetreeNode.BetreeNode| |a#11#0#0@@5| |a#11#1#0@@2|))))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7271|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| |a#11#0#0@@5| |a#11#1#0@@2|))
)))
(assert (forall ((|a#12#0#0@@4| T@U) (|a#12#1#0@@2| T@U) ) (!  (=> (and (= (type |a#12#0#0@@4|) DatatypeTypeType) (= (type |a#12#1#0@@2|) DatatypeTypeType)) (= (PagedBetree.BetreeNode.children (|#PagedBetree.BetreeNode.BetreeNode| |a#12#0#0@@4| |a#12#1#0@@2|)) |a#12#1#0@@2|))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7272|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| |a#12#0#0@@4| |a#12#1#0@@2|))
)))
(assert (forall ((|a#13#0#0@@3| T@U) (|a#13#1#0@@2| T@U) ) (!  (=> (and (= (type |a#13#0#0@@3|) DatatypeTypeType) (= (type |a#13#1#0@@2|) DatatypeTypeType)) (< (DtRank |a#13#1#0@@2|) (DtRank (|#PagedBetree.BetreeNode.BetreeNode| |a#13#0#0@@3| |a#13#1#0@@2|))))
 :qid |PagedBetreeidfy.69:5|
 :skolemid |7273|
 :pattern ( (|#PagedBetree.BetreeNode.BetreeNode| |a#13#0#0@@3| |a#13#1#0@@2|))
)))
(assert (forall ((d@@210 T@U) ) (!  (=> (and (= (type d@@210) DatatypeTypeType) (|$IsA#PagedBetree.BetreeNode| d@@210)) (or (PagedBetree.BetreeNode.Nil_q d@@210) (PagedBetree.BetreeNode.BetreeNode_q d@@210)))
 :qid |unknown.0:0|
 :skolemid |7274|
 :pattern ( (|$IsA#PagedBetree.BetreeNode| d@@210))
)))
(assert (forall ((d@@211 T@U) ) (!  (=> (and (= (type d@@211) DatatypeTypeType) ($Is d@@211 Tclass.PagedBetree.BetreeNode)) (or (PagedBetree.BetreeNode.Nil_q d@@211) (PagedBetree.BetreeNode.BetreeNode_q d@@211)))
 :qid |unknown.0:0|
 :skolemid |7275|
 :pattern ( (PagedBetree.BetreeNode.BetreeNode_q d@@211) ($Is d@@211 Tclass.PagedBetree.BetreeNode))
 :pattern ( (PagedBetree.BetreeNode.Nil_q d@@211) ($Is d@@211 Tclass.PagedBetree.BetreeNode))
)))
(assert (forall ((a@@184 T@U) (b@@133 T@U) ) (!  (=> (and (and (= (type a@@184) DatatypeTypeType) (= (type b@@133) DatatypeTypeType)) (and (PagedBetree.BetreeNode.Nil_q a@@184) (PagedBetree.BetreeNode.Nil_q b@@133))) (= (|PagedBetree.BetreeNode#Equal| a@@184 b@@133) true))
 :qid |unknown.0:0|
 :skolemid |7276|
 :pattern ( (|PagedBetree.BetreeNode#Equal| a@@184 b@@133) (PagedBetree.BetreeNode.Nil_q a@@184))
 :pattern ( (|PagedBetree.BetreeNode#Equal| a@@184 b@@133) (PagedBetree.BetreeNode.Nil_q b@@133))
)))
(assert (forall ((a@@185 T@U) (b@@134 T@U) ) (!  (=> (and (and (= (type a@@185) DatatypeTypeType) (= (type b@@134) DatatypeTypeType)) (and (PagedBetree.BetreeNode.BetreeNode_q a@@185) (PagedBetree.BetreeNode.BetreeNode_q b@@134))) (= (|PagedBetree.BetreeNode#Equal| a@@185 b@@134)  (and (|Buffers.BufferStack#Equal| (PagedBetree.BetreeNode.buffers a@@185) (PagedBetree.BetreeNode.buffers b@@134)) (|PagedBetree.ChildMap#Equal| (PagedBetree.BetreeNode.children a@@185) (PagedBetree.BetreeNode.children b@@134)))))
 :qid |unknown.0:0|
 :skolemid |7277|
 :pattern ( (|PagedBetree.BetreeNode#Equal| a@@185 b@@134) (PagedBetree.BetreeNode.BetreeNode_q a@@185))
 :pattern ( (|PagedBetree.BetreeNode#Equal| a@@185 b@@134) (PagedBetree.BetreeNode.BetreeNode_q b@@134))
)))
(assert (forall ((a@@186 T@U) (b@@135 T@U) ) (!  (=> (and (= (type a@@186) DatatypeTypeType) (= (type b@@135) DatatypeTypeType)) (= (|PagedBetree.BetreeNode#Equal| a@@186 b@@135) (= a@@186 b@@135)))
 :qid |unknown.0:0|
 :skolemid |7278|
 :pattern ( (|PagedBetree.BetreeNode#Equal| a@@186 b@@135))
)))
(assert (forall (($ly@@751 T@U) (this@@331 T@U) ) (!  (=> (and (= (type $ly@@751) LayerTypeType) (= (type this@@331) DatatypeTypeType)) (= (PagedBetree.BetreeNode.WF ($LS $ly@@751) this@@331) (PagedBetree.BetreeNode.WF $ly@@751 this@@331)))
 :qid |PagedBetreeidfy.72:15|
 :skolemid |7279|
 :pattern ( (PagedBetree.BetreeNode.WF ($LS $ly@@751) this@@331))
)))
(assert (forall (($ly@@752 T@U) (this@@332 T@U) ) (!  (=> (and (= (type $ly@@752) LayerTypeType) (= (type this@@332) DatatypeTypeType)) (= (PagedBetree.BetreeNode.WF $ly@@752 this@@332) (PagedBetree.BetreeNode.WF $LZ this@@332)))
 :qid |PagedBetreeidfy.72:15|
 :skolemid |7280|
 :pattern ( (PagedBetree.BetreeNode.WF (AsFuelBottom $ly@@752) this@@332))
)))
(assert  (=> true (forall (($ly@@753 T@U) (this@@333 T@U) ) (!  (=> (and (and (= (type $ly@@753) LayerTypeType) (= (type this@@333) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.WF#canCall| this@@333) ($Is this@@333 Tclass.PagedBetree.BetreeNode))) true)
 :qid |PagedBetreeidfy.72:15|
 :skolemid |7281|
 :pattern ( (PagedBetree.BetreeNode.WF $ly@@753 this@@333))
))))
(assert (forall (($ly@@754 T@U) (this@@334 T@U) ) (!  (=> (and (and (= (type $ly@@754) LayerTypeType) (= (type this@@334) DatatypeTypeType)) ($Is this@@334 Tclass.PagedBetree.BetreeNode)) (= (|PagedBetree.BetreeNode.WF#requires| $ly@@754 this@@334) true))
 :qid |PagedBetreeidfy.72:15|
 :skolemid |7282|
 :pattern ( (|PagedBetree.BetreeNode.WF#requires| $ly@@754 this@@334))
)))
(assert  (=> true (forall (($ly@@755 T@U) (this@@335 T@U) ) (!  (=> (and (and (= (type $ly@@755) LayerTypeType) (= (type this@@335) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.WF#canCall| this@@335) ($Is this@@335 Tclass.PagedBetree.BetreeNode))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (PagedBetree.BetreeNode.BetreeNode_q this@@335) (|PagedBetree.ChildMap.WF#canCall| (PagedBetree.BetreeNode.children this@@335)))) (= (PagedBetree.BetreeNode.WF ($LS $ly@@755) this@@335)  (and true (=> (PagedBetree.BetreeNode.BetreeNode_q this@@335) (PagedBetree.ChildMap.WF $ly@@755 (PagedBetree.BetreeNode.children this@@335)))))))
 :qid |PagedBetreeidfy.72:15|
 :skolemid |7283|
 :pattern ( (PagedBetree.BetreeNode.WF ($LS $ly@@755) this@@335))
))))
(assert  (=> true (forall (($ly@@756 T@U) (this@@336 T@U) ) (!  (=> (and (and (= (type $ly@@756) LayerTypeType) (= (type this@@336) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.WF#canCall| (Lit this@@336)) ($Is this@@336 Tclass.PagedBetree.BetreeNode))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@336))))) (|PagedBetree.ChildMap.WF#canCall| (Lit (PagedBetree.BetreeNode.children (Lit this@@336)))))) (= (PagedBetree.BetreeNode.WF ($LS $ly@@756) (Lit this@@336)) (U_2_bool (Lit (bool_2_U  (and true (=> (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@336)) (PagedBetree.ChildMap.WF ($LS $ly@@756) (Lit (PagedBetree.BetreeNode.children (Lit this@@336))))))))))))
 :qid |PagedBetreeidfy.72:15|
 :weight 3
 :skolemid |7284|
 :pattern ( (PagedBetree.BetreeNode.WF ($LS $ly@@756) (Lit this@@336)))
))))
(assert (forall ((arg0@@691 T@U) (arg1@@363 T@U) ) (! (= (type (PagedBetree.BetreeNode.Child arg0@@691 arg1@@363)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.Child|
 :pattern ( (PagedBetree.BetreeNode.Child arg0@@691 arg1@@363))
)))
(assert  (=> true (forall ((this@@337 T@U) (|key#0@@231| T@U) ) (!  (=> (and (and (= (type this@@337) DatatypeTypeType) (= (type |key#0@@231|) (SeqType BoxType))) (or (|PagedBetree.BetreeNode.Child#canCall| this@@337 |key#0@@231|) (and (and ($Is this@@337 Tclass.PagedBetree.BetreeNode) ($Is |key#0@@231| Tclass.KeyType.Key)) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@337) (PagedBetree.BetreeNode.BetreeNode_q this@@337))))) ($Is (PagedBetree.BetreeNode.Child this@@337 |key#0@@231|) Tclass.PagedBetree.BetreeNode))
 :qid |PagedBetreeidfy.76:14|
 :skolemid |7285|
 :pattern ( (PagedBetree.BetreeNode.Child this@@337 |key#0@@231|))
))))
(assert (forall ((this@@338 T@U) (|key#0@@232| T@U) ) (!  (=> (and (and (= (type this@@338) DatatypeTypeType) (= (type |key#0@@232|) (SeqType BoxType))) (and ($Is this@@338 Tclass.PagedBetree.BetreeNode) ($Is |key#0@@232| Tclass.KeyType.Key))) (= (|PagedBetree.BetreeNode.Child#requires| this@@338 |key#0@@232|)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@338) (PagedBetree.BetreeNode.BetreeNode_q this@@338))))
 :qid |PagedBetreeidfy.76:14|
 :skolemid |7286|
 :pattern ( (|PagedBetree.BetreeNode.Child#requires| this@@338 |key#0@@232|))
)))
(assert  (=> true (forall ((this@@339 T@U) (|key#0@@233| T@U) ) (!  (=> (and (and (= (type this@@339) DatatypeTypeType) (= (type |key#0@@233|) (SeqType BoxType))) (or (|PagedBetree.BetreeNode.Child#canCall| this@@339 |key#0@@233|) (and (and ($Is this@@339 Tclass.PagedBetree.BetreeNode) ($Is |key#0@@233| Tclass.KeyType.Key)) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@339) (PagedBetree.BetreeNode.BetreeNode_q this@@339))))) (and (PagedBetree.ChildMap.ChildMap_q (PagedBetree.BetreeNode.children this@@339)) (= (PagedBetree.BetreeNode.Child this@@339 |key#0@@233|) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children this@@339))) ($Box |key#0@@233|))))))
 :qid |PagedBetreeidfy.76:14|
 :skolemid |7287|
 :pattern ( (PagedBetree.BetreeNode.Child this@@339 |key#0@@233|))
))))
(assert  (=> true (forall ((this@@340 T@U) (|key#0@@234| T@U) ) (!  (=> (and (and (= (type this@@340) DatatypeTypeType) (= (type |key#0@@234|) (SeqType BoxType))) (or (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@340) (Lit |key#0@@234|)) (and (and ($Is this@@340 Tclass.PagedBetree.BetreeNode) ($Is |key#0@@234| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@340))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@340))))))))) (and (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit this@@340)))) (= (PagedBetree.BetreeNode.Child (Lit this@@340) (Lit |key#0@@234|)) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit this@@340)))))) ($Box (Lit |key#0@@234|)))))))
 :qid |PagedBetreeidfy.76:14|
 :weight 3
 :skolemid |7288|
 :pattern ( (PagedBetree.BetreeNode.Child (Lit this@@340) (Lit |key#0@@234|)))
))))
(assert (forall ((arg0@@692 T@U) (arg1@@364 T@U) ) (! (= (type (PagedBetree.BetreeNode.PushMemtable arg0@@692 arg1@@364)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.PushMemtable|
 :pattern ( (PagedBetree.BetreeNode.PushMemtable arg0@@692 arg1@@364))
)))
(assert  (=> true (forall ((this@@341 T@U) (|memtable#0@@3| T@U) ) (!  (=> (and (and (= (type this@@341) DatatypeTypeType) (= (type |memtable#0@@3|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushMemtable#canCall| this@@341 |memtable#0@@3|) (and (and ($Is this@@341 Tclass.PagedBetree.BetreeNode) ($Is |memtable#0@@3| Tclass.MemtableMod.Memtable)) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@341)))) ($Is (PagedBetree.BetreeNode.PushMemtable this@@341 |memtable#0@@3|) (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.84:14|
 :skolemid |7289|
 :pattern ( (PagedBetree.BetreeNode.PushMemtable this@@341 |memtable#0@@3|))
))))
(assert (forall ((this@@342 T@U) (|memtable#0@@4| T@U) ) (!  (=> (and (and (= (type this@@342) DatatypeTypeType) (= (type |memtable#0@@4|) DatatypeTypeType)) (and ($Is this@@342 Tclass.PagedBetree.BetreeNode) ($Is |memtable#0@@4| Tclass.MemtableMod.Memtable))) (= (|PagedBetree.BetreeNode.PushMemtable#requires| this@@342 |memtable#0@@4|) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@342)))
 :qid |PagedBetreeidfy.84:14|
 :skolemid |7290|
 :pattern ( (|PagedBetree.BetreeNode.PushMemtable#requires| this@@342 |memtable#0@@4|))
)))
(assert  (and (forall ((arg0@@693 T@U) ) (! (= (type (PagedBetree.BetreeNode.Promote arg0@@693)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.Promote|
 :pattern ( (PagedBetree.BetreeNode.Promote arg0@@693))
)) (forall ((arg0@@694 T@U) (arg1@@365 T@U) ) (! (= (type (PagedBetree.BetreeNode.PushBufferStack arg0@@694 arg1@@365)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.PushBufferStack|
 :pattern ( (PagedBetree.BetreeNode.PushBufferStack arg0@@694 arg1@@365))
))))
(assert  (=> true (forall ((this@@343 T@U) (|memtable#0@@5| T@U) ) (!  (=> (and (and (= (type this@@343) DatatypeTypeType) (= (type |memtable#0@@5|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushMemtable#canCall| this@@343 |memtable#0@@5|) (and (and ($Is this@@343 Tclass.PagedBetree.BetreeNode) ($Is |memtable#0@@5| Tclass.MemtableMod.Memtable)) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@343)))) (and (and (MemtableMod.Memtable.Memtable_q |memtable#0@@5|) (let ((|newBuffer#0@@1| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@5|))))
 (and (and (|PagedBetree.BetreeNode.Promote#canCall| this@@343) (|PagedBetree.BetreeNode.PushBufferStack#canCall| (PagedBetree.BetreeNode.Promote this@@343) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0@@1|))))) (MemtableMod.Memtable.Memtable_q |memtable#0@@5|)))) (= (PagedBetree.BetreeNode.PushMemtable this@@343 |memtable#0@@5|) (let ((|newBuffer#0@@2| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@5|))))
(|#StampedMod.Stamped.Stamped| ($Box (PagedBetree.BetreeNode.PushBufferStack (PagedBetree.BetreeNode.Promote this@@343) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0@@2|))))) (MemtableMod.Memtable.seqEnd |memtable#0@@5|))))))
 :qid |PagedBetreeidfy.84:14|
 :skolemid |7291|
 :pattern ( (PagedBetree.BetreeNode.PushMemtable this@@343 |memtable#0@@5|))
))))
(assert  (=> true (forall ((this@@344 T@U) (|memtable#0@@6| T@U) ) (!  (=> (and (and (= (type this@@344) DatatypeTypeType) (= (type |memtable#0@@6|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushMemtable#canCall| (Lit this@@344) (Lit |memtable#0@@6|)) (and (and ($Is this@@344 Tclass.PagedBetree.BetreeNode) ($Is |memtable#0@@6| Tclass.MemtableMod.Memtable)) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@344)))))))) (and (and (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@6|)) (let ((|newBuffer#1@@1| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@6|)))))))
 (and (and (|PagedBetree.BetreeNode.Promote#canCall| (Lit this@@344)) (|PagedBetree.BetreeNode.PushBufferStack#canCall| (Lit (PagedBetree.BetreeNode.Promote (Lit this@@344))) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1@@1|))))) (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@6|))))) (= (PagedBetree.BetreeNode.PushMemtable (Lit this@@344) (Lit |memtable#0@@6|)) (let ((|newBuffer#1@@2| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@6|)))))))
(Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit (PagedBetree.BetreeNode.PushBufferStack (Lit (PagedBetree.BetreeNode.Promote (Lit this@@344))) (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1@@2|)))))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit |memtable#0@@6|)))))))))
 :qid |PagedBetreeidfy.84:14|
 :weight 3
 :skolemid |7292|
 :pattern ( (PagedBetree.BetreeNode.PushMemtable (Lit this@@344) (Lit |memtable#0@@6|)))
))))
(assert  (=> true (forall ((this@@345 T@U) (|bufferStack#0@@3| T@U) ) (!  (=> (and (and (= (type this@@345) DatatypeTypeType) (= (type |bufferStack#0@@3|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushBufferStack#canCall| this@@345 |bufferStack#0@@3|) (and (and ($Is this@@345 Tclass.PagedBetree.BetreeNode) ($Is |bufferStack#0@@3| Tclass.Buffers.BufferStack)) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@345) (PagedBetree.BetreeNode.BetreeNode_q this@@345))))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.BetreeNode.PushBufferStack this@@345 |bufferStack#0@@3|)) ($Is (PagedBetree.BetreeNode.PushBufferStack this@@345 |bufferStack#0@@3|) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.91:14|
 :skolemid |7293|
 :pattern ( (PagedBetree.BetreeNode.PushBufferStack this@@345 |bufferStack#0@@3|))
))))
(assert (forall ((this@@346 T@U) (|bufferStack#0@@4| T@U) ) (!  (=> (and (and (= (type this@@346) DatatypeTypeType) (= (type |bufferStack#0@@4|) DatatypeTypeType)) (and ($Is this@@346 Tclass.PagedBetree.BetreeNode) ($Is |bufferStack#0@@4| Tclass.Buffers.BufferStack))) (= (|PagedBetree.BetreeNode.PushBufferStack#requires| this@@346 |bufferStack#0@@4|)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@346) (PagedBetree.BetreeNode.BetreeNode_q this@@346))))
 :qid |PagedBetreeidfy.91:14|
 :skolemid |7294|
 :pattern ( (|PagedBetree.BetreeNode.PushBufferStack#requires| this@@346 |bufferStack#0@@4|))
)))
(assert  (=> true (forall ((this@@347 T@U) (|bufferStack#0@@5| T@U) ) (!  (=> (and (and (= (type this@@347) DatatypeTypeType) (= (type |bufferStack#0@@5|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushBufferStack#canCall| this@@347 |bufferStack#0@@5|) (and (and ($Is this@@347 Tclass.PagedBetree.BetreeNode) ($Is |bufferStack#0@@5| Tclass.Buffers.BufferStack)) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@347) (PagedBetree.BetreeNode.BetreeNode_q this@@347))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (PagedBetree.BetreeNode.buffers this@@347) |bufferStack#0@@5|) (= (PagedBetree.BetreeNode.PushBufferStack this@@347 |bufferStack#0@@5|) (|#PagedBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.PushBufferStack (PagedBetree.BetreeNode.buffers this@@347) |bufferStack#0@@5|) (PagedBetree.BetreeNode.children this@@347)))))
 :qid |PagedBetreeidfy.91:14|
 :skolemid |7295|
 :pattern ( (PagedBetree.BetreeNode.PushBufferStack this@@347 |bufferStack#0@@5|))
))))
(assert  (=> true (forall ((this@@348 T@U) (|bufferStack#0@@6| T@U) ) (!  (=> (and (and (= (type this@@348) DatatypeTypeType) (= (type |bufferStack#0@@6|) DatatypeTypeType)) (or (|PagedBetree.BetreeNode.PushBufferStack#canCall| (Lit this@@348) (Lit |bufferStack#0@@6|)) (and (and ($Is this@@348 Tclass.PagedBetree.BetreeNode) ($Is |bufferStack#0@@6| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@348))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@348))))))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@348))) (Lit |bufferStack#0@@6|)) (= (PagedBetree.BetreeNode.PushBufferStack (Lit this@@348) (Lit |bufferStack#0@@6|)) (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.PushBufferStack (Lit (PagedBetree.BetreeNode.buffers (Lit this@@348))) (Lit |bufferStack#0@@6|))) (Lit (PagedBetree.BetreeNode.children (Lit this@@348))))))))
 :qid |PagedBetreeidfy.91:14|
 :weight 3
 :skolemid |7296|
 :pattern ( (PagedBetree.BetreeNode.PushBufferStack (Lit this@@348) (Lit |bufferStack#0@@6|)))
))))
(assert (forall ((arg0@@695 T@U) (arg1@@366 T@U) ) (! (= (type (PagedBetree.BetreeNode.FilterBuffersAndChildren arg0@@695 arg1@@366)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.FilterBuffersAndChildren|
 :pattern ( (PagedBetree.BetreeNode.FilterBuffersAndChildren arg0@@695 arg1@@366))
)))
(assert  (=> true (forall ((this@@349 T@U) (|filter#0| T@U) ) (!  (=> (and (and (= (type this@@349) DatatypeTypeType) (= (type |filter#0|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| this@@349 |filter#0|) (and (and ($Is this@@349 Tclass.PagedBetree.BetreeNode) ($Is |filter#0| (TISet Tclass.KeyType.Key))) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@349)))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.BetreeNode.FilterBuffersAndChildren this@@349 |filter#0|)) ($Is (PagedBetree.BetreeNode.FilterBuffersAndChildren this@@349 |filter#0|) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.99:14|
 :skolemid |7297|
 :pattern ( (PagedBetree.BetreeNode.FilterBuffersAndChildren this@@349 |filter#0|))
))))
(assert (forall ((this@@350 T@U) (|filter#0@@0| T@U) ) (!  (=> (and (and (= (type this@@350) DatatypeTypeType) (= (type |filter#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@350 Tclass.PagedBetree.BetreeNode) ($Is |filter#0@@0| (TISet Tclass.KeyType.Key)))) (= (|PagedBetree.BetreeNode.FilterBuffersAndChildren#requires| this@@350 |filter#0@@0|) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@350)))
 :qid |PagedBetreeidfy.99:14|
 :skolemid |7298|
 :pattern ( (|PagedBetree.BetreeNode.FilterBuffersAndChildren#requires| this@@350 |filter#0@@0|))
)))
(assert (forall ((arg0@@696 T@U) (arg1@@367 T@U) (arg2@@178 T@U) ) (! (= (type (|lambda#370| arg0@@696 arg1@@367 arg2@@178)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#370|
 :pattern ( (|lambda#370| arg0@@696 arg1@@367 arg2@@178))
)))
(assert  (=> true (forall ((this@@351 T@U) (|filter#0@@1| T@U) ) (!  (=> (and (and (= (type this@@351) DatatypeTypeType) (= (type |filter#0@@1|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| this@@351 |filter#0@@1|) (and (and ($Is this@@351 Tclass.PagedBetree.BetreeNode) ($Is |filter#0@@1| (TISet Tclass.KeyType.Key))) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@351)))) (and (=> (not (PagedBetree.BetreeNode.Nil_q this@@351)) (and (forall ((|key#0@@235| T@U) ) (!  (=> (and (= (type |key#0@@235|) (SeqType BoxType)) ($Is |key#0@@235| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@235|) (=> (Buffers.__default.AnyKey |key#0@@235|) (=> (U_2_bool (MapType0Select |filter#0@@1| ($Box |key#0@@235|))) (PagedBetree.ChildMap.ChildMap_q (PagedBetree.BetreeNode.children this@@351))))))
 :qid |PagedBetreeidfy.105:47|
 :skolemid |7299|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children this@@351))) ($Box |key#0@@235|))))
 :pattern ( (MapType0Select |filter#0@@1| ($Box |key#0@@235|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@235|))
)) (|Buffers.BufferStack.ApplyFilter#canCall| (PagedBetree.BetreeNode.buffers this@@351) |filter#0@@1|))) (= (PagedBetree.BetreeNode.FilterBuffersAndChildren this@@351 |filter#0@@1|) (ite (PagedBetree.BetreeNode.Nil_q this@@351) |#PagedBetree.BetreeNode.Nil| (let ((|filteredChildren#0| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#370| |filter#0@@1| (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children this@@351))) |#PagedBetree.BetreeNode.Nil|) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PagedBetree.BetreeNode.buffers this@@351) |filter#0@@1|) |filteredChildren#0|))))))
 :qid |PagedBetreeidfy.99:14|
 :skolemid |7300|
 :pattern ( (PagedBetree.BetreeNode.FilterBuffersAndChildren this@@351 |filter#0@@1|))
))))
(assert  (=> true (forall ((this@@352 T@U) (|filter#0@@2| T@U) ) (!  (=> (and (and (= (type this@@352) DatatypeTypeType) (= (type |filter#0@@2|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (Lit this@@352) |filter#0@@2|) (and (and ($Is this@@352 Tclass.PagedBetree.BetreeNode) ($Is |filter#0@@2| (TISet Tclass.KeyType.Key))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@352)))))))) (and (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit this@@352)))))) (and (forall ((|key#0@@236| T@U) ) (!  (=> (and (= (type |key#0@@236|) (SeqType BoxType)) ($Is |key#0@@236| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@236|) (=> (Buffers.__default.AnyKey |key#0@@236|) (=> (U_2_bool (MapType0Select |filter#0@@2| ($Box |key#0@@236|))) (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit this@@352))))))))
 :qid |PagedBetreeidfy.105:47|
 :skolemid |7301|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children this@@352))) ($Box |key#0@@236|))))
 :pattern ( (MapType0Select |filter#0@@2| ($Box |key#0@@236|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@236|))
)) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@352))) |filter#0@@2|))) (= (PagedBetree.BetreeNode.FilterBuffersAndChildren (Lit this@@352) |filter#0@@2|) (ite (PagedBetree.BetreeNode.Nil_q (Lit this@@352)) |#PagedBetree.BetreeNode.Nil| (let ((|filteredChildren#1| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#370| |filter#0@@2| (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit this@@352)))))) |#PagedBetree.BetreeNode.Nil|) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@352))) |filter#0@@2|) |filteredChildren#1|))))))
 :qid |PagedBetreeidfy.99:14|
 :weight 3
 :skolemid |7302|
 :pattern ( (PagedBetree.BetreeNode.FilterBuffersAndChildren (Lit this@@352) |filter#0@@2|))
))))
(assert  (=> true (forall ((this@@353 T@U) (|filter#0@@3| T@U) ) (!  (=> (and (and (= (type this@@353) DatatypeTypeType) (= (type |filter#0@@3|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (Lit this@@353) (Lit |filter#0@@3|)) (and (and ($Is this@@353 Tclass.PagedBetree.BetreeNode) ($Is |filter#0@@3| (TISet Tclass.KeyType.Key))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@353)))))))) (and (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit this@@353)))))) (and (forall ((|key#0@@237| T@U) ) (!  (=> (and (= (type |key#0@@237|) (SeqType BoxType)) ($Is |key#0@@237| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@237|) (=> (Buffers.__default.AnyKey |key#0@@237|) (=> (U_2_bool (MapType0Select (Lit |filter#0@@3|) ($Box |key#0@@237|))) (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit this@@353))))))))
 :qid |PagedBetreeidfy.105:47|
 :skolemid |7303|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children this@@353))) ($Box |key#0@@237|))))
 :pattern ( (MapType0Select |filter#0@@3| ($Box |key#0@@237|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@237|))
)) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@353))) (Lit |filter#0@@3|)))) (= (PagedBetree.BetreeNode.FilterBuffersAndChildren (Lit this@@353) (Lit |filter#0@@3|)) (ite (PagedBetree.BetreeNode.Nil_q (Lit this@@353)) |#PagedBetree.BetreeNode.Nil| (let ((|filteredChildren#2| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#370| (Lit |filter#0@@3|) (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit this@@353)))))) |#PagedBetree.BetreeNode.Nil|) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@353))) (Lit |filter#0@@3|))) |filteredChildren#2|))))))
 :qid |PagedBetreeidfy.99:14|
 :weight 3
 :skolemid |7304|
 :pattern ( (PagedBetree.BetreeNode.FilterBuffersAndChildren (Lit this@@353) (Lit |filter#0@@3|)))
))))
(assert (forall ((arg0@@697 T@U) (arg1@@368 T@U) (arg2@@179 T@U) ) (! (= (type (PagedBetree.BetreeNode.Split arg0@@697 arg1@@368 arg2@@179)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.Split|
 :pattern ( (PagedBetree.BetreeNode.Split arg0@@697 arg1@@368 arg2@@179))
)))
(assert  (=> true (forall ((this@@354 T@U) (|leftKeys#0@@0| T@U) (|rightKeys#0@@0| T@U) ) (!  (=> (and (and (and (= (type this@@354) DatatypeTypeType) (= (type |leftKeys#0@@0|) (MapType0Type BoxType boolType))) (= (type |rightKeys#0@@0|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Split#canCall| this@@354 |leftKeys#0@@0| |rightKeys#0@@0|) (and (and (and ($Is this@@354 Tclass.PagedBetree.BetreeNode) ($Is |leftKeys#0@@0| (TISet Tclass.KeyType.Key))) ($Is |rightKeys#0@@0| (TISet Tclass.KeyType.Key))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@354) (PagedBetree.BetreeNode.BetreeNode_q this@@354))))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.BetreeNode.Split this@@354 |leftKeys#0@@0| |rightKeys#0@@0|)) ($Is (PagedBetree.BetreeNode.Split this@@354 |leftKeys#0@@0| |rightKeys#0@@0|) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.109:14|
 :skolemid |7305|
 :pattern ( (PagedBetree.BetreeNode.Split this@@354 |leftKeys#0@@0| |rightKeys#0@@0|))
))))
(assert (forall ((this@@355 T@U) (|leftKeys#0@@1| T@U) (|rightKeys#0@@1| T@U) ) (!  (=> (and (and (and (= (type this@@355) DatatypeTypeType) (= (type |leftKeys#0@@1|) (MapType0Type BoxType boolType))) (= (type |rightKeys#0@@1|) (MapType0Type BoxType boolType))) (and (and ($Is this@@355 Tclass.PagedBetree.BetreeNode) ($Is |leftKeys#0@@1| (TISet Tclass.KeyType.Key))) ($Is |rightKeys#0@@1| (TISet Tclass.KeyType.Key)))) (= (|PagedBetree.BetreeNode.Split#requires| this@@355 |leftKeys#0@@1| |rightKeys#0@@1|)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@355) (PagedBetree.BetreeNode.BetreeNode_q this@@355))))
 :qid |PagedBetreeidfy.109:14|
 :skolemid |7306|
 :pattern ( (|PagedBetree.BetreeNode.Split#requires| this@@355 |leftKeys#0@@1| |rightKeys#0@@1|))
)))
(assert (forall ((arg0@@698 T@U) (arg1@@369 T@U) (arg2@@180 T@U) (arg3@@101 T@U) (arg4@@58 T@U) (arg5@@22 T@U) (arg6@@8 T@U) ) (! (= (type (|lambda#376| arg0@@698 arg1@@369 arg2@@180 arg3@@101 arg4@@58 arg5@@22 arg6@@8)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#376|
 :pattern ( (|lambda#376| arg0@@698 arg1@@369 arg2@@180 arg3@@101 arg4@@58 arg5@@22 arg6@@8))
)))
(assert  (=> true (forall ((this@@356 T@U) (|leftKeys#0@@2| T@U) (|rightKeys#0@@2| T@U) ) (!  (=> (and (and (and (= (type this@@356) DatatypeTypeType) (= (type |leftKeys#0@@2|) (MapType0Type BoxType boolType))) (= (type |rightKeys#0@@2|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Split#canCall| this@@356 |leftKeys#0@@2| |rightKeys#0@@2|) (and (and (and ($Is this@@356 Tclass.PagedBetree.BetreeNode) ($Is |leftKeys#0@@2| (TISet Tclass.KeyType.Key))) ($Is |rightKeys#0@@2| (TISet Tclass.KeyType.Key))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@356) (PagedBetree.BetreeNode.BetreeNode_q this@@356))))) (and (forall ((|key#0@@238| T@U) ) (!  (=> (and (= (type |key#0@@238|) (SeqType BoxType)) ($Is |key#0@@238| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@238|) (=> (Buffers.__default.AnyKey |key#0@@238|) (and (=> (U_2_bool (MapType0Select |leftKeys#0@@2| ($Box |key#0@@238|))) (and (|PagedBetree.BetreeNode.Child#canCall| this@@356 |key#0@@238|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child this@@356 |key#0@@238|) |leftKeys#0@@2|))) (=> (not (U_2_bool (MapType0Select |leftKeys#0@@2| ($Box |key#0@@238|)))) (and (=> (U_2_bool (MapType0Select |rightKeys#0@@2| ($Box |key#0@@238|))) (and (|PagedBetree.BetreeNode.Child#canCall| this@@356 |key#0@@238|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child this@@356 |key#0@@238|) |rightKeys#0@@2|))) (=> (not (U_2_bool (MapType0Select |rightKeys#0@@2| ($Box |key#0@@238|)))) (|PagedBetree.BetreeNode.Child#canCall| this@@356 |key#0@@238|))))))))
 :qid |PagedBetreeidfy.118:24|
 :skolemid |7307|
 :pattern ( (MapType0Select |rightKeys#0@@2| ($Box |key#0@@238|)))
 :pattern ( (PagedBetree.BetreeNode.Child this@@356 |key#0@@238|))
 :pattern ( (MapType0Select |leftKeys#0@@2| ($Box |key#0@@238|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@238|))
)) (= (PagedBetree.BetreeNode.Split this@@356 |leftKeys#0@@2| |rightKeys#0@@2|) (let ((|mapp#0| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#376| |leftKeys#0@@2| this@@356 |leftKeys#0@@2| |rightKeys#0@@2| this@@356 |rightKeys#0@@2| this@@356) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
(|#PagedBetree.BetreeNode.BetreeNode| (PagedBetree.BetreeNode.buffers this@@356) (|#PagedBetree.ChildMap.ChildMap| |mapp#0|))))))
 :qid |PagedBetreeidfy.109:14|
 :skolemid |7308|
 :pattern ( (PagedBetree.BetreeNode.Split this@@356 |leftKeys#0@@2| |rightKeys#0@@2|))
))))
(assert  (=> true (forall ((this@@357 T@U) (|leftKeys#0@@3| T@U) (|rightKeys#0@@3| T@U) ) (!  (=> (and (and (and (= (type this@@357) DatatypeTypeType) (= (type |leftKeys#0@@3|) (MapType0Type BoxType boolType))) (= (type |rightKeys#0@@3|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Split#canCall| (Lit this@@357) |leftKeys#0@@3| |rightKeys#0@@3|) (and (and (and ($Is this@@357 Tclass.PagedBetree.BetreeNode) ($Is |leftKeys#0@@3| (TISet Tclass.KeyType.Key))) ($Is |rightKeys#0@@3| (TISet Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@357))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@357))))))))) (and (forall ((|key#0@@239| T@U) ) (!  (=> (and (= (type |key#0@@239|) (SeqType BoxType)) ($Is |key#0@@239| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@239|) (=> (Buffers.__default.AnyKey |key#0@@239|) (and (=> (U_2_bool (MapType0Select |leftKeys#0@@3| ($Box |key#0@@239|))) (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@357) |key#0@@239|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child (Lit this@@357) |key#0@@239|) |leftKeys#0@@3|))) (=> (not (U_2_bool (MapType0Select |leftKeys#0@@3| ($Box |key#0@@239|)))) (and (=> (U_2_bool (MapType0Select |rightKeys#0@@3| ($Box |key#0@@239|))) (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@357) |key#0@@239|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child (Lit this@@357) |key#0@@239|) |rightKeys#0@@3|))) (=> (not (U_2_bool (MapType0Select |rightKeys#0@@3| ($Box |key#0@@239|)))) (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@357) |key#0@@239|))))))))
 :qid |PagedBetreeidfy.118:24|
 :skolemid |7309|
 :pattern ( (MapType0Select |rightKeys#0@@3| ($Box |key#0@@239|)))
 :pattern ( (PagedBetree.BetreeNode.Child this@@357 |key#0@@239|))
 :pattern ( (MapType0Select |leftKeys#0@@3| ($Box |key#0@@239|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@239|))
)) (= (PagedBetree.BetreeNode.Split (Lit this@@357) |leftKeys#0@@3| |rightKeys#0@@3|) (let ((|mapp#1| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#376| |leftKeys#0@@3| (Lit this@@357) |leftKeys#0@@3| |rightKeys#0@@3| (Lit this@@357) |rightKeys#0@@3| (Lit this@@357)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
(|#PagedBetree.BetreeNode.BetreeNode| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@357))) (|#PagedBetree.ChildMap.ChildMap| |mapp#1|))))))
 :qid |PagedBetreeidfy.109:14|
 :weight 3
 :skolemid |7310|
 :pattern ( (PagedBetree.BetreeNode.Split (Lit this@@357) |leftKeys#0@@3| |rightKeys#0@@3|))
))))
(assert  (=> true (forall ((this@@358 T@U) (|leftKeys#0@@4| T@U) (|rightKeys#0@@4| T@U) ) (!  (=> (and (and (and (= (type this@@358) DatatypeTypeType) (= (type |leftKeys#0@@4|) (MapType0Type BoxType boolType))) (= (type |rightKeys#0@@4|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Split#canCall| (Lit this@@358) (Lit |leftKeys#0@@4|) (Lit |rightKeys#0@@4|)) (and (and (and ($Is this@@358 Tclass.PagedBetree.BetreeNode) ($Is |leftKeys#0@@4| (TISet Tclass.KeyType.Key))) ($Is |rightKeys#0@@4| (TISet Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@358))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@358))))))))) (and (forall ((|key#0@@240| T@U) ) (!  (=> (and (= (type |key#0@@240|) (SeqType BoxType)) ($Is |key#0@@240| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@240|) (=> (Buffers.__default.AnyKey |key#0@@240|) (and (=> (U_2_bool (MapType0Select (Lit |leftKeys#0@@4|) ($Box |key#0@@240|))) (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@358) |key#0@@240|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child (Lit this@@358) |key#0@@240|) (Lit |leftKeys#0@@4|)))) (=> (not (U_2_bool (MapType0Select (Lit |leftKeys#0@@4|) ($Box |key#0@@240|)))) (and (=> (U_2_bool (MapType0Select (Lit |rightKeys#0@@4|) ($Box |key#0@@240|))) (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@358) |key#0@@240|) (|PagedBetree.BetreeNode.FilterBuffersAndChildren#canCall| (PagedBetree.BetreeNode.Child (Lit this@@358) |key#0@@240|) (Lit |rightKeys#0@@4|)))) (=> (not (U_2_bool (MapType0Select (Lit |rightKeys#0@@4|) ($Box |key#0@@240|)))) (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@358) |key#0@@240|))))))))
 :qid |PagedBetreeidfy.118:24|
 :skolemid |7311|
 :pattern ( (MapType0Select |rightKeys#0@@4| ($Box |key#0@@240|)))
 :pattern ( (PagedBetree.BetreeNode.Child this@@358 |key#0@@240|))
 :pattern ( (MapType0Select |leftKeys#0@@4| ($Box |key#0@@240|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@240|))
)) (= (PagedBetree.BetreeNode.Split (Lit this@@358) (Lit |leftKeys#0@@4|) (Lit |rightKeys#0@@4|)) (let ((|mapp#2| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#376| (Lit |leftKeys#0@@4|) (Lit this@@358) (Lit |leftKeys#0@@4|) (Lit |rightKeys#0@@4|) (Lit this@@358) (Lit |rightKeys#0@@4|) (Lit this@@358)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
(|#PagedBetree.BetreeNode.BetreeNode| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@358))) (|#PagedBetree.ChildMap.ChildMap| |mapp#2|))))))
 :qid |PagedBetreeidfy.109:14|
 :weight 3
 :skolemid |7312|
 :pattern ( (PagedBetree.BetreeNode.Split (Lit this@@358) (Lit |leftKeys#0@@4|) (Lit |rightKeys#0@@4|)))
))))
(assert  (=> true (forall ((this@@359 T@U) ) (!  (=> (and (= (type this@@359) DatatypeTypeType) (or (|PagedBetree.BetreeNode.Promote#canCall| this@@359) (and ($Is this@@359 Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@359)))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.BetreeNode.Promote this@@359)) ($Is (PagedBetree.BetreeNode.Promote this@@359) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.129:14|
 :skolemid |7313|
 :pattern ( (PagedBetree.BetreeNode.Promote this@@359))
))))
(assert (forall ((this@@360 T@U) ) (!  (=> (and (= (type this@@360) DatatypeTypeType) ($Is this@@360 Tclass.PagedBetree.BetreeNode)) (= (|PagedBetree.BetreeNode.Promote#requires| this@@360) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@360)))
 :qid |PagedBetreeidfy.129:14|
 :skolemid |7314|
 :pattern ( (|PagedBetree.BetreeNode.Promote#requires| this@@360))
)))
(assert (= (type PagedBetree.__default.EmptyRoot) DatatypeTypeType))
(assert  (=> true (forall ((this@@361 T@U) ) (!  (=> (and (= (type this@@361) DatatypeTypeType) (or (|PagedBetree.BetreeNode.Promote#canCall| this@@361) (and ($Is this@@361 Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) this@@361)))) (and (=> (PagedBetree.BetreeNode.Nil_q this@@361) |PagedBetree.__default.EmptyRoot#canCall|) (= (PagedBetree.BetreeNode.Promote this@@361) (ite (PagedBetree.BetreeNode.Nil_q this@@361) PagedBetree.__default.EmptyRoot this@@361))))
 :qid |PagedBetreeidfy.129:14|
 :skolemid |7315|
 :pattern ( (PagedBetree.BetreeNode.Promote this@@361))
))))
(assert  (=> true (forall ((this@@362 T@U) ) (!  (=> (and (= (type this@@362) DatatypeTypeType) (or (|PagedBetree.BetreeNode.Promote#canCall| (Lit this@@362)) (and ($Is this@@362 Tclass.PagedBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@362)))))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit this@@362))))) |PagedBetree.__default.EmptyRoot#canCall|) (= (PagedBetree.BetreeNode.Promote (Lit this@@362)) (ite (PagedBetree.BetreeNode.Nil_q (Lit this@@362)) PagedBetree.__default.EmptyRoot this@@362))))
 :qid |PagedBetreeidfy.129:14|
 :weight 3
 :skolemid |7316|
 :pattern ( (PagedBetree.BetreeNode.Promote (Lit this@@362)))
))))
(assert (forall ((arg0@@699 T@U) (arg1@@370 T@U) ) (! (= (type (PagedBetree.BetreeNode.Flush arg0@@699 arg1@@370)) DatatypeTypeType)
 :qid |funType:PagedBetree.BetreeNode.Flush|
 :pattern ( (PagedBetree.BetreeNode.Flush arg0@@699 arg1@@370))
)))
(assert  (=> true (forall ((this@@363 T@U) (|downKeys#0| T@U) ) (!  (=> (and (and (= (type this@@363) DatatypeTypeType) (= (type |downKeys#0|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Flush#canCall| this@@363 |downKeys#0|) (and (and ($Is this@@363 Tclass.PagedBetree.BetreeNode) ($Is |downKeys#0| (TISet Tclass.KeyType.Key))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@363) (PagedBetree.BetreeNode.BetreeNode_q this@@363))))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.BetreeNode.Flush this@@363 |downKeys#0|)) ($Is (PagedBetree.BetreeNode.Flush this@@363 |downKeys#0|) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.136:14|
 :skolemid |7317|
 :pattern ( (PagedBetree.BetreeNode.Flush this@@363 |downKeys#0|))
))))
(assert (forall ((this@@364 T@U) (|downKeys#0@@0| T@U) ) (!  (=> (and (and (= (type this@@364) DatatypeTypeType) (= (type |downKeys#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@364 Tclass.PagedBetree.BetreeNode) ($Is |downKeys#0@@0| (TISet Tclass.KeyType.Key)))) (= (|PagedBetree.BetreeNode.Flush#requires| this@@364 |downKeys#0@@0|)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@364) (PagedBetree.BetreeNode.BetreeNode_q this@@364))))
 :qid |PagedBetreeidfy.136:14|
 :skolemid |7318|
 :pattern ( (|PagedBetree.BetreeNode.Flush#requires| this@@364 |downKeys#0@@0|))
)))
(assert (forall ((arg0@@700 T@U) (arg1@@371 T@U) (arg2@@181 T@U) (arg3@@102 T@U) ) (! (= (type (|lambda#382| arg0@@700 arg1@@371 arg2@@181 arg3@@102)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#382|
 :pattern ( (|lambda#382| arg0@@700 arg1@@371 arg2@@181 arg3@@102))
)))
(assert  (=> true (forall ((this@@365 T@U) (|downKeys#0@@1| T@U) ) (!  (=> (and (and (= (type this@@365) DatatypeTypeType) (= (type |downKeys#0@@1|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Flush#canCall| this@@365 |downKeys#0@@1|) (and (and ($Is this@@365 Tclass.PagedBetree.BetreeNode) ($Is |downKeys#0@@1| (TISet Tclass.KeyType.Key))) (and (PagedBetree.BetreeNode.WF ($LS $LZ) this@@365) (PagedBetree.BetreeNode.BetreeNode_q this@@365))))) (and (and (and |Buffers.__default.AllKeys#canCall| (|Buffers.BufferStack.ApplyFilter#canCall| (PagedBetree.BetreeNode.buffers this@@365) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@1|))) (and (|Buffers.BufferStack.ApplyFilter#canCall| (PagedBetree.BetreeNode.buffers this@@365) |downKeys#0@@1|) (let ((|movedBuffers#0@@1| (Buffers.BufferStack.ApplyFilter (PagedBetree.BetreeNode.buffers this@@365) |downKeys#0@@1|)))
(forall ((|key#0@@241| T@U) ) (!  (=> (and (= (type |key#0@@241|) (SeqType BoxType)) ($Is |key#0@@241| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@241|) (=> (Buffers.__default.AnyKey |key#0@@241|) (and (=> (U_2_bool (MapType0Select |downKeys#0@@1| ($Box |key#0@@241|))) (and (and (|PagedBetree.BetreeNode.Child#canCall| this@@365 |key#0@@241|) (|PagedBetree.BetreeNode.Promote#canCall| (PagedBetree.BetreeNode.Child this@@365 |key#0@@241|))) (|PagedBetree.BetreeNode.PushBufferStack#canCall| (PagedBetree.BetreeNode.Promote (PagedBetree.BetreeNode.Child this@@365 |key#0@@241|)) |movedBuffers#0@@1|))) (=> (not (U_2_bool (MapType0Select |downKeys#0@@1| ($Box |key#0@@241|)))) (|PagedBetree.BetreeNode.Child#canCall| this@@365 |key#0@@241|))))))
 :qid |PagedBetreeidfy.145:40|
 :skolemid |7319|
 :pattern ( (PagedBetree.BetreeNode.Child this@@365 |key#0@@241|))
 :pattern ( (MapType0Select |downKeys#0@@1| ($Box |key#0@@241|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@241|))
))))) (= (PagedBetree.BetreeNode.Flush this@@365 |downKeys#0@@1|) (let ((|keptBuffers#0@@0| (Buffers.BufferStack.ApplyFilter (PagedBetree.BetreeNode.buffers this@@365) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@1|))))
(let ((|movedBuffers#0@@2| (Buffers.BufferStack.ApplyFilter (PagedBetree.BetreeNode.buffers this@@365) |downKeys#0@@1|)))
(let ((|outChildren#0| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#382| |downKeys#0@@1| this@@365 |movedBuffers#0@@2| this@@365) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| |keptBuffers#0@@0| |outChildren#0|)))))))
 :qid |PagedBetreeidfy.136:14|
 :skolemid |7320|
 :pattern ( (PagedBetree.BetreeNode.Flush this@@365 |downKeys#0@@1|))
))))
(assert  (=> true (forall ((this@@366 T@U) (|downKeys#0@@2| T@U) ) (!  (=> (and (and (= (type this@@366) DatatypeTypeType) (= (type |downKeys#0@@2|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Flush#canCall| (Lit this@@366) |downKeys#0@@2|) (and (and ($Is this@@366 Tclass.PagedBetree.BetreeNode) ($Is |downKeys#0@@2| (TISet Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@366))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@366))))))))) (and (and (and |Buffers.__default.AllKeys#canCall| (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@366))) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@2|))) (and (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@366))) |downKeys#0@@2|) (let ((|movedBuffers#1@@1| (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@366))) |downKeys#0@@2|)))
(forall ((|key#0@@242| T@U) ) (!  (=> (and (= (type |key#0@@242|) (SeqType BoxType)) ($Is |key#0@@242| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@242|) (=> (Buffers.__default.AnyKey |key#0@@242|) (and (=> (U_2_bool (MapType0Select |downKeys#0@@2| ($Box |key#0@@242|))) (and (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@366) |key#0@@242|) (|PagedBetree.BetreeNode.Promote#canCall| (PagedBetree.BetreeNode.Child (Lit this@@366) |key#0@@242|))) (|PagedBetree.BetreeNode.PushBufferStack#canCall| (PagedBetree.BetreeNode.Promote (PagedBetree.BetreeNode.Child (Lit this@@366) |key#0@@242|)) |movedBuffers#1@@1|))) (=> (not (U_2_bool (MapType0Select |downKeys#0@@2| ($Box |key#0@@242|)))) (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@366) |key#0@@242|))))))
 :qid |PagedBetreeidfy.145:40|
 :skolemid |7321|
 :pattern ( (PagedBetree.BetreeNode.Child this@@366 |key#0@@242|))
 :pattern ( (MapType0Select |downKeys#0@@2| ($Box |key#0@@242|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@242|))
))))) (= (PagedBetree.BetreeNode.Flush (Lit this@@366) |downKeys#0@@2|) (let ((|keptBuffers#1@@0| (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@366))) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@2|))))
(let ((|movedBuffers#1@@2| (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@366))) |downKeys#0@@2|)))
(let ((|outChildren#1| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#382| |downKeys#0@@2| (Lit this@@366) |movedBuffers#1@@2| (Lit this@@366)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| |keptBuffers#1@@0| |outChildren#1|)))))))
 :qid |PagedBetreeidfy.136:14|
 :weight 3
 :skolemid |7322|
 :pattern ( (PagedBetree.BetreeNode.Flush (Lit this@@366) |downKeys#0@@2|))
))))
(assert  (=> true (forall ((this@@367 T@U) (|downKeys#0@@3| T@U) ) (!  (=> (and (and (= (type this@@367) DatatypeTypeType) (= (type |downKeys#0@@3|) (MapType0Type BoxType boolType))) (or (|PagedBetree.BetreeNode.Flush#canCall| (Lit this@@367) (Lit |downKeys#0@@3|)) (and (and ($Is this@@367 Tclass.PagedBetree.BetreeNode) ($Is |downKeys#0@@3| (TISet Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit this@@367))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit this@@367))))))))) (and (and (and |Buffers.__default.AllKeys#canCall| (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@367))) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@3|))) (and (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit this@@367))) (Lit |downKeys#0@@3|)) (let ((|movedBuffers#2| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@367))) (Lit |downKeys#0@@3|)))))
(forall ((|key#0@@243| T@U) ) (!  (=> (and (= (type |key#0@@243|) (SeqType BoxType)) ($Is |key#0@@243| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |key#0@@243|) (=> (Buffers.__default.AnyKey |key#0@@243|) (and (=> (U_2_bool (MapType0Select (Lit |downKeys#0@@3|) ($Box |key#0@@243|))) (and (and (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@367) |key#0@@243|) (|PagedBetree.BetreeNode.Promote#canCall| (PagedBetree.BetreeNode.Child (Lit this@@367) |key#0@@243|))) (|PagedBetree.BetreeNode.PushBufferStack#canCall| (PagedBetree.BetreeNode.Promote (PagedBetree.BetreeNode.Child (Lit this@@367) |key#0@@243|)) |movedBuffers#2|))) (=> (not (U_2_bool (MapType0Select (Lit |downKeys#0@@3|) ($Box |key#0@@243|)))) (|PagedBetree.BetreeNode.Child#canCall| (Lit this@@367) |key#0@@243|))))))
 :qid |PagedBetreeidfy.145:40|
 :skolemid |7323|
 :pattern ( (PagedBetree.BetreeNode.Child this@@367 |key#0@@243|))
 :pattern ( (MapType0Select |downKeys#0@@3| ($Box |key#0@@243|)))
 :pattern ( (Buffers.__default.AnyKey |key#0@@243|))
))))) (= (PagedBetree.BetreeNode.Flush (Lit this@@367) (Lit |downKeys#0@@3|)) (let ((|keptBuffers#2| (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@367))) (|ISet#Difference| Buffers.__default.AllKeys |downKeys#0@@3|))))
(let ((|movedBuffers#2@@0| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PagedBetree.BetreeNode.buffers (Lit this@@367))) (Lit |downKeys#0@@3|)))))
(let ((|outChildren#2| (|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#382| (Lit |downKeys#0@@3|) (Lit this@@367) |movedBuffers#2@@0| (Lit this@@367)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))
(|#PagedBetree.BetreeNode.BetreeNode| |keptBuffers#2| |outChildren#2|)))))))
 :qid |PagedBetreeidfy.136:14|
 :weight 3
 :skolemid |7324|
 :pattern ( (PagedBetree.BetreeNode.Flush (Lit this@@367) (Lit |downKeys#0@@3|)))
))))
(assert (forall ((|a#0#0#0@@14| T@U) (|a#0#1#0@@9| T@U) ) (!  (=> (and (= (type |a#0#0#0@@14|) DatatypeTypeType) (= (type |a#0#1#0@@9|) DatatypeTypeType)) (= (DatatypeCtorId (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@14| |a#0#1#0@@9|)) |##PagedBetree.QueryReceiptLine.QueryReceiptLine|))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7325|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@14| |a#0#1#0@@9|))
)))
(assert (forall ((d@@212 T@U) ) (!  (=> (= (type d@@212) DatatypeTypeType) (= (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@212) (= (DatatypeCtorId d@@212) |##PagedBetree.QueryReceiptLine.QueryReceiptLine|)))
 :qid |unknown.0:0|
 :skolemid |7326|
 :pattern ( (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@212))
)))
(assert (forall ((d@@213 T@U) ) (!  (=> (and (= (type d@@213) DatatypeTypeType) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@213)) (exists ((|a#1#0#0@@14| T@U) (|a#1#1#0@@9| T@U) ) (!  (and (and (= (type |a#1#0#0@@14|) DatatypeTypeType) (= (type |a#1#1#0@@9|) DatatypeTypeType)) (= d@@213 (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#1#0#0@@14| |a#1#1#0@@9|)))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7327|
 :no-pattern (type |a#1#0#0@@14|)
 :no-pattern (type |a#1#1#0@@9|)
 :no-pattern (U_2_int |a#1#0#0@@14|)
 :no-pattern (U_2_bool |a#1#0#0@@14|)
 :no-pattern (U_2_int |a#1#1#0@@9|)
 :no-pattern (U_2_bool |a#1#1#0@@9|)
)))
 :qid |unknown.0:0|
 :skolemid |7328|
 :pattern ( (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@213))
)))
(assert (forall ((|a#2#0#0@@14| T@U) (|a#2#1#0@@9| T@U) ) (!  (=> (and (= (type |a#2#0#0@@14|) DatatypeTypeType) (= (type |a#2#1#0@@9|) DatatypeTypeType)) (= ($Is (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@14| |a#2#1#0@@9|) Tclass.PagedBetree.QueryReceiptLine)  (and ($Is |a#2#0#0@@14| Tclass.PagedBetree.BetreeNode) ($Is |a#2#1#0@@9| Tclass.ValueMessage.Message))))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7329|
 :pattern ( ($Is (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@14| |a#2#1#0@@9|) Tclass.PagedBetree.QueryReceiptLine))
)))
(assert (forall ((|a#3#0#0@@14| T@U) (|a#3#1#0@@9| T@U) ($h@@198 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@14|) DatatypeTypeType) (= (type |a#3#1#0@@9|) DatatypeTypeType)) (= (type $h@@198) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@198)) (= ($IsAlloc (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@14| |a#3#1#0@@9|) Tclass.PagedBetree.QueryReceiptLine $h@@198)  (and ($IsAlloc |a#3#0#0@@14| Tclass.PagedBetree.BetreeNode $h@@198) ($IsAlloc |a#3#1#0@@9| Tclass.ValueMessage.Message $h@@198))))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7330|
 :pattern ( ($IsAlloc (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@14| |a#3#1#0@@9|) Tclass.PagedBetree.QueryReceiptLine $h@@198))
)))
(assert (forall ((arg0@@701 T@U) ) (! (= (type (PagedBetree.QueryReceiptLine.node arg0@@701)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceiptLine.node|
 :pattern ( (PagedBetree.QueryReceiptLine.node arg0@@701))
)))
(assert (forall ((d@@214 T@U) ($h@@199 T@U) ) (!  (=> (and (and (= (type d@@214) DatatypeTypeType) (= (type $h@@199) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@199) (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@214) ($IsAlloc d@@214 Tclass.PagedBetree.QueryReceiptLine $h@@199)))) ($IsAlloc (PagedBetree.QueryReceiptLine.node d@@214) Tclass.PagedBetree.BetreeNode $h@@199))
 :qid |unknown.0:0|
 :skolemid |7331|
 :pattern ( ($IsAlloc (PagedBetree.QueryReceiptLine.node d@@214) Tclass.PagedBetree.BetreeNode $h@@199))
)))
(assert (forall ((arg0@@702 T@U) ) (! (= (type (PagedBetree.QueryReceiptLine.result arg0@@702)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceiptLine.result|
 :pattern ( (PagedBetree.QueryReceiptLine.result arg0@@702))
)))
(assert (forall ((d@@215 T@U) ($h@@200 T@U) ) (!  (=> (and (and (= (type d@@215) DatatypeTypeType) (= (type $h@@200) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@200) (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@215) ($IsAlloc d@@215 Tclass.PagedBetree.QueryReceiptLine $h@@200)))) ($IsAlloc (PagedBetree.QueryReceiptLine.result d@@215) Tclass.ValueMessage.Message $h@@200))
 :qid |unknown.0:0|
 :skolemid |7332|
 :pattern ( ($IsAlloc (PagedBetree.QueryReceiptLine.result d@@215) Tclass.ValueMessage.Message $h@@200))
)))
(assert (forall ((|a#4#0#0@@14| T@U) (|a#4#1#0@@9| T@U) ) (!  (=> (and (= (type |a#4#0#0@@14|) DatatypeTypeType) (= (type |a#4#1#0@@9|) DatatypeTypeType)) (= (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@14|) (Lit |a#4#1#0@@9|)) (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#4#0#0@@14| |a#4#1#0@@9|))))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7333|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@14|) (Lit |a#4#1#0@@9|)))
)))
(assert (forall ((|a#5#0#0@@17| T@U) (|a#5#1#0@@11| T@U) ) (!  (=> (and (= (type |a#5#0#0@@17|) DatatypeTypeType) (= (type |a#5#1#0@@11|) DatatypeTypeType)) (= (PagedBetree.QueryReceiptLine.node (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@17| |a#5#1#0@@11|)) |a#5#0#0@@17|))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7334|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@17| |a#5#1#0@@11|))
)))
(assert (forall ((|a#6#0#0@@17| T@U) (|a#6#1#0@@11| T@U) ) (!  (=> (and (= (type |a#6#0#0@@17|) DatatypeTypeType) (= (type |a#6#1#0@@11|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@17|) (DtRank (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@17| |a#6#1#0@@11|))))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7335|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@17| |a#6#1#0@@11|))
)))
(assert (forall ((|a#7#0#0@@16| T@U) (|a#7#1#0@@11| T@U) ) (!  (=> (and (= (type |a#7#0#0@@16|) DatatypeTypeType) (= (type |a#7#1#0@@11|) DatatypeTypeType)) (= (PagedBetree.QueryReceiptLine.result (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@16| |a#7#1#0@@11|)) |a#7#1#0@@11|))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7336|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@16| |a#7#1#0@@11|))
)))
(assert (forall ((|a#8#0#0@@12| T@U) (|a#8#1#0@@9| T@U) ) (!  (=> (and (= (type |a#8#0#0@@12|) DatatypeTypeType) (= (type |a#8#1#0@@9|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@9|) (DtRank (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@12| |a#8#1#0@@9|))))
 :qid |PagedBetreeidfy.161:5|
 :skolemid |7337|
 :pattern ( (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@12| |a#8#1#0@@9|))
)))
(assert (forall ((d@@216 T@U) ) (!  (=> (and (= (type d@@216) DatatypeTypeType) (|$IsA#PagedBetree.QueryReceiptLine| d@@216)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@216))
 :qid |unknown.0:0|
 :skolemid |7338|
 :pattern ( (|$IsA#PagedBetree.QueryReceiptLine| d@@216))
)))
(assert (forall ((d@@217 T@U) ) (!  (=> (and (= (type d@@217) DatatypeTypeType) ($Is d@@217 Tclass.PagedBetree.QueryReceiptLine)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@217))
 :qid |unknown.0:0|
 :skolemid |7339|
 :pattern ( (PagedBetree.QueryReceiptLine.QueryReceiptLine_q d@@217) ($Is d@@217 Tclass.PagedBetree.QueryReceiptLine))
)))
(assert (forall ((a@@187 T@U) (b@@136 T@U) ) (!  (=> (and (and (= (type a@@187) DatatypeTypeType) (= (type b@@136) DatatypeTypeType)) true) (= (|PagedBetree.QueryReceiptLine#Equal| a@@187 b@@136)  (and (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node a@@187) (PagedBetree.QueryReceiptLine.node b@@136)) (|ValueMessage.Message#Equal| (PagedBetree.QueryReceiptLine.result a@@187) (PagedBetree.QueryReceiptLine.result b@@136)))))
 :qid |unknown.0:0|
 :skolemid |7340|
 :pattern ( (|PagedBetree.QueryReceiptLine#Equal| a@@187 b@@136))
)))
(assert (forall ((a@@188 T@U) (b@@137 T@U) ) (!  (=> (and (= (type a@@188) DatatypeTypeType) (= (type b@@137) DatatypeTypeType)) (= (|PagedBetree.QueryReceiptLine#Equal| a@@188 b@@137) (= a@@188 b@@137)))
 :qid |unknown.0:0|
 :skolemid |7341|
 :pattern ( (|PagedBetree.QueryReceiptLine#Equal| a@@188 b@@137))
)))
(assert  (=> true (forall ((this@@368 T@U) ) (!  (=> (and (= (type this@@368) DatatypeTypeType) (or (|PagedBetree.QueryReceiptLine.WF#canCall| this@@368) ($Is this@@368 Tclass.PagedBetree.QueryReceiptLine))) true)
 :qid |PagedBetreeidfy.164:15|
 :skolemid |7342|
 :pattern ( (PagedBetree.QueryReceiptLine.WF this@@368))
))))
(assert (forall ((this@@369 T@U) ) (!  (=> (and (= (type this@@369) DatatypeTypeType) ($Is this@@369 Tclass.PagedBetree.QueryReceiptLine)) (= (|PagedBetree.QueryReceiptLine.WF#requires| this@@369) true))
 :qid |PagedBetreeidfy.164:15|
 :skolemid |7343|
 :pattern ( (|PagedBetree.QueryReceiptLine.WF#requires| this@@369))
)))
(assert  (=> true (forall ((this@@370 T@U) ) (!  (=> (and (= (type this@@370) DatatypeTypeType) (or (|PagedBetree.QueryReceiptLine.WF#canCall| this@@370) ($Is this@@370 Tclass.PagedBetree.QueryReceiptLine))) (and (and (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q this@@370) (|PagedBetree.BetreeNode.WF#canCall| (PagedBetree.QueryReceiptLine.node this@@370))) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.QueryReceiptLine.node this@@370)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q this@@370))) (= (PagedBetree.QueryReceiptLine.WF this@@370)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.QueryReceiptLine.node this@@370)) (ValueMessage.Message.Define_q (PagedBetree.QueryReceiptLine.result this@@370))))))
 :qid |PagedBetreeidfy.164:15|
 :skolemid |7344|
 :pattern ( (PagedBetree.QueryReceiptLine.WF this@@370))
))))
(assert  (=> true (forall ((this@@371 T@U) ) (!  (=> (and (= (type this@@371) DatatypeTypeType) (or (|PagedBetree.QueryReceiptLine.WF#canCall| (Lit this@@371)) ($Is this@@371 Tclass.PagedBetree.QueryReceiptLine))) (and (and (and (PagedBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@371)) (|PagedBetree.BetreeNode.WF#canCall| (Lit (PagedBetree.QueryReceiptLine.node (Lit this@@371))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.QueryReceiptLine.node (Lit this@@371))))))) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@371)))) (= (PagedBetree.QueryReceiptLine.WF (Lit this@@371)) (U_2_bool (Lit (bool_2_U  (and (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.QueryReceiptLine.node (Lit this@@371)))) (ValueMessage.Message.Define_q (Lit (PagedBetree.QueryReceiptLine.result (Lit this@@371)))))))))))
 :qid |PagedBetreeidfy.164:15|
 :weight 3
 :skolemid |7345|
 :pattern ( (PagedBetree.QueryReceiptLine.WF (Lit this@@371)))
))))
(assert (forall ((|a#0#0#0@@15| T@U) (|a#0#1#0@@10| T@U) (|a#0#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#0#0#0@@15|) (SeqType BoxType)) (= (type |a#0#1#0@@10|) DatatypeTypeType)) (= (type |a#0#2#0@@2|) (SeqType BoxType))) (= (DatatypeCtorId (|#PagedBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@15| |a#0#1#0@@10| |a#0#2#0@@2|)) |##PagedBetree.QueryReceipt.QueryReceipt|))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7346|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@15| |a#0#1#0@@10| |a#0#2#0@@2|))
)))
(assert (forall ((d@@218 T@U) ) (!  (=> (= (type d@@218) DatatypeTypeType) (= (PagedBetree.QueryReceipt.QueryReceipt_q d@@218) (= (DatatypeCtorId d@@218) |##PagedBetree.QueryReceipt.QueryReceipt|)))
 :qid |unknown.0:0|
 :skolemid |7347|
 :pattern ( (PagedBetree.QueryReceipt.QueryReceipt_q d@@218))
)))
(assert (forall ((d@@219 T@U) ) (!  (=> (and (= (type d@@219) DatatypeTypeType) (PagedBetree.QueryReceipt.QueryReceipt_q d@@219)) (exists ((|a#1#0#0@@15| T@U) (|a#1#1#0@@10| T@U) (|a#1#2#0@@2| T@U) ) (!  (and (and (and (= (type |a#1#0#0@@15|) (SeqType BoxType)) (= (type |a#1#1#0@@10|) DatatypeTypeType)) (= (type |a#1#2#0@@2|) (SeqType BoxType))) (= d@@219 (|#PagedBetree.QueryReceipt.QueryReceipt| |a#1#0#0@@15| |a#1#1#0@@10| |a#1#2#0@@2|)))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7348|
 :no-pattern (type |a#1#0#0@@15|)
 :no-pattern (type |a#1#1#0@@10|)
 :no-pattern (type |a#1#2#0@@2|)
 :no-pattern (U_2_int |a#1#0#0@@15|)
 :no-pattern (U_2_bool |a#1#0#0@@15|)
 :no-pattern (U_2_int |a#1#1#0@@10|)
 :no-pattern (U_2_bool |a#1#1#0@@10|)
 :no-pattern (U_2_int |a#1#2#0@@2|)
 :no-pattern (U_2_bool |a#1#2#0@@2|)
)))
 :qid |unknown.0:0|
 :skolemid |7349|
 :pattern ( (PagedBetree.QueryReceipt.QueryReceipt_q d@@219))
)))
(assert (forall ((|a#2#0#0@@15| T@U) (|a#2#1#0@@10| T@U) (|a#2#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#2#0#0@@15|) (SeqType BoxType)) (= (type |a#2#1#0@@10|) DatatypeTypeType)) (= (type |a#2#2#0@@2|) (SeqType BoxType))) (= ($Is (|#PagedBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@15| |a#2#1#0@@10| |a#2#2#0@@2|) Tclass.PagedBetree.QueryReceipt)  (and (and ($Is |a#2#0#0@@15| Tclass.KeyType.Key) ($Is |a#2#1#0@@10| Tclass.PagedBetree.BetreeNode)) ($Is |a#2#2#0@@2| (TSeq Tclass.PagedBetree.QueryReceiptLine)))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7350|
 :pattern ( ($Is (|#PagedBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@15| |a#2#1#0@@10| |a#2#2#0@@2|) Tclass.PagedBetree.QueryReceipt))
)))
(assert (forall ((|a#3#0#0@@15| T@U) (|a#3#1#0@@10| T@U) (|a#3#2#0@@2| T@U) ($h@@201 T@U) ) (!  (=> (and (and (and (and (= (type |a#3#0#0@@15|) (SeqType BoxType)) (= (type |a#3#1#0@@10|) DatatypeTypeType)) (= (type |a#3#2#0@@2|) (SeqType BoxType))) (= (type $h@@201) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@201)) (= ($IsAlloc (|#PagedBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@15| |a#3#1#0@@10| |a#3#2#0@@2|) Tclass.PagedBetree.QueryReceipt $h@@201)  (and (and ($IsAlloc |a#3#0#0@@15| Tclass.KeyType.Key $h@@201) ($IsAlloc |a#3#1#0@@10| Tclass.PagedBetree.BetreeNode $h@@201)) ($IsAlloc |a#3#2#0@@2| (TSeq Tclass.PagedBetree.QueryReceiptLine) $h@@201))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7351|
 :pattern ( ($IsAlloc (|#PagedBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@15| |a#3#1#0@@10| |a#3#2#0@@2|) Tclass.PagedBetree.QueryReceipt $h@@201))
)))
(assert (forall ((arg0@@703 T@U) ) (! (= (type (PagedBetree.QueryReceipt.key arg0@@703)) (SeqType BoxType))
 :qid |funType:PagedBetree.QueryReceipt.key|
 :pattern ( (PagedBetree.QueryReceipt.key arg0@@703))
)))
(assert (forall ((d@@220 T@U) ($h@@202 T@U) ) (!  (=> (and (and (= (type d@@220) DatatypeTypeType) (= (type $h@@202) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@202) (and (PagedBetree.QueryReceipt.QueryReceipt_q d@@220) ($IsAlloc d@@220 Tclass.PagedBetree.QueryReceipt $h@@202)))) ($IsAlloc (PagedBetree.QueryReceipt.key d@@220) Tclass.KeyType.Key $h@@202))
 :qid |unknown.0:0|
 :skolemid |7352|
 :pattern ( ($IsAlloc (PagedBetree.QueryReceipt.key d@@220) Tclass.KeyType.Key $h@@202))
)))
(assert (forall ((arg0@@704 T@U) ) (! (= (type (PagedBetree.QueryReceipt.root arg0@@704)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceipt.root|
 :pattern ( (PagedBetree.QueryReceipt.root arg0@@704))
)))
(assert (forall ((d@@221 T@U) ($h@@203 T@U) ) (!  (=> (and (and (= (type d@@221) DatatypeTypeType) (= (type $h@@203) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@203) (and (PagedBetree.QueryReceipt.QueryReceipt_q d@@221) ($IsAlloc d@@221 Tclass.PagedBetree.QueryReceipt $h@@203)))) ($IsAlloc (PagedBetree.QueryReceipt.root d@@221) Tclass.PagedBetree.BetreeNode $h@@203))
 :qid |unknown.0:0|
 :skolemid |7353|
 :pattern ( ($IsAlloc (PagedBetree.QueryReceipt.root d@@221) Tclass.PagedBetree.BetreeNode $h@@203))
)))
(assert (forall ((arg0@@705 T@U) ) (! (= (type (PagedBetree.QueryReceipt.lines arg0@@705)) (SeqType BoxType))
 :qid |funType:PagedBetree.QueryReceipt.lines|
 :pattern ( (PagedBetree.QueryReceipt.lines arg0@@705))
)))
(assert (forall ((d@@222 T@U) ($h@@204 T@U) ) (!  (=> (and (and (= (type d@@222) DatatypeTypeType) (= (type $h@@204) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@204) (and (PagedBetree.QueryReceipt.QueryReceipt_q d@@222) ($IsAlloc d@@222 Tclass.PagedBetree.QueryReceipt $h@@204)))) ($IsAlloc (PagedBetree.QueryReceipt.lines d@@222) (TSeq Tclass.PagedBetree.QueryReceiptLine) $h@@204))
 :qid |unknown.0:0|
 :skolemid |7354|
 :pattern ( ($IsAlloc (PagedBetree.QueryReceipt.lines d@@222) (TSeq Tclass.PagedBetree.QueryReceiptLine) $h@@204))
)))
(assert (forall ((|a#4#0#0@@15| T@U) (|a#4#1#0@@10| T@U) (|a#4#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#4#0#0@@15|) (SeqType BoxType)) (= (type |a#4#1#0@@10|) DatatypeTypeType)) (= (type |a#4#2#0@@2|) (SeqType BoxType))) (= (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@15|) (Lit |a#4#1#0@@10|) (Lit |a#4#2#0@@2|)) (Lit (|#PagedBetree.QueryReceipt.QueryReceipt| |a#4#0#0@@15| |a#4#1#0@@10| |a#4#2#0@@2|))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7355|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@15|) (Lit |a#4#1#0@@10|) (Lit |a#4#2#0@@2|)))
)))
(assert (forall ((|a#5#0#0@@18| T@U) (|a#5#1#0@@12| T@U) (|a#5#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#5#0#0@@18|) (SeqType BoxType)) (= (type |a#5#1#0@@12|) DatatypeTypeType)) (= (type |a#5#2#0@@2|) (SeqType BoxType))) (= (PagedBetree.QueryReceipt.key (|#PagedBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@18| |a#5#1#0@@12| |a#5#2#0@@2|)) |a#5#0#0@@18|))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7356|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@18| |a#5#1#0@@12| |a#5#2#0@@2|))
)))
(assert (forall ((|a#6#0#0@@18| T@U) (|a#6#1#0@@12| T@U) (|a#6#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@18|) (SeqType BoxType)) (= (type |a#6#1#0@@12|) DatatypeTypeType)) (= (type |a#6#2#0@@2|) (SeqType BoxType))) (= (PagedBetree.QueryReceipt.root (|#PagedBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@18| |a#6#1#0@@12| |a#6#2#0@@2|)) |a#6#1#0@@12|))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7357|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@18| |a#6#1#0@@12| |a#6#2#0@@2|))
)))
(assert (forall ((|a#7#0#0@@17| T@U) (|a#7#1#0@@12| T@U) (|a#7#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@17|) (SeqType BoxType)) (= (type |a#7#1#0@@12|) DatatypeTypeType)) (= (type |a#7#2#0@@2|) (SeqType BoxType))) (< (DtRank |a#7#1#0@@12|) (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@17| |a#7#1#0@@12| |a#7#2#0@@2|))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7358|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@17| |a#7#1#0@@12| |a#7#2#0@@2|))
)))
(assert (forall ((|a#8#0#0@@13| T@U) (|a#8#1#0@@10| T@U) (|a#8#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#8#0#0@@13|) (SeqType BoxType)) (= (type |a#8#1#0@@10|) DatatypeTypeType)) (= (type |a#8#2#0@@2|) (SeqType BoxType))) (= (PagedBetree.QueryReceipt.lines (|#PagedBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@13| |a#8#1#0@@10| |a#8#2#0@@2|)) |a#8#2#0@@2|))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7359|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@13| |a#8#1#0@@10| |a#8#2#0@@2|))
)))
(assert (forall ((|a#9#0#0@@7| T@U) (|a#9#1#0@@4| T@U) (|a#9#2#0@@1| T@U) (i@@30 Int) ) (!  (=> (and (and (and (= (type |a#9#0#0@@7|) (SeqType BoxType)) (= (type |a#9#1#0@@4|) DatatypeTypeType)) (= (type |a#9#2#0@@1|) (SeqType BoxType))) (and (<= 0 i@@30) (< i@@30 (|Seq#Length| |a#9#2#0@@1|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#9#2#0@@1| i@@30))) (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt| |a#9#0#0@@7| |a#9#1#0@@4| |a#9#2#0@@1|))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7360|
 :pattern ( (|Seq#Index| |a#9#2#0@@1| i@@30) (|#PagedBetree.QueryReceipt.QueryReceipt| |a#9#0#0@@7| |a#9#1#0@@4| |a#9#2#0@@1|))
)))
(assert (forall ((|a#10#0#0@@7| T@U) (|a#10#1#0@@4| T@U) (|a#10#2#0@@1| T@U) ) (!  (=> (and (and (= (type |a#10#0#0@@7|) (SeqType BoxType)) (= (type |a#10#1#0@@4|) DatatypeTypeType)) (= (type |a#10#2#0@@1|) (SeqType BoxType))) (< (|Seq#Rank| |a#10#2#0@@1|) (DtRank (|#PagedBetree.QueryReceipt.QueryReceipt| |a#10#0#0@@7| |a#10#1#0@@4| |a#10#2#0@@1|))))
 :qid |PagedBetreeidfy.174:5|
 :skolemid |7361|
 :pattern ( (|#PagedBetree.QueryReceipt.QueryReceipt| |a#10#0#0@@7| |a#10#1#0@@4| |a#10#2#0@@1|))
)))
(assert (forall ((d@@223 T@U) ) (!  (=> (and (= (type d@@223) DatatypeTypeType) (|$IsA#PagedBetree.QueryReceipt| d@@223)) (PagedBetree.QueryReceipt.QueryReceipt_q d@@223))
 :qid |unknown.0:0|
 :skolemid |7362|
 :pattern ( (|$IsA#PagedBetree.QueryReceipt| d@@223))
)))
(assert (forall ((d@@224 T@U) ) (!  (=> (and (= (type d@@224) DatatypeTypeType) ($Is d@@224 Tclass.PagedBetree.QueryReceipt)) (PagedBetree.QueryReceipt.QueryReceipt_q d@@224))
 :qid |unknown.0:0|
 :skolemid |7363|
 :pattern ( (PagedBetree.QueryReceipt.QueryReceipt_q d@@224) ($Is d@@224 Tclass.PagedBetree.QueryReceipt))
)))
(assert (forall ((a@@189 T@U) (b@@138 T@U) ) (!  (=> (and (and (= (type a@@189) DatatypeTypeType) (= (type b@@138) DatatypeTypeType)) true) (= (|PagedBetree.QueryReceipt#Equal| a@@189 b@@138)  (and (and (|Seq#Equal| (PagedBetree.QueryReceipt.key a@@189) (PagedBetree.QueryReceipt.key b@@138)) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceipt.root a@@189) (PagedBetree.QueryReceipt.root b@@138))) (|Seq#Equal| (PagedBetree.QueryReceipt.lines a@@189) (PagedBetree.QueryReceipt.lines b@@138)))))
 :qid |unknown.0:0|
 :skolemid |7364|
 :pattern ( (|PagedBetree.QueryReceipt#Equal| a@@189 b@@138))
)))
(assert (forall ((a@@190 T@U) (b@@139 T@U) ) (!  (=> (and (= (type a@@190) DatatypeTypeType) (= (type b@@139) DatatypeTypeType)) (= (|PagedBetree.QueryReceipt#Equal| a@@190 b@@139) (= a@@190 b@@139)))
 :qid |unknown.0:0|
 :skolemid |7365|
 :pattern ( (|PagedBetree.QueryReceipt#Equal| a@@190 b@@139))
)))
(assert  (=> true (forall ((this@@372 T@U) ) (!  (=> (and (= (type this@@372) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Structure#canCall| this@@372) ($Is this@@372 Tclass.PagedBetree.QueryReceipt))) true)
 :qid |PagedBetreeidfy.178:15|
 :skolemid |7366|
 :pattern ( (PagedBetree.QueryReceipt.Structure this@@372))
))))
(assert (forall ((this@@373 T@U) ) (!  (=> (and (= (type this@@373) DatatypeTypeType) ($Is this@@373 Tclass.PagedBetree.QueryReceipt)) (= (|PagedBetree.QueryReceipt.Structure#requires| this@@373) true))
 :qid |PagedBetreeidfy.178:15|
 :skolemid |7367|
 :pattern ( (|PagedBetree.QueryReceipt.Structure#requires| this@@373))
)))
(assert  (=> true (forall ((this@@374 T@U) ) (!  (=> (and (= (type this@@374) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Structure#canCall| this@@374) ($Is this@@374 Tclass.PagedBetree.QueryReceipt))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@374) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) (LitInt 0))))) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceipt.root this@@374))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@374) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) (LitInt 0))))) (PagedBetree.QueryReceipt.QueryReceipt_q this@@374))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) (LitInt 0)))) (PagedBetree.QueryReceipt.root this@@374)) (and (forall ((|i#0@@184| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@184|) (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@374) (=> (INTERNAL_lt_boogie |i#0@@184| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@374) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@184|)))) (PagedBetree.QueryReceipt.QueryReceipt_q this@@374)))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7369|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@184|)))
)) (=> (forall ((|i#0@@185| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@185|) (INTERNAL_lt_boogie |i#0@@185| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374)))) (= (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@185|)))) (INTERNAL_lt_boogie |i#0@@185| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374)) 1))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7370|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@185|)))
)) (and (|$IsA#ValueMessage.Message| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (PagedBetree.QueryReceipt.lines this@@374))))) (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@374) (|Sequences.__default.Last#canCall| Tclass.PagedBetree.QueryReceiptLine (PagedBetree.QueryReceipt.lines this@@374))) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (PagedBetree.QueryReceipt.lines this@@374))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PagedBetree.QueryReceipt.Structure this@@374)  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) (LitInt 0)))) (PagedBetree.QueryReceipt.root this@@374))) (forall ((|i#0@@186| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@186|) (INTERNAL_lt_boogie |i#0@@186| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374)))) (= (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@186|)))) (INTERNAL_lt_boogie |i#0@@186| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@374)) 1))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7368|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@374) |i#0@@186|)))
))) (|ValueMessage.Message#Equal| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (PagedBetree.QueryReceipt.lines this@@374)))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PagedBetreeidfy.178:15|
 :skolemid |7371|
 :pattern ( (PagedBetree.QueryReceipt.Structure this@@374))
))))
(assert  (=> true (forall ((this@@375 T@U) ) (!  (=> (and (= (type this@@375) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Structure#canCall| (Lit this@@375)) ($Is this@@375 Tclass.PagedBetree.QueryReceipt))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) (LitInt 0))))) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.QueryReceipt.root (Lit this@@375))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) (LitInt 0))))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) (LitInt 0)))) (PagedBetree.QueryReceipt.root (Lit this@@375))) (and (forall ((|i#1@@74| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@74|) (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)) (=> (INTERNAL_lt_boogie |i#1@@74| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) |i#1@@74|)))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375))))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7373|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@375) |i#1@@74|)))
)) (=> (forall ((|i#1@@75| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@75|) (INTERNAL_lt_boogie |i#1@@75| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375)))))) (= (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) |i#1@@75|)))) (INTERNAL_lt_boogie |i#1@@75| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375)))) 1))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7374|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@375) |i#1@@75|)))
)) (and (|$IsA#ValueMessage.Message| (Lit (PagedBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))))))) (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@375)) (|Sequences.__default.Last#canCall| Tclass.PagedBetree.QueryReceiptLine (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375)))))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PagedBetree.QueryReceipt.Structure (Lit this@@375))  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) (LitInt 0)))) (PagedBetree.QueryReceipt.root (Lit this@@375)))) (forall ((|i#1@@76| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@76|) (INTERNAL_lt_boogie |i#1@@76| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375)))))) (= (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))) |i#1@@76|)))) (INTERNAL_lt_boogie |i#1@@76| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375)))) 1))))
 :qid |PagedBetreeidfy.182:18|
 :skolemid |7372|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@375) |i#1@@76|)))
))) (|ValueMessage.Message#Equal| (PagedBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PagedBetree.QueryReceiptLine (Lit (PagedBetree.QueryReceipt.lines (Lit this@@375))))))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PagedBetreeidfy.178:15|
 :weight 3
 :skolemid |7375|
 :pattern ( (PagedBetree.QueryReceipt.Structure (Lit this@@375)))
))))
(assert  (=> true (forall ((this@@376 T@U) ) (!  (=> (and (= (type this@@376) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall| this@@376) ($Is this@@376 Tclass.PagedBetree.QueryReceipt))) true)
 :qid |PagedBetreeidfy.186:15|
 :skolemid |7376|
 :pattern ( (PagedBetree.QueryReceipt.AllLinesWF this@@376))
))))
(assert (forall ((this@@377 T@U) ) (!  (=> (and (= (type this@@377) DatatypeTypeType) ($Is this@@377 Tclass.PagedBetree.QueryReceipt)) (= (|PagedBetree.QueryReceipt.AllLinesWF#requires| this@@377) true))
 :qid |PagedBetreeidfy.186:15|
 :skolemid |7377|
 :pattern ( (|PagedBetree.QueryReceipt.AllLinesWF#requires| this@@377))
)))
(assert  (=> true (forall ((this@@378 T@U) ) (!  (=> (and (= (type this@@378) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall| this@@378) ($Is this@@378 Tclass.PagedBetree.QueryReceipt))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@187| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@187|) (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@378) (=> (INTERNAL_lt_boogie |i#0@@187| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@378))) (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@378) (|PagedBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@378) |i#0@@187|)))))))
 :qid |PagedBetreeidfy.188:18|
 :skolemid |7379|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@378) |i#0@@187|)))
))) (= (PagedBetree.QueryReceipt.AllLinesWF this@@378)  (and true (forall ((|i#0@@188| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@188|) (INTERNAL_lt_boogie |i#0@@188| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@378)))) (PagedBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@378) |i#0@@188|))))
 :qid |PagedBetreeidfy.188:18|
 :skolemid |7378|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@378) |i#0@@188|)))
))))))
 :qid |PagedBetreeidfy.186:15|
 :skolemid |7380|
 :pattern ( (PagedBetree.QueryReceipt.AllLinesWF this@@378))
))))
(assert  (=> true (forall ((this@@379 T@U) ) (!  (=> (and (= (type this@@379) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@379)) ($Is this@@379 Tclass.PagedBetree.QueryReceipt))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@77| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@77|) (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@379)) (=> (INTERNAL_lt_boogie |i#1@@77| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@379))))) (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@379)) (|PagedBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@379))) |i#1@@77|)))))))
 :qid |PagedBetreeidfy.188:18|
 :skolemid |7382|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@379) |i#1@@77|)))
))) (= (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@379))  (and true (forall ((|i#1@@78| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@78|) (INTERNAL_lt_boogie |i#1@@78| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@379)))))) (PagedBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@379))) |i#1@@78|))))
 :qid |PagedBetreeidfy.188:18|
 :skolemid |7381|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@379) |i#1@@78|)))
))))))
 :qid |PagedBetreeidfy.186:15|
 :weight 3
 :skolemid |7383|
 :pattern ( (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@379)))
))))
(assert (forall ((arg0@@706 T@U) (arg1@@372 Int) ) (! (= (type (PagedBetree.QueryReceipt.ChildAt arg0@@706 arg1@@372)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceipt.ChildAt|
 :pattern ( (PagedBetree.QueryReceipt.ChildAt arg0@@706 arg1@@372))
)))
(assert  (=> true (forall ((this@@380 T@U) (|i#0@@189| Int) ) (!  (=> (and (= (type this@@380) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildAt#canCall| this@@380 |i#0@@189|) (and (and ($Is this@@380 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@189|)) (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@380) (PagedBetree.QueryReceipt.Structure this@@380)) (INTERNAL_lt_boogie |i#0@@189| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@380)) 1)))))) ($Is (PagedBetree.QueryReceipt.ChildAt this@@380 |i#0@@189|) Tclass.PagedBetree.BetreeNode))
 :qid |PagedBetreeidfy.191:14|
 :skolemid |7384|
 :pattern ( (PagedBetree.QueryReceipt.ChildAt this@@380 |i#0@@189|))
))))
(assert (forall ((this@@381 T@U) (|i#0@@190| Int) ) (!  (=> (= (type this@@381) DatatypeTypeType) (=> (and ($Is this@@381 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@190|)) (= (|PagedBetree.QueryReceipt.ChildAt#requires| this@@381 |i#0@@190|)  (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@381) (PagedBetree.QueryReceipt.Structure this@@381)) (INTERNAL_lt_boogie |i#0@@190| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@381)) 1))))))
 :qid |PagedBetreeidfy.191:14|
 :skolemid |7385|
 :pattern ( (|PagedBetree.QueryReceipt.ChildAt#requires| this@@381 |i#0@@190|))
)))
(assert  (=> true (forall ((this@@382 T@U) (|i#0@@191| Int) ) (!  (=> (and (= (type this@@382) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildAt#canCall| this@@382 |i#0@@191|) (and (and ($Is this@@382 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@191|)) (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@382) (PagedBetree.QueryReceipt.Structure this@@382)) (INTERNAL_lt_boogie |i#0@@191| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@382)) 1)))))) (and (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@382) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@382) |i#0@@191|)))) (PagedBetree.QueryReceipt.QueryReceipt_q this@@382)) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@382) |i#0@@191|))) (PagedBetree.QueryReceipt.key this@@382))) (= (PagedBetree.QueryReceipt.ChildAt this@@382 |i#0@@191|) (PagedBetree.BetreeNode.Child (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@382) |i#0@@191|))) (PagedBetree.QueryReceipt.key this@@382)))))
 :qid |PagedBetreeidfy.191:14|
 :skolemid |7386|
 :pattern ( (PagedBetree.QueryReceipt.ChildAt this@@382 |i#0@@191|))
))))
(assert  (=> true (forall ((this@@383 T@U) (|i#0@@192| Int) ) (!  (=> (and (= (type this@@383) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildAt#canCall| (Lit this@@383) (LitInt |i#0@@192|)) (and (and ($Is this@@383 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@192|)) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@383))))) (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure (Lit this@@383)))))) (INTERNAL_lt_boogie |i#0@@192| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@383)))) 1)))))) (and (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@383)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@383))) (LitInt |i#0@@192|))))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@383))) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@383))) (LitInt |i#0@@192|)))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@383))))) (= (PagedBetree.QueryReceipt.ChildAt (Lit this@@383) (LitInt |i#0@@192|)) (PagedBetree.BetreeNode.Child (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@383))) (LitInt |i#0@@192|)))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@383)))))))
 :qid |PagedBetreeidfy.191:14|
 :weight 3
 :skolemid |7387|
 :pattern ( (PagedBetree.QueryReceipt.ChildAt (Lit this@@383) (LitInt |i#0@@192|)))
))))
(assert  (=> true (forall ((this@@384 T@U) (|i#0@@193| Int) ) (!  (=> (and (= (type this@@384) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall| this@@384 |i#0@@193|) (and (and ($Is this@@384 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@193|)) (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@384) (PagedBetree.QueryReceipt.Structure this@@384)) (INTERNAL_lt_boogie |i#0@@193| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@384)) 1)))))) true)
 :qid |PagedBetreeidfy.200:15|
 :skolemid |7388|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@384 |i#0@@193|))
))))
(assert (forall ((this@@385 T@U) (|i#0@@194| Int) ) (!  (=> (= (type this@@385) DatatypeTypeType) (=> (and ($Is this@@385 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@194|)) (= (|PagedBetree.QueryReceipt.ChildLinkedAt#requires| this@@385 |i#0@@194|)  (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@385) (PagedBetree.QueryReceipt.Structure this@@385)) (INTERNAL_lt_boogie |i#0@@194| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@385)) 1))))))
 :qid |PagedBetreeidfy.200:15|
 :skolemid |7389|
 :pattern ( (|PagedBetree.QueryReceipt.ChildLinkedAt#requires| this@@385 |i#0@@194|))
)))
(assert  (=> true (forall ((this@@386 T@U) (|i#0@@195| Int) ) (!  (=> (and (= (type this@@386) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall| this@@386 |i#0@@195|) (and (and ($Is this@@386 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@195|)) (and (and (PagedBetree.QueryReceipt.AllLinesWF this@@386) (PagedBetree.QueryReceipt.Structure this@@386)) (INTERNAL_lt_boogie |i#0@@195| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@386)) 1)))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@386) (INTERNAL_add_boogie |i#0@@195| 1))))) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceipt.ChildAt this@@386 |i#0@@195|))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@386) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@386) (INTERNAL_add_boogie |i#0@@195| 1))))) (|PagedBetree.QueryReceipt.ChildAt#canCall| this@@386 |i#0@@195|))) (= (PagedBetree.QueryReceipt.ChildLinkedAt this@@386 |i#0@@195|) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@386) (INTERNAL_add_boogie |i#0@@195| 1)))) (PagedBetree.QueryReceipt.ChildAt this@@386 |i#0@@195|)))))
 :qid |PagedBetreeidfy.200:15|
 :skolemid |7390|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@386 |i#0@@195|))
))))
(assert  (=> true (forall ((this@@387 T@U) (|i#0@@196| Int) ) (!  (=> (and (= (type this@@387) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@387) (LitInt |i#0@@196|)) (and (and ($Is this@@387 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@196|)) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@387))))) (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure (Lit this@@387)))))) (INTERNAL_lt_boogie |i#0@@196| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@387)))) 1)))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@387))) (LitInt (INTERNAL_add_boogie |i#0@@196| 1)))))) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.QueryReceipt.ChildAt (Lit this@@387) (LitInt |i#0@@196|))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@387)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@387))) (LitInt (INTERNAL_add_boogie |i#0@@196| 1)))))) (|PagedBetree.QueryReceipt.ChildAt#canCall| (Lit this@@387) (LitInt |i#0@@196|)))) (= (PagedBetree.QueryReceipt.ChildLinkedAt (Lit this@@387) (LitInt |i#0@@196|)) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@387))) (LitInt (INTERNAL_add_boogie |i#0@@196| 1))))) (PagedBetree.QueryReceipt.ChildAt (Lit this@@387) (LitInt |i#0@@196|))))))
 :qid |PagedBetreeidfy.200:15|
 :weight 3
 :skolemid |7391|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt (Lit this@@387) (LitInt |i#0@@196|)))
))))
(assert (forall ((arg0@@707 T@U) (arg1@@373 Int) ) (! (= (type (PagedBetree.QueryReceipt.ResultAt arg0@@707 arg1@@373)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceipt.ResultAt|
 :pattern ( (PagedBetree.QueryReceipt.ResultAt arg0@@707 arg1@@373))
)))
(assert  (=> true (forall ((this@@388 T@U) (|i#0@@197| Int) ) (!  (=> (and (= (type this@@388) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultAt#canCall| this@@388 |i#0@@197|) (and (and ($Is this@@388 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@197|)) (INTERNAL_lt_boogie |i#0@@197| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@388)))))) ($Is (PagedBetree.QueryReceipt.ResultAt this@@388 |i#0@@197|) Tclass.ValueMessage.Message))
 :qid |PagedBetreeidfy.208:14|
 :skolemid |7392|
 :pattern ( (PagedBetree.QueryReceipt.ResultAt this@@388 |i#0@@197|))
))))
(assert (forall ((this@@389 T@U) (|i#0@@198| Int) ) (!  (=> (= (type this@@389) DatatypeTypeType) (=> (and ($Is this@@389 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@198|)) (= (|PagedBetree.QueryReceipt.ResultAt#requires| this@@389 |i#0@@198|) (INTERNAL_lt_boogie |i#0@@198| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@389))))))
 :qid |PagedBetreeidfy.208:14|
 :skolemid |7393|
 :pattern ( (|PagedBetree.QueryReceipt.ResultAt#requires| this@@389 |i#0@@198|))
)))
(assert  (=> true (forall ((this@@390 T@U) (|i#0@@199| Int) ) (!  (=> (and (= (type this@@390) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultAt#canCall| this@@390 |i#0@@199|) (and (and ($Is this@@390 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@199|)) (INTERNAL_lt_boogie |i#0@@199| (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@390)))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@390) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@390) |i#0@@199|)))) (= (PagedBetree.QueryReceipt.ResultAt this@@390 |i#0@@199|) (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@390) |i#0@@199|))))))
 :qid |PagedBetreeidfy.208:14|
 :skolemid |7394|
 :pattern ( (PagedBetree.QueryReceipt.ResultAt this@@390 |i#0@@199|))
))))
(assert  (=> true (forall ((this@@391 T@U) (|i#0@@200| Int) ) (!  (=> (and (= (type this@@391) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultAt#canCall| (Lit this@@391) (LitInt |i#0@@200|)) (and (and ($Is this@@391 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@200|)) (INTERNAL_lt_boogie |i#0@@200| (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@391)))))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@391)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@391))) (LitInt |i#0@@200|))))) (= (PagedBetree.QueryReceipt.ResultAt (Lit this@@391) (LitInt |i#0@@200|)) (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@391))) (LitInt |i#0@@200|)))))))
 :qid |PagedBetreeidfy.208:14|
 :weight 3
 :skolemid |7395|
 :pattern ( (PagedBetree.QueryReceipt.ResultAt (Lit this@@391) (LitInt |i#0@@200|)))
))))
(assert  (=> true (forall ((this@@392 T@U) (|i#0@@201| Int) ) (!  (=> (and (= (type this@@392) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall| this@@392 |i#0@@201|) (and (and ($Is this@@392 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@201|)) (and (and (PagedBetree.QueryReceipt.Structure this@@392) (PagedBetree.QueryReceipt.AllLinesWF this@@392)) (INTERNAL_lt_boogie |i#0@@201| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@392)) 1)))))) true)
 :qid |PagedBetreeidfy.214:15|
 :skolemid |7396|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@392 |i#0@@201|))
))))
(assert (forall ((this@@393 T@U) (|i#0@@202| Int) ) (!  (=> (= (type this@@393) DatatypeTypeType) (=> (and ($Is this@@393 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@202|)) (= (|PagedBetree.QueryReceipt.ResultLinkedAt#requires| this@@393 |i#0@@202|)  (and (and (PagedBetree.QueryReceipt.Structure this@@393) (PagedBetree.QueryReceipt.AllLinesWF this@@393)) (INTERNAL_lt_boogie |i#0@@202| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@393)) 1))))))
 :qid |PagedBetreeidfy.214:15|
 :skolemid |7397|
 :pattern ( (|PagedBetree.QueryReceipt.ResultLinkedAt#requires| this@@393 |i#0@@202|))
)))
(assert  (=> true (forall ((this@@394 T@U) (|i#0@@203| Int) ) (!  (=> (and (= (type this@@394) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall| this@@394 |i#0@@203|) (and (and ($Is this@@394 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@203|)) (and (and (PagedBetree.QueryReceipt.Structure this@@394) (PagedBetree.QueryReceipt.AllLinesWF this@@394)) (INTERNAL_lt_boogie |i#0@@203| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@394)) 1)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (PagedBetree.QueryReceipt.key this@@394)) (PagedBetree.QueryReceipt.ResultAt this@@394 (INTERNAL_add_boogie |i#0@@203| 1))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@394) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (and (and (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@394) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (PagedBetree.QueryReceipt.QueryReceipt_q this@@394)) (|Buffers.BufferStack.Query#canCall| (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (PagedBetree.QueryReceipt.key this@@394))) (|PagedBetree.QueryReceipt.ResultAt#canCall| this@@394 (INTERNAL_add_boogie |i#0@@203| 1))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (PagedBetree.QueryReceipt.key this@@394)) (PagedBetree.QueryReceipt.ResultAt this@@394 (INTERNAL_add_boogie |i#0@@203| 1))))))) (= (PagedBetree.QueryReceipt.ResultLinkedAt this@@394 |i#0@@203|)  (and true (|ValueMessage.Message#Equal| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PagedBetree.QueryReceipt.lines this@@394) |i#0@@203|)))) (PagedBetree.QueryReceipt.key this@@394)) (PagedBetree.QueryReceipt.ResultAt this@@394 (INTERNAL_add_boogie |i#0@@203| 1))))))))
 :qid |PagedBetreeidfy.214:15|
 :skolemid |7398|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@394 |i#0@@203|))
))))
(assert  (=> true (forall ((this@@395 T@U) (|i#0@@204| Int) ) (!  (=> (and (= (type this@@395) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@395) (LitInt |i#0@@204|)) (and (and ($Is this@@395 Tclass.PagedBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@204|)) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure (Lit this@@395))))) (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@395)))))) (INTERNAL_lt_boogie |i#0@@204| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395)))) 1)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@395)))) (Lit (PagedBetree.QueryReceipt.ResultAt (Lit this@@395) (LitInt (INTERNAL_add_boogie |i#0@@204| 1))))))) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@395)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (and (and (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@395)) (PagedBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@395))) (|Buffers.BufferStack.Query#canCall| (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@395))))) (|PagedBetree.QueryReceipt.ResultAt#canCall| (Lit this@@395) (LitInt (INTERNAL_add_boogie |i#0@@204| 1)))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@395)))) (Lit (PagedBetree.QueryReceipt.ResultAt (Lit this@@395) (LitInt (INTERNAL_add_boogie |i#0@@204| 1))))))))) (= (PagedBetree.QueryReceipt.ResultLinkedAt (Lit this@@395) (LitInt |i#0@@204|))  (and true (|ValueMessage.Message#Equal| (PagedBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|)))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers (PagedBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@395))) (LitInt |i#0@@204|))))) (Lit (PagedBetree.QueryReceipt.key (Lit this@@395)))) (Lit (PagedBetree.QueryReceipt.ResultAt (Lit this@@395) (LitInt (INTERNAL_add_boogie |i#0@@204| 1))))))))))
 :qid |PagedBetreeidfy.214:15|
 :weight 3
 :skolemid |7399|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt (Lit this@@395) (LitInt |i#0@@204|)))
))))
(assert  (=> true (forall ((this@@396 T@U) ) (!  (=> (and (= (type this@@396) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Valid#canCall| this@@396) ($Is this@@396 Tclass.PagedBetree.QueryReceipt))) true)
 :qid |PagedBetreeidfy.222:15|
 :skolemid |7400|
 :pattern ( (PagedBetree.QueryReceipt.Valid this@@396))
))))
(assert (forall ((this@@397 T@U) ) (!  (=> (and (= (type this@@397) DatatypeTypeType) ($Is this@@397 Tclass.PagedBetree.QueryReceipt)) (= (|PagedBetree.QueryReceipt.Valid#requires| this@@397) true))
 :qid |PagedBetreeidfy.222:15|
 :skolemid |7401|
 :pattern ( (|PagedBetree.QueryReceipt.Valid#requires| this@@397))
)))
(assert  (=> true (forall ((this@@398 T@U) ) (!  (=> (and (= (type this@@398) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Valid#canCall| this@@398) ($Is this@@398 Tclass.PagedBetree.QueryReceipt))) (and (and (|PagedBetree.QueryReceipt.Structure#canCall| this@@398) (=> (PagedBetree.QueryReceipt.Structure this@@398) (and (|PagedBetree.QueryReceipt.AllLinesWF#canCall| this@@398) (=> (PagedBetree.QueryReceipt.AllLinesWF this@@398) (and (forall ((|i#0@@205| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@205|) (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@398) (=> (INTERNAL_lt_boogie |i#0@@205| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@398)) 1)) (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall| this@@398 |i#0@@205|))))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7404|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@398 |i#0@@205|))
)) (=> (forall ((|i#0@@206| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@206|) (INTERNAL_lt_boogie |i#0@@206| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@398)) 1))) (PagedBetree.QueryReceipt.ChildLinkedAt this@@398 |i#0@@206|))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7406|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@398 |i#0@@206|))
)) (forall ((|i#1@@79| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@79|) (and (PagedBetree.QueryReceipt.QueryReceipt_q this@@398) (=> (INTERNAL_lt_boogie |i#1@@79| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@398)) 1)) (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall| this@@398 |i#1@@79|))))
 :qid |PagedBetreeidfy.227:18|
 :skolemid |7405|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@398 |i#1@@79|))
)))))))) (= (PagedBetree.QueryReceipt.Valid this@@398)  (and (and (and (PagedBetree.QueryReceipt.Structure this@@398) (PagedBetree.QueryReceipt.AllLinesWF this@@398)) (forall ((|i#0@@207| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@207|) (INTERNAL_lt_boogie |i#0@@207| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@398)) 1))) (PagedBetree.QueryReceipt.ChildLinkedAt this@@398 |i#0@@207|))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7402|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@398 |i#0@@207|))
))) (forall ((|i#1@@80| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@80|) (INTERNAL_lt_boogie |i#1@@80| (INTERNAL_sub_boogie (|Seq#Length| (PagedBetree.QueryReceipt.lines this@@398)) 1))) (PagedBetree.QueryReceipt.ResultLinkedAt this@@398 |i#1@@80|))
 :qid |PagedBetreeidfy.227:18|
 :skolemid |7403|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@398 |i#1@@80|))
))))))
 :qid |PagedBetreeidfy.222:15|
 :skolemid |7407|
 :pattern ( (PagedBetree.QueryReceipt.Valid this@@398))
))))
(assert  (=> true (forall ((this@@399 T@U) ) (!  (=> (and (= (type this@@399) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Valid#canCall| (Lit this@@399)) ($Is this@@399 Tclass.PagedBetree.QueryReceipt))) (and (and (|PagedBetree.QueryReceipt.Structure#canCall| (Lit this@@399)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure (Lit this@@399))))) (and (|PagedBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@399)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@399))))) (and (forall ((|i#2@@21| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#2@@21|) (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@399)) (=> (INTERNAL_lt_boogie |i#2@@21| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@399)))) 1)) (|PagedBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@399) |i#2@@21|))))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7410|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@399 |i#2@@21|))
)) (=> (forall ((|i#2@@22| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@22|) (INTERNAL_lt_boogie |i#2@@22| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@399)))) 1))) (PagedBetree.QueryReceipt.ChildLinkedAt (Lit this@@399) |i#2@@22|))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7412|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@399 |i#2@@22|))
)) (forall ((|i#3@@11| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@11|) (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@399)) (=> (INTERNAL_lt_boogie |i#3@@11| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@399)))) 1)) (|PagedBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@399) |i#3@@11|))))
 :qid |PagedBetreeidfy.227:18|
 :skolemid |7411|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@399 |i#3@@11|))
)))))))) (= (PagedBetree.QueryReceipt.Valid (Lit this@@399))  (and (and (and (PagedBetree.QueryReceipt.Structure (Lit this@@399)) (PagedBetree.QueryReceipt.AllLinesWF (Lit this@@399))) (forall ((|i#2@@23| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@23|) (INTERNAL_lt_boogie |i#2@@23| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@399)))) 1))) (PagedBetree.QueryReceipt.ChildLinkedAt (Lit this@@399) |i#2@@23|))
 :qid |PagedBetreeidfy.226:18|
 :skolemid |7408|
 :pattern ( (PagedBetree.QueryReceipt.ChildLinkedAt this@@399 |i#2@@23|))
))) (forall ((|i#3@@12| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@12|) (INTERNAL_lt_boogie |i#3@@12| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit this@@399)))) 1))) (PagedBetree.QueryReceipt.ResultLinkedAt (Lit this@@399) |i#3@@12|))
 :qid |PagedBetreeidfy.227:18|
 :skolemid |7409|
 :pattern ( (PagedBetree.QueryReceipt.ResultLinkedAt this@@399 |i#3@@12|))
))))))
 :qid |PagedBetreeidfy.222:15|
 :weight 3
 :skolemid |7413|
 :pattern ( (PagedBetree.QueryReceipt.Valid (Lit this@@399)))
))))
(assert (forall ((arg0@@708 T@U) ) (! (= (type (PagedBetree.QueryReceipt.Result arg0@@708)) DatatypeTypeType)
 :qid |funType:PagedBetree.QueryReceipt.Result|
 :pattern ( (PagedBetree.QueryReceipt.Result arg0@@708))
)))
(assert  (=> true (forall ((this@@400 T@U) ) (!  (=> (and (= (type this@@400) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Result#canCall| this@@400) (and ($Is this@@400 Tclass.PagedBetree.QueryReceipt) (PagedBetree.QueryReceipt.Structure this@@400)))) ($Is (PagedBetree.QueryReceipt.Result this@@400) Tclass.ValueMessage.Message))
 :qid |PagedBetreeidfy.230:14|
 :skolemid |7414|
 :pattern ( (PagedBetree.QueryReceipt.Result this@@400))
))))
(assert (forall ((this@@401 T@U) ) (!  (=> (and (= (type this@@401) DatatypeTypeType) ($Is this@@401 Tclass.PagedBetree.QueryReceipt)) (= (|PagedBetree.QueryReceipt.Result#requires| this@@401) (PagedBetree.QueryReceipt.Structure this@@401)))
 :qid |PagedBetreeidfy.230:14|
 :skolemid |7415|
 :pattern ( (|PagedBetree.QueryReceipt.Result#requires| this@@401))
)))
(assert  (=> true (forall ((this@@402 T@U) ) (!  (=> (and (= (type this@@402) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Result#canCall| this@@402) (and ($Is this@@402 Tclass.PagedBetree.QueryReceipt) (PagedBetree.QueryReceipt.Structure this@@402)))) (and (|PagedBetree.QueryReceipt.ResultAt#canCall| this@@402 (LitInt 0)) (= (PagedBetree.QueryReceipt.Result this@@402) (PagedBetree.QueryReceipt.ResultAt this@@402 (LitInt 0)))))
 :qid |PagedBetreeidfy.230:14|
 :skolemid |7416|
 :pattern ( (PagedBetree.QueryReceipt.Result this@@402))
))))
(assert  (=> true (forall ((this@@403 T@U) ) (!  (=> (and (= (type this@@403) DatatypeTypeType) (or (|PagedBetree.QueryReceipt.Result#canCall| (Lit this@@403)) (and ($Is this@@403 Tclass.PagedBetree.QueryReceipt) (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Structure (Lit this@@403)))))))) (and (|PagedBetree.QueryReceipt.ResultAt#canCall| (Lit this@@403) (LitInt 0)) (= (PagedBetree.QueryReceipt.Result (Lit this@@403)) (Lit (PagedBetree.QueryReceipt.ResultAt (Lit this@@403) (LitInt 0))))))
 :qid |PagedBetreeidfy.230:14|
 :weight 3
 :skolemid |7417|
 :pattern ( (PagedBetree.QueryReceipt.Result (Lit this@@403)))
))))
(assert  (=> true (forall ((this@@404 T@U) (|root#0@@7| T@U) (|key#0@@244| T@U) ) (!  (=> (and (and (and (= (type this@@404) DatatypeTypeType) (= (type |root#0@@7|) DatatypeTypeType)) (= (type |key#0@@244|) (SeqType BoxType))) (or (|PagedBetree.QueryReceipt.ValidFor#canCall| this@@404 |root#0@@7| |key#0@@244|) (and (and ($Is this@@404 Tclass.PagedBetree.QueryReceipt) ($Is |root#0@@7| Tclass.PagedBetree.BetreeNode)) ($Is |key#0@@244| Tclass.KeyType.Key)))) true)
 :qid |PagedBetreeidfy.236:15|
 :skolemid |7418|
 :pattern ( (PagedBetree.QueryReceipt.ValidFor this@@404 |root#0@@7| |key#0@@244|))
))))
(assert (forall ((this@@405 T@U) (|root#0@@8| T@U) (|key#0@@245| T@U) ) (!  (=> (and (and (and (= (type this@@405) DatatypeTypeType) (= (type |root#0@@8|) DatatypeTypeType)) (= (type |key#0@@245|) (SeqType BoxType))) (and (and ($Is this@@405 Tclass.PagedBetree.QueryReceipt) ($Is |root#0@@8| Tclass.PagedBetree.BetreeNode)) ($Is |key#0@@245| Tclass.KeyType.Key))) (= (|PagedBetree.QueryReceipt.ValidFor#requires| this@@405 |root#0@@8| |key#0@@245|) true))
 :qid |PagedBetreeidfy.236:15|
 :skolemid |7419|
 :pattern ( (|PagedBetree.QueryReceipt.ValidFor#requires| this@@405 |root#0@@8| |key#0@@245|))
)))
(assert  (=> true (forall ((this@@406 T@U) (|root#0@@9| T@U) (|key#0@@246| T@U) ) (!  (=> (and (and (and (= (type this@@406) DatatypeTypeType) (= (type |root#0@@9|) DatatypeTypeType)) (= (type |key#0@@246|) (SeqType BoxType))) (or (|PagedBetree.QueryReceipt.ValidFor#canCall| this@@406 |root#0@@9| |key#0@@246|) (and (and ($Is this@@406 Tclass.PagedBetree.QueryReceipt) ($Is |root#0@@9| Tclass.PagedBetree.BetreeNode)) ($Is |key#0@@246| Tclass.KeyType.Key)))) (and (and (|PagedBetree.QueryReceipt.Valid#canCall| this@@406) (=> (PagedBetree.QueryReceipt.Valid this@@406) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.QueryReceipt.root this@@406)) (|$IsA#PagedBetree.BetreeNode| |root#0@@9|)) (PagedBetree.QueryReceipt.QueryReceipt_q this@@406)) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceipt.root this@@406) |root#0@@9|) (PagedBetree.QueryReceipt.QueryReceipt_q this@@406))))) (= (PagedBetree.QueryReceipt.ValidFor this@@406 |root#0@@9| |key#0@@246|)  (and (and (PagedBetree.QueryReceipt.Valid this@@406) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceipt.root this@@406) |root#0@@9|)) (|Seq#Equal| (PagedBetree.QueryReceipt.key this@@406) |key#0@@246|)))))
 :qid |PagedBetreeidfy.236:15|
 :skolemid |7420|
 :pattern ( (PagedBetree.QueryReceipt.ValidFor this@@406 |root#0@@9| |key#0@@246|))
))))
(assert  (=> true (forall ((this@@407 T@U) (|root#0@@10| T@U) (|key#0@@247| T@U) ) (!  (=> (and (and (and (= (type this@@407) DatatypeTypeType) (= (type |root#0@@10|) DatatypeTypeType)) (= (type |key#0@@247|) (SeqType BoxType))) (or (|PagedBetree.QueryReceipt.ValidFor#canCall| (Lit this@@407) (Lit |root#0@@10|) (Lit |key#0@@247|)) (and (and ($Is this@@407 Tclass.PagedBetree.QueryReceipt) ($Is |root#0@@10| Tclass.PagedBetree.BetreeNode)) ($Is |key#0@@247| Tclass.KeyType.Key)))) (and (and (|PagedBetree.QueryReceipt.Valid#canCall| (Lit this@@407)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Valid (Lit this@@407))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.QueryReceipt.root (Lit this@@407)))) (|$IsA#PagedBetree.BetreeNode| (Lit |root#0@@10|))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@407))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceipt.root (Lit this@@407)) |root#0@@10|) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit this@@407)))))) (= (PagedBetree.QueryReceipt.ValidFor (Lit this@@407) (Lit |root#0@@10|) (Lit |key#0@@247|))  (and (and (PagedBetree.QueryReceipt.Valid (Lit this@@407)) (|PagedBetree.BetreeNode#Equal| (PagedBetree.QueryReceipt.root (Lit this@@407)) |root#0@@10|)) (|Seq#Equal| (PagedBetree.QueryReceipt.key (Lit this@@407)) |key#0@@247|)))))
 :qid |PagedBetreeidfy.236:15|
 :weight 3
 :skolemid |7421|
 :pattern ( (PagedBetree.QueryReceipt.ValidFor (Lit this@@407) (Lit |root#0@@10|) (Lit |key#0@@247|)))
))))
(assert (forall ((|a#0#0#0@@16| T@U) (|a#0#1#0@@11| T@U) ) (!  (=> (and (= (type |a#0#0#0@@16|) DatatypeTypeType) (= (type |a#0#1#0@@11|) DatatypeTypeType)) (= (DatatypeCtorId (|#PagedBetree.Variables.Variables| |a#0#0#0@@16| |a#0#1#0@@11|)) |##PagedBetree.Variables.Variables|))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7422|
 :pattern ( (|#PagedBetree.Variables.Variables| |a#0#0#0@@16| |a#0#1#0@@11|))
)))
(assert (forall ((d@@225 T@U) ) (!  (=> (= (type d@@225) DatatypeTypeType) (= (PagedBetree.Variables.Variables_q d@@225) (= (DatatypeCtorId d@@225) |##PagedBetree.Variables.Variables|)))
 :qid |unknown.0:0|
 :skolemid |7423|
 :pattern ( (PagedBetree.Variables.Variables_q d@@225))
)))
(assert (forall ((d@@226 T@U) ) (!  (=> (and (= (type d@@226) DatatypeTypeType) (PagedBetree.Variables.Variables_q d@@226)) (exists ((|a#1#0#0@@16| T@U) (|a#1#1#0@@11| T@U) ) (!  (and (and (= (type |a#1#0#0@@16|) DatatypeTypeType) (= (type |a#1#1#0@@11|) DatatypeTypeType)) (= d@@226 (|#PagedBetree.Variables.Variables| |a#1#0#0@@16| |a#1#1#0@@11|)))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7424|
 :no-pattern (type |a#1#0#0@@16|)
 :no-pattern (type |a#1#1#0@@11|)
 :no-pattern (U_2_int |a#1#0#0@@16|)
 :no-pattern (U_2_bool |a#1#0#0@@16|)
 :no-pattern (U_2_int |a#1#1#0@@11|)
 :no-pattern (U_2_bool |a#1#1#0@@11|)
)))
 :qid |unknown.0:0|
 :skolemid |7425|
 :pattern ( (PagedBetree.Variables.Variables_q d@@226))
)))
(assert (forall ((|a#2#0#0@@16| T@U) (|a#2#1#0@@11| T@U) ) (!  (=> (and (= (type |a#2#0#0@@16|) DatatypeTypeType) (= (type |a#2#1#0@@11|) DatatypeTypeType)) (= ($Is (|#PagedBetree.Variables.Variables| |a#2#0#0@@16| |a#2#1#0@@11|) Tclass.PagedBetree.Variables)  (and ($Is |a#2#0#0@@16| Tclass.MemtableMod.Memtable) ($Is |a#2#1#0@@11| Tclass.PagedBetree.BetreeNode))))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7426|
 :pattern ( ($Is (|#PagedBetree.Variables.Variables| |a#2#0#0@@16| |a#2#1#0@@11|) Tclass.PagedBetree.Variables))
)))
(assert (forall ((|a#3#0#0@@16| T@U) (|a#3#1#0@@11| T@U) ($h@@205 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@16|) DatatypeTypeType) (= (type |a#3#1#0@@11|) DatatypeTypeType)) (= (type $h@@205) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@205)) (= ($IsAlloc (|#PagedBetree.Variables.Variables| |a#3#0#0@@16| |a#3#1#0@@11|) Tclass.PagedBetree.Variables $h@@205)  (and ($IsAlloc |a#3#0#0@@16| Tclass.MemtableMod.Memtable $h@@205) ($IsAlloc |a#3#1#0@@11| Tclass.PagedBetree.BetreeNode $h@@205))))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7427|
 :pattern ( ($IsAlloc (|#PagedBetree.Variables.Variables| |a#3#0#0@@16| |a#3#1#0@@11|) Tclass.PagedBetree.Variables $h@@205))
)))
(assert (forall ((arg0@@709 T@U) ) (! (= (type (PagedBetree.Variables.memtable arg0@@709)) DatatypeTypeType)
 :qid |funType:PagedBetree.Variables.memtable|
 :pattern ( (PagedBetree.Variables.memtable arg0@@709))
)))
(assert (forall ((d@@227 T@U) ($h@@206 T@U) ) (!  (=> (and (and (= (type d@@227) DatatypeTypeType) (= (type $h@@206) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@206) (and (PagedBetree.Variables.Variables_q d@@227) ($IsAlloc d@@227 Tclass.PagedBetree.Variables $h@@206)))) ($IsAlloc (PagedBetree.Variables.memtable d@@227) Tclass.MemtableMod.Memtable $h@@206))
 :qid |unknown.0:0|
 :skolemid |7428|
 :pattern ( ($IsAlloc (PagedBetree.Variables.memtable d@@227) Tclass.MemtableMod.Memtable $h@@206))
)))
(assert (forall ((arg0@@710 T@U) ) (! (= (type (PagedBetree.Variables.root arg0@@710)) DatatypeTypeType)
 :qid |funType:PagedBetree.Variables.root|
 :pattern ( (PagedBetree.Variables.root arg0@@710))
)))
(assert (forall ((d@@228 T@U) ($h@@207 T@U) ) (!  (=> (and (and (= (type d@@228) DatatypeTypeType) (= (type $h@@207) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@207) (and (PagedBetree.Variables.Variables_q d@@228) ($IsAlloc d@@228 Tclass.PagedBetree.Variables $h@@207)))) ($IsAlloc (PagedBetree.Variables.root d@@228) Tclass.PagedBetree.BetreeNode $h@@207))
 :qid |unknown.0:0|
 :skolemid |7429|
 :pattern ( ($IsAlloc (PagedBetree.Variables.root d@@228) Tclass.PagedBetree.BetreeNode $h@@207))
)))
(assert (forall ((|a#4#0#0@@16| T@U) (|a#4#1#0@@11| T@U) ) (!  (=> (and (= (type |a#4#0#0@@16|) DatatypeTypeType) (= (type |a#4#1#0@@11|) DatatypeTypeType)) (= (|#PagedBetree.Variables.Variables| (Lit |a#4#0#0@@16|) (Lit |a#4#1#0@@11|)) (Lit (|#PagedBetree.Variables.Variables| |a#4#0#0@@16| |a#4#1#0@@11|))))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7430|
 :pattern ( (|#PagedBetree.Variables.Variables| (Lit |a#4#0#0@@16|) (Lit |a#4#1#0@@11|)))
)))
(assert (forall ((|a#5#0#0@@19| T@U) (|a#5#1#0@@13| T@U) ) (!  (=> (and (= (type |a#5#0#0@@19|) DatatypeTypeType) (= (type |a#5#1#0@@13|) DatatypeTypeType)) (= (PagedBetree.Variables.memtable (|#PagedBetree.Variables.Variables| |a#5#0#0@@19| |a#5#1#0@@13|)) |a#5#0#0@@19|))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7431|
 :pattern ( (|#PagedBetree.Variables.Variables| |a#5#0#0@@19| |a#5#1#0@@13|))
)))
(assert (forall ((|a#6#0#0@@19| T@U) (|a#6#1#0@@13| T@U) ) (!  (=> (and (= (type |a#6#0#0@@19|) DatatypeTypeType) (= (type |a#6#1#0@@13|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@19|) (DtRank (|#PagedBetree.Variables.Variables| |a#6#0#0@@19| |a#6#1#0@@13|))))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7432|
 :pattern ( (|#PagedBetree.Variables.Variables| |a#6#0#0@@19| |a#6#1#0@@13|))
)))
(assert (forall ((|a#7#0#0@@18| T@U) (|a#7#1#0@@13| T@U) ) (!  (=> (and (= (type |a#7#0#0@@18|) DatatypeTypeType) (= (type |a#7#1#0@@13|) DatatypeTypeType)) (= (PagedBetree.Variables.root (|#PagedBetree.Variables.Variables| |a#7#0#0@@18| |a#7#1#0@@13|)) |a#7#1#0@@13|))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7433|
 :pattern ( (|#PagedBetree.Variables.Variables| |a#7#0#0@@18| |a#7#1#0@@13|))
)))
(assert (forall ((|a#8#0#0@@14| T@U) (|a#8#1#0@@11| T@U) ) (!  (=> (and (= (type |a#8#0#0@@14|) DatatypeTypeType) (= (type |a#8#1#0@@11|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@11|) (DtRank (|#PagedBetree.Variables.Variables| |a#8#0#0@@14| |a#8#1#0@@11|))))
 :qid |PagedBetreeidfy.245:5|
 :skolemid |7434|
 :pattern ( (|#PagedBetree.Variables.Variables| |a#8#0#0@@14| |a#8#1#0@@11|))
)))
(assert (forall ((d@@229 T@U) ) (!  (=> (and (= (type d@@229) DatatypeTypeType) (|$IsA#PagedBetree.Variables| d@@229)) (PagedBetree.Variables.Variables_q d@@229))
 :qid |unknown.0:0|
 :skolemid |7435|
 :pattern ( (|$IsA#PagedBetree.Variables| d@@229))
)))
(assert (forall ((d@@230 T@U) ) (!  (=> (and (= (type d@@230) DatatypeTypeType) ($Is d@@230 Tclass.PagedBetree.Variables)) (PagedBetree.Variables.Variables_q d@@230))
 :qid |unknown.0:0|
 :skolemid |7436|
 :pattern ( (PagedBetree.Variables.Variables_q d@@230) ($Is d@@230 Tclass.PagedBetree.Variables))
)))
(assert (forall ((a@@191 T@U) (b@@140 T@U) ) (!  (=> (and (and (= (type a@@191) DatatypeTypeType) (= (type b@@140) DatatypeTypeType)) true) (= (|PagedBetree.Variables#Equal| a@@191 b@@140)  (and (|MemtableMod.Memtable#Equal| (PagedBetree.Variables.memtable a@@191) (PagedBetree.Variables.memtable b@@140)) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Variables.root a@@191) (PagedBetree.Variables.root b@@140)))))
 :qid |unknown.0:0|
 :skolemid |7437|
 :pattern ( (|PagedBetree.Variables#Equal| a@@191 b@@140))
)))
(assert (forall ((a@@192 T@U) (b@@141 T@U) ) (!  (=> (and (= (type a@@192) DatatypeTypeType) (= (type b@@141) DatatypeTypeType)) (= (|PagedBetree.Variables#Equal| a@@192 b@@141) (= a@@192 b@@141)))
 :qid |unknown.0:0|
 :skolemid |7438|
 :pattern ( (|PagedBetree.Variables#Equal| a@@192 b@@141))
)))
(assert  (=> true (forall ((this@@408 T@U) ) (!  (=> (and (= (type this@@408) DatatypeTypeType) (or (|PagedBetree.Variables.WF#canCall| this@@408) ($Is this@@408 Tclass.PagedBetree.Variables))) true)
 :qid |PagedBetreeidfy.248:15|
 :skolemid |7439|
 :pattern ( (PagedBetree.Variables.WF this@@408))
))))
(assert (forall ((this@@409 T@U) ) (!  (=> (and (= (type this@@409) DatatypeTypeType) ($Is this@@409 Tclass.PagedBetree.Variables)) (= (|PagedBetree.Variables.WF#requires| this@@409) true))
 :qid |PagedBetreeidfy.248:15|
 :skolemid |7440|
 :pattern ( (|PagedBetree.Variables.WF#requires| this@@409))
)))
(assert  (=> true (forall ((this@@410 T@U) ) (!  (=> (and (= (type this@@410) DatatypeTypeType) (or (|PagedBetree.Variables.WF#canCall| this@@410) ($Is this@@410 Tclass.PagedBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PagedBetree.Variables.Variables_q this@@410) (|PagedBetree.BetreeNode.WF#canCall| (PagedBetree.Variables.root this@@410)))) (= (PagedBetree.Variables.WF this@@410)  (and true (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Variables.root this@@410))))))
 :qid |PagedBetreeidfy.248:15|
 :skolemid |7441|
 :pattern ( (PagedBetree.Variables.WF this@@410))
))))
(assert  (=> true (forall ((this@@411 T@U) ) (!  (=> (and (= (type this@@411) DatatypeTypeType) (or (|PagedBetree.Variables.WF#canCall| (Lit this@@411)) ($Is this@@411 Tclass.PagedBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PagedBetree.Variables.Variables_q (Lit this@@411)) (|PagedBetree.BetreeNode.WF#canCall| (Lit (PagedBetree.Variables.root (Lit this@@411)))))) (= (PagedBetree.Variables.WF (Lit this@@411)) (U_2_bool (Lit (bool_2_U  (and true (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.Variables.root (Lit this@@411)))))))))))
 :qid |PagedBetreeidfy.248:15|
 :weight 3
 :skolemid |7442|
 :pattern ( (PagedBetree.Variables.WF (Lit this@@411)))
))))
(assert (forall ((|a#0#0#0@@17| T@U) (|a#0#1#0@@12| T@U) (|a#0#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#0#0#0@@17|) DatatypeTypeType) (= (type |a#0#1#0@@12|) (SeqType BoxType))) (= (type |a#0#2#0@@3|) (SeqType BoxType))) (= (DatatypeCtorId (|#PagedBetree.Path.Path| |a#0#0#0@@17| |a#0#1#0@@12| |a#0#2#0@@3|)) |##PagedBetree.Path.Path|))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7443|
 :pattern ( (|#PagedBetree.Path.Path| |a#0#0#0@@17| |a#0#1#0@@12| |a#0#2#0@@3|))
)))
(assert (forall ((d@@231 T@U) ) (!  (=> (= (type d@@231) DatatypeTypeType) (= (PagedBetree.Path.Path_q d@@231) (= (DatatypeCtorId d@@231) |##PagedBetree.Path.Path|)))
 :qid |unknown.0:0|
 :skolemid |7444|
 :pattern ( (PagedBetree.Path.Path_q d@@231))
)))
(assert (forall ((d@@232 T@U) ) (!  (=> (and (= (type d@@232) DatatypeTypeType) (PagedBetree.Path.Path_q d@@232)) (exists ((|a#1#0#0@@17| T@U) (|a#1#1#0@@12| T@U) (|a#1#2#0@@3| T@U) ) (!  (and (and (and (= (type |a#1#0#0@@17|) DatatypeTypeType) (= (type |a#1#1#0@@12|) (SeqType BoxType))) (= (type |a#1#2#0@@3|) (SeqType BoxType))) (= d@@232 (|#PagedBetree.Path.Path| |a#1#0#0@@17| |a#1#1#0@@12| |a#1#2#0@@3|)))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7445|
 :no-pattern (type |a#1#0#0@@17|)
 :no-pattern (type |a#1#1#0@@12|)
 :no-pattern (type |a#1#2#0@@3|)
 :no-pattern (U_2_int |a#1#0#0@@17|)
 :no-pattern (U_2_bool |a#1#0#0@@17|)
 :no-pattern (U_2_int |a#1#1#0@@12|)
 :no-pattern (U_2_bool |a#1#1#0@@12|)
 :no-pattern (U_2_int |a#1#2#0@@3|)
 :no-pattern (U_2_bool |a#1#2#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |7446|
 :pattern ( (PagedBetree.Path.Path_q d@@232))
)))
(assert (forall ((|a#2#0#0@@17| T@U) (|a#2#1#0@@12| T@U) (|a#2#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#2#0#0@@17|) DatatypeTypeType) (= (type |a#2#1#0@@12|) (SeqType BoxType))) (= (type |a#2#2#0@@3|) (SeqType BoxType))) (= ($Is (|#PagedBetree.Path.Path| |a#2#0#0@@17| |a#2#1#0@@12| |a#2#2#0@@3|) Tclass.PagedBetree.Path)  (and (and ($Is |a#2#0#0@@17| Tclass.PagedBetree.BetreeNode) ($Is |a#2#1#0@@12| Tclass.KeyType.Key)) ($Is |a#2#2#0@@3| (TSeq (TISet Tclass.KeyType.Key))))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7447|
 :pattern ( ($Is (|#PagedBetree.Path.Path| |a#2#0#0@@17| |a#2#1#0@@12| |a#2#2#0@@3|) Tclass.PagedBetree.Path))
)))
(assert (forall ((|a#3#0#0@@17| T@U) (|a#3#1#0@@12| T@U) (|a#3#2#0@@3| T@U) ($h@@208 T@U) ) (!  (=> (and (and (and (and (= (type |a#3#0#0@@17|) DatatypeTypeType) (= (type |a#3#1#0@@12|) (SeqType BoxType))) (= (type |a#3#2#0@@3|) (SeqType BoxType))) (= (type $h@@208) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@208)) (= ($IsAlloc (|#PagedBetree.Path.Path| |a#3#0#0@@17| |a#3#1#0@@12| |a#3#2#0@@3|) Tclass.PagedBetree.Path $h@@208)  (and (and ($IsAlloc |a#3#0#0@@17| Tclass.PagedBetree.BetreeNode $h@@208) ($IsAlloc |a#3#1#0@@12| Tclass.KeyType.Key $h@@208)) ($IsAlloc |a#3#2#0@@3| (TSeq (TISet Tclass.KeyType.Key)) $h@@208))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7448|
 :pattern ( ($IsAlloc (|#PagedBetree.Path.Path| |a#3#0#0@@17| |a#3#1#0@@12| |a#3#2#0@@3|) Tclass.PagedBetree.Path $h@@208))
)))
(assert (forall ((arg0@@711 T@U) ) (! (= (type (PagedBetree.Path.node arg0@@711)) DatatypeTypeType)
 :qid |funType:PagedBetree.Path.node|
 :pattern ( (PagedBetree.Path.node arg0@@711))
)))
(assert (forall ((d@@233 T@U) ($h@@209 T@U) ) (!  (=> (and (and (= (type d@@233) DatatypeTypeType) (= (type $h@@209) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@209) (and (PagedBetree.Path.Path_q d@@233) ($IsAlloc d@@233 Tclass.PagedBetree.Path $h@@209)))) ($IsAlloc (PagedBetree.Path.node d@@233) Tclass.PagedBetree.BetreeNode $h@@209))
 :qid |unknown.0:0|
 :skolemid |7449|
 :pattern ( ($IsAlloc (PagedBetree.Path.node d@@233) Tclass.PagedBetree.BetreeNode $h@@209))
)))
(assert (forall ((arg0@@712 T@U) ) (! (= (type (PagedBetree.Path.key arg0@@712)) (SeqType BoxType))
 :qid |funType:PagedBetree.Path.key|
 :pattern ( (PagedBetree.Path.key arg0@@712))
)))
(assert (forall ((d@@234 T@U) ($h@@210 T@U) ) (!  (=> (and (and (= (type d@@234) DatatypeTypeType) (= (type $h@@210) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@210) (and (PagedBetree.Path.Path_q d@@234) ($IsAlloc d@@234 Tclass.PagedBetree.Path $h@@210)))) ($IsAlloc (PagedBetree.Path.key d@@234) Tclass.KeyType.Key $h@@210))
 :qid |unknown.0:0|
 :skolemid |7450|
 :pattern ( ($IsAlloc (PagedBetree.Path.key d@@234) Tclass.KeyType.Key $h@@210))
)))
(assert (forall ((arg0@@713 T@U) ) (! (= (type (PagedBetree.Path.routing arg0@@713)) (SeqType BoxType))
 :qid |funType:PagedBetree.Path.routing|
 :pattern ( (PagedBetree.Path.routing arg0@@713))
)))
(assert (forall ((d@@235 T@U) ($h@@211 T@U) ) (!  (=> (and (and (= (type d@@235) DatatypeTypeType) (= (type $h@@211) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@211) (and (PagedBetree.Path.Path_q d@@235) ($IsAlloc d@@235 Tclass.PagedBetree.Path $h@@211)))) ($IsAlloc (PagedBetree.Path.routing d@@235) (TSeq (TISet Tclass.KeyType.Key)) $h@@211))
 :qid |unknown.0:0|
 :skolemid |7451|
 :pattern ( ($IsAlloc (PagedBetree.Path.routing d@@235) (TSeq (TISet Tclass.KeyType.Key)) $h@@211))
)))
(assert (forall ((|a#4#0#0@@17| T@U) (|a#4#1#0@@12| T@U) (|a#4#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#4#0#0@@17|) DatatypeTypeType) (= (type |a#4#1#0@@12|) (SeqType BoxType))) (= (type |a#4#2#0@@3|) (SeqType BoxType))) (= (|#PagedBetree.Path.Path| (Lit |a#4#0#0@@17|) (Lit |a#4#1#0@@12|) (Lit |a#4#2#0@@3|)) (Lit (|#PagedBetree.Path.Path| |a#4#0#0@@17| |a#4#1#0@@12| |a#4#2#0@@3|))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7452|
 :pattern ( (|#PagedBetree.Path.Path| (Lit |a#4#0#0@@17|) (Lit |a#4#1#0@@12|) (Lit |a#4#2#0@@3|)))
)))
(assert (forall ((|a#5#0#0@@20| T@U) (|a#5#1#0@@14| T@U) (|a#5#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#5#0#0@@20|) DatatypeTypeType) (= (type |a#5#1#0@@14|) (SeqType BoxType))) (= (type |a#5#2#0@@3|) (SeqType BoxType))) (= (PagedBetree.Path.node (|#PagedBetree.Path.Path| |a#5#0#0@@20| |a#5#1#0@@14| |a#5#2#0@@3|)) |a#5#0#0@@20|))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7453|
 :pattern ( (|#PagedBetree.Path.Path| |a#5#0#0@@20| |a#5#1#0@@14| |a#5#2#0@@3|))
)))
(assert (forall ((|a#6#0#0@@20| T@U) (|a#6#1#0@@14| T@U) (|a#6#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@20|) DatatypeTypeType) (= (type |a#6#1#0@@14|) (SeqType BoxType))) (= (type |a#6#2#0@@3|) (SeqType BoxType))) (< (DtRank |a#6#0#0@@20|) (DtRank (|#PagedBetree.Path.Path| |a#6#0#0@@20| |a#6#1#0@@14| |a#6#2#0@@3|))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7454|
 :pattern ( (|#PagedBetree.Path.Path| |a#6#0#0@@20| |a#6#1#0@@14| |a#6#2#0@@3|))
)))
(assert (forall ((|a#7#0#0@@19| T@U) (|a#7#1#0@@14| T@U) (|a#7#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@19|) DatatypeTypeType) (= (type |a#7#1#0@@14|) (SeqType BoxType))) (= (type |a#7#2#0@@3|) (SeqType BoxType))) (= (PagedBetree.Path.key (|#PagedBetree.Path.Path| |a#7#0#0@@19| |a#7#1#0@@14| |a#7#2#0@@3|)) |a#7#1#0@@14|))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7455|
 :pattern ( (|#PagedBetree.Path.Path| |a#7#0#0@@19| |a#7#1#0@@14| |a#7#2#0@@3|))
)))
(assert (forall ((|a#8#0#0@@15| T@U) (|a#8#1#0@@12| T@U) (|a#8#2#0@@3| T@U) ) (!  (=> (and (and (= (type |a#8#0#0@@15|) DatatypeTypeType) (= (type |a#8#1#0@@12|) (SeqType BoxType))) (= (type |a#8#2#0@@3|) (SeqType BoxType))) (= (PagedBetree.Path.routing (|#PagedBetree.Path.Path| |a#8#0#0@@15| |a#8#1#0@@12| |a#8#2#0@@3|)) |a#8#2#0@@3|))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7456|
 :pattern ( (|#PagedBetree.Path.Path| |a#8#0#0@@15| |a#8#1#0@@12| |a#8#2#0@@3|))
)))
(assert (forall ((|a#9#0#0@@8| T@U) (|a#9#1#0@@5| T@U) (|a#9#2#0@@2| T@U) (i@@31 Int) ) (!  (=> (and (and (and (= (type |a#9#0#0@@8|) DatatypeTypeType) (= (type |a#9#1#0@@5|) (SeqType BoxType))) (= (type |a#9#2#0@@2|) (SeqType BoxType))) (and (<= 0 i@@31) (< i@@31 (|Seq#Length| |a#9#2#0@@2|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#9#2#0@@2| i@@31))) (DtRank (|#PagedBetree.Path.Path| |a#9#0#0@@8| |a#9#1#0@@5| |a#9#2#0@@2|))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7457|
 :pattern ( (|Seq#Index| |a#9#2#0@@2| i@@31) (|#PagedBetree.Path.Path| |a#9#0#0@@8| |a#9#1#0@@5| |a#9#2#0@@2|))
)))
(assert (forall ((|a#10#0#0@@8| T@U) (|a#10#1#0@@5| T@U) (|a#10#2#0@@2| T@U) ) (!  (=> (and (and (= (type |a#10#0#0@@8|) DatatypeTypeType) (= (type |a#10#1#0@@5|) (SeqType BoxType))) (= (type |a#10#2#0@@2|) (SeqType BoxType))) (< (|Seq#Rank| |a#10#2#0@@2|) (DtRank (|#PagedBetree.Path.Path| |a#10#0#0@@8| |a#10#1#0@@5| |a#10#2#0@@2|))))
 :qid |PagedBetreeidfy.300:24|
 :skolemid |7458|
 :pattern ( (|#PagedBetree.Path.Path| |a#10#0#0@@8| |a#10#1#0@@5| |a#10#2#0@@2|))
)))
(assert (forall ((d@@236 T@U) ) (!  (=> (and (= (type d@@236) DatatypeTypeType) (|$IsA#PagedBetree.Path| d@@236)) (PagedBetree.Path.Path_q d@@236))
 :qid |unknown.0:0|
 :skolemid |7459|
 :pattern ( (|$IsA#PagedBetree.Path| d@@236))
)))
(assert (forall ((d@@237 T@U) ) (!  (=> (and (= (type d@@237) DatatypeTypeType) ($Is d@@237 Tclass.PagedBetree.Path)) (PagedBetree.Path.Path_q d@@237))
 :qid |unknown.0:0|
 :skolemid |7460|
 :pattern ( (PagedBetree.Path.Path_q d@@237) ($Is d@@237 Tclass.PagedBetree.Path))
)))
(assert (forall ((a@@193 T@U) (b@@142 T@U) ) (!  (=> (and (and (= (type a@@193) DatatypeTypeType) (= (type b@@142) DatatypeTypeType)) true) (= (|PagedBetree.Path#Equal| a@@193 b@@142)  (and (and (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node a@@193) (PagedBetree.Path.node b@@142)) (|Seq#Equal| (PagedBetree.Path.key a@@193) (PagedBetree.Path.key b@@142))) (|Seq#Equal| (PagedBetree.Path.routing a@@193) (PagedBetree.Path.routing b@@142)))))
 :qid |unknown.0:0|
 :skolemid |7461|
 :pattern ( (|PagedBetree.Path#Equal| a@@193 b@@142))
)))
(assert (forall ((a@@194 T@U) (b@@143 T@U) ) (!  (=> (and (= (type a@@194) DatatypeTypeType) (= (type b@@143) DatatypeTypeType)) (= (|PagedBetree.Path#Equal| a@@194 b@@143) (= a@@194 b@@143)))
 :qid |unknown.0:0|
 :skolemid |7462|
 :pattern ( (|PagedBetree.Path#Equal| a@@194 b@@143))
)))
(assert (forall ((arg0@@714 T@U) ) (! (= (type (PagedBetree.Path.Subpath arg0@@714)) DatatypeTypeType)
 :qid |funType:PagedBetree.Path.Subpath|
 :pattern ( (PagedBetree.Path.Subpath arg0@@714))
)))
(assert  (=> true (forall ((this@@412 T@U) ) (!  (=> (and (= (type this@@412) DatatypeTypeType) (or (|PagedBetree.Path.Subpath#canCall| this@@412) (and ($Is this@@412 Tclass.PagedBetree.Path) (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@412))) (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@412))) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@412)))))) ($Is (PagedBetree.Path.Subpath this@@412) Tclass.PagedBetree.Path))
 :qid |PagedBetreeidfy.302:14|
 :skolemid |7463|
 :pattern ( (PagedBetree.Path.Subpath this@@412))
))))
(assert (forall ((this@@413 T@U) ) (!  (=> (and (= (type this@@413) DatatypeTypeType) ($Is this@@413 Tclass.PagedBetree.Path)) (= (|PagedBetree.Path.Subpath#requires| this@@413)  (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@413))) (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@413))) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@413)))))
 :qid |PagedBetreeidfy.302:14|
 :skolemid |7464|
 :pattern ( (|PagedBetree.Path.Subpath#requires| this@@413))
)))
(assert  (=> true (forall ((this@@414 T@U) ) (!  (=> (and (= (type this@@414) DatatypeTypeType) (or (|PagedBetree.Path.Subpath#canCall| this@@414) (and ($Is this@@414 Tclass.PagedBetree.Path) (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@414))) (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@414))) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@414)))))) (and (and (and (and (and (PagedBetree.Path.Path_q this@@414) (PagedBetree.Path.Path_q this@@414)) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.Path.node this@@414) (PagedBetree.Path.key this@@414))) (PagedBetree.Path.Path_q this@@414)) (PagedBetree.Path.Path_q this@@414)) (= (PagedBetree.Path.Subpath this@@414) (|#PagedBetree.Path.Path| (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@414) (PagedBetree.Path.key this@@414)) (PagedBetree.Path.key this@@414) (|Seq#Drop| (PagedBetree.Path.routing this@@414) (LitInt 1))))))
 :qid |PagedBetreeidfy.302:14|
 :skolemid |7465|
 :pattern ( (PagedBetree.Path.Subpath this@@414))
))))
(assert  (=> true (forall ((this@@415 T@U) ) (!  (=> (and (= (type this@@415) DatatypeTypeType) (or (|PagedBetree.Path.Subpath#canCall| (Lit this@@415)) (and ($Is this@@415 Tclass.PagedBetree.Path) (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@415))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.Path.node (Lit this@@415)))))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit (PagedBetree.Path.node (Lit this@@415))))))))))) (and (and (and (and (and (PagedBetree.Path.Path_q (Lit this@@415)) (PagedBetree.Path.Path_q (Lit this@@415))) (|PagedBetree.BetreeNode.Child#canCall| (Lit (PagedBetree.Path.node (Lit this@@415))) (Lit (PagedBetree.Path.key (Lit this@@415))))) (PagedBetree.Path.Path_q (Lit this@@415))) (PagedBetree.Path.Path_q (Lit this@@415))) (= (PagedBetree.Path.Subpath (Lit this@@415)) (Lit (|#PagedBetree.Path.Path| (Lit (PagedBetree.BetreeNode.Child (Lit (PagedBetree.Path.node (Lit this@@415))) (Lit (PagedBetree.Path.key (Lit this@@415))))) (Lit (PagedBetree.Path.key (Lit this@@415))) (Lit (|Seq#Drop| (Lit (PagedBetree.Path.routing (Lit this@@415))) (LitInt 1))))))))
 :qid |PagedBetreeidfy.302:14|
 :weight 3
 :skolemid |7466|
 :pattern ( (PagedBetree.Path.Subpath (Lit this@@415)))
))))
(assert  (=> true (forall ((this@@416 T@U) ) (!  (=> (and (= (type this@@416) DatatypeTypeType) (or (|PagedBetree.Path.CommonChildren#canCall| this@@416) (and ($Is this@@416 Tclass.PagedBetree.Path) (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@416)) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@416))) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@416))))))) true)
 :qid |PagedBetreeidfy.311:15|
 :skolemid |7467|
 :pattern ( (PagedBetree.Path.CommonChildren this@@416))
))))
(assert (forall ((this@@417 T@U) ) (!  (=> (and (= (type this@@417) DatatypeTypeType) ($Is this@@417 Tclass.PagedBetree.Path)) (= (|PagedBetree.Path.CommonChildren#requires| this@@417)  (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@417)) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@417))) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@417))))))
 :qid |PagedBetreeidfy.311:15|
 :skolemid |7468|
 :pattern ( (|PagedBetree.Path.CommonChildren#requires| this@@417))
)))
(assert  (=> true (forall ((this@@418 T@U) ) (!  (=> (and (= (type this@@418) DatatypeTypeType) (or (|PagedBetree.Path.CommonChildren#canCall| this@@418) (and ($Is this@@418 Tclass.PagedBetree.Path) (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@418)) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@418))) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@418))))))) (and (forall ((|k#0@@83| T@U) ) (!  (=> (and (= (type |k#0@@83|) (SeqType BoxType)) ($Is |k#0@@83| Tclass.KeyType.Key)) (and (PagedBetree.Path.Path_q this@@418) (=> (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@418) (LitInt 0))) ($Box |k#0@@83|))) (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) |k#0@@83|)) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) (PagedBetree.Path.key this@@418)))) (and (and (PagedBetree.Path.Path_q this@@418) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.Path.node this@@418) |k#0@@83|)) (and (and (PagedBetree.Path.Path_q this@@418) (PagedBetree.Path.Path_q this@@418)) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.Path.node this@@418) (PagedBetree.Path.key this@@418))))))))
 :qid |PagedBetreeidfy.316:14|
 :skolemid |7470|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) |k#0@@83|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@418) 0)) ($Box |k#0@@83|)))
)) (= (PagedBetree.Path.CommonChildren this@@418) (forall ((|k#0@@84| T@U) ) (!  (=> (= (type |k#0@@84|) (SeqType BoxType)) (=> (and ($Is |k#0@@84| Tclass.KeyType.Key) (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@418) (LitInt 0))) ($Box |k#0@@84|)))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) |k#0@@84|) (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) (PagedBetree.Path.key this@@418)))))
 :qid |PagedBetreeidfy.316:14|
 :skolemid |7469|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@418) |k#0@@84|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@418) 0)) ($Box |k#0@@84|)))
)))))
 :qid |PagedBetreeidfy.311:15|
 :skolemid |7471|
 :pattern ( (PagedBetree.Path.CommonChildren this@@418))
))))
(assert  (=> true (forall ((this@@419 T@U) ) (!  (=> (and (= (type this@@419) DatatypeTypeType) (or (|PagedBetree.Path.CommonChildren#canCall| (Lit this@@419)) (and ($Is this@@419 Tclass.PagedBetree.Path) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.Path.node (Lit this@@419))))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit (PagedBetree.Path.node (Lit this@@419)))))))) (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@419))))))))) (and (forall ((|k#1@@21| T@U) ) (!  (=> (and (= (type |k#1@@21|) (SeqType BoxType)) ($Is |k#1@@21| Tclass.KeyType.Key)) (and (PagedBetree.Path.Path_q (Lit this@@419)) (=> (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@419))) (LitInt 0))) ($Box |k#1@@21|))) (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.BetreeNode.Child (Lit (PagedBetree.Path.node (Lit this@@419))) |k#1@@21|)) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.BetreeNode.Child (Lit (PagedBetree.Path.node (Lit this@@419))) (Lit (PagedBetree.Path.key (Lit this@@419))))))) (and (and (PagedBetree.Path.Path_q (Lit this@@419)) (|PagedBetree.BetreeNode.Child#canCall| (Lit (PagedBetree.Path.node (Lit this@@419))) |k#1@@21|)) (and (and (PagedBetree.Path.Path_q (Lit this@@419)) (PagedBetree.Path.Path_q (Lit this@@419))) (|PagedBetree.BetreeNode.Child#canCall| (Lit (PagedBetree.Path.node (Lit this@@419))) (Lit (PagedBetree.Path.key (Lit this@@419))))))))))
 :qid |PagedBetreeidfy.316:14|
 :skolemid |7473|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@419) |k#1@@21|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@419) 0)) ($Box |k#1@@21|)))
)) (= (PagedBetree.Path.CommonChildren (Lit this@@419)) (forall ((|k#1@@22| T@U) ) (!  (=> (= (type |k#1@@22|) (SeqType BoxType)) (=> (and ($Is |k#1@@22| Tclass.KeyType.Key) (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@419))) (LitInt 0))) ($Box |k#1@@22|)))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.BetreeNode.Child (Lit (PagedBetree.Path.node (Lit this@@419))) |k#1@@22|) (PagedBetree.BetreeNode.Child (Lit (PagedBetree.Path.node (Lit this@@419))) (Lit (PagedBetree.Path.key (Lit this@@419)))))))
 :qid |PagedBetreeidfy.316:14|
 :skolemid |7472|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@419) |k#1@@22|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@419) 0)) ($Box |k#1@@22|)))
)))))
 :qid |PagedBetreeidfy.311:15|
 :weight 3
 :skolemid |7474|
 :pattern ( (PagedBetree.Path.CommonChildren (Lit this@@419)))
))))
(assert (forall (($ly@@757 T@U) (this@@420 T@U) ) (!  (=> (and (= (type $ly@@757) LayerTypeType) (= (type this@@420) DatatypeTypeType)) (= (PagedBetree.Path.Valid ($LS $ly@@757) this@@420) (PagedBetree.Path.Valid $ly@@757 this@@420)))
 :qid |PagedBetreeidfy.319:15|
 :skolemid |7475|
 :pattern ( (PagedBetree.Path.Valid ($LS $ly@@757) this@@420))
)))
(assert (forall (($ly@@758 T@U) (this@@421 T@U) ) (!  (=> (and (= (type $ly@@758) LayerTypeType) (= (type this@@421) DatatypeTypeType)) (= (PagedBetree.Path.Valid $ly@@758 this@@421) (PagedBetree.Path.Valid $LZ this@@421)))
 :qid |PagedBetreeidfy.319:15|
 :skolemid |7476|
 :pattern ( (PagedBetree.Path.Valid (AsFuelBottom $ly@@758) this@@421))
)))
(assert  (=> true (forall (($ly@@759 T@U) (this@@422 T@U) ) (!  (=> (and (and (= (type $ly@@759) LayerTypeType) (= (type this@@422) DatatypeTypeType)) (or (|PagedBetree.Path.Valid#canCall| this@@422) ($Is this@@422 Tclass.PagedBetree.Path))) true)
 :qid |PagedBetreeidfy.319:15|
 :skolemid |7477|
 :pattern ( (PagedBetree.Path.Valid $ly@@759 this@@422))
))))
(assert (forall (($ly@@760 T@U) (this@@423 T@U) ) (!  (=> (and (and (= (type $ly@@760) LayerTypeType) (= (type this@@423) DatatypeTypeType)) ($Is this@@423 Tclass.PagedBetree.Path)) (= (|PagedBetree.Path.Valid#requires| $ly@@760 this@@423) true))
 :qid |PagedBetreeidfy.319:15|
 :skolemid |7478|
 :pattern ( (|PagedBetree.Path.Valid#requires| $ly@@760 this@@423))
)))
(assert  (=> true (forall (($ly@@761 T@U) (this@@424 T@U) ) (!  (=> (and (and (= (type $ly@@761) LayerTypeType) (= (type this@@424) DatatypeTypeType)) (or (|PagedBetree.Path.Valid#canCall| this@@424) ($Is this@@424 Tclass.PagedBetree.Path))) (and (and (and (PagedBetree.Path.Path_q this@@424) (|PagedBetree.BetreeNode.WF#canCall| (PagedBetree.Path.node this@@424))) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@424)) (and (PagedBetree.Path.Path_q this@@424) (=> (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@424)) (and (PagedBetree.Path.Path_q this@@424) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@424))) (and (and (|PagedBetree.Path.Subpath#canCall| this@@424) (|PagedBetree.Path.Valid#canCall| (PagedBetree.Path.Subpath this@@424))) (=> (PagedBetree.Path.Valid $ly@@761 (PagedBetree.Path.Subpath this@@424)) (|PagedBetree.Path.CommonChildren#canCall| this@@424))))))))) (= (PagedBetree.Path.Valid ($LS $ly@@761) this@@424)  (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.node this@@424)) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.node this@@424))) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@424))) (and (PagedBetree.Path.Valid $ly@@761 (PagedBetree.Path.Subpath this@@424)) (PagedBetree.Path.CommonChildren this@@424)))))))
 :qid |PagedBetreeidfy.319:15|
 :skolemid |7479|
 :pattern ( (PagedBetree.Path.Valid ($LS $ly@@761) this@@424))
))))
(assert  (=> true (forall (($ly@@762 T@U) (this@@425 T@U) ) (!  (=> (and (and (= (type $ly@@762) LayerTypeType) (= (type this@@425) DatatypeTypeType)) (or (|PagedBetree.Path.Valid#canCall| (Lit this@@425)) ($Is this@@425 Tclass.PagedBetree.Path))) (and (and (and (PagedBetree.Path.Path_q (Lit this@@425)) (|PagedBetree.BetreeNode.WF#canCall| (Lit (PagedBetree.Path.node (Lit this@@425))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.Path.node (Lit this@@425))))))) (and (PagedBetree.Path.Path_q (Lit this@@425)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit (PagedBetree.Path.node (Lit this@@425))))))) (and (PagedBetree.Path.Path_q (Lit this@@425)) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@425))))) (and (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@425)) (|PagedBetree.Path.Valid#canCall| (Lit (PagedBetree.Path.Subpath (Lit this@@425))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $ly@@762) (Lit (PagedBetree.Path.Subpath (Lit this@@425))))))) (|PagedBetree.Path.CommonChildren#canCall| (Lit this@@425)))))))))) (= (PagedBetree.Path.Valid ($LS $ly@@762) (Lit this@@425))  (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit (PagedBetree.Path.node (Lit this@@425)))) (PagedBetree.BetreeNode.BetreeNode_q (Lit (PagedBetree.Path.node (Lit this@@425))))) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@425))))) (and (PagedBetree.Path.Valid ($LS $ly@@762) (Lit (PagedBetree.Path.Subpath (Lit this@@425)))) (PagedBetree.Path.CommonChildren (Lit this@@425))))))))
 :qid |PagedBetreeidfy.319:15|
 :weight 3
 :skolemid |7480|
 :pattern ( (PagedBetree.Path.Valid ($LS $ly@@762) (Lit this@@425)))
))))
(assert (forall ((arg0@@715 T@U) (arg1@@374 T@U) ) (! (= (type (PagedBetree.Path.Target arg0@@715 arg1@@374)) DatatypeTypeType)
 :qid |funType:PagedBetree.Path.Target|
 :pattern ( (PagedBetree.Path.Target arg0@@715 arg1@@374))
)))
(assert (forall (($ly@@763 T@U) (this@@426 T@U) ) (!  (=> (and (= (type $ly@@763) LayerTypeType) (= (type this@@426) DatatypeTypeType)) (= (PagedBetree.Path.Target ($LS $ly@@763) this@@426) (PagedBetree.Path.Target $ly@@763 this@@426)))
 :qid |PagedBetreeidfy.330:14|
 :skolemid |7481|
 :pattern ( (PagedBetree.Path.Target ($LS $ly@@763) this@@426))
)))
(assert (forall (($ly@@764 T@U) (this@@427 T@U) ) (!  (=> (and (= (type $ly@@764) LayerTypeType) (= (type this@@427) DatatypeTypeType)) (= (PagedBetree.Path.Target $ly@@764 this@@427) (PagedBetree.Path.Target $LZ this@@427)))
 :qid |PagedBetreeidfy.330:14|
 :skolemid |7482|
 :pattern ( (PagedBetree.Path.Target (AsFuelBottom $ly@@764) this@@427))
)))
(assert  (=> true (forall (($ly@@765 T@U) (this@@428 T@U) ) (!  (=> (and (and (= (type $ly@@765) LayerTypeType) (= (type this@@428) DatatypeTypeType)) (or (|PagedBetree.Path.Target#canCall| this@@428) (and ($Is this@@428 Tclass.PagedBetree.Path) (PagedBetree.Path.Valid ($LS $LZ) this@@428)))) (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (PagedBetree.Path.Target $ly@@765 this@@428)) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.Target $ly@@765 this@@428))) ($Is (PagedBetree.Path.Target $ly@@765 this@@428) Tclass.PagedBetree.BetreeNode)))
 :qid |PagedBetreeidfy.330:14|
 :skolemid |7483|
 :pattern ( (PagedBetree.Path.Target $ly@@765 this@@428))
))))
(assert (forall (($ly@@766 T@U) (this@@429 T@U) ) (!  (=> (and (and (= (type $ly@@766) LayerTypeType) (= (type this@@429) DatatypeTypeType)) ($Is this@@429 Tclass.PagedBetree.Path)) (= (|PagedBetree.Path.Target#requires| $ly@@766 this@@429) (PagedBetree.Path.Valid ($LS $LZ) this@@429)))
 :qid |PagedBetreeidfy.330:14|
 :skolemid |7484|
 :pattern ( (|PagedBetree.Path.Target#requires| $ly@@766 this@@429))
)))
(assert  (=> true (forall (($ly@@767 T@U) (this@@430 T@U) ) (!  (=> (and (and (= (type $ly@@767) LayerTypeType) (= (type this@@430) DatatypeTypeType)) (or (|PagedBetree.Path.Target#canCall| this@@430) (and ($Is this@@430 Tclass.PagedBetree.Path) (PagedBetree.Path.Valid ($LS $LZ) this@@430)))) (and (and (and (PagedBetree.Path.Path_q this@@430) (=> (= (LitInt 0) (|Seq#Length| (PagedBetree.Path.routing this@@430))) (PagedBetree.Path.Path_q this@@430))) (=> (not (= (LitInt 0) (|Seq#Length| (PagedBetree.Path.routing this@@430)))) (and (|PagedBetree.Path.Subpath#canCall| this@@430) (|PagedBetree.Path.Target#canCall| (PagedBetree.Path.Subpath this@@430))))) (= (PagedBetree.Path.Target ($LS $ly@@767) this@@430) (ite (= (LitInt 0) (|Seq#Length| (PagedBetree.Path.routing this@@430))) (PagedBetree.Path.node this@@430) (PagedBetree.Path.Target $ly@@767 (PagedBetree.Path.Subpath this@@430))))))
 :qid |PagedBetreeidfy.330:14|
 :skolemid |7485|
 :pattern ( (PagedBetree.Path.Target ($LS $ly@@767) this@@430))
))))
(assert  (=> true (forall (($ly@@768 T@U) (this@@431 T@U) ) (!  (=> (and (and (= (type $ly@@768) LayerTypeType) (= (type this@@431) DatatypeTypeType)) (or (|PagedBetree.Path.Target#canCall| (Lit this@@431)) (and ($Is this@@431 Tclass.PagedBetree.Path) (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit this@@431)))))))) (and (and (and (PagedBetree.Path.Path_q (Lit this@@431)) (=> (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@431))))) (PagedBetree.Path.Path_q (Lit this@@431)))) (=> (not (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@431)))))) (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@431)) (|PagedBetree.Path.Target#canCall| (Lit (PagedBetree.Path.Subpath (Lit this@@431))))))) (= (PagedBetree.Path.Target ($LS $ly@@768) (Lit this@@431)) (ite (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@431))))) (PagedBetree.Path.node (Lit this@@431)) (PagedBetree.Path.Target ($LS $ly@@768) (Lit (PagedBetree.Path.Subpath (Lit this@@431))))))))
 :qid |PagedBetreeidfy.330:14|
 :weight 3
 :skolemid |7486|
 :pattern ( (PagedBetree.Path.Target ($LS $ly@@768) (Lit this@@431)))
))))
(assert (forall ((arg0@@716 T@U) (arg1@@375 T@U) (arg2@@182 T@U) ) (! (= (type (PagedBetree.Path.ReplacedChildren arg0@@716 arg1@@375 arg2@@182)) DatatypeTypeType)
 :qid |funType:PagedBetree.Path.ReplacedChildren|
 :pattern ( (PagedBetree.Path.ReplacedChildren arg0@@716 arg1@@375 arg2@@182))
)))
(assert (forall (($ly@@769 T@U) (this@@432 T@U) (|replacement#0@@17| T@U) ) (!  (=> (and (and (= (type $ly@@769) LayerTypeType) (= (type this@@432) DatatypeTypeType)) (= (type |replacement#0@@17|) DatatypeTypeType)) (= (PagedBetree.Path.ReplacedChildren ($LS $ly@@769) this@@432 |replacement#0@@17|) (PagedBetree.Path.ReplacedChildren $ly@@769 this@@432 |replacement#0@@17|)))
 :qid |PagedBetreeidfy.342:24|
 :skolemid |7487|
 :pattern ( (PagedBetree.Path.ReplacedChildren ($LS $ly@@769) this@@432 |replacement#0@@17|))
)))
(assert (forall (($ly@@770 T@U) (this@@433 T@U) (|replacement#0@@18| T@U) ) (!  (=> (and (and (= (type $ly@@770) LayerTypeType) (= (type this@@433) DatatypeTypeType)) (= (type |replacement#0@@18|) DatatypeTypeType)) (= (PagedBetree.Path.ReplacedChildren $ly@@770 this@@433 |replacement#0@@18|) (PagedBetree.Path.ReplacedChildren $LZ this@@433 |replacement#0@@18|)))
 :qid |PagedBetreeidfy.342:24|
 :skolemid |7488|
 :pattern ( (PagedBetree.Path.ReplacedChildren (AsFuelBottom $ly@@770) this@@433 |replacement#0@@18|))
)))
(assert  (=> true (forall (($ly@@771 T@U) (this@@434 T@U) (|replacement#0@@19| T@U) ) (!  (=> (and (and (and (= (type $ly@@771) LayerTypeType) (= (type this@@434) DatatypeTypeType)) (= (type |replacement#0@@19|) DatatypeTypeType)) (or (|PagedBetree.Path.ReplacedChildren#canCall| this@@434 |replacement#0@@19|) (and (and ($Is this@@434 Tclass.PagedBetree.Path) ($Is |replacement#0@@19| Tclass.PagedBetree.BetreeNode)) (and (and (PagedBetree.Path.Valid ($LS $LZ) this@@434) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@19|)) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@434))))))) (and (PagedBetree.ChildMap.WF ($LS $LZ) (PagedBetree.Path.ReplacedChildren $ly@@771 this@@434 |replacement#0@@19|)) ($Is (PagedBetree.Path.ReplacedChildren $ly@@771 this@@434 |replacement#0@@19|) Tclass.PagedBetree.ChildMap)))
 :qid |PagedBetreeidfy.342:24|
 :skolemid |7489|
 :pattern ( (PagedBetree.Path.ReplacedChildren $ly@@771 this@@434 |replacement#0@@19|))
))))
(assert (forall (($ly@@772 T@U) (this@@435 T@U) (|replacement#0@@20| T@U) ) (!  (=> (and (and (and (= (type $ly@@772) LayerTypeType) (= (type this@@435) DatatypeTypeType)) (= (type |replacement#0@@20|) DatatypeTypeType)) (and ($Is this@@435 Tclass.PagedBetree.Path) ($Is |replacement#0@@20| Tclass.PagedBetree.BetreeNode))) (= (|PagedBetree.Path.ReplacedChildren#requires| $ly@@772 this@@435 |replacement#0@@20|)  (and (and (PagedBetree.Path.Valid ($LS $LZ) this@@435) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@20|)) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@435))))))
 :qid |PagedBetreeidfy.342:24|
 :skolemid |7490|
 :pattern ( (|PagedBetree.Path.ReplacedChildren#requires| $ly@@772 this@@435 |replacement#0@@20|))
)))
(assert  (and (forall ((arg0@@717 T@U) (arg1@@376 T@U) (arg2@@183 T@U) ) (! (= (type (PagedBetree.Path.Substitute arg0@@717 arg1@@376 arg2@@183)) DatatypeTypeType)
 :qid |funType:PagedBetree.Path.Substitute|
 :pattern ( (PagedBetree.Path.Substitute arg0@@717 arg1@@376 arg2@@183))
)) (forall ((arg0@@718 T@U) (arg1@@377 T@U) (arg2@@184 T@U) ) (! (= (type (|lambda#388| arg0@@718 arg1@@377 arg2@@184)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#388|
 :pattern ( (|lambda#388| arg0@@718 arg1@@377 arg2@@184))
))))
(assert  (=> true (forall (($ly@@773 T@U) (this@@436 T@U) (|replacement#0@@21| T@U) ) (!  (=> (and (and (and (= (type $ly@@773) LayerTypeType) (= (type this@@436) DatatypeTypeType)) (= (type |replacement#0@@21|) DatatypeTypeType)) (or (|PagedBetree.Path.ReplacedChildren#canCall| this@@436 |replacement#0@@21|) (and (and ($Is this@@436 Tclass.PagedBetree.Path) ($Is |replacement#0@@21| Tclass.PagedBetree.BetreeNode)) (and (and (PagedBetree.Path.Valid ($LS $LZ) this@@436) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@21|)) (INTERNAL_lt_boogie 0 (|Seq#Length| (PagedBetree.Path.routing this@@436))))))) (and (and (and (|PagedBetree.Path.Subpath#canCall| this@@436) (|PagedBetree.Path.Substitute#canCall| (PagedBetree.Path.Subpath this@@436) |replacement#0@@21|)) (forall ((|k#0@@85| T@U) ) (!  (=> (and (= (type |k#0@@85|) (SeqType BoxType)) ($Is |k#0@@85| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@85|) (=> (Buffers.__default.AnyKey |k#0@@85|) (and (PagedBetree.Path.Path_q this@@436) (=> (not (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@436) (LitInt 0))) ($Box |k#0@@85|)))) (and (PagedBetree.Path.Path_q this@@436) (|PagedBetree.BetreeNode.Child#canCall| (PagedBetree.Path.node this@@436) |k#0@@85|)))))))
 :qid |PagedBetreeidfy.351:21|
 :skolemid |7491|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@436) |k#0@@85|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@436) 0)) ($Box |k#0@@85|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@85|))
))) (= (PagedBetree.Path.ReplacedChildren ($LS $ly@@773) this@@436 |replacement#0@@21|) (let ((|replacedChild#0| (PagedBetree.Path.Substitute $ly@@773 (PagedBetree.Path.Subpath this@@436) |replacement#0@@21|)))
(|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#388| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@436) (LitInt 0))) |replacedChild#0| (PagedBetree.Path.node this@@436)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))))
 :qid |PagedBetreeidfy.342:24|
 :skolemid |7492|
 :pattern ( (PagedBetree.Path.ReplacedChildren ($LS $ly@@773) this@@436 |replacement#0@@21|))
))))
(assert  (=> true (forall (($ly@@774 T@U) (this@@437 T@U) (|replacement#0@@22| T@U) ) (!  (=> (and (and (and (= (type $ly@@774) LayerTypeType) (= (type this@@437) DatatypeTypeType)) (= (type |replacement#0@@22|) DatatypeTypeType)) (or (|PagedBetree.Path.ReplacedChildren#canCall| (Lit this@@437) |replacement#0@@22|) (and (and ($Is this@@437 Tclass.PagedBetree.Path) ($Is |replacement#0@@22| Tclass.PagedBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit this@@437))))) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@22|)) (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@437))))))))) (and (and (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@437)) (|PagedBetree.Path.Substitute#canCall| (Lit (PagedBetree.Path.Subpath (Lit this@@437))) |replacement#0@@22|)) (forall ((|k#0@@86| T@U) ) (!  (=> (and (= (type |k#0@@86|) (SeqType BoxType)) ($Is |k#0@@86| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@86|) (=> (Buffers.__default.AnyKey |k#0@@86|) (and (PagedBetree.Path.Path_q (Lit this@@437)) (=> (not (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@437))) (LitInt 0))) ($Box |k#0@@86|)))) (and (PagedBetree.Path.Path_q (Lit this@@437)) (|PagedBetree.BetreeNode.Child#canCall| (Lit (PagedBetree.Path.node (Lit this@@437))) |k#0@@86|)))))))
 :qid |PagedBetreeidfy.351:21|
 :skolemid |7493|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@437) |k#0@@86|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@437) 0)) ($Box |k#0@@86|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@86|))
))) (= (PagedBetree.Path.ReplacedChildren ($LS $ly@@774) (Lit this@@437) |replacement#0@@22|) (let ((|replacedChild#1| (PagedBetree.Path.Substitute ($LS $ly@@774) (Lit (PagedBetree.Path.Subpath (Lit this@@437))) |replacement#0@@22|)))
(|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#388| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@437))) (LitInt 0))) |replacedChild#1| (Lit (PagedBetree.Path.node (Lit this@@437)))) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))))
 :qid |PagedBetreeidfy.342:24|
 :weight 3
 :skolemid |7494|
 :pattern ( (PagedBetree.Path.ReplacedChildren ($LS $ly@@774) (Lit this@@437) |replacement#0@@22|))
))))
(assert  (=> true (forall (($ly@@775 T@U) (this@@438 T@U) (|replacement#0@@23| T@U) ) (!  (=> (and (and (and (= (type $ly@@775) LayerTypeType) (= (type this@@438) DatatypeTypeType)) (= (type |replacement#0@@23|) DatatypeTypeType)) (or (|PagedBetree.Path.ReplacedChildren#canCall| (Lit this@@438) (Lit |replacement#0@@23|)) (and (and ($Is this@@438 Tclass.PagedBetree.Path) ($Is |replacement#0@@23| Tclass.PagedBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit this@@438))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@23|)))))) (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@438))))))))) (and (and (and (|PagedBetree.Path.Subpath#canCall| (Lit this@@438)) (|PagedBetree.Path.Substitute#canCall| (Lit (PagedBetree.Path.Subpath (Lit this@@438))) (Lit |replacement#0@@23|))) (forall ((|k#0@@87| T@U) ) (!  (=> (and (= (type |k#0@@87|) (SeqType BoxType)) ($Is |k#0@@87| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@87|) (=> (Buffers.__default.AnyKey |k#0@@87|) (and (PagedBetree.Path.Path_q (Lit this@@438)) (=> (not (U_2_bool (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@438))) (LitInt 0))) ($Box |k#0@@87|)))) (and (PagedBetree.Path.Path_q (Lit this@@438)) (|PagedBetree.BetreeNode.Child#canCall| (Lit (PagedBetree.Path.node (Lit this@@438))) |k#0@@87|)))))))
 :qid |PagedBetreeidfy.351:21|
 :skolemid |7495|
 :pattern ( (PagedBetree.BetreeNode.Child (PagedBetree.Path.node this@@438) |k#0@@87|))
 :pattern ( (MapType0Select ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (PagedBetree.Path.routing this@@438) 0)) ($Box |k#0@@87|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@87|))
))) (= (PagedBetree.Path.ReplacedChildren ($LS $ly@@775) (Lit this@@438) (Lit |replacement#0@@23|)) (let ((|replacedChild#2| (Lit (PagedBetree.Path.Substitute ($LS $ly@@775) (Lit (PagedBetree.Path.Subpath (Lit this@@438))) (Lit |replacement#0@@23|)))))
(|#PagedBetree.ChildMap.ChildMap| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#388| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit (PagedBetree.Path.routing (Lit this@@438))) (LitInt 0))) |replacedChild#2| (Lit (PagedBetree.Path.node (Lit this@@438)))) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode)))))))
 :qid |PagedBetreeidfy.342:24|
 :weight 3
 :skolemid |7496|
 :pattern ( (PagedBetree.Path.ReplacedChildren ($LS $ly@@775) (Lit this@@438) (Lit |replacement#0@@23|)))
))))
(assert (forall (($ly@@776 T@U) (this@@439 T@U) (|replacement#0@@24| T@U) ) (!  (=> (and (and (= (type $ly@@776) LayerTypeType) (= (type this@@439) DatatypeTypeType)) (= (type |replacement#0@@24|) DatatypeTypeType)) (= (PagedBetree.Path.Substitute ($LS $ly@@776) this@@439 |replacement#0@@24|) (PagedBetree.Path.Substitute $ly@@776 this@@439 |replacement#0@@24|)))
 :qid |PagedBetreeidfy.354:14|
 :skolemid |7497|
 :pattern ( (PagedBetree.Path.Substitute ($LS $ly@@776) this@@439 |replacement#0@@24|))
)))
(assert (forall (($ly@@777 T@U) (this@@440 T@U) (|replacement#0@@25| T@U) ) (!  (=> (and (and (= (type $ly@@777) LayerTypeType) (= (type this@@440) DatatypeTypeType)) (= (type |replacement#0@@25|) DatatypeTypeType)) (= (PagedBetree.Path.Substitute $ly@@777 this@@440 |replacement#0@@25|) (PagedBetree.Path.Substitute $LZ this@@440 |replacement#0@@25|)))
 :qid |PagedBetreeidfy.354:14|
 :skolemid |7498|
 :pattern ( (PagedBetree.Path.Substitute (AsFuelBottom $ly@@777) this@@440 |replacement#0@@25|))
)))
(assert  (=> true (forall (($ly@@778 T@U) (this@@441 T@U) (|replacement#0@@26| T@U) ) (!  (=> (and (and (and (= (type $ly@@778) LayerTypeType) (= (type this@@441) DatatypeTypeType)) (= (type |replacement#0@@26|) DatatypeTypeType)) (or (|PagedBetree.Path.Substitute#canCall| this@@441 |replacement#0@@26|) (and (and ($Is this@@441 Tclass.PagedBetree.Path) ($Is |replacement#0@@26| Tclass.PagedBetree.BetreeNode)) (and (PagedBetree.Path.Valid ($LS $LZ) this@@441) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@26|))))) ($Is (PagedBetree.Path.Substitute $ly@@778 this@@441 |replacement#0@@26|) Tclass.PagedBetree.BetreeNode))
 :qid |PagedBetreeidfy.354:14|
 :skolemid |7499|
 :pattern ( (PagedBetree.Path.Substitute $ly@@778 this@@441 |replacement#0@@26|))
))))
(assert (forall (($ly@@779 T@U) (this@@442 T@U) (|replacement#0@@27| T@U) ) (!  (=> (and (and (and (= (type $ly@@779) LayerTypeType) (= (type this@@442) DatatypeTypeType)) (= (type |replacement#0@@27|) DatatypeTypeType)) (and ($Is this@@442 Tclass.PagedBetree.Path) ($Is |replacement#0@@27| Tclass.PagedBetree.BetreeNode))) (= (|PagedBetree.Path.Substitute#requires| $ly@@779 this@@442 |replacement#0@@27|)  (and (PagedBetree.Path.Valid ($LS $LZ) this@@442) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@27|))))
 :qid |PagedBetreeidfy.354:14|
 :skolemid |7500|
 :pattern ( (|PagedBetree.Path.Substitute#requires| $ly@@779 this@@442 |replacement#0@@27|))
)))
(assert  (=> true (forall (($ly@@780 T@U) (this@@443 T@U) (|replacement#0@@28| T@U) ) (!  (=> (and (and (and (= (type $ly@@780) LayerTypeType) (= (type this@@443) DatatypeTypeType)) (= (type |replacement#0@@28|) DatatypeTypeType)) (or (|PagedBetree.Path.Substitute#canCall| this@@443 |replacement#0@@28|) (and (and ($Is this@@443 Tclass.PagedBetree.Path) ($Is |replacement#0@@28| Tclass.PagedBetree.BetreeNode)) (and (PagedBetree.Path.Valid ($LS $LZ) this@@443) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@28|))))) (and (and (PagedBetree.Path.Path_q this@@443) (=> (not (= (LitInt 0) (|Seq#Length| (PagedBetree.Path.routing this@@443)))) (and (PagedBetree.Path.Path_q this@@443) (|PagedBetree.Path.ReplacedChildren#canCall| this@@443 |replacement#0@@28|)))) (= (PagedBetree.Path.Substitute ($LS $ly@@780) this@@443 |replacement#0@@28|) (ite (= (LitInt 0) (|Seq#Length| (PagedBetree.Path.routing this@@443))) |replacement#0@@28| (|#PagedBetree.BetreeNode.BetreeNode| (PagedBetree.BetreeNode.buffers (PagedBetree.Path.node this@@443)) (PagedBetree.Path.ReplacedChildren $ly@@780 this@@443 |replacement#0@@28|))))))
 :qid |PagedBetreeidfy.354:14|
 :skolemid |7501|
 :pattern ( (PagedBetree.Path.Substitute ($LS $ly@@780) this@@443 |replacement#0@@28|))
))))
(assert  (=> true (forall (($ly@@781 T@U) (this@@444 T@U) (|replacement#0@@29| T@U) ) (!  (=> (and (and (and (= (type $ly@@781) LayerTypeType) (= (type this@@444) DatatypeTypeType)) (= (type |replacement#0@@29|) DatatypeTypeType)) (or (|PagedBetree.Path.Substitute#canCall| (Lit this@@444) |replacement#0@@29|) (and (and ($Is this@@444 Tclass.PagedBetree.Path) ($Is |replacement#0@@29| Tclass.PagedBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit this@@444))))) (PagedBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@29|))))) (and (and (PagedBetree.Path.Path_q (Lit this@@444)) (=> (not (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@444)))))) (and (PagedBetree.Path.Path_q (Lit this@@444)) (|PagedBetree.Path.ReplacedChildren#canCall| (Lit this@@444) |replacement#0@@29|)))) (= (PagedBetree.Path.Substitute ($LS $ly@@781) (Lit this@@444) |replacement#0@@29|) (ite (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@444))))) |replacement#0@@29| (|#PagedBetree.BetreeNode.BetreeNode| (Lit (PagedBetree.BetreeNode.buffers (Lit (PagedBetree.Path.node (Lit this@@444))))) (PagedBetree.Path.ReplacedChildren ($LS $ly@@781) (Lit this@@444) |replacement#0@@29|))))))
 :qid |PagedBetreeidfy.354:14|
 :weight 3
 :skolemid |7502|
 :pattern ( (PagedBetree.Path.Substitute ($LS $ly@@781) (Lit this@@444) |replacement#0@@29|))
))))
(assert  (=> true (forall (($ly@@782 T@U) (this@@445 T@U) (|replacement#0@@30| T@U) ) (!  (=> (and (and (and (= (type $ly@@782) LayerTypeType) (= (type this@@445) DatatypeTypeType)) (= (type |replacement#0@@30|) DatatypeTypeType)) (or (|PagedBetree.Path.Substitute#canCall| (Lit this@@445) (Lit |replacement#0@@30|)) (and (and ($Is this@@445 Tclass.PagedBetree.Path) ($Is |replacement#0@@30| Tclass.PagedBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit this@@445))))) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@30|))))))))) (and (and (PagedBetree.Path.Path_q (Lit this@@445)) (=> (not (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@445)))))) (and (PagedBetree.Path.Path_q (Lit this@@445)) (|PagedBetree.Path.ReplacedChildren#canCall| (Lit this@@445) (Lit |replacement#0@@30|))))) (= (PagedBetree.Path.Substitute ($LS $ly@@782) (Lit this@@445) (Lit |replacement#0@@30|)) (ite (= (LitInt 0) (|Seq#Length| (Lit (PagedBetree.Path.routing (Lit this@@445))))) |replacement#0@@30| (|#PagedBetree.BetreeNode.BetreeNode| (Lit (PagedBetree.BetreeNode.buffers (Lit (PagedBetree.Path.node (Lit this@@445))))) (PagedBetree.Path.ReplacedChildren ($LS $ly@@782) (Lit this@@445) (Lit |replacement#0@@30|)))))))
 :qid |PagedBetreeidfy.354:14|
 :weight 3
 :skolemid |7503|
 :pattern ( (PagedBetree.Path.Substitute ($LS $ly@@782) (Lit this@@445) (Lit |replacement#0@@30|)))
))))
(assert (forall ((|a#0#0#0@@18| T@U) ) (!  (=> (= (type |a#0#0#0@@18|) DatatypeTypeType) (= (DatatypeCtorId (|#PagedBetree.Step.QueryStep| |a#0#0#0@@18|)) |##PagedBetree.Step.QueryStep|))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7504|
 :pattern ( (|#PagedBetree.Step.QueryStep| |a#0#0#0@@18|))
)))
(assert (forall ((d@@238 T@U) ) (!  (=> (= (type d@@238) DatatypeTypeType) (= (PagedBetree.Step.QueryStep_q d@@238) (= (DatatypeCtorId d@@238) |##PagedBetree.Step.QueryStep|)))
 :qid |unknown.0:0|
 :skolemid |7505|
 :pattern ( (PagedBetree.Step.QueryStep_q d@@238))
)))
(assert (forall ((d@@239 T@U) ) (!  (=> (and (= (type d@@239) DatatypeTypeType) (PagedBetree.Step.QueryStep_q d@@239)) (exists ((|a#1#0#0@@18| T@U) ) (!  (and (= (type |a#1#0#0@@18|) DatatypeTypeType) (= d@@239 (|#PagedBetree.Step.QueryStep| |a#1#0#0@@18|)))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7506|
 :no-pattern (type |a#1#0#0@@18|)
 :no-pattern (U_2_int |a#1#0#0@@18|)
 :no-pattern (U_2_bool |a#1#0#0@@18|)
)))
 :qid |unknown.0:0|
 :skolemid |7507|
 :pattern ( (PagedBetree.Step.QueryStep_q d@@239))
)))
(assert (forall ((|a#2#0#0@@18| T@U) ) (!  (=> (= (type |a#2#0#0@@18|) DatatypeTypeType) (= ($Is (|#PagedBetree.Step.QueryStep| |a#2#0#0@@18|) Tclass.PagedBetree.Step) ($Is |a#2#0#0@@18| Tclass.PagedBetree.QueryReceipt)))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7508|
 :pattern ( ($Is (|#PagedBetree.Step.QueryStep| |a#2#0#0@@18|) Tclass.PagedBetree.Step))
)))
(assert (forall ((|a#3#0#0@@18| T@U) ($h@@212 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@18|) DatatypeTypeType) (= (type $h@@212) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@212)) (= ($IsAlloc (|#PagedBetree.Step.QueryStep| |a#3#0#0@@18|) Tclass.PagedBetree.Step $h@@212) ($IsAlloc |a#3#0#0@@18| Tclass.PagedBetree.QueryReceipt $h@@212)))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7509|
 :pattern ( ($IsAlloc (|#PagedBetree.Step.QueryStep| |a#3#0#0@@18|) Tclass.PagedBetree.Step $h@@212))
)))
(assert (forall ((arg0@@719 T@U) ) (! (= (type (PagedBetree.Step.receipt arg0@@719)) DatatypeTypeType)
 :qid |funType:PagedBetree.Step.receipt|
 :pattern ( (PagedBetree.Step.receipt arg0@@719))
)))
(assert (forall ((d@@240 T@U) ($h@@213 T@U) ) (!  (=> (and (and (= (type d@@240) DatatypeTypeType) (= (type $h@@213) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@213) (and (PagedBetree.Step.QueryStep_q d@@240) ($IsAlloc d@@240 Tclass.PagedBetree.Step $h@@213)))) ($IsAlloc (PagedBetree.Step.receipt d@@240) Tclass.PagedBetree.QueryReceipt $h@@213))
 :qid |unknown.0:0|
 :skolemid |7510|
 :pattern ( ($IsAlloc (PagedBetree.Step.receipt d@@240) Tclass.PagedBetree.QueryReceipt $h@@213))
)))
(assert (forall ((|a#4#0#0@@18| T@U) ) (!  (=> (= (type |a#4#0#0@@18|) DatatypeTypeType) (= (|#PagedBetree.Step.QueryStep| (Lit |a#4#0#0@@18|)) (Lit (|#PagedBetree.Step.QueryStep| |a#4#0#0@@18|))))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7511|
 :pattern ( (|#PagedBetree.Step.QueryStep| (Lit |a#4#0#0@@18|)))
)))
(assert (forall ((|a#5#0#0@@21| T@U) ) (!  (=> (= (type |a#5#0#0@@21|) DatatypeTypeType) (= (PagedBetree.Step.receipt (|#PagedBetree.Step.QueryStep| |a#5#0#0@@21|)) |a#5#0#0@@21|))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7512|
 :pattern ( (|#PagedBetree.Step.QueryStep| |a#5#0#0@@21|))
)))
(assert (forall ((|a#6#0#0@@21| T@U) ) (!  (=> (= (type |a#6#0#0@@21|) DatatypeTypeType) (< (DtRank |a#6#0#0@@21|) (DtRank (|#PagedBetree.Step.QueryStep| |a#6#0#0@@21|))))
 :qid |PagedBetreeidfy.431:17|
 :skolemid |7513|
 :pattern ( (|#PagedBetree.Step.QueryStep| |a#6#0#0@@21|))
)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.PutStep|) |##PagedBetree.Step.PutStep|))
(assert (forall ((d@@241 T@U) ) (!  (=> (= (type d@@241) DatatypeTypeType) (= (PagedBetree.Step.PutStep_q d@@241) (= (DatatypeCtorId d@@241) |##PagedBetree.Step.PutStep|)))
 :qid |unknown.0:0|
 :skolemid |7514|
 :pattern ( (PagedBetree.Step.PutStep_q d@@241))
)))
(assert (forall ((d@@242 T@U) ) (!  (=> (and (= (type d@@242) DatatypeTypeType) (PagedBetree.Step.PutStep_q d@@242)) (= d@@242 |#PagedBetree.Step.PutStep|))
 :qid |unknown.0:0|
 :skolemid |7515|
 :pattern ( (PagedBetree.Step.PutStep_q d@@242))
)))
(assert ($Is |#PagedBetree.Step.PutStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@214 T@U) ) (!  (=> (and (= (type $h@@214) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@214)) ($IsAlloc |#PagedBetree.Step.PutStep| Tclass.PagedBetree.Step $h@@214))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7516|
 :pattern ( ($IsAlloc |#PagedBetree.Step.PutStep| Tclass.PagedBetree.Step $h@@214))
)))
(assert (= |#PagedBetree.Step.PutStep| (Lit |#PagedBetree.Step.PutStep|)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.QueryEndLsnStep|) |##PagedBetree.Step.QueryEndLsnStep|))
(assert (forall ((d@@243 T@U) ) (!  (=> (= (type d@@243) DatatypeTypeType) (= (PagedBetree.Step.QueryEndLsnStep_q d@@243) (= (DatatypeCtorId d@@243) |##PagedBetree.Step.QueryEndLsnStep|)))
 :qid |unknown.0:0|
 :skolemid |7517|
 :pattern ( (PagedBetree.Step.QueryEndLsnStep_q d@@243))
)))
(assert (forall ((d@@244 T@U) ) (!  (=> (and (= (type d@@244) DatatypeTypeType) (PagedBetree.Step.QueryEndLsnStep_q d@@244)) (= d@@244 |#PagedBetree.Step.QueryEndLsnStep|))
 :qid |unknown.0:0|
 :skolemid |7518|
 :pattern ( (PagedBetree.Step.QueryEndLsnStep_q d@@244))
)))
(assert ($Is |#PagedBetree.Step.QueryEndLsnStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@215 T@U) ) (!  (=> (and (= (type $h@@215) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@215)) ($IsAlloc |#PagedBetree.Step.QueryEndLsnStep| Tclass.PagedBetree.Step $h@@215))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7519|
 :pattern ( ($IsAlloc |#PagedBetree.Step.QueryEndLsnStep| Tclass.PagedBetree.Step $h@@215))
)))
(assert (= |#PagedBetree.Step.QueryEndLsnStep| (Lit |#PagedBetree.Step.QueryEndLsnStep|)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.FreezeAsStep|) |##PagedBetree.Step.FreezeAsStep|))
(assert (forall ((d@@245 T@U) ) (!  (=> (= (type d@@245) DatatypeTypeType) (= (PagedBetree.Step.FreezeAsStep_q d@@245) (= (DatatypeCtorId d@@245) |##PagedBetree.Step.FreezeAsStep|)))
 :qid |unknown.0:0|
 :skolemid |7520|
 :pattern ( (PagedBetree.Step.FreezeAsStep_q d@@245))
)))
(assert (forall ((d@@246 T@U) ) (!  (=> (and (= (type d@@246) DatatypeTypeType) (PagedBetree.Step.FreezeAsStep_q d@@246)) (= d@@246 |#PagedBetree.Step.FreezeAsStep|))
 :qid |unknown.0:0|
 :skolemid |7521|
 :pattern ( (PagedBetree.Step.FreezeAsStep_q d@@246))
)))
(assert ($Is |#PagedBetree.Step.FreezeAsStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@216 T@U) ) (!  (=> (and (= (type $h@@216) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@216)) ($IsAlloc |#PagedBetree.Step.FreezeAsStep| Tclass.PagedBetree.Step $h@@216))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7522|
 :pattern ( ($IsAlloc |#PagedBetree.Step.FreezeAsStep| Tclass.PagedBetree.Step $h@@216))
)))
(assert (= |#PagedBetree.Step.FreezeAsStep| (Lit |#PagedBetree.Step.FreezeAsStep|)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.InternalGrowStep|) |##PagedBetree.Step.InternalGrowStep|))
(assert (forall ((d@@247 T@U) ) (!  (=> (= (type d@@247) DatatypeTypeType) (= (PagedBetree.Step.InternalGrowStep_q d@@247) (= (DatatypeCtorId d@@247) |##PagedBetree.Step.InternalGrowStep|)))
 :qid |unknown.0:0|
 :skolemid |7523|
 :pattern ( (PagedBetree.Step.InternalGrowStep_q d@@247))
)))
(assert (forall ((d@@248 T@U) ) (!  (=> (and (= (type d@@248) DatatypeTypeType) (PagedBetree.Step.InternalGrowStep_q d@@248)) (= d@@248 |#PagedBetree.Step.InternalGrowStep|))
 :qid |unknown.0:0|
 :skolemid |7524|
 :pattern ( (PagedBetree.Step.InternalGrowStep_q d@@248))
)))
(assert ($Is |#PagedBetree.Step.InternalGrowStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@217 T@U) ) (!  (=> (and (= (type $h@@217) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@217)) ($IsAlloc |#PagedBetree.Step.InternalGrowStep| Tclass.PagedBetree.Step $h@@217))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7525|
 :pattern ( ($IsAlloc |#PagedBetree.Step.InternalGrowStep| Tclass.PagedBetree.Step $h@@217))
)))
(assert (= |#PagedBetree.Step.InternalGrowStep| (Lit |#PagedBetree.Step.InternalGrowStep|)))
(assert (forall ((|a#27#0#0@@2| T@U) (|a#27#1#0@@0| T@U) (|a#27#2#0| T@U) ) (!  (=> (and (and (= (type |a#27#0#0@@2|) DatatypeTypeType) (= (type |a#27#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#27#2#0|) (MapType0Type BoxType boolType))) (= (DatatypeCtorId (|#PagedBetree.Step.InternalSplitStep| |a#27#0#0@@2| |a#27#1#0@@0| |a#27#2#0|)) |##PagedBetree.Step.InternalSplitStep|))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7526|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| |a#27#0#0@@2| |a#27#1#0@@0| |a#27#2#0|))
)))
(assert (forall ((d@@249 T@U) ) (!  (=> (= (type d@@249) DatatypeTypeType) (= (PagedBetree.Step.InternalSplitStep_q d@@249) (= (DatatypeCtorId d@@249) |##PagedBetree.Step.InternalSplitStep|)))
 :qid |unknown.0:0|
 :skolemid |7527|
 :pattern ( (PagedBetree.Step.InternalSplitStep_q d@@249))
)))
(assert (forall ((d@@250 T@U) ) (!  (=> (and (= (type d@@250) DatatypeTypeType) (PagedBetree.Step.InternalSplitStep_q d@@250)) (exists ((|a#28#0#0@@1| T@U) (|a#28#1#0@@0| T@U) (|a#28#2#0| T@U) ) (!  (and (and (and (= (type |a#28#0#0@@1|) DatatypeTypeType) (= (type |a#28#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#28#2#0|) (MapType0Type BoxType boolType))) (= d@@250 (|#PagedBetree.Step.InternalSplitStep| |a#28#0#0@@1| |a#28#1#0@@0| |a#28#2#0|)))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7528|
 :no-pattern (type |a#28#0#0@@1|)
 :no-pattern (type |a#28#1#0@@0|)
 :no-pattern (type |a#28#2#0|)
 :no-pattern (U_2_int |a#28#0#0@@1|)
 :no-pattern (U_2_bool |a#28#0#0@@1|)
 :no-pattern (U_2_int |a#28#1#0@@0|)
 :no-pattern (U_2_bool |a#28#1#0@@0|)
 :no-pattern (U_2_int |a#28#2#0|)
 :no-pattern (U_2_bool |a#28#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |7529|
 :pattern ( (PagedBetree.Step.InternalSplitStep_q d@@250))
)))
(assert (forall ((|a#29#0#0@@1| T@U) (|a#29#1#0@@0| T@U) (|a#29#2#0| T@U) ) (!  (=> (and (and (= (type |a#29#0#0@@1|) DatatypeTypeType) (= (type |a#29#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#29#2#0|) (MapType0Type BoxType boolType))) (= ($Is (|#PagedBetree.Step.InternalSplitStep| |a#29#0#0@@1| |a#29#1#0@@0| |a#29#2#0|) Tclass.PagedBetree.Step)  (and (and ($Is |a#29#0#0@@1| Tclass.PagedBetree.Path) ($Is |a#29#1#0@@0| (TISet Tclass.KeyType.Key))) ($Is |a#29#2#0| (TISet Tclass.KeyType.Key)))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7530|
 :pattern ( ($Is (|#PagedBetree.Step.InternalSplitStep| |a#29#0#0@@1| |a#29#1#0@@0| |a#29#2#0|) Tclass.PagedBetree.Step))
)))
(assert (forall ((|a#30#0#0@@1| T@U) (|a#30#1#0@@0| T@U) (|a#30#2#0| T@U) ($h@@218 T@U) ) (!  (=> (and (and (and (and (= (type |a#30#0#0@@1|) DatatypeTypeType) (= (type |a#30#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#30#2#0|) (MapType0Type BoxType boolType))) (= (type $h@@218) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@218)) (= ($IsAlloc (|#PagedBetree.Step.InternalSplitStep| |a#30#0#0@@1| |a#30#1#0@@0| |a#30#2#0|) Tclass.PagedBetree.Step $h@@218)  (and (and ($IsAlloc |a#30#0#0@@1| Tclass.PagedBetree.Path $h@@218) ($IsAlloc |a#30#1#0@@0| (TISet Tclass.KeyType.Key) $h@@218)) ($IsAlloc |a#30#2#0| (TISet Tclass.KeyType.Key) $h@@218))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7531|
 :pattern ( ($IsAlloc (|#PagedBetree.Step.InternalSplitStep| |a#30#0#0@@1| |a#30#1#0@@0| |a#30#2#0|) Tclass.PagedBetree.Step $h@@218))
)))
(assert (forall ((arg0@@720 T@U) ) (! (= (type (PagedBetree.Step.path arg0@@720)) DatatypeTypeType)
 :qid |funType:PagedBetree.Step.path|
 :pattern ( (PagedBetree.Step.path arg0@@720))
)))
(assert (forall ((d@@251 T@U) ($h@@219 T@U) ) (!  (=> (and (and (= (type d@@251) DatatypeTypeType) (= (type $h@@219) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@219) (and (PagedBetree.Step.InternalSplitStep_q d@@251) ($IsAlloc d@@251 Tclass.PagedBetree.Step $h@@219)))) ($IsAlloc (PagedBetree.Step.path d@@251) Tclass.PagedBetree.Path $h@@219))
 :qid |unknown.0:0|
 :skolemid |7532|
 :pattern ( ($IsAlloc (PagedBetree.Step.path d@@251) Tclass.PagedBetree.Path $h@@219))
)))
(assert (forall ((arg0@@721 T@U) ) (! (= (type (PagedBetree.Step.leftKeys arg0@@721)) (MapType0Type BoxType boolType))
 :qid |funType:PagedBetree.Step.leftKeys|
 :pattern ( (PagedBetree.Step.leftKeys arg0@@721))
)))
(assert (forall ((d@@252 T@U) ($h@@220 T@U) ) (!  (=> (and (and (= (type d@@252) DatatypeTypeType) (= (type $h@@220) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@220) (and (PagedBetree.Step.InternalSplitStep_q d@@252) ($IsAlloc d@@252 Tclass.PagedBetree.Step $h@@220)))) ($IsAlloc (PagedBetree.Step.leftKeys d@@252) (TISet Tclass.KeyType.Key) $h@@220))
 :qid |unknown.0:0|
 :skolemid |7533|
 :pattern ( ($IsAlloc (PagedBetree.Step.leftKeys d@@252) (TISet Tclass.KeyType.Key) $h@@220))
)))
(assert (forall ((arg0@@722 T@U) ) (! (= (type (PagedBetree.Step.rightKeys arg0@@722)) (MapType0Type BoxType boolType))
 :qid |funType:PagedBetree.Step.rightKeys|
 :pattern ( (PagedBetree.Step.rightKeys arg0@@722))
)))
(assert (forall ((d@@253 T@U) ($h@@221 T@U) ) (!  (=> (and (and (= (type d@@253) DatatypeTypeType) (= (type $h@@221) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@221) (and (PagedBetree.Step.InternalSplitStep_q d@@253) ($IsAlloc d@@253 Tclass.PagedBetree.Step $h@@221)))) ($IsAlloc (PagedBetree.Step.rightKeys d@@253) (TISet Tclass.KeyType.Key) $h@@221))
 :qid |unknown.0:0|
 :skolemid |7534|
 :pattern ( ($IsAlloc (PagedBetree.Step.rightKeys d@@253) (TISet Tclass.KeyType.Key) $h@@221))
)))
(assert (forall ((|a#31#0#0@@1| T@U) (|a#31#1#0@@0| T@U) (|a#31#2#0| T@U) ) (!  (=> (and (and (= (type |a#31#0#0@@1|) DatatypeTypeType) (= (type |a#31#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#31#2#0|) (MapType0Type BoxType boolType))) (= (|#PagedBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@1|) (Lit |a#31#1#0@@0|) (Lit |a#31#2#0|)) (Lit (|#PagedBetree.Step.InternalSplitStep| |a#31#0#0@@1| |a#31#1#0@@0| |a#31#2#0|))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7535|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@1|) (Lit |a#31#1#0@@0|) (Lit |a#31#2#0|)))
)))
(assert (forall ((|a#32#0#0@@1| T@U) (|a#32#1#0@@0| T@U) (|a#32#2#0| T@U) ) (!  (=> (and (and (= (type |a#32#0#0@@1|) DatatypeTypeType) (= (type |a#32#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#32#2#0|) (MapType0Type BoxType boolType))) (= (PagedBetree.Step.path (|#PagedBetree.Step.InternalSplitStep| |a#32#0#0@@1| |a#32#1#0@@0| |a#32#2#0|)) |a#32#0#0@@1|))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7536|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| |a#32#0#0@@1| |a#32#1#0@@0| |a#32#2#0|))
)))
(assert (forall ((|a#33#0#0@@2| T@U) (|a#33#1#0@@0| T@U) (|a#33#2#0| T@U) ) (!  (=> (and (and (= (type |a#33#0#0@@2|) DatatypeTypeType) (= (type |a#33#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#33#2#0|) (MapType0Type BoxType boolType))) (< (DtRank |a#33#0#0@@2|) (DtRank (|#PagedBetree.Step.InternalSplitStep| |a#33#0#0@@2| |a#33#1#0@@0| |a#33#2#0|))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7537|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| |a#33#0#0@@2| |a#33#1#0@@0| |a#33#2#0|))
)))
(assert (forall ((|a#34#0#0@@2| T@U) (|a#34#1#0@@0| T@U) (|a#34#2#0| T@U) ) (!  (=> (and (and (= (type |a#34#0#0@@2|) DatatypeTypeType) (= (type |a#34#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#34#2#0|) (MapType0Type BoxType boolType))) (= (PagedBetree.Step.leftKeys (|#PagedBetree.Step.InternalSplitStep| |a#34#0#0@@2| |a#34#1#0@@0| |a#34#2#0|)) |a#34#1#0@@0|))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7538|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| |a#34#0#0@@2| |a#34#1#0@@0| |a#34#2#0|))
)))
(assert (forall ((|a#35#0#0@@2| T@U) (|a#35#1#0@@0| T@U) (|a#35#2#0| T@U) (d@@254 T@U) ) (!  (=> (and (and (and (and (= (type |a#35#0#0@@2|) DatatypeTypeType) (= (type |a#35#1#0@@0|) (MapType0Type BoxType boolType))) (= (type |a#35#2#0|) (MapType0Type BoxType boolType))) (= (type d@@254) DatatypeTypeType)) (U_2_bool (MapType0Select |a#35#1#0@@0| ($Box d@@254)))) (< (DtRank d@@254) (DtRank (|#PagedBetree.Step.InternalSplitStep| |a#35#0#0@@2| |a#35#1#0@@0| |a#35#2#0|))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7539|
 :pattern ( (MapType0Select |a#35#1#0@@0| ($Box d@@254)) (|#PagedBetree.Step.InternalSplitStep| |a#35#0#0@@2| |a#35#1#0@@0| |a#35#2#0|))
)))
(assert (forall ((|a#36#0#0@@1| T@U) (|a#36#1#0| T@U) (|a#36#2#0| T@U) ) (!  (=> (and (and (= (type |a#36#0#0@@1|) DatatypeTypeType) (= (type |a#36#1#0|) (MapType0Type BoxType boolType))) (= (type |a#36#2#0|) (MapType0Type BoxType boolType))) (= (PagedBetree.Step.rightKeys (|#PagedBetree.Step.InternalSplitStep| |a#36#0#0@@1| |a#36#1#0| |a#36#2#0|)) |a#36#2#0|))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7540|
 :pattern ( (|#PagedBetree.Step.InternalSplitStep| |a#36#0#0@@1| |a#36#1#0| |a#36#2#0|))
)))
(assert (forall ((|a#37#0#0@@1| T@U) (|a#37#1#0| T@U) (|a#37#2#0| T@U) (d@@255 T@U) ) (!  (=> (and (and (and (and (= (type |a#37#0#0@@1|) DatatypeTypeType) (= (type |a#37#1#0|) (MapType0Type BoxType boolType))) (= (type |a#37#2#0|) (MapType0Type BoxType boolType))) (= (type d@@255) DatatypeTypeType)) (U_2_bool (MapType0Select |a#37#2#0| ($Box d@@255)))) (< (DtRank d@@255) (DtRank (|#PagedBetree.Step.InternalSplitStep| |a#37#0#0@@1| |a#37#1#0| |a#37#2#0|))))
 :qid |PagedBetreeidfy.436:25|
 :skolemid |7541|
 :pattern ( (MapType0Select |a#37#2#0| ($Box d@@255)) (|#PagedBetree.Step.InternalSplitStep| |a#37#0#0@@1| |a#37#1#0| |a#37#2#0|))
)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.InternalFlushMemtableStep|) |##PagedBetree.Step.InternalFlushMemtableStep|))
(assert (forall ((d@@256 T@U) ) (!  (=> (= (type d@@256) DatatypeTypeType) (= (PagedBetree.Step.InternalFlushMemtableStep_q d@@256) (= (DatatypeCtorId d@@256) |##PagedBetree.Step.InternalFlushMemtableStep|)))
 :qid |unknown.0:0|
 :skolemid |7542|
 :pattern ( (PagedBetree.Step.InternalFlushMemtableStep_q d@@256))
)))
(assert (forall ((d@@257 T@U) ) (!  (=> (and (= (type d@@257) DatatypeTypeType) (PagedBetree.Step.InternalFlushMemtableStep_q d@@257)) (= d@@257 |#PagedBetree.Step.InternalFlushMemtableStep|))
 :qid |unknown.0:0|
 :skolemid |7543|
 :pattern ( (PagedBetree.Step.InternalFlushMemtableStep_q d@@257))
)))
(assert ($Is |#PagedBetree.Step.InternalFlushMemtableStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@222 T@U) ) (!  (=> (and (= (type $h@@222) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@222)) ($IsAlloc |#PagedBetree.Step.InternalFlushMemtableStep| Tclass.PagedBetree.Step $h@@222))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7544|
 :pattern ( ($IsAlloc |#PagedBetree.Step.InternalFlushMemtableStep| Tclass.PagedBetree.Step $h@@222))
)))
(assert (= |#PagedBetree.Step.InternalFlushMemtableStep| (Lit |#PagedBetree.Step.InternalFlushMemtableStep|)))
(assert (forall ((|a#43#0#0@@0| T@U) (|a#43#1#0@@0| T@U) ) (!  (=> (and (= (type |a#43#0#0@@0|) DatatypeTypeType) (= (type |a#43#1#0@@0|) (MapType0Type BoxType boolType))) (= (DatatypeCtorId (|#PagedBetree.Step.InternalFlushStep| |a#43#0#0@@0| |a#43#1#0@@0|)) |##PagedBetree.Step.InternalFlushStep|))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7545|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| |a#43#0#0@@0| |a#43#1#0@@0|))
)))
(assert (forall ((d@@258 T@U) ) (!  (=> (= (type d@@258) DatatypeTypeType) (= (PagedBetree.Step.InternalFlushStep_q d@@258) (= (DatatypeCtorId d@@258) |##PagedBetree.Step.InternalFlushStep|)))
 :qid |unknown.0:0|
 :skolemid |7546|
 :pattern ( (PagedBetree.Step.InternalFlushStep_q d@@258))
)))
(assert (forall ((d@@259 T@U) ) (!  (=> (and (= (type d@@259) DatatypeTypeType) (PagedBetree.Step.InternalFlushStep_q d@@259)) (exists ((|a#44#0#0@@0| T@U) (|a#44#1#0@@0| T@U) ) (!  (and (and (= (type |a#44#0#0@@0|) DatatypeTypeType) (= (type |a#44#1#0@@0|) (MapType0Type BoxType boolType))) (= d@@259 (|#PagedBetree.Step.InternalFlushStep| |a#44#0#0@@0| |a#44#1#0@@0|)))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7547|
 :no-pattern (type |a#44#0#0@@0|)
 :no-pattern (type |a#44#1#0@@0|)
 :no-pattern (U_2_int |a#44#0#0@@0|)
 :no-pattern (U_2_bool |a#44#0#0@@0|)
 :no-pattern (U_2_int |a#44#1#0@@0|)
 :no-pattern (U_2_bool |a#44#1#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |7548|
 :pattern ( (PagedBetree.Step.InternalFlushStep_q d@@259))
)))
(assert (forall ((|a#45#0#0@@0| T@U) (|a#45#1#0@@0| T@U) ) (!  (=> (and (= (type |a#45#0#0@@0|) DatatypeTypeType) (= (type |a#45#1#0@@0|) (MapType0Type BoxType boolType))) (= ($Is (|#PagedBetree.Step.InternalFlushStep| |a#45#0#0@@0| |a#45#1#0@@0|) Tclass.PagedBetree.Step)  (and ($Is |a#45#0#0@@0| Tclass.PagedBetree.Path) ($Is |a#45#1#0@@0| (TISet Tclass.KeyType.Key)))))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7549|
 :pattern ( ($Is (|#PagedBetree.Step.InternalFlushStep| |a#45#0#0@@0| |a#45#1#0@@0|) Tclass.PagedBetree.Step))
)))
(assert (forall ((|a#46#0#0@@0| T@U) (|a#46#1#0@@0| T@U) ($h@@223 T@U) ) (!  (=> (and (and (and (= (type |a#46#0#0@@0|) DatatypeTypeType) (= (type |a#46#1#0@@0|) (MapType0Type BoxType boolType))) (= (type $h@@223) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@223)) (= ($IsAlloc (|#PagedBetree.Step.InternalFlushStep| |a#46#0#0@@0| |a#46#1#0@@0|) Tclass.PagedBetree.Step $h@@223)  (and ($IsAlloc |a#46#0#0@@0| Tclass.PagedBetree.Path $h@@223) ($IsAlloc |a#46#1#0@@0| (TISet Tclass.KeyType.Key) $h@@223))))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7550|
 :pattern ( ($IsAlloc (|#PagedBetree.Step.InternalFlushStep| |a#46#0#0@@0| |a#46#1#0@@0|) Tclass.PagedBetree.Step $h@@223))
)))
(assert (forall ((d@@260 T@U) ($h@@224 T@U) ) (!  (=> (and (and (= (type d@@260) DatatypeTypeType) (= (type $h@@224) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@224) (and (PagedBetree.Step.InternalFlushStep_q d@@260) ($IsAlloc d@@260 Tclass.PagedBetree.Step $h@@224)))) ($IsAlloc (PagedBetree.Step.path d@@260) Tclass.PagedBetree.Path $h@@224))
 :qid |unknown.0:0|
 :skolemid |7551|
 :pattern ( ($IsAlloc (PagedBetree.Step.path d@@260) Tclass.PagedBetree.Path $h@@224))
)))
(assert (forall ((arg0@@723 T@U) ) (! (= (type (PagedBetree.Step.downKeys arg0@@723)) (MapType0Type BoxType boolType))
 :qid |funType:PagedBetree.Step.downKeys|
 :pattern ( (PagedBetree.Step.downKeys arg0@@723))
)))
(assert (forall ((d@@261 T@U) ($h@@225 T@U) ) (!  (=> (and (and (= (type d@@261) DatatypeTypeType) (= (type $h@@225) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@225) (and (PagedBetree.Step.InternalFlushStep_q d@@261) ($IsAlloc d@@261 Tclass.PagedBetree.Step $h@@225)))) ($IsAlloc (PagedBetree.Step.downKeys d@@261) (TISet Tclass.KeyType.Key) $h@@225))
 :qid |unknown.0:0|
 :skolemid |7552|
 :pattern ( ($IsAlloc (PagedBetree.Step.downKeys d@@261) (TISet Tclass.KeyType.Key) $h@@225))
)))
(assert (forall ((|a#47#0#0@@0| T@U) (|a#47#1#0@@0| T@U) ) (!  (=> (and (= (type |a#47#0#0@@0|) DatatypeTypeType) (= (type |a#47#1#0@@0|) (MapType0Type BoxType boolType))) (= (|#PagedBetree.Step.InternalFlushStep| (Lit |a#47#0#0@@0|) (Lit |a#47#1#0@@0|)) (Lit (|#PagedBetree.Step.InternalFlushStep| |a#47#0#0@@0| |a#47#1#0@@0|))))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7553|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| (Lit |a#47#0#0@@0|) (Lit |a#47#1#0@@0|)))
)))
(assert (forall ((|a#48#0#0@@0| T@U) (|a#48#1#0@@0| T@U) ) (!  (=> (and (= (type |a#48#0#0@@0|) DatatypeTypeType) (= (type |a#48#1#0@@0|) (MapType0Type BoxType boolType))) (= (PagedBetree.Step.path (|#PagedBetree.Step.InternalFlushStep| |a#48#0#0@@0| |a#48#1#0@@0|)) |a#48#0#0@@0|))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7554|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| |a#48#0#0@@0| |a#48#1#0@@0|))
)))
(assert (forall ((|a#49#0#0@@0| T@U) (|a#49#1#0@@0| T@U) ) (!  (=> (and (= (type |a#49#0#0@@0|) DatatypeTypeType) (= (type |a#49#1#0@@0|) (MapType0Type BoxType boolType))) (< (DtRank |a#49#0#0@@0|) (DtRank (|#PagedBetree.Step.InternalFlushStep| |a#49#0#0@@0| |a#49#1#0@@0|))))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7555|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| |a#49#0#0@@0| |a#49#1#0@@0|))
)))
(assert (forall ((|a#50#0#0@@0| T@U) (|a#50#1#0@@0| T@U) ) (!  (=> (and (= (type |a#50#0#0@@0|) DatatypeTypeType) (= (type |a#50#1#0@@0|) (MapType0Type BoxType boolType))) (= (PagedBetree.Step.downKeys (|#PagedBetree.Step.InternalFlushStep| |a#50#0#0@@0| |a#50#1#0@@0|)) |a#50#1#0@@0|))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7556|
 :pattern ( (|#PagedBetree.Step.InternalFlushStep| |a#50#0#0@@0| |a#50#1#0@@0|))
)))
(assert (forall ((|a#51#0#0@@0| T@U) (|a#51#1#0@@0| T@U) (d@@262 T@U) ) (!  (=> (and (and (and (= (type |a#51#0#0@@0|) DatatypeTypeType) (= (type |a#51#1#0@@0|) (MapType0Type BoxType boolType))) (= (type d@@262) DatatypeTypeType)) (U_2_bool (MapType0Select |a#51#1#0@@0| ($Box d@@262)))) (< (DtRank d@@262) (DtRank (|#PagedBetree.Step.InternalFlushStep| |a#51#0#0@@0| |a#51#1#0@@0|))))
 :qid |PagedBetreeidfy.438:25|
 :skolemid |7557|
 :pattern ( (MapType0Select |a#51#1#0@@0| ($Box d@@262)) (|#PagedBetree.Step.InternalFlushStep| |a#51#0#0@@0| |a#51#1#0@@0|))
)))
(assert (forall ((|a#52#0#0@@1| T@U) (|a#52#1#0@@1| T@U) ) (!  (=> (and (= (type |a#52#0#0@@1|) DatatypeTypeType) (= (type |a#52#1#0@@1|) DatatypeTypeType)) (= (DatatypeCtorId (|#PagedBetree.Step.InternalCompactStep| |a#52#0#0@@1| |a#52#1#0@@1|)) |##PagedBetree.Step.InternalCompactStep|))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7558|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| |a#52#0#0@@1| |a#52#1#0@@1|))
)))
(assert (forall ((d@@263 T@U) ) (!  (=> (= (type d@@263) DatatypeTypeType) (= (PagedBetree.Step.InternalCompactStep_q d@@263) (= (DatatypeCtorId d@@263) |##PagedBetree.Step.InternalCompactStep|)))
 :qid |unknown.0:0|
 :skolemid |7559|
 :pattern ( (PagedBetree.Step.InternalCompactStep_q d@@263))
)))
(assert (forall ((d@@264 T@U) ) (!  (=> (and (= (type d@@264) DatatypeTypeType) (PagedBetree.Step.InternalCompactStep_q d@@264)) (exists ((|a#53#0#0@@1| T@U) (|a#53#1#0@@1| T@U) ) (!  (and (and (= (type |a#53#0#0@@1|) DatatypeTypeType) (= (type |a#53#1#0@@1|) DatatypeTypeType)) (= d@@264 (|#PagedBetree.Step.InternalCompactStep| |a#53#0#0@@1| |a#53#1#0@@1|)))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7560|
 :no-pattern (type |a#53#0#0@@1|)
 :no-pattern (type |a#53#1#0@@1|)
 :no-pattern (U_2_int |a#53#0#0@@1|)
 :no-pattern (U_2_bool |a#53#0#0@@1|)
 :no-pattern (U_2_int |a#53#1#0@@1|)
 :no-pattern (U_2_bool |a#53#1#0@@1|)
)))
 :qid |unknown.0:0|
 :skolemid |7561|
 :pattern ( (PagedBetree.Step.InternalCompactStep_q d@@264))
)))
(assert (forall ((|a#54#0#0@@1| T@U) (|a#54#1#0@@1| T@U) ) (!  (=> (and (= (type |a#54#0#0@@1|) DatatypeTypeType) (= (type |a#54#1#0@@1|) DatatypeTypeType)) (= ($Is (|#PagedBetree.Step.InternalCompactStep| |a#54#0#0@@1| |a#54#1#0@@1|) Tclass.PagedBetree.Step)  (and ($Is |a#54#0#0@@1| Tclass.PagedBetree.Path) ($Is |a#54#1#0@@1| Tclass.Buffers.BufferStack))))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7562|
 :pattern ( ($Is (|#PagedBetree.Step.InternalCompactStep| |a#54#0#0@@1| |a#54#1#0@@1|) Tclass.PagedBetree.Step))
)))
(assert (forall ((|a#55#0#0@@1| T@U) (|a#55#1#0@@1| T@U) ($h@@226 T@U) ) (!  (=> (and (and (and (= (type |a#55#0#0@@1|) DatatypeTypeType) (= (type |a#55#1#0@@1|) DatatypeTypeType)) (= (type $h@@226) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@226)) (= ($IsAlloc (|#PagedBetree.Step.InternalCompactStep| |a#55#0#0@@1| |a#55#1#0@@1|) Tclass.PagedBetree.Step $h@@226)  (and ($IsAlloc |a#55#0#0@@1| Tclass.PagedBetree.Path $h@@226) ($IsAlloc |a#55#1#0@@1| Tclass.Buffers.BufferStack $h@@226))))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7563|
 :pattern ( ($IsAlloc (|#PagedBetree.Step.InternalCompactStep| |a#55#0#0@@1| |a#55#1#0@@1|) Tclass.PagedBetree.Step $h@@226))
)))
(assert (forall ((d@@265 T@U) ($h@@227 T@U) ) (!  (=> (and (and (= (type d@@265) DatatypeTypeType) (= (type $h@@227) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@227) (and (PagedBetree.Step.InternalCompactStep_q d@@265) ($IsAlloc d@@265 Tclass.PagedBetree.Step $h@@227)))) ($IsAlloc (PagedBetree.Step.path d@@265) Tclass.PagedBetree.Path $h@@227))
 :qid |unknown.0:0|
 :skolemid |7564|
 :pattern ( ($IsAlloc (PagedBetree.Step.path d@@265) Tclass.PagedBetree.Path $h@@227))
)))
(assert (forall ((arg0@@724 T@U) ) (! (= (type (PagedBetree.Step.compactedBuffers arg0@@724)) DatatypeTypeType)
 :qid |funType:PagedBetree.Step.compactedBuffers|
 :pattern ( (PagedBetree.Step.compactedBuffers arg0@@724))
)))
(assert (forall ((d@@266 T@U) ($h@@228 T@U) ) (!  (=> (and (and (= (type d@@266) DatatypeTypeType) (= (type $h@@228) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@228) (and (PagedBetree.Step.InternalCompactStep_q d@@266) ($IsAlloc d@@266 Tclass.PagedBetree.Step $h@@228)))) ($IsAlloc (PagedBetree.Step.compactedBuffers d@@266) Tclass.Buffers.BufferStack $h@@228))
 :qid |unknown.0:0|
 :skolemid |7565|
 :pattern ( ($IsAlloc (PagedBetree.Step.compactedBuffers d@@266) Tclass.Buffers.BufferStack $h@@228))
)))
(assert (forall ((|a#56#0#0@@1| T@U) (|a#56#1#0@@1| T@U) ) (!  (=> (and (= (type |a#56#0#0@@1|) DatatypeTypeType) (= (type |a#56#1#0@@1|) DatatypeTypeType)) (= (|#PagedBetree.Step.InternalCompactStep| (Lit |a#56#0#0@@1|) (Lit |a#56#1#0@@1|)) (Lit (|#PagedBetree.Step.InternalCompactStep| |a#56#0#0@@1| |a#56#1#0@@1|))))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7566|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| (Lit |a#56#0#0@@1|) (Lit |a#56#1#0@@1|)))
)))
(assert (forall ((|a#57#0#0@@1| T@U) (|a#57#1#0@@1| T@U) ) (!  (=> (and (= (type |a#57#0#0@@1|) DatatypeTypeType) (= (type |a#57#1#0@@1|) DatatypeTypeType)) (= (PagedBetree.Step.path (|#PagedBetree.Step.InternalCompactStep| |a#57#0#0@@1| |a#57#1#0@@1|)) |a#57#0#0@@1|))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7567|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| |a#57#0#0@@1| |a#57#1#0@@1|))
)))
(assert (forall ((|a#58#0#0@@0| T@U) (|a#58#1#0@@0| T@U) ) (!  (=> (and (= (type |a#58#0#0@@0|) DatatypeTypeType) (= (type |a#58#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#58#0#0@@0|) (DtRank (|#PagedBetree.Step.InternalCompactStep| |a#58#0#0@@0| |a#58#1#0@@0|))))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7568|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| |a#58#0#0@@0| |a#58#1#0@@0|))
)))
(assert (forall ((|a#59#0#0@@0| T@U) (|a#59#1#0@@0| T@U) ) (!  (=> (and (= (type |a#59#0#0@@0|) DatatypeTypeType) (= (type |a#59#1#0@@0|) DatatypeTypeType)) (= (PagedBetree.Step.compactedBuffers (|#PagedBetree.Step.InternalCompactStep| |a#59#0#0@@0| |a#59#1#0@@0|)) |a#59#1#0@@0|))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7569|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| |a#59#0#0@@0| |a#59#1#0@@0|))
)))
(assert (forall ((|a#60#0#0@@0| T@U) (|a#60#1#0@@0| T@U) ) (!  (=> (and (= (type |a#60#0#0@@0|) DatatypeTypeType) (= (type |a#60#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#60#1#0@@0|) (DtRank (|#PagedBetree.Step.InternalCompactStep| |a#60#0#0@@0| |a#60#1#0@@0|))))
 :qid |PagedBetreeidfy.439:27|
 :skolemid |7570|
 :pattern ( (|#PagedBetree.Step.InternalCompactStep| |a#60#0#0@@0| |a#60#1#0@@0|))
)))
(assert (= (DatatypeCtorId |#PagedBetree.Step.InternalNoOpStep|) |##PagedBetree.Step.InternalNoOpStep|))
(assert (forall ((d@@267 T@U) ) (!  (=> (= (type d@@267) DatatypeTypeType) (= (PagedBetree.Step.InternalNoOpStep_q d@@267) (= (DatatypeCtorId d@@267) |##PagedBetree.Step.InternalNoOpStep|)))
 :qid |unknown.0:0|
 :skolemid |7571|
 :pattern ( (PagedBetree.Step.InternalNoOpStep_q d@@267))
)))
(assert (forall ((d@@268 T@U) ) (!  (=> (and (= (type d@@268) DatatypeTypeType) (PagedBetree.Step.InternalNoOpStep_q d@@268)) (= d@@268 |#PagedBetree.Step.InternalNoOpStep|))
 :qid |unknown.0:0|
 :skolemid |7572|
 :pattern ( (PagedBetree.Step.InternalNoOpStep_q d@@268))
)))
(assert ($Is |#PagedBetree.Step.InternalNoOpStep| Tclass.PagedBetree.Step))
(assert (forall (($h@@229 T@U) ) (!  (=> (and (= (type $h@@229) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@229)) ($IsAlloc |#PagedBetree.Step.InternalNoOpStep| Tclass.PagedBetree.Step $h@@229))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7573|
 :pattern ( ($IsAlloc |#PagedBetree.Step.InternalNoOpStep| Tclass.PagedBetree.Step $h@@229))
)))
(assert (= |#PagedBetree.Step.InternalNoOpStep| (Lit |#PagedBetree.Step.InternalNoOpStep|)))
(assert (forall ((d@@269 T@U) ) (!  (=> (and (= (type d@@269) DatatypeTypeType) (|$IsA#PagedBetree.Step| d@@269)) (or (or (or (or (or (or (or (or (or (PagedBetree.Step.QueryStep_q d@@269) (PagedBetree.Step.PutStep_q d@@269)) (PagedBetree.Step.QueryEndLsnStep_q d@@269)) (PagedBetree.Step.FreezeAsStep_q d@@269)) (PagedBetree.Step.InternalGrowStep_q d@@269)) (PagedBetree.Step.InternalSplitStep_q d@@269)) (PagedBetree.Step.InternalFlushMemtableStep_q d@@269)) (PagedBetree.Step.InternalFlushStep_q d@@269)) (PagedBetree.Step.InternalCompactStep_q d@@269)) (PagedBetree.Step.InternalNoOpStep_q d@@269)))
 :qid |unknown.0:0|
 :skolemid |7574|
 :pattern ( (|$IsA#PagedBetree.Step| d@@269))
)))
(assert (forall ((d@@270 T@U) ) (!  (=> (and (= (type d@@270) DatatypeTypeType) ($Is d@@270 Tclass.PagedBetree.Step)) (or (or (or (or (or (or (or (or (or (PagedBetree.Step.QueryStep_q d@@270) (PagedBetree.Step.PutStep_q d@@270)) (PagedBetree.Step.QueryEndLsnStep_q d@@270)) (PagedBetree.Step.FreezeAsStep_q d@@270)) (PagedBetree.Step.InternalGrowStep_q d@@270)) (PagedBetree.Step.InternalSplitStep_q d@@270)) (PagedBetree.Step.InternalFlushMemtableStep_q d@@270)) (PagedBetree.Step.InternalFlushStep_q d@@270)) (PagedBetree.Step.InternalCompactStep_q d@@270)) (PagedBetree.Step.InternalNoOpStep_q d@@270)))
 :qid |unknown.0:0|
 :skolemid |7575|
 :pattern ( (PagedBetree.Step.InternalNoOpStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.InternalCompactStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.InternalFlushStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.InternalFlushMemtableStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.InternalSplitStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.InternalGrowStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.FreezeAsStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.QueryEndLsnStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.PutStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
 :pattern ( (PagedBetree.Step.QueryStep_q d@@270) ($Is d@@270 Tclass.PagedBetree.Step))
)))
(assert (forall ((a@@195 T@U) (b@@144 T@U) ) (!  (=> (and (and (= (type a@@195) DatatypeTypeType) (= (type b@@144) DatatypeTypeType)) (and (PagedBetree.Step.QueryStep_q a@@195) (PagedBetree.Step.QueryStep_q b@@144))) (= (|PagedBetree.Step#Equal| a@@195 b@@144) (|PagedBetree.QueryReceipt#Equal| (PagedBetree.Step.receipt a@@195) (PagedBetree.Step.receipt b@@144))))
 :qid |unknown.0:0|
 :skolemid |7576|
 :pattern ( (|PagedBetree.Step#Equal| a@@195 b@@144) (PagedBetree.Step.QueryStep_q a@@195))
 :pattern ( (|PagedBetree.Step#Equal| a@@195 b@@144) (PagedBetree.Step.QueryStep_q b@@144))
)))
(assert (forall ((a@@196 T@U) (b@@145 T@U) ) (!  (=> (and (and (= (type a@@196) DatatypeTypeType) (= (type b@@145) DatatypeTypeType)) (and (PagedBetree.Step.PutStep_q a@@196) (PagedBetree.Step.PutStep_q b@@145))) (= (|PagedBetree.Step#Equal| a@@196 b@@145) true))
 :qid |unknown.0:0|
 :skolemid |7577|
 :pattern ( (|PagedBetree.Step#Equal| a@@196 b@@145) (PagedBetree.Step.PutStep_q a@@196))
 :pattern ( (|PagedBetree.Step#Equal| a@@196 b@@145) (PagedBetree.Step.PutStep_q b@@145))
)))
(assert (forall ((a@@197 T@U) (b@@146 T@U) ) (!  (=> (and (and (= (type a@@197) DatatypeTypeType) (= (type b@@146) DatatypeTypeType)) (and (PagedBetree.Step.QueryEndLsnStep_q a@@197) (PagedBetree.Step.QueryEndLsnStep_q b@@146))) (= (|PagedBetree.Step#Equal| a@@197 b@@146) true))
 :qid |unknown.0:0|
 :skolemid |7578|
 :pattern ( (|PagedBetree.Step#Equal| a@@197 b@@146) (PagedBetree.Step.QueryEndLsnStep_q a@@197))
 :pattern ( (|PagedBetree.Step#Equal| a@@197 b@@146) (PagedBetree.Step.QueryEndLsnStep_q b@@146))
)))
(assert (forall ((a@@198 T@U) (b@@147 T@U) ) (!  (=> (and (and (= (type a@@198) DatatypeTypeType) (= (type b@@147) DatatypeTypeType)) (and (PagedBetree.Step.FreezeAsStep_q a@@198) (PagedBetree.Step.FreezeAsStep_q b@@147))) (= (|PagedBetree.Step#Equal| a@@198 b@@147) true))
 :qid |unknown.0:0|
 :skolemid |7579|
 :pattern ( (|PagedBetree.Step#Equal| a@@198 b@@147) (PagedBetree.Step.FreezeAsStep_q a@@198))
 :pattern ( (|PagedBetree.Step#Equal| a@@198 b@@147) (PagedBetree.Step.FreezeAsStep_q b@@147))
)))
(assert (forall ((a@@199 T@U) (b@@148 T@U) ) (!  (=> (and (and (= (type a@@199) DatatypeTypeType) (= (type b@@148) DatatypeTypeType)) (and (PagedBetree.Step.InternalGrowStep_q a@@199) (PagedBetree.Step.InternalGrowStep_q b@@148))) (= (|PagedBetree.Step#Equal| a@@199 b@@148) true))
 :qid |unknown.0:0|
 :skolemid |7580|
 :pattern ( (|PagedBetree.Step#Equal| a@@199 b@@148) (PagedBetree.Step.InternalGrowStep_q a@@199))
 :pattern ( (|PagedBetree.Step#Equal| a@@199 b@@148) (PagedBetree.Step.InternalGrowStep_q b@@148))
)))
(assert (forall ((a@@200 T@U) (b@@149 T@U) ) (!  (=> (and (and (= (type a@@200) DatatypeTypeType) (= (type b@@149) DatatypeTypeType)) (and (PagedBetree.Step.InternalSplitStep_q a@@200) (PagedBetree.Step.InternalSplitStep_q b@@149))) (= (|PagedBetree.Step#Equal| a@@200 b@@149)  (and (and (|PagedBetree.Path#Equal| (PagedBetree.Step.path a@@200) (PagedBetree.Step.path b@@149)) (|ISet#Equal| (PagedBetree.Step.leftKeys a@@200) (PagedBetree.Step.leftKeys b@@149))) (|ISet#Equal| (PagedBetree.Step.rightKeys a@@200) (PagedBetree.Step.rightKeys b@@149)))))
 :qid |unknown.0:0|
 :skolemid |7581|
 :pattern ( (|PagedBetree.Step#Equal| a@@200 b@@149) (PagedBetree.Step.InternalSplitStep_q a@@200))
 :pattern ( (|PagedBetree.Step#Equal| a@@200 b@@149) (PagedBetree.Step.InternalSplitStep_q b@@149))
)))
(assert (forall ((a@@201 T@U) (b@@150 T@U) ) (!  (=> (and (and (= (type a@@201) DatatypeTypeType) (= (type b@@150) DatatypeTypeType)) (and (PagedBetree.Step.InternalFlushMemtableStep_q a@@201) (PagedBetree.Step.InternalFlushMemtableStep_q b@@150))) (= (|PagedBetree.Step#Equal| a@@201 b@@150) true))
 :qid |unknown.0:0|
 :skolemid |7582|
 :pattern ( (|PagedBetree.Step#Equal| a@@201 b@@150) (PagedBetree.Step.InternalFlushMemtableStep_q a@@201))
 :pattern ( (|PagedBetree.Step#Equal| a@@201 b@@150) (PagedBetree.Step.InternalFlushMemtableStep_q b@@150))
)))
(assert (forall ((a@@202 T@U) (b@@151 T@U) ) (!  (=> (and (and (= (type a@@202) DatatypeTypeType) (= (type b@@151) DatatypeTypeType)) (and (PagedBetree.Step.InternalFlushStep_q a@@202) (PagedBetree.Step.InternalFlushStep_q b@@151))) (= (|PagedBetree.Step#Equal| a@@202 b@@151)  (and (|PagedBetree.Path#Equal| (PagedBetree.Step.path a@@202) (PagedBetree.Step.path b@@151)) (|ISet#Equal| (PagedBetree.Step.downKeys a@@202) (PagedBetree.Step.downKeys b@@151)))))
 :qid |unknown.0:0|
 :skolemid |7583|
 :pattern ( (|PagedBetree.Step#Equal| a@@202 b@@151) (PagedBetree.Step.InternalFlushStep_q a@@202))
 :pattern ( (|PagedBetree.Step#Equal| a@@202 b@@151) (PagedBetree.Step.InternalFlushStep_q b@@151))
)))
(assert (forall ((a@@203 T@U) (b@@152 T@U) ) (!  (=> (and (and (= (type a@@203) DatatypeTypeType) (= (type b@@152) DatatypeTypeType)) (and (PagedBetree.Step.InternalCompactStep_q a@@203) (PagedBetree.Step.InternalCompactStep_q b@@152))) (= (|PagedBetree.Step#Equal| a@@203 b@@152)  (and (|PagedBetree.Path#Equal| (PagedBetree.Step.path a@@203) (PagedBetree.Step.path b@@152)) (|Buffers.BufferStack#Equal| (PagedBetree.Step.compactedBuffers a@@203) (PagedBetree.Step.compactedBuffers b@@152)))))
 :qid |unknown.0:0|
 :skolemid |7584|
 :pattern ( (|PagedBetree.Step#Equal| a@@203 b@@152) (PagedBetree.Step.InternalCompactStep_q a@@203))
 :pattern ( (|PagedBetree.Step#Equal| a@@203 b@@152) (PagedBetree.Step.InternalCompactStep_q b@@152))
)))
(assert (forall ((a@@204 T@U) (b@@153 T@U) ) (!  (=> (and (and (= (type a@@204) DatatypeTypeType) (= (type b@@153) DatatypeTypeType)) (and (PagedBetree.Step.InternalNoOpStep_q a@@204) (PagedBetree.Step.InternalNoOpStep_q b@@153))) (= (|PagedBetree.Step#Equal| a@@204 b@@153) true))
 :qid |unknown.0:0|
 :skolemid |7585|
 :pattern ( (|PagedBetree.Step#Equal| a@@204 b@@153) (PagedBetree.Step.InternalNoOpStep_q a@@204))
 :pattern ( (|PagedBetree.Step#Equal| a@@204 b@@153) (PagedBetree.Step.InternalNoOpStep_q b@@153))
)))
(assert (forall ((a@@205 T@U) (b@@154 T@U) ) (!  (=> (and (= (type a@@205) DatatypeTypeType) (= (type b@@154) DatatypeTypeType)) (= (|PagedBetree.Step#Equal| a@@205 b@@154) (= a@@205 b@@154)))
 :qid |unknown.0:0|
 :skolemid |7586|
 :pattern ( (|PagedBetree.Step#Equal| a@@205 b@@154))
)))
(assert  (=> true (forall ((this@@446 T@U) ) (!  (=> (and (= (type this@@446) DatatypeTypeType) (or (|PagedBetree.Step.WF#canCall| this@@446) ($Is this@@446 Tclass.PagedBetree.Step))) true)
 :qid |PagedBetreeidfy.442:15|
 :skolemid |7587|
 :pattern ( (PagedBetree.Step.WF this@@446))
))))
(assert (forall ((this@@447 T@U) ) (!  (=> (and (= (type this@@447) DatatypeTypeType) ($Is this@@447 Tclass.PagedBetree.Step)) (= (|PagedBetree.Step.WF#requires| this@@447) true))
 :qid |PagedBetreeidfy.442:15|
 :skolemid |7588|
 :pattern ( (|PagedBetree.Step.WF#requires| this@@447))
)))
(assert  (=> true (forall ((this@@448 T@U) ) (!  (=> (and (= (type this@@448) DatatypeTypeType) (or (|PagedBetree.Step.WF#canCall| this@@448) ($Is this@@448 Tclass.PagedBetree.Step))) (and (=> (not (PagedBetree.Step.QueryStep_q this@@448)) (=> (not (PagedBetree.Step.PutStep_q this@@448)) (=> (not (PagedBetree.Step.QueryEndLsnStep_q this@@448)) (=> (not (PagedBetree.Step.FreezeAsStep_q this@@448)) (=> (not (PagedBetree.Step.InternalGrowStep_q this@@448)) (and (=> (PagedBetree.Step.InternalSplitStep_q this@@448) (let ((|path#3@@1| (PagedBetree.Step.path this@@448)))
(|PagedBetree.Path.Valid#canCall| |path#3@@1|))) (=> (not (PagedBetree.Step.InternalSplitStep_q this@@448)) (=> (not (PagedBetree.Step.InternalFlushMemtableStep_q this@@448)) (and (=> (PagedBetree.Step.InternalFlushStep_q this@@448) (let ((|path#4@@1| (PagedBetree.Step.path this@@448)))
(|PagedBetree.Path.Valid#canCall| |path#4@@1|))) (=> (not (PagedBetree.Step.InternalFlushStep_q this@@448)) (=> (PagedBetree.Step.InternalCompactStep_q this@@448) (let ((|compactedBuffers#1@@0| (PagedBetree.Step.compactedBuffers this@@448)))
(let ((|path#5@@1| (PagedBetree.Step.path this@@448)))
 (and (|PagedBetree.Path.Valid#canCall| |path#5@@1|) (=> (PagedBetree.Path.Valid ($LS $LZ) |path#5@@1|) (and (|PagedBetree.Path.Target#canCall| |path#5@@1|) (=> (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.Target ($LS $LZ) |path#5@@1|)) (and (|PagedBetree.Path.Target#canCall| |path#5@@1|) (|Buffers.BufferStack.Equivalent#canCall| (PagedBetree.BetreeNode.buffers (PagedBetree.Path.Target ($LS $LZ) |path#5@@1|)) |compactedBuffers#1@@0|))))))))))))))))))) (= (PagedBetree.Step.WF this@@448) (ite (PagedBetree.Step.QueryStep_q this@@448) true (ite (PagedBetree.Step.PutStep_q this@@448) true (ite (PagedBetree.Step.QueryEndLsnStep_q this@@448) true (ite (PagedBetree.Step.FreezeAsStep_q this@@448) true (ite (PagedBetree.Step.InternalGrowStep_q this@@448) true (ite (PagedBetree.Step.InternalSplitStep_q this@@448) (let ((|path#0@@11| (PagedBetree.Step.path this@@448)))
(PagedBetree.Path.Valid ($LS $LZ) |path#0@@11|)) (ite (PagedBetree.Step.InternalFlushMemtableStep_q this@@448) true (ite (PagedBetree.Step.InternalFlushStep_q this@@448) (let ((|path#1@@1| (PagedBetree.Step.path this@@448)))
(PagedBetree.Path.Valid ($LS $LZ) |path#1@@1|)) (ite (PagedBetree.Step.InternalCompactStep_q this@@448) (let ((|compactedBuffers#0@@1| (PagedBetree.Step.compactedBuffers this@@448)))
(let ((|path#2@@1| (PagedBetree.Step.path this@@448)))
 (and (and (PagedBetree.Path.Valid ($LS $LZ) |path#2@@1|) (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.Target ($LS $LZ) |path#2@@1|))) (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers (PagedBetree.Path.Target ($LS $LZ) |path#2@@1|)) |compactedBuffers#0@@1|)))) true))))))))))))
 :qid |PagedBetreeidfy.442:15|
 :skolemid |7589|
 :pattern ( (PagedBetree.Step.WF this@@448))
))))
(assert  (=> true (forall ((this@@449 T@U) ) (!  (=> (and (= (type this@@449) DatatypeTypeType) (or (|PagedBetree.Step.WF#canCall| (Lit this@@449)) ($Is this@@449 Tclass.PagedBetree.Step))) (and (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryStep_q (Lit this@@449)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.PutStep_q (Lit this@@449)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryEndLsnStep_q (Lit this@@449)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.FreezeAsStep_q (Lit this@@449)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalGrowStep_q (Lit this@@449)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q (Lit this@@449))))) (let ((|path#9@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
(|PagedBetree.Path.Valid#canCall| |path#9@@1|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q (Lit this@@449)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushMemtableStep_q (Lit this@@449)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q (Lit this@@449))))) (let ((|path#10@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
(|PagedBetree.Path.Valid#canCall| |path#10@@1|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q (Lit this@@449)))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalCompactStep_q (Lit this@@449))))) (let ((|compactedBuffers#3@@0| (Lit (PagedBetree.Step.compactedBuffers (Lit this@@449)))))
(let ((|path#11@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
 (and (|PagedBetree.Path.Valid#canCall| |path#11@@1|) (=> (PagedBetree.Path.Valid ($LS $LZ) |path#11@@1|) (and (|PagedBetree.Path.Target#canCall| |path#11@@1|) (=> (PagedBetree.BetreeNode.BetreeNode_q (PagedBetree.Path.Target ($LS $LZ) |path#11@@1|)) (and (|PagedBetree.Path.Target#canCall| |path#11@@1|) (|Buffers.BufferStack.Equivalent#canCall| (PagedBetree.BetreeNode.buffers (PagedBetree.Path.Target ($LS $LZ) |path#11@@1|)) |compactedBuffers#3@@0|))))))))))))))))))) (= (PagedBetree.Step.WF (Lit this@@449)) (ite (PagedBetree.Step.QueryStep_q (Lit this@@449)) true (ite (PagedBetree.Step.PutStep_q (Lit this@@449)) true (ite (PagedBetree.Step.QueryEndLsnStep_q (Lit this@@449)) true (ite (PagedBetree.Step.FreezeAsStep_q (Lit this@@449)) true (ite (PagedBetree.Step.InternalGrowStep_q (Lit this@@449)) true (ite (PagedBetree.Step.InternalSplitStep_q (Lit this@@449)) (U_2_bool (let ((|path#6@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
(Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) |path#6@@1|))))) (ite (PagedBetree.Step.InternalFlushMemtableStep_q (Lit this@@449)) true (ite (PagedBetree.Step.InternalFlushStep_q (Lit this@@449)) (U_2_bool (let ((|path#7@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
(Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) |path#7@@1|))))) (ite (PagedBetree.Step.InternalCompactStep_q (Lit this@@449)) (U_2_bool (let ((|compactedBuffers#2@@1| (Lit (PagedBetree.Step.compactedBuffers (Lit this@@449)))))
(let ((|path#8@@1| (Lit (PagedBetree.Step.path (Lit this@@449)))))
(Lit (bool_2_U  (and (and (PagedBetree.Path.Valid ($LS $LZ) |path#8@@1|) (PagedBetree.BetreeNode.BetreeNode_q (Lit (PagedBetree.Path.Target ($LS $LZ) |path#8@@1|)))) (Buffers.BufferStack.Equivalent (Lit (PagedBetree.BetreeNode.buffers (Lit (PagedBetree.Path.Target ($LS $LZ) |path#8@@1|)))) |compactedBuffers#2@@1|))))))) true))))))))))))
 :qid |PagedBetreeidfy.442:15|
 :weight 3
 :skolemid |7590|
 :pattern ( (PagedBetree.Step.WF (Lit this@@449)))
))))
(assert (= (type Tclass.PagedBetree.__default) TyType))
(assert (= (Tag Tclass.PagedBetree.__default) Tagclass.PagedBetree.__default))
(assert (= (TagFamily Tclass.PagedBetree.__default) tytagFamily$_default))
(assert (forall ((bx@@182 T@U) ) (!  (=> (and (= (type bx@@182) BoxType) ($IsBox bx@@182 Tclass.PagedBetree.__default)) (and (= ($Box ($Unbox refType bx@@182)) bx@@182) ($Is ($Unbox refType bx@@182) Tclass.PagedBetree.__default)))
 :qid |unknown.0:0|
 :skolemid |7591|
 :pattern ( ($IsBox bx@@182 Tclass.PagedBetree.__default))
)))
(assert (forall (($o@@73 T@U) ) (!  (=> (= (type $o@@73) refType) (= ($Is $o@@73 Tclass.PagedBetree.__default)  (or (= $o@@73 null) (= (dtype $o@@73) Tclass.PagedBetree.__default))))
 :qid |unknown.0:0|
 :skolemid |7592|
 :pattern ( ($Is $o@@73 Tclass.PagedBetree.__default))
)))
(assert (forall (($o@@74 T@U) ($h@@230 T@U) ) (!  (=> (and (= (type $o@@74) refType) (= (type $h@@230) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@74 Tclass.PagedBetree.__default $h@@230)  (or (= $o@@74 null) (U_2_bool (MapType1Select (MapType0Select $h@@230 $o@@74) alloc)))))
 :qid |unknown.0:0|
 :skolemid |7593|
 :pattern ( ($IsAlloc $o@@74 Tclass.PagedBetree.__default $h@@230))
)))
(assert  (=> true (=> true ($Is PagedBetree.__default.EmptyImage (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))))
(assert (= |PagedBetree.__default.EmptyImage#requires| true))
(assert  (=> true (=> true (= PagedBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PagedBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert  (=> true (=> true (= PagedBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PagedBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert (forall ((arg0@@725 T@U) ) (! (= (type (PagedBetree.__default.ConstantChildMap arg0@@725)) DatatypeTypeType)
 :qid |funType:PagedBetree.__default.ConstantChildMap|
 :pattern ( (PagedBetree.__default.ConstantChildMap arg0@@725))
)))
(assert  (=> true (forall ((|target#0| T@U) ) (!  (=> (and (= (type |target#0|) DatatypeTypeType) (or (|PagedBetree.__default.ConstantChildMap#canCall| |target#0|) (and ($Is |target#0| Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) |target#0|)))) (and (PagedBetree.ChildMap.WF ($LS $LZ) (PagedBetree.__default.ConstantChildMap |target#0|)) ($Is (PagedBetree.__default.ConstantChildMap |target#0|) Tclass.PagedBetree.ChildMap)))
 :qid |PagedBetreeidfy.55:29|
 :skolemid |7594|
 :pattern ( (PagedBetree.__default.ConstantChildMap |target#0|))
))))
(assert (forall ((|target#0@@0| T@U) ) (!  (=> (and (= (type |target#0@@0|) DatatypeTypeType) ($Is |target#0@@0| Tclass.PagedBetree.BetreeNode)) (= (|PagedBetree.__default.ConstantChildMap#requires| |target#0@@0|) (PagedBetree.BetreeNode.WF ($LS $LZ) |target#0@@0|)))
 :qid |PagedBetreeidfy.55:29|
 :skolemid |7595|
 :pattern ( (|PagedBetree.__default.ConstantChildMap#requires| |target#0@@0|))
)))
(assert  (=> true (forall ((|target#0@@1| T@U) ) (!  (=> (and (= (type |target#0@@1|) DatatypeTypeType) (or (|PagedBetree.__default.ConstantChildMap#canCall| |target#0@@1|) (and ($Is |target#0@@1| Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) |target#0@@1|)))) (and (forall ((|key#0@@248| T@U) ) (!  (=> (and (= (type |key#0@@248|) (SeqType BoxType)) ($Is |key#0@@248| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |key#0@@248|))
 :qid |PagedBetreeidfy.59:22|
 :skolemid |7596|
 :pattern ( (Buffers.__default.AnyKey |key#0@@248|))
)) (= (PagedBetree.__default.ConstantChildMap |target#0@@1|) (let ((|mapp#0@@0| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#150| ($Box |target#0@@1|)) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
(|#PagedBetree.ChildMap.ChildMap| |mapp#0@@0|)))))
 :qid |PagedBetreeidfy.55:29|
 :skolemid |7597|
 :pattern ( (PagedBetree.__default.ConstantChildMap |target#0@@1|))
))))
(assert  (=> true (forall ((|target#0@@2| T@U) ) (!  (=> (and (= (type |target#0@@2|) DatatypeTypeType) (or (|PagedBetree.__default.ConstantChildMap#canCall| (Lit |target#0@@2|)) (and ($Is |target#0@@2| Tclass.PagedBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |target#0@@2|)))))))) (and (forall ((|key#0@@249| T@U) ) (!  (=> (and (= (type |key#0@@249|) (SeqType BoxType)) ($Is |key#0@@249| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |key#0@@249|))
 :qid |PagedBetreeidfy.59:22|
 :skolemid |7598|
 :pattern ( (Buffers.__default.AnyKey |key#0@@249|))
)) (= (PagedBetree.__default.ConstantChildMap (Lit |target#0@@2|)) (let ((|mapp#1@@0| (|IMap#Glue| (|lambda#0| Tclass.KeyType.Key) (|lambda#150| ($Box (Lit |target#0@@2|))) (TIMap Tclass.KeyType.Key Tclass.PagedBetree.BetreeNode))))
(|#PagedBetree.ChildMap.ChildMap| |mapp#1@@0|)))))
 :qid |PagedBetreeidfy.55:29|
 :weight 3
 :skolemid |7599|
 :pattern ( (PagedBetree.__default.ConstantChildMap (Lit |target#0@@2|)))
))))
(assert (= (type PagedBetree.__default.EmptyChildMap) DatatypeTypeType))
(assert  (=> true (=> true ($Is PagedBetree.__default.EmptyChildMap Tclass.PagedBetree.ChildMap))))
(assert (= |PagedBetree.__default.EmptyChildMap#requires| true))
(assert  (=> true (=> true (and (|PagedBetree.__default.ConstantChildMap#canCall| (Lit |#PagedBetree.BetreeNode.Nil|)) (= PagedBetree.__default.EmptyChildMap (Lit (PagedBetree.__default.ConstantChildMap (Lit |#PagedBetree.BetreeNode.Nil|))))))))
(assert  (=> true (=> true (and (|PagedBetree.__default.ConstantChildMap#canCall| (Lit |#PagedBetree.BetreeNode.Nil|)) (= PagedBetree.__default.EmptyChildMap (Lit (PagedBetree.__default.ConstantChildMap (Lit |#PagedBetree.BetreeNode.Nil|))))))))
(assert  (=> true (=> true (and (PagedBetree.BetreeNode.WF ($LS $LZ) PagedBetree.__default.EmptyRoot) ($Is PagedBetree.__default.EmptyRoot Tclass.PagedBetree.BetreeNode)))))
(assert (= |PagedBetree.__default.EmptyRoot#requires| true))
(assert  (=> true (=> true (and (|PagedBetree.__default.ConstantChildMap#canCall| (Lit |#PagedBetree.BetreeNode.Nil|)) (= PagedBetree.__default.EmptyRoot (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (Lit (PagedBetree.__default.ConstantChildMap (Lit |#PagedBetree.BetreeNode.Nil|))))))))))
(assert  (=> true (=> true (and (|PagedBetree.__default.ConstantChildMap#canCall| (Lit |#PagedBetree.BetreeNode.Nil|)) (= PagedBetree.__default.EmptyRoot (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (Lit (PagedBetree.__default.ConstantChildMap (Lit |#PagedBetree.BetreeNode.Nil|))))))))))
(assert  (=> true (forall ((|v#0@@92| T@U) (|v'#0@@47| T@U) (|lbl#0@@51| T@U) (|receipt#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@92|) DatatypeTypeType) (= (type |v'#0@@47|) DatatypeTypeType)) (= (type |lbl#0@@51|) DatatypeTypeType)) (= (type |receipt#0@@10|) DatatypeTypeType)) (or (|PagedBetree.__default.Query#canCall| |v#0@@92| |v'#0@@47| |lbl#0@@51| |receipt#0@@10|) (and (and (and ($Is |v#0@@92| Tclass.PagedBetree.Variables) ($Is |v'#0@@47| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@51| Tclass.PagedBetree.TransitionLabel)) ($Is |receipt#0@@10| Tclass.PagedBetree.QueryReceipt)))) true)
 :qid |PagedBetreeidfy.253:19|
 :skolemid |7600|
 :pattern ( (PagedBetree.__default.Query |v#0@@92| |v'#0@@47| |lbl#0@@51| |receipt#0@@10|))
))))
(assert (forall ((|v#0@@93| T@U) (|v'#0@@48| T@U) (|lbl#0@@52| T@U) (|receipt#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@93|) DatatypeTypeType) (= (type |v'#0@@48|) DatatypeTypeType)) (= (type |lbl#0@@52|) DatatypeTypeType)) (= (type |receipt#0@@11|) DatatypeTypeType)) (and (and (and ($Is |v#0@@93| Tclass.PagedBetree.Variables) ($Is |v'#0@@48| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@52| Tclass.PagedBetree.TransitionLabel)) ($Is |receipt#0@@11| Tclass.PagedBetree.QueryReceipt))) (= (|PagedBetree.__default.Query#requires| |v#0@@93| |v'#0@@48| |lbl#0@@52| |receipt#0@@11|) true))
 :qid |PagedBetreeidfy.253:19|
 :skolemid |7601|
 :pattern ( (|PagedBetree.__default.Query#requires| |v#0@@93| |v'#0@@48| |lbl#0@@52| |receipt#0@@11|))
)))
(assert  (=> true (forall ((|v#0@@94| T@U) (|v'#0@@49| T@U) (|lbl#0@@53| T@U) (|receipt#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@94|) DatatypeTypeType) (= (type |v'#0@@49|) DatatypeTypeType)) (= (type |lbl#0@@53|) DatatypeTypeType)) (= (type |receipt#0@@12|) DatatypeTypeType)) (or (|PagedBetree.__default.Query#canCall| |v#0@@94| |v'#0@@49| |lbl#0@@53| |receipt#0@@12|) (and (and (and ($Is |v#0@@94| Tclass.PagedBetree.Variables) ($Is |v'#0@@49| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@53| Tclass.PagedBetree.TransitionLabel)) ($Is |receipt#0@@12| Tclass.PagedBetree.QueryReceipt)))) (and (=> (PagedBetree.TransitionLabel.QueryLabel_q |lbl#0@@53|) (and (and (PagedBetree.Variables.Variables_q |v#0@@94|) (MemtableMod.Memtable.Memtable_q (PagedBetree.Variables.memtable |v#0@@94|))) (=> (= (PagedBetree.TransitionLabel.endLsn |lbl#0@@53|) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@94|))) (and (and (PagedBetree.Variables.Variables_q |v#0@@94|) (|PagedBetree.QueryReceipt.ValidFor#canCall| |receipt#0@@12| (PagedBetree.Variables.root |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|))) (=> (PagedBetree.QueryReceipt.ValidFor |receipt#0@@12| (PagedBetree.Variables.root |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|)) (and (and (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PagedBetree.Variables.memtable |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|)) (PagedBetree.QueryReceipt.Result |receipt#0@@12|))) (and (and (and (PagedBetree.Variables.Variables_q |v#0@@94|) (|MemtableMod.Memtable.Query#canCall| (PagedBetree.Variables.memtable |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|))) (|PagedBetree.QueryReceipt.Result#canCall| |receipt#0@@12|)) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Query (PagedBetree.Variables.memtable |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|)) (PagedBetree.QueryReceipt.Result |receipt#0@@12|)))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PagedBetree.TransitionLabel.value |lbl#0@@53|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PagedBetree.Variables.memtable |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|)) (PagedBetree.QueryReceipt.Result |receipt#0@@12|))) (and (|$IsA#PagedBetree.Variables| |v'#0@@49|) (|$IsA#PagedBetree.Variables| |v#0@@94|))))))))) (= (PagedBetree.__default.Query |v#0@@94| |v'#0@@49| |lbl#0@@53| |receipt#0@@12|)  (and (and (and (and (PagedBetree.TransitionLabel.QueryLabel_q |lbl#0@@53|) (= (PagedBetree.TransitionLabel.endLsn |lbl#0@@53|) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@94|)))) (PagedBetree.QueryReceipt.ValidFor |receipt#0@@12| (PagedBetree.Variables.root |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PagedBetree.TransitionLabel.value |lbl#0@@53|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PagedBetree.Variables.memtable |v#0@@94|) (PagedBetree.TransitionLabel.key |lbl#0@@53|)) (PagedBetree.QueryReceipt.Result |receipt#0@@12|)))) (|PagedBetree.Variables#Equal| |v'#0@@49| |v#0@@94|)))))
 :qid |PagedBetreeidfy.253:19|
 :skolemid |7602|
 :pattern ( (PagedBetree.__default.Query |v#0@@94| |v'#0@@49| |lbl#0@@53| |receipt#0@@12|))
))))
(assert  (=> true (forall ((|v#0@@95| T@U) (|v'#0@@50| T@U) (|lbl#0@@54| T@U) (|receipt#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@95|) DatatypeTypeType) (= (type |v'#0@@50|) DatatypeTypeType)) (= (type |lbl#0@@54|) DatatypeTypeType)) (= (type |receipt#0@@13|) DatatypeTypeType)) (or (|PagedBetree.__default.Query#canCall| (Lit |v#0@@95|) (Lit |v'#0@@50|) (Lit |lbl#0@@54|) (Lit |receipt#0@@13|)) (and (and (and ($Is |v#0@@95| Tclass.PagedBetree.Variables) ($Is |v'#0@@50| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@54| Tclass.PagedBetree.TransitionLabel)) ($Is |receipt#0@@13| Tclass.PagedBetree.QueryReceipt)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@54|))))) (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@95|)) (MemtableMod.Memtable.Memtable_q (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))))) (=> (= (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@54|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|)))))) (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@95|)) (|PagedBetree.QueryReceipt.ValidFor#canCall| (Lit |receipt#0@@13|) (Lit (PagedBetree.Variables.root (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.ValidFor (Lit |receipt#0@@13|) (Lit (PagedBetree.Variables.root (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))))) (and (and (|$IsA#ValueMessage.Message| (Lit (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (Lit (PagedBetree.QueryReceipt.Result (Lit |receipt#0@@13|)))))) (and (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@95|)) (|MemtableMod.Memtable.Query#canCall| (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (|PagedBetree.QueryReceipt.Result#canCall| (Lit |receipt#0@@13|))) (|ValueMessage.__default.Merge#canCall| (Lit (MemtableMod.Memtable.Query (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (Lit (PagedBetree.QueryReceipt.Result (Lit |receipt#0@@13|)))))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PagedBetree.TransitionLabel.value (Lit |lbl#0@@54|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (Lit (PagedBetree.QueryReceipt.Result (Lit |receipt#0@@13|))))) (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@50|)) (|$IsA#PagedBetree.Variables| (Lit |v#0@@95|)))))))))) (= (PagedBetree.__default.Query (Lit |v#0@@95|) (Lit |v'#0@@50|) (Lit |lbl#0@@54|) (Lit |receipt#0@@13|))  (and (and (and (and (PagedBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@54|)) (= (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@54|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))))))) (PagedBetree.QueryReceipt.ValidFor (Lit |receipt#0@@13|) (Lit (PagedBetree.Variables.root (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PagedBetree.TransitionLabel.value (Lit |lbl#0@@54|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PagedBetree.Variables.memtable (Lit |v#0@@95|))) (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@54|))))) (Lit (PagedBetree.QueryReceipt.Result (Lit |receipt#0@@13|)))))) (|PagedBetree.Variables#Equal| |v'#0@@50| |v#0@@95|)))))
 :qid |PagedBetreeidfy.253:19|
 :weight 3
 :skolemid |7603|
 :pattern ( (PagedBetree.__default.Query (Lit |v#0@@95|) (Lit |v'#0@@50|) (Lit |lbl#0@@54|) (Lit |receipt#0@@13|)))
))))
(assert  (=> true (forall ((|v#0@@96| T@U) (|v'#0@@51| T@U) (|lbl#0@@55| T@U) ) (!  (=> (and (and (and (= (type |v#0@@96|) DatatypeTypeType) (= (type |v'#0@@51|) DatatypeTypeType)) (= (type |lbl#0@@55|) DatatypeTypeType)) (or (|PagedBetree.__default.Put#canCall| |v#0@@96| |v'#0@@51| |lbl#0@@55|) (and (and ($Is |v#0@@96| Tclass.PagedBetree.Variables) ($Is |v'#0@@51| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@55| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.262:17|
 :skolemid |7604|
 :pattern ( (PagedBetree.__default.Put |v#0@@96| |v'#0@@51| |lbl#0@@55|))
))))
(assert (forall ((|v#0@@97| T@U) (|v'#0@@52| T@U) (|lbl#0@@56| T@U) ) (!  (=> (and (and (and (= (type |v#0@@97|) DatatypeTypeType) (= (type |v'#0@@52|) DatatypeTypeType)) (= (type |lbl#0@@56|) DatatypeTypeType)) (and (and ($Is |v#0@@97| Tclass.PagedBetree.Variables) ($Is |v'#0@@52| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@56| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.Put#requires| |v#0@@97| |v'#0@@52| |lbl#0@@56|) true))
 :qid |PagedBetreeidfy.262:17|
 :skolemid |7605|
 :pattern ( (|PagedBetree.__default.Put#requires| |v#0@@97| |v'#0@@52| |lbl#0@@56|))
)))
(assert  (=> true (forall ((|v#0@@98| T@U) (|v'#0@@53| T@U) (|lbl#0@@57| T@U) ) (!  (=> (and (and (and (= (type |v#0@@98|) DatatypeTypeType) (= (type |v'#0@@53|) DatatypeTypeType)) (= (type |lbl#0@@57|) DatatypeTypeType)) (or (|PagedBetree.__default.Put#canCall| |v#0@@98| |v'#0@@53| |lbl#0@@57|) (and (and ($Is |v#0@@98| Tclass.PagedBetree.Variables) ($Is |v'#0@@53| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@57| Tclass.PagedBetree.TransitionLabel)))) (and (=> (PagedBetree.TransitionLabel.PutLabel_q |lbl#0@@57|) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (PagedBetree.TransitionLabel.puts |lbl#0@@57|)) (=> (MsgHistoryMod.MsgHistory.WF (PagedBetree.TransitionLabel.puts |lbl#0@@57|)) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (PagedBetree.TransitionLabel.puts |lbl#0@@57|)) (and (PagedBetree.Variables.Variables_q |v#0@@98|) (MemtableMod.Memtable.Memtable_q (PagedBetree.Variables.memtable |v#0@@98|)))) (=> (= (MsgHistoryMod.MsgHistory.seqStart (PagedBetree.TransitionLabel.puts |lbl#0@@57|)) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@98|))) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@53|) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#0@@14| |v#0@@98|))
(let ((|dt_update#memtable#0#0@@3| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PagedBetree.Variables.memtable |v#0@@98|) (PagedBetree.TransitionLabel.puts |lbl#0@@57|))))
(|#PagedBetree.Variables.Variables| |dt_update#memtable#0#0@@3| (PagedBetree.Variables.root |dt_update_tmp#0#0@@14|)))))) (let ((|dt_update_tmp#0#0@@15| |v#0@@98|))
 (and (and (PagedBetree.Variables.Variables_q |v#0@@98|) (|MemtableMod.Memtable.ApplyPuts#canCall| (PagedBetree.Variables.memtable |v#0@@98|) (PagedBetree.TransitionLabel.puts |lbl#0@@57|))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#0@@15|))))))))) (= (PagedBetree.__default.Put |v#0@@98| |v'#0@@53| |lbl#0@@57|)  (and (and (and (PagedBetree.TransitionLabel.PutLabel_q |lbl#0@@57|) (MsgHistoryMod.MsgHistory.WF (PagedBetree.TransitionLabel.puts |lbl#0@@57|))) (= (MsgHistoryMod.MsgHistory.seqStart (PagedBetree.TransitionLabel.puts |lbl#0@@57|)) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@98|)))) (|PagedBetree.Variables#Equal| |v'#0@@53| (let ((|dt_update_tmp#0#0@@16| |v#0@@98|))
(let ((|dt_update#memtable#0#0@@4| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PagedBetree.Variables.memtable |v#0@@98|) (PagedBetree.TransitionLabel.puts |lbl#0@@57|))))
(|#PagedBetree.Variables.Variables| |dt_update#memtable#0#0@@4| (PagedBetree.Variables.root |dt_update_tmp#0#0@@16|)))))))))
 :qid |PagedBetreeidfy.262:17|
 :skolemid |7606|
 :pattern ( (PagedBetree.__default.Put |v#0@@98| |v'#0@@53| |lbl#0@@57|))
))))
(assert  (=> true (forall ((|v#0@@99| T@U) (|v'#0@@54| T@U) (|lbl#0@@58| T@U) ) (!  (=> (and (and (and (= (type |v#0@@99|) DatatypeTypeType) (= (type |v'#0@@54|) DatatypeTypeType)) (= (type |lbl#0@@58|) DatatypeTypeType)) (or (|PagedBetree.__default.Put#canCall| (Lit |v#0@@99|) (Lit |v'#0@@54|) (Lit |lbl#0@@58|)) (and (and ($Is |v#0@@99| Tclass.PagedBetree.Variables) ($Is |v'#0@@54| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@58| Tclass.PagedBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@58|))))) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|)))) (=> (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|)))) (and (PagedBetree.Variables.Variables_q (Lit |v#0@@99|)) (MemtableMod.Memtable.Memtable_q (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|)))))) (=> (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|)))))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@54|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#1@@14| (Lit |v#0@@99|)))
(let ((|dt_update#memtable#0#1@@3| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|))) (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|)))))))
(Lit (|#PagedBetree.Variables.Variables| |dt_update#memtable#0#1@@3| (Lit (PagedBetree.Variables.root |dt_update_tmp#0#1@@14|)))))))) (let ((|dt_update_tmp#0#1@@15| (Lit |v#0@@99|)))
 (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@99|)) (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|))) (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|))))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#1@@15|))))))))) (= (PagedBetree.__default.Put (Lit |v#0@@99|) (Lit |v'#0@@54|) (Lit |lbl#0@@58|))  (and (and (and (PagedBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@58|)) (MsgHistoryMod.MsgHistory.WF (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|))))))) (|PagedBetree.Variables#Equal| |v'#0@@54| (let ((|dt_update_tmp#0#1@@16| (Lit |v#0@@99|)))
(let ((|dt_update#memtable#0#1@@4| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@99|))) (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@58|)))))))
(Lit (|#PagedBetree.Variables.Variables| |dt_update#memtable#0#1@@4| (Lit (PagedBetree.Variables.root |dt_update_tmp#0#1@@16|)))))))))))
 :qid |PagedBetreeidfy.262:17|
 :weight 3
 :skolemid |7607|
 :pattern ( (PagedBetree.__default.Put (Lit |v#0@@99|) (Lit |v'#0@@54|) (Lit |lbl#0@@58|)))
))))
(assert  (=> true (forall ((|v#0@@100| T@U) (|v'#0@@55| T@U) (|lbl#0@@59| T@U) ) (!  (=> (and (and (and (= (type |v#0@@100|) DatatypeTypeType) (= (type |v'#0@@55|) DatatypeTypeType)) (= (type |lbl#0@@59|) DatatypeTypeType)) (or (|PagedBetree.__default.QueryEndLsn#canCall| |v#0@@100| |v'#0@@55| |lbl#0@@59|) (and (and ($Is |v#0@@100| Tclass.PagedBetree.Variables) ($Is |v'#0@@55| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@59| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.272:25|
 :skolemid |7608|
 :pattern ( (PagedBetree.__default.QueryEndLsn |v#0@@100| |v'#0@@55| |lbl#0@@59|))
))))
(assert (forall ((|v#0@@101| T@U) (|v'#0@@56| T@U) (|lbl#0@@60| T@U) ) (!  (=> (and (and (and (= (type |v#0@@101|) DatatypeTypeType) (= (type |v'#0@@56|) DatatypeTypeType)) (= (type |lbl#0@@60|) DatatypeTypeType)) (and (and ($Is |v#0@@101| Tclass.PagedBetree.Variables) ($Is |v'#0@@56| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@60| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.QueryEndLsn#requires| |v#0@@101| |v'#0@@56| |lbl#0@@60|) true))
 :qid |PagedBetreeidfy.272:25|
 :skolemid |7609|
 :pattern ( (|PagedBetree.__default.QueryEndLsn#requires| |v#0@@101| |v'#0@@56| |lbl#0@@60|))
)))
(assert  (=> true (forall ((|v#0@@102| T@U) (|v'#0@@57| T@U) (|lbl#0@@61| T@U) ) (!  (=> (and (and (and (= (type |v#0@@102|) DatatypeTypeType) (= (type |v'#0@@57|) DatatypeTypeType)) (= (type |lbl#0@@61|) DatatypeTypeType)) (or (|PagedBetree.__default.QueryEndLsn#canCall| |v#0@@102| |v'#0@@57| |lbl#0@@61|) (and (and ($Is |v#0@@102| Tclass.PagedBetree.Variables) ($Is |v'#0@@57| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@61| Tclass.PagedBetree.TransitionLabel)))) (and (=> (PagedBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@61|) (and (and (PagedBetree.Variables.Variables_q |v#0@@102|) (MemtableMod.Memtable.Memtable_q (PagedBetree.Variables.memtable |v#0@@102|))) (=> (= (PagedBetree.TransitionLabel.endLsn |lbl#0@@61|) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@102|))) (and (|$IsA#PagedBetree.Variables| |v'#0@@57|) (|$IsA#PagedBetree.Variables| |v#0@@102|))))) (= (PagedBetree.__default.QueryEndLsn |v#0@@102| |v'#0@@57| |lbl#0@@61|)  (and (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@61|) (= (PagedBetree.TransitionLabel.endLsn |lbl#0@@61|) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@102|)))) (|PagedBetree.Variables#Equal| |v'#0@@57| |v#0@@102|)))))
 :qid |PagedBetreeidfy.272:25|
 :skolemid |7610|
 :pattern ( (PagedBetree.__default.QueryEndLsn |v#0@@102| |v'#0@@57| |lbl#0@@61|))
))))
(assert  (=> true (forall ((|v#0@@103| T@U) (|v'#0@@58| T@U) (|lbl#0@@62| T@U) ) (!  (=> (and (and (and (= (type |v#0@@103|) DatatypeTypeType) (= (type |v'#0@@58|) DatatypeTypeType)) (= (type |lbl#0@@62|) DatatypeTypeType)) (or (|PagedBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@103|) (Lit |v'#0@@58|) (Lit |lbl#0@@62|)) (and (and ($Is |v#0@@103| Tclass.PagedBetree.Variables) ($Is |v'#0@@58| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@62| Tclass.PagedBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@62|))))) (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@103|)) (MemtableMod.Memtable.Memtable_q (Lit (PagedBetree.Variables.memtable (Lit |v#0@@103|))))) (=> (= (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@62|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@103|)))))) (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@58|)) (|$IsA#PagedBetree.Variables| (Lit |v#0@@103|)))))) (= (PagedBetree.__default.QueryEndLsn (Lit |v#0@@103|) (Lit |v'#0@@58|) (Lit |lbl#0@@62|))  (and (and (PagedBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@62|)) (= (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@62|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@103|))))))) (|PagedBetree.Variables#Equal| |v'#0@@58| |v#0@@103|)))))
 :qid |PagedBetreeidfy.272:25|
 :weight 3
 :skolemid |7611|
 :pattern ( (PagedBetree.__default.QueryEndLsn (Lit |v#0@@103|) (Lit |v'#0@@58|) (Lit |lbl#0@@62|)))
))))
(assert  (=> true (forall ((|v#0@@104| T@U) (|v'#0@@59| T@U) (|lbl#0@@63| T@U) ) (!  (=> (and (and (and (= (type |v#0@@104|) DatatypeTypeType) (= (type |v'#0@@59|) DatatypeTypeType)) (= (type |lbl#0@@63|) DatatypeTypeType)) (or (|PagedBetree.__default.FreezeAs#canCall| |v#0@@104| |v'#0@@59| |lbl#0@@63|) (and (and ($Is |v#0@@104| Tclass.PagedBetree.Variables) ($Is |v'#0@@59| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@63| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.279:22|
 :skolemid |7612|
 :pattern ( (PagedBetree.__default.FreezeAs |v#0@@104| |v'#0@@59| |lbl#0@@63|))
))))
(assert (forall ((|v#0@@105| T@U) (|v'#0@@60| T@U) (|lbl#0@@64| T@U) ) (!  (=> (and (and (and (= (type |v#0@@105|) DatatypeTypeType) (= (type |v'#0@@60|) DatatypeTypeType)) (= (type |lbl#0@@64|) DatatypeTypeType)) (and (and ($Is |v#0@@105| Tclass.PagedBetree.Variables) ($Is |v'#0@@60| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@64| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.FreezeAs#requires| |v#0@@105| |v'#0@@60| |lbl#0@@64|) true))
 :qid |PagedBetreeidfy.279:22|
 :skolemid |7613|
 :pattern ( (|PagedBetree.__default.FreezeAs#requires| |v#0@@105| |v'#0@@60| |lbl#0@@64|))
)))
(assert  (=> true (forall ((|v#0@@106| T@U) (|v'#0@@61| T@U) (|lbl#0@@65| T@U) ) (!  (=> (and (and (and (= (type |v#0@@106|) DatatypeTypeType) (= (type |v'#0@@61|) DatatypeTypeType)) (= (type |lbl#0@@65|) DatatypeTypeType)) (or (|PagedBetree.__default.FreezeAs#canCall| |v#0@@106| |v'#0@@61| |lbl#0@@65|) (and (and ($Is |v#0@@106| Tclass.PagedBetree.Variables) ($Is |v'#0@@61| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@65| Tclass.PagedBetree.TransitionLabel)))) (and (=> (PagedBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@65|) (and (|PagedBetree.Variables.WF#canCall| |v#0@@106|) (=> (PagedBetree.Variables.WF |v#0@@106|) (and (and (PagedBetree.Variables.Variables_q |v#0@@106|) (|MemtableMod.Memtable.IsEmpty#canCall| (PagedBetree.Variables.memtable |v#0@@106|))) (=> (MemtableMod.Memtable.IsEmpty (PagedBetree.Variables.memtable |v#0@@106|)) (and (and (|$IsA#StampedMod.Stamped| (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@65|)) (and (PagedBetree.Variables.Variables_q |v#0@@106|) (and (PagedBetree.Variables.Variables_q |v#0@@106|) (MemtableMod.Memtable.Memtable_q (PagedBetree.Variables.memtable |v#0@@106|))))) (=> (|StampedMod.Stamped#Equal| (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@65|) (|#StampedMod.Stamped.Stamped| ($Box (PagedBetree.Variables.root |v#0@@106|)) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@106|)))) (and (|$IsA#PagedBetree.Variables| |v'#0@@61|) (|$IsA#PagedBetree.Variables| |v#0@@106|))))))))) (= (PagedBetree.__default.FreezeAs |v#0@@106| |v'#0@@61| |lbl#0@@65|)  (and (and (and (and (PagedBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@65|) (PagedBetree.Variables.WF |v#0@@106|)) (MemtableMod.Memtable.IsEmpty (PagedBetree.Variables.memtable |v#0@@106|))) (|StampedMod.Stamped#Equal| (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@65|) (|#StampedMod.Stamped.Stamped| ($Box (PagedBetree.Variables.root |v#0@@106|)) (MemtableMod.Memtable.seqEnd (PagedBetree.Variables.memtable |v#0@@106|))))) (|PagedBetree.Variables#Equal| |v'#0@@61| |v#0@@106|)))))
 :qid |PagedBetreeidfy.279:22|
 :skolemid |7614|
 :pattern ( (PagedBetree.__default.FreezeAs |v#0@@106| |v'#0@@61| |lbl#0@@65|))
))))
(assert  (=> true (forall ((|v#0@@107| T@U) (|v'#0@@62| T@U) (|lbl#0@@66| T@U) ) (!  (=> (and (and (and (= (type |v#0@@107|) DatatypeTypeType) (= (type |v'#0@@62|) DatatypeTypeType)) (= (type |lbl#0@@66|) DatatypeTypeType)) (or (|PagedBetree.__default.FreezeAs#canCall| (Lit |v#0@@107|) (Lit |v'#0@@62|) (Lit |lbl#0@@66|)) (and (and ($Is |v#0@@107| Tclass.PagedBetree.Variables) ($Is |v'#0@@62| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@66| Tclass.PagedBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@66|))))) (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@107|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@107|))))) (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@107|)) (|MemtableMod.Memtable.IsEmpty#canCall| (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|))))) (=> (U_2_bool (Lit (bool_2_U (MemtableMod.Memtable.IsEmpty (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|))))))) (and (and (|$IsA#StampedMod.Stamped| (Lit (PagedBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@66|)))) (and (PagedBetree.Variables.Variables_q (Lit |v#0@@107|)) (and (PagedBetree.Variables.Variables_q (Lit |v#0@@107|)) (MemtableMod.Memtable.Memtable_q (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|))))))) (=> (|StampedMod.Stamped#Equal| (PagedBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@66|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PagedBetree.Variables.root (Lit |v#0@@107|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|))))))) (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@62|)) (|$IsA#PagedBetree.Variables| (Lit |v#0@@107|)))))))))) (= (PagedBetree.__default.FreezeAs (Lit |v#0@@107|) (Lit |v'#0@@62|) (Lit |lbl#0@@66|))  (and (and (and (and (PagedBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@66|)) (PagedBetree.Variables.WF (Lit |v#0@@107|))) (MemtableMod.Memtable.IsEmpty (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|))))) (|StampedMod.Stamped#Equal| (PagedBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@66|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PagedBetree.Variables.root (Lit |v#0@@107|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PagedBetree.Variables.memtable (Lit |v#0@@107|)))))))) (|PagedBetree.Variables#Equal| |v'#0@@62| |v#0@@107|)))))
 :qid |PagedBetreeidfy.279:22|
 :weight 3
 :skolemid |7615|
 :pattern ( (PagedBetree.__default.FreezeAs (Lit |v#0@@107|) (Lit |v'#0@@62|) (Lit |lbl#0@@66|)))
))))
(assert  (=> true (forall ((|v#0@@108| T@U) (|v'#0@@63| T@U) (|lbl#0@@67| T@U) ) (!  (=> (and (and (and (= (type |v#0@@108|) DatatypeTypeType) (= (type |v'#0@@63|) DatatypeTypeType)) (= (type |lbl#0@@67|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlushMemtable#canCall| |v#0@@108| |v'#0@@63| |lbl#0@@67|) (and (and ($Is |v#0@@108| Tclass.PagedBetree.Variables) ($Is |v'#0@@63| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@67| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.289:35|
 :skolemid |7616|
 :pattern ( (PagedBetree.__default.InternalFlushMemtable |v#0@@108| |v'#0@@63| |lbl#0@@67|))
))))
(assert (forall ((|v#0@@109| T@U) (|v'#0@@64| T@U) (|lbl#0@@68| T@U) ) (!  (=> (and (and (and (= (type |v#0@@109|) DatatypeTypeType) (= (type |v'#0@@64|) DatatypeTypeType)) (= (type |lbl#0@@68|) DatatypeTypeType)) (and (and ($Is |v#0@@109| Tclass.PagedBetree.Variables) ($Is |v'#0@@64| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@68| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.InternalFlushMemtable#requires| |v#0@@109| |v'#0@@64| |lbl#0@@68|) true))
 :qid |PagedBetreeidfy.289:35|
 :skolemid |7617|
 :pattern ( (|PagedBetree.__default.InternalFlushMemtable#requires| |v#0@@109| |v'#0@@64| |lbl#0@@68|))
)))
(assert  (=> true (forall ((|v#0@@110| T@U) (|v'#0@@65| T@U) (|lbl#0@@69| T@U) ) (!  (=> (and (and (and (= (type |v#0@@110|) DatatypeTypeType) (= (type |v'#0@@65|) DatatypeTypeType)) (= (type |lbl#0@@69|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlushMemtable#canCall| |v#0@@110| |v'#0@@65| |lbl#0@@69|) (and (and ($Is |v#0@@110| Tclass.PagedBetree.Variables) ($Is |v'#0@@65| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@69| Tclass.PagedBetree.TransitionLabel)))) (and (and (|PagedBetree.Variables.WF#canCall| |v#0@@110|) (=> (PagedBetree.Variables.WF |v#0@@110|) (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@69|) (and (and (PagedBetree.Variables.Variables_q |v#0@@110|) (MemtableMod.Memtable.Memtable_q (PagedBetree.Variables.memtable |v#0@@110|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@65|) (|$IsA#PagedBetree.Variables| (let ((|dt_update#root#0#0@@9| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PagedBetree.BetreeNode.PushMemtable (PagedBetree.Variables.root |v#0@@110|) (PagedBetree.Variables.memtable |v#0@@110|))))))
(let ((|dt_update#memtable#0#0@@5| (MemtableMod.Memtable.Drain (PagedBetree.Variables.memtable |v#0@@110|))))
(|#PagedBetree.Variables.Variables| |dt_update#memtable#0#0@@5| |dt_update#root#0#0@@9|))))) (and (and (and (and (PagedBetree.Variables.Variables_q |v#0@@110|) (PagedBetree.Variables.Variables_q |v#0@@110|)) (|PagedBetree.BetreeNode.PushMemtable#canCall| (PagedBetree.Variables.root |v#0@@110|) (PagedBetree.Variables.memtable |v#0@@110|))) (StampedMod.Stamped.Stamped_q (PagedBetree.BetreeNode.PushMemtable (PagedBetree.Variables.root |v#0@@110|) (PagedBetree.Variables.memtable |v#0@@110|)))) (and (PagedBetree.Variables.Variables_q |v#0@@110|) (|MemtableMod.Memtable.Drain#canCall| (PagedBetree.Variables.memtable |v#0@@110|)))))))))) (= (PagedBetree.__default.InternalFlushMemtable |v#0@@110| |v'#0@@65| |lbl#0@@69|)  (and (and (PagedBetree.Variables.WF |v#0@@110|) (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@69|)) (and true (|PagedBetree.Variables#Equal| |v'#0@@65| (let ((|dt_update#root#0#0@@10| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PagedBetree.BetreeNode.PushMemtable (PagedBetree.Variables.root |v#0@@110|) (PagedBetree.Variables.memtable |v#0@@110|))))))
(let ((|dt_update#memtable#0#0@@6| (MemtableMod.Memtable.Drain (PagedBetree.Variables.memtable |v#0@@110|))))
(|#PagedBetree.Variables.Variables| |dt_update#memtable#0#0@@6| |dt_update#root#0#0@@10|)))))))))
 :qid |PagedBetreeidfy.289:35|
 :skolemid |7618|
 :pattern ( (PagedBetree.__default.InternalFlushMemtable |v#0@@110| |v'#0@@65| |lbl#0@@69|))
))))
(assert  (=> true (forall ((|v#0@@111| T@U) (|v'#0@@66| T@U) (|lbl#0@@70| T@U) ) (!  (=> (and (and (and (= (type |v#0@@111|) DatatypeTypeType) (= (type |v'#0@@66|) DatatypeTypeType)) (= (type |lbl#0@@70|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@111|) (Lit |v'#0@@66|) (Lit |lbl#0@@70|)) (and (and ($Is |v#0@@111| Tclass.PagedBetree.Variables) ($Is |v'#0@@66| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@70| Tclass.PagedBetree.TransitionLabel)))) (and (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@111|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@111|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@70|))))) (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@111|)) (MemtableMod.Memtable.Memtable_q (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|))))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@66|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update#root#0#1@@9| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PagedBetree.BetreeNode.PushMemtable (Lit (PagedBetree.Variables.root (Lit |v#0@@111|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|))))))))))
(let ((|dt_update#memtable#0#1@@5| (Lit (MemtableMod.Memtable.Drain (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|)))))))
(Lit (|#PagedBetree.Variables.Variables| |dt_update#memtable#0#1@@5| |dt_update#root#0#1@@9|)))))) (and (and (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@111|)) (PagedBetree.Variables.Variables_q (Lit |v#0@@111|))) (|PagedBetree.BetreeNode.PushMemtable#canCall| (Lit (PagedBetree.Variables.root (Lit |v#0@@111|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|))))) (StampedMod.Stamped.Stamped_q (Lit (PagedBetree.BetreeNode.PushMemtable (Lit (PagedBetree.Variables.root (Lit |v#0@@111|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|))))))) (and (PagedBetree.Variables.Variables_q (Lit |v#0@@111|)) (|MemtableMod.Memtable.Drain#canCall| (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|)))))))))))) (= (PagedBetree.__default.InternalFlushMemtable (Lit |v#0@@111|) (Lit |v'#0@@66|) (Lit |lbl#0@@70|))  (and (and (PagedBetree.Variables.WF (Lit |v#0@@111|)) (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@70|))) (and true (|PagedBetree.Variables#Equal| |v'#0@@66| (let ((|dt_update#root#0#1@@10| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PagedBetree.BetreeNode.PushMemtable (Lit (PagedBetree.Variables.root (Lit |v#0@@111|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|))))))))))
(let ((|dt_update#memtable#0#1@@6| (Lit (MemtableMod.Memtable.Drain (Lit (PagedBetree.Variables.memtable (Lit |v#0@@111|)))))))
(Lit (|#PagedBetree.Variables.Variables| |dt_update#memtable#0#1@@6| |dt_update#root#0#1@@10|))))))))))
 :qid |PagedBetreeidfy.289:35|
 :weight 3
 :skolemid |7619|
 :pattern ( (PagedBetree.__default.InternalFlushMemtable (Lit |v#0@@111|) (Lit |v'#0@@66|) (Lit |lbl#0@@70|)))
))))
(assert  (=> true (forall ((|v#0@@112| T@U) (|v'#0@@67| T@U) (|lbl#0@@71| T@U) ) (!  (=> (and (and (and (= (type |v#0@@112|) DatatypeTypeType) (= (type |v'#0@@67|) DatatypeTypeType)) (= (type |lbl#0@@71|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalGrow#canCall| |v#0@@112| |v'#0@@67| |lbl#0@@71|) (and (and ($Is |v#0@@112| Tclass.PagedBetree.Variables) ($Is |v'#0@@67| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@71| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.366:26|
 :skolemid |7620|
 :pattern ( (PagedBetree.__default.InternalGrow |v#0@@112| |v'#0@@67| |lbl#0@@71|))
))))
(assert (forall ((|v#0@@113| T@U) (|v'#0@@68| T@U) (|lbl#0@@72| T@U) ) (!  (=> (and (and (and (= (type |v#0@@113|) DatatypeTypeType) (= (type |v'#0@@68|) DatatypeTypeType)) (= (type |lbl#0@@72|) DatatypeTypeType)) (and (and ($Is |v#0@@113| Tclass.PagedBetree.Variables) ($Is |v'#0@@68| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@72| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.InternalGrow#requires| |v#0@@113| |v'#0@@68| |lbl#0@@72|) true))
 :qid |PagedBetreeidfy.366:26|
 :skolemid |7621|
 :pattern ( (|PagedBetree.__default.InternalGrow#requires| |v#0@@113| |v'#0@@68| |lbl#0@@72|))
)))
(assert  (=> true (forall ((|v#0@@114| T@U) (|v'#0@@69| T@U) (|lbl#0@@73| T@U) ) (!  (=> (and (and (and (= (type |v#0@@114|) DatatypeTypeType) (= (type |v'#0@@69|) DatatypeTypeType)) (= (type |lbl#0@@73|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalGrow#canCall| |v#0@@114| |v'#0@@69| |lbl#0@@73|) (and (and ($Is |v#0@@114| Tclass.PagedBetree.Variables) ($Is |v'#0@@69| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@73| Tclass.PagedBetree.TransitionLabel)))) (and (and (|PagedBetree.Variables.WF#canCall| |v#0@@114|) (=> (PagedBetree.Variables.WF |v#0@@114|) (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@73|) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@69|) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#0@@17| |v#0@@114|))
(let ((|dt_update#root#0#0@@11| (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (PagedBetree.__default.ConstantChildMap (PagedBetree.Variables.root |v#0@@114|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@17|) |dt_update#root#0#0@@11|))))) (let ((|dt_update_tmp#0#0@@18| |v#0@@114|))
 (and (and (PagedBetree.Variables.Variables_q |v#0@@114|) (|PagedBetree.__default.ConstantChildMap#canCall| (PagedBetree.Variables.root |v#0@@114|))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#0@@18|))))))) (= (PagedBetree.__default.InternalGrow |v#0@@114| |v'#0@@69| |lbl#0@@73|)  (and (and (PagedBetree.Variables.WF |v#0@@114|) (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@73|)) (|PagedBetree.Variables#Equal| |v'#0@@69| (let ((|dt_update_tmp#0#0@@19| |v#0@@114|))
(let ((|dt_update#root#0#0@@12| (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (PagedBetree.__default.ConstantChildMap (PagedBetree.Variables.root |v#0@@114|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@19|) |dt_update#root#0#0@@12|))))))))
 :qid |PagedBetreeidfy.366:26|
 :skolemid |7622|
 :pattern ( (PagedBetree.__default.InternalGrow |v#0@@114| |v'#0@@69| |lbl#0@@73|))
))))
(assert  (=> true (forall ((|v#0@@115| T@U) (|v'#0@@70| T@U) (|lbl#0@@74| T@U) ) (!  (=> (and (and (and (= (type |v#0@@115|) DatatypeTypeType) (= (type |v'#0@@70|) DatatypeTypeType)) (= (type |lbl#0@@74|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalGrow#canCall| (Lit |v#0@@115|) (Lit |v'#0@@70|) (Lit |lbl#0@@74|)) (and (and ($Is |v#0@@115| Tclass.PagedBetree.Variables) ($Is |v'#0@@70| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@74| Tclass.PagedBetree.TransitionLabel)))) (and (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@115|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@115|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@74|))))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@70|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#1@@17| (Lit |v#0@@115|)))
(let ((|dt_update#root#0#1@@11| (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (Lit (PagedBetree.__default.ConstantChildMap (Lit (PagedBetree.Variables.root (Lit |v#0@@115|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@17|)) |dt_update#root#0#1@@11|)))))) (let ((|dt_update_tmp#0#1@@18| (Lit |v#0@@115|)))
 (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@115|)) (|PagedBetree.__default.ConstantChildMap#canCall| (Lit (PagedBetree.Variables.root (Lit |v#0@@115|))))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#1@@18|))))))) (= (PagedBetree.__default.InternalGrow (Lit |v#0@@115|) (Lit |v'#0@@70|) (Lit |lbl#0@@74|))  (and (and (PagedBetree.Variables.WF (Lit |v#0@@115|)) (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@74|))) (|PagedBetree.Variables#Equal| |v'#0@@70| (let ((|dt_update_tmp#0#1@@19| (Lit |v#0@@115|)))
(let ((|dt_update#root#0#1@@12| (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) (Lit (PagedBetree.__default.ConstantChildMap (Lit (PagedBetree.Variables.root (Lit |v#0@@115|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@19|)) |dt_update#root#0#1@@12|)))))))))
 :qid |PagedBetreeidfy.366:26|
 :weight 3
 :skolemid |7623|
 :pattern ( (PagedBetree.__default.InternalGrow (Lit |v#0@@115|) (Lit |v'#0@@70|) (Lit |lbl#0@@74|)))
))))
(assert  (=> true (forall ((|v#0@@116| T@U) (|v'#0@@71| T@U) (|lbl#0@@75| T@U) (|step#0@@33| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@116|) DatatypeTypeType) (= (type |v'#0@@71|) DatatypeTypeType)) (= (type |lbl#0@@75|) DatatypeTypeType)) (= (type |step#0@@33|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalSplit#canCall| |v#0@@116| |v'#0@@71| |lbl#0@@75| |step#0@@33|) (and (and (and ($Is |v#0@@116| Tclass.PagedBetree.Variables) ($Is |v'#0@@71| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@75| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@33| Tclass.PagedBetree.Step)))) true)
 :qid |PagedBetreeidfy.375:27|
 :skolemid |7624|
 :pattern ( (PagedBetree.__default.InternalSplit |v#0@@116| |v'#0@@71| |lbl#0@@75| |step#0@@33|))
))))
(assert (forall ((|v#0@@117| T@U) (|v'#0@@72| T@U) (|lbl#0@@76| T@U) (|step#0@@34| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@117|) DatatypeTypeType) (= (type |v'#0@@72|) DatatypeTypeType)) (= (type |lbl#0@@76|) DatatypeTypeType)) (= (type |step#0@@34|) DatatypeTypeType)) (and (and (and ($Is |v#0@@117| Tclass.PagedBetree.Variables) ($Is |v'#0@@72| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@76| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@34| Tclass.PagedBetree.Step))) (= (|PagedBetree.__default.InternalSplit#requires| |v#0@@117| |v'#0@@72| |lbl#0@@76| |step#0@@34|) true))
 :qid |PagedBetreeidfy.375:27|
 :skolemid |7625|
 :pattern ( (|PagedBetree.__default.InternalSplit#requires| |v#0@@117| |v'#0@@72| |lbl#0@@76| |step#0@@34|))
)))
(assert  (=> true (forall ((|v#0@@118| T@U) (|v'#0@@73| T@U) (|lbl#0@@77| T@U) (|step#0@@35| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@118|) DatatypeTypeType) (= (type |v'#0@@73|) DatatypeTypeType)) (= (type |lbl#0@@77|) DatatypeTypeType)) (= (type |step#0@@35|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalSplit#canCall| |v#0@@118| |v'#0@@73| |lbl#0@@77| |step#0@@35|) (and (and (and ($Is |v#0@@118| Tclass.PagedBetree.Variables) ($Is |v'#0@@73| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@77| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@35| Tclass.PagedBetree.Step)))) (and (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@77|) (=> (PagedBetree.Step.InternalSplitStep_q |step#0@@35|) (and (|PagedBetree.Path.Valid#canCall| (PagedBetree.Step.path |step#0@@35|)) (=> (PagedBetree.Path.Valid ($LS $LZ) (PagedBetree.Step.path |step#0@@35|)) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@35|))) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Variables.root |v#0@@118|))) (and (PagedBetree.Path.Path_q (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Variables.Variables_q |v#0@@118|))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Variables.root |v#0@@118|)) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@73|) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#0@@20| |v#0@@118|))
(let ((|dt_update#root#0#0@@13| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@35|) (PagedBetree.BetreeNode.Split (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Step.leftKeys |step#0@@35|) (PagedBetree.Step.rightKeys |step#0@@35|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@20|) |dt_update#root#0#0@@13|))))) (let ((|dt_update_tmp#0#0@@21| |v#0@@118|))
 (and (and (and (|PagedBetree.Path.Target#canCall| (PagedBetree.Step.path |step#0@@35|)) (|PagedBetree.BetreeNode.Split#canCall| (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Step.leftKeys |step#0@@35|) (PagedBetree.Step.rightKeys |step#0@@35|))) (|PagedBetree.Path.Substitute#canCall| (PagedBetree.Step.path |step#0@@35|) (PagedBetree.BetreeNode.Split (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Step.leftKeys |step#0@@35|) (PagedBetree.Step.rightKeys |step#0@@35|)))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#0@@21|)))))))))) (= (PagedBetree.__default.InternalSplit |v#0@@118| |v'#0@@73| |lbl#0@@77| |step#0@@35|)  (and (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@77|) (PagedBetree.Step.InternalSplitStep_q |step#0@@35|)) (PagedBetree.Path.Valid ($LS $LZ) (PagedBetree.Step.path |step#0@@35|))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Variables.root |v#0@@118|))) (|PagedBetree.Variables#Equal| |v'#0@@73| (let ((|dt_update_tmp#0#0@@22| |v#0@@118|))
(let ((|dt_update#root#0#0@@14| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@35|) (PagedBetree.BetreeNode.Split (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@35|)) (PagedBetree.Step.leftKeys |step#0@@35|) (PagedBetree.Step.rightKeys |step#0@@35|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@22|) |dt_update#root#0#0@@14|))))))))
 :qid |PagedBetreeidfy.375:27|
 :skolemid |7626|
 :pattern ( (PagedBetree.__default.InternalSplit |v#0@@118| |v'#0@@73| |lbl#0@@77| |step#0@@35|))
))))
(assert  (=> true (forall ((|v#0@@119| T@U) (|v'#0@@74| T@U) (|lbl#0@@78| T@U) (|step#0@@36| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@119|) DatatypeTypeType) (= (type |v'#0@@74|) DatatypeTypeType)) (= (type |lbl#0@@78|) DatatypeTypeType)) (= (type |step#0@@36|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalSplit#canCall| (Lit |v#0@@119|) (Lit |v'#0@@74|) (Lit |lbl#0@@78|) (Lit |step#0@@36|)) (and (and (and ($Is |v#0@@119| Tclass.PagedBetree.Variables) ($Is |v'#0@@74| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@78| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@36| Tclass.PagedBetree.Step)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@78|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q (Lit |step#0@@36|))))) (and (|PagedBetree.Path.Valid#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))))) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Variables.root (Lit |v#0@@119|))))) (and (PagedBetree.Path.Path_q (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))) (PagedBetree.Variables.Variables_q (Lit |v#0@@119|)))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))) (PagedBetree.Variables.root (Lit |v#0@@119|))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@74|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#1@@20| (Lit |v#0@@119|)))
(let ((|dt_update#root#0#1@@13| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))) (Lit (PagedBetree.BetreeNode.Split (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))) (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@36|))) (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@36|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@20|)) |dt_update#root#0#1@@13|)))))) (let ((|dt_update_tmp#0#1@@21| (Lit |v#0@@119|)))
 (and (and (and (|PagedBetree.Path.Target#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))) (|PagedBetree.BetreeNode.Split#canCall| (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))) (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@36|))) (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@36|))))) (|PagedBetree.Path.Substitute#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@36|))) (Lit (PagedBetree.BetreeNode.Split (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))) (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@36|))) (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@36|))))))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#1@@21|)))))))))) (= (PagedBetree.__default.InternalSplit (Lit |v#0@@119|) (Lit |v'#0@@74|) (Lit |lbl#0@@78|) (Lit |step#0@@36|))  (and (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@78|)) (PagedBetree.Step.InternalSplitStep_q (Lit |step#0@@36|))) (PagedBetree.Path.Valid ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@36|)))) (PagedBetree.Variables.root (Lit |v#0@@119|)))) (|PagedBetree.Variables#Equal| |v'#0@@74| (let ((|dt_update_tmp#0#1@@22| (Lit |v#0@@119|)))
(let ((|dt_update#root#0#1@@14| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))) (Lit (PagedBetree.BetreeNode.Split (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@36|))))) (Lit (PagedBetree.Step.leftKeys (Lit |step#0@@36|))) (Lit (PagedBetree.Step.rightKeys (Lit |step#0@@36|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@22|)) |dt_update#root#0#1@@14|)))))))))
 :qid |PagedBetreeidfy.375:27|
 :weight 3
 :skolemid |7627|
 :pattern ( (PagedBetree.__default.InternalSplit (Lit |v#0@@119|) (Lit |v'#0@@74|) (Lit |lbl#0@@78|) (Lit |step#0@@36|)))
))))
(assert  (=> true (forall ((|v#0@@120| T@U) (|v'#0@@75| T@U) (|lbl#0@@79| T@U) (|step#0@@37| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@120|) DatatypeTypeType) (= (type |v'#0@@75|) DatatypeTypeType)) (= (type |lbl#0@@79|) DatatypeTypeType)) (= (type |step#0@@37|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlush#canCall| |v#0@@120| |v'#0@@75| |lbl#0@@79| |step#0@@37|) (and (and (and ($Is |v#0@@120| Tclass.PagedBetree.Variables) ($Is |v'#0@@75| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@79| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@37| Tclass.PagedBetree.Step)))) true)
 :qid |PagedBetreeidfy.386:27|
 :skolemid |7628|
 :pattern ( (PagedBetree.__default.InternalFlush |v#0@@120| |v'#0@@75| |lbl#0@@79| |step#0@@37|))
))))
(assert (forall ((|v#0@@121| T@U) (|v'#0@@76| T@U) (|lbl#0@@80| T@U) (|step#0@@38| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@121|) DatatypeTypeType) (= (type |v'#0@@76|) DatatypeTypeType)) (= (type |lbl#0@@80|) DatatypeTypeType)) (= (type |step#0@@38|) DatatypeTypeType)) (and (and (and ($Is |v#0@@121| Tclass.PagedBetree.Variables) ($Is |v'#0@@76| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@80| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@38| Tclass.PagedBetree.Step))) (= (|PagedBetree.__default.InternalFlush#requires| |v#0@@121| |v'#0@@76| |lbl#0@@80| |step#0@@38|) true))
 :qid |PagedBetreeidfy.386:27|
 :skolemid |7629|
 :pattern ( (|PagedBetree.__default.InternalFlush#requires| |v#0@@121| |v'#0@@76| |lbl#0@@80| |step#0@@38|))
)))
(assert  (=> true (forall ((|v#0@@122| T@U) (|v'#0@@77| T@U) (|lbl#0@@81| T@U) (|step#0@@39| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@122|) DatatypeTypeType) (= (type |v'#0@@77|) DatatypeTypeType)) (= (type |lbl#0@@81|) DatatypeTypeType)) (= (type |step#0@@39|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlush#canCall| |v#0@@122| |v'#0@@77| |lbl#0@@81| |step#0@@39|) (and (and (and ($Is |v#0@@122| Tclass.PagedBetree.Variables) ($Is |v'#0@@77| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@81| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@39| Tclass.PagedBetree.Step)))) (and (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@81|) (=> (PagedBetree.Step.InternalFlushStep_q |step#0@@39|) (and (|PagedBetree.Path.Valid#canCall| (PagedBetree.Step.path |step#0@@39|)) (=> (PagedBetree.Path.Valid ($LS $LZ) (PagedBetree.Step.path |step#0@@39|)) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@39|))) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Variables.root |v#0@@122|))) (and (PagedBetree.Path.Path_q (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Variables.Variables_q |v#0@@122|))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Variables.root |v#0@@122|)) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@77|) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#0@@23| |v#0@@122|))
(let ((|dt_update#root#0#0@@15| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@39|) (PagedBetree.BetreeNode.Flush (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Step.downKeys |step#0@@39|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@23|) |dt_update#root#0#0@@15|))))) (let ((|dt_update_tmp#0#0@@24| |v#0@@122|))
 (and (and (and (|PagedBetree.Path.Target#canCall| (PagedBetree.Step.path |step#0@@39|)) (|PagedBetree.BetreeNode.Flush#canCall| (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Step.downKeys |step#0@@39|))) (|PagedBetree.Path.Substitute#canCall| (PagedBetree.Step.path |step#0@@39|) (PagedBetree.BetreeNode.Flush (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Step.downKeys |step#0@@39|)))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#0@@24|)))))))))) (= (PagedBetree.__default.InternalFlush |v#0@@122| |v'#0@@77| |lbl#0@@81| |step#0@@39|)  (and (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@81|) (PagedBetree.Step.InternalFlushStep_q |step#0@@39|)) (PagedBetree.Path.Valid ($LS $LZ) (PagedBetree.Step.path |step#0@@39|))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Variables.root |v#0@@122|))) (|PagedBetree.Variables#Equal| |v'#0@@77| (let ((|dt_update_tmp#0#0@@25| |v#0@@122|))
(let ((|dt_update#root#0#0@@16| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@39|) (PagedBetree.BetreeNode.Flush (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@39|)) (PagedBetree.Step.downKeys |step#0@@39|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@25|) |dt_update#root#0#0@@16|))))))))
 :qid |PagedBetreeidfy.386:27|
 :skolemid |7630|
 :pattern ( (PagedBetree.__default.InternalFlush |v#0@@122| |v'#0@@77| |lbl#0@@81| |step#0@@39|))
))))
(assert  (=> true (forall ((|v#0@@123| T@U) (|v'#0@@78| T@U) (|lbl#0@@82| T@U) (|step#0@@40| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@123|) DatatypeTypeType) (= (type |v'#0@@78|) DatatypeTypeType)) (= (type |lbl#0@@82|) DatatypeTypeType)) (= (type |step#0@@40|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalFlush#canCall| (Lit |v#0@@123|) (Lit |v'#0@@78|) (Lit |lbl#0@@82|) (Lit |step#0@@40|)) (and (and (and ($Is |v#0@@123| Tclass.PagedBetree.Variables) ($Is |v'#0@@78| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@82| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@40| Tclass.PagedBetree.Step)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@82|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q (Lit |step#0@@40|))))) (and (|PagedBetree.Path.Valid#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Path.Valid ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))))) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Variables.root (Lit |v#0@@123|))))) (and (PagedBetree.Path.Path_q (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))) (PagedBetree.Variables.Variables_q (Lit |v#0@@123|)))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))) (PagedBetree.Variables.root (Lit |v#0@@123|))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@78|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#1@@23| (Lit |v#0@@123|)))
(let ((|dt_update#root#0#1@@15| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))) (Lit (PagedBetree.BetreeNode.Flush (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))) (Lit (PagedBetree.Step.downKeys (Lit |step#0@@40|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@23|)) |dt_update#root#0#1@@15|)))))) (let ((|dt_update_tmp#0#1@@24| (Lit |v#0@@123|)))
 (and (and (and (|PagedBetree.Path.Target#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))) (|PagedBetree.BetreeNode.Flush#canCall| (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))) (Lit (PagedBetree.Step.downKeys (Lit |step#0@@40|))))) (|PagedBetree.Path.Substitute#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@40|))) (Lit (PagedBetree.BetreeNode.Flush (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))) (Lit (PagedBetree.Step.downKeys (Lit |step#0@@40|))))))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#1@@24|)))))))))) (= (PagedBetree.__default.InternalFlush (Lit |v#0@@123|) (Lit |v'#0@@78|) (Lit |lbl#0@@82|) (Lit |step#0@@40|))  (and (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@82|)) (PagedBetree.Step.InternalFlushStep_q (Lit |step#0@@40|))) (PagedBetree.Path.Valid ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@40|)))) (PagedBetree.Variables.root (Lit |v#0@@123|)))) (|PagedBetree.Variables#Equal| |v'#0@@78| (let ((|dt_update_tmp#0#1@@25| (Lit |v#0@@123|)))
(let ((|dt_update#root#0#1@@16| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))) (Lit (PagedBetree.BetreeNode.Flush (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@40|))))) (Lit (PagedBetree.Step.downKeys (Lit |step#0@@40|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@25|)) |dt_update#root#0#1@@16|)))))))))
 :qid |PagedBetreeidfy.386:27|
 :weight 3
 :skolemid |7631|
 :pattern ( (PagedBetree.__default.InternalFlush (Lit |v#0@@123|) (Lit |v'#0@@78|) (Lit |lbl#0@@82|) (Lit |step#0@@40|)))
))))
(assert (forall ((arg0@@726 T@U) (arg1@@378 T@U) ) (! (= (type (PagedBetree.__default.CompactedNode arg0@@726 arg1@@378)) DatatypeTypeType)
 :qid |funType:PagedBetree.__default.CompactedNode|
 :pattern ( (PagedBetree.__default.CompactedNode arg0@@726 arg1@@378))
)))
(assert  (=> true (forall ((|original#0@@3| T@U) (|newBufs#0@@3| T@U) ) (!  (=> (and (and (= (type |original#0@@3|) DatatypeTypeType) (= (type |newBufs#0@@3|) DatatypeTypeType)) (or (|PagedBetree.__default.CompactedNode#canCall| |original#0@@3| |newBufs#0@@3|) (and (and ($Is |original#0@@3| Tclass.PagedBetree.BetreeNode) ($Is |newBufs#0@@3| Tclass.Buffers.BufferStack)) (and (PagedBetree.BetreeNode.BetreeNode_q |original#0@@3|) (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers |original#0@@3|) |newBufs#0@@3|))))) ($Is (PagedBetree.__default.CompactedNode |original#0@@3| |newBufs#0@@3|) Tclass.PagedBetree.BetreeNode))
 :qid |PagedBetreeidfy.397:26|
 :skolemid |7632|
 :pattern ( (PagedBetree.__default.CompactedNode |original#0@@3| |newBufs#0@@3|))
))))
(assert (forall ((|original#0@@4| T@U) (|newBufs#0@@4| T@U) ) (!  (=> (and (and (= (type |original#0@@4|) DatatypeTypeType) (= (type |newBufs#0@@4|) DatatypeTypeType)) (and ($Is |original#0@@4| Tclass.PagedBetree.BetreeNode) ($Is |newBufs#0@@4| Tclass.Buffers.BufferStack))) (= (|PagedBetree.__default.CompactedNode#requires| |original#0@@4| |newBufs#0@@4|)  (and (PagedBetree.BetreeNode.BetreeNode_q |original#0@@4|) (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers |original#0@@4|) |newBufs#0@@4|))))
 :qid |PagedBetreeidfy.397:26|
 :skolemid |7633|
 :pattern ( (|PagedBetree.__default.CompactedNode#requires| |original#0@@4| |newBufs#0@@4|))
)))
(assert  (=> true (forall ((|original#0@@5| T@U) (|newBufs#0@@5| T@U) ) (!  (=> (and (and (= (type |original#0@@5|) DatatypeTypeType) (= (type |newBufs#0@@5|) DatatypeTypeType)) (or (|PagedBetree.__default.CompactedNode#canCall| |original#0@@5| |newBufs#0@@5|) (and (and ($Is |original#0@@5| Tclass.PagedBetree.BetreeNode) ($Is |newBufs#0@@5| Tclass.Buffers.BufferStack)) (and (PagedBetree.BetreeNode.BetreeNode_q |original#0@@5|) (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers |original#0@@5|) |newBufs#0@@5|))))) (= (PagedBetree.__default.CompactedNode |original#0@@5| |newBufs#0@@5|) (|#PagedBetree.BetreeNode.BetreeNode| |newBufs#0@@5| (PagedBetree.BetreeNode.children |original#0@@5|))))
 :qid |PagedBetreeidfy.397:26|
 :skolemid |7634|
 :pattern ( (PagedBetree.__default.CompactedNode |original#0@@5| |newBufs#0@@5|))
))))
(assert  (=> true (forall ((|original#0@@6| T@U) (|newBufs#0@@6| T@U) ) (!  (=> (and (and (= (type |original#0@@6|) DatatypeTypeType) (= (type |newBufs#0@@6|) DatatypeTypeType)) (or (|PagedBetree.__default.CompactedNode#canCall| (Lit |original#0@@6|) (Lit |newBufs#0@@6|)) (and (and ($Is |original#0@@6| Tclass.PagedBetree.BetreeNode) ($Is |newBufs#0@@6| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit |original#0@@6|))))) (U_2_bool (Lit (bool_2_U (Buffers.BufferStack.Equivalent (Lit (PagedBetree.BetreeNode.buffers (Lit |original#0@@6|))) (Lit |newBufs#0@@6|))))))))) (= (PagedBetree.__default.CompactedNode (Lit |original#0@@6|) (Lit |newBufs#0@@6|)) (Lit (|#PagedBetree.BetreeNode.BetreeNode| (Lit |newBufs#0@@6|) (Lit (PagedBetree.BetreeNode.children (Lit |original#0@@6|)))))))
 :qid |PagedBetreeidfy.397:26|
 :weight 3
 :skolemid |7635|
 :pattern ( (PagedBetree.__default.CompactedNode (Lit |original#0@@6|) (Lit |newBufs#0@@6|)))
))))
(assert  (=> true (forall ((|v#0@@124| T@U) (|v'#0@@79| T@U) (|lbl#0@@83| T@U) (|step#0@@41| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@124|) DatatypeTypeType) (= (type |v'#0@@79|) DatatypeTypeType)) (= (type |lbl#0@@83|) DatatypeTypeType)) (= (type |step#0@@41|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalCompact#canCall| |v#0@@124| |v'#0@@79| |lbl#0@@83| |step#0@@41|) (and (and (and (and ($Is |v#0@@124| Tclass.PagedBetree.Variables) ($Is |v'#0@@79| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@83| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@41| Tclass.PagedBetree.Step)) (PagedBetree.Step.WF |step#0@@41|)))) true)
 :qid |PagedBetreeidfy.404:29|
 :skolemid |7636|
 :pattern ( (PagedBetree.__default.InternalCompact |v#0@@124| |v'#0@@79| |lbl#0@@83| |step#0@@41|))
))))
(assert (forall ((|v#0@@125| T@U) (|v'#0@@80| T@U) (|lbl#0@@84| T@U) (|step#0@@42| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@125|) DatatypeTypeType) (= (type |v'#0@@80|) DatatypeTypeType)) (= (type |lbl#0@@84|) DatatypeTypeType)) (= (type |step#0@@42|) DatatypeTypeType)) (and (and (and ($Is |v#0@@125| Tclass.PagedBetree.Variables) ($Is |v'#0@@80| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@84| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@42| Tclass.PagedBetree.Step))) (= (|PagedBetree.__default.InternalCompact#requires| |v#0@@125| |v'#0@@80| |lbl#0@@84| |step#0@@42|) (PagedBetree.Step.WF |step#0@@42|)))
 :qid |PagedBetreeidfy.404:29|
 :skolemid |7637|
 :pattern ( (|PagedBetree.__default.InternalCompact#requires| |v#0@@125| |v'#0@@80| |lbl#0@@84| |step#0@@42|))
)))
(assert  (=> true (forall ((|v#0@@126| T@U) (|v'#0@@81| T@U) (|lbl#0@@85| T@U) (|step#0@@43| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@126|) DatatypeTypeType) (= (type |v'#0@@81|) DatatypeTypeType)) (= (type |lbl#0@@85|) DatatypeTypeType)) (= (type |step#0@@43|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalCompact#canCall| |v#0@@126| |v'#0@@81| |lbl#0@@85| |step#0@@43|) (and (and (and (and ($Is |v#0@@126| Tclass.PagedBetree.Variables) ($Is |v'#0@@81| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@85| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@43| Tclass.PagedBetree.Step)) (PagedBetree.Step.WF |step#0@@43|)))) (and (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@85|) (=> (PagedBetree.Step.InternalCompactStep_q |step#0@@43|) (and (and (and (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@43|))) (|$IsA#PagedBetree.BetreeNode| (PagedBetree.Variables.root |v#0@@126|))) (and (PagedBetree.Path.Path_q (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Variables.Variables_q |v#0@@126|))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Variables.root |v#0@@126|)) (and (and (|$IsA#PagedBetree.Variables| |v'#0@@81|) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#0@@26| |v#0@@126|))
(let ((|dt_update#root#0#0@@17| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@43|) (PagedBetree.__default.CompactedNode (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Step.compactedBuffers |step#0@@43|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@26|) |dt_update#root#0#0@@17|))))) (let ((|dt_update_tmp#0#0@@27| |v#0@@126|))
 (and (and (and (|PagedBetree.Path.Target#canCall| (PagedBetree.Step.path |step#0@@43|)) (|PagedBetree.__default.CompactedNode#canCall| (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Step.compactedBuffers |step#0@@43|))) (|PagedBetree.Path.Substitute#canCall| (PagedBetree.Step.path |step#0@@43|) (PagedBetree.__default.CompactedNode (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Step.compactedBuffers |step#0@@43|)))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#0@@27|)))))))) (= (PagedBetree.__default.InternalCompact |v#0@@126| |v'#0@@81| |lbl#0@@85| |step#0@@43|)  (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@85|) (PagedBetree.Step.InternalCompactStep_q |step#0@@43|)) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Variables.root |v#0@@126|))) (|PagedBetree.Variables#Equal| |v'#0@@81| (let ((|dt_update_tmp#0#0@@28| |v#0@@126|))
(let ((|dt_update#root#0#0@@18| (PagedBetree.Path.Substitute ($LS $LZ) (PagedBetree.Step.path |step#0@@43|) (PagedBetree.__default.CompactedNode (PagedBetree.Path.Target ($LS $LZ) (PagedBetree.Step.path |step#0@@43|)) (PagedBetree.Step.compactedBuffers |step#0@@43|)))))
(|#PagedBetree.Variables.Variables| (PagedBetree.Variables.memtable |dt_update_tmp#0#0@@28|) |dt_update#root#0#0@@18|))))))))
 :qid |PagedBetreeidfy.404:29|
 :skolemid |7638|
 :pattern ( (PagedBetree.__default.InternalCompact |v#0@@126| |v'#0@@81| |lbl#0@@85| |step#0@@43|))
))))
(assert  (=> true (forall ((|v#0@@127| T@U) (|v'#0@@82| T@U) (|lbl#0@@86| T@U) (|step#0@@44| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@127|) DatatypeTypeType) (= (type |v'#0@@82|) DatatypeTypeType)) (= (type |lbl#0@@86|) DatatypeTypeType)) (= (type |step#0@@44|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalCompact#canCall| (Lit |v#0@@127|) (Lit |v'#0@@82|) (Lit |lbl#0@@86|) (Lit |step#0@@44|)) (and (and (and (and ($Is |v#0@@127| Tclass.PagedBetree.Variables) ($Is |v'#0@@82| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@86| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@44| Tclass.PagedBetree.Step)) (U_2_bool (Lit (bool_2_U (PagedBetree.Step.WF (Lit |step#0@@44|)))))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@86|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalCompactStep_q (Lit |step#0@@44|))))) (and (and (and (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@44|)))))) (|$IsA#PagedBetree.BetreeNode| (Lit (PagedBetree.Variables.root (Lit |v#0@@127|))))) (and (PagedBetree.Path.Path_q (Lit (PagedBetree.Step.path (Lit |step#0@@44|)))) (PagedBetree.Variables.Variables_q (Lit |v#0@@127|)))) (=> (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@44|)))) (PagedBetree.Variables.root (Lit |v#0@@127|))) (and (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@82|)) (|$IsA#PagedBetree.Variables| (let ((|dt_update_tmp#0#1@@26| (Lit |v#0@@127|)))
(let ((|dt_update#root#0#1@@17| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))) (Lit (PagedBetree.__default.CompactedNode (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))))) (Lit (PagedBetree.Step.compactedBuffers (Lit |step#0@@44|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@26|)) |dt_update#root#0#1@@17|)))))) (let ((|dt_update_tmp#0#1@@27| (Lit |v#0@@127|)))
 (and (and (and (|PagedBetree.Path.Target#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@44|)))) (|PagedBetree.__default.CompactedNode#canCall| (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))))) (Lit (PagedBetree.Step.compactedBuffers (Lit |step#0@@44|))))) (|PagedBetree.Path.Substitute#canCall| (Lit (PagedBetree.Step.path (Lit |step#0@@44|))) (Lit (PagedBetree.__default.CompactedNode (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))))) (Lit (PagedBetree.Step.compactedBuffers (Lit |step#0@@44|))))))) (PagedBetree.Variables.Variables_q |dt_update_tmp#0#1@@27|)))))))) (= (PagedBetree.__default.InternalCompact (Lit |v#0@@127|) (Lit |v'#0@@82|) (Lit |lbl#0@@86|) (Lit |step#0@@44|))  (and (and (and (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@86|)) (PagedBetree.Step.InternalCompactStep_q (Lit |step#0@@44|))) (|PagedBetree.BetreeNode#Equal| (PagedBetree.Path.node (Lit (PagedBetree.Step.path (Lit |step#0@@44|)))) (PagedBetree.Variables.root (Lit |v#0@@127|)))) (|PagedBetree.Variables#Equal| |v'#0@@82| (let ((|dt_update_tmp#0#1@@28| (Lit |v#0@@127|)))
(let ((|dt_update#root#0#1@@18| (Lit (PagedBetree.Path.Substitute ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))) (Lit (PagedBetree.__default.CompactedNode (Lit (PagedBetree.Path.Target ($LS $LZ) (Lit (PagedBetree.Step.path (Lit |step#0@@44|))))) (Lit (PagedBetree.Step.compactedBuffers (Lit |step#0@@44|)))))))))
(Lit (|#PagedBetree.Variables.Variables| (Lit (PagedBetree.Variables.memtable |dt_update_tmp#0#1@@28|)) |dt_update#root#0#1@@18|)))))))))
 :qid |PagedBetreeidfy.404:29|
 :weight 3
 :skolemid |7639|
 :pattern ( (PagedBetree.__default.InternalCompact (Lit |v#0@@127|) (Lit |v'#0@@82|) (Lit |lbl#0@@86|) (Lit |step#0@@44|)))
))))
(assert  (=> true (forall ((|v#0@@128| T@U) (|v'#0@@83| T@U) (|lbl#0@@87| T@U) ) (!  (=> (and (and (and (= (type |v#0@@128|) DatatypeTypeType) (= (type |v'#0@@83|) DatatypeTypeType)) (= (type |lbl#0@@87|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalNoOp#canCall| |v#0@@128| |v'#0@@83| |lbl#0@@87|) (and (and ($Is |v#0@@128| Tclass.PagedBetree.Variables) ($Is |v'#0@@83| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@87| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.415:26|
 :skolemid |7640|
 :pattern ( (PagedBetree.__default.InternalNoOp |v#0@@128| |v'#0@@83| |lbl#0@@87|))
))))
(assert (forall ((|v#0@@129| T@U) (|v'#0@@84| T@U) (|lbl#0@@88| T@U) ) (!  (=> (and (and (and (= (type |v#0@@129|) DatatypeTypeType) (= (type |v'#0@@84|) DatatypeTypeType)) (= (type |lbl#0@@88|) DatatypeTypeType)) (and (and ($Is |v#0@@129| Tclass.PagedBetree.Variables) ($Is |v'#0@@84| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@88| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.InternalNoOp#requires| |v#0@@129| |v'#0@@84| |lbl#0@@88|) true))
 :qid |PagedBetreeidfy.415:26|
 :skolemid |7641|
 :pattern ( (|PagedBetree.__default.InternalNoOp#requires| |v#0@@129| |v'#0@@84| |lbl#0@@88|))
)))
(assert  (=> true (forall ((|v#0@@130| T@U) (|v'#0@@85| T@U) (|lbl#0@@89| T@U) ) (!  (=> (and (and (and (= (type |v#0@@130|) DatatypeTypeType) (= (type |v'#0@@85|) DatatypeTypeType)) (= (type |lbl#0@@89|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalNoOp#canCall| |v#0@@130| |v'#0@@85| |lbl#0@@89|) (and (and ($Is |v#0@@130| Tclass.PagedBetree.Variables) ($Is |v'#0@@85| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@89| Tclass.PagedBetree.TransitionLabel)))) (and (=> (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@89|) (and (|PagedBetree.Variables.WF#canCall| |v#0@@130|) (=> (PagedBetree.Variables.WF |v#0@@130|) (and (|$IsA#PagedBetree.Variables| |v'#0@@85|) (|$IsA#PagedBetree.Variables| |v#0@@130|))))) (= (PagedBetree.__default.InternalNoOp |v#0@@130| |v'#0@@85| |lbl#0@@89|)  (and (and (PagedBetree.TransitionLabel.InternalLabel_q |lbl#0@@89|) (PagedBetree.Variables.WF |v#0@@130|)) (|PagedBetree.Variables#Equal| |v'#0@@85| |v#0@@130|)))))
 :qid |PagedBetreeidfy.415:26|
 :skolemid |7642|
 :pattern ( (PagedBetree.__default.InternalNoOp |v#0@@130| |v'#0@@85| |lbl#0@@89|))
))))
(assert  (=> true (forall ((|v#0@@131| T@U) (|v'#0@@86| T@U) (|lbl#0@@90| T@U) ) (!  (=> (and (and (and (= (type |v#0@@131|) DatatypeTypeType) (= (type |v'#0@@86|) DatatypeTypeType)) (= (type |lbl#0@@90|) DatatypeTypeType)) (or (|PagedBetree.__default.InternalNoOp#canCall| (Lit |v#0@@131|) (Lit |v'#0@@86|) (Lit |lbl#0@@90|)) (and (and ($Is |v#0@@131| Tclass.PagedBetree.Variables) ($Is |v'#0@@86| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@90| Tclass.PagedBetree.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@90|))))) (and (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@131|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@131|))))) (and (|$IsA#PagedBetree.Variables| (Lit |v'#0@@86|)) (|$IsA#PagedBetree.Variables| (Lit |v#0@@131|)))))) (= (PagedBetree.__default.InternalNoOp (Lit |v#0@@131|) (Lit |v'#0@@86|) (Lit |lbl#0@@90|))  (and (and (PagedBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@90|)) (PagedBetree.Variables.WF (Lit |v#0@@131|))) (|PagedBetree.Variables#Equal| |v'#0@@86| |v#0@@131|)))))
 :qid |PagedBetreeidfy.415:26|
 :weight 3
 :skolemid |7643|
 :pattern ( (PagedBetree.__default.InternalNoOp (Lit |v#0@@131|) (Lit |v'#0@@86|) (Lit |lbl#0@@90|)))
))))
(assert  (=> true (forall ((|v#0@@132| T@U) (|stampedBetree#0@@8| T@U) ) (!  (=> (and (and (= (type |v#0@@132|) DatatypeTypeType) (= (type |stampedBetree#0@@8|) DatatypeTypeType)) (or (|PagedBetree.__default.Init#canCall| |v#0@@132| |stampedBetree#0@@8|) (and ($Is |v#0@@132| Tclass.PagedBetree.Variables) ($Is |stampedBetree#0@@8| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))))) true)
 :qid |PagedBetreeidfy.424:18|
 :skolemid |7644|
 :pattern ( (PagedBetree.__default.Init |v#0@@132| |stampedBetree#0@@8|))
))))
(assert (forall ((|v#0@@133| T@U) (|stampedBetree#0@@9| T@U) ) (!  (=> (and (and (= (type |v#0@@133|) DatatypeTypeType) (= (type |stampedBetree#0@@9|) DatatypeTypeType)) (and ($Is |v#0@@133| Tclass.PagedBetree.Variables) ($Is |stampedBetree#0@@9| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)))) (= (|PagedBetree.__default.Init#requires| |v#0@@133| |stampedBetree#0@@9|) true))
 :qid |PagedBetreeidfy.424:18|
 :skolemid |7645|
 :pattern ( (|PagedBetree.__default.Init#requires| |v#0@@133| |stampedBetree#0@@9|))
)))
(assert  (=> true (forall ((|v#0@@134| T@U) (|stampedBetree#0@@10| T@U) ) (!  (=> (and (and (= (type |v#0@@134|) DatatypeTypeType) (= (type |stampedBetree#0@@10|) DatatypeTypeType)) (or (|PagedBetree.__default.Init#canCall| |v#0@@134| |stampedBetree#0@@10|) (and ($Is |v#0@@134| Tclass.PagedBetree.Variables) ($Is |stampedBetree#0@@10| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))))) (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@10|) (|PagedBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@10|)))) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@10|))) (and (|$IsA#PagedBetree.Variables| |v#0@@134|) (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@10|) (|MemtableMod.__default.EmptyMemtable#canCall| (StampedMod.Stamped.seqEnd |stampedBetree#0@@10|))) (StampedMod.Stamped.Stamped_q |stampedBetree#0@@10|))))) (= (PagedBetree.__default.Init |v#0@@134| |stampedBetree#0@@10|)  (and (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@10|))) (|PagedBetree.Variables#Equal| |v#0@@134| (|#PagedBetree.Variables.Variables| (MemtableMod.__default.EmptyMemtable (StampedMod.Stamped.seqEnd |stampedBetree#0@@10|)) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@10|))))))))
 :qid |PagedBetreeidfy.424:18|
 :skolemid |7646|
 :pattern ( (PagedBetree.__default.Init |v#0@@134| |stampedBetree#0@@10|))
))))
(assert  (=> true (forall ((|v#0@@135| T@U) (|stampedBetree#0@@11| T@U) ) (!  (=> (and (and (= (type |v#0@@135|) DatatypeTypeType) (= (type |stampedBetree#0@@11|) DatatypeTypeType)) (or (|PagedBetree.__default.Init#canCall| (Lit |v#0@@135|) (Lit |stampedBetree#0@@11|)) (and ($Is |v#0@@135| Tclass.PagedBetree.Variables) ($Is |stampedBetree#0@@11| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))))) (and (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@11|)) (|PagedBetree.BetreeNode.WF#canCall| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@11|)))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@11|)))))))) (and (|$IsA#PagedBetree.Variables| (Lit |v#0@@135|)) (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@11|)) (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@11|))))) (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@11|)))))) (= (PagedBetree.__default.Init (Lit |v#0@@135|) (Lit |stampedBetree#0@@11|))  (and (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@11|))))) (|PagedBetree.Variables#Equal| |v#0@@135| (|#PagedBetree.Variables.Variables| (Lit (MemtableMod.__default.EmptyMemtable (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@11|))))) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@11|))))))))))
 :qid |PagedBetreeidfy.424:18|
 :weight 3
 :skolemid |7647|
 :pattern ( (PagedBetree.__default.Init (Lit |v#0@@135|) (Lit |stampedBetree#0@@11|)))
))))
(assert  (=> true (forall ((|v#0@@136| T@U) (|v'#0@@87| T@U) (|lbl#0@@91| T@U) (|step#0@@45| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@136|) DatatypeTypeType) (= (type |v'#0@@87|) DatatypeTypeType)) (= (type |lbl#0@@91|) DatatypeTypeType)) (= (type |step#0@@45|) DatatypeTypeType)) (or (|PagedBetree.__default.NextStep#canCall| |v#0@@136| |v'#0@@87| |lbl#0@@91| |step#0@@45|) (and (and (and ($Is |v#0@@136| Tclass.PagedBetree.Variables) ($Is |v'#0@@87| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@91| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@45| Tclass.PagedBetree.Step)))) true)
 :qid |PagedBetreeidfy.455:22|
 :skolemid |7648|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@136| |v'#0@@87| |lbl#0@@91| |step#0@@45|))
))))
(assert (forall ((|v#0@@137| T@U) (|v'#0@@88| T@U) (|lbl#0@@92| T@U) (|step#0@@46| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@137|) DatatypeTypeType) (= (type |v'#0@@88|) DatatypeTypeType)) (= (type |lbl#0@@92|) DatatypeTypeType)) (= (type |step#0@@46|) DatatypeTypeType)) (and (and (and ($Is |v#0@@137| Tclass.PagedBetree.Variables) ($Is |v'#0@@88| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@92| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@46| Tclass.PagedBetree.Step))) (= (|PagedBetree.__default.NextStep#requires| |v#0@@137| |v'#0@@88| |lbl#0@@92| |step#0@@46|) true))
 :qid |PagedBetreeidfy.455:22|
 :skolemid |7649|
 :pattern ( (|PagedBetree.__default.NextStep#requires| |v#0@@137| |v'#0@@88| |lbl#0@@92| |step#0@@46|))
)))
(assert  (=> true (forall ((|v#0@@138| T@U) (|v'#0@@89| T@U) (|lbl#0@@93| T@U) (|step#0@@47| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@138|) DatatypeTypeType) (= (type |v'#0@@89|) DatatypeTypeType)) (= (type |lbl#0@@93|) DatatypeTypeType)) (= (type |step#0@@47|) DatatypeTypeType)) (or (|PagedBetree.__default.NextStep#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|) (and (and (and ($Is |v#0@@138| Tclass.PagedBetree.Variables) ($Is |v'#0@@89| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@93| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@47| Tclass.PagedBetree.Step)))) (and (and (|PagedBetree.Step.WF#canCall| |step#0@@47|) (=> (PagedBetree.Step.WF |step#0@@47|) (and (=> (PagedBetree.Step.QueryStep_q |step#0@@47|) (let ((|receipt#1@@2| (PagedBetree.Step.receipt |step#0@@47|)))
(|PagedBetree.__default.Query#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93| |receipt#1@@2|))) (=> (not (PagedBetree.Step.QueryStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.PutStep_q |step#0@@47|) (|PagedBetree.__default.Put#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|)) (=> (not (PagedBetree.Step.PutStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.QueryEndLsnStep_q |step#0@@47|) (|PagedBetree.__default.QueryEndLsn#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|)) (=> (not (PagedBetree.Step.QueryEndLsnStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.FreezeAsStep_q |step#0@@47|) (|PagedBetree.__default.FreezeAs#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|)) (=> (not (PagedBetree.Step.FreezeAsStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.InternalGrowStep_q |step#0@@47|) (|PagedBetree.__default.InternalGrow#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|)) (=> (not (PagedBetree.Step.InternalGrowStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.InternalSplitStep_q |step#0@@47|) (|PagedBetree.__default.InternalSplit#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|)) (=> (not (PagedBetree.Step.InternalSplitStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.InternalFlushMemtableStep_q |step#0@@47|) (|PagedBetree.__default.InternalFlushMemtable#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|)) (=> (not (PagedBetree.Step.InternalFlushMemtableStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.InternalFlushStep_q |step#0@@47|) (|PagedBetree.__default.InternalFlush#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|)) (=> (not (PagedBetree.Step.InternalFlushStep_q |step#0@@47|)) (and (=> (PagedBetree.Step.InternalCompactStep_q |step#0@@47|) (|PagedBetree.__default.InternalCompact#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|)) (=> (not (PagedBetree.Step.InternalCompactStep_q |step#0@@47|)) (|PagedBetree.__default.InternalNoOp#canCall| |v#0@@138| |v'#0@@89| |lbl#0@@93|))))))))))))))))))))) (= (PagedBetree.__default.NextStep |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|)  (and (PagedBetree.Step.WF |step#0@@47|) (ite (PagedBetree.Step.QueryStep_q |step#0@@47|) (let ((|receipt#0@@14| (PagedBetree.Step.receipt |step#0@@47|)))
(PagedBetree.__default.Query |v#0@@138| |v'#0@@89| |lbl#0@@93| |receipt#0@@14|)) (ite (PagedBetree.Step.PutStep_q |step#0@@47|) (PagedBetree.__default.Put |v#0@@138| |v'#0@@89| |lbl#0@@93|) (ite (PagedBetree.Step.QueryEndLsnStep_q |step#0@@47|) (PagedBetree.__default.QueryEndLsn |v#0@@138| |v'#0@@89| |lbl#0@@93|) (ite (PagedBetree.Step.FreezeAsStep_q |step#0@@47|) (PagedBetree.__default.FreezeAs |v#0@@138| |v'#0@@89| |lbl#0@@93|) (ite (PagedBetree.Step.InternalGrowStep_q |step#0@@47|) (PagedBetree.__default.InternalGrow |v#0@@138| |v'#0@@89| |lbl#0@@93|) (ite (PagedBetree.Step.InternalSplitStep_q |step#0@@47|) (PagedBetree.__default.InternalSplit |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|) (ite (PagedBetree.Step.InternalFlushMemtableStep_q |step#0@@47|) (PagedBetree.__default.InternalFlushMemtable |v#0@@138| |v'#0@@89| |lbl#0@@93|) (ite (PagedBetree.Step.InternalFlushStep_q |step#0@@47|) (PagedBetree.__default.InternalFlush |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|) (ite (PagedBetree.Step.InternalCompactStep_q |step#0@@47|) (PagedBetree.__default.InternalCompact |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|) (PagedBetree.__default.InternalNoOp |v#0@@138| |v'#0@@89| |lbl#0@@93|))))))))))))))
 :qid |PagedBetreeidfy.455:22|
 :skolemid |7650|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@138| |v'#0@@89| |lbl#0@@93| |step#0@@47|))
))))
(assert  (=> true (forall ((|v#0@@139| T@U) (|v'#0@@90| T@U) (|lbl#0@@94| T@U) (|step#0@@48| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@139|) DatatypeTypeType) (= (type |v'#0@@90|) DatatypeTypeType)) (= (type |lbl#0@@94|) DatatypeTypeType)) (= (type |step#0@@48|) DatatypeTypeType)) (or (|PagedBetree.__default.NextStep#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|)) (and (and (and ($Is |v#0@@139| Tclass.PagedBetree.Variables) ($Is |v'#0@@90| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@94| Tclass.PagedBetree.TransitionLabel)) ($Is |step#0@@48| Tclass.PagedBetree.Step)))) (and (and (|PagedBetree.Step.WF#canCall| (Lit |step#0@@48|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.WF (Lit |step#0@@48|))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryStep_q (Lit |step#0@@48|))))) (let ((|receipt#3@@2| (Lit (PagedBetree.Step.receipt (Lit |step#0@@48|)))))
(|PagedBetree.__default.Query#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) |receipt#3@@2|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.PutStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.Put#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.PutStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryEndLsnStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.QueryEndLsnStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.FreezeAsStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.FreezeAs#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.FreezeAsStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalGrowStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.InternalGrow#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalGrowStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.InternalSplit#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalSplitStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.InternalFlush#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalFlushStep_q (Lit |step#0@@48|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalCompactStep_q (Lit |step#0@@48|))))) (|PagedBetree.__default.InternalCompact#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.Step.InternalCompactStep_q (Lit |step#0@@48|)))))) (|PagedBetree.__default.InternalNoOp#canCall| (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)))))))))))))))))))))) (= (PagedBetree.__default.NextStep (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|))  (and (PagedBetree.Step.WF (Lit |step#0@@48|)) (ite (PagedBetree.Step.QueryStep_q (Lit |step#0@@48|)) (U_2_bool (let ((|receipt#2@@2| (Lit (PagedBetree.Step.receipt (Lit |step#0@@48|)))))
(Lit (bool_2_U (PagedBetree.__default.Query (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) |receipt#2@@2|))))) (ite (PagedBetree.Step.PutStep_q (Lit |step#0@@48|)) (PagedBetree.__default.Put (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)) (ite (PagedBetree.Step.QueryEndLsnStep_q (Lit |step#0@@48|)) (PagedBetree.__default.QueryEndLsn (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)) (ite (PagedBetree.Step.FreezeAsStep_q (Lit |step#0@@48|)) (PagedBetree.__default.FreezeAs (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)) (ite (PagedBetree.Step.InternalGrowStep_q (Lit |step#0@@48|)) (PagedBetree.__default.InternalGrow (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)) (ite (PagedBetree.Step.InternalSplitStep_q (Lit |step#0@@48|)) (PagedBetree.__default.InternalSplit (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|)) (ite (PagedBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@48|)) (PagedBetree.__default.InternalFlushMemtable (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)) (ite (PagedBetree.Step.InternalFlushStep_q (Lit |step#0@@48|)) (PagedBetree.__default.InternalFlush (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|)) (ite (PagedBetree.Step.InternalCompactStep_q (Lit |step#0@@48|)) (PagedBetree.__default.InternalCompact (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|)) (PagedBetree.__default.InternalNoOp (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|)))))))))))))))
 :qid |PagedBetreeidfy.455:22|
 :weight 3
 :skolemid |7651|
 :pattern ( (PagedBetree.__default.NextStep (Lit |v#0@@139|) (Lit |v'#0@@90|) (Lit |lbl#0@@94|) (Lit |step#0@@48|)))
))))
(assert  (=> true (forall ((|v#0@@140| T@U) (|v'#0@@91| T@U) (|lbl#0@@95| T@U) ) (!  (=> (and (and (and (= (type |v#0@@140|) DatatypeTypeType) (= (type |v'#0@@91|) DatatypeTypeType)) (= (type |lbl#0@@95|) DatatypeTypeType)) (or (|PagedBetree.__default.Next#canCall| |v#0@@140| |v'#0@@91| |lbl#0@@95|) (and (and ($Is |v#0@@140| Tclass.PagedBetree.Variables) ($Is |v'#0@@91| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@95| Tclass.PagedBetree.TransitionLabel)))) true)
 :qid |PagedBetreeidfy.472:18|
 :skolemid |7652|
 :pattern ( (PagedBetree.__default.Next |v#0@@140| |v'#0@@91| |lbl#0@@95|))
))))
(assert (forall ((|v#0@@141| T@U) (|v'#0@@92| T@U) (|lbl#0@@96| T@U) ) (!  (=> (and (and (and (= (type |v#0@@141|) DatatypeTypeType) (= (type |v'#0@@92|) DatatypeTypeType)) (= (type |lbl#0@@96|) DatatypeTypeType)) (and (and ($Is |v#0@@141| Tclass.PagedBetree.Variables) ($Is |v'#0@@92| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@96| Tclass.PagedBetree.TransitionLabel))) (= (|PagedBetree.__default.Next#requires| |v#0@@141| |v'#0@@92| |lbl#0@@96|) true))
 :qid |PagedBetreeidfy.472:18|
 :skolemid |7653|
 :pattern ( (|PagedBetree.__default.Next#requires| |v#0@@141| |v'#0@@92| |lbl#0@@96|))
)))
(assert  (=> true (forall ((|v#0@@142| T@U) (|v'#0@@93| T@U) (|lbl#0@@97| T@U) ) (!  (=> (and (and (and (= (type |v#0@@142|) DatatypeTypeType) (= (type |v'#0@@93|) DatatypeTypeType)) (= (type |lbl#0@@97|) DatatypeTypeType)) (or (|PagedBetree.__default.Next#canCall| |v#0@@142| |v'#0@@93| |lbl#0@@97|) (and (and ($Is |v#0@@142| Tclass.PagedBetree.Variables) ($Is |v'#0@@93| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@97| Tclass.PagedBetree.TransitionLabel)))) (and (forall ((|step#0@@49| T@U) ) (!  (=> (and (= (type |step#0@@49|) DatatypeTypeType) ($Is |step#0@@49| Tclass.PagedBetree.Step)) (|PagedBetree.__default.NextStep#canCall| |v#0@@142| |v'#0@@93| |lbl#0@@97| |step#0@@49|))
 :qid |PagedBetreeidfy.473:12|
 :skolemid |7655|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@142| |v'#0@@93| |lbl#0@@97| |step#0@@49|))
)) (= (PagedBetree.__default.Next |v#0@@142| |v'#0@@93| |lbl#0@@97|) (exists ((|step#0@@50| T@U) ) (!  (and (= (type |step#0@@50|) DatatypeTypeType) (and ($Is |step#0@@50| Tclass.PagedBetree.Step) (PagedBetree.__default.NextStep |v#0@@142| |v'#0@@93| |lbl#0@@97| |step#0@@50|)))
 :qid |PagedBetreeidfy.473:12|
 :skolemid |7654|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@142| |v'#0@@93| |lbl#0@@97| |step#0@@50|))
)))))
 :qid |PagedBetreeidfy.472:18|
 :skolemid |7656|
 :pattern ( (PagedBetree.__default.Next |v#0@@142| |v'#0@@93| |lbl#0@@97|))
))))
(assert  (=> true (forall ((|v#0@@143| T@U) (|v'#0@@94| T@U) (|lbl#0@@98| T@U) ) (!  (=> (and (and (and (= (type |v#0@@143|) DatatypeTypeType) (= (type |v'#0@@94|) DatatypeTypeType)) (= (type |lbl#0@@98|) DatatypeTypeType)) (or (|PagedBetree.__default.Next#canCall| (Lit |v#0@@143|) (Lit |v'#0@@94|) (Lit |lbl#0@@98|)) (and (and ($Is |v#0@@143| Tclass.PagedBetree.Variables) ($Is |v'#0@@94| Tclass.PagedBetree.Variables)) ($Is |lbl#0@@98| Tclass.PagedBetree.TransitionLabel)))) (and (forall ((|step#1@@1| T@U) ) (!  (=> (and (= (type |step#1@@1|) DatatypeTypeType) ($Is |step#1@@1| Tclass.PagedBetree.Step)) (|PagedBetree.__default.NextStep#canCall| (Lit |v#0@@143|) (Lit |v'#0@@94|) (Lit |lbl#0@@98|) |step#1@@1|))
 :qid |PagedBetreeidfy.473:12|
 :skolemid |7658|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@143| |v'#0@@94| |lbl#0@@98| |step#1@@1|))
)) (= (PagedBetree.__default.Next (Lit |v#0@@143|) (Lit |v'#0@@94|) (Lit |lbl#0@@98|)) (exists ((|step#1@@2| T@U) ) (!  (and (= (type |step#1@@2|) DatatypeTypeType) (and ($Is |step#1@@2| Tclass.PagedBetree.Step) (PagedBetree.__default.NextStep (Lit |v#0@@143|) (Lit |v'#0@@94|) (Lit |lbl#0@@98|) |step#1@@2|)))
 :qid |PagedBetreeidfy.473:12|
 :skolemid |7657|
 :pattern ( (PagedBetree.__default.NextStep |v#0@@143| |v'#0@@94| |lbl#0@@98| |step#1@@2|))
)))))
 :qid |PagedBetreeidfy.472:18|
 :weight 3
 :skolemid |7659|
 :pattern ( (PagedBetree.__default.Next (Lit |v#0@@143|) (Lit |v'#0@@94|) (Lit |lbl#0@@98|)))
))))
(assert (forall ((arg0@@727 Int) (arg1@@379 T@U) (arg2@@185 T@U) ) (! (= (type (|#AbstractMap.TransitionLabel.QueryLabel| arg0@@727 arg1@@379 arg2@@185)) DatatypeTypeType)
 :qid |funType:#AbstractMap.TransitionLabel.QueryLabel|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| arg0@@727 arg1@@379 arg2@@185))
)))
(assert (forall ((|a#0#0#0@@19| Int) (|a#0#1#0@@13| T@U) (|a#0#2#0@@4| T@U) ) (!  (=> (and (= (type |a#0#1#0@@13|) (SeqType BoxType)) (= (type |a#0#2#0@@4|) (SeqType BoxType))) (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.QueryLabel| |a#0#0#0@@19| |a#0#1#0@@13| |a#0#2#0@@4|)) |##AbstractMap.TransitionLabel.QueryLabel|))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7660|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| |a#0#0#0@@19| |a#0#1#0@@13| |a#0#2#0@@4|))
)))
(assert (forall ((d@@271 T@U) ) (!  (=> (= (type d@@271) DatatypeTypeType) (= (AbstractMap.TransitionLabel.QueryLabel_q d@@271) (= (DatatypeCtorId d@@271) |##AbstractMap.TransitionLabel.QueryLabel|)))
 :qid |unknown.0:0|
 :skolemid |7661|
 :pattern ( (AbstractMap.TransitionLabel.QueryLabel_q d@@271))
)))
(assert (forall ((d@@272 T@U) ) (!  (=> (and (= (type d@@272) DatatypeTypeType) (AbstractMap.TransitionLabel.QueryLabel_q d@@272)) (exists ((|a#1#0#0@@19| Int) (|a#1#1#0@@13| T@U) (|a#1#2#0@@4| T@U) ) (!  (and (and (= (type |a#1#1#0@@13|) (SeqType BoxType)) (= (type |a#1#2#0@@4|) (SeqType BoxType))) (= d@@272 (|#AbstractMap.TransitionLabel.QueryLabel| |a#1#0#0@@19| |a#1#1#0@@13| |a#1#2#0@@4|)))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7662|
 :no-pattern (type |a#1#1#0@@13|)
 :no-pattern (type |a#1#2#0@@4|)
 :no-pattern (U_2_int |a#1#1#0@@13|)
 :no-pattern (U_2_bool |a#1#1#0@@13|)
 :no-pattern (U_2_int |a#1#2#0@@4|)
 :no-pattern (U_2_bool |a#1#2#0@@4|)
)))
 :qid |unknown.0:0|
 :skolemid |7663|
 :pattern ( (AbstractMap.TransitionLabel.QueryLabel_q d@@272))
)))
(assert (= (type Tclass.AbstractMap.TransitionLabel) TyType))
(assert (= (Tag Tclass.AbstractMap.TransitionLabel) Tagclass.AbstractMap.TransitionLabel))
(assert (= (TagFamily Tclass.AbstractMap.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@183 T@U) ) (!  (=> (and (= (type bx@@183) BoxType) ($IsBox bx@@183 Tclass.AbstractMap.TransitionLabel)) (and (= ($Box ($Unbox DatatypeTypeType bx@@183)) bx@@183) ($Is ($Unbox DatatypeTypeType bx@@183) Tclass.AbstractMap.TransitionLabel)))
 :qid |unknown.0:0|
 :skolemid |7664|
 :pattern ( ($IsBox bx@@183 Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((|a#2#0#0@@19| Int) (|a#2#1#0@@13| T@U) (|a#2#2#0@@4| T@U) ) (!  (=> (and (= (type |a#2#1#0@@13|) (SeqType BoxType)) (= (type |a#2#2#0@@4|) (SeqType BoxType))) (= ($Is (|#AbstractMap.TransitionLabel.QueryLabel| |a#2#0#0@@19| |a#2#1#0@@13| |a#2#2#0@@4|) Tclass.AbstractMap.TransitionLabel)  (and (and ($Is (int_2_U |a#2#0#0@@19|) Tclass._System.nat) ($Is |a#2#1#0@@13| Tclass.KeyType.Key)) ($Is |a#2#2#0@@4| Tclass.ValueType.Value))))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7665|
 :pattern ( ($Is (|#AbstractMap.TransitionLabel.QueryLabel| |a#2#0#0@@19| |a#2#1#0@@13| |a#2#2#0@@4|) Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((|a#3#0#0@@19| Int) (|a#3#1#0@@13| T@U) (|a#3#2#0@@4| T@U) ($h@@231 T@U) ) (!  (=> (and (and (and (= (type |a#3#1#0@@13|) (SeqType BoxType)) (= (type |a#3#2#0@@4|) (SeqType BoxType))) (= (type $h@@231) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@231)) (= ($IsAlloc (|#AbstractMap.TransitionLabel.QueryLabel| |a#3#0#0@@19| |a#3#1#0@@13| |a#3#2#0@@4|) Tclass.AbstractMap.TransitionLabel $h@@231)  (and (and ($IsAlloc (int_2_U |a#3#0#0@@19|) Tclass._System.nat $h@@231) ($IsAlloc |a#3#1#0@@13| Tclass.KeyType.Key $h@@231)) ($IsAlloc |a#3#2#0@@4| Tclass.ValueType.Value $h@@231))))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7666|
 :pattern ( ($IsAlloc (|#AbstractMap.TransitionLabel.QueryLabel| |a#3#0#0@@19| |a#3#1#0@@13| |a#3#2#0@@4|) Tclass.AbstractMap.TransitionLabel $h@@231))
)))
(assert (forall ((d@@273 T@U) ($h@@232 T@U) ) (!  (=> (and (and (= (type d@@273) DatatypeTypeType) (= (type $h@@232) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@232) (and (AbstractMap.TransitionLabel.QueryLabel_q d@@273) ($IsAlloc d@@273 Tclass.AbstractMap.TransitionLabel $h@@232)))) ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@273)) Tclass._System.nat $h@@232))
 :qid |unknown.0:0|
 :skolemid |7667|
 :pattern ( ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@273)) Tclass._System.nat $h@@232))
)))
(assert (forall ((arg0@@728 T@U) ) (! (= (type (AbstractMap.TransitionLabel.key arg0@@728)) (SeqType BoxType))
 :qid |funType:AbstractMap.TransitionLabel.key|
 :pattern ( (AbstractMap.TransitionLabel.key arg0@@728))
)))
(assert (forall ((d@@274 T@U) ($h@@233 T@U) ) (!  (=> (and (and (= (type d@@274) DatatypeTypeType) (= (type $h@@233) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@233) (and (AbstractMap.TransitionLabel.QueryLabel_q d@@274) ($IsAlloc d@@274 Tclass.AbstractMap.TransitionLabel $h@@233)))) ($IsAlloc (AbstractMap.TransitionLabel.key d@@274) Tclass.KeyType.Key $h@@233))
 :qid |unknown.0:0|
 :skolemid |7668|
 :pattern ( ($IsAlloc (AbstractMap.TransitionLabel.key d@@274) Tclass.KeyType.Key $h@@233))
)))
(assert (forall ((arg0@@729 T@U) ) (! (= (type (AbstractMap.TransitionLabel.value arg0@@729)) (SeqType BoxType))
 :qid |funType:AbstractMap.TransitionLabel.value|
 :pattern ( (AbstractMap.TransitionLabel.value arg0@@729))
)))
(assert (forall ((d@@275 T@U) ($h@@234 T@U) ) (!  (=> (and (and (= (type d@@275) DatatypeTypeType) (= (type $h@@234) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@234) (and (AbstractMap.TransitionLabel.QueryLabel_q d@@275) ($IsAlloc d@@275 Tclass.AbstractMap.TransitionLabel $h@@234)))) ($IsAlloc (AbstractMap.TransitionLabel.value d@@275) Tclass.ValueType.Value $h@@234))
 :qid |unknown.0:0|
 :skolemid |7669|
 :pattern ( ($IsAlloc (AbstractMap.TransitionLabel.value d@@275) Tclass.ValueType.Value $h@@234))
)))
(assert (forall ((|a#4#0#0@@19| Int) (|a#4#1#0@@13| T@U) (|a#4#2#0@@4| T@U) ) (!  (=> (and (= (type |a#4#1#0@@13|) (SeqType BoxType)) (= (type |a#4#2#0@@4|) (SeqType BoxType))) (= (|#AbstractMap.TransitionLabel.QueryLabel| (LitInt |a#4#0#0@@19|) (Lit |a#4#1#0@@13|) (Lit |a#4#2#0@@4|)) (Lit (|#AbstractMap.TransitionLabel.QueryLabel| |a#4#0#0@@19| |a#4#1#0@@13| |a#4#2#0@@4|))))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7670|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| (LitInt |a#4#0#0@@19|) (Lit |a#4#1#0@@13|) (Lit |a#4#2#0@@4|)))
)))
(assert (forall ((|a#5#0#0@@22| Int) (|a#5#1#0@@15| T@U) (|a#5#2#0@@4| T@U) ) (!  (=> (and (= (type |a#5#1#0@@15|) (SeqType BoxType)) (= (type |a#5#2#0@@4|) (SeqType BoxType))) (= (AbstractMap.TransitionLabel.endLsn (|#AbstractMap.TransitionLabel.QueryLabel| |a#5#0#0@@22| |a#5#1#0@@15| |a#5#2#0@@4|)) |a#5#0#0@@22|))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7671|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| |a#5#0#0@@22| |a#5#1#0@@15| |a#5#2#0@@4|))
)))
(assert (forall ((|a#6#0#0@@22| Int) (|a#6#1#0@@15| T@U) (|a#6#2#0@@4| T@U) ) (!  (=> (and (= (type |a#6#1#0@@15|) (SeqType BoxType)) (= (type |a#6#2#0@@4|) (SeqType BoxType))) (= (AbstractMap.TransitionLabel.key (|#AbstractMap.TransitionLabel.QueryLabel| |a#6#0#0@@22| |a#6#1#0@@15| |a#6#2#0@@4|)) |a#6#1#0@@15|))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7672|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| |a#6#0#0@@22| |a#6#1#0@@15| |a#6#2#0@@4|))
)))
(assert (forall ((|a#7#0#0@@20| Int) (|a#7#1#0@@15| T@U) (|a#7#2#0@@4| T@U) ) (!  (=> (and (= (type |a#7#1#0@@15|) (SeqType BoxType)) (= (type |a#7#2#0@@4|) (SeqType BoxType))) (= (AbstractMap.TransitionLabel.value (|#AbstractMap.TransitionLabel.QueryLabel| |a#7#0#0@@20| |a#7#1#0@@15| |a#7#2#0@@4|)) |a#7#2#0@@4|))
 :qid |AbstractMapidfy.16:18|
 :skolemid |7673|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryLabel| |a#7#0#0@@20| |a#7#1#0@@15| |a#7#2#0@@4|))
)))
(assert (forall ((arg0@@730 T@U) ) (! (= (type (|#AbstractMap.TransitionLabel.PutLabel| arg0@@730)) DatatypeTypeType)
 :qid |funType:#AbstractMap.TransitionLabel.PutLabel|
 :pattern ( (|#AbstractMap.TransitionLabel.PutLabel| arg0@@730))
)))
(assert (forall ((|a#8#0#0@@16| T@U) ) (!  (=> (= (type |a#8#0#0@@16|) DatatypeTypeType) (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.PutLabel| |a#8#0#0@@16|)) |##AbstractMap.TransitionLabel.PutLabel|))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7674|
 :pattern ( (|#AbstractMap.TransitionLabel.PutLabel| |a#8#0#0@@16|))
)))
(assert (forall ((d@@276 T@U) ) (!  (=> (= (type d@@276) DatatypeTypeType) (= (AbstractMap.TransitionLabel.PutLabel_q d@@276) (= (DatatypeCtorId d@@276) |##AbstractMap.TransitionLabel.PutLabel|)))
 :qid |unknown.0:0|
 :skolemid |7675|
 :pattern ( (AbstractMap.TransitionLabel.PutLabel_q d@@276))
)))
(assert (forall ((d@@277 T@U) ) (!  (=> (and (= (type d@@277) DatatypeTypeType) (AbstractMap.TransitionLabel.PutLabel_q d@@277)) (exists ((|a#9#0#0@@9| T@U) ) (!  (and (= (type |a#9#0#0@@9|) DatatypeTypeType) (= d@@277 (|#AbstractMap.TransitionLabel.PutLabel| |a#9#0#0@@9|)))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7676|
 :no-pattern (type |a#9#0#0@@9|)
 :no-pattern (U_2_int |a#9#0#0@@9|)
 :no-pattern (U_2_bool |a#9#0#0@@9|)
)))
 :qid |unknown.0:0|
 :skolemid |7677|
 :pattern ( (AbstractMap.TransitionLabel.PutLabel_q d@@277))
)))
(assert (forall ((|a#10#0#0@@9| T@U) ) (!  (=> (= (type |a#10#0#0@@9|) DatatypeTypeType) (= ($Is (|#AbstractMap.TransitionLabel.PutLabel| |a#10#0#0@@9|) Tclass.AbstractMap.TransitionLabel) ($Is |a#10#0#0@@9| Tclass.MsgHistoryMod.MsgHistory)))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7678|
 :pattern ( ($Is (|#AbstractMap.TransitionLabel.PutLabel| |a#10#0#0@@9|) Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((|a#11#0#0@@6| T@U) ($h@@235 T@U) ) (!  (=> (and (and (= (type |a#11#0#0@@6|) DatatypeTypeType) (= (type $h@@235) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@235)) (= ($IsAlloc (|#AbstractMap.TransitionLabel.PutLabel| |a#11#0#0@@6|) Tclass.AbstractMap.TransitionLabel $h@@235) ($IsAlloc |a#11#0#0@@6| Tclass.MsgHistoryMod.MsgHistory $h@@235)))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7679|
 :pattern ( ($IsAlloc (|#AbstractMap.TransitionLabel.PutLabel| |a#11#0#0@@6|) Tclass.AbstractMap.TransitionLabel $h@@235))
)))
(assert (forall ((arg0@@731 T@U) ) (! (= (type (AbstractMap.TransitionLabel.puts arg0@@731)) DatatypeTypeType)
 :qid |funType:AbstractMap.TransitionLabel.puts|
 :pattern ( (AbstractMap.TransitionLabel.puts arg0@@731))
)))
(assert (forall ((d@@278 T@U) ($h@@236 T@U) ) (!  (=> (and (and (= (type d@@278) DatatypeTypeType) (= (type $h@@236) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@236) (and (AbstractMap.TransitionLabel.PutLabel_q d@@278) ($IsAlloc d@@278 Tclass.AbstractMap.TransitionLabel $h@@236)))) ($IsAlloc (AbstractMap.TransitionLabel.puts d@@278) Tclass.MsgHistoryMod.MsgHistory $h@@236))
 :qid |unknown.0:0|
 :skolemid |7680|
 :pattern ( ($IsAlloc (AbstractMap.TransitionLabel.puts d@@278) Tclass.MsgHistoryMod.MsgHistory $h@@236))
)))
(assert (forall ((|a#12#0#0@@5| T@U) ) (!  (=> (= (type |a#12#0#0@@5|) DatatypeTypeType) (= (|#AbstractMap.TransitionLabel.PutLabel| (Lit |a#12#0#0@@5|)) (Lit (|#AbstractMap.TransitionLabel.PutLabel| |a#12#0#0@@5|))))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7681|
 :pattern ( (|#AbstractMap.TransitionLabel.PutLabel| (Lit |a#12#0#0@@5|)))
)))
(assert (forall ((|a#13#0#0@@4| T@U) ) (!  (=> (= (type |a#13#0#0@@4|) DatatypeTypeType) (= (AbstractMap.TransitionLabel.puts (|#AbstractMap.TransitionLabel.PutLabel| |a#13#0#0@@4|)) |a#13#0#0@@4|))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7682|
 :pattern ( (|#AbstractMap.TransitionLabel.PutLabel| |a#13#0#0@@4|))
)))
(assert (forall ((|a#14#0#0@@3| T@U) ) (!  (=> (= (type |a#14#0#0@@3|) DatatypeTypeType) (< (DtRank |a#14#0#0@@3|) (DtRank (|#AbstractMap.TransitionLabel.PutLabel| |a#14#0#0@@3|))))
 :qid |AbstractMapidfy.17:16|
 :skolemid |7683|
 :pattern ( (|#AbstractMap.TransitionLabel.PutLabel| |a#14#0#0@@3|))
)))
(assert (forall ((arg0@@732 Int) ) (! (= (type (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| arg0@@732)) DatatypeTypeType)
 :qid |funType:#AbstractMap.TransitionLabel.QueryEndLsnLabel|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| arg0@@732))
)))
(assert (forall ((|a#15#0#0@@3| Int) ) (! (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@3|)) |##AbstractMap.TransitionLabel.QueryEndLsnLabel|)
 :qid |AbstractMapidfy.18:24|
 :skolemid |7684|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#15#0#0@@3|))
)))
(assert (forall ((d@@279 T@U) ) (!  (=> (= (type d@@279) DatatypeTypeType) (= (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@279) (= (DatatypeCtorId d@@279) |##AbstractMap.TransitionLabel.QueryEndLsnLabel|)))
 :qid |unknown.0:0|
 :skolemid |7685|
 :pattern ( (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@279))
)))
(assert (forall ((d@@280 T@U) ) (!  (=> (and (= (type d@@280) DatatypeTypeType) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@280)) (exists ((|a#16#0#0@@3| Int) ) (! (= d@@280 (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#16#0#0@@3|))
 :qid |AbstractMapidfy.18:24|
 :skolemid |7686|
)))
 :qid |unknown.0:0|
 :skolemid |7687|
 :pattern ( (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@280))
)))
(assert (forall ((|a#17#0#0@@3| Int) ) (! (= ($Is (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@3|) Tclass.AbstractMap.TransitionLabel) ($Is (int_2_U |a#17#0#0@@3|) Tclass._System.nat))
 :qid |AbstractMapidfy.18:24|
 :skolemid |7688|
 :pattern ( ($Is (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#17#0#0@@3|) Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((|a#18#0#0@@2| Int) ($h@@237 T@U) ) (!  (=> (and (= (type $h@@237) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@237)) (= ($IsAlloc (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#18#0#0@@2|) Tclass.AbstractMap.TransitionLabel $h@@237) ($IsAlloc (int_2_U |a#18#0#0@@2|) Tclass._System.nat $h@@237)))
 :qid |AbstractMapidfy.18:24|
 :skolemid |7689|
 :pattern ( ($IsAlloc (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#18#0#0@@2|) Tclass.AbstractMap.TransitionLabel $h@@237))
)))
(assert (forall ((d@@281 T@U) ($h@@238 T@U) ) (!  (=> (and (and (= (type d@@281) DatatypeTypeType) (= (type $h@@238) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@238) (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@281) ($IsAlloc d@@281 Tclass.AbstractMap.TransitionLabel $h@@238)))) ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@281)) Tclass._System.nat $h@@238))
 :qid |unknown.0:0|
 :skolemid |7690|
 :pattern ( ($IsAlloc (int_2_U (AbstractMap.TransitionLabel.endLsn d@@281)) Tclass._System.nat $h@@238))
)))
(assert (forall ((|a#19#0#0@@2| Int) ) (! (= (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@2|)) (Lit (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#19#0#0@@2|)))
 :qid |AbstractMapidfy.18:24|
 :skolemid |7691|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| (LitInt |a#19#0#0@@2|)))
)))
(assert (forall ((|a#20#0#0@@2| Int) ) (! (= (AbstractMap.TransitionLabel.endLsn (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@2|)) |a#20#0#0@@2|)
 :qid |AbstractMapidfy.18:24|
 :skolemid |7692|
 :pattern ( (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |a#20#0#0@@2|))
)))
(assert (forall ((arg0@@733 T@U) ) (! (= (type (|#AbstractMap.TransitionLabel.FreezeAsLabel| arg0@@733)) DatatypeTypeType)
 :qid |funType:#AbstractMap.TransitionLabel.FreezeAsLabel|
 :pattern ( (|#AbstractMap.TransitionLabel.FreezeAsLabel| arg0@@733))
)))
(assert (forall ((|a#21#0#0@@2| T@U) ) (!  (=> (= (type |a#21#0#0@@2|) DatatypeTypeType) (= (DatatypeCtorId (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#21#0#0@@2|)) |##AbstractMap.TransitionLabel.FreezeAsLabel|))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7693|
 :pattern ( (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#21#0#0@@2|))
)))
(assert (forall ((d@@282 T@U) ) (!  (=> (= (type d@@282) DatatypeTypeType) (= (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@282) (= (DatatypeCtorId d@@282) |##AbstractMap.TransitionLabel.FreezeAsLabel|)))
 :qid |unknown.0:0|
 :skolemid |7694|
 :pattern ( (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@282))
)))
(assert (forall ((d@@283 T@U) ) (!  (=> (and (= (type d@@283) DatatypeTypeType) (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@283)) (exists ((|a#22#0#0@@2| T@U) ) (!  (and (= (type |a#22#0#0@@2|) DatatypeTypeType) (= d@@283 (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#22#0#0@@2|)))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7695|
 :no-pattern (type |a#22#0#0@@2|)
 :no-pattern (U_2_int |a#22#0#0@@2|)
 :no-pattern (U_2_bool |a#22#0#0@@2|)
)))
 :qid |unknown.0:0|
 :skolemid |7696|
 :pattern ( (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@283))
)))
(assert (forall ((|a#23#0#0@@1| T@U) ) (!  (=> (= (type |a#23#0#0@@1|) DatatypeTypeType) (= ($Is (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#23#0#0@@1|) Tclass.AbstractMap.TransitionLabel) ($Is |a#23#0#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7697|
 :pattern ( ($Is (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#23#0#0@@1|) Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((|a#24#0#0@@1| T@U) ($h@@239 T@U) ) (!  (=> (and (and (= (type |a#24#0#0@@1|) DatatypeTypeType) (= (type $h@@239) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@239)) (= ($IsAlloc (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#24#0#0@@1|) Tclass.AbstractMap.TransitionLabel $h@@239) ($IsAlloc |a#24#0#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@239)))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7698|
 :pattern ( ($IsAlloc (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#24#0#0@@1|) Tclass.AbstractMap.TransitionLabel $h@@239))
)))
(assert (forall ((arg0@@734 T@U) ) (! (= (type (AbstractMap.TransitionLabel.stampedMap arg0@@734)) DatatypeTypeType)
 :qid |funType:AbstractMap.TransitionLabel.stampedMap|
 :pattern ( (AbstractMap.TransitionLabel.stampedMap arg0@@734))
)))
(assert (forall ((d@@284 T@U) ($h@@240 T@U) ) (!  (=> (and (and (= (type d@@284) DatatypeTypeType) (= (type $h@@240) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@240) (and (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@284) ($IsAlloc d@@284 Tclass.AbstractMap.TransitionLabel $h@@240)))) ($IsAlloc (AbstractMap.TransitionLabel.stampedMap d@@284) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@240))
 :qid |unknown.0:0|
 :skolemid |7699|
 :pattern ( ($IsAlloc (AbstractMap.TransitionLabel.stampedMap d@@284) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@240))
)))
(assert (forall ((|a#25#0#0@@1| T@U) ) (!  (=> (= (type |a#25#0#0@@1|) DatatypeTypeType) (= (|#AbstractMap.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0@@1|)) (Lit (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#25#0#0@@1|))))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7700|
 :pattern ( (|#AbstractMap.TransitionLabel.FreezeAsLabel| (Lit |a#25#0#0@@1|)))
)))
(assert (forall ((|a#26#0#0@@1| T@U) ) (!  (=> (= (type |a#26#0#0@@1|) DatatypeTypeType) (= (AbstractMap.TransitionLabel.stampedMap (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#26#0#0@@1|)) |a#26#0#0@@1|))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7701|
 :pattern ( (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#26#0#0@@1|))
)))
(assert (forall ((|a#27#0#0@@3| T@U) ) (!  (=> (= (type |a#27#0#0@@3|) DatatypeTypeType) (< (DtRank |a#27#0#0@@3|) (DtRank (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#27#0#0@@3|))))
 :qid |AbstractMapidfy.19:21|
 :skolemid |7702|
 :pattern ( (|#AbstractMap.TransitionLabel.FreezeAsLabel| |a#27#0#0@@3|))
)))
(assert (= (type |#AbstractMap.TransitionLabel.InternalLabel|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#AbstractMap.TransitionLabel.InternalLabel|) |##AbstractMap.TransitionLabel.InternalLabel|))
(assert (forall ((d@@285 T@U) ) (!  (=> (= (type d@@285) DatatypeTypeType) (= (AbstractMap.TransitionLabel.InternalLabel_q d@@285) (= (DatatypeCtorId d@@285) |##AbstractMap.TransitionLabel.InternalLabel|)))
 :qid |unknown.0:0|
 :skolemid |7703|
 :pattern ( (AbstractMap.TransitionLabel.InternalLabel_q d@@285))
)))
(assert (forall ((d@@286 T@U) ) (!  (=> (and (= (type d@@286) DatatypeTypeType) (AbstractMap.TransitionLabel.InternalLabel_q d@@286)) (= d@@286 |#AbstractMap.TransitionLabel.InternalLabel|))
 :qid |unknown.0:0|
 :skolemid |7704|
 :pattern ( (AbstractMap.TransitionLabel.InternalLabel_q d@@286))
)))
(assert ($Is |#AbstractMap.TransitionLabel.InternalLabel| Tclass.AbstractMap.TransitionLabel))
(assert (forall (($h@@241 T@U) ) (!  (=> (and (= (type $h@@241) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@241)) ($IsAlloc |#AbstractMap.TransitionLabel.InternalLabel| Tclass.AbstractMap.TransitionLabel $h@@241))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7705|
 :pattern ( ($IsAlloc |#AbstractMap.TransitionLabel.InternalLabel| Tclass.AbstractMap.TransitionLabel $h@@241))
)))
(assert (= |#AbstractMap.TransitionLabel.InternalLabel| (Lit |#AbstractMap.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@287 T@U) ) (!  (=> (and (= (type d@@287) DatatypeTypeType) (|$IsA#AbstractMap.TransitionLabel| d@@287)) (or (or (or (or (AbstractMap.TransitionLabel.QueryLabel_q d@@287) (AbstractMap.TransitionLabel.PutLabel_q d@@287)) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@287)) (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@287)) (AbstractMap.TransitionLabel.InternalLabel_q d@@287)))
 :qid |unknown.0:0|
 :skolemid |7706|
 :pattern ( (|$IsA#AbstractMap.TransitionLabel| d@@287))
)))
(assert (forall ((d@@288 T@U) ) (!  (=> (and (= (type d@@288) DatatypeTypeType) ($Is d@@288 Tclass.AbstractMap.TransitionLabel)) (or (or (or (or (AbstractMap.TransitionLabel.QueryLabel_q d@@288) (AbstractMap.TransitionLabel.PutLabel_q d@@288)) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@288)) (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@288)) (AbstractMap.TransitionLabel.InternalLabel_q d@@288)))
 :qid |unknown.0:0|
 :skolemid |7707|
 :pattern ( (AbstractMap.TransitionLabel.InternalLabel_q d@@288) ($Is d@@288 Tclass.AbstractMap.TransitionLabel))
 :pattern ( (AbstractMap.TransitionLabel.FreezeAsLabel_q d@@288) ($Is d@@288 Tclass.AbstractMap.TransitionLabel))
 :pattern ( (AbstractMap.TransitionLabel.QueryEndLsnLabel_q d@@288) ($Is d@@288 Tclass.AbstractMap.TransitionLabel))
 :pattern ( (AbstractMap.TransitionLabel.PutLabel_q d@@288) ($Is d@@288 Tclass.AbstractMap.TransitionLabel))
 :pattern ( (AbstractMap.TransitionLabel.QueryLabel_q d@@288) ($Is d@@288 Tclass.AbstractMap.TransitionLabel))
)))
(assert (forall ((a@@206 T@U) (b@@155 T@U) ) (!  (=> (and (and (= (type a@@206) DatatypeTypeType) (= (type b@@155) DatatypeTypeType)) (and (AbstractMap.TransitionLabel.QueryLabel_q a@@206) (AbstractMap.TransitionLabel.QueryLabel_q b@@155))) (= (|AbstractMap.TransitionLabel#Equal| a@@206 b@@155)  (and (and (= (AbstractMap.TransitionLabel.endLsn a@@206) (AbstractMap.TransitionLabel.endLsn b@@155)) (|Seq#Equal| (AbstractMap.TransitionLabel.key a@@206) (AbstractMap.TransitionLabel.key b@@155))) (|Seq#Equal| (AbstractMap.TransitionLabel.value a@@206) (AbstractMap.TransitionLabel.value b@@155)))))
 :qid |unknown.0:0|
 :skolemid |7708|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@206 b@@155) (AbstractMap.TransitionLabel.QueryLabel_q a@@206))
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@206 b@@155) (AbstractMap.TransitionLabel.QueryLabel_q b@@155))
)))
(assert (forall ((a@@207 T@U) (b@@156 T@U) ) (!  (=> (and (and (= (type a@@207) DatatypeTypeType) (= (type b@@156) DatatypeTypeType)) (and (AbstractMap.TransitionLabel.PutLabel_q a@@207) (AbstractMap.TransitionLabel.PutLabel_q b@@156))) (= (|AbstractMap.TransitionLabel#Equal| a@@207 b@@156) (|MsgHistoryMod.MsgHistory#Equal| (AbstractMap.TransitionLabel.puts a@@207) (AbstractMap.TransitionLabel.puts b@@156))))
 :qid |unknown.0:0|
 :skolemid |7709|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@207 b@@156) (AbstractMap.TransitionLabel.PutLabel_q a@@207))
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@207 b@@156) (AbstractMap.TransitionLabel.PutLabel_q b@@156))
)))
(assert (forall ((a@@208 T@U) (b@@157 T@U) ) (!  (=> (and (and (= (type a@@208) DatatypeTypeType) (= (type b@@157) DatatypeTypeType)) (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q a@@208) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q b@@157))) (= (|AbstractMap.TransitionLabel#Equal| a@@208 b@@157) (= (AbstractMap.TransitionLabel.endLsn a@@208) (AbstractMap.TransitionLabel.endLsn b@@157))))
 :qid |unknown.0:0|
 :skolemid |7710|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@208 b@@157) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q a@@208))
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@208 b@@157) (AbstractMap.TransitionLabel.QueryEndLsnLabel_q b@@157))
)))
(assert (forall ((a@@209 T@U) (b@@158 T@U) ) (!  (=> (and (and (= (type a@@209) DatatypeTypeType) (= (type b@@158) DatatypeTypeType)) (and (AbstractMap.TransitionLabel.FreezeAsLabel_q a@@209) (AbstractMap.TransitionLabel.FreezeAsLabel_q b@@158))) (= (|AbstractMap.TransitionLabel#Equal| a@@209 b@@158) (|StampedMod.Stamped#Equal| (AbstractMap.TransitionLabel.stampedMap a@@209) (AbstractMap.TransitionLabel.stampedMap b@@158))))
 :qid |unknown.0:0|
 :skolemid |7711|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@209 b@@158) (AbstractMap.TransitionLabel.FreezeAsLabel_q a@@209))
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@209 b@@158) (AbstractMap.TransitionLabel.FreezeAsLabel_q b@@158))
)))
(assert (forall ((a@@210 T@U) (b@@159 T@U) ) (!  (=> (and (and (= (type a@@210) DatatypeTypeType) (= (type b@@159) DatatypeTypeType)) (and (AbstractMap.TransitionLabel.InternalLabel_q a@@210) (AbstractMap.TransitionLabel.InternalLabel_q b@@159))) (= (|AbstractMap.TransitionLabel#Equal| a@@210 b@@159) true))
 :qid |unknown.0:0|
 :skolemid |7712|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@210 b@@159) (AbstractMap.TransitionLabel.InternalLabel_q a@@210))
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@210 b@@159) (AbstractMap.TransitionLabel.InternalLabel_q b@@159))
)))
(assert (forall ((a@@211 T@U) (b@@160 T@U) ) (!  (=> (and (= (type a@@211) DatatypeTypeType) (= (type b@@160) DatatypeTypeType)) (= (|AbstractMap.TransitionLabel#Equal| a@@211 b@@160) (= a@@211 b@@160)))
 :qid |unknown.0:0|
 :skolemid |7713|
 :pattern ( (|AbstractMap.TransitionLabel#Equal| a@@211 b@@160))
)))
(assert (forall ((arg0@@735 T@U) ) (! (= (type (|#AbstractMap.Variables.Variables| arg0@@735)) DatatypeTypeType)
 :qid |funType:#AbstractMap.Variables.Variables|
 :pattern ( (|#AbstractMap.Variables.Variables| arg0@@735))
)))
(assert (forall ((|a#33#0#0@@3| T@U) ) (!  (=> (= (type |a#33#0#0@@3|) DatatypeTypeType) (= (DatatypeCtorId (|#AbstractMap.Variables.Variables| |a#33#0#0@@3|)) |##AbstractMap.Variables.Variables|))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7714|
 :pattern ( (|#AbstractMap.Variables.Variables| |a#33#0#0@@3|))
)))
(assert (forall ((d@@289 T@U) ) (!  (=> (= (type d@@289) DatatypeTypeType) (= (AbstractMap.Variables.Variables_q d@@289) (= (DatatypeCtorId d@@289) |##AbstractMap.Variables.Variables|)))
 :qid |unknown.0:0|
 :skolemid |7715|
 :pattern ( (AbstractMap.Variables.Variables_q d@@289))
)))
(assert (forall ((d@@290 T@U) ) (!  (=> (and (= (type d@@290) DatatypeTypeType) (AbstractMap.Variables.Variables_q d@@290)) (exists ((|a#34#0#0@@3| T@U) ) (!  (and (= (type |a#34#0#0@@3|) DatatypeTypeType) (= d@@290 (|#AbstractMap.Variables.Variables| |a#34#0#0@@3|)))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7716|
 :no-pattern (type |a#34#0#0@@3|)
 :no-pattern (U_2_int |a#34#0#0@@3|)
 :no-pattern (U_2_bool |a#34#0#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |7717|
 :pattern ( (AbstractMap.Variables.Variables_q d@@290))
)))
(assert (= (type Tclass.AbstractMap.Variables) TyType))
(assert (= (Tag Tclass.AbstractMap.Variables) Tagclass.AbstractMap.Variables))
(assert (= (TagFamily Tclass.AbstractMap.Variables) tytagFamily$Variables))
(assert (forall ((bx@@184 T@U) ) (!  (=> (and (= (type bx@@184) BoxType) ($IsBox bx@@184 Tclass.AbstractMap.Variables)) (and (= ($Box ($Unbox DatatypeTypeType bx@@184)) bx@@184) ($Is ($Unbox DatatypeTypeType bx@@184) Tclass.AbstractMap.Variables)))
 :qid |unknown.0:0|
 :skolemid |7718|
 :pattern ( ($IsBox bx@@184 Tclass.AbstractMap.Variables))
)))
(assert (forall ((|a#35#0#0@@3| T@U) ) (!  (=> (= (type |a#35#0#0@@3|) DatatypeTypeType) (= ($Is (|#AbstractMap.Variables.Variables| |a#35#0#0@@3|) Tclass.AbstractMap.Variables) ($Is |a#35#0#0@@3| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7719|
 :pattern ( ($Is (|#AbstractMap.Variables.Variables| |a#35#0#0@@3|) Tclass.AbstractMap.Variables))
)))
(assert (forall ((|a#36#0#0@@2| T@U) ($h@@242 T@U) ) (!  (=> (and (and (= (type |a#36#0#0@@2|) DatatypeTypeType) (= (type $h@@242) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@242)) (= ($IsAlloc (|#AbstractMap.Variables.Variables| |a#36#0#0@@2|) Tclass.AbstractMap.Variables $h@@242) ($IsAlloc |a#36#0#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@242)))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7720|
 :pattern ( ($IsAlloc (|#AbstractMap.Variables.Variables| |a#36#0#0@@2|) Tclass.AbstractMap.Variables $h@@242))
)))
(assert (forall ((arg0@@736 T@U) ) (! (= (type (AbstractMap.Variables.stampedMap arg0@@736)) DatatypeTypeType)
 :qid |funType:AbstractMap.Variables.stampedMap|
 :pattern ( (AbstractMap.Variables.stampedMap arg0@@736))
)))
(assert (forall ((d@@291 T@U) ($h@@243 T@U) ) (!  (=> (and (and (= (type d@@291) DatatypeTypeType) (= (type $h@@243) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@243) (and (AbstractMap.Variables.Variables_q d@@291) ($IsAlloc d@@291 Tclass.AbstractMap.Variables $h@@243)))) ($IsAlloc (AbstractMap.Variables.stampedMap d@@291) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@243))
 :qid |unknown.0:0|
 :skolemid |7721|
 :pattern ( ($IsAlloc (AbstractMap.Variables.stampedMap d@@291) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap) $h@@243))
)))
(assert (forall ((|a#37#0#0@@2| T@U) ) (!  (=> (= (type |a#37#0#0@@2|) DatatypeTypeType) (= (|#AbstractMap.Variables.Variables| (Lit |a#37#0#0@@2|)) (Lit (|#AbstractMap.Variables.Variables| |a#37#0#0@@2|))))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7722|
 :pattern ( (|#AbstractMap.Variables.Variables| (Lit |a#37#0#0@@2|)))
)))
(assert (forall ((|a#38#0#0@@1| T@U) ) (!  (=> (= (type |a#38#0#0@@1|) DatatypeTypeType) (= (AbstractMap.Variables.stampedMap (|#AbstractMap.Variables.Variables| |a#38#0#0@@1|)) |a#38#0#0@@1|))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7723|
 :pattern ( (|#AbstractMap.Variables.Variables| |a#38#0#0@@1|))
)))
(assert (forall ((|a#39#0#0@@1| T@U) ) (!  (=> (= (type |a#39#0#0@@1|) DatatypeTypeType) (< (DtRank |a#39#0#0@@1|) (DtRank (|#AbstractMap.Variables.Variables| |a#39#0#0@@1|))))
 :qid |AbstractMapidfy.22:34|
 :skolemid |7724|
 :pattern ( (|#AbstractMap.Variables.Variables| |a#39#0#0@@1|))
)))
(assert (forall ((d@@292 T@U) ) (!  (=> (and (= (type d@@292) DatatypeTypeType) (|$IsA#AbstractMap.Variables| d@@292)) (AbstractMap.Variables.Variables_q d@@292))
 :qid |unknown.0:0|
 :skolemid |7725|
 :pattern ( (|$IsA#AbstractMap.Variables| d@@292))
)))
(assert (forall ((d@@293 T@U) ) (!  (=> (and (= (type d@@293) DatatypeTypeType) ($Is d@@293 Tclass.AbstractMap.Variables)) (AbstractMap.Variables.Variables_q d@@293))
 :qid |unknown.0:0|
 :skolemid |7726|
 :pattern ( (AbstractMap.Variables.Variables_q d@@293) ($Is d@@293 Tclass.AbstractMap.Variables))
)))
(assert (forall ((a@@212 T@U) (b@@161 T@U) ) (!  (=> (and (and (= (type a@@212) DatatypeTypeType) (= (type b@@161) DatatypeTypeType)) true) (= (|AbstractMap.Variables#Equal| a@@212 b@@161) (|StampedMod.Stamped#Equal| (AbstractMap.Variables.stampedMap a@@212) (AbstractMap.Variables.stampedMap b@@161))))
 :qid |unknown.0:0|
 :skolemid |7727|
 :pattern ( (|AbstractMap.Variables#Equal| a@@212 b@@161))
)))
(assert (forall ((a@@213 T@U) (b@@162 T@U) ) (!  (=> (and (= (type a@@213) DatatypeTypeType) (= (type b@@162) DatatypeTypeType)) (= (|AbstractMap.Variables#Equal| a@@213 b@@162) (= a@@213 b@@162)))
 :qid |unknown.0:0|
 :skolemid |7728|
 :pattern ( (|AbstractMap.Variables#Equal| a@@213 b@@162))
)))
(assert (= (type Tclass.AbstractMap.__default) TyType))
(assert (= (Tag Tclass.AbstractMap.__default) Tagclass.AbstractMap.__default))
(assert (= (TagFamily Tclass.AbstractMap.__default) tytagFamily$_default))
(assert (forall ((bx@@185 T@U) ) (!  (=> (and (= (type bx@@185) BoxType) ($IsBox bx@@185 Tclass.AbstractMap.__default)) (and (= ($Box ($Unbox refType bx@@185)) bx@@185) ($Is ($Unbox refType bx@@185) Tclass.AbstractMap.__default)))
 :qid |unknown.0:0|
 :skolemid |7729|
 :pattern ( ($IsBox bx@@185 Tclass.AbstractMap.__default))
)))
(assert (forall (($o@@75 T@U) ) (!  (=> (= (type $o@@75) refType) (= ($Is $o@@75 Tclass.AbstractMap.__default)  (or (= $o@@75 null) (= (dtype $o@@75) Tclass.AbstractMap.__default))))
 :qid |unknown.0:0|
 :skolemid |7730|
 :pattern ( ($Is $o@@75 Tclass.AbstractMap.__default))
)))
(assert (forall (($o@@76 T@U) ($h@@244 T@U) ) (!  (=> (and (= (type $o@@76) refType) (= (type $h@@244) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@76 Tclass.AbstractMap.__default $h@@244)  (or (= $o@@76 null) (U_2_bool (MapType1Select (MapType0Select $h@@244 $o@@76) alloc)))))
 :qid |unknown.0:0|
 :skolemid |7731|
 :pattern ( ($IsAlloc $o@@76 Tclass.AbstractMap.__default $h@@244))
)))
(assert  (=> true (forall ((|v#0@@144| T@U) (|v'#0@@95| T@U) (|lbl#0@@99| T@U) ) (!  (=> (and (and (and (= (type |v#0@@144|) DatatypeTypeType) (= (type |v'#0@@95|) DatatypeTypeType)) (= (type |lbl#0@@99|) DatatypeTypeType)) (or (|AbstractMap.__default.Query#canCall| |v#0@@144| |v'#0@@95| |lbl#0@@99|) (and (and ($Is |v#0@@144| Tclass.AbstractMap.Variables) ($Is |v'#0@@95| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@99| Tclass.AbstractMap.TransitionLabel)))) true)
 :qid |AbstractMapidfy.25:19|
 :skolemid |7732|
 :pattern ( (AbstractMap.__default.Query |v#0@@144| |v'#0@@95| |lbl#0@@99|))
))))
(assert (forall ((|v#0@@145| T@U) (|v'#0@@96| T@U) (|lbl#0@@100| T@U) ) (!  (=> (and (and (and (= (type |v#0@@145|) DatatypeTypeType) (= (type |v'#0@@96|) DatatypeTypeType)) (= (type |lbl#0@@100|) DatatypeTypeType)) (and (and ($Is |v#0@@145| Tclass.AbstractMap.Variables) ($Is |v'#0@@96| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@100| Tclass.AbstractMap.TransitionLabel))) (= (|AbstractMap.__default.Query#requires| |v#0@@145| |v'#0@@96| |lbl#0@@100|) true))
 :qid |AbstractMapidfy.25:19|
 :skolemid |7733|
 :pattern ( (|AbstractMap.__default.Query#requires| |v#0@@145| |v'#0@@96| |lbl#0@@100|))
)))
(assert  (=> true (forall ((|v#0@@146| T@U) (|v'#0@@97| T@U) (|lbl#0@@101| T@U) ) (!  (=> (and (and (and (= (type |v#0@@146|) DatatypeTypeType) (= (type |v'#0@@97|) DatatypeTypeType)) (= (type |lbl#0@@101|) DatatypeTypeType)) (or (|AbstractMap.__default.Query#canCall| |v#0@@146| |v'#0@@97| |lbl#0@@101|) (and (and ($Is |v#0@@146| Tclass.AbstractMap.Variables) ($Is |v'#0@@97| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@101| Tclass.AbstractMap.TransitionLabel)))) (and (=> (AbstractMap.TransitionLabel.QueryLabel_q |lbl#0@@101|) (and (and (AbstractMap.Variables.Variables_q |v#0@@146|) (StampedMod.Stamped.Stamped_q (AbstractMap.Variables.stampedMap |v#0@@146|))) (=> (= (AbstractMap.TransitionLabel.endLsn |lbl#0@@101|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@146|))) (and (and (AbstractMap.Variables.Variables_q |v#0@@146|) (StampedMod.Stamped.Stamped_q (AbstractMap.Variables.stampedMap |v#0@@146|))) (=> (|Seq#Equal| (AbstractMap.TransitionLabel.value |lbl#0@@101|) (ValueMessage.Message.value ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value (AbstractMap.Variables.stampedMap |v#0@@146|)))) ($Box (AbstractMap.TransitionLabel.key |lbl#0@@101|)))))) (and (|$IsA#AbstractMap.Variables| |v'#0@@97|) (|$IsA#AbstractMap.Variables| |v#0@@146|))))))) (= (AbstractMap.__default.Query |v#0@@146| |v'#0@@97| |lbl#0@@101|)  (and (and (AbstractMap.TransitionLabel.QueryLabel_q |lbl#0@@101|) (= (AbstractMap.TransitionLabel.endLsn |lbl#0@@101|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@146|)))) (and (|Seq#Equal| (AbstractMap.TransitionLabel.value |lbl#0@@101|) (ValueMessage.Message.value ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value (AbstractMap.Variables.stampedMap |v#0@@146|)))) ($Box (AbstractMap.TransitionLabel.key |lbl#0@@101|)))))) (|AbstractMap.Variables#Equal| |v'#0@@97| |v#0@@146|))))))
 :qid |AbstractMapidfy.25:19|
 :skolemid |7734|
 :pattern ( (AbstractMap.__default.Query |v#0@@146| |v'#0@@97| |lbl#0@@101|))
))))
(assert  (=> true (forall ((|v#0@@147| T@U) (|v'#0@@98| T@U) (|lbl#0@@102| T@U) ) (!  (=> (and (and (and (= (type |v#0@@147|) DatatypeTypeType) (= (type |v'#0@@98|) DatatypeTypeType)) (= (type |lbl#0@@102|) DatatypeTypeType)) (or (|AbstractMap.__default.Query#canCall| (Lit |v#0@@147|) (Lit |v'#0@@98|) (Lit |lbl#0@@102|)) (and (and ($Is |v#0@@147| Tclass.AbstractMap.Variables) ($Is |v'#0@@98| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@102| Tclass.AbstractMap.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryLabel_q (Lit |lbl#0@@102|))))) (and (and (AbstractMap.Variables.Variables_q (Lit |v#0@@147|)) (StampedMod.Stamped.Stamped_q (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|))))) (=> (= (LitInt (AbstractMap.TransitionLabel.endLsn (Lit |lbl#0@@102|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|)))))) (and (and (AbstractMap.Variables.Variables_q (Lit |v#0@@147|)) (StampedMod.Stamped.Stamped_q (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|))))) (=> (|Seq#Equal| (AbstractMap.TransitionLabel.value (Lit |lbl#0@@102|)) (ValueMessage.Message.value ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|))))))) ($Box (Lit (AbstractMap.TransitionLabel.key (Lit |lbl#0@@102|)))))))) (and (|$IsA#AbstractMap.Variables| (Lit |v'#0@@98|)) (|$IsA#AbstractMap.Variables| (Lit |v#0@@147|)))))))) (= (AbstractMap.__default.Query (Lit |v#0@@147|) (Lit |v'#0@@98|) (Lit |lbl#0@@102|))  (and (and (AbstractMap.TransitionLabel.QueryLabel_q (Lit |lbl#0@@102|)) (= (LitInt (AbstractMap.TransitionLabel.endLsn (Lit |lbl#0@@102|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|))))))) (and (|Seq#Equal| (AbstractMap.TransitionLabel.value (Lit |lbl#0@@102|)) (ValueMessage.Message.value ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@147|))))))) ($Box (Lit (AbstractMap.TransitionLabel.key (Lit |lbl#0@@102|)))))))) (|AbstractMap.Variables#Equal| |v'#0@@98| |v#0@@147|))))))
 :qid |AbstractMapidfy.25:19|
 :weight 3
 :skolemid |7735|
 :pattern ( (AbstractMap.__default.Query (Lit |v#0@@147|) (Lit |v'#0@@98|) (Lit |lbl#0@@102|)))
))))
(assert  (=> true (forall ((|v#0@@148| T@U) (|v'#0@@99| T@U) (|lbl#0@@103| T@U) ) (!  (=> (and (and (and (= (type |v#0@@148|) DatatypeTypeType) (= (type |v'#0@@99|) DatatypeTypeType)) (= (type |lbl#0@@103|) DatatypeTypeType)) (or (|AbstractMap.__default.Put#canCall| |v#0@@148| |v'#0@@99| |lbl#0@@103|) (and (and ($Is |v#0@@148| Tclass.AbstractMap.Variables) ($Is |v'#0@@99| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@103| Tclass.AbstractMap.TransitionLabel)))) true)
 :qid |AbstractMapidfy.34:17|
 :skolemid |7736|
 :pattern ( (AbstractMap.__default.Put |v#0@@148| |v'#0@@99| |lbl#0@@103|))
))))
(assert (forall ((|v#0@@149| T@U) (|v'#0@@100| T@U) (|lbl#0@@104| T@U) ) (!  (=> (and (and (and (= (type |v#0@@149|) DatatypeTypeType) (= (type |v'#0@@100|) DatatypeTypeType)) (= (type |lbl#0@@104|) DatatypeTypeType)) (and (and ($Is |v#0@@149| Tclass.AbstractMap.Variables) ($Is |v'#0@@100| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@104| Tclass.AbstractMap.TransitionLabel))) (= (|AbstractMap.__default.Put#requires| |v#0@@149| |v'#0@@100| |lbl#0@@104|) true))
 :qid |AbstractMapidfy.34:17|
 :skolemid |7737|
 :pattern ( (|AbstractMap.__default.Put#requires| |v#0@@149| |v'#0@@100| |lbl#0@@104|))
)))
(assert  (=> true (forall ((|v#0@@150| T@U) (|v'#0@@101| T@U) (|lbl#0@@105| T@U) ) (!  (=> (and (and (and (= (type |v#0@@150|) DatatypeTypeType) (= (type |v'#0@@101|) DatatypeTypeType)) (= (type |lbl#0@@105|) DatatypeTypeType)) (or (|AbstractMap.__default.Put#canCall| |v#0@@150| |v'#0@@101| |lbl#0@@105|) (and (and ($Is |v#0@@150| Tclass.AbstractMap.Variables) ($Is |v'#0@@101| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@105| Tclass.AbstractMap.TransitionLabel)))) (and (=> (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@105|) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (AbstractMap.TransitionLabel.puts |lbl#0@@105|)) (=> (MsgHistoryMod.MsgHistory.WF (AbstractMap.TransitionLabel.puts |lbl#0@@105|)) (and (and (and (AbstractMap.Variables.Variables_q |v#0@@150|) (StampedMod.Stamped.Stamped_q (AbstractMap.Variables.stampedMap |v#0@@150|))) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (AbstractMap.TransitionLabel.puts |lbl#0@@105|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@150|)))) (=> (MsgHistoryMod.MsgHistory.CanFollow (AbstractMap.TransitionLabel.puts |lbl#0@@105|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@150|))) (and (and (|$IsA#StampedMod.Stamped| (AbstractMap.Variables.stampedMap |v'#0@@101|)) (|$IsA#StampedMod.Stamped| (MsgHistoryMod.__default.MapPlusHistory (AbstractMap.Variables.stampedMap |v#0@@150|) (AbstractMap.TransitionLabel.puts |lbl#0@@105|)))) (and (AbstractMap.Variables.Variables_q |v'#0@@101|) (and (AbstractMap.Variables.Variables_q |v#0@@150|) (|MsgHistoryMod.__default.MapPlusHistory#canCall| (AbstractMap.Variables.stampedMap |v#0@@150|) (AbstractMap.TransitionLabel.puts |lbl#0@@105|)))))))))) (= (AbstractMap.__default.Put |v#0@@150| |v'#0@@101| |lbl#0@@105|)  (and (and (and (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@105|) (MsgHistoryMod.MsgHistory.WF (AbstractMap.TransitionLabel.puts |lbl#0@@105|))) (MsgHistoryMod.MsgHistory.CanFollow (AbstractMap.TransitionLabel.puts |lbl#0@@105|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@150|)))) (|StampedMod.Stamped#Equal| (AbstractMap.Variables.stampedMap |v'#0@@101|) (MsgHistoryMod.__default.MapPlusHistory (AbstractMap.Variables.stampedMap |v#0@@150|) (AbstractMap.TransitionLabel.puts |lbl#0@@105|)))))))
 :qid |AbstractMapidfy.34:17|
 :skolemid |7738|
 :pattern ( (AbstractMap.__default.Put |v#0@@150| |v'#0@@101| |lbl#0@@105|))
))))
(assert  (=> true (forall ((|v#0@@151| T@U) (|v'#0@@102| T@U) (|lbl#0@@106| T@U) ) (!  (=> (and (and (and (= (type |v#0@@151|) DatatypeTypeType) (= (type |v'#0@@102|) DatatypeTypeType)) (= (type |lbl#0@@106|) DatatypeTypeType)) (or (|AbstractMap.__default.Put#canCall| (Lit |v#0@@151|) (Lit |v'#0@@102|) (Lit |lbl#0@@106|)) (and (and ($Is |v#0@@151| Tclass.AbstractMap.Variables) ($Is |v'#0@@102| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@106| Tclass.AbstractMap.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.PutLabel_q (Lit |lbl#0@@106|))))) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|)))) (=> (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))))))) (and (and (and (AbstractMap.Variables.Variables_q (Lit |v#0@@151|)) (StampedMod.Stamped.Stamped_q (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))))) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))))))) (=> (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))))))))) (and (and (|$IsA#StampedMod.Stamped| (Lit (AbstractMap.Variables.stampedMap (Lit |v'#0@@102|)))) (|$IsA#StampedMod.Stamped| (Lit (MsgHistoryMod.__default.MapPlusHistory (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))) (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))))))) (and (AbstractMap.Variables.Variables_q (Lit |v'#0@@102|)) (and (AbstractMap.Variables.Variables_q (Lit |v#0@@151|)) (|MsgHistoryMod.__default.MapPlusHistory#canCall| (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))) (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|)))))))))))) (= (AbstractMap.__default.Put (Lit |v#0@@151|) (Lit |v'#0@@102|) (Lit |lbl#0@@106|))  (and (and (and (AbstractMap.TransitionLabel.PutLabel_q (Lit |lbl#0@@106|)) (MsgHistoryMod.MsgHistory.WF (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))))) (MsgHistoryMod.MsgHistory.CanFollow (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))))))) (|StampedMod.Stamped#Equal| (AbstractMap.Variables.stampedMap (Lit |v'#0@@102|)) (MsgHistoryMod.__default.MapPlusHistory (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@151|))) (Lit (AbstractMap.TransitionLabel.puts (Lit |lbl#0@@106|)))))))))
 :qid |AbstractMapidfy.34:17|
 :weight 3
 :skolemid |7739|
 :pattern ( (AbstractMap.__default.Put (Lit |v#0@@151|) (Lit |v'#0@@102|) (Lit |lbl#0@@106|)))
))))
(assert  (=> true (forall ((|v#0@@152| T@U) (|v'#0@@103| T@U) (|lbl#0@@107| T@U) ) (!  (=> (and (and (and (= (type |v#0@@152|) DatatypeTypeType) (= (type |v'#0@@103|) DatatypeTypeType)) (= (type |lbl#0@@107|) DatatypeTypeType)) (or (|AbstractMap.__default.QueryEndLsn#canCall| |v#0@@152| |v'#0@@103| |lbl#0@@107|) (and (and ($Is |v#0@@152| Tclass.AbstractMap.Variables) ($Is |v'#0@@103| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@107| Tclass.AbstractMap.TransitionLabel)))) true)
 :qid |AbstractMapidfy.42:25|
 :skolemid |7740|
 :pattern ( (AbstractMap.__default.QueryEndLsn |v#0@@152| |v'#0@@103| |lbl#0@@107|))
))))
(assert (forall ((|v#0@@153| T@U) (|v'#0@@104| T@U) (|lbl#0@@108| T@U) ) (!  (=> (and (and (and (= (type |v#0@@153|) DatatypeTypeType) (= (type |v'#0@@104|) DatatypeTypeType)) (= (type |lbl#0@@108|) DatatypeTypeType)) (and (and ($Is |v#0@@153| Tclass.AbstractMap.Variables) ($Is |v'#0@@104| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@108| Tclass.AbstractMap.TransitionLabel))) (= (|AbstractMap.__default.QueryEndLsn#requires| |v#0@@153| |v'#0@@104| |lbl#0@@108|) true))
 :qid |AbstractMapidfy.42:25|
 :skolemid |7741|
 :pattern ( (|AbstractMap.__default.QueryEndLsn#requires| |v#0@@153| |v'#0@@104| |lbl#0@@108|))
)))
(assert  (=> true (forall ((|v#0@@154| T@U) (|v'#0@@105| T@U) (|lbl#0@@109| T@U) ) (!  (=> (and (and (and (= (type |v#0@@154|) DatatypeTypeType) (= (type |v'#0@@105|) DatatypeTypeType)) (= (type |lbl#0@@109|) DatatypeTypeType)) (or (|AbstractMap.__default.QueryEndLsn#canCall| |v#0@@154| |v'#0@@105| |lbl#0@@109|) (and (and ($Is |v#0@@154| Tclass.AbstractMap.Variables) ($Is |v'#0@@105| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@109| Tclass.AbstractMap.TransitionLabel)))) (and (=> (AbstractMap.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@109|) (and (and (AbstractMap.Variables.Variables_q |v#0@@154|) (StampedMod.Stamped.Stamped_q (AbstractMap.Variables.stampedMap |v#0@@154|))) (=> (= (AbstractMap.TransitionLabel.endLsn |lbl#0@@109|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@154|))) (and (|$IsA#AbstractMap.Variables| |v'#0@@105|) (|$IsA#AbstractMap.Variables| |v#0@@154|))))) (= (AbstractMap.__default.QueryEndLsn |v#0@@154| |v'#0@@105| |lbl#0@@109|)  (and (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@109|) (= (AbstractMap.TransitionLabel.endLsn |lbl#0@@109|) (StampedMod.Stamped.seqEnd (AbstractMap.Variables.stampedMap |v#0@@154|)))) (|AbstractMap.Variables#Equal| |v'#0@@105| |v#0@@154|)))))
 :qid |AbstractMapidfy.42:25|
 :skolemid |7742|
 :pattern ( (AbstractMap.__default.QueryEndLsn |v#0@@154| |v'#0@@105| |lbl#0@@109|))
))))
(assert  (=> true (forall ((|v#0@@155| T@U) (|v'#0@@106| T@U) (|lbl#0@@110| T@U) ) (!  (=> (and (and (and (= (type |v#0@@155|) DatatypeTypeType) (= (type |v'#0@@106|) DatatypeTypeType)) (= (type |lbl#0@@110|) DatatypeTypeType)) (or (|AbstractMap.__default.QueryEndLsn#canCall| (Lit |v#0@@155|) (Lit |v'#0@@106|) (Lit |lbl#0@@110|)) (and (and ($Is |v#0@@155| Tclass.AbstractMap.Variables) ($Is |v'#0@@106| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@110| Tclass.AbstractMap.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@110|))))) (and (and (AbstractMap.Variables.Variables_q (Lit |v#0@@155|)) (StampedMod.Stamped.Stamped_q (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@155|))))) (=> (= (LitInt (AbstractMap.TransitionLabel.endLsn (Lit |lbl#0@@110|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@155|)))))) (and (|$IsA#AbstractMap.Variables| (Lit |v'#0@@106|)) (|$IsA#AbstractMap.Variables| (Lit |v#0@@155|)))))) (= (AbstractMap.__default.QueryEndLsn (Lit |v#0@@155|) (Lit |v'#0@@106|) (Lit |lbl#0@@110|))  (and (and (AbstractMap.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@110|)) (= (LitInt (AbstractMap.TransitionLabel.endLsn (Lit |lbl#0@@110|))) (LitInt (StampedMod.Stamped.seqEnd (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@155|))))))) (|AbstractMap.Variables#Equal| |v'#0@@106| |v#0@@155|)))))
 :qid |AbstractMapidfy.42:25|
 :weight 3
 :skolemid |7743|
 :pattern ( (AbstractMap.__default.QueryEndLsn (Lit |v#0@@155|) (Lit |v'#0@@106|) (Lit |lbl#0@@110|)))
))))
(assert  (=> true (forall ((|v#0@@156| T@U) (|v'#0@@107| T@U) (|lbl#0@@111| T@U) ) (!  (=> (and (and (and (= (type |v#0@@156|) DatatypeTypeType) (= (type |v'#0@@107|) DatatypeTypeType)) (= (type |lbl#0@@111|) DatatypeTypeType)) (or (|AbstractMap.__default.FreezeAs#canCall| |v#0@@156| |v'#0@@107| |lbl#0@@111|) (and (and ($Is |v#0@@156| Tclass.AbstractMap.Variables) ($Is |v'#0@@107| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@111| Tclass.AbstractMap.TransitionLabel)))) true)
 :qid |AbstractMapidfy.49:22|
 :skolemid |7744|
 :pattern ( (AbstractMap.__default.FreezeAs |v#0@@156| |v'#0@@107| |lbl#0@@111|))
))))
(assert (forall ((|v#0@@157| T@U) (|v'#0@@108| T@U) (|lbl#0@@112| T@U) ) (!  (=> (and (and (and (= (type |v#0@@157|) DatatypeTypeType) (= (type |v'#0@@108|) DatatypeTypeType)) (= (type |lbl#0@@112|) DatatypeTypeType)) (and (and ($Is |v#0@@157| Tclass.AbstractMap.Variables) ($Is |v'#0@@108| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@112| Tclass.AbstractMap.TransitionLabel))) (= (|AbstractMap.__default.FreezeAs#requires| |v#0@@157| |v'#0@@108| |lbl#0@@112|) true))
 :qid |AbstractMapidfy.49:22|
 :skolemid |7745|
 :pattern ( (|AbstractMap.__default.FreezeAs#requires| |v#0@@157| |v'#0@@108| |lbl#0@@112|))
)))
(assert  (=> true (forall ((|v#0@@158| T@U) (|v'#0@@109| T@U) (|lbl#0@@113| T@U) ) (!  (=> (and (and (and (= (type |v#0@@158|) DatatypeTypeType) (= (type |v'#0@@109|) DatatypeTypeType)) (= (type |lbl#0@@113|) DatatypeTypeType)) (or (|AbstractMap.__default.FreezeAs#canCall| |v#0@@158| |v'#0@@109| |lbl#0@@113|) (and (and ($Is |v#0@@158| Tclass.AbstractMap.Variables) ($Is |v'#0@@109| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@113| Tclass.AbstractMap.TransitionLabel)))) (and (=> (AbstractMap.TransitionLabel.FreezeAsLabel_q |lbl#0@@113|) (and (and (and (|$IsA#StampedMod.Stamped| (AbstractMap.TransitionLabel.stampedMap |lbl#0@@113|)) (|$IsA#StampedMod.Stamped| (AbstractMap.Variables.stampedMap |v#0@@158|))) (AbstractMap.Variables.Variables_q |v#0@@158|)) (=> (|StampedMod.Stamped#Equal| (AbstractMap.TransitionLabel.stampedMap |lbl#0@@113|) (AbstractMap.Variables.stampedMap |v#0@@158|)) (and (|$IsA#AbstractMap.Variables| |v'#0@@109|) (|$IsA#AbstractMap.Variables| |v#0@@158|))))) (= (AbstractMap.__default.FreezeAs |v#0@@158| |v'#0@@109| |lbl#0@@113|)  (and (and (AbstractMap.TransitionLabel.FreezeAsLabel_q |lbl#0@@113|) (|StampedMod.Stamped#Equal| (AbstractMap.TransitionLabel.stampedMap |lbl#0@@113|) (AbstractMap.Variables.stampedMap |v#0@@158|))) (|AbstractMap.Variables#Equal| |v'#0@@109| |v#0@@158|)))))
 :qid |AbstractMapidfy.49:22|
 :skolemid |7746|
 :pattern ( (AbstractMap.__default.FreezeAs |v#0@@158| |v'#0@@109| |lbl#0@@113|))
))))
(assert  (=> true (forall ((|v#0@@159| T@U) (|v'#0@@110| T@U) (|lbl#0@@114| T@U) ) (!  (=> (and (and (and (= (type |v#0@@159|) DatatypeTypeType) (= (type |v'#0@@110|) DatatypeTypeType)) (= (type |lbl#0@@114|) DatatypeTypeType)) (or (|AbstractMap.__default.FreezeAs#canCall| (Lit |v#0@@159|) (Lit |v'#0@@110|) (Lit |lbl#0@@114|)) (and (and ($Is |v#0@@159| Tclass.AbstractMap.Variables) ($Is |v'#0@@110| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@114| Tclass.AbstractMap.TransitionLabel)))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@114|))))) (and (and (and (|$IsA#StampedMod.Stamped| (Lit (AbstractMap.TransitionLabel.stampedMap (Lit |lbl#0@@114|)))) (|$IsA#StampedMod.Stamped| (Lit (AbstractMap.Variables.stampedMap (Lit |v#0@@159|))))) (AbstractMap.Variables.Variables_q (Lit |v#0@@159|))) (=> (|StampedMod.Stamped#Equal| (AbstractMap.TransitionLabel.stampedMap (Lit |lbl#0@@114|)) (AbstractMap.Variables.stampedMap (Lit |v#0@@159|))) (and (|$IsA#AbstractMap.Variables| (Lit |v'#0@@110|)) (|$IsA#AbstractMap.Variables| (Lit |v#0@@159|)))))) (= (AbstractMap.__default.FreezeAs (Lit |v#0@@159|) (Lit |v'#0@@110|) (Lit |lbl#0@@114|))  (and (and (AbstractMap.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@114|)) (|StampedMod.Stamped#Equal| (AbstractMap.TransitionLabel.stampedMap (Lit |lbl#0@@114|)) (AbstractMap.Variables.stampedMap (Lit |v#0@@159|)))) (|AbstractMap.Variables#Equal| |v'#0@@110| |v#0@@159|)))))
 :qid |AbstractMapidfy.49:22|
 :weight 3
 :skolemid |7747|
 :pattern ( (AbstractMap.__default.FreezeAs (Lit |v#0@@159|) (Lit |v'#0@@110|) (Lit |lbl#0@@114|)))
))))
(assert  (=> true (forall ((|v#0@@160| T@U) (|persistentMap#0| T@U) ) (!  (=> (and (and (= (type |v#0@@160|) DatatypeTypeType) (= (type |persistentMap#0|) DatatypeTypeType)) (or (|AbstractMap.__default.Init#canCall| |v#0@@160| |persistentMap#0|) (and ($Is |v#0@@160| Tclass.AbstractMap.Variables) ($Is |persistentMap#0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))) true)
 :qid |AbstractMapidfy.57:18|
 :skolemid |7748|
 :pattern ( (AbstractMap.__default.Init |v#0@@160| |persistentMap#0|))
))))
(assert (forall ((|v#0@@161| T@U) (|persistentMap#0@@0| T@U) ) (!  (=> (and (and (= (type |v#0@@161|) DatatypeTypeType) (= (type |persistentMap#0@@0|) DatatypeTypeType)) (and ($Is |v#0@@161| Tclass.AbstractMap.Variables) ($Is |persistentMap#0@@0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))) (= (|AbstractMap.__default.Init#requires| |v#0@@161| |persistentMap#0@@0|) true))
 :qid |AbstractMapidfy.57:18|
 :skolemid |7749|
 :pattern ( (|AbstractMap.__default.Init#requires| |v#0@@161| |persistentMap#0@@0|))
)))
(assert  (=> true (forall ((|v#0@@162| T@U) (|persistentMap#0@@1| T@U) ) (!  (=> (and (and (= (type |v#0@@162|) DatatypeTypeType) (= (type |persistentMap#0@@1|) DatatypeTypeType)) (or (|AbstractMap.__default.Init#canCall| |v#0@@162| |persistentMap#0@@1|) (and ($Is |v#0@@162| Tclass.AbstractMap.Variables) ($Is |persistentMap#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))) (and (|$IsA#AbstractMap.Variables| |v#0@@162|) (= (AbstractMap.__default.Init |v#0@@162| |persistentMap#0@@1|) (|AbstractMap.Variables#Equal| |v#0@@162| (|#AbstractMap.Variables.Variables| |persistentMap#0@@1|)))))
 :qid |AbstractMapidfy.57:18|
 :skolemid |7750|
 :pattern ( (AbstractMap.__default.Init |v#0@@162| |persistentMap#0@@1|))
))))
(assert  (=> true (forall ((|v#0@@163| T@U) (|persistentMap#0@@2| T@U) ) (!  (=> (and (and (= (type |v#0@@163|) DatatypeTypeType) (= (type |persistentMap#0@@2|) DatatypeTypeType)) (or (|AbstractMap.__default.Init#canCall| (Lit |v#0@@163|) (Lit |persistentMap#0@@2|)) (and ($Is |v#0@@163| Tclass.AbstractMap.Variables) ($Is |persistentMap#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))) (and (|$IsA#AbstractMap.Variables| (Lit |v#0@@163|)) (= (AbstractMap.__default.Init (Lit |v#0@@163|) (Lit |persistentMap#0@@2|)) (|AbstractMap.Variables#Equal| |v#0@@163| (|#AbstractMap.Variables.Variables| (Lit |persistentMap#0@@2|))))))
 :qid |AbstractMapidfy.57:18|
 :weight 3
 :skolemid |7751|
 :pattern ( (AbstractMap.__default.Init (Lit |v#0@@163|) (Lit |persistentMap#0@@2|)))
))))
(assert  (=> true (forall ((|v#0@@164| T@U) (|v'#0@@111| T@U) (|lbl#0@@115| T@U) ) (!  (=> (and (and (and (= (type |v#0@@164|) DatatypeTypeType) (= (type |v'#0@@111|) DatatypeTypeType)) (= (type |lbl#0@@115|) DatatypeTypeType)) (or (|AbstractMap.__default.Next#canCall| |v#0@@164| |v'#0@@111| |lbl#0@@115|) (and (and ($Is |v#0@@164| Tclass.AbstractMap.Variables) ($Is |v'#0@@111| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@115| Tclass.AbstractMap.TransitionLabel)))) true)
 :qid |AbstractMapidfy.62:18|
 :skolemid |7752|
 :pattern ( (AbstractMap.__default.Next |v#0@@164| |v'#0@@111| |lbl#0@@115|))
))))
(assert (forall ((|v#0@@165| T@U) (|v'#0@@112| T@U) (|lbl#0@@116| T@U) ) (!  (=> (and (and (and (= (type |v#0@@165|) DatatypeTypeType) (= (type |v'#0@@112|) DatatypeTypeType)) (= (type |lbl#0@@116|) DatatypeTypeType)) (and (and ($Is |v#0@@165| Tclass.AbstractMap.Variables) ($Is |v'#0@@112| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@116| Tclass.AbstractMap.TransitionLabel))) (= (|AbstractMap.__default.Next#requires| |v#0@@165| |v'#0@@112| |lbl#0@@116|) true))
 :qid |AbstractMapidfy.62:18|
 :skolemid |7753|
 :pattern ( (|AbstractMap.__default.Next#requires| |v#0@@165| |v'#0@@112| |lbl#0@@116|))
)))
(assert  (=> true (forall ((|v#0@@166| T@U) (|v'#0@@113| T@U) (|lbl#0@@117| T@U) ) (!  (=> (and (and (and (= (type |v#0@@166|) DatatypeTypeType) (= (type |v'#0@@113|) DatatypeTypeType)) (= (type |lbl#0@@117|) DatatypeTypeType)) (or (|AbstractMap.__default.Next#canCall| |v#0@@166| |v'#0@@113| |lbl#0@@117|) (and (and ($Is |v#0@@166| Tclass.AbstractMap.Variables) ($Is |v'#0@@113| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@117| Tclass.AbstractMap.TransitionLabel)))) (and (and (=> (AbstractMap.TransitionLabel.QueryLabel_q |lbl#0@@117|) (|AbstractMap.__default.Query#canCall| |v#0@@166| |v'#0@@113| |lbl#0@@117|)) (=> (not (AbstractMap.TransitionLabel.QueryLabel_q |lbl#0@@117|)) (and (=> (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@117|) (|AbstractMap.__default.Put#canCall| |v#0@@166| |v'#0@@113| |lbl#0@@117|)) (=> (not (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@117|)) (and (=> (AbstractMap.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@117|) (|AbstractMap.__default.QueryEndLsn#canCall| |v#0@@166| |v'#0@@113| |lbl#0@@117|)) (=> (not (AbstractMap.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@117|)) (and (=> (AbstractMap.TransitionLabel.FreezeAsLabel_q |lbl#0@@117|) (|AbstractMap.__default.FreezeAs#canCall| |v#0@@166| |v'#0@@113| |lbl#0@@117|)) (=> (not (AbstractMap.TransitionLabel.FreezeAsLabel_q |lbl#0@@117|)) (and (|$IsA#AbstractMap.Variables| |v#0@@166|) (|$IsA#AbstractMap.Variables| |v'#0@@113|)))))))))) (= (AbstractMap.__default.Next |v#0@@166| |v'#0@@113| |lbl#0@@117|) (ite (AbstractMap.TransitionLabel.QueryLabel_q |lbl#0@@117|) (AbstractMap.__default.Query |v#0@@166| |v'#0@@113| |lbl#0@@117|) (ite (AbstractMap.TransitionLabel.PutLabel_q |lbl#0@@117|) (AbstractMap.__default.Put |v#0@@166| |v'#0@@113| |lbl#0@@117|) (ite (AbstractMap.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@117|) (AbstractMap.__default.QueryEndLsn |v#0@@166| |v'#0@@113| |lbl#0@@117|) (ite (AbstractMap.TransitionLabel.FreezeAsLabel_q |lbl#0@@117|) (AbstractMap.__default.FreezeAs |v#0@@166| |v'#0@@113| |lbl#0@@117|) (|AbstractMap.Variables#Equal| |v#0@@166| |v'#0@@113|))))))))
 :qid |AbstractMapidfy.62:18|
 :skolemid |7754|
 :pattern ( (AbstractMap.__default.Next |v#0@@166| |v'#0@@113| |lbl#0@@117|))
))))
(assert  (=> true (forall ((|v#0@@167| T@U) (|v'#0@@114| T@U) (|lbl#0@@118| T@U) ) (!  (=> (and (and (and (= (type |v#0@@167|) DatatypeTypeType) (= (type |v'#0@@114|) DatatypeTypeType)) (= (type |lbl#0@@118|) DatatypeTypeType)) (or (|AbstractMap.__default.Next#canCall| (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (and (and ($Is |v#0@@167| Tclass.AbstractMap.Variables) ($Is |v'#0@@114| Tclass.AbstractMap.Variables)) ($Is |lbl#0@@118| Tclass.AbstractMap.TransitionLabel)))) (and (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryLabel_q (Lit |lbl#0@@118|))))) (|AbstractMap.__default.Query#canCall| (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|))) (=> (not (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryLabel_q (Lit |lbl#0@@118|)))))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.PutLabel_q (Lit |lbl#0@@118|))))) (|AbstractMap.__default.Put#canCall| (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|))) (=> (not (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.PutLabel_q (Lit |lbl#0@@118|)))))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@118|))))) (|AbstractMap.__default.QueryEndLsn#canCall| (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|))) (=> (not (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@118|)))))) (and (=> (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@118|))))) (|AbstractMap.__default.FreezeAs#canCall| (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|))) (=> (not (U_2_bool (Lit (bool_2_U (AbstractMap.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@118|)))))) (and (|$IsA#AbstractMap.Variables| (Lit |v#0@@167|)) (|$IsA#AbstractMap.Variables| (Lit |v'#0@@114|))))))))))) (= (AbstractMap.__default.Next (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (ite (AbstractMap.TransitionLabel.QueryLabel_q (Lit |lbl#0@@118|)) (AbstractMap.__default.Query (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (ite (AbstractMap.TransitionLabel.PutLabel_q (Lit |lbl#0@@118|)) (AbstractMap.__default.Put (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (ite (AbstractMap.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@118|)) (AbstractMap.__default.QueryEndLsn (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (ite (AbstractMap.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@118|)) (AbstractMap.__default.FreezeAs (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)) (|AbstractMap.Variables#Equal| |v#0@@167| |v'#0@@114|))))))))
 :qid |AbstractMapidfy.62:18|
 :weight 3
 :skolemid |7755|
 :pattern ( (AbstractMap.__default.Next (Lit |v#0@@167|) (Lit |v'#0@@114|) (Lit |lbl#0@@118|)))
))))
(assert (= (type Tclass.PagedBetreeRefinement.__default) TyType))
(assert (= (Tag Tclass.PagedBetreeRefinement.__default) Tagclass.PagedBetreeRefinement.__default))
(assert (= (TagFamily Tclass.PagedBetreeRefinement.__default) tytagFamily$_default))
(assert (forall ((bx@@186 T@U) ) (!  (=> (and (= (type bx@@186) BoxType) ($IsBox bx@@186 Tclass.PagedBetreeRefinement.__default)) (and (= ($Box ($Unbox refType bx@@186)) bx@@186) ($Is ($Unbox refType bx@@186) Tclass.PagedBetreeRefinement.__default)))
 :qid |unknown.0:0|
 :skolemid |7756|
 :pattern ( ($IsBox bx@@186 Tclass.PagedBetreeRefinement.__default))
)))
(assert (forall (($o@@77 T@U) ) (!  (=> (= (type $o@@77) refType) (= ($Is $o@@77 Tclass.PagedBetreeRefinement.__default)  (or (= $o@@77 null) (= (dtype $o@@77) Tclass.PagedBetreeRefinement.__default))))
 :qid |unknown.0:0|
 :skolemid |7757|
 :pattern ( ($Is $o@@77 Tclass.PagedBetreeRefinement.__default))
)))
(assert (forall (($o@@78 T@U) ($h@@245 T@U) ) (!  (=> (and (= (type $o@@78) refType) (= (type $h@@245) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@78 Tclass.PagedBetreeRefinement.__default $h@@245)  (or (= $o@@78 null) (U_2_bool (MapType1Select (MapType0Select $h@@245 $o@@78) alloc)))))
 :qid |unknown.0:0|
 :skolemid |7758|
 :pattern ( ($IsAlloc $o@@78 Tclass.PagedBetreeRefinement.__default $h@@245))
)))
(assert (forall ((arg0@@737 T@U) (arg1@@380 T@U) (arg2@@186 T@U) ) (! (= (type (PagedBetreeRefinement.__default.BuildQueryReceipt arg0@@737 arg1@@380 arg2@@186)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.BuildQueryReceipt|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt arg0@@737 arg1@@380 arg2@@186))
)))
(assert (forall (($ly@@783 T@U) (|node#0@@15| T@U) (|key#0@@250| T@U) ) (!  (=> (and (and (= (type $ly@@783) LayerTypeType) (= (type |node#0@@15|) DatatypeTypeType)) (= (type |key#0@@250|) (SeqType BoxType))) (= (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@783) |node#0@@15| |key#0@@250|) (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@783 |node#0@@15| |key#0@@250|)))
 :qid |PagedBetreeRefinementidfy.23:12|
 :skolemid |7759|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@783) |node#0@@15| |key#0@@250|))
)))
(assert (forall (($ly@@784 T@U) (|node#0@@16| T@U) (|key#0@@251| T@U) ) (!  (=> (and (and (= (type $ly@@784) LayerTypeType) (= (type |node#0@@16|) DatatypeTypeType)) (= (type |key#0@@251|) (SeqType BoxType))) (= (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@784 |node#0@@16| |key#0@@251|) (PagedBetreeRefinement.__default.BuildQueryReceipt $LZ |node#0@@16| |key#0@@251|)))
 :qid |PagedBetreeRefinementidfy.23:12|
 :skolemid |7760|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt (AsFuelBottom $ly@@784) |node#0@@16| |key#0@@251|))
)))
(assert  (=> true (forall (($ly@@785 T@U) (|node#0@@17| T@U) (|key#0@@252| T@U) ) (!  (=> (and (and (and (= (type $ly@@785) LayerTypeType) (= (type |node#0@@17|) DatatypeTypeType)) (= (type |key#0@@252|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| |node#0@@17| |key#0@@252|) (and (and ($Is |node#0@@17| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@252| Tclass.KeyType.Key)) (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@17|)))) (and (and (|Seq#Equal| (PagedBetree.QueryReceipt.key (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@785 |node#0@@17| |key#0@@252|)) |key#0@@252|) (PagedBetree.QueryReceipt.Valid (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@785 |node#0@@17| |key#0@@252|))) ($Is (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@785 |node#0@@17| |key#0@@252|) Tclass.PagedBetree.QueryReceipt)))
 :qid |PagedBetreeRefinementidfy.23:12|
 :skolemid |7761|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@785 |node#0@@17| |key#0@@252|))
))))
(assert (forall (($ly@@786 T@U) (|node#0@@18| T@U) (|key#0@@253| T@U) ) (!  (=> (and (and (and (= (type $ly@@786) LayerTypeType) (= (type |node#0@@18|) DatatypeTypeType)) (= (type |key#0@@253|) (SeqType BoxType))) (and ($Is |node#0@@18| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@253| Tclass.KeyType.Key))) (= (|PagedBetreeRefinement.__default.BuildQueryReceipt#requires| $ly@@786 |node#0@@18| |key#0@@253|) (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@18|)))
 :qid |PagedBetreeRefinementidfy.23:12|
 :skolemid |7762|
 :pattern ( (|PagedBetreeRefinement.__default.BuildQueryReceipt#requires| $ly@@786 |node#0@@18| |key#0@@253|))
)))
(assert  (=> true (forall (($ly@@787 T@U) (|node#0@@19| T@U) (|key#0@@254| T@U) ) (!  (=> (and (and (and (= (type $ly@@787) LayerTypeType) (= (type |node#0@@19|) DatatypeTypeType)) (= (type |key#0@@254|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| |node#0@@19| |key#0@@254|) (and (and ($Is |node#0@@19| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@254| Tclass.KeyType.Key)) (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@19|)))) (and (and (=> (PagedBetree.BetreeNode.Nil_q |node#0@@19|) |ValueMessage.__default.DefaultValue#canCall|) (=> (not (PagedBetree.BetreeNode.Nil_q |node#0@@19|)) (and (and (PagedBetree.ChildMap.ChildMap_q (PagedBetree.BetreeNode.children |node#0@@19|)) (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children |node#0@@19|))) ($Box |key#0@@254|))) |key#0@@254|)) (let ((|childReceipt#0| (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@787 ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children |node#0@@19|))) ($Box |key#0@@254|))) |key#0@@254|)))
 (and (|Buffers.BufferStack.Query#canCall| (PagedBetree.BetreeNode.buffers |node#0@@19|) |key#0@@254|) (let ((|thisMessage#0| (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers |node#0@@19|) |key#0@@254|)))
 (and (and (|PagedBetree.QueryReceipt.Result#canCall| |childReceipt#0|) (|ValueMessage.__default.Merge#canCall| |thisMessage#0| (PagedBetree.QueryReceipt.Result |childReceipt#0|))) (PagedBetree.QueryReceipt.QueryReceipt_q |childReceipt#0|)))))))) (= (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@787) |node#0@@19| |key#0@@254|) (ite (PagedBetree.BetreeNode.Nil_q |node#0@@19|) (|#PagedBetree.QueryReceipt.QueryReceipt| |key#0@@254| |node#0@@19| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |#PagedBetree.BetreeNode.Nil|) (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))) (let ((|childReceipt#0@@0| (PagedBetreeRefinement.__default.BuildQueryReceipt $ly@@787 ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children |node#0@@19|))) ($Box |key#0@@254|))) |key#0@@254|)))
(let ((|thisMessage#0@@0| (Buffers.BufferStack.Query (PagedBetree.BetreeNode.buffers |node#0@@19|) |key#0@@254|)))
(let ((|topLine#0| (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| |node#0@@19| (ValueMessage.__default.Merge |thisMessage#0@@0| (PagedBetree.QueryReceipt.Result |childReceipt#0@@0|)))))
(let ((|receipt#0@@15| (|#PagedBetree.QueryReceipt.QueryReceipt| |key#0@@254| |node#0@@19| (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |topLine#0|)) (PagedBetree.QueryReceipt.lines |childReceipt#0@@0|)))))
|receipt#0@@15|))))))))
 :qid |PagedBetreeRefinementidfy.23:12|
 :skolemid |7763|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@787) |node#0@@19| |key#0@@254|))
))))
(assert  (=> true (forall (($ly@@788 T@U) (|node#0@@20| T@U) (|key#0@@255| T@U) ) (!  (=> (and (and (and (= (type $ly@@788) LayerTypeType) (= (type |node#0@@20|) DatatypeTypeType)) (= (type |key#0@@255|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| (Lit |node#0@@20|) |key#0@@255|) (and (and ($Is |node#0@@20| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@255| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@20|)))))))) (and (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@20|))))) |ValueMessage.__default.DefaultValue#canCall|) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@20|)))))) (and (and (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@20|)))) (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@20|)))))) ($Box |key#0@@255|))) |key#0@@255|)) (let ((|childReceipt#1| (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@788) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@20|)))))) ($Box |key#0@@255|))) |key#0@@255|)))
 (and (|Buffers.BufferStack.Query#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@20|))) |key#0@@255|) (let ((|thisMessage#1| (Buffers.BufferStack.Query (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@20|))) |key#0@@255|)))
 (and (and (|PagedBetree.QueryReceipt.Result#canCall| |childReceipt#1|) (|ValueMessage.__default.Merge#canCall| |thisMessage#1| (PagedBetree.QueryReceipt.Result |childReceipt#1|))) (PagedBetree.QueryReceipt.QueryReceipt_q |childReceipt#1|)))))))) (= (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@788) (Lit |node#0@@20|) |key#0@@255|) (ite (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@20|)) (|#PagedBetree.QueryReceipt.QueryReceipt| |key#0@@255| (Lit |node#0@@20|) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |#PagedBetree.BetreeNode.Nil|) (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))) (let ((|childReceipt#1@@0| (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@788) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@20|)))))) ($Box |key#0@@255|))) |key#0@@255|)))
(let ((|thisMessage#1@@0| (Buffers.BufferStack.Query (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@20|))) |key#0@@255|)))
(let ((|topLine#1| (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |node#0@@20|) (ValueMessage.__default.Merge |thisMessage#1@@0| (PagedBetree.QueryReceipt.Result |childReceipt#1@@0|)))))
(let ((|receipt#1@@3| (|#PagedBetree.QueryReceipt.QueryReceipt| |key#0@@255| (Lit |node#0@@20|) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |topLine#1|)) (PagedBetree.QueryReceipt.lines |childReceipt#1@@0|)))))
|receipt#1@@3|))))))))
 :qid |PagedBetreeRefinementidfy.23:12|
 :weight 3
 :skolemid |7764|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@788) (Lit |node#0@@20|) |key#0@@255|))
))))
(assert  (=> true (forall (($ly@@789 T@U) (|node#0@@21| T@U) (|key#0@@256| T@U) ) (!  (=> (and (and (and (= (type $ly@@789) LayerTypeType) (= (type |node#0@@21|) DatatypeTypeType)) (= (type |key#0@@256|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| (Lit |node#0@@21|) (Lit |key#0@@256|)) (and (and ($Is |node#0@@21| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@256| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@21|)))))))) (and (and (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@21|))))) |ValueMessage.__default.DefaultValue#canCall|) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@21|)))))) (and (and (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@21|)))) (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@21|)))))) ($Box (Lit |key#0@@256|)))) (Lit |key#0@@256|))) (let ((|childReceipt#2| (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@789) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@21|)))))) ($Box (Lit |key#0@@256|)))) (Lit |key#0@@256|))))
 (and (|Buffers.BufferStack.Query#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@21|))) (Lit |key#0@@256|)) (let ((|thisMessage#2| (Lit (Buffers.BufferStack.Query (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@21|))) (Lit |key#0@@256|)))))
 (and (and (|PagedBetree.QueryReceipt.Result#canCall| |childReceipt#2|) (|ValueMessage.__default.Merge#canCall| |thisMessage#2| (PagedBetree.QueryReceipt.Result |childReceipt#2|))) (PagedBetree.QueryReceipt.QueryReceipt_q |childReceipt#2|)))))))) (= (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@789) (Lit |node#0@@21|) (Lit |key#0@@256|)) (ite (PagedBetree.BetreeNode.Nil_q (Lit |node#0@@21|)) (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit |key#0@@256|) (Lit |node#0@@21|) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |#PagedBetree.BetreeNode.Nil|) (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))) (let ((|childReceipt#2@@0| (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@789) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@21|)))))) ($Box (Lit |key#0@@256|)))) (Lit |key#0@@256|))))
(let ((|thisMessage#2@@0| (Lit (Buffers.BufferStack.Query (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@21|))) (Lit |key#0@@256|)))))
(let ((|topLine#2| (|#PagedBetree.QueryReceiptLine.QueryReceiptLine| (Lit |node#0@@21|) (ValueMessage.__default.Merge |thisMessage#2@@0| (PagedBetree.QueryReceipt.Result |childReceipt#2@@0|)))))
(let ((|receipt#2@@3| (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit |key#0@@256|) (Lit |node#0@@21|) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |topLine#2|)) (PagedBetree.QueryReceipt.lines |childReceipt#2@@0|)))))
|receipt#2@@3|))))))))
 :qid |PagedBetreeRefinementidfy.23:12|
 :weight 3
 :skolemid |7765|
 :pattern ( (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $ly@@789) (Lit |node#0@@21|) (Lit |key#0@@256|)))
))))
(assert (forall ((arg0@@738 T@U) (arg1@@381 T@U) ) (! (= (type (PagedBetreeRefinement.__default.INodeAt arg0@@738 arg1@@381)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.INodeAt|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt arg0@@738 arg1@@381))
)))
(assert  (=> true (forall ((|betreeNode#0| T@U) (|key#0@@257| T@U) ) (!  (=> (and (and (= (type |betreeNode#0|) DatatypeTypeType) (= (type |key#0@@257|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.INodeAt#canCall| |betreeNode#0| |key#0@@257|) (and (and ($Is |betreeNode#0| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@257| Tclass.KeyType.Key)) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0|)))) ($Is (PagedBetreeRefinement.__default.INodeAt |betreeNode#0| |key#0@@257|) Tclass.ValueMessage.Message))
 :qid |PagedBetreeRefinementidfy.45:20|
 :skolemid |7766|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt |betreeNode#0| |key#0@@257|))
))))
(assert (forall ((|betreeNode#0@@0| T@U) (|key#0@@258| T@U) ) (!  (=> (and (and (= (type |betreeNode#0@@0|) DatatypeTypeType) (= (type |key#0@@258|) (SeqType BoxType))) (and ($Is |betreeNode#0@@0| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@258| Tclass.KeyType.Key))) (= (|PagedBetreeRefinement.__default.INodeAt#requires| |betreeNode#0@@0| |key#0@@258|) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@0|)))
 :qid |PagedBetreeRefinementidfy.45:20|
 :skolemid |7767|
 :pattern ( (|PagedBetreeRefinement.__default.INodeAt#requires| |betreeNode#0@@0| |key#0@@258|))
)))
(assert  (=> true (forall ((|betreeNode#0@@1| T@U) (|key#0@@259| T@U) ) (!  (=> (and (and (= (type |betreeNode#0@@1|) DatatypeTypeType) (= (type |key#0@@259|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.INodeAt#canCall| |betreeNode#0@@1| |key#0@@259|) (and (and ($Is |betreeNode#0@@1| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@259| Tclass.KeyType.Key)) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@1|)))) (and (and (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| |betreeNode#0@@1| |key#0@@259|) (|PagedBetree.QueryReceipt.Result#canCall| (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $LZ) |betreeNode#0@@1| |key#0@@259|))) (= (PagedBetreeRefinement.__default.INodeAt |betreeNode#0@@1| |key#0@@259|) (PagedBetree.QueryReceipt.Result (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $LZ) |betreeNode#0@@1| |key#0@@259|)))))
 :qid |PagedBetreeRefinementidfy.45:20|
 :skolemid |7768|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt |betreeNode#0@@1| |key#0@@259|))
))))
(assert  (=> true (forall ((|betreeNode#0@@2| T@U) (|key#0@@260| T@U) ) (!  (=> (and (and (= (type |betreeNode#0@@2|) DatatypeTypeType) (= (type |key#0@@260|) (SeqType BoxType))) (or (|PagedBetreeRefinement.__default.INodeAt#canCall| (Lit |betreeNode#0@@2|) (Lit |key#0@@260|)) (and (and ($Is |betreeNode#0@@2| Tclass.PagedBetree.BetreeNode) ($Is |key#0@@260| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |betreeNode#0@@2|)))))))) (and (and (|PagedBetreeRefinement.__default.BuildQueryReceipt#canCall| (Lit |betreeNode#0@@2|) (Lit |key#0@@260|)) (|PagedBetree.QueryReceipt.Result#canCall| (Lit (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $LZ) (Lit |betreeNode#0@@2|) (Lit |key#0@@260|))))) (= (PagedBetreeRefinement.__default.INodeAt (Lit |betreeNode#0@@2|) (Lit |key#0@@260|)) (Lit (PagedBetree.QueryReceipt.Result (Lit (PagedBetreeRefinement.__default.BuildQueryReceipt ($LS $LZ) (Lit |betreeNode#0@@2|) (Lit |key#0@@260|))))))))
 :qid |PagedBetreeRefinementidfy.45:20|
 :weight 3
 :skolemid |7769|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt (Lit |betreeNode#0@@2|) (Lit |key#0@@260|)))
))))
(assert (forall ((arg0@@739 T@U) (arg1@@382 T@U) ) (! (= (type (PagedBetreeRefinement.__default.INode arg0@@739 arg1@@382)) (IMapType BoxType BoxType))
 :qid |funType:PagedBetreeRefinement.__default.INode|
 :pattern ( (PagedBetreeRefinement.__default.INode arg0@@739 arg1@@382))
)))
(assert (forall (($ly@@790 T@U) (|betreeNode#0@@3| T@U) ) (!  (=> (and (= (type $ly@@790) LayerTypeType) (= (type |betreeNode#0@@3|) DatatypeTypeType)) (= (PagedBetreeRefinement.__default.INode ($LS $ly@@790) |betreeNode#0@@3|) (PagedBetreeRefinement.__default.INode $ly@@790 |betreeNode#0@@3|)))
 :qid |PagedBetreeRefinementidfy.51:22|
 :skolemid |7770|
 :pattern ( (PagedBetreeRefinement.__default.INode ($LS $ly@@790) |betreeNode#0@@3|))
)))
(assert (forall (($ly@@791 T@U) (|betreeNode#0@@4| T@U) ) (!  (=> (and (= (type $ly@@791) LayerTypeType) (= (type |betreeNode#0@@4|) DatatypeTypeType)) (= (PagedBetreeRefinement.__default.INode $ly@@791 |betreeNode#0@@4|) (PagedBetreeRefinement.__default.INode $LZ |betreeNode#0@@4|)))
 :qid |PagedBetreeRefinementidfy.51:22|
 :skolemid |7771|
 :pattern ( (PagedBetreeRefinement.__default.INode (AsFuelBottom $ly@@791) |betreeNode#0@@4|))
)))
(assert  (=> true (forall (($ly@@792 T@U) (|betreeNode#0@@5| T@U) ) (!  (=> (and (and (= (type $ly@@792) LayerTypeType) (= (type |betreeNode#0@@5|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.INode#canCall| |betreeNode#0@@5|) (and ($Is |betreeNode#0@@5| Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@5|)))) ($Is (PagedBetreeRefinement.__default.INode $ly@@792 |betreeNode#0@@5|) Tclass.TotalKMMapMod.TotalMap))
 :qid |PagedBetreeRefinementidfy.51:22|
 :skolemid |7772|
 :pattern ( (PagedBetreeRefinement.__default.INode $ly@@792 |betreeNode#0@@5|))
))))
(assert (forall (($ly@@793 T@U) (|betreeNode#0@@6| T@U) ) (!  (=> (and (and (= (type $ly@@793) LayerTypeType) (= (type |betreeNode#0@@6|) DatatypeTypeType)) ($Is |betreeNode#0@@6| Tclass.PagedBetree.BetreeNode)) (= (|PagedBetreeRefinement.__default.INode#requires| $ly@@793 |betreeNode#0@@6|) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@6|)))
 :qid |PagedBetreeRefinementidfy.51:22|
 :skolemid |7773|
 :pattern ( (|PagedBetreeRefinement.__default.INode#requires| $ly@@793 |betreeNode#0@@6|))
)))
(assert (forall ((arg0@@740 T@U) ) (! (= (type (|lambda#398| arg0@@740)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#398|
 :pattern ( (|lambda#398| arg0@@740))
)))
(assert  (=> true (forall (($ly@@794 T@U) (|betreeNode#0@@7| T@U) ) (!  (=> (and (and (= (type $ly@@794) LayerTypeType) (= (type |betreeNode#0@@7|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.INode#canCall| |betreeNode#0@@7|) (and ($Is |betreeNode#0@@7| Tclass.PagedBetree.BetreeNode) (PagedBetree.BetreeNode.WF ($LS $LZ) |betreeNode#0@@7|)))) (and (forall ((|key#0@@261| T@U) ) (!  (=> (and (= (type |key#0@@261|) (SeqType BoxType)) ($Is |key#0@@261| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |key#0@@261|) (=> (TotalKMMapMod.__default.AnyKey |key#0@@261|) (|PagedBetreeRefinement.__default.INodeAt#canCall| |betreeNode#0@@7| |key#0@@261|))))
 :qid |PagedBetreeRefinementidfy.54:10|
 :skolemid |7774|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt |betreeNode#0@@7| |key#0@@261|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |key#0@@261|))
)) (= (PagedBetreeRefinement.__default.INode ($LS $ly@@794) |betreeNode#0@@7|) (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#398| |betreeNode#0@@7|) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))
 :qid |PagedBetreeRefinementidfy.51:22|
 :skolemid |7775|
 :pattern ( (PagedBetreeRefinement.__default.INode ($LS $ly@@794) |betreeNode#0@@7|))
))))
(assert  (=> true (forall (($ly@@795 T@U) (|betreeNode#0@@8| T@U) ) (!  (=> (and (and (= (type $ly@@795) LayerTypeType) (= (type |betreeNode#0@@8|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.INode#canCall| (Lit |betreeNode#0@@8|)) (and ($Is |betreeNode#0@@8| Tclass.PagedBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |betreeNode#0@@8|)))))))) (and (forall ((|key#0@@262| T@U) ) (!  (=> (and (= (type |key#0@@262|) (SeqType BoxType)) ($Is |key#0@@262| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |key#0@@262|) (=> (TotalKMMapMod.__default.AnyKey |key#0@@262|) (|PagedBetreeRefinement.__default.INodeAt#canCall| (Lit |betreeNode#0@@8|) |key#0@@262|))))
 :qid |PagedBetreeRefinementidfy.54:10|
 :skolemid |7776|
 :pattern ( (PagedBetreeRefinement.__default.INodeAt |betreeNode#0@@8| |key#0@@262|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |key#0@@262|))
)) (= (PagedBetreeRefinement.__default.INode ($LS $ly@@795) (Lit |betreeNode#0@@8|)) (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#398| (Lit |betreeNode#0@@8|)) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))
 :qid |PagedBetreeRefinementidfy.51:22|
 :weight 3
 :skolemid |7777|
 :pattern ( (PagedBetreeRefinement.__default.INode ($LS $ly@@795) (Lit |betreeNode#0@@8|)))
))))
(assert (forall ((arg0@@741 T@U) ) (! (= (type (PagedBetreeRefinement.__default.IStampedBetree arg0@@741)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.IStampedBetree|
 :pattern ( (PagedBetreeRefinement.__default.IStampedBetree arg0@@741))
)))
(assert  (=> true (forall ((|stampedBetree#0@@12| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@12|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#0@@12|) (and ($Is |stampedBetree#0@@12| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)) (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@12|)))))) ($Is (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@12|) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))
 :qid |PagedBetreeRefinementidfy.57:27|
 :skolemid |7778|
 :pattern ( (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@12|))
))))
(assert (forall ((|stampedBetree#0@@13| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@13|) DatatypeTypeType) ($Is |stampedBetree#0@@13| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode))) (= (|PagedBetreeRefinement.__default.IStampedBetree#requires| |stampedBetree#0@@13|) (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@13|)))))
 :qid |PagedBetreeRefinementidfy.57:27|
 :skolemid |7779|
 :pattern ( (|PagedBetreeRefinement.__default.IStampedBetree#requires| |stampedBetree#0@@13|))
)))
(assert (= (type StartFuel_PagedBetreeRefinement._default.INode) LayerTypeType))
(assert  (=> true (forall ((|stampedBetree#0@@14| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@14|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#0@@14|) (and ($Is |stampedBetree#0@@14| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)) (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@14|)))))) (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@14|) (|PagedBetreeRefinement.__default.INode#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@14|)))) (StampedMod.Stamped.Stamped_q |stampedBetree#0@@14|)) (= (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@14|) (|#StampedMod.Stamped.Stamped| ($Box (PagedBetreeRefinement.__default.INode StartFuel_PagedBetreeRefinement._default.INode ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@14|)))) (StampedMod.Stamped.seqEnd |stampedBetree#0@@14|)))))
 :qid |PagedBetreeRefinementidfy.57:27|
 :skolemid |7780|
 :pattern ( (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@14|))
))))
(assert  (=> true (forall ((|stampedBetree#0@@15| T@U) ) (!  (=> (and (= (type |stampedBetree#0@@15|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.IStampedBetree#canCall| (Lit |stampedBetree#0@@15|)) (and ($Is |stampedBetree#0@@15| (Tclass.StampedMod.Stamped Tclass.PagedBetree.BetreeNode)) (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@15|))))))))))) (and (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@15|)) (|PagedBetreeRefinement.__default.INode#canCall| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@15|)))))) (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@15|))) (= (PagedBetreeRefinement.__default.IStampedBetree (Lit |stampedBetree#0@@15|)) (|#StampedMod.Stamped.Stamped| ($Box (PagedBetreeRefinement.__default.INode StartFuel_PagedBetreeRefinement._default.INode (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@15|)))))) (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@15|)))))))
 :qid |PagedBetreeRefinementidfy.57:27|
 :weight 3
 :skolemid |7781|
 :pattern ( (PagedBetreeRefinement.__default.IStampedBetree (Lit |stampedBetree#0@@15|)))
))))
(assert (forall ((arg0@@742 T@U) ) (! (= (type (PagedBetreeRefinement.__default.ILbl arg0@@742)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.ILbl|
 :pattern ( (PagedBetreeRefinement.__default.ILbl arg0@@742))
)))
(assert  (=> true (forall ((|lbl#0@@119| T@U) ) (!  (=> (and (= (type |lbl#0@@119|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ILbl#canCall| |lbl#0@@119|) ($Is |lbl#0@@119| Tclass.PagedBetree.TransitionLabel))) ($Is (PagedBetreeRefinement.__default.ILbl |lbl#0@@119|) Tclass.AbstractMap.TransitionLabel))
 :qid |PagedBetreeRefinementidfy.63:17|
 :skolemid |7782|
 :pattern ( (PagedBetreeRefinement.__default.ILbl |lbl#0@@119|))
))))
(assert (forall ((|lbl#0@@120| T@U) ) (!  (=> (and (= (type |lbl#0@@120|) DatatypeTypeType) ($Is |lbl#0@@120| Tclass.PagedBetree.TransitionLabel)) (= (|PagedBetreeRefinement.__default.ILbl#requires| |lbl#0@@120|) true))
 :qid |PagedBetreeRefinementidfy.63:17|
 :skolemid |7783|
 :pattern ( (|PagedBetreeRefinement.__default.ILbl#requires| |lbl#0@@120|))
)))
(assert  (=> true (forall ((|lbl#0@@121| T@U) ) (!  (=> (and (= (type |lbl#0@@121|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ILbl#canCall| |lbl#0@@121|) ($Is |lbl#0@@121| Tclass.PagedBetree.TransitionLabel))) (and (=> (not (PagedBetree.TransitionLabel.QueryLabel_q |lbl#0@@121|)) (=> (not (PagedBetree.TransitionLabel.PutLabel_q |lbl#0@@121|)) (=> (not (PagedBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@121|)) (=> (PagedBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@121|) (let ((|stampedBetree#1@@0| (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@121|)))
 (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#1@@0|) (|PagedBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1@@0|)))) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1@@0|))) (|PagedBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#1@@0|))) (=> (not (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#1@@0|)))) |StampedMod.__default.Empty#canCall|))))))) (= (PagedBetreeRefinement.__default.ILbl |lbl#0@@121|) (ite (PagedBetree.TransitionLabel.QueryLabel_q |lbl#0@@121|) (let ((|value#0@@7| (PagedBetree.TransitionLabel.value |lbl#0@@121|)))
(let ((|key#0@@263| (PagedBetree.TransitionLabel.key |lbl#0@@121|)))
(let ((|endLsn#0@@0| (PagedBetree.TransitionLabel.endLsn |lbl#0@@121|)))
(|#AbstractMap.TransitionLabel.QueryLabel| |endLsn#0@@0| |key#0@@263| |value#0@@7|)))) (ite (PagedBetree.TransitionLabel.PutLabel_q |lbl#0@@121|) (let ((|puts#0@@7| (PagedBetree.TransitionLabel.puts |lbl#0@@121|)))
(|#AbstractMap.TransitionLabel.PutLabel| |puts#0@@7|)) (ite (PagedBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@121|) (let ((|endLsn#1@@0| (PagedBetree.TransitionLabel.endLsn |lbl#0@@121|)))
(|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |endLsn#1@@0|)) (ite (PagedBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@121|) (let ((|stampedBetree#0@@16| (PagedBetree.TransitionLabel.stampedBetree |lbl#0@@121|)))
(|#AbstractMap.TransitionLabel.FreezeAsLabel| (ite (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@16|))) (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#0@@16|) StampedMod.__default.Empty))) |#AbstractMap.TransitionLabel.InternalLabel|)))))))
 :qid |PagedBetreeRefinementidfy.63:17|
 :skolemid |7784|
 :pattern ( (PagedBetreeRefinement.__default.ILbl |lbl#0@@121|))
))))
(assert  (=> true (forall ((|lbl#0@@122| T@U) ) (!  (=> (and (= (type |lbl#0@@122|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ILbl#canCall| (Lit |lbl#0@@122|)) ($Is |lbl#0@@122| Tclass.PagedBetree.TransitionLabel))) (and (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@122|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@122|)))))) (=> (not (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@122|)))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@122|))))) (let ((|stampedBetree#3@@0| (Lit (PagedBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@122|)))))
 (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#3@@0|) (|PagedBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3@@0|)))) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3@@0|))) (|PagedBetreeRefinement.__default.IStampedBetree#canCall| |stampedBetree#3@@0|))) (=> (not (PagedBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#3@@0|)))) |StampedMod.__default.Empty#canCall|))))))) (= (PagedBetreeRefinement.__default.ILbl (Lit |lbl#0@@122|)) (ite (PagedBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@122|)) (let ((|value#2@@1| (Lit (PagedBetree.TransitionLabel.value (Lit |lbl#0@@122|)))))
(let ((|key#2@@2| (Lit (PagedBetree.TransitionLabel.key (Lit |lbl#0@@122|)))))
(let ((|endLsn#4@@0| (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@122|)))))
(Lit (|#AbstractMap.TransitionLabel.QueryLabel| |endLsn#4@@0| |key#2@@2| |value#2@@1|))))) (ite (PagedBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@122|)) (let ((|puts#2@@0| (Lit (PagedBetree.TransitionLabel.puts (Lit |lbl#0@@122|)))))
(Lit (|#AbstractMap.TransitionLabel.PutLabel| |puts#2@@0|))) (ite (PagedBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@122|)) (let ((|endLsn#5@@0| (LitInt (PagedBetree.TransitionLabel.endLsn (Lit |lbl#0@@122|)))))
(Lit (|#AbstractMap.TransitionLabel.QueryEndLsnLabel| |endLsn#5@@0|))) (ite (PagedBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@122|)) (let ((|stampedBetree#2@@0| (Lit (PagedBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@122|)))))
(|#AbstractMap.TransitionLabel.FreezeAsLabel| (ite (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#2@@0|)))) (PagedBetreeRefinement.__default.IStampedBetree |stampedBetree#2@@0|) StampedMod.__default.Empty))) |#AbstractMap.TransitionLabel.InternalLabel|)))))))
 :qid |PagedBetreeRefinementidfy.63:17|
 :weight 3
 :skolemid |7785|
 :pattern ( (PagedBetreeRefinement.__default.ILbl (Lit |lbl#0@@122|)))
))))
(assert (forall ((arg0@@743 T@U) ) (! (= (type (PagedBetreeRefinement.__default.I arg0@@743)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.I|
 :pattern ( (PagedBetreeRefinement.__default.I arg0@@743))
)))
(assert  (=> true (forall ((|v#0@@168| T@U) ) (!  (=> (and (= (type |v#0@@168|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.I#canCall| |v#0@@168|) (and ($Is |v#0@@168| Tclass.PagedBetree.Variables) (PagedBetree.Variables.WF |v#0@@168|)))) ($Is (PagedBetreeRefinement.__default.I |v#0@@168|) Tclass.AbstractMap.Variables))
 :qid |PagedBetreeRefinementidfy.74:14|
 :skolemid |7786|
 :pattern ( (PagedBetreeRefinement.__default.I |v#0@@168|))
))))
(assert (forall ((|v#0@@169| T@U) ) (!  (=> (and (= (type |v#0@@169|) DatatypeTypeType) ($Is |v#0@@169| Tclass.PagedBetree.Variables)) (= (|PagedBetreeRefinement.__default.I#requires| |v#0@@169|) (PagedBetree.Variables.WF |v#0@@169|)))
 :qid |PagedBetreeRefinementidfy.74:14|
 :skolemid |7787|
 :pattern ( (|PagedBetreeRefinement.__default.I#requires| |v#0@@169|))
)))
(assert  (=> true (forall ((|v#0@@170| T@U) ) (!  (=> (and (= (type |v#0@@170|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.I#canCall| |v#0@@170|) (and ($Is |v#0@@170| Tclass.PagedBetree.Variables) (PagedBetree.Variables.WF |v#0@@170|)))) (and (and (and (and (PagedBetree.Variables.Variables_q |v#0@@170|) (PagedBetree.Variables.Variables_q |v#0@@170|)) (|PagedBetree.BetreeNode.PushMemtable#canCall| (PagedBetree.Variables.root |v#0@@170|) (PagedBetree.Variables.memtable |v#0@@170|))) (|PagedBetreeRefinement.__default.IStampedBetree#canCall| (PagedBetree.BetreeNode.PushMemtable (PagedBetree.Variables.root |v#0@@170|) (PagedBetree.Variables.memtable |v#0@@170|)))) (= (PagedBetreeRefinement.__default.I |v#0@@170|) (|#AbstractMap.Variables.Variables| (PagedBetreeRefinement.__default.IStampedBetree (PagedBetree.BetreeNode.PushMemtable (PagedBetree.Variables.root |v#0@@170|) (PagedBetree.Variables.memtable |v#0@@170|)))))))
 :qid |PagedBetreeRefinementidfy.74:14|
 :skolemid |7788|
 :pattern ( (PagedBetreeRefinement.__default.I |v#0@@170|))
))))
(assert  (=> true (forall ((|v#0@@171| T@U) ) (!  (=> (and (= (type |v#0@@171|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.I#canCall| (Lit |v#0@@171|)) (and ($Is |v#0@@171| Tclass.PagedBetree.Variables) (U_2_bool (Lit (bool_2_U (PagedBetree.Variables.WF (Lit |v#0@@171|)))))))) (and (and (and (and (PagedBetree.Variables.Variables_q (Lit |v#0@@171|)) (PagedBetree.Variables.Variables_q (Lit |v#0@@171|))) (|PagedBetree.BetreeNode.PushMemtable#canCall| (Lit (PagedBetree.Variables.root (Lit |v#0@@171|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@171|))))) (|PagedBetreeRefinement.__default.IStampedBetree#canCall| (Lit (PagedBetree.BetreeNode.PushMemtable (Lit (PagedBetree.Variables.root (Lit |v#0@@171|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@171|))))))) (= (PagedBetreeRefinement.__default.I (Lit |v#0@@171|)) (Lit (|#AbstractMap.Variables.Variables| (Lit (PagedBetreeRefinement.__default.IStampedBetree (Lit (PagedBetree.BetreeNode.PushMemtable (Lit (PagedBetree.Variables.root (Lit |v#0@@171|))) (Lit (PagedBetree.Variables.memtable (Lit |v#0@@171|))))))))))))
 :qid |PagedBetreeRefinementidfy.74:14|
 :weight 3
 :skolemid |7789|
 :pattern ( (PagedBetreeRefinement.__default.I (Lit |v#0@@171|)))
))))
(assert (forall ((arg0@@744 T@U) (arg1@@383 T@U) (arg2@@187 T@U) ) (! (= (type (PagedBetreeRefinement.__default.MapApply arg0@@744 arg1@@383 arg2@@187)) (IMapType BoxType BoxType))
 :qid |funType:PagedBetreeRefinement.__default.MapApply|
 :pattern ( (PagedBetreeRefinement.__default.MapApply arg0@@744 arg1@@383 arg2@@187))
)))
(assert (forall (($ly@@796 T@U) (|memtable#0@@7| T@U) (|base#0| T@U) ) (!  (=> (and (and (= (type $ly@@796) LayerTypeType) (= (type |memtable#0@@7|) DatatypeTypeType)) (= (type |base#0|) (IMapType BoxType BoxType))) (= (PagedBetreeRefinement.__default.MapApply ($LS $ly@@796) |memtable#0@@7| |base#0|) (PagedBetreeRefinement.__default.MapApply $ly@@796 |memtable#0@@7| |base#0|)))
 :qid |PagedBetreeRefinementidfy.115:22|
 :skolemid |7790|
 :pattern ( (PagedBetreeRefinement.__default.MapApply ($LS $ly@@796) |memtable#0@@7| |base#0|))
)))
(assert (forall (($ly@@797 T@U) (|memtable#0@@8| T@U) (|base#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@797) LayerTypeType) (= (type |memtable#0@@8|) DatatypeTypeType)) (= (type |base#0@@0|) (IMapType BoxType BoxType))) (= (PagedBetreeRefinement.__default.MapApply $ly@@797 |memtable#0@@8| |base#0@@0|) (PagedBetreeRefinement.__default.MapApply $LZ |memtable#0@@8| |base#0@@0|)))
 :qid |PagedBetreeRefinementidfy.115:22|
 :skolemid |7791|
 :pattern ( (PagedBetreeRefinement.__default.MapApply (AsFuelBottom $ly@@797) |memtable#0@@8| |base#0@@0|))
)))
(assert  (=> true (forall (($ly@@798 T@U) (|memtable#0@@9| T@U) (|base#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@798) LayerTypeType) (= (type |memtable#0@@9|) DatatypeTypeType)) (= (type |base#0@@1|) (IMapType BoxType BoxType))) (or (|PagedBetreeRefinement.__default.MapApply#canCall| |memtable#0@@9| |base#0@@1|) (and ($Is |memtable#0@@9| Tclass.MemtableMod.Memtable) ($Is |base#0@@1| Tclass.TotalKMMapMod.TotalMap)))) ($Is (PagedBetreeRefinement.__default.MapApply $ly@@798 |memtable#0@@9| |base#0@@1|) Tclass.TotalKMMapMod.TotalMap))
 :qid |PagedBetreeRefinementidfy.115:22|
 :skolemid |7792|
 :pattern ( (PagedBetreeRefinement.__default.MapApply $ly@@798 |memtable#0@@9| |base#0@@1|))
))))
(assert (forall (($ly@@799 T@U) (|memtable#0@@10| T@U) (|base#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@799) LayerTypeType) (= (type |memtable#0@@10|) DatatypeTypeType)) (= (type |base#0@@2|) (IMapType BoxType BoxType))) (and ($Is |memtable#0@@10| Tclass.MemtableMod.Memtable) ($Is |base#0@@2| Tclass.TotalKMMapMod.TotalMap))) (= (|PagedBetreeRefinement.__default.MapApply#requires| $ly@@799 |memtable#0@@10| |base#0@@2|) true))
 :qid |PagedBetreeRefinementidfy.115:22|
 :skolemid |7793|
 :pattern ( (|PagedBetreeRefinement.__default.MapApply#requires| $ly@@799 |memtable#0@@10| |base#0@@2|))
)))
(assert (forall ((arg0@@745 T@U) (arg1@@384 T@U) ) (! (= (type (|lambda#402| arg0@@745 arg1@@384)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#402|
 :pattern ( (|lambda#402| arg0@@745 arg1@@384))
)))
(assert  (=> true (forall (($ly@@800 T@U) (|memtable#0@@11| T@U) (|base#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@800) LayerTypeType) (= (type |memtable#0@@11|) DatatypeTypeType)) (= (type |base#0@@3|) (IMapType BoxType BoxType))) (or (|PagedBetreeRefinement.__default.MapApply#canCall| |memtable#0@@11| |base#0@@3|) (and ($Is |memtable#0@@11| Tclass.MemtableMod.Memtable) ($Is |base#0@@3| Tclass.TotalKMMapMod.TotalMap)))) (and (forall ((|k#0@@88| T@U) ) (!  (=> (and (= (type |k#0@@88|) (SeqType BoxType)) ($Is |k#0@@88| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@88|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@88|) (and (|MemtableMod.Memtable.Get#canCall| |memtable#0@@11| |k#0@@88|) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Get |memtable#0@@11| |k#0@@88|) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |base#0@@3|) ($Box |k#0@@88|))))))))
 :qid |PagedBetreeRefinementidfy.117:10|
 :skolemid |7794|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |base#0@@3|) ($Box |k#0@@88|))))
 :pattern ( (MemtableMod.Memtable.Get |memtable#0@@11| |k#0@@88|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@88|))
)) (= (PagedBetreeRefinement.__default.MapApply ($LS $ly@@800) |memtable#0@@11| |base#0@@3|) (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#402| |memtable#0@@11| (|IMap#Elements| |base#0@@3|)) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))
 :qid |PagedBetreeRefinementidfy.115:22|
 :skolemid |7795|
 :pattern ( (PagedBetreeRefinement.__default.MapApply ($LS $ly@@800) |memtable#0@@11| |base#0@@3|))
))))
(assert  (=> true (forall (($ly@@801 T@U) (|memtable#0@@12| T@U) (|base#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@801) LayerTypeType) (= (type |memtable#0@@12|) DatatypeTypeType)) (= (type |base#0@@4|) (IMapType BoxType BoxType))) (or (|PagedBetreeRefinement.__default.MapApply#canCall| (Lit |memtable#0@@12|) |base#0@@4|) (and ($Is |memtable#0@@12| Tclass.MemtableMod.Memtable) ($Is |base#0@@4| Tclass.TotalKMMapMod.TotalMap)))) (and (forall ((|k#0@@89| T@U) ) (!  (=> (and (= (type |k#0@@89|) (SeqType BoxType)) ($Is |k#0@@89| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@89|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@89|) (and (|MemtableMod.Memtable.Get#canCall| (Lit |memtable#0@@12|) |k#0@@89|) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Get (Lit |memtable#0@@12|) |k#0@@89|) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |base#0@@4|) ($Box |k#0@@89|))))))))
 :qid |PagedBetreeRefinementidfy.117:10|
 :skolemid |7796|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |base#0@@4|) ($Box |k#0@@89|))))
 :pattern ( (MemtableMod.Memtable.Get |memtable#0@@12| |k#0@@89|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@89|))
)) (= (PagedBetreeRefinement.__default.MapApply ($LS $ly@@801) (Lit |memtable#0@@12|) |base#0@@4|) (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#402| (Lit |memtable#0@@12|) (|IMap#Elements| |base#0@@4|)) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))
 :qid |PagedBetreeRefinementidfy.115:22|
 :weight 3
 :skolemid |7797|
 :pattern ( (PagedBetreeRefinement.__default.MapApply ($LS $ly@@801) (Lit |memtable#0@@12|) |base#0@@4|))
))))
(assert  (=> true (forall (($ly@@802 T@U) (|memtable#0@@13| T@U) (|base#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@802) LayerTypeType) (= (type |memtable#0@@13|) DatatypeTypeType)) (= (type |base#0@@5|) (IMapType BoxType BoxType))) (or (|PagedBetreeRefinement.__default.MapApply#canCall| (Lit |memtable#0@@13|) (Lit |base#0@@5|)) (and ($Is |memtable#0@@13| Tclass.MemtableMod.Memtable) ($Is |base#0@@5| Tclass.TotalKMMapMod.TotalMap)))) (and (forall ((|k#0@@90| T@U) ) (!  (=> (and (= (type |k#0@@90|) (SeqType BoxType)) ($Is |k#0@@90| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@90|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@90|) (and (|MemtableMod.Memtable.Get#canCall| (Lit |memtable#0@@13|) |k#0@@90|) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Get (Lit |memtable#0@@13|) |k#0@@90|) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit |base#0@@5|)) ($Box |k#0@@90|))))))))
 :qid |PagedBetreeRefinementidfy.117:10|
 :skolemid |7798|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |base#0@@5|) ($Box |k#0@@90|))))
 :pattern ( (MemtableMod.Memtable.Get |memtable#0@@13| |k#0@@90|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@90|))
)) (= (PagedBetreeRefinement.__default.MapApply ($LS $ly@@802) (Lit |memtable#0@@13|) (Lit |base#0@@5|)) (|IMap#Glue| (|lambda#149| Tclass.KeyType.Key) (|lambda#402| (Lit |memtable#0@@13|) (|IMap#Elements| (Lit |base#0@@5|))) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))
 :qid |PagedBetreeRefinementidfy.115:22|
 :weight 3
 :skolemid |7799|
 :pattern ( (PagedBetreeRefinement.__default.MapApply ($LS $ly@@802) (Lit |memtable#0@@13|) (Lit |base#0@@5|)))
))))
(assert (forall ((arg0@@746 T@U) ) (! (= (type (PagedBetreeRefinement.__default.ReceiptDropFirst arg0@@746)) DatatypeTypeType)
 :qid |funType:PagedBetreeRefinement.__default.ReceiptDropFirst|
 :pattern ( (PagedBetreeRefinement.__default.ReceiptDropFirst arg0@@746))
)))
(assert  (=> true (forall ((|receipt#0@@16| T@U) ) (!  (=> (and (= (type |receipt#0@@16|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall| |receipt#0@@16|) (and ($Is |receipt#0@@16| Tclass.PagedBetree.QueryReceipt) (and (PagedBetree.QueryReceipt.Valid |receipt#0@@16|) (INTERNAL_lt_boogie 1 (|Seq#Length| (PagedBetree.QueryReceipt.lines |receipt#0@@16|))))))) ($Is (PagedBetreeRefinement.__default.ReceiptDropFirst |receipt#0@@16|) Tclass.PagedBetree.QueryReceipt))
 :qid |PagedBetreeRefinementidfy.169:29|
 :skolemid |7800|
 :pattern ( (PagedBetreeRefinement.__default.ReceiptDropFirst |receipt#0@@16|))
))))
(assert (forall ((|receipt#0@@17| T@U) ) (!  (=> (and (= (type |receipt#0@@17|) DatatypeTypeType) ($Is |receipt#0@@17| Tclass.PagedBetree.QueryReceipt)) (= (|PagedBetreeRefinement.__default.ReceiptDropFirst#requires| |receipt#0@@17|)  (and (PagedBetree.QueryReceipt.Valid |receipt#0@@17|) (INTERNAL_lt_boogie 1 (|Seq#Length| (PagedBetree.QueryReceipt.lines |receipt#0@@17|))))))
 :qid |PagedBetreeRefinementidfy.169:29|
 :skolemid |7801|
 :pattern ( (|PagedBetreeRefinement.__default.ReceiptDropFirst#requires| |receipt#0@@17|))
)))
(assert  (=> true (forall ((|receipt#0@@18| T@U) ) (!  (=> (and (= (type |receipt#0@@18|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall| |receipt#0@@18|) (and ($Is |receipt#0@@18| Tclass.PagedBetree.QueryReceipt) (and (PagedBetree.QueryReceipt.Valid |receipt#0@@18|) (INTERNAL_lt_boogie 1 (|Seq#Length| (PagedBetree.QueryReceipt.lines |receipt#0@@18|))))))) (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@18|) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@18|) (PagedBetree.ChildMap.ChildMap_q (PagedBetree.BetreeNode.children (PagedBetree.QueryReceipt.root |receipt#0@@18|)))) (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@18|))) (PagedBetree.QueryReceipt.QueryReceipt_q |receipt#0@@18|)) (= (PagedBetreeRefinement.__default.ReceiptDropFirst |receipt#0@@18|) (|#PagedBetree.QueryReceipt.QueryReceipt| (PagedBetree.QueryReceipt.key |receipt#0@@18|) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (PagedBetree.ChildMap.mapp (PagedBetree.BetreeNode.children (PagedBetree.QueryReceipt.root |receipt#0@@18|)))) ($Box (PagedBetree.QueryReceipt.key |receipt#0@@18|)))) (|Seq#Drop| (PagedBetree.QueryReceipt.lines |receipt#0@@18|) (LitInt 1))))))
 :qid |PagedBetreeRefinementidfy.169:29|
 :skolemid |7802|
 :pattern ( (PagedBetreeRefinement.__default.ReceiptDropFirst |receipt#0@@18|))
))))
(assert  (=> true (forall ((|receipt#0@@19| T@U) ) (!  (=> (and (= (type |receipt#0@@19|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.ReceiptDropFirst#canCall| (Lit |receipt#0@@19|)) (and ($Is |receipt#0@@19| Tclass.PagedBetree.QueryReceipt) (and (U_2_bool (Lit (bool_2_U (PagedBetree.QueryReceipt.Valid (Lit |receipt#0@@19|))))) (INTERNAL_lt_boogie 1 (|Seq#Length| (Lit (PagedBetree.QueryReceipt.lines (Lit |receipt#0@@19|))))))))) (and (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@19|)) (and (and (PagedBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@19|)) (PagedBetree.ChildMap.ChildMap_q (Lit (PagedBetree.BetreeNode.children (Lit (PagedBetree.QueryReceipt.root (Lit |receipt#0@@19|))))))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@19|)))) (PagedBetree.QueryReceipt.QueryReceipt_q (Lit |receipt#0@@19|))) (= (PagedBetreeRefinement.__default.ReceiptDropFirst (Lit |receipt#0@@19|)) (|#PagedBetree.QueryReceipt.QueryReceipt| (Lit (PagedBetree.QueryReceipt.key (Lit |receipt#0@@19|))) ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit (PagedBetree.ChildMap.mapp (Lit (PagedBetree.BetreeNode.children (Lit (PagedBetree.QueryReceipt.root (Lit |receipt#0@@19|)))))))) ($Box (Lit (PagedBetree.QueryReceipt.key (Lit |receipt#0@@19|)))))) (Lit (|Seq#Drop| (Lit (PagedBetree.QueryReceipt.lines (Lit |receipt#0@@19|))) (LitInt 1)))))))
 :qid |PagedBetreeRefinementidfy.169:29|
 :weight 3
 :skolemid |7803|
 :pattern ( (PagedBetreeRefinement.__default.ReceiptDropFirst (Lit |receipt#0@@19|)))
))))
(assert  (=> true (forall ((|node#0@@22| T@U) (|other#0@@24| T@U) ) (!  (=> (and (and (= (type |node#0@@22|) DatatypeTypeType) (= (type |other#0@@24|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall| |node#0@@22| |other#0@@24|) (and ($Is |node#0@@22| Tclass.PagedBetree.BetreeNode) ($Is |other#0@@24| Tclass.PagedBetree.BetreeNode)))) true)
 :qid |PagedBetreeRefinementidfy.391:40|
 :skolemid |7804|
 :pattern ( (PagedBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@22| |other#0@@24|))
))))
(assert (forall ((|node#0@@23| T@U) (|other#0@@25| T@U) ) (!  (=> (and (and (= (type |node#0@@23|) DatatypeTypeType) (= (type |other#0@@25|) DatatypeTypeType)) (and ($Is |node#0@@23| Tclass.PagedBetree.BetreeNode) ($Is |other#0@@25| Tclass.PagedBetree.BetreeNode))) (= (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires| |node#0@@23| |other#0@@25|) true))
 :qid |PagedBetreeRefinementidfy.391:40|
 :skolemid |7805|
 :pattern ( (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#requires| |node#0@@23| |other#0@@25|))
)))
(assert  (=> true (forall ((|node#0@@24| T@U) (|other#0@@26| T@U) ) (!  (=> (and (and (= (type |node#0@@24|) DatatypeTypeType) (= (type |other#0@@26|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall| |node#0@@24| |other#0@@26|) (and ($Is |node#0@@24| Tclass.PagedBetree.BetreeNode) ($Is |other#0@@26| Tclass.PagedBetree.BetreeNode)))) (and (and (|PagedBetree.BetreeNode.WF#canCall| |node#0@@24|) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@24|) (and (|PagedBetree.BetreeNode.WF#canCall| |other#0@@26|) (=> (PagedBetree.BetreeNode.WF ($LS $LZ) |other#0@@26|) (=> (PagedBetree.BetreeNode.BetreeNode_q |node#0@@24|) (=> (PagedBetree.BetreeNode.BetreeNode_q |other#0@@26|) (and (|Buffers.BufferStack.Equivalent#canCall| (PagedBetree.BetreeNode.buffers |node#0@@24|) (PagedBetree.BetreeNode.buffers |other#0@@26|)) (=> (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers |node#0@@24|) (PagedBetree.BetreeNode.buffers |other#0@@26|)) (and (|$IsA#PagedBetree.ChildMap| (PagedBetree.BetreeNode.children |node#0@@24|)) (|$IsA#PagedBetree.ChildMap| (PagedBetree.BetreeNode.children |other#0@@26|))))))))))) (= (PagedBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@24| |other#0@@26|)  (and (and (and (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) |node#0@@24|) (PagedBetree.BetreeNode.WF ($LS $LZ) |other#0@@26|)) (PagedBetree.BetreeNode.BetreeNode_q |node#0@@24|)) (PagedBetree.BetreeNode.BetreeNode_q |other#0@@26|)) (Buffers.BufferStack.Equivalent (PagedBetree.BetreeNode.buffers |node#0@@24|) (PagedBetree.BetreeNode.buffers |other#0@@26|))) (|PagedBetree.ChildMap#Equal| (PagedBetree.BetreeNode.children |node#0@@24|) (PagedBetree.BetreeNode.children |other#0@@26|))))))
 :qid |PagedBetreeRefinementidfy.391:40|
 :skolemid |7806|
 :pattern ( (PagedBetreeRefinement.__default.EquivalentBufferCompaction |node#0@@24| |other#0@@26|))
))))
(assert  (=> true (forall ((|node#0@@25| T@U) (|other#0@@27| T@U) ) (!  (=> (and (and (= (type |node#0@@25|) DatatypeTypeType) (= (type |other#0@@27|) DatatypeTypeType)) (or (|PagedBetreeRefinement.__default.EquivalentBufferCompaction#canCall| (Lit |node#0@@25|) (Lit |other#0@@27|)) (and ($Is |node#0@@25| Tclass.PagedBetree.BetreeNode) ($Is |other#0@@27| Tclass.PagedBetree.BetreeNode)))) (and (and (|PagedBetree.BetreeNode.WF#canCall| (Lit |node#0@@25|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@25|))))) (and (|PagedBetree.BetreeNode.WF#canCall| (Lit |other#0@@27|)) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |other#0@@27|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit |node#0@@25|))))) (=> (U_2_bool (Lit (bool_2_U (PagedBetree.BetreeNode.BetreeNode_q (Lit |other#0@@27|))))) (and (|Buffers.BufferStack.Equivalent#canCall| (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@25|))) (Lit (PagedBetree.BetreeNode.buffers (Lit |other#0@@27|)))) (=> (U_2_bool (Lit (bool_2_U (Buffers.BufferStack.Equivalent (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@25|))) (Lit (PagedBetree.BetreeNode.buffers (Lit |other#0@@27|))))))) (and (|$IsA#PagedBetree.ChildMap| (Lit (PagedBetree.BetreeNode.children (Lit |node#0@@25|)))) (|$IsA#PagedBetree.ChildMap| (Lit (PagedBetree.BetreeNode.children (Lit |other#0@@27|))))))))))))) (= (PagedBetreeRefinement.__default.EquivalentBufferCompaction (Lit |node#0@@25|) (Lit |other#0@@27|))  (and (and (and (and (and (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |node#0@@25|)) (PagedBetree.BetreeNode.WF ($LS $LZ) (Lit |other#0@@27|))) (PagedBetree.BetreeNode.BetreeNode_q (Lit |node#0@@25|))) (PagedBetree.BetreeNode.BetreeNode_q (Lit |other#0@@27|))) (Buffers.BufferStack.Equivalent (Lit (PagedBetree.BetreeNode.buffers (Lit |node#0@@25|))) (Lit (PagedBetree.BetreeNode.buffers (Lit |other#0@@27|))))) (|PagedBetree.ChildMap#Equal| (PagedBetree.BetreeNode.children (Lit |node#0@@25|)) (PagedBetree.BetreeNode.children (Lit |other#0@@27|)))))))
 :qid |PagedBetreeRefinementidfy.391:40|
 :weight 3
 :skolemid |7807|
 :pattern ( (PagedBetreeRefinement.__default.EquivalentBufferCompaction (Lit |node#0@@25|) (Lit |other#0@@27|)))
))))
(assert  (=> true (forall ((|v#0@@172| T@U) ) (!  (=> (and (= (type |v#0@@172|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.Inv#canCall| |v#0@@172|) ($Is |v#0@@172| Tclass.PagedBetree.Variables))) true)
 :qid |PagedBetreeRefinementidfy.417:17|
 :skolemid |7808|
 :pattern ( (PagedBetreeRefinement.__default.Inv |v#0@@172|))
))))
(assert (forall ((|v#0@@173| T@U) ) (!  (=> (and (= (type |v#0@@173|) DatatypeTypeType) ($Is |v#0@@173| Tclass.PagedBetree.Variables)) (= (|PagedBetreeRefinement.__default.Inv#requires| |v#0@@173|) true))
 :qid |PagedBetreeRefinementidfy.417:17|
 :skolemid |7809|
 :pattern ( (|PagedBetreeRefinement.__default.Inv#requires| |v#0@@173|))
)))
(assert  (=> true (forall ((|v#0@@174| T@U) ) (!  (=> (and (= (type |v#0@@174|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.Inv#canCall| |v#0@@174|) ($Is |v#0@@174| Tclass.PagedBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|PagedBetree.Variables.WF#canCall| |v#0@@174|)) (= (PagedBetreeRefinement.__default.Inv |v#0@@174|)  (and true (PagedBetree.Variables.WF |v#0@@174|)))))
 :qid |PagedBetreeRefinementidfy.417:17|
 :skolemid |7810|
 :pattern ( (PagedBetreeRefinement.__default.Inv |v#0@@174|))
))))
(assert  (=> true (forall ((|v#0@@175| T@U) ) (!  (=> (and (= (type |v#0@@175|) DatatypeTypeType) (or (|PagedBetreeRefinement.__default.Inv#canCall| (Lit |v#0@@175|)) ($Is |v#0@@175| Tclass.PagedBetree.Variables))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|PagedBetree.Variables.WF#canCall| (Lit |v#0@@175|))) (= (PagedBetreeRefinement.__default.Inv (Lit |v#0@@175|)) (U_2_bool (Lit (bool_2_U  (and true (PagedBetree.Variables.WF (Lit |v#0@@175|)))))))))
 :qid |PagedBetreeRefinementidfy.417:17|
 :weight 3
 :skolemid |7811|
 :pattern ( (PagedBetreeRefinement.__default.Inv (Lit |v#0@@175|)))
))))
(assert (forall ((|l#0@@21| T@U) (|$w#0| T@U) ) (!  (=> (and (= (type |l#0@@21|) TyType) (= (type |$w#0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#0| |l#0@@21|) |$w#0|))  (and ($IsBox |$w#0| |l#0@@21|) (Buffers.__default.AnyKey ($Unbox (SeqType BoxType) |$w#0|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7812|
 :pattern ( (MapType0Select (|lambda#0| |l#0@@21|) |$w#0|))
)))
(assert (forall ((|l#0@@22| T@U) (|l#1| T@U) (|l#2| T@U) (|l#3| T@U) (|$w#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@22|) (MapType0Type BoxType boolType)) (= (type |l#1|) LayerTypeType)) (= (type |l#2|) DatatypeTypeType)) (= (type |l#3|) DatatypeTypeType)) (= (type |$w#0@@0|) BoxType)) (= (MapType0Select (|lambda#1| |l#0@@22| |l#1| |l#2| |l#3|) |$w#0@@0|) ($Box (ite (U_2_bool (MapType0Select |l#0@@22| |$w#0@@0|)) (PivotBetreeRefinement.__default.INode |l#1| (PivotBetree.BetreeNode.Child |l#2| ($Unbox (SeqType BoxType) |$w#0@@0|))) |l#3|))))
 :qid |PivotBetreeRefinementbroken1idfy.34:22|
 :skolemid |7813|
 :pattern ( (MapType0Select (|lambda#1| |l#0@@22| |l#1| |l#2| |l#3|) |$w#0@@0|))
)))
(assert  (and (and (and (and (and (and (and (forall ((arg0@@747 T@T) (arg1@@385 T@T) ) (! (= (Ctor (MapType6Type arg0@@747 arg1@@385)) 28)
 :qid |ctor:MapType6Type|
)) (forall ((arg0@@748 T@T) (arg1@@386 T@T) ) (! (= (MapType6TypeInv0 (MapType6Type arg0@@748 arg1@@386)) arg0@@748)
 :qid |typeInv:MapType6TypeInv0|
 :pattern ( (MapType6Type arg0@@748 arg1@@386))
))) (forall ((arg0@@749 T@T) (arg1@@387 T@T) ) (! (= (MapType6TypeInv1 (MapType6Type arg0@@749 arg1@@387)) arg1@@387)
 :qid |typeInv:MapType6TypeInv1|
 :pattern ( (MapType6Type arg0@@749 arg1@@387))
))) (forall ((arg0@@750 T@U) (arg1@@388 T@U) (arg2@@188 T@U) ) (! (let ((aVar1@@6 (MapType6TypeInv1 (type arg0@@750))))
(= (type (MapType6Select arg0@@750 arg1@@388 arg2@@188)) aVar1@@6))
 :qid |funType:MapType6Select|
 :pattern ( (MapType6Select arg0@@750 arg1@@388 arg2@@188))
))) (forall ((arg0@@751 T@U) (arg1@@389 T@U) (arg2@@189 T@U) (arg3@@103 T@U) ) (! (let ((aVar1@@7 (type arg3@@103)))
(let ((aVar0@@4 (type arg1@@389)))
(= (type (MapType6Store arg0@@751 arg1@@389 arg2@@189 arg3@@103)) (MapType6Type aVar0@@4 aVar1@@7))))
 :qid |funType:MapType6Store|
 :pattern ( (MapType6Store arg0@@751 arg1@@389 arg2@@189 arg3@@103))
))) (forall ((m@@71 T@U) (x0@@27 T@U) (x1@@21 T@U) (val@@28 T@U) ) (! (let ((aVar1@@8 (MapType6TypeInv1 (type m@@71))))
 (=> (= (type val@@28) aVar1@@8) (= (MapType6Select (MapType6Store m@@71 x0@@27 x1@@21 val@@28) x0@@27 x1@@21) val@@28)))
 :qid |mapAx0:MapType6Select|
 :weight 0
))) (and (and (forall ((val@@29 T@U) (m@@72 T@U) (x0@@28 T@U) (x1@@22 T@U) (y0@@21 T@U) (y1@@17 T@U) ) (!  (or (= x0@@28 y0@@21) (= (MapType6Select (MapType6Store m@@72 x0@@28 x1@@22 val@@29) y0@@21 y1@@17) (MapType6Select m@@72 y0@@21 y1@@17)))
 :qid |mapAx1:MapType6Select:0|
 :weight 0
)) (forall ((val@@30 T@U) (m@@73 T@U) (x0@@29 T@U) (x1@@23 T@U) (y0@@22 T@U) (y1@@18 T@U) ) (!  (or (= x1@@23 y1@@18) (= (MapType6Select (MapType6Store m@@73 x0@@29 x1@@23 val@@30) y0@@22 y1@@18) (MapType6Select m@@73 y0@@22 y1@@18)))
 :qid |mapAx1:MapType6Select:1|
 :weight 0
))) (forall ((val@@31 T@U) (m@@74 T@U) (x0@@30 T@U) (x1@@24 T@U) (y0@@23 T@U) (y1@@19 T@U) ) (!  (or true (= (MapType6Select (MapType6Store m@@74 x0@@30 x1@@24 val@@31) y0@@23 y1@@19) (MapType6Select m@@74 y0@@23 y1@@19)))
 :qid |mapAx2:MapType6Select|
 :weight 0
)))) (forall ((arg0@@752 T@U) (arg1@@390 T@U) (arg2@@190 T@U) (arg3@@104 Bool) ) (! (= (type (|lambda#4| arg0@@752 arg1@@390 arg2@@190 arg3@@104)) (MapType6Type refType boolType))
 :qid |funType:lambda#4|
 :pattern ( (|lambda#4| arg0@@752 arg1@@390 arg2@@190 arg3@@104))
))))
(assert (forall ((|l#0@@23| T@U) (|l#1@@0| T@U) (|l#2@@0| T@U) (|l#3@@0| Bool) ($o@@79 T@U) ($f@@1 T@U) ) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1))))
 (=> (and (and (and (and (= (type |l#0@@23|) refType) (= (type |l#1@@0|) (MapType0Type refType MapType1Type))) (= (type |l#2@@0|) (FieldType boolType))) (= (type $o@@79) refType)) (= (type $f@@1) (FieldType alpha@@8))) (= (U_2_bool (MapType6Select (|lambda#4| |l#0@@23| |l#1@@0| |l#2@@0| |l#3@@0|) $o@@79 $f@@1))  (=> (and (not (= $o@@79 |l#0@@23|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@0| $o@@79) |l#2@@0|))) |l#3@@0|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7814|
 :pattern ( (MapType6Select (|lambda#4| |l#0@@23| |l#1@@0| |l#2@@0| |l#3@@0|) $o@@79 $f@@1))
)))
(assert (forall ((arg0@@753 T@U) (arg1@@391 T@U) (arg2@@191 T@U) (arg3@@105 Bool) ) (! (= (type (|lambda#5| arg0@@753 arg1@@391 arg2@@191 arg3@@105)) (MapType6Type refType boolType))
 :qid |funType:lambda#5|
 :pattern ( (|lambda#5| arg0@@753 arg1@@391 arg2@@191 arg3@@105))
)))
(assert (forall ((|l#0@@24| T@U) (|l#1@@1| T@U) (|l#2@@1| T@U) (|l#3@@1| Bool) ($o@@80 T@U) ($f@@2 T@U) ) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2))))
 (=> (and (and (and (and (= (type |l#0@@24|) refType) (= (type |l#1@@1|) (MapType0Type refType MapType1Type))) (= (type |l#2@@1|) (FieldType boolType))) (= (type $o@@80) refType)) (= (type $f@@2) (FieldType alpha@@9))) (= (U_2_bool (MapType6Select (|lambda#5| |l#0@@24| |l#1@@1| |l#2@@1| |l#3@@1|) $o@@80 $f@@2))  (=> (and (not (= $o@@80 |l#0@@24|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@1| $o@@80) |l#2@@1|))) |l#3@@1|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7815|
 :pattern ( (MapType6Select (|lambda#5| |l#0@@24| |l#1@@1| |l#2@@1| |l#3@@1|) $o@@80 $f@@2))
)))
(assert (forall ((arg0@@754 T@U) (arg1@@392 T@U) (arg2@@192 T@U) (arg3@@106 Bool) ) (! (= (type (|lambda#8| arg0@@754 arg1@@392 arg2@@192 arg3@@106)) (MapType6Type refType boolType))
 :qid |funType:lambda#8|
 :pattern ( (|lambda#8| arg0@@754 arg1@@392 arg2@@192 arg3@@106))
)))
(assert (forall ((|l#0@@25| T@U) (|l#1@@2| T@U) (|l#2@@2| T@U) (|l#3@@2| Bool) ($o@@81 T@U) ($f@@3 T@U) ) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3))))
 (=> (and (and (and (and (= (type |l#0@@25|) refType) (= (type |l#1@@2|) (MapType0Type refType MapType1Type))) (= (type |l#2@@2|) (FieldType boolType))) (= (type $o@@81) refType)) (= (type $f@@3) (FieldType alpha@@10))) (= (U_2_bool (MapType6Select (|lambda#8| |l#0@@25| |l#1@@2| |l#2@@2| |l#3@@2|) $o@@81 $f@@3))  (=> (and (not (= $o@@81 |l#0@@25|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@2| $o@@81) |l#2@@2|))) |l#3@@2|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7816|
 :pattern ( (MapType6Select (|lambda#8| |l#0@@25| |l#1@@2| |l#2@@2| |l#3@@2|) $o@@81 $f@@3))
)))
(assert (forall ((arg0@@755 T@U) (arg1@@393 T@U) (arg2@@193 T@U) (arg3@@107 Bool) ) (! (= (type (|lambda#9| arg0@@755 arg1@@393 arg2@@193 arg3@@107)) (MapType6Type refType boolType))
 :qid |funType:lambda#9|
 :pattern ( (|lambda#9| arg0@@755 arg1@@393 arg2@@193 arg3@@107))
)))
(assert (forall ((|l#0@@26| T@U) (|l#1@@3| T@U) (|l#2@@3| T@U) (|l#3@@3| Bool) ($o@@82 T@U) ($f@@4 T@U) ) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4))))
 (=> (and (and (and (and (= (type |l#0@@26|) refType) (= (type |l#1@@3|) (MapType0Type refType MapType1Type))) (= (type |l#2@@3|) (FieldType boolType))) (= (type $o@@82) refType)) (= (type $f@@4) (FieldType alpha@@11))) (= (U_2_bool (MapType6Select (|lambda#9| |l#0@@26| |l#1@@3| |l#2@@3| |l#3@@3|) $o@@82 $f@@4))  (=> (and (not (= $o@@82 |l#0@@26|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@3| $o@@82) |l#2@@3|))) |l#3@@3|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7817|
 :pattern ( (MapType6Select (|lambda#9| |l#0@@26| |l#1@@3| |l#2@@3| |l#3@@3|) $o@@82 $f@@4))
)))
(assert (forall ((arg0@@756 T@U) (arg1@@394 T@U) (arg2@@194 T@U) (arg3@@108 Bool) ) (! (= (type (|lambda#10| arg0@@756 arg1@@394 arg2@@194 arg3@@108)) (MapType6Type refType boolType))
 :qid |funType:lambda#10|
 :pattern ( (|lambda#10| arg0@@756 arg1@@394 arg2@@194 arg3@@108))
)))
(assert (forall ((|l#0@@27| T@U) (|l#1@@4| T@U) (|l#2@@4| T@U) (|l#3@@4| Bool) ($o@@83 T@U) ($f@@5 T@U) ) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5))))
 (=> (and (and (and (and (= (type |l#0@@27|) refType) (= (type |l#1@@4|) (MapType0Type refType MapType1Type))) (= (type |l#2@@4|) (FieldType boolType))) (= (type $o@@83) refType)) (= (type $f@@5) (FieldType alpha@@12))) (= (U_2_bool (MapType6Select (|lambda#10| |l#0@@27| |l#1@@4| |l#2@@4| |l#3@@4|) $o@@83 $f@@5))  (=> (and (not (= $o@@83 |l#0@@27|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@4| $o@@83) |l#2@@4|))) |l#3@@4|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7818|
 :pattern ( (MapType6Select (|lambda#10| |l#0@@27| |l#1@@4| |l#2@@4| |l#3@@4|) $o@@83 $f@@5))
)))
(assert (forall ((arg0@@757 T@U) (arg1@@395 T@U) (arg2@@195 T@U) (arg3@@109 Bool) ) (! (= (type (|lambda#11| arg0@@757 arg1@@395 arg2@@195 arg3@@109)) (MapType6Type refType boolType))
 :qid |funType:lambda#11|
 :pattern ( (|lambda#11| arg0@@757 arg1@@395 arg2@@195 arg3@@109))
)))
(assert (forall ((|l#0@@28| T@U) (|l#1@@5| T@U) (|l#2@@5| T@U) (|l#3@@5| Bool) ($o@@84 T@U) ($f@@6 T@U) ) (! (let ((alpha@@13 (FieldTypeInv0 (type $f@@6))))
 (=> (and (and (and (and (= (type |l#0@@28|) refType) (= (type |l#1@@5|) (MapType0Type refType MapType1Type))) (= (type |l#2@@5|) (FieldType boolType))) (= (type $o@@84) refType)) (= (type $f@@6) (FieldType alpha@@13))) (= (U_2_bool (MapType6Select (|lambda#11| |l#0@@28| |l#1@@5| |l#2@@5| |l#3@@5|) $o@@84 $f@@6))  (=> (and (not (= $o@@84 |l#0@@28|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@5| $o@@84) |l#2@@5|))) |l#3@@5|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7819|
 :pattern ( (MapType6Select (|lambda#11| |l#0@@28| |l#1@@5| |l#2@@5| |l#3@@5|) $o@@84 $f@@6))
)))
(assert (forall ((arg0@@758 T@U) (arg1@@396 T@U) (arg2@@196 T@U) (arg3@@110 Bool) ) (! (= (type (|lambda#12| arg0@@758 arg1@@396 arg2@@196 arg3@@110)) (MapType6Type refType boolType))
 :qid |funType:lambda#12|
 :pattern ( (|lambda#12| arg0@@758 arg1@@396 arg2@@196 arg3@@110))
)))
(assert (forall ((|l#0@@29| T@U) (|l#1@@6| T@U) (|l#2@@6| T@U) (|l#3@@6| Bool) ($o@@85 T@U) ($f@@7 T@U) ) (! (let ((alpha@@14 (FieldTypeInv0 (type $f@@7))))
 (=> (and (and (and (and (= (type |l#0@@29|) refType) (= (type |l#1@@6|) (MapType0Type refType MapType1Type))) (= (type |l#2@@6|) (FieldType boolType))) (= (type $o@@85) refType)) (= (type $f@@7) (FieldType alpha@@14))) (= (U_2_bool (MapType6Select (|lambda#12| |l#0@@29| |l#1@@6| |l#2@@6| |l#3@@6|) $o@@85 $f@@7))  (=> (and (not (= $o@@85 |l#0@@29|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@6| $o@@85) |l#2@@6|))) |l#3@@6|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7820|
 :pattern ( (MapType6Select (|lambda#12| |l#0@@29| |l#1@@6| |l#2@@6| |l#3@@6|) $o@@85 $f@@7))
)))
(assert (forall ((arg0@@759 T@U) (arg1@@397 T@U) (arg2@@197 T@U) (arg3@@111 Bool) ) (! (= (type (|lambda#13| arg0@@759 arg1@@397 arg2@@197 arg3@@111)) (MapType6Type refType boolType))
 :qid |funType:lambda#13|
 :pattern ( (|lambda#13| arg0@@759 arg1@@397 arg2@@197 arg3@@111))
)))
(assert (forall ((|l#0@@30| T@U) (|l#1@@7| T@U) (|l#2@@7| T@U) (|l#3@@7| Bool) ($o@@86 T@U) ($f@@8 T@U) ) (! (let ((alpha@@15 (FieldTypeInv0 (type $f@@8))))
 (=> (and (and (and (and (= (type |l#0@@30|) refType) (= (type |l#1@@7|) (MapType0Type refType MapType1Type))) (= (type |l#2@@7|) (FieldType boolType))) (= (type $o@@86) refType)) (= (type $f@@8) (FieldType alpha@@15))) (= (U_2_bool (MapType6Select (|lambda#13| |l#0@@30| |l#1@@7| |l#2@@7| |l#3@@7|) $o@@86 $f@@8))  (=> (and (not (= $o@@86 |l#0@@30|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@7| $o@@86) |l#2@@7|))) |l#3@@7|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7821|
 :pattern ( (MapType6Select (|lambda#13| |l#0@@30| |l#1@@7| |l#2@@7| |l#3@@7|) $o@@86 $f@@8))
)))
(assert (forall ((arg0@@760 T@U) (arg1@@398 T@U) (arg2@@198 T@U) (arg3@@112 Bool) ) (! (= (type (|lambda#14| arg0@@760 arg1@@398 arg2@@198 arg3@@112)) (MapType6Type refType boolType))
 :qid |funType:lambda#14|
 :pattern ( (|lambda#14| arg0@@760 arg1@@398 arg2@@198 arg3@@112))
)))
(assert (forall ((|l#0@@31| T@U) (|l#1@@8| T@U) (|l#2@@8| T@U) (|l#3@@8| Bool) ($o@@87 T@U) ($f@@9 T@U) ) (! (let ((alpha@@16 (FieldTypeInv0 (type $f@@9))))
 (=> (and (and (and (and (= (type |l#0@@31|) refType) (= (type |l#1@@8|) (MapType0Type refType MapType1Type))) (= (type |l#2@@8|) (FieldType boolType))) (= (type $o@@87) refType)) (= (type $f@@9) (FieldType alpha@@16))) (= (U_2_bool (MapType6Select (|lambda#14| |l#0@@31| |l#1@@8| |l#2@@8| |l#3@@8|) $o@@87 $f@@9))  (=> (and (not (= $o@@87 |l#0@@31|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@8| $o@@87) |l#2@@8|))) |l#3@@8|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7822|
 :pattern ( (MapType6Select (|lambda#14| |l#0@@31| |l#1@@8| |l#2@@8| |l#3@@8|) $o@@87 $f@@9))
)))
(assert (forall ((arg0@@761 T@U) (arg1@@399 T@U) (arg2@@199 T@U) (arg3@@113 Bool) ) (! (= (type (|lambda#15| arg0@@761 arg1@@399 arg2@@199 arg3@@113)) (MapType6Type refType boolType))
 :qid |funType:lambda#15|
 :pattern ( (|lambda#15| arg0@@761 arg1@@399 arg2@@199 arg3@@113))
)))
(assert (forall ((|l#0@@32| T@U) (|l#1@@9| T@U) (|l#2@@9| T@U) (|l#3@@9| Bool) ($o@@88 T@U) ($f@@10 T@U) ) (! (let ((alpha@@17 (FieldTypeInv0 (type $f@@10))))
 (=> (and (and (and (and (= (type |l#0@@32|) refType) (= (type |l#1@@9|) (MapType0Type refType MapType1Type))) (= (type |l#2@@9|) (FieldType boolType))) (= (type $o@@88) refType)) (= (type $f@@10) (FieldType alpha@@17))) (= (U_2_bool (MapType6Select (|lambda#15| |l#0@@32| |l#1@@9| |l#2@@9| |l#3@@9|) $o@@88 $f@@10))  (=> (and (not (= $o@@88 |l#0@@32|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@9| $o@@88) |l#2@@9|))) |l#3@@9|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7823|
 :pattern ( (MapType6Select (|lambda#15| |l#0@@32| |l#1@@9| |l#2@@9| |l#3@@9|) $o@@88 $f@@10))
)))
(assert (forall ((arg0@@762 T@U) (arg1@@400 T@U) (arg2@@200 T@U) (arg3@@114 Bool) ) (! (= (type (|lambda#16| arg0@@762 arg1@@400 arg2@@200 arg3@@114)) (MapType6Type refType boolType))
 :qid |funType:lambda#16|
 :pattern ( (|lambda#16| arg0@@762 arg1@@400 arg2@@200 arg3@@114))
)))
(assert (forall ((|l#0@@33| T@U) (|l#1@@10| T@U) (|l#2@@10| T@U) (|l#3@@10| Bool) ($o@@89 T@U) ($f@@11 T@U) ) (! (let ((alpha@@18 (FieldTypeInv0 (type $f@@11))))
 (=> (and (and (and (and (= (type |l#0@@33|) refType) (= (type |l#1@@10|) (MapType0Type refType MapType1Type))) (= (type |l#2@@10|) (FieldType boolType))) (= (type $o@@89) refType)) (= (type $f@@11) (FieldType alpha@@18))) (= (U_2_bool (MapType6Select (|lambda#16| |l#0@@33| |l#1@@10| |l#2@@10| |l#3@@10|) $o@@89 $f@@11))  (=> (and (not (= $o@@89 |l#0@@33|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@10| $o@@89) |l#2@@10|))) |l#3@@10|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7824|
 :pattern ( (MapType6Select (|lambda#16| |l#0@@33| |l#1@@10| |l#2@@10| |l#3@@10|) $o@@89 $f@@11))
)))
(assert (forall ((arg0@@763 T@U) (arg1@@401 T@U) (arg2@@201 T@U) (arg3@@115 Bool) ) (! (= (type (|lambda#17| arg0@@763 arg1@@401 arg2@@201 arg3@@115)) (MapType6Type refType boolType))
 :qid |funType:lambda#17|
 :pattern ( (|lambda#17| arg0@@763 arg1@@401 arg2@@201 arg3@@115))
)))
(assert (forall ((|l#0@@34| T@U) (|l#1@@11| T@U) (|l#2@@11| T@U) (|l#3@@11| Bool) ($o@@90 T@U) ($f@@12 T@U) ) (! (let ((alpha@@19 (FieldTypeInv0 (type $f@@12))))
 (=> (and (and (and (and (= (type |l#0@@34|) refType) (= (type |l#1@@11|) (MapType0Type refType MapType1Type))) (= (type |l#2@@11|) (FieldType boolType))) (= (type $o@@90) refType)) (= (type $f@@12) (FieldType alpha@@19))) (= (U_2_bool (MapType6Select (|lambda#17| |l#0@@34| |l#1@@11| |l#2@@11| |l#3@@11|) $o@@90 $f@@12))  (=> (and (not (= $o@@90 |l#0@@34|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@11| $o@@90) |l#2@@11|))) |l#3@@11|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7825|
 :pattern ( (MapType6Select (|lambda#17| |l#0@@34| |l#1@@11| |l#2@@11| |l#3@@11|) $o@@90 $f@@12))
)))
(assert (forall ((arg0@@764 T@U) (arg1@@402 T@U) (arg2@@202 T@U) (arg3@@116 Bool) ) (! (= (type (|lambda#18| arg0@@764 arg1@@402 arg2@@202 arg3@@116)) (MapType6Type refType boolType))
 :qid |funType:lambda#18|
 :pattern ( (|lambda#18| arg0@@764 arg1@@402 arg2@@202 arg3@@116))
)))
(assert (forall ((|l#0@@35| T@U) (|l#1@@12| T@U) (|l#2@@12| T@U) (|l#3@@12| Bool) ($o@@91 T@U) ($f@@13 T@U) ) (! (let ((alpha@@20 (FieldTypeInv0 (type $f@@13))))
 (=> (and (and (and (and (= (type |l#0@@35|) refType) (= (type |l#1@@12|) (MapType0Type refType MapType1Type))) (= (type |l#2@@12|) (FieldType boolType))) (= (type $o@@91) refType)) (= (type $f@@13) (FieldType alpha@@20))) (= (U_2_bool (MapType6Select (|lambda#18| |l#0@@35| |l#1@@12| |l#2@@12| |l#3@@12|) $o@@91 $f@@13))  (=> (and (not (= $o@@91 |l#0@@35|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@12| $o@@91) |l#2@@12|))) |l#3@@12|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7826|
 :pattern ( (MapType6Select (|lambda#18| |l#0@@35| |l#1@@12| |l#2@@12| |l#3@@12|) $o@@91 $f@@13))
)))
(assert (forall ((arg0@@765 T@U) (arg1@@403 T@U) (arg2@@203 T@U) (arg3@@117 Bool) ) (! (= (type (|lambda#19| arg0@@765 arg1@@403 arg2@@203 arg3@@117)) (MapType6Type refType boolType))
 :qid |funType:lambda#19|
 :pattern ( (|lambda#19| arg0@@765 arg1@@403 arg2@@203 arg3@@117))
)))
(assert (forall ((|l#0@@36| T@U) (|l#1@@13| T@U) (|l#2@@13| T@U) (|l#3@@13| Bool) ($o@@92 T@U) ($f@@14 T@U) ) (! (let ((alpha@@21 (FieldTypeInv0 (type $f@@14))))
 (=> (and (and (and (and (= (type |l#0@@36|) refType) (= (type |l#1@@13|) (MapType0Type refType MapType1Type))) (= (type |l#2@@13|) (FieldType boolType))) (= (type $o@@92) refType)) (= (type $f@@14) (FieldType alpha@@21))) (= (U_2_bool (MapType6Select (|lambda#19| |l#0@@36| |l#1@@13| |l#2@@13| |l#3@@13|) $o@@92 $f@@14))  (=> (and (not (= $o@@92 |l#0@@36|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@13| $o@@92) |l#2@@13|))) |l#3@@13|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7827|
 :pattern ( (MapType6Select (|lambda#19| |l#0@@36| |l#1@@13| |l#2@@13| |l#3@@13|) $o@@92 $f@@14))
)))
(assert (forall ((arg0@@766 T@U) (arg1@@404 T@U) (arg2@@204 T@U) (arg3@@118 Bool) ) (! (= (type (|lambda#20| arg0@@766 arg1@@404 arg2@@204 arg3@@118)) (MapType6Type refType boolType))
 :qid |funType:lambda#20|
 :pattern ( (|lambda#20| arg0@@766 arg1@@404 arg2@@204 arg3@@118))
)))
(assert (forall ((|l#0@@37| T@U) (|l#1@@14| T@U) (|l#2@@14| T@U) (|l#3@@14| Bool) ($o@@93 T@U) ($f@@15 T@U) ) (! (let ((alpha@@22 (FieldTypeInv0 (type $f@@15))))
 (=> (and (and (and (and (= (type |l#0@@37|) refType) (= (type |l#1@@14|) (MapType0Type refType MapType1Type))) (= (type |l#2@@14|) (FieldType boolType))) (= (type $o@@93) refType)) (= (type $f@@15) (FieldType alpha@@22))) (= (U_2_bool (MapType6Select (|lambda#20| |l#0@@37| |l#1@@14| |l#2@@14| |l#3@@14|) $o@@93 $f@@15))  (=> (and (not (= $o@@93 |l#0@@37|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@14| $o@@93) |l#2@@14|))) |l#3@@14|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7828|
 :pattern ( (MapType6Select (|lambda#20| |l#0@@37| |l#1@@14| |l#2@@14| |l#3@@14|) $o@@93 $f@@15))
)))
(assert (forall ((arg0@@767 T@U) (arg1@@405 T@U) (arg2@@205 T@U) (arg3@@119 Bool) ) (! (= (type (|lambda#21| arg0@@767 arg1@@405 arg2@@205 arg3@@119)) (MapType6Type refType boolType))
 :qid |funType:lambda#21|
 :pattern ( (|lambda#21| arg0@@767 arg1@@405 arg2@@205 arg3@@119))
)))
(assert (forall ((|l#0@@38| T@U) (|l#1@@15| T@U) (|l#2@@15| T@U) (|l#3@@15| Bool) ($o@@94 T@U) ($f@@16 T@U) ) (! (let ((alpha@@23 (FieldTypeInv0 (type $f@@16))))
 (=> (and (and (and (and (= (type |l#0@@38|) refType) (= (type |l#1@@15|) (MapType0Type refType MapType1Type))) (= (type |l#2@@15|) (FieldType boolType))) (= (type $o@@94) refType)) (= (type $f@@16) (FieldType alpha@@23))) (= (U_2_bool (MapType6Select (|lambda#21| |l#0@@38| |l#1@@15| |l#2@@15| |l#3@@15|) $o@@94 $f@@16))  (=> (and (not (= $o@@94 |l#0@@38|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@15| $o@@94) |l#2@@15|))) |l#3@@15|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7829|
 :pattern ( (MapType6Select (|lambda#21| |l#0@@38| |l#1@@15| |l#2@@15| |l#3@@15|) $o@@94 $f@@16))
)))
(assert (forall ((arg0@@768 T@U) (arg1@@406 T@U) (arg2@@206 T@U) (arg3@@120 Bool) ) (! (= (type (|lambda#22| arg0@@768 arg1@@406 arg2@@206 arg3@@120)) (MapType6Type refType boolType))
 :qid |funType:lambda#22|
 :pattern ( (|lambda#22| arg0@@768 arg1@@406 arg2@@206 arg3@@120))
)))
(assert (forall ((|l#0@@39| T@U) (|l#1@@16| T@U) (|l#2@@16| T@U) (|l#3@@16| Bool) ($o@@95 T@U) ($f@@17 T@U) ) (! (let ((alpha@@24 (FieldTypeInv0 (type $f@@17))))
 (=> (and (and (and (and (= (type |l#0@@39|) refType) (= (type |l#1@@16|) (MapType0Type refType MapType1Type))) (= (type |l#2@@16|) (FieldType boolType))) (= (type $o@@95) refType)) (= (type $f@@17) (FieldType alpha@@24))) (= (U_2_bool (MapType6Select (|lambda#22| |l#0@@39| |l#1@@16| |l#2@@16| |l#3@@16|) $o@@95 $f@@17))  (=> (and (not (= $o@@95 |l#0@@39|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@16| $o@@95) |l#2@@16|))) |l#3@@16|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7830|
 :pattern ( (MapType6Select (|lambda#22| |l#0@@39| |l#1@@16| |l#2@@16| |l#3@@16|) $o@@95 $f@@17))
)))
(assert (forall ((arg0@@769 T@U) (arg1@@407 T@U) (arg2@@207 T@U) (arg3@@121 Bool) ) (! (= (type (|lambda#23| arg0@@769 arg1@@407 arg2@@207 arg3@@121)) (MapType6Type refType boolType))
 :qid |funType:lambda#23|
 :pattern ( (|lambda#23| arg0@@769 arg1@@407 arg2@@207 arg3@@121))
)))
(assert (forall ((|l#0@@40| T@U) (|l#1@@17| T@U) (|l#2@@17| T@U) (|l#3@@17| Bool) ($o@@96 T@U) ($f@@18 T@U) ) (! (let ((alpha@@25 (FieldTypeInv0 (type $f@@18))))
 (=> (and (and (and (and (= (type |l#0@@40|) refType) (= (type |l#1@@17|) (MapType0Type refType MapType1Type))) (= (type |l#2@@17|) (FieldType boolType))) (= (type $o@@96) refType)) (= (type $f@@18) (FieldType alpha@@25))) (= (U_2_bool (MapType6Select (|lambda#23| |l#0@@40| |l#1@@17| |l#2@@17| |l#3@@17|) $o@@96 $f@@18))  (=> (and (not (= $o@@96 |l#0@@40|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@17| $o@@96) |l#2@@17|))) |l#3@@17|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7831|
 :pattern ( (MapType6Select (|lambda#23| |l#0@@40| |l#1@@17| |l#2@@17| |l#3@@17|) $o@@96 $f@@18))
)))
(assert (forall ((arg0@@770 T@U) (arg1@@408 T@U) (arg2@@208 T@U) (arg3@@122 Bool) ) (! (= (type (|lambda#24| arg0@@770 arg1@@408 arg2@@208 arg3@@122)) (MapType6Type refType boolType))
 :qid |funType:lambda#24|
 :pattern ( (|lambda#24| arg0@@770 arg1@@408 arg2@@208 arg3@@122))
)))
(assert (forall ((|l#0@@41| T@U) (|l#1@@18| T@U) (|l#2@@18| T@U) (|l#3@@18| Bool) ($o@@97 T@U) ($f@@19 T@U) ) (! (let ((alpha@@26 (FieldTypeInv0 (type $f@@19))))
 (=> (and (and (and (and (= (type |l#0@@41|) refType) (= (type |l#1@@18|) (MapType0Type refType MapType1Type))) (= (type |l#2@@18|) (FieldType boolType))) (= (type $o@@97) refType)) (= (type $f@@19) (FieldType alpha@@26))) (= (U_2_bool (MapType6Select (|lambda#24| |l#0@@41| |l#1@@18| |l#2@@18| |l#3@@18|) $o@@97 $f@@19))  (=> (and (not (= $o@@97 |l#0@@41|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@18| $o@@97) |l#2@@18|))) |l#3@@18|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7832|
 :pattern ( (MapType6Select (|lambda#24| |l#0@@41| |l#1@@18| |l#2@@18| |l#3@@18|) $o@@97 $f@@19))
)))
(assert (forall ((arg0@@771 T@U) (arg1@@409 T@U) (arg2@@209 T@U) (arg3@@123 Bool) ) (! (= (type (|lambda#25| arg0@@771 arg1@@409 arg2@@209 arg3@@123)) (MapType6Type refType boolType))
 :qid |funType:lambda#25|
 :pattern ( (|lambda#25| arg0@@771 arg1@@409 arg2@@209 arg3@@123))
)))
(assert (forall ((|l#0@@42| T@U) (|l#1@@19| T@U) (|l#2@@19| T@U) (|l#3@@19| Bool) ($o@@98 T@U) ($f@@20 T@U) ) (! (let ((alpha@@27 (FieldTypeInv0 (type $f@@20))))
 (=> (and (and (and (and (= (type |l#0@@42|) refType) (= (type |l#1@@19|) (MapType0Type refType MapType1Type))) (= (type |l#2@@19|) (FieldType boolType))) (= (type $o@@98) refType)) (= (type $f@@20) (FieldType alpha@@27))) (= (U_2_bool (MapType6Select (|lambda#25| |l#0@@42| |l#1@@19| |l#2@@19| |l#3@@19|) $o@@98 $f@@20))  (=> (and (not (= $o@@98 |l#0@@42|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@19| $o@@98) |l#2@@19|))) |l#3@@19|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7833|
 :pattern ( (MapType6Select (|lambda#25| |l#0@@42| |l#1@@19| |l#2@@19| |l#3@@19|) $o@@98 $f@@20))
)))
(assert (forall ((arg0@@772 T@U) (arg1@@410 T@U) (arg2@@210 T@U) (arg3@@124 Bool) ) (! (= (type (|lambda#26| arg0@@772 arg1@@410 arg2@@210 arg3@@124)) (MapType6Type refType boolType))
 :qid |funType:lambda#26|
 :pattern ( (|lambda#26| arg0@@772 arg1@@410 arg2@@210 arg3@@124))
)))
(assert (forall ((|l#0@@43| T@U) (|l#1@@20| T@U) (|l#2@@20| T@U) (|l#3@@20| Bool) ($o@@99 T@U) ($f@@21 T@U) ) (! (let ((alpha@@28 (FieldTypeInv0 (type $f@@21))))
 (=> (and (and (and (and (= (type |l#0@@43|) refType) (= (type |l#1@@20|) (MapType0Type refType MapType1Type))) (= (type |l#2@@20|) (FieldType boolType))) (= (type $o@@99) refType)) (= (type $f@@21) (FieldType alpha@@28))) (= (U_2_bool (MapType6Select (|lambda#26| |l#0@@43| |l#1@@20| |l#2@@20| |l#3@@20|) $o@@99 $f@@21))  (=> (and (not (= $o@@99 |l#0@@43|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@20| $o@@99) |l#2@@20|))) |l#3@@20|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7834|
 :pattern ( (MapType6Select (|lambda#26| |l#0@@43| |l#1@@20| |l#2@@20| |l#3@@20|) $o@@99 $f@@21))
)))
(assert (forall ((arg0@@773 T@U) (arg1@@411 T@U) (arg2@@211 T@U) (arg3@@125 Bool) ) (! (= (type (|lambda#27| arg0@@773 arg1@@411 arg2@@211 arg3@@125)) (MapType6Type refType boolType))
 :qid |funType:lambda#27|
 :pattern ( (|lambda#27| arg0@@773 arg1@@411 arg2@@211 arg3@@125))
)))
(assert (forall ((|l#0@@44| T@U) (|l#1@@21| T@U) (|l#2@@21| T@U) (|l#3@@21| Bool) ($o@@100 T@U) ($f@@22 T@U) ) (! (let ((alpha@@29 (FieldTypeInv0 (type $f@@22))))
 (=> (and (and (and (and (= (type |l#0@@44|) refType) (= (type |l#1@@21|) (MapType0Type refType MapType1Type))) (= (type |l#2@@21|) (FieldType boolType))) (= (type $o@@100) refType)) (= (type $f@@22) (FieldType alpha@@29))) (= (U_2_bool (MapType6Select (|lambda#27| |l#0@@44| |l#1@@21| |l#2@@21| |l#3@@21|) $o@@100 $f@@22))  (=> (and (not (= $o@@100 |l#0@@44|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@21| $o@@100) |l#2@@21|))) |l#3@@21|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7835|
 :pattern ( (MapType6Select (|lambda#27| |l#0@@44| |l#1@@21| |l#2@@21| |l#3@@21|) $o@@100 $f@@22))
)))
(assert (forall ((arg0@@774 T@U) (arg1@@412 T@U) (arg2@@212 T@U) (arg3@@126 Bool) ) (! (= (type (|lambda#28| arg0@@774 arg1@@412 arg2@@212 arg3@@126)) (MapType6Type refType boolType))
 :qid |funType:lambda#28|
 :pattern ( (|lambda#28| arg0@@774 arg1@@412 arg2@@212 arg3@@126))
)))
(assert (forall ((|l#0@@45| T@U) (|l#1@@22| T@U) (|l#2@@22| T@U) (|l#3@@22| Bool) ($o@@101 T@U) ($f@@23 T@U) ) (! (let ((alpha@@30 (FieldTypeInv0 (type $f@@23))))
 (=> (and (and (and (and (= (type |l#0@@45|) refType) (= (type |l#1@@22|) (MapType0Type refType MapType1Type))) (= (type |l#2@@22|) (FieldType boolType))) (= (type $o@@101) refType)) (= (type $f@@23) (FieldType alpha@@30))) (= (U_2_bool (MapType6Select (|lambda#28| |l#0@@45| |l#1@@22| |l#2@@22| |l#3@@22|) $o@@101 $f@@23))  (=> (and (not (= $o@@101 |l#0@@45|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@22| $o@@101) |l#2@@22|))) |l#3@@22|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7836|
 :pattern ( (MapType6Select (|lambda#28| |l#0@@45| |l#1@@22| |l#2@@22| |l#3@@22|) $o@@101 $f@@23))
)))
(assert (forall ((arg0@@775 T@U) (arg1@@413 T@U) (arg2@@213 T@U) (arg3@@127 Bool) ) (! (= (type (|lambda#29| arg0@@775 arg1@@413 arg2@@213 arg3@@127)) (MapType6Type refType boolType))
 :qid |funType:lambda#29|
 :pattern ( (|lambda#29| arg0@@775 arg1@@413 arg2@@213 arg3@@127))
)))
(assert (forall ((|l#0@@46| T@U) (|l#1@@23| T@U) (|l#2@@23| T@U) (|l#3@@23| Bool) ($o@@102 T@U) ($f@@24 T@U) ) (! (let ((alpha@@31 (FieldTypeInv0 (type $f@@24))))
 (=> (and (and (and (and (= (type |l#0@@46|) refType) (= (type |l#1@@23|) (MapType0Type refType MapType1Type))) (= (type |l#2@@23|) (FieldType boolType))) (= (type $o@@102) refType)) (= (type $f@@24) (FieldType alpha@@31))) (= (U_2_bool (MapType6Select (|lambda#29| |l#0@@46| |l#1@@23| |l#2@@23| |l#3@@23|) $o@@102 $f@@24))  (=> (and (not (= $o@@102 |l#0@@46|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@23| $o@@102) |l#2@@23|))) |l#3@@23|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7837|
 :pattern ( (MapType6Select (|lambda#29| |l#0@@46| |l#1@@23| |l#2@@23| |l#3@@23|) $o@@102 $f@@24))
)))
(assert (forall ((arg0@@776 T@U) (arg1@@414 T@U) (arg2@@214 T@U) (arg3@@128 Bool) ) (! (= (type (|lambda#30| arg0@@776 arg1@@414 arg2@@214 arg3@@128)) (MapType6Type refType boolType))
 :qid |funType:lambda#30|
 :pattern ( (|lambda#30| arg0@@776 arg1@@414 arg2@@214 arg3@@128))
)))
(assert (forall ((|l#0@@47| T@U) (|l#1@@24| T@U) (|l#2@@24| T@U) (|l#3@@24| Bool) ($o@@103 T@U) ($f@@25 T@U) ) (! (let ((alpha@@32 (FieldTypeInv0 (type $f@@25))))
 (=> (and (and (and (and (= (type |l#0@@47|) refType) (= (type |l#1@@24|) (MapType0Type refType MapType1Type))) (= (type |l#2@@24|) (FieldType boolType))) (= (type $o@@103) refType)) (= (type $f@@25) (FieldType alpha@@32))) (= (U_2_bool (MapType6Select (|lambda#30| |l#0@@47| |l#1@@24| |l#2@@24| |l#3@@24|) $o@@103 $f@@25))  (=> (and (not (= $o@@103 |l#0@@47|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@24| $o@@103) |l#2@@24|))) |l#3@@24|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7838|
 :pattern ( (MapType6Select (|lambda#30| |l#0@@47| |l#1@@24| |l#2@@24| |l#3@@24|) $o@@103 $f@@25))
)))
(assert (forall ((|l#0@@48| T@U) (|$l#0#heap#0| T@U) (|$l#0#i#0| T@U) ) (!  (=> (and (and (= (type |l#0@@48|) (SeqType BoxType)) (= (type |$l#0#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0|) BoxType)) (= (MapType2Select (|lambda#31| |l#0@@48|) |$l#0#heap#0| |$l#0#i#0|) ($Box (PivotBetreeRefinement.__default.IReceiptLine ($Unbox DatatypeTypeType (|Seq#Index| |l#0@@48| (U_2_int ($Unbox intType |$l#0#i#0|))))))))
 :qid |PivotBetreeRefinementbroken1idfy.160:84|
 :skolemid |7839|
 :pattern ( (MapType2Select (|lambda#31| |l#0@@48|) |$l#0#heap#0| |$l#0#i#0|))
)))
(assert (forall ((|l#0@@49| T@U) (|l#1@@25| Int) (|l#2@@25| Int) (|$l#0#heap#0@@0| T@U) (|$l#0#i#0@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@49|) TyType) (= (type |$l#0#heap#0@@0|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@0|) BoxType)) (= (U_2_bool (MapType2Select (|lambda#32| |l#0@@49| |l#1@@25| |l#2@@25|) |$l#0#heap#0@@0| |$l#0#i#0@@0|))  (and ($IsBox |$l#0#i#0@@0| |l#0@@49|) (and (INTERNAL_le_boogie |l#1@@25| (U_2_int ($Unbox intType |$l#0#i#0@@0|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$l#0#i#0@@0|)) |l#2@@25|)))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |7840|
 :pattern ( (MapType2Select (|lambda#32| |l#0@@49| |l#1@@25| |l#2@@25|) |$l#0#heap#0@@0| |$l#0#i#0@@0|))
)))
(assert (forall ((|l#0@@50| Bool) (|$l#0#o#0| T@U) ) (!  (=> (= (type |$l#0#o#0|) refType) (= (U_2_bool (MapType0Select (|lambda#33| |l#0@@50|) |$l#0#o#0|)) |l#0@@50|))
 :qid |unknown.0:0|
 :skolemid |7841|
 :pattern ( (MapType0Select (|lambda#33| |l#0@@50|) |$l#0#o#0|))
)))
(assert (forall ((|l#0@@51| T@U) (|$l#0#heap#0@@1| T@U) (|$l#0#i#0@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@51|) (MapType0Type BoxType boolType)) (= (type |$l#0#heap#0@@1|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@1|) BoxType)) (= (MapType2Select (|lambda#34| |l#0@@51|) |$l#0#heap#0@@1| |$l#0#i#0@@1|) |l#0@@51|))
 :qid |PivotBetreeRefinementbroken1idfy.160:28|
 :skolemid |7842|
 :pattern ( (MapType2Select (|lambda#34| |l#0@@51|) |$l#0#heap#0@@1| |$l#0#i#0@@1|))
)))
(assert (forall ((|l#0@@52| T@U) (|$l#0#ly#0| T@U) ) (!  (=> (and (= (type |l#0@@52|) HandleTypeType) (= (type |$l#0#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#35| |l#0@@52|) |$l#0#ly#0|) |l#0@@52|))
 :qid |PivotBetreeRefinementbroken1idfy.160:28|
 :skolemid |7843|
 :pattern ( (MapType0Select (|lambda#35| |l#0@@52|) |$l#0#ly#0|))
)))
(assert (forall ((arg0@@777 T@U) (arg1@@415 T@U) (arg2@@215 T@U) (arg3@@129 Bool) ) (! (= (type (|lambda#41| arg0@@777 arg1@@415 arg2@@215 arg3@@129)) (MapType6Type refType boolType))
 :qid |funType:lambda#41|
 :pattern ( (|lambda#41| arg0@@777 arg1@@415 arg2@@215 arg3@@129))
)))
(assert (forall ((|l#0@@53| T@U) (|l#1@@26| T@U) (|l#2@@26| T@U) (|l#3@@25| Bool) ($o@@104 T@U) ($f@@26 T@U) ) (! (let ((alpha@@33 (FieldTypeInv0 (type $f@@26))))
 (=> (and (and (and (and (= (type |l#0@@53|) refType) (= (type |l#1@@26|) (MapType0Type refType MapType1Type))) (= (type |l#2@@26|) (FieldType boolType))) (= (type $o@@104) refType)) (= (type $f@@26) (FieldType alpha@@33))) (= (U_2_bool (MapType6Select (|lambda#41| |l#0@@53| |l#1@@26| |l#2@@26| |l#3@@25|) $o@@104 $f@@26))  (=> (and (not (= $o@@104 |l#0@@53|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@26| $o@@104) |l#2@@26|))) |l#3@@25|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7844|
 :pattern ( (MapType6Select (|lambda#41| |l#0@@53| |l#1@@26| |l#2@@26| |l#3@@25|) $o@@104 $f@@26))
)))
(assert (forall ((arg0@@778 T@U) (arg1@@416 T@U) (arg2@@216 T@U) (arg3@@130 Bool) ) (! (= (type (|lambda#42| arg0@@778 arg1@@416 arg2@@216 arg3@@130)) (MapType6Type refType boolType))
 :qid |funType:lambda#42|
 :pattern ( (|lambda#42| arg0@@778 arg1@@416 arg2@@216 arg3@@130))
)))
(assert (forall ((|l#0@@54| T@U) (|l#1@@27| T@U) (|l#2@@27| T@U) (|l#3@@26| Bool) ($o@@105 T@U) ($f@@27 T@U) ) (! (let ((alpha@@34 (FieldTypeInv0 (type $f@@27))))
 (=> (and (and (and (and (= (type |l#0@@54|) refType) (= (type |l#1@@27|) (MapType0Type refType MapType1Type))) (= (type |l#2@@27|) (FieldType boolType))) (= (type $o@@105) refType)) (= (type $f@@27) (FieldType alpha@@34))) (= (U_2_bool (MapType6Select (|lambda#42| |l#0@@54| |l#1@@27| |l#2@@27| |l#3@@26|) $o@@105 $f@@27))  (=> (and (not (= $o@@105 |l#0@@54|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@27| $o@@105) |l#2@@27|))) |l#3@@26|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7845|
 :pattern ( (MapType6Select (|lambda#42| |l#0@@54| |l#1@@27| |l#2@@27| |l#3@@26|) $o@@105 $f@@27))
)))
(assert (forall ((arg0@@779 T@U) (arg1@@417 T@U) (arg2@@217 T@U) (arg3@@131 Bool) ) (! (= (type (|lambda#53| arg0@@779 arg1@@417 arg2@@217 arg3@@131)) (MapType6Type refType boolType))
 :qid |funType:lambda#53|
 :pattern ( (|lambda#53| arg0@@779 arg1@@417 arg2@@217 arg3@@131))
)))
(assert (forall ((|l#0@@55| T@U) (|l#1@@28| T@U) (|l#2@@28| T@U) (|l#3@@27| Bool) ($o@@106 T@U) ($f@@28 T@U) ) (! (let ((alpha@@35 (FieldTypeInv0 (type $f@@28))))
 (=> (and (and (and (and (= (type |l#0@@55|) refType) (= (type |l#1@@28|) (MapType0Type refType MapType1Type))) (= (type |l#2@@28|) (FieldType boolType))) (= (type $o@@106) refType)) (= (type $f@@28) (FieldType alpha@@35))) (= (U_2_bool (MapType6Select (|lambda#53| |l#0@@55| |l#1@@28| |l#2@@28| |l#3@@27|) $o@@106 $f@@28))  (=> (and (not (= $o@@106 |l#0@@55|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@28| $o@@106) |l#2@@28|))) |l#3@@27|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7846|
 :pattern ( (MapType6Select (|lambda#53| |l#0@@55| |l#1@@28| |l#2@@28| |l#3@@27|) $o@@106 $f@@28))
)))
(assert (forall ((arg0@@780 T@U) (arg1@@418 T@U) (arg2@@218 T@U) (arg3@@132 Bool) ) (! (= (type (|lambda#54| arg0@@780 arg1@@418 arg2@@218 arg3@@132)) (MapType6Type refType boolType))
 :qid |funType:lambda#54|
 :pattern ( (|lambda#54| arg0@@780 arg1@@418 arg2@@218 arg3@@132))
)))
(assert (forall ((|l#0@@56| T@U) (|l#1@@29| T@U) (|l#2@@29| T@U) (|l#3@@28| Bool) ($o@@107 T@U) ($f@@29 T@U) ) (! (let ((alpha@@36 (FieldTypeInv0 (type $f@@29))))
 (=> (and (and (and (and (= (type |l#0@@56|) refType) (= (type |l#1@@29|) (MapType0Type refType MapType1Type))) (= (type |l#2@@29|) (FieldType boolType))) (= (type $o@@107) refType)) (= (type $f@@29) (FieldType alpha@@36))) (= (U_2_bool (MapType6Select (|lambda#54| |l#0@@56| |l#1@@29| |l#2@@29| |l#3@@28|) $o@@107 $f@@29))  (=> (and (not (= $o@@107 |l#0@@56|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@29| $o@@107) |l#2@@29|))) |l#3@@28|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7847|
 :pattern ( (MapType6Select (|lambda#54| |l#0@@56| |l#1@@29| |l#2@@29| |l#3@@28|) $o@@107 $f@@29))
)))
(assert (forall ((arg0@@781 T@U) (arg1@@419 T@U) (arg2@@219 T@U) (arg3@@133 Bool) ) (! (= (type (|lambda#55| arg0@@781 arg1@@419 arg2@@219 arg3@@133)) (MapType6Type refType boolType))
 :qid |funType:lambda#55|
 :pattern ( (|lambda#55| arg0@@781 arg1@@419 arg2@@219 arg3@@133))
)))
(assert (forall ((|l#0@@57| T@U) (|l#1@@30| T@U) (|l#2@@30| T@U) (|l#3@@29| Bool) ($o@@108 T@U) ($f@@30 T@U) ) (! (let ((alpha@@37 (FieldTypeInv0 (type $f@@30))))
 (=> (and (and (and (and (= (type |l#0@@57|) refType) (= (type |l#1@@30|) (MapType0Type refType MapType1Type))) (= (type |l#2@@30|) (FieldType boolType))) (= (type $o@@108) refType)) (= (type $f@@30) (FieldType alpha@@37))) (= (U_2_bool (MapType6Select (|lambda#55| |l#0@@57| |l#1@@30| |l#2@@30| |l#3@@29|) $o@@108 $f@@30))  (=> (and (not (= $o@@108 |l#0@@57|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@30| $o@@108) |l#2@@30|))) |l#3@@29|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7848|
 :pattern ( (MapType6Select (|lambda#55| |l#0@@57| |l#1@@30| |l#2@@30| |l#3@@29|) $o@@108 $f@@30))
)))
(assert (forall ((|l#0@@58| T@U) (|l#1@@31| T@U) (|l#2@@31| T@U) (|$y#0| T@U) ) (!  (=> (and (and (and (= (type |l#0@@58|) TyType) (= (type |l#1@@31|) (MapType0Type BoxType boolType))) (= (type |l#2@@31|) DatatypeTypeType)) (= (type |$y#0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#56| |l#0@@58| |l#1@@31| |l#2@@31|) |$y#0|))  (and ($IsBox |$y#0| |l#0@@58|) (and (U_2_bool (MapType0Select |l#1@@31| |$y#0|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| ($Unbox (SeqType BoxType) |$y#0|)) |l#2@@31|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7849|
 :pattern ( (MapType0Select (|lambda#56| |l#0@@58| |l#1@@31| |l#2@@31|) |$y#0|))
)))
(assert (forall ((arg0@@782 T@U) (arg1@@420 T@U) (arg2@@220 T@U) (arg3@@134 Bool) ) (! (= (type (|lambda#58| arg0@@782 arg1@@420 arg2@@220 arg3@@134)) (MapType6Type refType boolType))
 :qid |funType:lambda#58|
 :pattern ( (|lambda#58| arg0@@782 arg1@@420 arg2@@220 arg3@@134))
)))
(assert (forall ((|l#0@@59| T@U) (|l#1@@32| T@U) (|l#2@@32| T@U) (|l#3@@30| Bool) ($o@@109 T@U) ($f@@31 T@U) ) (! (let ((alpha@@38 (FieldTypeInv0 (type $f@@31))))
 (=> (and (and (and (and (= (type |l#0@@59|) refType) (= (type |l#1@@32|) (MapType0Type refType MapType1Type))) (= (type |l#2@@32|) (FieldType boolType))) (= (type $o@@109) refType)) (= (type $f@@31) (FieldType alpha@@38))) (= (U_2_bool (MapType6Select (|lambda#58| |l#0@@59| |l#1@@32| |l#2@@32| |l#3@@30|) $o@@109 $f@@31))  (=> (and (not (= $o@@109 |l#0@@59|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@32| $o@@109) |l#2@@32|))) |l#3@@30|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7850|
 :pattern ( (MapType6Select (|lambda#58| |l#0@@59| |l#1@@32| |l#2@@32| |l#3@@30|) $o@@109 $f@@31))
)))
(assert (forall ((arg0@@783 T@U) (arg1@@421 T@U) (arg2@@221 T@U) (arg3@@135 Bool) ) (! (= (type (|lambda#59| arg0@@783 arg1@@421 arg2@@221 arg3@@135)) (MapType6Type refType boolType))
 :qid |funType:lambda#59|
 :pattern ( (|lambda#59| arg0@@783 arg1@@421 arg2@@221 arg3@@135))
)))
(assert (forall ((|l#0@@60| T@U) (|l#1@@33| T@U) (|l#2@@33| T@U) (|l#3@@31| Bool) ($o@@110 T@U) ($f@@32 T@U) ) (! (let ((alpha@@39 (FieldTypeInv0 (type $f@@32))))
 (=> (and (and (and (and (= (type |l#0@@60|) refType) (= (type |l#1@@33|) (MapType0Type refType MapType1Type))) (= (type |l#2@@33|) (FieldType boolType))) (= (type $o@@110) refType)) (= (type $f@@32) (FieldType alpha@@39))) (= (U_2_bool (MapType6Select (|lambda#59| |l#0@@60| |l#1@@33| |l#2@@33| |l#3@@31|) $o@@110 $f@@32))  (=> (and (not (= $o@@110 |l#0@@60|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@33| $o@@110) |l#2@@33|))) |l#3@@31|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7851|
 :pattern ( (MapType6Select (|lambda#59| |l#0@@60| |l#1@@33| |l#2@@33| |l#3@@31|) $o@@110 $f@@32))
)))
(assert (forall ((arg0@@784 T@U) (arg1@@422 T@U) (arg2@@222 T@U) (arg3@@136 Bool) ) (! (= (type (|lambda#61| arg0@@784 arg1@@422 arg2@@222 arg3@@136)) (MapType6Type refType boolType))
 :qid |funType:lambda#61|
 :pattern ( (|lambda#61| arg0@@784 arg1@@422 arg2@@222 arg3@@136))
)))
(assert (forall ((|l#0@@61| T@U) (|l#1@@34| T@U) (|l#2@@34| T@U) (|l#3@@32| Bool) ($o@@111 T@U) ($f@@33 T@U) ) (! (let ((alpha@@40 (FieldTypeInv0 (type $f@@33))))
 (=> (and (and (and (and (= (type |l#0@@61|) refType) (= (type |l#1@@34|) (MapType0Type refType MapType1Type))) (= (type |l#2@@34|) (FieldType boolType))) (= (type $o@@111) refType)) (= (type $f@@33) (FieldType alpha@@40))) (= (U_2_bool (MapType6Select (|lambda#61| |l#0@@61| |l#1@@34| |l#2@@34| |l#3@@32|) $o@@111 $f@@33))  (=> (and (not (= $o@@111 |l#0@@61|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@34| $o@@111) |l#2@@34|))) |l#3@@32|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7852|
 :pattern ( (MapType6Select (|lambda#61| |l#0@@61| |l#1@@34| |l#2@@34| |l#3@@32|) $o@@111 $f@@33))
)))
(assert (forall ((arg0@@785 T@U) (arg1@@423 T@U) (arg2@@223 T@U) (arg3@@137 Bool) ) (! (= (type (|lambda#62| arg0@@785 arg1@@423 arg2@@223 arg3@@137)) (MapType6Type refType boolType))
 :qid |funType:lambda#62|
 :pattern ( (|lambda#62| arg0@@785 arg1@@423 arg2@@223 arg3@@137))
)))
(assert (forall ((|l#0@@62| T@U) (|l#1@@35| T@U) (|l#2@@35| T@U) (|l#3@@33| Bool) ($o@@112 T@U) ($f@@34 T@U) ) (! (let ((alpha@@41 (FieldTypeInv0 (type $f@@34))))
 (=> (and (and (and (and (= (type |l#0@@62|) refType) (= (type |l#1@@35|) (MapType0Type refType MapType1Type))) (= (type |l#2@@35|) (FieldType boolType))) (= (type $o@@112) refType)) (= (type $f@@34) (FieldType alpha@@41))) (= (U_2_bool (MapType6Select (|lambda#62| |l#0@@62| |l#1@@35| |l#2@@35| |l#3@@33|) $o@@112 $f@@34))  (=> (and (not (= $o@@112 |l#0@@62|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@35| $o@@112) |l#2@@35|))) |l#3@@33|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7853|
 :pattern ( (MapType6Select (|lambda#62| |l#0@@62| |l#1@@35| |l#2@@35| |l#3@@33|) $o@@112 $f@@34))
)))
(assert (forall ((arg0@@786 T@U) (arg1@@424 T@U) (arg2@@224 T@U) (arg3@@138 Bool) ) (! (= (type (|lambda#63| arg0@@786 arg1@@424 arg2@@224 arg3@@138)) (MapType6Type refType boolType))
 :qid |funType:lambda#63|
 :pattern ( (|lambda#63| arg0@@786 arg1@@424 arg2@@224 arg3@@138))
)))
(assert (forall ((|l#0@@63| T@U) (|l#1@@36| T@U) (|l#2@@36| T@U) (|l#3@@34| Bool) ($o@@113 T@U) ($f@@35 T@U) ) (! (let ((alpha@@42 (FieldTypeInv0 (type $f@@35))))
 (=> (and (and (and (and (= (type |l#0@@63|) refType) (= (type |l#1@@36|) (MapType0Type refType MapType1Type))) (= (type |l#2@@36|) (FieldType boolType))) (= (type $o@@113) refType)) (= (type $f@@35) (FieldType alpha@@42))) (= (U_2_bool (MapType6Select (|lambda#63| |l#0@@63| |l#1@@36| |l#2@@36| |l#3@@34|) $o@@113 $f@@35))  (=> (and (not (= $o@@113 |l#0@@63|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@36| $o@@113) |l#2@@36|))) |l#3@@34|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7854|
 :pattern ( (MapType6Select (|lambda#63| |l#0@@63| |l#1@@36| |l#2@@36| |l#3@@34|) $o@@113 $f@@35))
)))
(assert (forall ((arg0@@787 T@U) (arg1@@425 T@U) (arg2@@225 T@U) (arg3@@139 Bool) ) (! (= (type (|lambda#64| arg0@@787 arg1@@425 arg2@@225 arg3@@139)) (MapType6Type refType boolType))
 :qid |funType:lambda#64|
 :pattern ( (|lambda#64| arg0@@787 arg1@@425 arg2@@225 arg3@@139))
)))
(assert (forall ((|l#0@@64| T@U) (|l#1@@37| T@U) (|l#2@@37| T@U) (|l#3@@35| Bool) ($o@@114 T@U) ($f@@36 T@U) ) (! (let ((alpha@@43 (FieldTypeInv0 (type $f@@36))))
 (=> (and (and (and (and (= (type |l#0@@64|) refType) (= (type |l#1@@37|) (MapType0Type refType MapType1Type))) (= (type |l#2@@37|) (FieldType boolType))) (= (type $o@@114) refType)) (= (type $f@@36) (FieldType alpha@@43))) (= (U_2_bool (MapType6Select (|lambda#64| |l#0@@64| |l#1@@37| |l#2@@37| |l#3@@35|) $o@@114 $f@@36))  (=> (and (not (= $o@@114 |l#0@@64|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@37| $o@@114) |l#2@@37|))) |l#3@@35|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7855|
 :pattern ( (MapType6Select (|lambda#64| |l#0@@64| |l#1@@37| |l#2@@37| |l#3@@35|) $o@@114 $f@@36))
)))
(assert (forall ((arg0@@788 T@U) (arg1@@426 T@U) (arg2@@226 T@U) (arg3@@140 Bool) ) (! (= (type (|lambda#65| arg0@@788 arg1@@426 arg2@@226 arg3@@140)) (MapType6Type refType boolType))
 :qid |funType:lambda#65|
 :pattern ( (|lambda#65| arg0@@788 arg1@@426 arg2@@226 arg3@@140))
)))
(assert (forall ((|l#0@@65| T@U) (|l#1@@38| T@U) (|l#2@@38| T@U) (|l#3@@36| Bool) ($o@@115 T@U) ($f@@37 T@U) ) (! (let ((alpha@@44 (FieldTypeInv0 (type $f@@37))))
 (=> (and (and (and (and (= (type |l#0@@65|) refType) (= (type |l#1@@38|) (MapType0Type refType MapType1Type))) (= (type |l#2@@38|) (FieldType boolType))) (= (type $o@@115) refType)) (= (type $f@@37) (FieldType alpha@@44))) (= (U_2_bool (MapType6Select (|lambda#65| |l#0@@65| |l#1@@38| |l#2@@38| |l#3@@36|) $o@@115 $f@@37))  (=> (and (not (= $o@@115 |l#0@@65|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@38| $o@@115) |l#2@@38|))) |l#3@@36|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7856|
 :pattern ( (MapType6Select (|lambda#65| |l#0@@65| |l#1@@38| |l#2@@38| |l#3@@36|) $o@@115 $f@@37))
)))
(assert (forall ((arg0@@789 T@U) (arg1@@427 T@U) (arg2@@227 T@U) (arg3@@141 Bool) ) (! (= (type (|lambda#66| arg0@@789 arg1@@427 arg2@@227 arg3@@141)) (MapType6Type refType boolType))
 :qid |funType:lambda#66|
 :pattern ( (|lambda#66| arg0@@789 arg1@@427 arg2@@227 arg3@@141))
)))
(assert (forall ((|l#0@@66| T@U) (|l#1@@39| T@U) (|l#2@@39| T@U) (|l#3@@37| Bool) ($o@@116 T@U) ($f@@38 T@U) ) (! (let ((alpha@@45 (FieldTypeInv0 (type $f@@38))))
 (=> (and (and (and (and (= (type |l#0@@66|) refType) (= (type |l#1@@39|) (MapType0Type refType MapType1Type))) (= (type |l#2@@39|) (FieldType boolType))) (= (type $o@@116) refType)) (= (type $f@@38) (FieldType alpha@@45))) (= (U_2_bool (MapType6Select (|lambda#66| |l#0@@66| |l#1@@39| |l#2@@39| |l#3@@37|) $o@@116 $f@@38))  (=> (and (not (= $o@@116 |l#0@@66|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@39| $o@@116) |l#2@@39|))) |l#3@@37|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7857|
 :pattern ( (MapType6Select (|lambda#66| |l#0@@66| |l#1@@39| |l#2@@39| |l#3@@37|) $o@@116 $f@@38))
)))
(assert (forall ((arg0@@790 T@U) (arg1@@428 T@U) (arg2@@228 T@U) (arg3@@142 Bool) ) (! (= (type (|lambda#67| arg0@@790 arg1@@428 arg2@@228 arg3@@142)) (MapType6Type refType boolType))
 :qid |funType:lambda#67|
 :pattern ( (|lambda#67| arg0@@790 arg1@@428 arg2@@228 arg3@@142))
)))
(assert (forall ((|l#0@@67| T@U) (|l#1@@40| T@U) (|l#2@@40| T@U) (|l#3@@38| Bool) ($o@@117 T@U) ($f@@39 T@U) ) (! (let ((alpha@@46 (FieldTypeInv0 (type $f@@39))))
 (=> (and (and (and (and (= (type |l#0@@67|) refType) (= (type |l#1@@40|) (MapType0Type refType MapType1Type))) (= (type |l#2@@40|) (FieldType boolType))) (= (type $o@@117) refType)) (= (type $f@@39) (FieldType alpha@@46))) (= (U_2_bool (MapType6Select (|lambda#67| |l#0@@67| |l#1@@40| |l#2@@40| |l#3@@38|) $o@@117 $f@@39))  (=> (and (not (= $o@@117 |l#0@@67|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@40| $o@@117) |l#2@@40|))) |l#3@@38|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7858|
 :pattern ( (MapType6Select (|lambda#67| |l#0@@67| |l#1@@40| |l#2@@40| |l#3@@38|) $o@@117 $f@@39))
)))
(assert (forall ((arg0@@791 T@U) (arg1@@429 T@U) (arg2@@229 T@U) (arg3@@143 Bool) ) (! (= (type (|lambda#68| arg0@@791 arg1@@429 arg2@@229 arg3@@143)) (MapType6Type refType boolType))
 :qid |funType:lambda#68|
 :pattern ( (|lambda#68| arg0@@791 arg1@@429 arg2@@229 arg3@@143))
)))
(assert (forall ((|l#0@@68| T@U) (|l#1@@41| T@U) (|l#2@@41| T@U) (|l#3@@39| Bool) ($o@@118 T@U) ($f@@40 T@U) ) (! (let ((alpha@@47 (FieldTypeInv0 (type $f@@40))))
 (=> (and (and (and (and (= (type |l#0@@68|) refType) (= (type |l#1@@41|) (MapType0Type refType MapType1Type))) (= (type |l#2@@41|) (FieldType boolType))) (= (type $o@@118) refType)) (= (type $f@@40) (FieldType alpha@@47))) (= (U_2_bool (MapType6Select (|lambda#68| |l#0@@68| |l#1@@41| |l#2@@41| |l#3@@39|) $o@@118 $f@@40))  (=> (and (not (= $o@@118 |l#0@@68|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@41| $o@@118) |l#2@@41|))) |l#3@@39|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7859|
 :pattern ( (MapType6Select (|lambda#68| |l#0@@68| |l#1@@41| |l#2@@41| |l#3@@39|) $o@@118 $f@@40))
)))
(assert (forall ((arg0@@792 T@U) (arg1@@430 T@U) (arg2@@230 T@U) (arg3@@144 Bool) ) (! (= (type (|lambda#69| arg0@@792 arg1@@430 arg2@@230 arg3@@144)) (MapType6Type refType boolType))
 :qid |funType:lambda#69|
 :pattern ( (|lambda#69| arg0@@792 arg1@@430 arg2@@230 arg3@@144))
)))
(assert (forall ((|l#0@@69| T@U) (|l#1@@42| T@U) (|l#2@@42| T@U) (|l#3@@40| Bool) ($o@@119 T@U) ($f@@41 T@U) ) (! (let ((alpha@@48 (FieldTypeInv0 (type $f@@41))))
 (=> (and (and (and (and (= (type |l#0@@69|) refType) (= (type |l#1@@42|) (MapType0Type refType MapType1Type))) (= (type |l#2@@42|) (FieldType boolType))) (= (type $o@@119) refType)) (= (type $f@@41) (FieldType alpha@@48))) (= (U_2_bool (MapType6Select (|lambda#69| |l#0@@69| |l#1@@42| |l#2@@42| |l#3@@40|) $o@@119 $f@@41))  (=> (and (not (= $o@@119 |l#0@@69|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@42| $o@@119) |l#2@@42|))) |l#3@@40|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7860|
 :pattern ( (MapType6Select (|lambda#69| |l#0@@69| |l#1@@42| |l#2@@42| |l#3@@40|) $o@@119 $f@@41))
)))
(assert (forall ((arg0@@793 T@U) (arg1@@431 T@U) (arg2@@231 T@U) (arg3@@145 Bool) ) (! (= (type (|lambda#70| arg0@@793 arg1@@431 arg2@@231 arg3@@145)) (MapType6Type refType boolType))
 :qid |funType:lambda#70|
 :pattern ( (|lambda#70| arg0@@793 arg1@@431 arg2@@231 arg3@@145))
)))
(assert (forall ((|l#0@@70| T@U) (|l#1@@43| T@U) (|l#2@@43| T@U) (|l#3@@41| Bool) ($o@@120 T@U) ($f@@42 T@U) ) (! (let ((alpha@@49 (FieldTypeInv0 (type $f@@42))))
 (=> (and (and (and (and (= (type |l#0@@70|) refType) (= (type |l#1@@43|) (MapType0Type refType MapType1Type))) (= (type |l#2@@43|) (FieldType boolType))) (= (type $o@@120) refType)) (= (type $f@@42) (FieldType alpha@@49))) (= (U_2_bool (MapType6Select (|lambda#70| |l#0@@70| |l#1@@43| |l#2@@43| |l#3@@41|) $o@@120 $f@@42))  (=> (and (not (= $o@@120 |l#0@@70|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@43| $o@@120) |l#2@@43|))) |l#3@@41|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7861|
 :pattern ( (MapType6Select (|lambda#70| |l#0@@70| |l#1@@43| |l#2@@43| |l#3@@41|) $o@@120 $f@@42))
)))
(assert (forall ((arg0@@794 T@U) (arg1@@432 T@U) (arg2@@232 T@U) (arg3@@146 Bool) ) (! (= (type (|lambda#71| arg0@@794 arg1@@432 arg2@@232 arg3@@146)) (MapType6Type refType boolType))
 :qid |funType:lambda#71|
 :pattern ( (|lambda#71| arg0@@794 arg1@@432 arg2@@232 arg3@@146))
)))
(assert (forall ((|l#0@@71| T@U) (|l#1@@44| T@U) (|l#2@@44| T@U) (|l#3@@42| Bool) ($o@@121 T@U) ($f@@43 T@U) ) (! (let ((alpha@@50 (FieldTypeInv0 (type $f@@43))))
 (=> (and (and (and (and (= (type |l#0@@71|) refType) (= (type |l#1@@44|) (MapType0Type refType MapType1Type))) (= (type |l#2@@44|) (FieldType boolType))) (= (type $o@@121) refType)) (= (type $f@@43) (FieldType alpha@@50))) (= (U_2_bool (MapType6Select (|lambda#71| |l#0@@71| |l#1@@44| |l#2@@44| |l#3@@42|) $o@@121 $f@@43))  (=> (and (not (= $o@@121 |l#0@@71|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@44| $o@@121) |l#2@@44|))) |l#3@@42|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7862|
 :pattern ( (MapType6Select (|lambda#71| |l#0@@71| |l#1@@44| |l#2@@44| |l#3@@42|) $o@@121 $f@@43))
)))
(assert (forall ((arg0@@795 T@U) (arg1@@433 T@U) (arg2@@233 T@U) (arg3@@147 Bool) ) (! (= (type (|lambda#72| arg0@@795 arg1@@433 arg2@@233 arg3@@147)) (MapType6Type refType boolType))
 :qid |funType:lambda#72|
 :pattern ( (|lambda#72| arg0@@795 arg1@@433 arg2@@233 arg3@@147))
)))
(assert (forall ((|l#0@@72| T@U) (|l#1@@45| T@U) (|l#2@@45| T@U) (|l#3@@43| Bool) ($o@@122 T@U) ($f@@44 T@U) ) (! (let ((alpha@@51 (FieldTypeInv0 (type $f@@44))))
 (=> (and (and (and (and (= (type |l#0@@72|) refType) (= (type |l#1@@45|) (MapType0Type refType MapType1Type))) (= (type |l#2@@45|) (FieldType boolType))) (= (type $o@@122) refType)) (= (type $f@@44) (FieldType alpha@@51))) (= (U_2_bool (MapType6Select (|lambda#72| |l#0@@72| |l#1@@45| |l#2@@45| |l#3@@43|) $o@@122 $f@@44))  (=> (and (not (= $o@@122 |l#0@@72|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@45| $o@@122) |l#2@@45|))) |l#3@@43|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7863|
 :pattern ( (MapType6Select (|lambda#72| |l#0@@72| |l#1@@45| |l#2@@45| |l#3@@43|) $o@@122 $f@@44))
)))
(assert (forall ((arg0@@796 T@U) (arg1@@434 T@U) (arg2@@234 T@U) (arg3@@148 Bool) ) (! (= (type (|lambda#73| arg0@@796 arg1@@434 arg2@@234 arg3@@148)) (MapType6Type refType boolType))
 :qid |funType:lambda#73|
 :pattern ( (|lambda#73| arg0@@796 arg1@@434 arg2@@234 arg3@@148))
)))
(assert (forall ((|l#0@@73| T@U) (|l#1@@46| T@U) (|l#2@@46| T@U) (|l#3@@44| Bool) ($o@@123 T@U) ($f@@45 T@U) ) (! (let ((alpha@@52 (FieldTypeInv0 (type $f@@45))))
 (=> (and (and (and (and (= (type |l#0@@73|) refType) (= (type |l#1@@46|) (MapType0Type refType MapType1Type))) (= (type |l#2@@46|) (FieldType boolType))) (= (type $o@@123) refType)) (= (type $f@@45) (FieldType alpha@@52))) (= (U_2_bool (MapType6Select (|lambda#73| |l#0@@73| |l#1@@46| |l#2@@46| |l#3@@44|) $o@@123 $f@@45))  (=> (and (not (= $o@@123 |l#0@@73|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@46| $o@@123) |l#2@@46|))) |l#3@@44|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7864|
 :pattern ( (MapType6Select (|lambda#73| |l#0@@73| |l#1@@46| |l#2@@46| |l#3@@44|) $o@@123 $f@@45))
)))
(assert (forall ((arg0@@797 T@U) (arg1@@435 T@U) (arg2@@235 T@U) (arg3@@149 Bool) ) (! (= (type (|lambda#74| arg0@@797 arg1@@435 arg2@@235 arg3@@149)) (MapType6Type refType boolType))
 :qid |funType:lambda#74|
 :pattern ( (|lambda#74| arg0@@797 arg1@@435 arg2@@235 arg3@@149))
)))
(assert (forall ((|l#0@@74| T@U) (|l#1@@47| T@U) (|l#2@@47| T@U) (|l#3@@45| Bool) ($o@@124 T@U) ($f@@46 T@U) ) (! (let ((alpha@@53 (FieldTypeInv0 (type $f@@46))))
 (=> (and (and (and (and (= (type |l#0@@74|) refType) (= (type |l#1@@47|) (MapType0Type refType MapType1Type))) (= (type |l#2@@47|) (FieldType boolType))) (= (type $o@@124) refType)) (= (type $f@@46) (FieldType alpha@@53))) (= (U_2_bool (MapType6Select (|lambda#74| |l#0@@74| |l#1@@47| |l#2@@47| |l#3@@45|) $o@@124 $f@@46))  (=> (and (not (= $o@@124 |l#0@@74|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@47| $o@@124) |l#2@@47|))) |l#3@@45|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7865|
 :pattern ( (MapType6Select (|lambda#74| |l#0@@74| |l#1@@47| |l#2@@47| |l#3@@45|) $o@@124 $f@@46))
)))
(assert (forall ((arg0@@798 T@U) (arg1@@436 T@U) (arg2@@236 T@U) (arg3@@150 Bool) ) (! (= (type (|lambda#75| arg0@@798 arg1@@436 arg2@@236 arg3@@150)) (MapType6Type refType boolType))
 :qid |funType:lambda#75|
 :pattern ( (|lambda#75| arg0@@798 arg1@@436 arg2@@236 arg3@@150))
)))
(assert (forall ((|l#0@@75| T@U) (|l#1@@48| T@U) (|l#2@@48| T@U) (|l#3@@46| Bool) ($o@@125 T@U) ($f@@47 T@U) ) (! (let ((alpha@@54 (FieldTypeInv0 (type $f@@47))))
 (=> (and (and (and (and (= (type |l#0@@75|) refType) (= (type |l#1@@48|) (MapType0Type refType MapType1Type))) (= (type |l#2@@48|) (FieldType boolType))) (= (type $o@@125) refType)) (= (type $f@@47) (FieldType alpha@@54))) (= (U_2_bool (MapType6Select (|lambda#75| |l#0@@75| |l#1@@48| |l#2@@48| |l#3@@46|) $o@@125 $f@@47))  (=> (and (not (= $o@@125 |l#0@@75|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@48| $o@@125) |l#2@@48|))) |l#3@@46|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7866|
 :pattern ( (MapType6Select (|lambda#75| |l#0@@75| |l#1@@48| |l#2@@48| |l#3@@46|) $o@@125 $f@@47))
)))
(assert (forall ((arg0@@799 T@U) (arg1@@437 T@U) (arg2@@237 T@U) (arg3@@151 Bool) ) (! (= (type (|lambda#76| arg0@@799 arg1@@437 arg2@@237 arg3@@151)) (MapType6Type refType boolType))
 :qid |funType:lambda#76|
 :pattern ( (|lambda#76| arg0@@799 arg1@@437 arg2@@237 arg3@@151))
)))
(assert (forall ((|l#0@@76| T@U) (|l#1@@49| T@U) (|l#2@@49| T@U) (|l#3@@47| Bool) ($o@@126 T@U) ($f@@48 T@U) ) (! (let ((alpha@@55 (FieldTypeInv0 (type $f@@48))))
 (=> (and (and (and (and (= (type |l#0@@76|) refType) (= (type |l#1@@49|) (MapType0Type refType MapType1Type))) (= (type |l#2@@49|) (FieldType boolType))) (= (type $o@@126) refType)) (= (type $f@@48) (FieldType alpha@@55))) (= (U_2_bool (MapType6Select (|lambda#76| |l#0@@76| |l#1@@49| |l#2@@49| |l#3@@47|) $o@@126 $f@@48))  (=> (and (not (= $o@@126 |l#0@@76|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@49| $o@@126) |l#2@@49|))) |l#3@@47|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7867|
 :pattern ( (MapType6Select (|lambda#76| |l#0@@76| |l#1@@49| |l#2@@49| |l#3@@47|) $o@@126 $f@@48))
)))
(assert (forall ((arg0@@800 T@U) (arg1@@438 T@U) (arg2@@238 T@U) (arg3@@152 Bool) ) (! (= (type (|lambda#77| arg0@@800 arg1@@438 arg2@@238 arg3@@152)) (MapType6Type refType boolType))
 :qid |funType:lambda#77|
 :pattern ( (|lambda#77| arg0@@800 arg1@@438 arg2@@238 arg3@@152))
)))
(assert (forall ((|l#0@@77| T@U) (|l#1@@50| T@U) (|l#2@@50| T@U) (|l#3@@48| Bool) ($o@@127 T@U) ($f@@49 T@U) ) (! (let ((alpha@@56 (FieldTypeInv0 (type $f@@49))))
 (=> (and (and (and (and (= (type |l#0@@77|) refType) (= (type |l#1@@50|) (MapType0Type refType MapType1Type))) (= (type |l#2@@50|) (FieldType boolType))) (= (type $o@@127) refType)) (= (type $f@@49) (FieldType alpha@@56))) (= (U_2_bool (MapType6Select (|lambda#77| |l#0@@77| |l#1@@50| |l#2@@50| |l#3@@48|) $o@@127 $f@@49))  (=> (and (not (= $o@@127 |l#0@@77|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@50| $o@@127) |l#2@@50|))) |l#3@@48|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7868|
 :pattern ( (MapType6Select (|lambda#77| |l#0@@77| |l#1@@50| |l#2@@50| |l#3@@48|) $o@@127 $f@@49))
)))
(assert (forall ((arg0@@801 T@U) (arg1@@439 T@U) (arg2@@239 T@U) (arg3@@153 Bool) ) (! (= (type (|lambda#78| arg0@@801 arg1@@439 arg2@@239 arg3@@153)) (MapType6Type refType boolType))
 :qid |funType:lambda#78|
 :pattern ( (|lambda#78| arg0@@801 arg1@@439 arg2@@239 arg3@@153))
)))
(assert (forall ((|l#0@@78| T@U) (|l#1@@51| T@U) (|l#2@@51| T@U) (|l#3@@49| Bool) ($o@@128 T@U) ($f@@50 T@U) ) (! (let ((alpha@@57 (FieldTypeInv0 (type $f@@50))))
 (=> (and (and (and (and (= (type |l#0@@78|) refType) (= (type |l#1@@51|) (MapType0Type refType MapType1Type))) (= (type |l#2@@51|) (FieldType boolType))) (= (type $o@@128) refType)) (= (type $f@@50) (FieldType alpha@@57))) (= (U_2_bool (MapType6Select (|lambda#78| |l#0@@78| |l#1@@51| |l#2@@51| |l#3@@49|) $o@@128 $f@@50))  (=> (and (not (= $o@@128 |l#0@@78|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@51| $o@@128) |l#2@@51|))) |l#3@@49|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7869|
 :pattern ( (MapType6Select (|lambda#78| |l#0@@78| |l#1@@51| |l#2@@51| |l#3@@49|) $o@@128 $f@@50))
)))
(assert (forall ((arg0@@802 T@U) (arg1@@440 T@U) (arg2@@240 T@U) (arg3@@154 Bool) ) (! (= (type (|lambda#79| arg0@@802 arg1@@440 arg2@@240 arg3@@154)) (MapType6Type refType boolType))
 :qid |funType:lambda#79|
 :pattern ( (|lambda#79| arg0@@802 arg1@@440 arg2@@240 arg3@@154))
)))
(assert (forall ((|l#0@@79| T@U) (|l#1@@52| T@U) (|l#2@@52| T@U) (|l#3@@50| Bool) ($o@@129 T@U) ($f@@51 T@U) ) (! (let ((alpha@@58 (FieldTypeInv0 (type $f@@51))))
 (=> (and (and (and (and (= (type |l#0@@79|) refType) (= (type |l#1@@52|) (MapType0Type refType MapType1Type))) (= (type |l#2@@52|) (FieldType boolType))) (= (type $o@@129) refType)) (= (type $f@@51) (FieldType alpha@@58))) (= (U_2_bool (MapType6Select (|lambda#79| |l#0@@79| |l#1@@52| |l#2@@52| |l#3@@50|) $o@@129 $f@@51))  (=> (and (not (= $o@@129 |l#0@@79|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@52| $o@@129) |l#2@@52|))) |l#3@@50|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7870|
 :pattern ( (MapType6Select (|lambda#79| |l#0@@79| |l#1@@52| |l#2@@52| |l#3@@50|) $o@@129 $f@@51))
)))
(assert (forall ((arg0@@803 T@U) (arg1@@441 T@U) (arg2@@241 T@U) (arg3@@155 Bool) ) (! (= (type (|lambda#80| arg0@@803 arg1@@441 arg2@@241 arg3@@155)) (MapType6Type refType boolType))
 :qid |funType:lambda#80|
 :pattern ( (|lambda#80| arg0@@803 arg1@@441 arg2@@241 arg3@@155))
)))
(assert (forall ((|l#0@@80| T@U) (|l#1@@53| T@U) (|l#2@@53| T@U) (|l#3@@51| Bool) ($o@@130 T@U) ($f@@52 T@U) ) (! (let ((alpha@@59 (FieldTypeInv0 (type $f@@52))))
 (=> (and (and (and (and (= (type |l#0@@80|) refType) (= (type |l#1@@53|) (MapType0Type refType MapType1Type))) (= (type |l#2@@53|) (FieldType boolType))) (= (type $o@@130) refType)) (= (type $f@@52) (FieldType alpha@@59))) (= (U_2_bool (MapType6Select (|lambda#80| |l#0@@80| |l#1@@53| |l#2@@53| |l#3@@51|) $o@@130 $f@@52))  (=> (and (not (= $o@@130 |l#0@@80|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@53| $o@@130) |l#2@@53|))) |l#3@@51|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7871|
 :pattern ( (MapType6Select (|lambda#80| |l#0@@80| |l#1@@53| |l#2@@53| |l#3@@51|) $o@@130 $f@@52))
)))
(assert (forall ((arg0@@804 T@U) (arg1@@442 T@U) (arg2@@242 T@U) (arg3@@156 Bool) ) (! (= (type (|lambda#81| arg0@@804 arg1@@442 arg2@@242 arg3@@156)) (MapType6Type refType boolType))
 :qid |funType:lambda#81|
 :pattern ( (|lambda#81| arg0@@804 arg1@@442 arg2@@242 arg3@@156))
)))
(assert (forall ((|l#0@@81| T@U) (|l#1@@54| T@U) (|l#2@@54| T@U) (|l#3@@52| Bool) ($o@@131 T@U) ($f@@53 T@U) ) (! (let ((alpha@@60 (FieldTypeInv0 (type $f@@53))))
 (=> (and (and (and (and (= (type |l#0@@81|) refType) (= (type |l#1@@54|) (MapType0Type refType MapType1Type))) (= (type |l#2@@54|) (FieldType boolType))) (= (type $o@@131) refType)) (= (type $f@@53) (FieldType alpha@@60))) (= (U_2_bool (MapType6Select (|lambda#81| |l#0@@81| |l#1@@54| |l#2@@54| |l#3@@52|) $o@@131 $f@@53))  (=> (and (not (= $o@@131 |l#0@@81|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@54| $o@@131) |l#2@@54|))) |l#3@@52|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7872|
 :pattern ( (MapType6Select (|lambda#81| |l#0@@81| |l#1@@54| |l#2@@54| |l#3@@52|) $o@@131 $f@@53))
)))
(assert (forall ((arg0@@805 T@U) (arg1@@443 T@U) (arg2@@243 T@U) (arg3@@157 Bool) ) (! (= (type (|lambda#82| arg0@@805 arg1@@443 arg2@@243 arg3@@157)) (MapType6Type refType boolType))
 :qid |funType:lambda#82|
 :pattern ( (|lambda#82| arg0@@805 arg1@@443 arg2@@243 arg3@@157))
)))
(assert (forall ((|l#0@@82| T@U) (|l#1@@55| T@U) (|l#2@@55| T@U) (|l#3@@53| Bool) ($o@@132 T@U) ($f@@54 T@U) ) (! (let ((alpha@@61 (FieldTypeInv0 (type $f@@54))))
 (=> (and (and (and (and (= (type |l#0@@82|) refType) (= (type |l#1@@55|) (MapType0Type refType MapType1Type))) (= (type |l#2@@55|) (FieldType boolType))) (= (type $o@@132) refType)) (= (type $f@@54) (FieldType alpha@@61))) (= (U_2_bool (MapType6Select (|lambda#82| |l#0@@82| |l#1@@55| |l#2@@55| |l#3@@53|) $o@@132 $f@@54))  (=> (and (not (= $o@@132 |l#0@@82|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@55| $o@@132) |l#2@@55|))) |l#3@@53|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7873|
 :pattern ( (MapType6Select (|lambda#82| |l#0@@82| |l#1@@55| |l#2@@55| |l#3@@53|) $o@@132 $f@@54))
)))
(assert (forall ((arg0@@806 T@U) (arg1@@444 T@U) (arg2@@244 T@U) (arg3@@158 Bool) ) (! (= (type (|lambda#83| arg0@@806 arg1@@444 arg2@@244 arg3@@158)) (MapType6Type refType boolType))
 :qid |funType:lambda#83|
 :pattern ( (|lambda#83| arg0@@806 arg1@@444 arg2@@244 arg3@@158))
)))
(assert (forall ((|l#0@@83| T@U) (|l#1@@56| T@U) (|l#2@@56| T@U) (|l#3@@54| Bool) ($o@@133 T@U) ($f@@55 T@U) ) (! (let ((alpha@@62 (FieldTypeInv0 (type $f@@55))))
 (=> (and (and (and (and (= (type |l#0@@83|) refType) (= (type |l#1@@56|) (MapType0Type refType MapType1Type))) (= (type |l#2@@56|) (FieldType boolType))) (= (type $o@@133) refType)) (= (type $f@@55) (FieldType alpha@@62))) (= (U_2_bool (MapType6Select (|lambda#83| |l#0@@83| |l#1@@56| |l#2@@56| |l#3@@54|) $o@@133 $f@@55))  (=> (and (not (= $o@@133 |l#0@@83|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@56| $o@@133) |l#2@@56|))) |l#3@@54|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7874|
 :pattern ( (MapType6Select (|lambda#83| |l#0@@83| |l#1@@56| |l#2@@56| |l#3@@54|) $o@@133 $f@@55))
)))
(assert (forall ((arg0@@807 T@U) (arg1@@445 T@U) (arg2@@245 T@U) (arg3@@159 Bool) ) (! (= (type (|lambda#84| arg0@@807 arg1@@445 arg2@@245 arg3@@159)) (MapType6Type refType boolType))
 :qid |funType:lambda#84|
 :pattern ( (|lambda#84| arg0@@807 arg1@@445 arg2@@245 arg3@@159))
)))
(assert (forall ((|l#0@@84| T@U) (|l#1@@57| T@U) (|l#2@@57| T@U) (|l#3@@55| Bool) ($o@@134 T@U) ($f@@56 T@U) ) (! (let ((alpha@@63 (FieldTypeInv0 (type $f@@56))))
 (=> (and (and (and (and (= (type |l#0@@84|) refType) (= (type |l#1@@57|) (MapType0Type refType MapType1Type))) (= (type |l#2@@57|) (FieldType boolType))) (= (type $o@@134) refType)) (= (type $f@@56) (FieldType alpha@@63))) (= (U_2_bool (MapType6Select (|lambda#84| |l#0@@84| |l#1@@57| |l#2@@57| |l#3@@55|) $o@@134 $f@@56))  (=> (and (not (= $o@@134 |l#0@@84|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@57| $o@@134) |l#2@@57|))) |l#3@@55|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7875|
 :pattern ( (MapType6Select (|lambda#84| |l#0@@84| |l#1@@57| |l#2@@57| |l#3@@55|) $o@@134 $f@@56))
)))
(assert (forall ((arg0@@808 T@U) (arg1@@446 T@U) (arg2@@246 T@U) (arg3@@160 Bool) ) (! (= (type (|lambda#85| arg0@@808 arg1@@446 arg2@@246 arg3@@160)) (MapType6Type refType boolType))
 :qid |funType:lambda#85|
 :pattern ( (|lambda#85| arg0@@808 arg1@@446 arg2@@246 arg3@@160))
)))
(assert (forall ((|l#0@@85| T@U) (|l#1@@58| T@U) (|l#2@@58| T@U) (|l#3@@56| Bool) ($o@@135 T@U) ($f@@57 T@U) ) (! (let ((alpha@@64 (FieldTypeInv0 (type $f@@57))))
 (=> (and (and (and (and (= (type |l#0@@85|) refType) (= (type |l#1@@58|) (MapType0Type refType MapType1Type))) (= (type |l#2@@58|) (FieldType boolType))) (= (type $o@@135) refType)) (= (type $f@@57) (FieldType alpha@@64))) (= (U_2_bool (MapType6Select (|lambda#85| |l#0@@85| |l#1@@58| |l#2@@58| |l#3@@56|) $o@@135 $f@@57))  (=> (and (not (= $o@@135 |l#0@@85|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@58| $o@@135) |l#2@@58|))) |l#3@@56|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7876|
 :pattern ( (MapType6Select (|lambda#85| |l#0@@85| |l#1@@58| |l#2@@58| |l#3@@56|) $o@@135 $f@@57))
)))
(assert (forall ((arg0@@809 T@U) (arg1@@447 T@U) (arg2@@247 T@U) (arg3@@161 Bool) ) (! (= (type (|lambda#86| arg0@@809 arg1@@447 arg2@@247 arg3@@161)) (MapType6Type refType boolType))
 :qid |funType:lambda#86|
 :pattern ( (|lambda#86| arg0@@809 arg1@@447 arg2@@247 arg3@@161))
)))
(assert (forall ((|l#0@@86| T@U) (|l#1@@59| T@U) (|l#2@@59| T@U) (|l#3@@57| Bool) ($o@@136 T@U) ($f@@58 T@U) ) (! (let ((alpha@@65 (FieldTypeInv0 (type $f@@58))))
 (=> (and (and (and (and (= (type |l#0@@86|) refType) (= (type |l#1@@59|) (MapType0Type refType MapType1Type))) (= (type |l#2@@59|) (FieldType boolType))) (= (type $o@@136) refType)) (= (type $f@@58) (FieldType alpha@@65))) (= (U_2_bool (MapType6Select (|lambda#86| |l#0@@86| |l#1@@59| |l#2@@59| |l#3@@57|) $o@@136 $f@@58))  (=> (and (not (= $o@@136 |l#0@@86|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@59| $o@@136) |l#2@@59|))) |l#3@@57|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7877|
 :pattern ( (MapType6Select (|lambda#86| |l#0@@86| |l#1@@59| |l#2@@59| |l#3@@57|) $o@@136 $f@@58))
)))
(assert (forall ((arg0@@810 T@U) (arg1@@448 T@U) (arg2@@248 T@U) (arg3@@162 Bool) ) (! (= (type (|lambda#87| arg0@@810 arg1@@448 arg2@@248 arg3@@162)) (MapType6Type refType boolType))
 :qid |funType:lambda#87|
 :pattern ( (|lambda#87| arg0@@810 arg1@@448 arg2@@248 arg3@@162))
)))
(assert (forall ((|l#0@@87| T@U) (|l#1@@60| T@U) (|l#2@@60| T@U) (|l#3@@58| Bool) ($o@@137 T@U) ($f@@59 T@U) ) (! (let ((alpha@@66 (FieldTypeInv0 (type $f@@59))))
 (=> (and (and (and (and (= (type |l#0@@87|) refType) (= (type |l#1@@60|) (MapType0Type refType MapType1Type))) (= (type |l#2@@60|) (FieldType boolType))) (= (type $o@@137) refType)) (= (type $f@@59) (FieldType alpha@@66))) (= (U_2_bool (MapType6Select (|lambda#87| |l#0@@87| |l#1@@60| |l#2@@60| |l#3@@58|) $o@@137 $f@@59))  (=> (and (not (= $o@@137 |l#0@@87|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@60| $o@@137) |l#2@@60|))) |l#3@@58|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7878|
 :pattern ( (MapType6Select (|lambda#87| |l#0@@87| |l#1@@60| |l#2@@60| |l#3@@58|) $o@@137 $f@@59))
)))
(assert (forall ((arg0@@811 T@U) (arg1@@449 T@U) (arg2@@249 T@U) (arg3@@163 Bool) ) (! (= (type (|lambda#88| arg0@@811 arg1@@449 arg2@@249 arg3@@163)) (MapType6Type refType boolType))
 :qid |funType:lambda#88|
 :pattern ( (|lambda#88| arg0@@811 arg1@@449 arg2@@249 arg3@@163))
)))
(assert (forall ((|l#0@@88| T@U) (|l#1@@61| T@U) (|l#2@@61| T@U) (|l#3@@59| Bool) ($o@@138 T@U) ($f@@60 T@U) ) (! (let ((alpha@@67 (FieldTypeInv0 (type $f@@60))))
 (=> (and (and (and (and (= (type |l#0@@88|) refType) (= (type |l#1@@61|) (MapType0Type refType MapType1Type))) (= (type |l#2@@61|) (FieldType boolType))) (= (type $o@@138) refType)) (= (type $f@@60) (FieldType alpha@@67))) (= (U_2_bool (MapType6Select (|lambda#88| |l#0@@88| |l#1@@61| |l#2@@61| |l#3@@59|) $o@@138 $f@@60))  (=> (and (not (= $o@@138 |l#0@@88|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@61| $o@@138) |l#2@@61|))) |l#3@@59|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7879|
 :pattern ( (MapType6Select (|lambda#88| |l#0@@88| |l#1@@61| |l#2@@61| |l#3@@59|) $o@@138 $f@@60))
)))
(assert (forall ((arg0@@812 T@U) (arg1@@450 T@U) (arg2@@250 T@U) (arg3@@164 Bool) ) (! (= (type (|lambda#89| arg0@@812 arg1@@450 arg2@@250 arg3@@164)) (MapType6Type refType boolType))
 :qid |funType:lambda#89|
 :pattern ( (|lambda#89| arg0@@812 arg1@@450 arg2@@250 arg3@@164))
)))
(assert (forall ((|l#0@@89| T@U) (|l#1@@62| T@U) (|l#2@@62| T@U) (|l#3@@60| Bool) ($o@@139 T@U) ($f@@61 T@U) ) (! (let ((alpha@@68 (FieldTypeInv0 (type $f@@61))))
 (=> (and (and (and (and (= (type |l#0@@89|) refType) (= (type |l#1@@62|) (MapType0Type refType MapType1Type))) (= (type |l#2@@62|) (FieldType boolType))) (= (type $o@@139) refType)) (= (type $f@@61) (FieldType alpha@@68))) (= (U_2_bool (MapType6Select (|lambda#89| |l#0@@89| |l#1@@62| |l#2@@62| |l#3@@60|) $o@@139 $f@@61))  (=> (and (not (= $o@@139 |l#0@@89|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@62| $o@@139) |l#2@@62|))) |l#3@@60|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7880|
 :pattern ( (MapType6Select (|lambda#89| |l#0@@89| |l#1@@62| |l#2@@62| |l#3@@60|) $o@@139 $f@@61))
)))
(assert (forall ((arg0@@813 T@U) (arg1@@451 T@U) (arg2@@251 T@U) (arg3@@165 Bool) ) (! (= (type (|lambda#90| arg0@@813 arg1@@451 arg2@@251 arg3@@165)) (MapType6Type refType boolType))
 :qid |funType:lambda#90|
 :pattern ( (|lambda#90| arg0@@813 arg1@@451 arg2@@251 arg3@@165))
)))
(assert (forall ((|l#0@@90| T@U) (|l#1@@63| T@U) (|l#2@@63| T@U) (|l#3@@61| Bool) ($o@@140 T@U) ($f@@62 T@U) ) (! (let ((alpha@@69 (FieldTypeInv0 (type $f@@62))))
 (=> (and (and (and (and (= (type |l#0@@90|) refType) (= (type |l#1@@63|) (MapType0Type refType MapType1Type))) (= (type |l#2@@63|) (FieldType boolType))) (= (type $o@@140) refType)) (= (type $f@@62) (FieldType alpha@@69))) (= (U_2_bool (MapType6Select (|lambda#90| |l#0@@90| |l#1@@63| |l#2@@63| |l#3@@61|) $o@@140 $f@@62))  (=> (and (not (= $o@@140 |l#0@@90|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@63| $o@@140) |l#2@@63|))) |l#3@@61|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7881|
 :pattern ( (MapType6Select (|lambda#90| |l#0@@90| |l#1@@63| |l#2@@63| |l#3@@61|) $o@@140 $f@@62))
)))
(assert (forall ((arg0@@814 T@U) (arg1@@452 T@U) (arg2@@252 T@U) (arg3@@166 Bool) ) (! (= (type (|lambda#91| arg0@@814 arg1@@452 arg2@@252 arg3@@166)) (MapType6Type refType boolType))
 :qid |funType:lambda#91|
 :pattern ( (|lambda#91| arg0@@814 arg1@@452 arg2@@252 arg3@@166))
)))
(assert (forall ((|l#0@@91| T@U) (|l#1@@64| T@U) (|l#2@@64| T@U) (|l#3@@62| Bool) ($o@@141 T@U) ($f@@63 T@U) ) (! (let ((alpha@@70 (FieldTypeInv0 (type $f@@63))))
 (=> (and (and (and (and (= (type |l#0@@91|) refType) (= (type |l#1@@64|) (MapType0Type refType MapType1Type))) (= (type |l#2@@64|) (FieldType boolType))) (= (type $o@@141) refType)) (= (type $f@@63) (FieldType alpha@@70))) (= (U_2_bool (MapType6Select (|lambda#91| |l#0@@91| |l#1@@64| |l#2@@64| |l#3@@62|) $o@@141 $f@@63))  (=> (and (not (= $o@@141 |l#0@@91|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@64| $o@@141) |l#2@@64|))) |l#3@@62|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7882|
 :pattern ( (MapType6Select (|lambda#91| |l#0@@91| |l#1@@64| |l#2@@64| |l#3@@62|) $o@@141 $f@@63))
)))
(assert (forall ((arg0@@815 T@U) (arg1@@453 T@U) (arg2@@253 T@U) (arg3@@167 Bool) ) (! (= (type (|lambda#92| arg0@@815 arg1@@453 arg2@@253 arg3@@167)) (MapType6Type refType boolType))
 :qid |funType:lambda#92|
 :pattern ( (|lambda#92| arg0@@815 arg1@@453 arg2@@253 arg3@@167))
)))
(assert (forall ((|l#0@@92| T@U) (|l#1@@65| T@U) (|l#2@@65| T@U) (|l#3@@63| Bool) ($o@@142 T@U) ($f@@64 T@U) ) (! (let ((alpha@@71 (FieldTypeInv0 (type $f@@64))))
 (=> (and (and (and (and (= (type |l#0@@92|) refType) (= (type |l#1@@65|) (MapType0Type refType MapType1Type))) (= (type |l#2@@65|) (FieldType boolType))) (= (type $o@@142) refType)) (= (type $f@@64) (FieldType alpha@@71))) (= (U_2_bool (MapType6Select (|lambda#92| |l#0@@92| |l#1@@65| |l#2@@65| |l#3@@63|) $o@@142 $f@@64))  (=> (and (not (= $o@@142 |l#0@@92|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@65| $o@@142) |l#2@@65|))) |l#3@@63|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7883|
 :pattern ( (MapType6Select (|lambda#92| |l#0@@92| |l#1@@65| |l#2@@65| |l#3@@63|) $o@@142 $f@@64))
)))
(assert (forall ((arg0@@816 T@U) (arg1@@454 T@U) (arg2@@254 T@U) ) (! (= (type (|lambda#93| arg0@@816 arg1@@454 arg2@@254)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#93|
 :pattern ( (|lambda#93| arg0@@816 arg1@@454 arg2@@254))
)))
(assert (forall ((|l#0@@93| T@U) (|l#1@@66| T@U) (|l#2@@66| T@U) (|$l#1#heap#0| T@U) (|$l#1#n#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@93|) LayerTypeType) (= (type |l#1@@66|) LayerTypeType)) (= (type |l#2@@66|) DatatypeTypeType)) (= (type |$l#1#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#1#n#0|) BoxType)) (= (MapType2Select (|lambda#93| |l#0@@93| |l#1@@66| |l#2@@66|) |$l#1#heap#0| |$l#1#n#0|) ($Box (ite  (and (PivotBetree.BetreeNode.WF |l#0@@93| ($Unbox DatatypeTypeType |$l#1#n#0|)) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType |$l#1#n#0|))) (PivotBetreeRefinement.__default.INode |l#1@@66| ($Unbox DatatypeTypeType |$l#1#n#0|)) |l#2@@66|))))
 :qid |unknown.0:0|
 :skolemid |7884|
 :pattern ( (MapType2Select (|lambda#93| |l#0@@93| |l#1@@66| |l#2@@66|) |$l#1#heap#0| |$l#1#n#0|))
)))
(assert (forall ((arg0@@817 T@U) ) (! (= (type (|lambda#94| arg0@@817)) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))
 :qid |funType:lambda#94|
 :pattern ( (|lambda#94| arg0@@817))
)))
(assert (forall ((|l#0@@94| T@U) (|$l#1#heap#0@@0| T@U) (|$l#1#n#0@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@94|) TyType) (= (type |$l#1#heap#0@@0|) (MapType0Type refType MapType1Type))) (= (type |$l#1#n#0@@0|) BoxType)) (= (U_2_bool (MapType2Select (|lambda#94| |l#0@@94|) |$l#1#heap#0@@0| |$l#1#n#0@@0|)) ($IsBox |$l#1#n#0@@0| |l#0@@94|)))
 :qid |PivotBetreeidfy.43:12|
 :skolemid |7885|
 :pattern ( (MapType2Select (|lambda#94| |l#0@@94|) |$l#1#heap#0@@0| |$l#1#n#0@@0|))
)))
(assert (forall ((arg0@@818 T@U) (arg1@@455 T@U) (arg2@@255 T@U) ) (! (= (type (|lambda#97| arg0@@818 arg1@@455 arg2@@255)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#97|
 :pattern ( (|lambda#97| arg0@@818 arg1@@455 arg2@@255))
)))
(assert (forall ((|l#0@@95| T@U) (|l#1@@67| T@U) (|l#2@@67| T@U) (|$l#1#ly#0| T@U) ) (!  (=> (and (and (and (= (type |l#0@@95|) DatatypeTypeType) (= (type |l#1@@67|) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type |l#2@@67|) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type |$l#1#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#97| |l#0@@95| |l#1@@67| |l#2@@67|) |$l#1#ly#0|) (Handle1 (|lambda#93| |$l#1#ly#0| |$l#1#ly#0| |l#0@@95|) |l#1@@67| |l#2@@67|)))
 :qid |PivotBetreeRefinementbroken1idfy.465:9|
 :skolemid |7886|
 :pattern ( (MapType0Select (|lambda#97| |l#0@@95| |l#1@@67| |l#2@@67|) |$l#1#ly#0|))
)))
(assert (forall ((arg0@@819 T@U) (arg1@@456 T@U) (arg2@@256 T@U) ) (! (= (type (|lambda#98| arg0@@819 arg1@@456 arg2@@256)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#98|
 :pattern ( (|lambda#98| arg0@@819 arg1@@456 arg2@@256))
)))
(assert (forall ((|l#0@@96| T@U) (|l#1@@68| T@U) (|l#2@@68| T@U) (|$l#3#heap#0| T@U) (|$l#3#n#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@96|) LayerTypeType) (= (type |l#1@@68|) DatatypeTypeType)) (= (type |l#2@@68|) DatatypeTypeType)) (= (type |$l#3#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#3#n#0|) BoxType)) (= (MapType2Select (|lambda#98| |l#0@@96| |l#1@@68| |l#2@@68|) |$l#3#heap#0| |$l#3#n#0|) ($Box (ite (PivotBetree.BetreeNode.WF |l#0@@96| ($Unbox DatatypeTypeType |$l#3#n#0|)) (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType |$l#3#n#0|) |l#1@@68|) |l#2@@68|))))
 :qid |unknown.0:0|
 :skolemid |7887|
 :pattern ( (MapType2Select (|lambda#98| |l#0@@96| |l#1@@68| |l#2@@68|) |$l#3#heap#0| |$l#3#n#0|))
)))
(assert (forall ((arg0@@820 T@U) (arg1@@457 T@U) (arg2@@257 T@U) (arg3@@168 T@U) ) (! (= (type (|lambda#102| arg0@@820 arg1@@457 arg2@@257 arg3@@168)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#102|
 :pattern ( (|lambda#102| arg0@@820 arg1@@457 arg2@@257 arg3@@168))
)))
(assert (forall ((|l#0@@97| T@U) (|l#1@@69| T@U) (|l#2@@69| T@U) (|l#3@@64| T@U) (|$l#3#ly#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@97|) DatatypeTypeType) (= (type |l#1@@69|) DatatypeTypeType)) (= (type |l#2@@69|) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type |l#3@@64|) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type |$l#3#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#102| |l#0@@97| |l#1@@69| |l#2@@69| |l#3@@64|) |$l#3#ly#0|) (Handle1 (|lambda#98| |$l#3#ly#0| |l#0@@97| |l#1@@69|) |l#2@@69| |l#3@@64|)))
 :qid |PivotBetreeRefinementbroken1idfy.456:59|
 :skolemid |7888|
 :pattern ( (MapType0Select (|lambda#102| |l#0@@97| |l#1@@69| |l#2@@69| |l#3@@64|) |$l#3#ly#0|))
)))
(assert (forall ((arg0@@821 T@U) (arg1@@458 T@U) (arg2@@258 T@U) ) (! (= (type (|lambda#103| arg0@@821 arg1@@458 arg2@@258)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#103|
 :pattern ( (|lambda#103| arg0@@821 arg1@@458 arg2@@258))
)))
(assert (forall ((|l#0@@98| T@U) (|l#1@@70| T@U) (|l#2@@70| T@U) (|$l#5#heap#0| T@U) (|$l#5#n#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@98|) LayerTypeType) (= (type |l#1@@70|) DatatypeTypeType)) (= (type |l#2@@70|) DatatypeTypeType)) (= (type |$l#5#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#5#n#0|) BoxType)) (= (MapType2Select (|lambda#103| |l#0@@98| |l#1@@70| |l#2@@70|) |$l#5#heap#0| |$l#5#n#0|) ($Box (ite  (and (PivotBetree.BetreeNode.WF |l#0@@98| ($Unbox DatatypeTypeType |$l#5#n#0|)) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType |$l#5#n#0|))) (PivotBetree.BetreeNode.PushBufferStack ($Unbox DatatypeTypeType |$l#5#n#0|) |l#1@@70|) |l#2@@70|))))
 :qid |unknown.0:0|
 :skolemid |7889|
 :pattern ( (MapType2Select (|lambda#103| |l#0@@98| |l#1@@70| |l#2@@70|) |$l#5#heap#0| |$l#5#n#0|))
)))
(assert (forall ((arg0@@822 T@U) (arg1@@459 T@U) (arg2@@259 T@U) (arg3@@169 T@U) ) (! (= (type (|lambda#107| arg0@@822 arg1@@459 arg2@@259 arg3@@169)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#107|
 :pattern ( (|lambda#107| arg0@@822 arg1@@459 arg2@@259 arg3@@169))
)))
(assert (forall ((|l#0@@99| T@U) (|l#1@@71| T@U) (|l#2@@71| T@U) (|l#3@@65| T@U) (|$l#5#ly#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@99|) DatatypeTypeType) (= (type |l#1@@71|) DatatypeTypeType)) (= (type |l#2@@71|) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type |l#3@@65|) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type |$l#5#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#107| |l#0@@99| |l#1@@71| |l#2@@71| |l#3@@65|) |$l#5#ly#0|) (Handle1 (|lambda#103| |$l#5#ly#0| |l#0@@99| |l#1@@71|) |l#2@@71| |l#3@@65|)))
 :qid |PivotBetreeRefinementbroken1idfy.456:82|
 :skolemid |7890|
 :pattern ( (MapType0Select (|lambda#107| |l#0@@99| |l#1@@71| |l#2@@71| |l#3@@65|) |$l#5#ly#0|))
)))
(assert (forall ((arg0@@823 T@U) (arg1@@460 T@U) ) (! (= (type (|lambda#108| arg0@@823 arg1@@460)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#108|
 :pattern ( (|lambda#108| arg0@@823 arg1@@460))
)))
(assert (forall ((|l#0@@100| T@U) (|l#1@@72| T@U) (|$l#7#heap#0| T@U) (|$l#7#pn#0| T@U) ) (!  (=> (and (and (and (= (type |l#0@@100|) LayerTypeType) (= (type |l#1@@72|) DatatypeTypeType)) (= (type |$l#7#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#7#pn#0|) BoxType)) (= (MapType2Select (|lambda#108| |l#0@@100| |l#1@@72|) |$l#7#heap#0| |$l#7#pn#0|) ($Box (ite (PagedBetree.BetreeNode.WF |l#0@@100| ($Unbox DatatypeTypeType |$l#7#pn#0|)) (PagedBetree.BetreeNode.Promote ($Unbox DatatypeTypeType |$l#7#pn#0|)) |l#1@@72|))))
 :qid |unknown.0:0|
 :skolemid |7891|
 :pattern ( (MapType2Select (|lambda#108| |l#0@@100| |l#1@@72|) |$l#7#heap#0| |$l#7#pn#0|))
)))
(assert (forall ((arg0@@824 T@U) (arg1@@461 T@U) (arg2@@260 T@U) ) (! (= (type (|lambda#112| arg0@@824 arg1@@461 arg2@@260)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#112|
 :pattern ( (|lambda#112| arg0@@824 arg1@@461 arg2@@260))
)))
(assert (forall ((|l#0@@101| T@U) (|l#1@@73| T@U) (|l#2@@72| T@U) (|$l#7#ly#0| T@U) ) (!  (=> (and (and (and (= (type |l#0@@101|) DatatypeTypeType) (= (type |l#1@@73|) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type |l#2@@72|) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type |$l#7#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#112| |l#0@@101| |l#1@@73| |l#2@@72|) |$l#7#ly#0|) (Handle1 (|lambda#108| |$l#7#ly#0| |l#0@@101|) |l#1@@73| |l#2@@72|)))
 :qid |PivotBetreeRefinementbroken1idfy.465:9|
 :skolemid |7892|
 :pattern ( (MapType0Select (|lambda#112| |l#0@@101| |l#1@@73| |l#2@@72|) |$l#7#ly#0|))
)))
(assert (forall ((arg0@@825 T@U) (arg1@@462 T@U) (arg2@@261 T@U) ) (! (= (type (|lambda#113| arg0@@825 arg1@@462 arg2@@261)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#113|
 :pattern ( (|lambda#113| arg0@@825 arg1@@462 arg2@@261))
)))
(assert (forall ((|l#0@@102| T@U) (|l#1@@74| T@U) (|l#2@@73| T@U) (|$l#9#heap#0| T@U) (|$l#9#pn#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@102|) LayerTypeType) (= (type |l#1@@74|) DatatypeTypeType)) (= (type |l#2@@73|) DatatypeTypeType)) (= (type |$l#9#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#9#pn#0|) BoxType)) (= (MapType2Select (|lambda#113| |l#0@@102| |l#1@@74| |l#2@@73|) |$l#9#heap#0| |$l#9#pn#0|) ($Box (ite  (and (PagedBetree.BetreeNode.WF |l#0@@102| ($Unbox DatatypeTypeType |$l#9#pn#0|)) (PagedBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType |$l#9#pn#0|))) (PagedBetree.BetreeNode.PushBufferStack ($Unbox DatatypeTypeType |$l#9#pn#0|) |l#1@@74|) |l#2@@73|))))
 :qid |unknown.0:0|
 :skolemid |7893|
 :pattern ( (MapType2Select (|lambda#113| |l#0@@102| |l#1@@74| |l#2@@73|) |$l#9#heap#0| |$l#9#pn#0|))
)))
(assert (forall ((arg0@@826 T@U) (arg1@@463 T@U) (arg2@@262 T@U) (arg3@@170 T@U) ) (! (= (type (|lambda#117| arg0@@826 arg1@@463 arg2@@262 arg3@@170)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#117|
 :pattern ( (|lambda#117| arg0@@826 arg1@@463 arg2@@262 arg3@@170))
)))
(assert (forall ((|l#0@@103| T@U) (|l#1@@75| T@U) (|l#2@@74| T@U) (|l#3@@66| T@U) (|$l#9#ly#0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@103|) DatatypeTypeType) (= (type |l#1@@75|) DatatypeTypeType)) (= (type |l#2@@74|) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type |l#3@@66|) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type |$l#9#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#117| |l#0@@103| |l#1@@75| |l#2@@74| |l#3@@66|) |$l#9#ly#0|) (Handle1 (|lambda#113| |$l#9#ly#0| |l#0@@103| |l#1@@75|) |l#2@@74| |l#3@@66|)))
 :qid |PivotBetreeRefinementbroken1idfy.456:82|
 :skolemid |7894|
 :pattern ( (MapType0Select (|lambda#117| |l#0@@103| |l#1@@75| |l#2@@74| |l#3@@66|) |$l#9#ly#0|))
)))
(assert (forall ((arg0@@827 T@U) (arg1@@464 T@U) (arg2@@263 T@U) (arg3@@171 Bool) ) (! (= (type (|lambda#118| arg0@@827 arg1@@464 arg2@@263 arg3@@171)) (MapType6Type refType boolType))
 :qid |funType:lambda#118|
 :pattern ( (|lambda#118| arg0@@827 arg1@@464 arg2@@263 arg3@@171))
)))
(assert (forall ((|l#0@@104| T@U) (|l#1@@76| T@U) (|l#2@@75| T@U) (|l#3@@67| Bool) ($o@@143 T@U) ($f@@65 T@U) ) (! (let ((alpha@@72 (FieldTypeInv0 (type $f@@65))))
 (=> (and (and (and (and (= (type |l#0@@104|) refType) (= (type |l#1@@76|) (MapType0Type refType MapType1Type))) (= (type |l#2@@75|) (FieldType boolType))) (= (type $o@@143) refType)) (= (type $f@@65) (FieldType alpha@@72))) (= (U_2_bool (MapType6Select (|lambda#118| |l#0@@104| |l#1@@76| |l#2@@75| |l#3@@67|) $o@@143 $f@@65))  (=> (and (not (= $o@@143 |l#0@@104|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@76| $o@@143) |l#2@@75|))) |l#3@@67|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7895|
 :pattern ( (MapType6Select (|lambda#118| |l#0@@104| |l#1@@76| |l#2@@75| |l#3@@67|) $o@@143 $f@@65))
)))
(assert (forall ((arg0@@828 T@U) (arg1@@465 T@U) (arg2@@264 T@U) (arg3@@172 Bool) ) (! (= (type (|lambda#119| arg0@@828 arg1@@465 arg2@@264 arg3@@172)) (MapType6Type refType boolType))
 :qid |funType:lambda#119|
 :pattern ( (|lambda#119| arg0@@828 arg1@@465 arg2@@264 arg3@@172))
)))
(assert (forall ((|l#0@@105| T@U) (|l#1@@77| T@U) (|l#2@@76| T@U) (|l#3@@68| Bool) ($o@@144 T@U) ($f@@66 T@U) ) (! (let ((alpha@@73 (FieldTypeInv0 (type $f@@66))))
 (=> (and (and (and (and (= (type |l#0@@105|) refType) (= (type |l#1@@77|) (MapType0Type refType MapType1Type))) (= (type |l#2@@76|) (FieldType boolType))) (= (type $o@@144) refType)) (= (type $f@@66) (FieldType alpha@@73))) (= (U_2_bool (MapType6Select (|lambda#119| |l#0@@105| |l#1@@77| |l#2@@76| |l#3@@68|) $o@@144 $f@@66))  (=> (and (not (= $o@@144 |l#0@@105|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@77| $o@@144) |l#2@@76|))) |l#3@@68|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7896|
 :pattern ( (MapType6Select (|lambda#119| |l#0@@105| |l#1@@77| |l#2@@76| |l#3@@68|) $o@@144 $f@@66))
)))
(assert (forall ((arg0@@829 T@U) (arg1@@466 T@U) (arg2@@265 T@U) (arg3@@173 Bool) ) (! (= (type (|lambda#120| arg0@@829 arg1@@466 arg2@@265 arg3@@173)) (MapType6Type refType boolType))
 :qid |funType:lambda#120|
 :pattern ( (|lambda#120| arg0@@829 arg1@@466 arg2@@265 arg3@@173))
)))
(assert (forall ((|l#0@@106| T@U) (|l#1@@78| T@U) (|l#2@@77| T@U) (|l#3@@69| Bool) ($o@@145 T@U) ($f@@67 T@U) ) (! (let ((alpha@@74 (FieldTypeInv0 (type $f@@67))))
 (=> (and (and (and (and (= (type |l#0@@106|) refType) (= (type |l#1@@78|) (MapType0Type refType MapType1Type))) (= (type |l#2@@77|) (FieldType boolType))) (= (type $o@@145) refType)) (= (type $f@@67) (FieldType alpha@@74))) (= (U_2_bool (MapType6Select (|lambda#120| |l#0@@106| |l#1@@78| |l#2@@77| |l#3@@69|) $o@@145 $f@@67))  (=> (and (not (= $o@@145 |l#0@@106|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@78| $o@@145) |l#2@@77|))) |l#3@@69|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7897|
 :pattern ( (MapType6Select (|lambda#120| |l#0@@106| |l#1@@78| |l#2@@77| |l#3@@69|) $o@@145 $f@@67))
)))
(assert (forall ((arg0@@830 T@U) (arg1@@467 T@U) (arg2@@266 T@U) (arg3@@174 Bool) ) (! (= (type (|lambda#121| arg0@@830 arg1@@467 arg2@@266 arg3@@174)) (MapType6Type refType boolType))
 :qid |funType:lambda#121|
 :pattern ( (|lambda#121| arg0@@830 arg1@@467 arg2@@266 arg3@@174))
)))
(assert (forall ((|l#0@@107| T@U) (|l#1@@79| T@U) (|l#2@@78| T@U) (|l#3@@70| Bool) ($o@@146 T@U) ($f@@68 T@U) ) (! (let ((alpha@@75 (FieldTypeInv0 (type $f@@68))))
 (=> (and (and (and (and (= (type |l#0@@107|) refType) (= (type |l#1@@79|) (MapType0Type refType MapType1Type))) (= (type |l#2@@78|) (FieldType boolType))) (= (type $o@@146) refType)) (= (type $f@@68) (FieldType alpha@@75))) (= (U_2_bool (MapType6Select (|lambda#121| |l#0@@107| |l#1@@79| |l#2@@78| |l#3@@70|) $o@@146 $f@@68))  (=> (and (not (= $o@@146 |l#0@@107|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@79| $o@@146) |l#2@@78|))) |l#3@@70|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7898|
 :pattern ( (MapType6Select (|lambda#121| |l#0@@107| |l#1@@79| |l#2@@78| |l#3@@70|) $o@@146 $f@@68))
)))
(assert (forall ((arg0@@831 T@U) (arg1@@468 T@U) (arg2@@267 T@U) (arg3@@175 Bool) ) (! (= (type (|lambda#122| arg0@@831 arg1@@468 arg2@@267 arg3@@175)) (MapType6Type refType boolType))
 :qid |funType:lambda#122|
 :pattern ( (|lambda#122| arg0@@831 arg1@@468 arg2@@267 arg3@@175))
)))
(assert (forall ((|l#0@@108| T@U) (|l#1@@80| T@U) (|l#2@@79| T@U) (|l#3@@71| Bool) ($o@@147 T@U) ($f@@69 T@U) ) (! (let ((alpha@@76 (FieldTypeInv0 (type $f@@69))))
 (=> (and (and (and (and (= (type |l#0@@108|) refType) (= (type |l#1@@80|) (MapType0Type refType MapType1Type))) (= (type |l#2@@79|) (FieldType boolType))) (= (type $o@@147) refType)) (= (type $f@@69) (FieldType alpha@@76))) (= (U_2_bool (MapType6Select (|lambda#122| |l#0@@108| |l#1@@80| |l#2@@79| |l#3@@71|) $o@@147 $f@@69))  (=> (and (not (= $o@@147 |l#0@@108|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@80| $o@@147) |l#2@@79|))) |l#3@@71|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7899|
 :pattern ( (MapType6Select (|lambda#122| |l#0@@108| |l#1@@80| |l#2@@79| |l#3@@71|) $o@@147 $f@@69))
)))
(assert (forall ((arg0@@832 T@U) (arg1@@469 T@U) (arg2@@268 T@U) (arg3@@176 Bool) ) (! (= (type (|lambda#123| arg0@@832 arg1@@469 arg2@@268 arg3@@176)) (MapType6Type refType boolType))
 :qid |funType:lambda#123|
 :pattern ( (|lambda#123| arg0@@832 arg1@@469 arg2@@268 arg3@@176))
)))
(assert (forall ((|l#0@@109| T@U) (|l#1@@81| T@U) (|l#2@@80| T@U) (|l#3@@72| Bool) ($o@@148 T@U) ($f@@70 T@U) ) (! (let ((alpha@@77 (FieldTypeInv0 (type $f@@70))))
 (=> (and (and (and (and (= (type |l#0@@109|) refType) (= (type |l#1@@81|) (MapType0Type refType MapType1Type))) (= (type |l#2@@80|) (FieldType boolType))) (= (type $o@@148) refType)) (= (type $f@@70) (FieldType alpha@@77))) (= (U_2_bool (MapType6Select (|lambda#123| |l#0@@109| |l#1@@81| |l#2@@80| |l#3@@72|) $o@@148 $f@@70))  (=> (and (not (= $o@@148 |l#0@@109|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@81| $o@@148) |l#2@@80|))) |l#3@@72|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7900|
 :pattern ( (MapType6Select (|lambda#123| |l#0@@109| |l#1@@81| |l#2@@80| |l#3@@72|) $o@@148 $f@@70))
)))
(assert (forall ((arg0@@833 T@U) (arg1@@470 T@U) (arg2@@269 T@U) (arg3@@177 Bool) ) (! (= (type (|lambda#124| arg0@@833 arg1@@470 arg2@@269 arg3@@177)) (MapType6Type refType boolType))
 :qid |funType:lambda#124|
 :pattern ( (|lambda#124| arg0@@833 arg1@@470 arg2@@269 arg3@@177))
)))
(assert (forall ((|l#0@@110| T@U) (|l#1@@82| T@U) (|l#2@@81| T@U) (|l#3@@73| Bool) ($o@@149 T@U) ($f@@71 T@U) ) (! (let ((alpha@@78 (FieldTypeInv0 (type $f@@71))))
 (=> (and (and (and (and (= (type |l#0@@110|) refType) (= (type |l#1@@82|) (MapType0Type refType MapType1Type))) (= (type |l#2@@81|) (FieldType boolType))) (= (type $o@@149) refType)) (= (type $f@@71) (FieldType alpha@@78))) (= (U_2_bool (MapType6Select (|lambda#124| |l#0@@110| |l#1@@82| |l#2@@81| |l#3@@73|) $o@@149 $f@@71))  (=> (and (not (= $o@@149 |l#0@@110|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@82| $o@@149) |l#2@@81|))) |l#3@@73|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7901|
 :pattern ( (MapType6Select (|lambda#124| |l#0@@110| |l#1@@82| |l#2@@81| |l#3@@73|) $o@@149 $f@@71))
)))
(assert (forall ((arg0@@834 T@U) (arg1@@471 T@U) (arg2@@270 T@U) (arg3@@178 Bool) ) (! (= (type (|lambda#125| arg0@@834 arg1@@471 arg2@@270 arg3@@178)) (MapType6Type refType boolType))
 :qid |funType:lambda#125|
 :pattern ( (|lambda#125| arg0@@834 arg1@@471 arg2@@270 arg3@@178))
)))
(assert (forall ((|l#0@@111| T@U) (|l#1@@83| T@U) (|l#2@@82| T@U) (|l#3@@74| Bool) ($o@@150 T@U) ($f@@72 T@U) ) (! (let ((alpha@@79 (FieldTypeInv0 (type $f@@72))))
 (=> (and (and (and (and (= (type |l#0@@111|) refType) (= (type |l#1@@83|) (MapType0Type refType MapType1Type))) (= (type |l#2@@82|) (FieldType boolType))) (= (type $o@@150) refType)) (= (type $f@@72) (FieldType alpha@@79))) (= (U_2_bool (MapType6Select (|lambda#125| |l#0@@111| |l#1@@83| |l#2@@82| |l#3@@74|) $o@@150 $f@@72))  (=> (and (not (= $o@@150 |l#0@@111|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@83| $o@@150) |l#2@@82|))) |l#3@@74|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7902|
 :pattern ( (MapType6Select (|lambda#125| |l#0@@111| |l#1@@83| |l#2@@82| |l#3@@74|) $o@@150 $f@@72))
)))
(assert (forall ((arg0@@835 T@U) (arg1@@472 T@U) (arg2@@271 T@U) (arg3@@179 Bool) ) (! (= (type (|lambda#126| arg0@@835 arg1@@472 arg2@@271 arg3@@179)) (MapType6Type refType boolType))
 :qid |funType:lambda#126|
 :pattern ( (|lambda#126| arg0@@835 arg1@@472 arg2@@271 arg3@@179))
)))
(assert (forall ((|l#0@@112| T@U) (|l#1@@84| T@U) (|l#2@@83| T@U) (|l#3@@75| Bool) ($o@@151 T@U) ($f@@73 T@U) ) (! (let ((alpha@@80 (FieldTypeInv0 (type $f@@73))))
 (=> (and (and (and (and (= (type |l#0@@112|) refType) (= (type |l#1@@84|) (MapType0Type refType MapType1Type))) (= (type |l#2@@83|) (FieldType boolType))) (= (type $o@@151) refType)) (= (type $f@@73) (FieldType alpha@@80))) (= (U_2_bool (MapType6Select (|lambda#126| |l#0@@112| |l#1@@84| |l#2@@83| |l#3@@75|) $o@@151 $f@@73))  (=> (and (not (= $o@@151 |l#0@@112|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@84| $o@@151) |l#2@@83|))) |l#3@@75|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7903|
 :pattern ( (MapType6Select (|lambda#126| |l#0@@112| |l#1@@84| |l#2@@83| |l#3@@75|) $o@@151 $f@@73))
)))
(assert (forall ((arg0@@836 T@U) (arg1@@473 T@U) (arg2@@272 T@U) (arg3@@180 Bool) ) (! (= (type (|lambda#127| arg0@@836 arg1@@473 arg2@@272 arg3@@180)) (MapType6Type refType boolType))
 :qid |funType:lambda#127|
 :pattern ( (|lambda#127| arg0@@836 arg1@@473 arg2@@272 arg3@@180))
)))
(assert (forall ((|l#0@@113| T@U) (|l#1@@85| T@U) (|l#2@@84| T@U) (|l#3@@76| Bool) ($o@@152 T@U) ($f@@74 T@U) ) (! (let ((alpha@@81 (FieldTypeInv0 (type $f@@74))))
 (=> (and (and (and (and (= (type |l#0@@113|) refType) (= (type |l#1@@85|) (MapType0Type refType MapType1Type))) (= (type |l#2@@84|) (FieldType boolType))) (= (type $o@@152) refType)) (= (type $f@@74) (FieldType alpha@@81))) (= (U_2_bool (MapType6Select (|lambda#127| |l#0@@113| |l#1@@85| |l#2@@84| |l#3@@76|) $o@@152 $f@@74))  (=> (and (not (= $o@@152 |l#0@@113|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@85| $o@@152) |l#2@@84|))) |l#3@@76|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7904|
 :pattern ( (MapType6Select (|lambda#127| |l#0@@113| |l#1@@85| |l#2@@84| |l#3@@76|) $o@@152 $f@@74))
)))
(assert (forall ((arg0@@837 T@U) (arg1@@474 T@U) (arg2@@273 T@U) (arg3@@181 Bool) ) (! (= (type (|lambda#128| arg0@@837 arg1@@474 arg2@@273 arg3@@181)) (MapType6Type refType boolType))
 :qid |funType:lambda#128|
 :pattern ( (|lambda#128| arg0@@837 arg1@@474 arg2@@273 arg3@@181))
)))
(assert (forall ((|l#0@@114| T@U) (|l#1@@86| T@U) (|l#2@@85| T@U) (|l#3@@77| Bool) ($o@@153 T@U) ($f@@75 T@U) ) (! (let ((alpha@@82 (FieldTypeInv0 (type $f@@75))))
 (=> (and (and (and (and (= (type |l#0@@114|) refType) (= (type |l#1@@86|) (MapType0Type refType MapType1Type))) (= (type |l#2@@85|) (FieldType boolType))) (= (type $o@@153) refType)) (= (type $f@@75) (FieldType alpha@@82))) (= (U_2_bool (MapType6Select (|lambda#128| |l#0@@114| |l#1@@86| |l#2@@85| |l#3@@77|) $o@@153 $f@@75))  (=> (and (not (= $o@@153 |l#0@@114|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@86| $o@@153) |l#2@@85|))) |l#3@@77|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7905|
 :pattern ( (MapType6Select (|lambda#128| |l#0@@114| |l#1@@86| |l#2@@85| |l#3@@77|) $o@@153 $f@@75))
)))
(assert (forall ((arg0@@838 T@U) (arg1@@475 T@U) (arg2@@274 T@U) (arg3@@182 Bool) ) (! (= (type (|lambda#129| arg0@@838 arg1@@475 arg2@@274 arg3@@182)) (MapType6Type refType boolType))
 :qid |funType:lambda#129|
 :pattern ( (|lambda#129| arg0@@838 arg1@@475 arg2@@274 arg3@@182))
)))
(assert (forall ((|l#0@@115| T@U) (|l#1@@87| T@U) (|l#2@@86| T@U) (|l#3@@78| Bool) ($o@@154 T@U) ($f@@76 T@U) ) (! (let ((alpha@@83 (FieldTypeInv0 (type $f@@76))))
 (=> (and (and (and (and (= (type |l#0@@115|) refType) (= (type |l#1@@87|) (MapType0Type refType MapType1Type))) (= (type |l#2@@86|) (FieldType boolType))) (= (type $o@@154) refType)) (= (type $f@@76) (FieldType alpha@@83))) (= (U_2_bool (MapType6Select (|lambda#129| |l#0@@115| |l#1@@87| |l#2@@86| |l#3@@78|) $o@@154 $f@@76))  (=> (and (not (= $o@@154 |l#0@@115|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@87| $o@@154) |l#2@@86|))) |l#3@@78|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7906|
 :pattern ( (MapType6Select (|lambda#129| |l#0@@115| |l#1@@87| |l#2@@86| |l#3@@78|) $o@@154 $f@@76))
)))
(assert (forall ((arg0@@839 T@U) (arg1@@476 T@U) (arg2@@275 T@U) (arg3@@183 Bool) ) (! (= (type (|lambda#130| arg0@@839 arg1@@476 arg2@@275 arg3@@183)) (MapType6Type refType boolType))
 :qid |funType:lambda#130|
 :pattern ( (|lambda#130| arg0@@839 arg1@@476 arg2@@275 arg3@@183))
)))
(assert (forall ((|l#0@@116| T@U) (|l#1@@88| T@U) (|l#2@@87| T@U) (|l#3@@79| Bool) ($o@@155 T@U) ($f@@77 T@U) ) (! (let ((alpha@@84 (FieldTypeInv0 (type $f@@77))))
 (=> (and (and (and (and (= (type |l#0@@116|) refType) (= (type |l#1@@88|) (MapType0Type refType MapType1Type))) (= (type |l#2@@87|) (FieldType boolType))) (= (type $o@@155) refType)) (= (type $f@@77) (FieldType alpha@@84))) (= (U_2_bool (MapType6Select (|lambda#130| |l#0@@116| |l#1@@88| |l#2@@87| |l#3@@79|) $o@@155 $f@@77))  (=> (and (not (= $o@@155 |l#0@@116|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@88| $o@@155) |l#2@@87|))) |l#3@@79|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7907|
 :pattern ( (MapType6Select (|lambda#130| |l#0@@116| |l#1@@88| |l#2@@87| |l#3@@79|) $o@@155 $f@@77))
)))
(assert (forall ((arg0@@840 T@U) (arg1@@477 T@U) (arg2@@276 T@U) (arg3@@184 Bool) ) (! (= (type (|lambda#131| arg0@@840 arg1@@477 arg2@@276 arg3@@184)) (MapType6Type refType boolType))
 :qid |funType:lambda#131|
 :pattern ( (|lambda#131| arg0@@840 arg1@@477 arg2@@276 arg3@@184))
)))
(assert (forall ((|l#0@@117| T@U) (|l#1@@89| T@U) (|l#2@@88| T@U) (|l#3@@80| Bool) ($o@@156 T@U) ($f@@78 T@U) ) (! (let ((alpha@@85 (FieldTypeInv0 (type $f@@78))))
 (=> (and (and (and (and (= (type |l#0@@117|) refType) (= (type |l#1@@89|) (MapType0Type refType MapType1Type))) (= (type |l#2@@88|) (FieldType boolType))) (= (type $o@@156) refType)) (= (type $f@@78) (FieldType alpha@@85))) (= (U_2_bool (MapType6Select (|lambda#131| |l#0@@117| |l#1@@89| |l#2@@88| |l#3@@80|) $o@@156 $f@@78))  (=> (and (not (= $o@@156 |l#0@@117|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@89| $o@@156) |l#2@@88|))) |l#3@@80|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7908|
 :pattern ( (MapType6Select (|lambda#131| |l#0@@117| |l#1@@89| |l#2@@88| |l#3@@80|) $o@@156 $f@@78))
)))
(assert (forall ((arg0@@841 T@U) (arg1@@478 T@U) (arg2@@277 T@U) (arg3@@185 Bool) ) (! (= (type (|lambda#132| arg0@@841 arg1@@478 arg2@@277 arg3@@185)) (MapType6Type refType boolType))
 :qid |funType:lambda#132|
 :pattern ( (|lambda#132| arg0@@841 arg1@@478 arg2@@277 arg3@@185))
)))
(assert (forall ((|l#0@@118| T@U) (|l#1@@90| T@U) (|l#2@@89| T@U) (|l#3@@81| Bool) ($o@@157 T@U) ($f@@79 T@U) ) (! (let ((alpha@@86 (FieldTypeInv0 (type $f@@79))))
 (=> (and (and (and (and (= (type |l#0@@118|) refType) (= (type |l#1@@90|) (MapType0Type refType MapType1Type))) (= (type |l#2@@89|) (FieldType boolType))) (= (type $o@@157) refType)) (= (type $f@@79) (FieldType alpha@@86))) (= (U_2_bool (MapType6Select (|lambda#132| |l#0@@118| |l#1@@90| |l#2@@89| |l#3@@81|) $o@@157 $f@@79))  (=> (and (not (= $o@@157 |l#0@@118|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@90| $o@@157) |l#2@@89|))) |l#3@@81|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7909|
 :pattern ( (MapType6Select (|lambda#132| |l#0@@118| |l#1@@90| |l#2@@89| |l#3@@81|) $o@@157 $f@@79))
)))
(assert (forall ((arg0@@842 T@U) (arg1@@479 T@U) (arg2@@278 T@U) (arg3@@186 Bool) ) (! (= (type (|lambda#133| arg0@@842 arg1@@479 arg2@@278 arg3@@186)) (MapType6Type refType boolType))
 :qid |funType:lambda#133|
 :pattern ( (|lambda#133| arg0@@842 arg1@@479 arg2@@278 arg3@@186))
)))
(assert (forall ((|l#0@@119| T@U) (|l#1@@91| T@U) (|l#2@@90| T@U) (|l#3@@82| Bool) ($o@@158 T@U) ($f@@80 T@U) ) (! (let ((alpha@@87 (FieldTypeInv0 (type $f@@80))))
 (=> (and (and (and (and (= (type |l#0@@119|) refType) (= (type |l#1@@91|) (MapType0Type refType MapType1Type))) (= (type |l#2@@90|) (FieldType boolType))) (= (type $o@@158) refType)) (= (type $f@@80) (FieldType alpha@@87))) (= (U_2_bool (MapType6Select (|lambda#133| |l#0@@119| |l#1@@91| |l#2@@90| |l#3@@82|) $o@@158 $f@@80))  (=> (and (not (= $o@@158 |l#0@@119|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@91| $o@@158) |l#2@@90|))) |l#3@@82|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7910|
 :pattern ( (MapType6Select (|lambda#133| |l#0@@119| |l#1@@91| |l#2@@90| |l#3@@82|) $o@@158 $f@@80))
)))
(assert (forall ((arg0@@843 T@U) (arg1@@480 T@U) (arg2@@279 T@U) (arg3@@187 Bool) ) (! (= (type (|lambda#134| arg0@@843 arg1@@480 arg2@@279 arg3@@187)) (MapType6Type refType boolType))
 :qid |funType:lambda#134|
 :pattern ( (|lambda#134| arg0@@843 arg1@@480 arg2@@279 arg3@@187))
)))
(assert (forall ((|l#0@@120| T@U) (|l#1@@92| T@U) (|l#2@@91| T@U) (|l#3@@83| Bool) ($o@@159 T@U) ($f@@81 T@U) ) (! (let ((alpha@@88 (FieldTypeInv0 (type $f@@81))))
 (=> (and (and (and (and (= (type |l#0@@120|) refType) (= (type |l#1@@92|) (MapType0Type refType MapType1Type))) (= (type |l#2@@91|) (FieldType boolType))) (= (type $o@@159) refType)) (= (type $f@@81) (FieldType alpha@@88))) (= (U_2_bool (MapType6Select (|lambda#134| |l#0@@120| |l#1@@92| |l#2@@91| |l#3@@83|) $o@@159 $f@@81))  (=> (and (not (= $o@@159 |l#0@@120|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@92| $o@@159) |l#2@@91|))) |l#3@@83|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7911|
 :pattern ( (MapType6Select (|lambda#134| |l#0@@120| |l#1@@92| |l#2@@91| |l#3@@83|) $o@@159 $f@@81))
)))
(assert (forall ((arg0@@844 T@U) (arg1@@481 T@U) (arg2@@280 T@U) (arg3@@188 Bool) ) (! (= (type (|lambda#135| arg0@@844 arg1@@481 arg2@@280 arg3@@188)) (MapType6Type refType boolType))
 :qid |funType:lambda#135|
 :pattern ( (|lambda#135| arg0@@844 arg1@@481 arg2@@280 arg3@@188))
)))
(assert (forall ((|l#0@@121| T@U) (|l#1@@93| T@U) (|l#2@@92| T@U) (|l#3@@84| Bool) ($o@@160 T@U) ($f@@82 T@U) ) (! (let ((alpha@@89 (FieldTypeInv0 (type $f@@82))))
 (=> (and (and (and (and (= (type |l#0@@121|) refType) (= (type |l#1@@93|) (MapType0Type refType MapType1Type))) (= (type |l#2@@92|) (FieldType boolType))) (= (type $o@@160) refType)) (= (type $f@@82) (FieldType alpha@@89))) (= (U_2_bool (MapType6Select (|lambda#135| |l#0@@121| |l#1@@93| |l#2@@92| |l#3@@84|) $o@@160 $f@@82))  (=> (and (not (= $o@@160 |l#0@@121|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@93| $o@@160) |l#2@@92|))) |l#3@@84|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7912|
 :pattern ( (MapType6Select (|lambda#135| |l#0@@121| |l#1@@93| |l#2@@92| |l#3@@84|) $o@@160 $f@@82))
)))
(assert (forall ((arg0@@845 T@U) (arg1@@482 T@U) (arg2@@281 T@U) (arg3@@189 Bool) ) (! (= (type (|lambda#136| arg0@@845 arg1@@482 arg2@@281 arg3@@189)) (MapType6Type refType boolType))
 :qid |funType:lambda#136|
 :pattern ( (|lambda#136| arg0@@845 arg1@@482 arg2@@281 arg3@@189))
)))
(assert (forall ((|l#0@@122| T@U) (|l#1@@94| T@U) (|l#2@@93| T@U) (|l#3@@85| Bool) ($o@@161 T@U) ($f@@83 T@U) ) (! (let ((alpha@@90 (FieldTypeInv0 (type $f@@83))))
 (=> (and (and (and (and (= (type |l#0@@122|) refType) (= (type |l#1@@94|) (MapType0Type refType MapType1Type))) (= (type |l#2@@93|) (FieldType boolType))) (= (type $o@@161) refType)) (= (type $f@@83) (FieldType alpha@@90))) (= (U_2_bool (MapType6Select (|lambda#136| |l#0@@122| |l#1@@94| |l#2@@93| |l#3@@85|) $o@@161 $f@@83))  (=> (and (not (= $o@@161 |l#0@@122|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@94| $o@@161) |l#2@@93|))) |l#3@@85|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7913|
 :pattern ( (MapType6Select (|lambda#136| |l#0@@122| |l#1@@94| |l#2@@93| |l#3@@85|) $o@@161 $f@@83))
)))
(assert (forall ((arg0@@846 T@U) (arg1@@483 T@U) (arg2@@282 T@U) (arg3@@190 Bool) ) (! (= (type (|lambda#137| arg0@@846 arg1@@483 arg2@@282 arg3@@190)) (MapType6Type refType boolType))
 :qid |funType:lambda#137|
 :pattern ( (|lambda#137| arg0@@846 arg1@@483 arg2@@282 arg3@@190))
)))
(assert (forall ((|l#0@@123| T@U) (|l#1@@95| T@U) (|l#2@@94| T@U) (|l#3@@86| Bool) ($o@@162 T@U) ($f@@84 T@U) ) (! (let ((alpha@@91 (FieldTypeInv0 (type $f@@84))))
 (=> (and (and (and (and (= (type |l#0@@123|) refType) (= (type |l#1@@95|) (MapType0Type refType MapType1Type))) (= (type |l#2@@94|) (FieldType boolType))) (= (type $o@@162) refType)) (= (type $f@@84) (FieldType alpha@@91))) (= (U_2_bool (MapType6Select (|lambda#137| |l#0@@123| |l#1@@95| |l#2@@94| |l#3@@86|) $o@@162 $f@@84))  (=> (and (not (= $o@@162 |l#0@@123|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@95| $o@@162) |l#2@@94|))) |l#3@@86|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7914|
 :pattern ( (MapType6Select (|lambda#137| |l#0@@123| |l#1@@95| |l#2@@94| |l#3@@86|) $o@@162 $f@@84))
)))
(assert (forall ((arg0@@847 T@U) (arg1@@484 T@U) (arg2@@283 T@U) (arg3@@191 Bool) ) (! (= (type (|lambda#138| arg0@@847 arg1@@484 arg2@@283 arg3@@191)) (MapType6Type refType boolType))
 :qid |funType:lambda#138|
 :pattern ( (|lambda#138| arg0@@847 arg1@@484 arg2@@283 arg3@@191))
)))
(assert (forall ((|l#0@@124| T@U) (|l#1@@96| T@U) (|l#2@@95| T@U) (|l#3@@87| Bool) ($o@@163 T@U) ($f@@85 T@U) ) (! (let ((alpha@@92 (FieldTypeInv0 (type $f@@85))))
 (=> (and (and (and (and (= (type |l#0@@124|) refType) (= (type |l#1@@96|) (MapType0Type refType MapType1Type))) (= (type |l#2@@95|) (FieldType boolType))) (= (type $o@@163) refType)) (= (type $f@@85) (FieldType alpha@@92))) (= (U_2_bool (MapType6Select (|lambda#138| |l#0@@124| |l#1@@96| |l#2@@95| |l#3@@87|) $o@@163 $f@@85))  (=> (and (not (= $o@@163 |l#0@@124|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@96| $o@@163) |l#2@@95|))) |l#3@@87|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |7915|
 :pattern ( (MapType6Select (|lambda#138| |l#0@@124| |l#1@@96| |l#2@@95| |l#3@@87|) $o@@163 $f@@85))
)))
(assert (forall ((|l#0@@125| T@U) (|l#1@@97| T@U) (|$l#0#heap#0@@2| T@U) (|$l#0#i#0@@2| T@U) ) (!  (=> (and (and (and (= (type |l#0@@125|) TyType) (= (type |l#1@@97|) (SeqType BoxType))) (= (type |$l#0#heap#0@@2|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@2|) BoxType)) (= (MapType2Select (|lambda#139| |l#0@@125| |l#1@@97|) |$l#0#heap#0@@2| |$l#0#i#0@@2|) ($Box (bool_2_U (LinearMaybe.__default.has |l#0@@125| (|Seq#Index| |l#1@@97| (U_2_int ($Unbox intType |$l#0#i#0@@2|))))))))
 :qid |unknown.0:0|
 :skolemid |7916|
 :pattern ( (MapType2Select (|lambda#139| |l#0@@125| |l#1@@97|) |$l#0#heap#0@@2| |$l#0#i#0@@2|))
)))
(assert (forall ((|l#0@@126| T@U) (|$w#0@@1| T@U) ) (!  (=> (and (= (type |l#0@@126|) TyType) (= (type |$w#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#149| |l#0@@126|) |$w#0@@1|))  (and ($IsBox |$w#0@@1| |l#0@@126|) (TotalKMMapMod.__default.AnyKey ($Unbox (SeqType BoxType) |$w#0@@1|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7917|
 :pattern ( (MapType0Select (|lambda#149| |l#0@@126|) |$w#0@@1|))
)))
(assert (forall ((|l#0@@127| T@U) (|$w#0@@2| T@U) ) (!  (=> (and (= (type |l#0@@127|) BoxType) (= (type |$w#0@@2|) BoxType)) (= (MapType0Select (|lambda#150| |l#0@@127|) |$w#0@@2|) |l#0@@127|))
 :qid |TotalMapsdfyTotalKMMapMod.28:5|
 :skolemid |7918|
 :pattern ( (MapType0Select (|lambda#150| |l#0@@127|) |$w#0@@2|))
)))
(assert (forall ((|l#0@@128| T@U) (|l#1@@98| T@U) (|l#2@@96| Int) (|$y#0@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@128|) TyType) (= (type |l#1@@98|) (MapType0Type BoxType intType))) (= (type |$y#0@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#153| |l#0@@128| |l#1@@98| |l#2@@96|) |$y#0@@0|))  (and ($IsBox |$y#0@@0| |l#0@@128|) (> (U_2_int (MapType0Select |l#1@@98| |$y#0@@0|)) |l#2@@96|))))
 :qid |unknown.0:0|
 :skolemid |7919|
 :pattern ( (MapType0Select (|lambda#153| |l#0@@128| |l#1@@98| |l#2@@96|) |$y#0@@0|))
)))
(assert (forall ((|l#0@@129| T@U) (|l#1@@99| T@U) (|$y#0@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@129|) TyType) (= (type |l#1@@99|) (MapType0Type BoxType boolType))) (= (type |$y#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#155| |l#0@@129| |l#1@@99|) |$y#0@@1|))  (and ($IsBox |$y#0@@1| |l#0@@129|) (U_2_bool (MapType0Select |l#1@@99| |$y#0@@1|)))))
 :qid |unknown.0:0|
 :skolemid |7920|
 :pattern ( (MapType0Select (|lambda#155| |l#0@@129| |l#1@@99|) |$y#0@@1|))
)))
(assert (forall ((|l#0@@130| T@U) (|l#1@@100| T@U) (|l#2@@97| T@U) (|l#3@@88| T@U) (|$l#0#heap#0@@3| T@U) (|$l#0#i#0@@3| T@U) ) (!  (=> (and (and (and (and (and (= (type |l#0@@130|) TyType) (= (type |l#1@@100|) TyType)) (= (type |l#2@@97|) HandleTypeType)) (= (type |l#3@@88|) (SeqType BoxType))) (= (type |$l#0#heap#0@@3|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@3|) BoxType)) (= (MapType2Select (|lambda#161| |l#0@@130| |l#1@@100| |l#2@@97| |l#3@@88|) |$l#0#heap#0@@3| |$l#0#i#0@@3|) (Apply1 |l#0@@130| |l#1@@100| |$l#0#heap#0@@3| |l#2@@97| (|Seq#Index| |l#3@@88| (U_2_int ($Unbox intType |$l#0#i#0@@3|))))))
 :qid |unknown.0:0|
 :skolemid |7921|
 :pattern ( (MapType2Select (|lambda#161| |l#0@@130| |l#1@@100| |l#2@@97| |l#3@@88|) |$l#0#heap#0@@3| |$l#0#i#0@@3|))
)))
(assert (forall ((|l#0@@131| T@U) (|l#1@@101| Int) (|l#2@@98| Int) (|l#3@@89| T@U) (|l#4| T@U) (|l#5| T@U) (|l#6| T@U) (|$l#0#heap#0@@4| T@U) (|$l#0#i#0@@4| T@U) ) (!  (=> (and (and (and (and (and (and (= (type |l#0@@131|) TyType) (= (type |l#3@@89|) TyType)) (= (type |l#4|) TyType)) (= (type |l#5|) HandleTypeType)) (= (type |l#6|) (SeqType BoxType))) (= (type |$l#0#heap#0@@4|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@4|) BoxType)) (= (U_2_bool (MapType2Select (|lambda#162| |l#0@@131| |l#1@@101| |l#2@@98| |l#3@@89| |l#4| |l#5| |l#6|) |$l#0#heap#0@@4| |$l#0#i#0@@4|))  (and ($IsBox |$l#0#i#0@@4| |l#0@@131|) (and (and (INTERNAL_le_boogie |l#1@@101| (U_2_int ($Unbox intType |$l#0#i#0@@4|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$l#0#i#0@@4|)) |l#2@@98|)) (Requires1 |l#3@@89| |l#4| |$l#0#heap#0@@4| |l#5| (|Seq#Index| |l#6| (U_2_int ($Unbox intType |$l#0#i#0@@4|))))))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |7922|
 :pattern ( (MapType2Select (|lambda#162| |l#0@@131| |l#1@@101| |l#2@@98| |l#3@@89| |l#4| |l#5| |l#6|) |$l#0#heap#0@@4| |$l#0#i#0@@4|))
)))
(assert (forall ((arg0@@848 T@U) (arg1@@485 Int) (arg2@@284 Int) (arg3@@192 T@U) (arg4@@59 T@U) (arg5@@23 T@U) (arg6@@9 T@U) (arg7@@4 T@U) (arg8@@4 T@U) (arg9@@2 T@U) (arg10@@2 T@U) (arg11 T@U) (arg12 T@U) ) (! (= (type (|lambda#163| arg0@@848 arg1@@485 arg2@@284 arg3@@192 arg4@@59 arg5@@23 arg6@@9 arg7@@4 arg8@@4 arg9@@2 arg10@@2 arg11 arg12)) (MapType0Type refType boolType))
 :qid |funType:lambda#163|
 :pattern ( (|lambda#163| arg0@@848 arg1@@485 arg2@@284 arg3@@192 arg4@@59 arg5@@23 arg6@@9 arg7@@4 arg8@@4 arg9@@2 arg10@@2 arg11 arg12))
)))
(assert (forall ((|l#0@@132| T@U) (|l#1@@102| Int) (|l#2@@99| Int) (|l#3@@90| T@U) (|l#4@@0| T@U) (|l#5@@0| T@U) (|l#6@@0| T@U) (|l#7| T@U) (|l#8| T@U) (|l#9| T@U) (|l#10| T@U) (|l#11| T@U) (|l#12| T@U) (|$l#0#o#0@@0| T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type |l#0@@132|) TyType) (= (type |l#3@@90|) TyType)) (= (type |l#4@@0|) TyType)) (= (type |l#5@@0|) (MapType0Type refType MapType1Type))) (= (type |l#6@@0|) HandleTypeType)) (= (type |l#7|) (SeqType BoxType))) (= (type |l#8|) TyType)) (= (type |l#9|) TyType)) (= (type |l#10|) (MapType0Type refType MapType1Type))) (= (type |l#11|) HandleTypeType)) (= (type |l#12|) (SeqType BoxType))) (= (type |$l#0#o#0@@0|) refType)) (= (U_2_bool (MapType0Select (|lambda#163| |l#0@@132| |l#1@@102| |l#2@@99| |l#3@@90| |l#4@@0| |l#5@@0| |l#6@@0| |l#7| |l#8| |l#9| |l#10| |l#11| |l#12|) |$l#0#o#0@@0|)) (exists ((|i#3@@13| Int) (|o#0| T@U) ) (!  (and (= (type |o#0|) refType) (and (and ($Is |o#0| |l#0@@132|) (and (and (INTERNAL_le_boogie |l#1@@102| |i#3@@13|) (INTERNAL_lt_boogie |i#3@@13| |l#2@@99|)) (U_2_bool (MapType0Select (Reads1 |l#3@@90| |l#4@@0| |l#5@@0| |l#6@@0| (|Seq#Index| |l#7| |i#3@@13|)) ($Box |o#0|))))) (= ($Box |$l#0#o#0@@0|) ($Box |o#0|))))
 :qid |Sequencesidfy.142:17|
 :skolemid |4896|
 :pattern ( (MapType0Select (Reads1 |l#8| |l#9| |l#10| |l#11| (|Seq#Index| |l#12| |i#3@@13|)) ($Box |o#0|)))
))))
 :qid |unknown.0:0|
 :skolemid |7923|
 :pattern ( (MapType0Select (|lambda#163| |l#0@@132| |l#1@@102| |l#2@@99| |l#3@@90| |l#4@@0| |l#5@@0| |l#6@@0| |l#7| |l#8| |l#9| |l#10| |l#11| |l#12|) |$l#0#o#0@@0|))
)))
(assert (forall ((|l#0@@133| T@U) (|l#1@@103| Int) (|l#2@@100| Int) (|l#3@@91| T@U) (|l#4@@1| T@U) (|l#5@@1| T@U) (|l#6@@1| T@U) (|l#7@@0| T@U) (|l#8@@0| T@U) (|l#9@@0| T@U) (|l#10@@0| T@U) (|$l#0#heap#0@@5| T@U) (|$l#0#i#0@@5| T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type |l#0@@133|) TyType) (= (type |l#3@@91|) TyType)) (= (type |l#4@@1|) TyType)) (= (type |l#5@@1|) HandleTypeType)) (= (type |l#6@@1|) (SeqType BoxType))) (= (type |l#7@@0|) TyType)) (= (type |l#8@@0|) TyType)) (= (type |l#9@@0|) HandleTypeType)) (= (type |l#10@@0|) (SeqType BoxType))) (= (type |$l#0#heap#0@@5|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@5|) BoxType)) (= (MapType2Select (|lambda#164| |l#0@@133| |l#1@@103| |l#2@@100| |l#3@@91| |l#4@@1| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |l#9@@0| |l#10@@0|) |$l#0#heap#0@@5| |$l#0#i#0@@5|) (SetRef_to_SetBox (|lambda#163| |l#0@@133| |l#1@@103| |l#2@@100| |l#3@@91| |l#4@@1| |$l#0#heap#0@@5| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |$l#0#heap#0@@5| |l#9@@0| |l#10@@0|))))
 :qid |unknown.0:0|
 :skolemid |7924|
 :pattern ( (MapType2Select (|lambda#164| |l#0@@133| |l#1@@103| |l#2@@100| |l#3@@91| |l#4@@1| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |l#9@@0| |l#10@@0|) |$l#0#heap#0@@5| |$l#0#i#0@@5|))
)))
(assert (forall ((|$l#2#heap#0| T@U) (|$l#2#a#0| T@U) (|$l#2#e#0| T@U) ) (!  (=> (and (and (= (type |$l#2#heap#0|) (MapType0Type refType MapType1Type)) (= (type |$l#2#a#0|) BoxType)) (= (type |$l#2#e#0|) BoxType)) (= (MapType3Select |lambda#176| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|) ($Box (|Set#Union| ($Unbox (MapType0Type BoxType boolType) |$l#2#a#0|) ($Unbox (MapType0Type BoxType boolType) |$l#2#e#0|)))))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |7925|
 :pattern ( (MapType3Select |lambda#176| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|))
)))
(assert (forall ((|l#0@@134| T@U) (|l#1@@104| T@U) (|$l#2#heap#0@@0| T@U) (|$l#2#a#0@@0| T@U) (|$l#2#e#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@134|) TyType) (= (type |l#1@@104|) TyType)) (= (type |$l#2#heap#0@@0|) (MapType0Type refType MapType1Type))) (= (type |$l#2#a#0@@0|) BoxType)) (= (type |$l#2#e#0@@0|) BoxType)) (= (U_2_bool (MapType3Select (|lambda#177| |l#0@@134| |l#1@@104|) |$l#2#heap#0@@0| |$l#2#a#0@@0| |$l#2#e#0@@0|))  (and ($IsBox |$l#2#a#0@@0| |l#0@@134|) ($IsBox |$l#2#e#0@@0| |l#1@@104|))))
 :qid |unknown.0:0|
 :skolemid |7926|
 :pattern ( (MapType3Select (|lambda#177| |l#0@@134| |l#1@@104|) |$l#2#heap#0@@0| |$l#2#a#0@@0| |$l#2#e#0@@0|))
)))
(assert (forall ((|l#0@@135| T@U) (|$l#2#heap#0@@1| T@U) (|$l#2#a#0@@1| T@U) (|$l#2#e#0@@1| T@U) ) (!  (=> (and (and (and (= (type |l#0@@135|) (MapType0Type BoxType boolType)) (= (type |$l#2#heap#0@@1|) (MapType0Type refType MapType1Type))) (= (type |$l#2#a#0@@1|) BoxType)) (= (type |$l#2#e#0@@1|) BoxType)) (= (MapType3Select (|lambda#179| |l#0@@135|) |$l#2#heap#0@@1| |$l#2#a#0@@1| |$l#2#e#0@@1|) |l#0@@135|))
 :qid |Sequencesidfy.350:15|
 :skolemid |7927|
 :pattern ( (MapType3Select (|lambda#179| |l#0@@135|) |$l#2#heap#0@@1| |$l#2#a#0@@1| |$l#2#e#0@@1|))
)))
(assert (forall ((|l#0@@136| T@U) (|l#1@@105| T@U) (|l#2@@101| T@U) (|$w#0@@3| T@U) ) (!  (=> (and (and (and (= (type |l#0@@136|) TyType) (= (type |l#1@@105|) (MapType0Type BoxType boolType))) (= (type |l#2@@101|) BoxType)) (= (type |$w#0@@3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#196| |l#0@@136| |l#1@@105| |l#2@@101|) |$w#0@@3|))  (and ($IsBox |$w#0@@3| |l#0@@136|) (and (U_2_bool (MapType0Select |l#1@@105| |$w#0@@3|)) (not (= |$w#0@@3| |l#2@@101|))))))
 :qid |unknown.0:0|
 :skolemid |7928|
 :pattern ( (MapType0Select (|lambda#196| |l#0@@136| |l#1@@105| |l#2@@101|) |$w#0@@3|))
)))
(assert (forall ((|l#0@@137| T@U) (|$w#0@@4| T@U) ) (!  (=> (and (= (type |l#0@@137|) (MapType0Type BoxType BoxType)) (= (type |$w#0@@4|) BoxType)) (= (MapType0Select (|lambda#197| |l#0@@137|) |$w#0@@4|) (MapType0Select |l#0@@137| |$w#0@@4|)))
 :qid |MapRemovesdfy.22:44|
 :skolemid |7929|
 :pattern ( (MapType0Select (|lambda#197| |l#0@@137|) |$w#0@@4|))
)))
(assert (forall ((|l#0@@138| T@U) (|l#1@@106| T@U) (|l#2@@102| T@U) (|$w#0@@5| T@U) ) (!  (=> (and (and (and (= (type |l#0@@138|) TyType) (= (type |l#1@@106|) (MapType0Type BoxType boolType))) (= (type |l#2@@102|) (MapType0Type BoxType boolType))) (= (type |$w#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#202| |l#0@@138| |l#1@@106| |l#2@@102|) |$w#0@@5|))  (and ($IsBox |$w#0@@5| |l#0@@138|) (and (U_2_bool (MapType0Select |l#1@@106| |$w#0@@5|)) (not (U_2_bool (MapType0Select |l#2@@102| |$w#0@@5|)))))))
 :qid |unknown.0:0|
 :skolemid |7930|
 :pattern ( (MapType0Select (|lambda#202| |l#0@@138| |l#1@@106| |l#2@@102|) |$w#0@@5|))
)))
(assert (forall ((|l#0@@139| T@U) (|l#1@@107| T@U) (|l#2@@103| T@U) (|$w#0@@6| T@U) ) (!  (=> (and (and (and (= (type |l#0@@139|) TyType) (= (type |l#1@@107|) TyType)) (= (type |l#2@@103|) (IMapType BoxType BoxType))) (= (type |$w#0@@6|) BoxType)) (= (MapType0Select (|lambda#207| |l#0@@139| |l#1@@107| |l#2@@103|) |$w#0@@6|) (let ((|a#0@@219| (|$let#8_a| |l#0@@139| |l#1@@107| |l#2@@103| |$w#0@@6|)))
|a#0@@219|)))
 :qid |unknown.0:0|
 :skolemid |7931|
 :pattern ( (MapType0Select (|lambda#207| |l#0@@139| |l#1@@107| |l#2@@103|) |$w#0@@6|))
)))
(assert (forall ((|l#0@@140| T@U) (|l#1@@108| T@U) (|l#2@@104| T@U) (|$w#0@@7| T@U) ) (!  (=> (and (and (and (= (type |l#0@@140|) TyType) (= (type |l#1@@108|) (MapType0Type BoxType boolType))) (= (type |l#2@@104|) (MapType0Type BoxType boolType))) (= (type |$w#0@@7|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#218| |l#0@@140| |l#1@@108| |l#2@@104|) |$w#0@@7|))  (and ($IsBox |$w#0@@7| |l#0@@140|) (and (U_2_bool (MapType0Select |l#1@@108| |$w#0@@7|)) (U_2_bool (MapType0Select |l#2@@104| |$w#0@@7|))))))
 :qid |unknown.0:0|
 :skolemid |7932|
 :pattern ( (MapType0Select (|lambda#218| |l#0@@140| |l#1@@108| |l#2@@104|) |$w#0@@7|))
)))
(assert (forall ((|l#0@@141| T@U) (|l#1@@109| T@U) (|l#2@@105| T@U) (|$w#0@@8| T@U) ) (!  (=> (and (and (and (= (type |l#0@@141|) (MapType0Type BoxType boolType)) (= (type |l#1@@109|) (MapType0Type BoxType BoxType))) (= (type |l#2@@105|) (MapType0Type BoxType BoxType))) (= (type |$w#0@@8|) BoxType)) (= (MapType0Select (|lambda#233| |l#0@@141| |l#1@@109| |l#2@@105|) |$w#0@@8|) (ite (U_2_bool (MapType0Select |l#0@@141| |$w#0@@8|)) (MapType0Select |l#1@@109| |$w#0@@8|) (MapType0Select |l#2@@105| |$w#0@@8|))))
 :qid |Mapsidfy.134:52|
 :skolemid |7933|
 :pattern ( (MapType0Select (|lambda#233| |l#0@@141| |l#1@@109| |l#2@@105|) |$w#0@@8|))
)))
(assert (forall ((|l#0@@142| T@U) (|l#1@@110| T@U) (|l#2@@106| T@U) (|l#3@@92| T@U) (|l#4@@2| T@U) (|$w#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type |l#0@@142|) (MapType0Type BoxType boolType)) (= (type |l#1@@110|) (MapType0Type BoxType BoxType))) (= (type |l#2@@106|) (MapType0Type BoxType boolType))) (= (type |l#3@@92|) (MapType0Type BoxType BoxType))) (= (type |l#4@@2|) (MapType0Type BoxType BoxType))) (= (type |$w#0@@9|) BoxType)) (= (MapType0Select (|lambda#253| |l#0@@142| |l#1@@110| |l#2@@106| |l#3@@92| |l#4@@2|) |$w#0@@9|) (ite (U_2_bool (MapType0Select |l#0@@142| |$w#0@@9|)) (MapType0Select |l#1@@110| |$w#0@@9|) (ite (U_2_bool (MapType0Select |l#2@@106| |$w#0@@9|)) (MapType0Select |l#3@@92| |$w#0@@9|) (MapType0Select |l#4@@2| |$w#0@@9|)))))
 :qid |Mapsidfy.212:9|
 :skolemid |7934|
 :pattern ( (MapType0Select (|lambda#253| |l#0@@142| |l#1@@110| |l#2@@106| |l#3@@92| |l#4@@2|) |$w#0@@9|))
)))
(assert (forall ((|l#0@@143| T@U) (|l#1@@111| Int) (|l#2@@107| Int) (|$y#0@@2| T@U) ) (!  (=> (and (= (type |l#0@@143|) TyType) (= (type |$y#0@@2|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#260| |l#0@@143| |l#1@@111| |l#2@@107|) |$y#0@@2|))  (and ($IsBox |$y#0@@2| |l#0@@143|) (and (INTERNAL_le_boogie |l#1@@111| (U_2_int ($Unbox intType |$y#0@@2|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$y#0@@2|)) |l#2@@107|)))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |7935|
 :pattern ( (MapType0Select (|lambda#260| |l#0@@143| |l#1@@111| |l#2@@107|) |$y#0@@2|))
)))
(assert (forall ((|l#0@@144| T@U) (|l#1@@112| T@U) (|$l#0#heap#0@@6| T@U) (|$l#0#i#0@@6| T@U) ) (!  (=> (and (and (and (= (type |l#0@@144|) (SeqType BoxType)) (= (type |l#1@@112|) (MapType0Type BoxType boolType))) (= (type |$l#0#heap#0@@6|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@6|) BoxType)) (= (MapType2Select (|lambda#276| |l#0@@144| |l#1@@112|) |$l#0#heap#0@@6| |$l#0#i#0@@6|) ($Box (Buffers.Buffer.ApplyFilter ($Unbox DatatypeTypeType (|Seq#Index| |l#0@@144| (U_2_int ($Unbox intType |$l#0#i#0@@6|)))) |l#1@@112|))))
 :qid |Buffersidfy.55:63|
 :skolemid |7936|
 :pattern ( (MapType2Select (|lambda#276| |l#0@@144| |l#1@@112|) |$l#0#heap#0@@6| |$l#0#i#0@@6|))
)))
(assert (forall ((|l#0@@145| T@U) (|l#1@@113| Int) (|$y#2| T@U) ) (!  (=> (and (= (type |l#0@@145|) TyType) (= (type |$y#2|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#295| |l#0@@145| |l#1@@113|) |$y#2|))  (and ($IsBox |$y#2| |l#0@@145|) (Byte__Order.__default.lt (U_2_int ($Unbox intType |$y#2|)) |l#1@@113|))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |7937|
 :pattern ( (MapType0Select (|lambda#295| |l#0@@145| |l#1@@113|) |$y#2|))
)))
(assert (forall ((|l#0@@146| T@U) (|l#1@@114| T@U) (|l#2@@108| Int) (|$y#3| T@U) ) (!  (=> (and (and (= (type |l#0@@146|) TyType) (= (type |l#1@@114|) LayerTypeType)) (= (type |$y#3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#297| |l#0@@146| |l#1@@114| |l#2@@108|) |$y#3|))  (and ($IsBox |$y#3| |l#0@@146|) (Byte__Order.__default.lte |l#1@@114| |l#2@@108| (U_2_int ($Unbox intType |$y#3|))))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |7938|
 :pattern ( (MapType0Select (|lambda#297| |l#0@@146| |l#1@@114| |l#2@@108|) |$y#3|))
)))
(assert (forall ((|l#0@@147| T@U) (|l#1@@115| T@U) (|$y#1| T@U) ) (!  (=> (and (and (= (type |l#0@@147|) TyType) (= (type |l#1@@115|) (SeqType BoxType))) (= (type |$y#1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#307| |l#0@@147| |l#1@@115|) |$y#1|))  (and ($IsBox |$y#1| |l#0@@147|) (|Seq#Contains| |l#1@@115| |$y#1|))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |7939|
 :pattern ( (MapType0Select (|lambda#307| |l#0@@147| |l#1@@115|) |$y#1|))
)))
(assert (forall ((|l#0@@148| T@U) (|l#1@@116| T@U) (|$y#2@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@148|) TyType) (= (type |l#1@@116|) (SeqType BoxType))) (= (type |$y#2@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#311| |l#0@@148| |l#1@@116|) |$y#2@@0|))  (and ($IsBox |$y#2@@0| |l#0@@148|) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) |$y#2@@0|) |l#1@@116|))))
 :qid |unknown.0:0|
 :skolemid |7940|
 :pattern ( (MapType0Select (|lambda#311| |l#0@@148| |l#1@@116|) |$y#2@@0|))
)))
(assert (forall ((|l#0@@149| T@U) (|l#1@@117| T@U) (|$y#3@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@149|) TyType) (= (type |l#1@@117|) (SeqType BoxType))) (= (type |$y#3@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#313| |l#0@@149| |l#1@@117|) |$y#3@@0|))  (and ($IsBox |$y#3@@0| |l#0@@149|) (Lexicographic__Byte__Order.__default.lte |l#1@@117| ($Unbox (SeqType BoxType) |$y#3@@0|)))))
 :qid |unknown.0:0|
 :skolemid |7941|
 :pattern ( (MapType0Select (|lambda#313| |l#0@@149| |l#1@@117|) |$y#3@@0|))
)))
(assert (forall ((|l#0@@150| T@U) (|$l#0#heap#0@@7| T@U) (|$l#0#i#0@@7| T@U) ) (!  (=> (and (and (= (type |l#0@@150|) (SeqType BoxType)) (= (type |$l#0#heap#0@@7|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@7|) BoxType)) (= (MapType2Select (|lambda#327| |l#0@@150|) |$l#0#heap#0@@7| |$l#0#i#0@@7|) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| ($Unbox (SeqType BoxType) (|Seq#Index| |l#0@@150| (U_2_int ($Unbox intType |$l#0#i#0@@7|))))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:23|
 :skolemid |7942|
 :pattern ( (MapType2Select (|lambda#327| |l#0@@150|) |$l#0#heap#0@@7| |$l#0#i#0@@7|))
)))
(assert (forall ((|l#0@@151| T@U) (|l#1@@118| T@U) (|$y#2@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@151|) TyType) (= (type |l#1@@118|) DatatypeTypeType)) (= (type |$y#2@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#337| |l#0@@151| |l#1@@118|) |$y#2@@1|))  (and ($IsBox |$y#2@@1| |l#0@@151|) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType |$y#2@@1|) |l#1@@118|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:12|
 :skolemid |7943|
 :pattern ( (MapType0Select (|lambda#337| |l#0@@151| |l#1@@118|) |$y#2@@1|))
)))
(assert (forall ((|l#0@@152| T@U) (|l#1@@119| T@U) (|$y#3@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@152|) TyType) (= (type |l#1@@119|) DatatypeTypeType)) (= (type |$y#3@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#339| |l#0@@152| |l#1@@119|) |$y#3@@1|))  (and ($IsBox |$y#3@@1| |l#0@@152|) (Upperbounded__Lexicographic__Byte__Order.__default.lte |l#1@@119| ($Unbox DatatypeTypeType |$y#3@@1|)))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:12|
 :skolemid |7944|
 :pattern ( (MapType0Select (|lambda#339| |l#0@@152| |l#1@@119|) |$y#3@@1|))
)))
(assert (forall ((|l#0@@153| T@U) (|l#1@@120| T@U) (|l#2@@109| T@U) (|l#3@@93| Int) (|$y#0@@3| T@U) ) (!  (=> (and (and (and (= (type |l#0@@153|) TyType) (= (type |l#1@@120|) (SeqType BoxType))) (= (type |l#2@@109|) (SeqType BoxType))) (= (type |$y#0@@3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#363| |l#0@@153| |l#1@@120| |l#2@@109| |l#3@@93|) |$y#0@@3|))  (and ($IsBox |$y#0@@3| |l#0@@153|) (and (BoundedPivotsLib.__default.BoundedKey |l#1@@120| ($Unbox (SeqType BoxType) |$y#0@@3|)) (= (BoundedPivotsLib.__default.Route |l#2@@109| ($Unbox (SeqType BoxType) |$y#0@@3|)) |l#3@@93|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7945|
 :pattern ( (MapType0Select (|lambda#363| |l#0@@153| |l#1@@120| |l#2@@109| |l#3@@93|) |$y#0@@3|))
)))
(assert (forall ((|l#0@@154| T@U) (|l#1@@121| T@U) (|$y#0@@4| T@U) ) (!  (=> (and (and (= (type |l#0@@154|) TyType) (= (type |l#1@@121|) DatatypeTypeType)) (= (type |$y#0@@4|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#365| |l#0@@154| |l#1@@121|) |$y#0@@4|))  (and ($IsBox |$y#0@@4| |l#0@@154|) (DomainMod.Domain.Contains |l#1@@121| ($Unbox (SeqType BoxType) |$y#0@@4|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7946|
 :pattern ( (MapType0Select (|lambda#365| |l#0@@154| |l#1@@121|) |$y#0@@4|))
)))
(assert (forall ((|l#0@@155| T@U) (|l#1@@122| T@U) (|$y#0@@5| T@U) ) (!  (=> (and (and (= (type |l#0@@155|) TyType) (= (type |l#1@@122|) DatatypeTypeType)) (= (type |$y#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#367| |l#0@@155| |l#1@@122|) |$y#0@@5|))  (and ($IsBox |$y#0@@5| |l#0@@155|) (PivotBetree.BetreeNode.KeyInDomain |l#1@@122| ($Unbox (SeqType BoxType) |$y#0@@5|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |7947|
 :pattern ( (MapType0Select (|lambda#367| |l#0@@155| |l#1@@122|) |$y#0@@5|))
)))
(assert (forall ((|l#0@@156| T@U) (|l#1@@123| T@U) (|l#2@@110| T@U) (|$w#0@@10| T@U) ) (!  (=> (and (and (and (= (type |l#0@@156|) (MapType0Type BoxType boolType)) (= (type |l#1@@123|) (MapType0Type BoxType BoxType))) (= (type |l#2@@110|) DatatypeTypeType)) (= (type |$w#0@@10|) BoxType)) (= (MapType0Select (|lambda#370| |l#0@@156| |l#1@@123| |l#2@@110|) |$w#0@@10|) ($Box (ite (U_2_bool (MapType0Select |l#0@@156| |$w#0@@10|)) ($Unbox DatatypeTypeType (MapType0Select |l#1@@123| |$w#0@@10|)) |l#2@@110|))))
 :qid |PagedBetreeidfy.99:39|
 :skolemid |7948|
 :pattern ( (MapType0Select (|lambda#370| |l#0@@156| |l#1@@123| |l#2@@110|) |$w#0@@10|))
)))
(assert (forall ((|l#0@@157| T@U) (|l#1@@124| T@U) (|l#2@@111| T@U) (|l#3@@94| T@U) (|l#4@@3| T@U) (|l#5@@2| T@U) (|l#6@@2| T@U) (|$w#0@@11| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type |l#0@@157|) (MapType0Type BoxType boolType)) (= (type |l#1@@124|) DatatypeTypeType)) (= (type |l#2@@111|) (MapType0Type BoxType boolType))) (= (type |l#3@@94|) (MapType0Type BoxType boolType))) (= (type |l#4@@3|) DatatypeTypeType)) (= (type |l#5@@2|) (MapType0Type BoxType boolType))) (= (type |l#6@@2|) DatatypeTypeType)) (= (type |$w#0@@11|) BoxType)) (= (MapType0Select (|lambda#376| |l#0@@157| |l#1@@124| |l#2@@111| |l#3@@94| |l#4@@3| |l#5@@2| |l#6@@2|) |$w#0@@11|) ($Box (ite (U_2_bool (MapType0Select |l#0@@157| |$w#0@@11|)) (PagedBetree.BetreeNode.FilterBuffersAndChildren (PagedBetree.BetreeNode.Child |l#1@@124| ($Unbox (SeqType BoxType) |$w#0@@11|)) |l#2@@111|) (ite (U_2_bool (MapType0Select |l#3@@94| |$w#0@@11|)) (PagedBetree.BetreeNode.FilterBuffersAndChildren (PagedBetree.BetreeNode.Child |l#4@@3| ($Unbox (SeqType BoxType) |$w#0@@11|)) |l#5@@2|) (PagedBetree.BetreeNode.Child |l#6@@2| ($Unbox (SeqType BoxType) |$w#0@@11|)))))))
 :qid |PagedBetreeidfy.109:20|
 :skolemid |7949|
 :pattern ( (MapType0Select (|lambda#376| |l#0@@157| |l#1@@124| |l#2@@111| |l#3@@94| |l#4@@3| |l#5@@2| |l#6@@2|) |$w#0@@11|))
)))
(assert (forall ((|l#0@@158| T@U) (|l#1@@125| T@U) (|l#2@@112| T@U) (|l#3@@95| T@U) (|$w#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@158|) (MapType0Type BoxType boolType)) (= (type |l#1@@125|) DatatypeTypeType)) (= (type |l#2@@112|) DatatypeTypeType)) (= (type |l#3@@95|) DatatypeTypeType)) (= (type |$w#0@@12|) BoxType)) (= (MapType0Select (|lambda#382| |l#0@@158| |l#1@@125| |l#2@@112| |l#3@@95|) |$w#0@@12|) ($Box (ite (U_2_bool (MapType0Select |l#0@@158| |$w#0@@12|)) (PagedBetree.BetreeNode.PushBufferStack (PagedBetree.BetreeNode.Promote (PagedBetree.BetreeNode.Child |l#1@@125| ($Unbox (SeqType BoxType) |$w#0@@12|))) |l#2@@112|) (PagedBetree.BetreeNode.Child |l#3@@95| ($Unbox (SeqType BoxType) |$w#0@@12|))))))
 :qid |PagedBetreeidfy.136:20|
 :skolemid |7950|
 :pattern ( (MapType0Select (|lambda#382| |l#0@@158| |l#1@@125| |l#2@@112| |l#3@@95|) |$w#0@@12|))
)))
(assert (forall ((|l#0@@159| T@U) (|l#1@@126| T@U) (|l#2@@113| T@U) (|$w#0@@13| T@U) ) (!  (=> (and (and (and (= (type |l#0@@159|) (MapType0Type BoxType boolType)) (= (type |l#1@@126|) DatatypeTypeType)) (= (type |l#2@@113|) DatatypeTypeType)) (= (type |$w#0@@13|) BoxType)) (= (MapType0Select (|lambda#388| |l#0@@159| |l#1@@126| |l#2@@113|) |$w#0@@13|) ($Box (ite (U_2_bool (MapType0Select |l#0@@159| |$w#0@@13|)) |l#1@@126| (PagedBetree.BetreeNode.Child |l#2@@113| ($Unbox (SeqType BoxType) |$w#0@@13|))))))
 :qid |PagedBetreeidfy.351:53|
 :skolemid |7951|
 :pattern ( (MapType0Select (|lambda#388| |l#0@@159| |l#1@@126| |l#2@@113|) |$w#0@@13|))
)))
(assert (forall ((|l#0@@160| T@U) (|$w#0@@14| T@U) ) (!  (=> (and (= (type |l#0@@160|) DatatypeTypeType) (= (type |$w#0@@14|) BoxType)) (= (MapType0Select (|lambda#398| |l#0@@160|) |$w#0@@14|) ($Box (PagedBetreeRefinement.__default.INodeAt |l#0@@160| ($Unbox (SeqType BoxType) |$w#0@@14|)))))
 :qid |PagedBetreeRefinementidfy.51:28|
 :skolemid |7952|
 :pattern ( (MapType0Select (|lambda#398| |l#0@@160|) |$w#0@@14|))
)))
(assert (forall ((|l#0@@161| T@U) (|l#1@@127| T@U) (|$w#0@@15| T@U) ) (!  (=> (and (and (= (type |l#0@@161|) DatatypeTypeType) (= (type |l#1@@127|) (MapType0Type BoxType BoxType))) (= (type |$w#0@@15|) BoxType)) (= (MapType0Select (|lambda#402| |l#0@@161| |l#1@@127|) |$w#0@@15|) ($Box (ValueMessage.__default.Merge (MemtableMod.Memtable.Get |l#0@@161| ($Unbox (SeqType BoxType) |$w#0@@15|)) ($Unbox DatatypeTypeType (MapType0Select |l#1@@127| |$w#0@@15|))))))
 :qid |PagedBetreeRefinementidfy.115:31|
 :skolemid |7953|
 :pattern ( (MapType0Select (|lambda#402| |l#0@@161| |l#1@@127|) |$w#0@@15|))
)))
(declare-fun ControlFlow (Int Int) Int)
(declare-fun |v'#0@@115| () T@U)
(declare-fun |step#0_0@0| () T@U)
(declare-fun $Heap@@111 () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun |##original#0_2_0@0| () T@U)
(declare-fun |##newBufs#0_2_0@0| () T@U)
(declare-fun |compactedNode#0_2_0@0| () T@U)
(declare-fun |path##0_2_0@0| () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $Heap@2 () T@U)
(declare-fun |path##0_1_0@0| () T@U)
(declare-fun |##childIdx#0_1_0@0| () Int)
(declare-fun |target'##0_1_0@0| () T@U)
(declare-fun $Heap@1 () T@U)
(declare-fun |path##0_0_0@0| () T@U)
(declare-fun |##request#0_0_0@0| () T@U)
(declare-fun |target'##0_0_0@0| () T@U)
(declare-fun $Heap@0 () T@U)
(declare-fun |v#0@@176| () T@U)
(declare-fun |lbl#0@@123| () T@U)
(declare-fun |step#0_1@0| () T@U)
(declare-fun StartFuel_Sequences._default.Range () T@U)
(declare-fun StartFuelAssert_Sequences._default.Range () T@U)
(declare-fun StartFuel_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuelAssert_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuel_Sequences._default.remove () T@U)
(declare-fun StartFuelAssert_Sequences._default.remove () T@U)
(declare-fun StartFuel_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuelAssert_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuelAssert_Sequences._default.insert () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace1with2 () T@U)
(declare-fun StartFuel_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuel_Sequences._default.concat () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat () T@U)
(declare-fun StartFuel_Sequences._default.concat3 () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat3 () T@U)
(declare-fun StartFuel_Sequences._default.concatSeq () T@U)
(declare-fun StartFuelAssert_Sequences._default.concatSeq () T@U)
(declare-fun StartFuel_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuel_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexIterate () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuel_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuel_Sequences._default.Zip () T@U)
(declare-fun StartFuelAssert_Sequences._default.Zip () T@U)
(declare-fun StartFuelAssert_Sequences._default.Unzip () T@U)
(declare-fun StartFuel_Sequences._default.Flatten () T@U)
(declare-fun StartFuelAssert_Sequences._default.Flatten () T@U)
(declare-fun StartFuel_Sequences._default.seqMax () T@U)
(declare-fun StartFuelAssert_Sequences._default.seqMax () T@U)
(declare-fun StartFuel_Sequences._default.fill () T@U)
(declare-fun StartFuelAssert_Sequences._default.fill () T@U)
(declare-fun StartFuel_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuel_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuel_Maps._default.IMapInvert () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapInvert () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferA () T@U)
(declare-fun StartFuel_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.MapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferA () T@U)
(declare-fun StartFuel_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.IMapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnion () T@U)
(declare-fun StartFuel_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun StartFuelAssert_SeqComparison._default.lte () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.lte () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuel_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft () T@U)
(declare-fun StartFuelAssert_BoundedPivotsLib._default.CutoffForRight () T@U)
(declare-fun StartFuelAssert_DomainMod.Domain.SaneKeys () T@U)
(declare-fun StartFuel_PagedBetree.Path.ReplacedChildren () T@U)
(declare-fun StartFuelAssert_PagedBetree.Path.ReplacedChildren () T@U)
(declare-fun StartFuelAssert_PagedBetreeRefinement._default.INode () T@U)
(declare-fun StartFuel_PagedBetreeRefinement._default.MapApply () T@U)
(declare-fun StartFuelAssert_PagedBetreeRefinement._default.MapApply () T@U)
(declare-fun |step#0_0| () T@U)
(declare-fun |compactedNode#0_2_0| () T@U)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type |v'#0@@115|) DatatypeTypeType) (= (type |step#0_0@0|) DatatypeTypeType)) (= (type |path##0_0_0@0|) DatatypeTypeType)) (= (type $Heap@@111) (MapType0Type refType MapType1Type))) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type |##request#0_0_0@0|) DatatypeTypeType)) (= (type |target'##0_0_0@0|) DatatypeTypeType)) (= (type $_Frame@0) (MapType6Type refType boolType))) (= (type $Heap@0) (MapType0Type refType MapType1Type))) (= (type |path##0_1_0@0|) DatatypeTypeType)) (= (type |target'##0_1_0@0|) DatatypeTypeType)) (= (type $Heap@1) (MapType0Type refType MapType1Type))) (= (type |##original#0_2_0@0|) DatatypeTypeType)) (= (type |##newBufs#0_2_0@0|) DatatypeTypeType)) (= (type |compactedNode#0_2_0@0|) DatatypeTypeType)) (= (type |path##0_2_0@0|) DatatypeTypeType)) (= (type $Heap@2) (MapType0Type refType MapType1Type))) (= (type |v#0@@176|) DatatypeTypeType)) (= (type |lbl#0@@123|) DatatypeTypeType)) (= (type |step#0_1@0|) DatatypeTypeType)) (= (type StartFuel_Sequences._default.Range) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Range) LayerTypeType)) (= (type StartFuel_Sequences._default.ApplyOpaque) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.ApplyOpaque) LayerTypeType)) (= (type StartFuel_Sequences._default.remove) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.remove) LayerTypeType)) (= (type StartFuel_Sequences._default.RemoveOneValue) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.RemoveOneValue) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.insert) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.replace1with2) LayerTypeType)) (= (type StartFuel_Sequences._default.replace2with1) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.replace2with1) LayerTypeType)) (= (type StartFuel_Sequences._default.concat) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concat) LayerTypeType)) (= (type StartFuel_Sequences._default.concat3) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concat3) LayerTypeType)) (= (type StartFuel_Sequences._default.concatSeq) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concatSeq) LayerTypeType)) (= (type StartFuel_Sequences._default.IsPrefix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.IsPrefix) LayerTypeType)) (= (type StartFuel_Sequences._default.IsSuffix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.IsSuffix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndexIterate) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqIndex) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndex) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqOfLength) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqOfLength) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqIndexUpdate) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndexUpdate) LayerTypeType)) (= (type StartFuel_Sequences._default.Zip) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Zip) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Unzip) LayerTypeType)) (= (type StartFuel_Sequences._default.Flatten) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Flatten) LayerTypeType)) (= (type StartFuel_Sequences._default.seqMax) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.seqMax) LayerTypeType)) (= (type StartFuel_Sequences._default.fill) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.fill) LayerTypeType)) (= (type StartFuel_Maps._default.MapRemoveStrong) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemoveStrong) LayerTypeType)) (= (type StartFuel_Maps._default.MapRemove1Strong) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemove1Strong) LayerTypeType)) (= (type StartFuel_Maps._default.IMapInvert) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapInvert) LayerTypeType)) (= (type StartFuel_Maps._default.IMapRemove) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapRemove) LayerTypeType)) (= (type StartFuel_Maps._default.IMapRemove1) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapRemove1) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapDisjointUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnionPreferA) LayerTypeType)) (= (type StartFuel_Maps._default.MapUnionPreferB) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnionPreferB) LayerTypeType)) (= (type StartFuel_Maps._default.MapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnionPreferA) LayerTypeType)) (= (type StartFuel_Maps._default.IMapUnionPreferB) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnionPreferB) LayerTypeType)) (= (type StartFuel_Maps._default.IMapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnion) LayerTypeType)) (= (type StartFuel_Maps._default.MapDisjointUnion3) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapDisjointUnion3) LayerTypeType)) (= (type StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType)) (= (type StartFuelAssert_SeqComparison._default.lte) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.lte) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuel_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft) LayerTypeType)) (= (type StartFuelAssert_BoundedPivotsLib._default.CutoffForRight) LayerTypeType)) (= (type StartFuelAssert_DomainMod.Domain.SaneKeys) LayerTypeType)) (= (type StartFuel_PagedBetree.Path.ReplacedChildren) LayerTypeType)) (= (type StartFuelAssert_PagedBetree.Path.ReplacedChildren) LayerTypeType)) (= (type StartFuelAssert_PagedBetreeRefinement._default.INode) LayerTypeType)) (= (type StartFuel_PagedBetreeRefinement._default.MapApply) LayerTypeType)) (= (type StartFuelAssert_PagedBetreeRefinement._default.MapApply) LayerTypeType)) (= (type |step#0_0|) DatatypeTypeType)) (= (type |compactedNode#0_2_0|) DatatypeTypeType)))
(push 1)
(set-info :boogie-vc-id Impl$$PivotBetreeRefinement.__default.InvNext)
(set-option :timeout 0)
(set-option :rlimit 16350000)
(assert (not
 (=> (= (ControlFlow 0 0) 1316568) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 1316501) (- 0 1341924)) (=> (|PivotBetreeRefinement.__default.Inv#canCall| |v'#0@@115|) (or (PivotBetreeRefinement.__default.Inv |v'#0@@115|) (PivotBetree.Variables.WF |v'#0@@115|)))) (=> (=> (|PivotBetreeRefinement.__default.Inv#canCall| |v'#0@@115|) (or (PivotBetreeRefinement.__default.Inv |v'#0@@115|) (PivotBetree.Variables.WF |v'#0@@115|))) (=> (= (ControlFlow 0 1316501) (- 0 1341940)) (=> (|PivotBetreeRefinement.__default.Inv#canCall| |v'#0@@115|) (or (PivotBetreeRefinement.__default.Inv |v'#0@@115|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v'#0@@115|)) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Variables.root |v'#0@@115|)) DomainMod.__default.TotalDomain)))))))))
(let ((anon15_Else_correct  (=> (and (not (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (= (ControlFlow 0 81710) 1316501)) GeneratedUnifiedExit_correct)))
(let ((anon15_Then_correct  (=> (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|) (and (=> (= (ControlFlow 0 81708) (- 0 1334671)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> ($IsAlloc (PivotBetree.Step.path |step#0_0@0|) Tclass.PivotBetree.Path $Heap@@111) (and (=> (= (ControlFlow 0 81708) (- 0 1334693)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1334755)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1334855)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_2_0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_2_0|) (INTERNAL_lt_boogie |i#0_2_0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1458|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_0|)))
)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335003)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335118)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_2_1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_2_1|) (INTERNAL_lt_boogie |i#0_2_1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1459|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_1|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335307)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335409)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335496)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335560)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_2_2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_2_2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_2|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1462|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_2|))
))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335762)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335852)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1335980)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_2_3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_2_3|) (INTERNAL_lt_boogie |i#0_2_3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1464|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_3|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336156)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336299)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_2_4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_2_4|) (INTERNAL_lt_boogie |i#0_2_4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1465|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_4|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336516)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336646)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336761)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1336853)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_2_5| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_2_5|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_5|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_5|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_5|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_5|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_5|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1468|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_5|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_5|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_2_5|))
))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337083)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337136)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337343)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337679)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337868)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1337922)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_2_6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_2_6|) (INTERNAL_lt_boogie |i#0_2_6| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_6|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |1470|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_2_6|)))
)))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338028)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath (PivotBetree.Step.path |step#0_0@0|))))))) (=> (and (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|))) (and (=> (= (ControlFlow 0 81708) (- 0 1338084)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|) (=> (and (and (= |##original#0_2_0@0| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) ($IsAlloc |##original#0_2_0@0| Tclass.PivotBetree.BetreeNode $Heap@@111)) (and (= |##newBufs#0_2_0@0| (PivotBetree.Step.compactedBuffers |step#0_0@0|)) ($IsAlloc |##newBufs#0_2_0@0| Tclass.Buffers.BufferStack $Heap@@111))) (and (=> (= (ControlFlow 0 81708) (- 0 1338125)) (PivotBetree.BetreeNode.BetreeNode_q |##original#0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q |##original#0_2_0@0|) (and (=> (= (ControlFlow 0 81708) (- 0 1338131)) (=> (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers |##original#0_2_0@0|) |##newBufs#0_2_0@0|) (or (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |##original#0_2_0@0|) |##newBufs#0_2_0@0|) (forall ((|k#0_2_0| T@U) ) (!  (=> (= (type |k#0_2_0|) (SeqType BoxType)) (=> (and ($Is |k#0_2_0| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0_2_0|)) (|ValueMessage.Message#Equal| (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers |##original#0_2_0@0|) |k#0_2_0|) (Buffers.BufferStack.Query |##newBufs#0_2_0@0| |k#0_2_0|))))
 :qid |Buffersidfy.65:14|
 :skolemid |1473|
 :pattern ( (Buffers.BufferStack.Query |##newBufs#0_2_0@0| |k#0_2_0|))
 :pattern ( (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers |##original#0_2_0@0|) |k#0_2_0|))
 :pattern ( (Buffers.__default.AnyKey |k#0_2_0|))
))))) (=> (and (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |##original#0_2_0@0|) |##newBufs#0_2_0@0|) (|PivotBetree.__default.CompactedNode#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.compactedBuffers |step#0_0@0|))) (=> (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|)) (|PivotBetree.__default.CompactedNode#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.compactedBuffers |step#0_0@0|))) (= |compactedNode#0_2_0@0| (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.compactedBuffers |step#0_0@0|)))) (and (=> (= (ControlFlow 0 81708) (- 0 1338262)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> (= |path##0_2_0@0| (PivotBetree.Step.path |step#0_0@0|)) (and (=> (= (ControlFlow 0 81708) (- 0 1338290)) (forall (($o@@164 T@U) ($f@@86 T@U) ) (! (let ((alpha@@93 (FieldTypeInv0 (type $f@@86))))
 (=> (and (and (= (type $o@@164) refType) (= (type $f@@86) (FieldType alpha@@93))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@164 $f@@86))))
 :qid |PivotBetreeRefinementbroken1idfy.104:30|
 :skolemid |1475|
 :no-pattern (type $o@@164)
 :no-pattern (type $f@@86)
 :no-pattern (U_2_int $o@@164)
 :no-pattern (U_2_bool $o@@164)
 :no-pattern (U_2_int $f@@86)
 :no-pattern (U_2_bool $f@@86)
))) (=> (forall (($o@@165 T@U) ($f@@87 T@U) ) (! (let ((alpha@@94 (FieldTypeInv0 (type $f@@87))))
 (=> (and (and (= (type $o@@165) refType) (= (type $f@@87) (FieldType alpha@@94))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@165 $f@@87))))
 :qid |PivotBetreeRefinementbroken1idfy.104:30|
 :skolemid |1475|
 :no-pattern (type $o@@165)
 :no-pattern (type $f@@87)
 :no-pattern (U_2_int $o@@165)
 :no-pattern (U_2_bool $o@@165)
 :no-pattern (U_2_int $f@@87)
 :no-pattern (U_2_bool $f@@87)
)) (and (=> (= (ControlFlow 0 81708) (- 0 1338308)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338358)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338438)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#17| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17|) (INTERNAL_lt_boogie |i#17| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#17|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#17|)))
)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#17@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17@@0|) (INTERNAL_lt_boogie |i#17@@0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#17@@0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#17@@0|)))
))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338562)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338655)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#18| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18|) (INTERNAL_lt_boogie |i#18| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#18@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18@@0|) (INTERNAL_lt_boogie |i#18@@0| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18@@0|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18@@0|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#18@@0|)))
))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338814)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 2))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 2)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338896)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1338965)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339017)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#19| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#19|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#19|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#19|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#19|))
))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#19@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19@@0|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#19@@0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19@@0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19@@0|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19@@0|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#19@@0|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#19@@0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#19@@0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#19@@0|))
)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339187)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339257)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339357)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#20| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20|) (INTERNAL_lt_boogie |i#20| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#20|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#20|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#20@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20@@0|) (INTERNAL_lt_boogie |i#20@@0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#20@@0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#20@@0|)))
))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339501)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339614)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#21| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21|) (INTERNAL_lt_boogie |i#21| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21|)))
)))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (forall ((|i#21@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21@@0|) (INTERNAL_lt_boogie |i#21@@0| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21@@0|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21@@0|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) |i#21@@0|)))
))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339793)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 2))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 2)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339895)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1339984)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340056)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#22| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#22|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#22|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#22|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#22|))
))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#22@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22@@0|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#22@@0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22@@0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22@@0|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22@@0|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#22@@0|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_2_0@0|) |i#22@@0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#22@@0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_2_0@0|) |i#22@@0|))
)))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340246)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340285)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340454)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1))))))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340730)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_2_0@0|) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.Path.key |path##0_2_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_2_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_2_0@0|))) 1))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340881)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_2_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_2_0@0|))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1340923)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#23| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23|) (INTERNAL_lt_boogie |i#23| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#23|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#23|)))
)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_2_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_2_0@0|)) (forall ((|i#23@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23@@0|) (INTERNAL_lt_boogie |i#23@@0| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#23@@0|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_2_0@0|)) |i#23@@0|)))
))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341013)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_2_0@0|)))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_2_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_2_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_2_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_2_0@0|))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341047)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341087)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341149)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (forall ((|i#24| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24|) (INTERNAL_lt_boogie |i#24| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#24|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#24|)))
)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (forall ((|i#24@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24@@0|) (INTERNAL_lt_boogie |i#24@@0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#24@@0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#24@@0|)))
))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341251)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341324)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (forall ((|i#25| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25|) (INTERNAL_lt_boogie |i#25| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (forall ((|i#25@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25@@0|) (INTERNAL_lt_boogie |i#25@@0| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25@@0|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25@@0|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|) |i#25@@0|)))
))))))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341455)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) 2))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)) 2)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341519)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |compactedNode#0_2_0@0|)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341572)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|)))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341614)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (forall ((|i#26| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |compactedNode#0_2_0@0| |i#26|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26|))) (PivotBetree.BetreeNode.DomainRoutedToChild |compactedNode#0_2_0@0| |i#26|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |compactedNode#0_2_0@0| |i#26|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |compactedNode#0_2_0@0| |i#26|))
))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |compactedNode#0_2_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |compactedNode#0_2_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|) (forall ((|i#26@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26@@0|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |compactedNode#0_2_0@0| |i#26@@0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26@@0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26@@0|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26@@0|))) (PivotBetree.BetreeNode.DomainRoutedToChild |compactedNode#0_2_0@0| |i#26@@0|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |compactedNode#0_2_0@0| |i#26@@0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |compactedNode#0_2_0@0|) |i#26@@0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |compactedNode#0_2_0@0| |i#26@@0|))
)))))))))) (and (=> (= (ControlFlow 0 81708) (- 0 1341754)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|)))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |compactedNode#0_2_0@0|))) (and (=> (= (ControlFlow 0 81708) (- 0 1341769)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |compactedNode#0_2_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_2_0@0|)))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_2_0@0| |compactedNode#0_2_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |compactedNode#0_2_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_2_0@0|))))) (=> (and (and (and ($IsGoodHeap $Heap@2) ($IsHeapAnchor $Heap@2)) (and (|PivotBetree.Path.Substitute#canCall| |path##0_2_0@0| |compactedNode#0_2_0@0|) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|)) (and (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|)) (and (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|))) (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.Substitute ($LS $LZ) |path##0_2_0@0| |compactedNode#0_2_0@0|))))))) (and (= $Heap@@111 $Heap@2) (= (ControlFlow 0 81708) 1316501)))) GeneratedUnifiedExit_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(let ((anon14_Else_correct  (=> (not (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (and (=> (= (ControlFlow 0 81706) 81708) anon15_Then_correct) (=> (= (ControlFlow 0 81706) 81710) anon15_Else_correct)))))
(let ((anon14_Then_correct  (=> (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|) (and (=> (= (ControlFlow 0 81699) (- 0 1325801)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> (= |path##0_1_0@0| (PivotBetree.Step.path |step#0_0@0|)) (and (=> (= (ControlFlow 0 81699) (- 0 1325825)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> ($IsAlloc (PivotBetree.Step.path |step#0_0@0|) Tclass.PivotBetree.Path $Heap@@111) (and (=> (= (ControlFlow 0 81699) (- 0 1325847)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1325909)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326009)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_0|) (INTERNAL_lt_boogie |i#0_1_0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1434|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_0|)))
)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326157)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326272)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_1_1|) (INTERNAL_lt_boogie |i#0_1_1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1435|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_1|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326461)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326563)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326650)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326714)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_1_2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_2|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1438|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_2|))
))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1326916)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327006)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327134)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_3|) (INTERNAL_lt_boogie |i#0_1_3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1440|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_3|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327310)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327453)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_1_4|) (INTERNAL_lt_boogie |i#0_1_4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1441|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_4|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327670)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327800)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1327915)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1328007)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_1_5| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_5|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_5|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_5|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_5|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_5|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_5|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1444|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_5|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_5|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_5|))
))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1328237)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1328290)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1328497)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1328833)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329022)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329076)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_1_6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_6|) (INTERNAL_lt_boogie |i#0_1_6| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_6|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |1446|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_6|)))
)))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329182)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath (PivotBetree.Step.path |step#0_0@0|))))))) (=> (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|)) ($IsAlloc (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) Tclass.PivotBetree.BetreeNode $Heap@@111)) (and (=> (= (ControlFlow 0 81699) (- 0 1329253)) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (=> (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|) (=> (and (= |##childIdx#0_1_0@0| (PivotBetree.Step.childIdx |step#0_0@0|)) ($IsAlloc (int_2_U |##childIdx#0_1_0@0|) Tclass._System.nat $Heap@@111)) (and (=> (= (ControlFlow 0 81699) (- 0 1329272)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329360)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329504)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_7| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_7|) (INTERNAL_lt_boogie |i#0_1_7| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_7|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1448|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_7|)))
)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329708)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1329869)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_1_8| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_1_8|) (INTERNAL_lt_boogie |i#0_1_8| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_8|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_8|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1450|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_8|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330128)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330274)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330403)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330495)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_1_9| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_1_9|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_9|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_9|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_9|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_9|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_9|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1454|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_9|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) |i#0_1_9|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)) |i#0_1_9|))
))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330779)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330820)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1330889)) (=> (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (=> (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (or (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (INTERNAL_lt_boogie |##childIdx#0_1_0@0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|)))))))))) (=> (and (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) |##childIdx#0_1_0@0|) (|PivotBetree.BetreeNode.Flush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.childIdx |step#0_0@0|))) (=> (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|)) (|PivotBetree.BetreeNode.Flush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.childIdx |step#0_0@0|))) (= |target'##0_1_0@0| (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.childIdx |step#0_0@0|)))) (and (=> (= (ControlFlow 0 81699) (- 0 1331030)) (forall (($o@@166 T@U) ($f@@88 T@U) ) (! (let ((alpha@@95 (FieldTypeInv0 (type $f@@88))))
 (=> (and (and (= (type $o@@166) refType) (= (type $f@@88) (FieldType alpha@@95))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@166 $f@@88))))
 :qid |PivotBetreeRefinementbroken1idfy.101:30|
 :skolemid |1457|
 :no-pattern (type $o@@166)
 :no-pattern (type $f@@88)
 :no-pattern (U_2_int $o@@166)
 :no-pattern (U_2_bool $o@@166)
 :no-pattern (U_2_int $f@@88)
 :no-pattern (U_2_bool $f@@88)
))) (=> (forall (($o@@167 T@U) ($f@@89 T@U) ) (! (let ((alpha@@96 (FieldTypeInv0 (type $f@@89))))
 (=> (and (and (= (type $o@@167) refType) (= (type $f@@89) (FieldType alpha@@96))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@167 $f@@89))))
 :qid |PivotBetreeRefinementbroken1idfy.101:30|
 :skolemid |1457|
 :no-pattern (type $o@@167)
 :no-pattern (type $f@@89)
 :no-pattern (U_2_int $o@@167)
 :no-pattern (U_2_bool $o@@167)
 :no-pattern (U_2_int $f@@89)
 :no-pattern (U_2_bool $f@@89)
)) (and (=> (= (ControlFlow 0 81699) (- 0 1331048)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331098)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331178)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#17@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17@@1|) (INTERNAL_lt_boogie |i#17@@1| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#17@@1|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#17@@1|)))
)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#17@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17@@2|) (INTERNAL_lt_boogie |i#17@@2| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#17@@2|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#17@@2|)))
))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331302)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331395)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#18@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18@@1|) (INTERNAL_lt_boogie |i#18@@1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@1|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#18@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18@@2|) (INTERNAL_lt_boogie |i#18@@2| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@2|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@2|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#18@@2|)))
))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331554)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 2))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 2)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331636)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331705)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331757)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#19@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19@@1|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@1|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@1|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@1|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@1|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@1|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@1|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@1|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@1|))
))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#19@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19@@2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@2|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#19@@2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#19@@2|))
)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331927)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1331997)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332097)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#20@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20@@1|) (INTERNAL_lt_boogie |i#20@@1| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#20@@1|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#20@@1|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#20@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20@@2|) (INTERNAL_lt_boogie |i#20@@2| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#20@@2|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#20@@2|)))
))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332241)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332354)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#21@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21@@1|) (INTERNAL_lt_boogie |i#21@@1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@1|)))
)))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (forall ((|i#21@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21@@2|) (INTERNAL_lt_boogie |i#21@@2| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@2|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@2|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) |i#21@@2|)))
))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332533)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 2))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 2)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332635)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332724)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332796)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#22@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22@@1|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@1|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@1|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@1|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@1|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@1|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@1|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@1|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@1|))
))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#22@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22@@2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@2|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#22@@2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_1_0@0|) |i#22@@2|))
)))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1332986)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333025)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333194)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1))))))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333470)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_1_0@0|) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.Path.key |path##0_1_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_1_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_1_0@0|))) 1))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333621)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_1_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_1_0@0|))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333663)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#23@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23@@1|) (INTERNAL_lt_boogie |i#23@@1| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#23@@1|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#23@@1|)))
)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_1_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_1_0@0|)) (forall ((|i#23@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23@@2|) (INTERNAL_lt_boogie |i#23@@2| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#23@@2|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_1_0@0|)) |i#23@@2|)))
))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333753)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_1_0@0|)))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_1_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_1_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_1_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_1_0@0|))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333787)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333827)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333889)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (forall ((|i#24@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24@@1|) (INTERNAL_lt_boogie |i#24@@1| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#24@@1|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#24@@1|)))
)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (forall ((|i#24@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24@@2|) (INTERNAL_lt_boogie |i#24@@2| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#24@@2|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#24@@2|)))
))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1333991)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334064)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (forall ((|i#25@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25@@1|) (INTERNAL_lt_boogie |i#25@@1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@1|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (forall ((|i#25@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25@@2|) (INTERNAL_lt_boogie |i#25@@2| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@2|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@2|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|) |i#25@@2|)))
))))))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334195)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) 2))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)) 2)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334259)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |target'##0_1_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |target'##0_1_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_1_0@0|)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334312)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |target'##0_1_0@0|)))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |target'##0_1_0@0|))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334354)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (forall ((|i#26@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26@@1|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |target'##0_1_0@0| |i#26@@1|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@1|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@1|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@1|))) (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_1_0@0| |i#26@@1|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_1_0@0| |i#26@@1|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@1|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |target'##0_1_0@0| |i#26@@1|))
))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |target'##0_1_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |target'##0_1_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|) (forall ((|i#26@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26@@2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |target'##0_1_0@0| |i#26@@2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@2|))) (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_1_0@0| |i#26@@2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_1_0@0| |i#26@@2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_1_0@0|) |i#26@@2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |target'##0_1_0@0| |i#26@@2|))
)))))))))) (and (=> (= (ControlFlow 0 81699) (- 0 1334494)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|)))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |target'##0_1_0@0|))) (and (=> (= (ControlFlow 0 81699) (- 0 1334509)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |target'##0_1_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_1_0@0|)))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_1_0@0| |target'##0_1_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |target'##0_1_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_1_0@0|))))) (=> (and (and (and ($IsGoodHeap $Heap@1) ($IsHeapAnchor $Heap@1)) (and (|PivotBetree.Path.Substitute#canCall| |path##0_1_0@0| |target'##0_1_0@0|) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|)) (and (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|)) (and (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|))) (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.Substitute ($LS $LZ) |path##0_1_0@0| |target'##0_1_0@0|))))))) (and (= $Heap@@111 $Heap@1) (= (ControlFlow 0 81699) 1316501)))) GeneratedUnifiedExit_correct))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(let ((anon13_Else_correct  (=> (not (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|)) (and (=> (= (ControlFlow 0 81697) 81699) anon14_Then_correct) (=> (= (ControlFlow 0 81697) 81706) anon14_Else_correct)))))
(let ((anon13_Then_correct  (=> (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (and (=> (= (ControlFlow 0 81690) (- 0 1318590)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> (= |path##0_0_0@0| (PivotBetree.Step.path |step#0_0@0|)) (and (=> (= (ControlFlow 0 81690) (- 0 1318614)) (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|))) (=> (or (or (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (PivotBetree.Step.InternalFlushStep_q |step#0_0@0|)) (PivotBetree.Step.InternalCompactStep_q |step#0_0@0|)) (=> ($IsAlloc (PivotBetree.Step.path |step#0_0@0|) Tclass.PivotBetree.Path $Heap@@111) (and (=> (= (ControlFlow 0 81690) (- 0 1318636)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1318698)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1318798)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_0_0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_0_0|) (INTERNAL_lt_boogie |i#0_0_0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1414|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_0|)))
)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1318946)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319061)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_0_1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_0_1|) (INTERNAL_lt_boogie |i#0_0_1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1415|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_1|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319250)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319352)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319439)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319503)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_0_2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_0_2|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_2|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_2|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_2|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_2|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_2|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1418|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_2|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_2|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_2|))
))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319705)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319795)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1319923)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_0_3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_0_3|) (INTERNAL_lt_boogie |i#0_0_3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |1420|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_3|)))
)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320099)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320242)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (forall ((|i#0_0_4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0_0_4|) (INTERNAL_lt_boogie |i#0_0_4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |1421|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_4|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320459)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 2))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320589)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320704)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1320796)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_0_5| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_0_5|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_5|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_5|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_5|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_5|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_5|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |1424|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_5|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_5|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) |i#0_0_5|))
))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321026)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321079)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321286)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321622)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Step.path |step#0_0@0|))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))) 1)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321811)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321865)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) (forall ((|i#0_0_6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0_0_6|) (INTERNAL_lt_boogie |i#0_0_6| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_6|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |1426|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Step.path |step#0_0@0|))) |i#0_0_6|)))
)))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1321971)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0_0@0|)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Step.path |step#0_0@0|))) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath (PivotBetree.Step.path |step#0_0@0|))))))) (=> (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (=> (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|)) ($IsAlloc (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) Tclass.PivotBetree.BetreeNode $Heap@@111)) (and (=> (= (ControlFlow 0 81690) (- 0 1322042)) (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|)) (=> (PivotBetree.Step.InternalSplitStep_q |step#0_0@0|) (=> (and (= |##request#0_0_0@0| (PivotBetree.Step.request |step#0_0@0|)) ($IsAlloc |##request#0_0_0@0| Tclass.SplitRequestMod.SplitRequest $Heap@@111)) (and (=> (= (ControlFlow 0 81690) (- 0 1322061)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@111 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Step.path |step#0_0@0|))) ($Box |##request#0_0_0@0|))) (=> (and (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@111 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|))) ($Box |##request#0_0_0@0|)) (|PivotBetree.BetreeNode.SplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.request |step#0_0@0|))) (=> (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0_0@0|)) (|PivotBetree.BetreeNode.SplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.request |step#0_0@0|))) (= |target'##0_0_0@0| (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0_0@0|)) (PivotBetree.Step.request |step#0_0@0|)))) (and (=> (= (ControlFlow 0 81690) (- 0 1322162)) (forall (($o@@168 T@U) ($f@@90 T@U) ) (! (let ((alpha@@97 (FieldTypeInv0 (type $f@@90))))
 (=> (and (and (= (type $o@@168) refType) (= (type $f@@90) (FieldType alpha@@97))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@168 $f@@90))))
 :qid |PivotBetreeRefinementbroken1idfy.99:30|
 :skolemid |1433|
 :no-pattern (type $o@@168)
 :no-pattern (type $f@@90)
 :no-pattern (U_2_int $o@@168)
 :no-pattern (U_2_bool $o@@168)
 :no-pattern (U_2_int $f@@90)
 :no-pattern (U_2_bool $f@@90)
))) (=> (forall (($o@@169 T@U) ($f@@91 T@U) ) (! (let ((alpha@@98 (FieldTypeInv0 (type $f@@91))))
 (=> (and (and (= (type $o@@169) refType) (= (type $f@@91) (FieldType alpha@@98))) false) (U_2_bool (MapType6Select $_Frame@0 $o@@169 $f@@91))))
 :qid |PivotBetreeRefinementbroken1idfy.99:30|
 :skolemid |1433|
 :no-pattern (type $o@@169)
 :no-pattern (type $f@@91)
 :no-pattern (U_2_int $o@@169)
 :no-pattern (U_2_bool $o@@169)
 :no-pattern (U_2_int $f@@91)
 :no-pattern (U_2_bool $f@@91)
)) (and (=> (= (ControlFlow 0 81690) (- 0 1322180)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322230)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322310)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#17@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17@@3|) (INTERNAL_lt_boogie |i#17@@3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#17@@3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#17@@3|)))
)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#17@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#17@@4|) (INTERNAL_lt_boogie |i#17@@4| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#17@@4|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#17@@4|)))
))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322434)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322527)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#18@@3| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18@@3|) (INTERNAL_lt_boogie |i#18@@3| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@3|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@3|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@3|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#18@@4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#18@@4|) (INTERNAL_lt_boogie |i#18@@4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#18@@4|)))
))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322686)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 2))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 2)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322768)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322837)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1322889)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#19@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19@@3|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@3|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@3|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@3|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@3|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@3|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@3|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@3|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@3|))
))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#19@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19@@4|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@4|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@4|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@4|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@4|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@4|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@4|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#19@@4|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#19@@4|))
)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323059)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323129)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323229)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#20@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20@@3|) (INTERNAL_lt_boogie |i#20@@3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#20@@3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#20@@3|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#20@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#20@@4|) (INTERNAL_lt_boogie |i#20@@4| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#20@@4|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2224|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#20@@4|)))
))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323373)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (U_2_bool (Lit (bool_2_U true)))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323486)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#21@@3| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21@@3|) (INTERNAL_lt_boogie |i#21@@3| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@3|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@3|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@3|)))
)))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (forall ((|i#21@@4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#21@@4|) (INTERNAL_lt_boogie |i#21@@4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) |i#21@@4|)))
))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323665)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 2))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 2)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323767)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323856)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1323928)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#22@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22@@3|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@3|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@3|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@3|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@3|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@3|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@3|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@3|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@3|))
))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node |path##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#22@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22@@4|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@4|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@4|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@4|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@4|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@4|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2228|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@4|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#22@@4|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node |path##0_0_0@0|) |i#22@@4|))
)))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324118)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324157)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324326)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))))))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1))))))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324602)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))))))))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node |path##0_0_0@0|) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.Path.key |path##0_0_0@0|)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key |path##0_0_0@0|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node |path##0_0_0@0|))) 1))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324753)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_0_0@0|)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node |path##0_0_0@0|))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324795)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#23@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23@@3|) (INTERNAL_lt_boogie |i#23@@3| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#23@@3|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#23@@3|)))
)))))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node |path##0_0_0@0|)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node |path##0_0_0@0|)) (forall ((|i#23@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#23@@4|) (INTERNAL_lt_boogie |i#23@@4| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#23@@4|))))
 :qid |PivotBetreeidfy.99:18|
 :skolemid |2230|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node |path##0_0_0@0|)) |i#23@@4|)))
))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324885)) (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_0_0@0|)))))) (=> (=> (|PivotBetree.Path.Valid#canCall| |path##0_0_0@0|) (or (PivotBetree.Path.Valid ($LS $LZ) |path##0_0_0@0|) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth |path##0_0_0@0|)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath |path##0_0_0@0|))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324919)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (U_2_bool (Lit (bool_2_U true)))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (U_2_bool (Lit (bool_2_U true))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1324959)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325021)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (forall ((|i#24@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24@@3|) (INTERNAL_lt_boogie |i#24@@3| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#24@@3|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#24@@3|)))
)))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (forall ((|i#24@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24@@4|) (INTERNAL_lt_boogie |i#24@@4| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#24@@4|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2232|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#24@@4|)))
))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325123)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true))))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (U_2_bool (Lit (bool_2_U true)))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325196)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (forall ((|i#25@@3| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25@@3|) (INTERNAL_lt_boogie |i#25@@3| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@3|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@3|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@3|)))
)))))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (forall ((|i#25@@4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#25@@4|) (INTERNAL_lt_boogie |i#25@@4| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@4|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@4|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2233|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|) |i#25@@4|)))
))))))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325327)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) 2))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)) 2)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325391)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |target'##0_0_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LocalStructure |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |target'##0_0_0@0|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |target'##0_0_0@0|)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325444)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |target'##0_0_0@0|)))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |target'##0_0_0@0|))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325486)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (forall ((|i#26@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26@@3|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |target'##0_0_0@0| |i#26@@3|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@3|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@3|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@3|))) (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_0_0@0| |i#26@@3|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_0_0@0| |i#26@@3|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@3|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |target'##0_0_0@0| |i#26@@3|))
))))))))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.WF#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |target'##0_0_0@0|) (or (PivotBetree.BetreeNode.LinkedChildren |target'##0_0_0@0|) (=> (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|) (forall ((|i#26@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26@@4|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |target'##0_0_0@0| |i#26@@4|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@4|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@4|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@4|))) (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_0_0@0| |i#26@@4|)))
 :qid |PivotBetreeidfy.66:17|
 :skolemid |2236|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |target'##0_0_0@0| |i#26@@4|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |target'##0_0_0@0|) |i#26@@4|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |target'##0_0_0@0| |i#26@@4|))
)))))))))) (and (=> (= (ControlFlow 0 81690) (- 0 1325626)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|)))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (PivotBetree.BetreeNode.BetreeNode_q |target'##0_0_0@0|))) (and (=> (= (ControlFlow 0 81690) (- 0 1325641)) (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |target'##0_0_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_0_0@0|)))))) (=> (=> (|PivotBetree.Path.ValidReplacement#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (or (PivotBetree.Path.ValidReplacement |path##0_0_0@0| |target'##0_0_0@0|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |target'##0_0_0@0|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) |path##0_0_0@0|))))) (=> (and (and (and ($IsGoodHeap $Heap@0) ($IsHeapAnchor $Heap@0)) (and (|PivotBetree.Path.Substitute#canCall| |path##0_0_0@0| |target'##0_0_0@0|) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|)))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|)) (and (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|)) (and (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|))) (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.Substitute ($LS $LZ) |path##0_0_0@0| |target'##0_0_0@0|))))))) (and (= $Heap@@111 $Heap@0) (= (ControlFlow 0 81690) 1316501)))) GeneratedUnifiedExit_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(let ((anon3_correct  (and (=> (= (ControlFlow 0 81688) (- 0 1318392)) (or (and ($Is (Lit |#PivotBetree.Step.InternalNoOpStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalNoOpStep|))) (or (and ($Is (Lit |#PivotBetree.Step.InternalFlushMemtableStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalFlushMemtableStep|))) (or (and ($Is (Lit |#PivotBetree.Step.InternalGrowStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalGrowStep|))) (or (and ($Is (Lit |#PivotBetree.Step.FreezeAsStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.FreezeAsStep|))) (or (and ($Is (Lit |#PivotBetree.Step.QueryEndLsnStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.QueryEndLsnStep|))) (or (and ($Is (Lit |#PivotBetree.Step.PutStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.PutStep|))) (exists ((|$as#step0_0#0_0| T@U) ) (!  (and (= (type |$as#step0_0#0_0|) DatatypeTypeType) (and ($Is |$as#step0_0#0_0| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| |$as#step0_0#0_0|)))
 :qid |PivotBetreeRefinementbroken1idfy.97:11|
 :skolemid |1412|
 :no-pattern (type |$as#step0_0#0_0|)
 :no-pattern (U_2_int |$as#step0_0#0_0|)
 :no-pattern (U_2_bool |$as#step0_0#0_0|)
))))))))) (=> (or (and ($Is (Lit |#PivotBetree.Step.InternalNoOpStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalNoOpStep|))) (or (and ($Is (Lit |#PivotBetree.Step.InternalFlushMemtableStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalFlushMemtableStep|))) (or (and ($Is (Lit |#PivotBetree.Step.InternalGrowStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.InternalGrowStep|))) (or (and ($Is (Lit |#PivotBetree.Step.FreezeAsStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.FreezeAsStep|))) (or (and ($Is (Lit |#PivotBetree.Step.QueryEndLsnStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.QueryEndLsnStep|))) (or (and ($Is (Lit |#PivotBetree.Step.PutStep|) Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| (Lit |#PivotBetree.Step.PutStep|))) (exists ((|$as#step0_0#0_0@@0| T@U) ) (!  (and (= (type |$as#step0_0#0_0@@0|) DatatypeTypeType) (and ($Is |$as#step0_0#0_0@@0| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| |$as#step0_0#0_0@@0|)))
 :qid |PivotBetreeRefinementbroken1idfy.97:11|
 :skolemid |1412|
 :no-pattern (type |$as#step0_0#0_0@@0|)
 :no-pattern (U_2_int |$as#step0_0#0_0@@0|)
 :no-pattern (U_2_bool |$as#step0_0#0_0@@0|)
)))))))) (=> (and (and ($Is |step#0_0@0| Tclass.PivotBetree.Step) ($IsAlloc |step#0_0@0| Tclass.PivotBetree.Step $Heap@@111)) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| |step#0_0@0|)) (and (=> (= (ControlFlow 0 81688) 81690) anon13_Then_correct) (=> (= (ControlFlow 0 81688) 81697) anon13_Else_correct)))))))
(let ((anon12_Else_correct  (=> (and (not (and ($Is |step#0_1@0| Tclass.PivotBetree.Step) ($IsAlloc |step#0_1@0| Tclass.PivotBetree.Step $Heap@@111))) (= (ControlFlow 0 81681) 81688)) anon3_correct)))
(let ((anon12_Then_correct  (=> (and (and (and (and ($Is |step#0_1@0| Tclass.PivotBetree.Step) ($IsAlloc |step#0_1@0| Tclass.PivotBetree.Step $Heap@@111)) ($IsAlloc |v#0@@176| Tclass.PivotBetree.Variables $Heap@@111)) (and ($IsAlloc |v'#0@@115| Tclass.PivotBetree.Variables $Heap@@111) ($IsAlloc |lbl#0@@123| Tclass.PivotBetree.TransitionLabel $Heap@@111))) (and (and ($IsAlloc |step#0_1@0| Tclass.PivotBetree.Step $Heap@@111) (|PivotBetree.__default.NextStep#canCall| |v#0@@176| |v'#0@@115| |lbl#0@@123| |step#0_1@0|)) (and (|PivotBetree.__default.NextStep#canCall| |v#0@@176| |v'#0@@115| |lbl#0@@123| |step#0_1@0|) (= (ControlFlow 0 81679) 81688)))) anon3_correct)))
(let ((anon11_Then_correct  (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v'#0@@115|)) (and (=> (= (ControlFlow 0 81677) 81679) anon12_Then_correct) (=> (= (ControlFlow 0 81677) 81681) anon12_Else_correct)))))
(let ((anon11_Else_correct  (=> (and (not (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v'#0@@115|))) (= (ControlFlow 0 81712) 1316501)) GeneratedUnifiedExit_correct)))
(let ((anon0_correct  (=> (= (AsFuelBottom StartFuel_Sequences._default.NoDupes) StartFuel_Sequences._default.NoDupes) (=> (and (= (AsFuelBottom StartFuelAssert_Sequences._default.NoDupes) StartFuelAssert_Sequences._default.NoDupes) (= (AsFuelBottom StartFuel_Sequences._default.Range) StartFuel_Sequences._default.Range)) (=> (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.Range) StartFuelAssert_Sequences._default.Range) (= (AsFuelBottom StartFuel_Sequences._default.ApplyOpaque) StartFuel_Sequences._default.ApplyOpaque)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.ApplyOpaque) StartFuelAssert_Sequences._default.ApplyOpaque) (= (AsFuelBottom StartFuel_Sequences._default.remove) StartFuel_Sequences._default.remove))) (=> (and (and (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.remove) StartFuelAssert_Sequences._default.remove) (= (AsFuelBottom StartFuel_Sequences._default.RemoveOneValue) StartFuel_Sequences._default.RemoveOneValue)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.RemoveOneValue) StartFuelAssert_Sequences._default.RemoveOneValue) (= (AsFuelBottom StartFuel_Sequences._default.insert) StartFuel_Sequences._default.insert))) (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.insert) StartFuelAssert_Sequences._default.insert) (= (AsFuelBottom StartFuel_Sequences._default.replace1with2) StartFuel_Sequences._default.replace1with2)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.replace1with2) StartFuelAssert_Sequences._default.replace1with2) (= (AsFuelBottom StartFuel_Sequences._default.replace2with1) StartFuel_Sequences._default.replace2with1)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.replace2with1) StartFuelAssert_Sequences._default.replace2with1) (= (AsFuelBottom StartFuel_Sequences._default.concat) StartFuel_Sequences._default.concat)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.concat) StartFuelAssert_Sequences._default.concat) (= (AsFuelBottom StartFuel_Sequences._default.concat3) StartFuel_Sequences._default.concat3))) (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.concat3) StartFuelAssert_Sequences._default.concat3) (= (AsFuelBottom StartFuel_Sequences._default.concatSeq) StartFuel_Sequences._default.concatSeq)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.concatSeq) StartFuelAssert_Sequences._default.concatSeq) (= (AsFuelBottom StartFuel_Sequences._default.IsPrefix) StartFuel_Sequences._default.IsPrefix))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.IsPrefix) StartFuelAssert_Sequences._default.IsPrefix) (= (AsFuelBottom StartFuel_Sequences._default.IsSuffix) StartFuel_Sequences._default.IsSuffix)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.IsSuffix) StartFuelAssert_Sequences._default.IsSuffix) (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexIterate) StartFuel_Sequences._default.SeqIndexIterate))) (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexIterate) StartFuelAssert_Sequences._default.SeqIndexIterate) (= (AsFuelBottom StartFuel_Sequences._default.SeqIndex) StartFuel_Sequences._default.SeqIndex)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndex) StartFuelAssert_Sequences._default.SeqIndex) (= (AsFuelBottom StartFuel_Sequences._default.SeqOfLength) StartFuel_Sequences._default.SeqOfLength)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqOfLength) StartFuelAssert_Sequences._default.SeqOfLength) (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexUpdate) StartFuel_Sequences._default.SeqIndexUpdate)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexUpdate) StartFuelAssert_Sequences._default.SeqIndexUpdate) (= (AsFuelBottom StartFuel_Sequences._default.Zip) StartFuel_Sequences._default.Zip))) (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.Zip) StartFuelAssert_Sequences._default.Zip) (= (AsFuelBottom StartFuel_Sequences._default.Unzip) StartFuel_Sequences._default.Unzip)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.Unzip) StartFuelAssert_Sequences._default.Unzip) (= (AsFuelBottom StartFuel_Sequences._default.FlattenShape) StartFuel_Sequences._default.FlattenShape)))))) (=> (and (and (and (and (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenShape) StartFuelAssert_Sequences._default.FlattenShape) (= (AsFuelBottom StartFuel_Sequences._default.FlattenLength) StartFuel_Sequences._default.FlattenLength)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenLength) StartFuelAssert_Sequences._default.FlattenLength) (= (AsFuelBottom StartFuel_Sequences._default.Flatten) StartFuel_Sequences._default.Flatten))) (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.Flatten) StartFuelAssert_Sequences._default.Flatten) (= (AsFuelBottom StartFuel_Sequences._default.seqMax) StartFuel_Sequences._default.seqMax)) (and (= (AsFuelBottom StartFuelAssert_Sequences._default.seqMax) StartFuelAssert_Sequences._default.seqMax) (= (AsFuelBottom StartFuel_Sequences._default.fill) StartFuel_Sequences._default.fill)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Sequences._default.fill) StartFuelAssert_Sequences._default.fill) (= (AsFuelBottom StartFuel_MapRemove_s._default.MapRemove1) StartFuel_MapRemove_s._default.MapRemove1)) (and (= (AsFuelBottom StartFuelAssert_MapRemove_s._default.MapRemove1) StartFuelAssert_MapRemove_s._default.MapRemove1) (= (AsFuelBottom StartFuel_Maps._default.MapRemove) StartFuel_Maps._default.MapRemove))) (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove) StartFuelAssert_Maps._default.MapRemove) (= (AsFuelBottom StartFuel_Maps._default.MapRemoveStrong) StartFuel_Maps._default.MapRemoveStrong)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemoveStrong) StartFuelAssert_Maps._default.MapRemoveStrong) (= (AsFuelBottom StartFuel_Maps._default.MapRemove1Strong) StartFuel_Maps._default.MapRemove1Strong))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove1Strong) StartFuelAssert_Maps._default.MapRemove1Strong) (= (AsFuelBottom StartFuel_Maps._default.IMapInvert) StartFuel_Maps._default.IMapInvert)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapInvert) StartFuelAssert_Maps._default.IMapInvert) (= (AsFuelBottom StartFuel_Maps._default.IMapRemove) StartFuel_Maps._default.IMapRemove))) (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove) StartFuelAssert_Maps._default.IMapRemove) (= (AsFuelBottom StartFuel_Maps._default.IMapRemove1) StartFuel_Maps._default.IMapRemove1)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove1) StartFuelAssert_Maps._default.IMapRemove1) (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion) StartFuel_Maps._default.MapDisjointUnion)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion) StartFuelAssert_Maps._default.MapDisjointUnion) (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferA) StartFuel_Maps._default.MapUnionPreferA)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferA) StartFuelAssert_Maps._default.MapUnionPreferA) (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferB) StartFuel_Maps._default.MapUnionPreferB))) (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferB) StartFuelAssert_Maps._default.MapUnionPreferB) (= (AsFuelBottom StartFuel_Maps._default.MapUnion) StartFuel_Maps._default.MapUnion)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnion) StartFuelAssert_Maps._default.MapUnion) (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferA) StartFuel_Maps._default.IMapUnionPreferA)))))) (and (and (and (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferA) StartFuelAssert_Maps._default.IMapUnionPreferA) (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferB) StartFuel_Maps._default.IMapUnionPreferB)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferB) StartFuelAssert_Maps._default.IMapUnionPreferB) (= (AsFuelBottom StartFuel_Maps._default.IMapUnion) StartFuel_Maps._default.IMapUnion))) (and (and (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnion) StartFuelAssert_Maps._default.IMapUnion) (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion3) StartFuel_Maps._default.MapDisjointUnion3)) (and (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion3) StartFuelAssert_Maps._default.MapDisjointUnion3) (= (AsFuelBottom StartFuel_MsgHistoryMod.MsgHistory.LSNSet) StartFuel_MsgHistoryMod.MsgHistory.LSNSet)))) (and (and (and (= (AsFuelBottom StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) (= (AsFuelBottom StartFuel_SeqComparison._default.lte) StartFuel_SeqComparison._default.lte)) (and (= (AsFuelBottom StartFuelAssert_SeqComparison._default.lte) StartFuelAssert_SeqComparison._default.lte) (= (AsFuelBottom StartFuel_Byte_Order._default.lte) StartFuel_Byte_Order._default.lte))) (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.lte) StartFuelAssert_Byte_Order._default.lte) (= (AsFuelBottom StartFuel_Byte_Order._default.ltedef) StartFuel_Byte_Order._default.ltedef)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.ltedef) StartFuelAssert_Byte_Order._default.ltedef) (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt))) (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuel_Byte_Order._default.NotMinimum) StartFuel_Byte_Order._default.NotMinimum)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.NotMinimum) StartFuelAssert_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuel_Byte_Order._default.SortedSeqForMap) StartFuel_Byte_Order._default.SortedSeqForMap)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuel_Byte_Order._default.minimum) StartFuel_Byte_Order._default.minimum)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.minimum) StartFuelAssert_Byte_Order._default.minimum) (= (AsFuelBottom StartFuel_Byte_Order._default.minimumOpt) StartFuel_Byte_Order._default.minimumOpt))) (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.minimumOpt) StartFuelAssert_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuel_Byte_Order._default.maximum) StartFuel_Byte_Order._default.maximum)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.maximum) StartFuelAssert_Byte_Order._default.maximum) (= (AsFuelBottom StartFuel_Byte_Order._default.maximumOpt) StartFuel_Byte_Order._default.maximumOpt))))))) (and (and (and (and (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.maximumOpt) StartFuelAssert_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuel_Byte_Order._default.IsSorted) StartFuel_Byte_Order._default.IsSorted)) (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.IsSorted) StartFuelAssert_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuel_Byte_Order._default.IsStrictlySorted) StartFuel_Byte_Order._default.IsStrictlySorted))) (and (and (= (AsFuelBottom StartFuelAssert_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.NotMinimum) StartFuel_Lexicographic_Byte_Order._default.NotMinimum))) (and (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum) StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.minimum) StartFuel_Lexicographic_Byte_Order._default.minimum))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.minimum) StartFuelAssert_Lexicographic_Byte_Order._default.minimum) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.minimumOpt) StartFuel_Lexicographic_Byte_Order._default.minimumOpt)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt) StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.maximum) StartFuel_Lexicographic_Byte_Order._default.maximum))) (and (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.maximum) StartFuelAssert_Lexicographic_Byte_Order._default.maximum) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.maximumOpt) StartFuel_Lexicographic_Byte_Order._default.maximumOpt)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt) StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.IsSorted) StartFuel_Lexicographic_Byte_Order._default.IsSorted)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted) StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted)) (and (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte))) (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound)) (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt)))))) (and (and (and (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum)) (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap))) (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum)) (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt)))) (and (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum)) (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt))) (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted)) (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted))))) (and (and (and (and (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuel_BoundedPivotsLib._default.CutoffForLeft) StartFuel_BoundedPivotsLib._default.CutoffForLeft)) (and (= (AsFuelBottom StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft) StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft) (= (AsFuelBottom StartFuel_BoundedPivotsLib._default.CutoffForRight) StartFuel_BoundedPivotsLib._default.CutoffForRight))) (and (and (= (AsFuelBottom StartFuelAssert_BoundedPivotsLib._default.CutoffForRight) StartFuelAssert_BoundedPivotsLib._default.CutoffForRight) (= (AsFuelBottom StartFuel_DomainMod.Domain.SaneKeys) StartFuel_DomainMod.Domain.SaneKeys)) (and (= (AsFuelBottom StartFuelAssert_DomainMod.Domain.SaneKeys) StartFuelAssert_DomainMod.Domain.SaneKeys) (= (AsFuelBottom StartFuel_PagedBetree.Path.ReplacedChildren) StartFuel_PagedBetree.Path.ReplacedChildren)))) (and (and (and (= (AsFuelBottom StartFuelAssert_PagedBetree.Path.ReplacedChildren) StartFuelAssert_PagedBetree.Path.ReplacedChildren) (= (AsFuelBottom StartFuel_PagedBetreeRefinement._default.INode) StartFuel_PagedBetreeRefinement._default.INode)) (and (= (AsFuelBottom StartFuelAssert_PagedBetreeRefinement._default.INode) StartFuelAssert_PagedBetreeRefinement._default.INode) (= (AsFuelBottom StartFuel_PagedBetreeRefinement._default.MapApply) StartFuel_PagedBetreeRefinement._default.MapApply))) (and (and (= (AsFuelBottom StartFuelAssert_PagedBetreeRefinement._default.MapApply) StartFuelAssert_PagedBetreeRefinement._default.MapApply) (= $_Frame@0 (|lambda#20| null $Heap@@111 alloc false))) (and (PivotBetree.Variables.Variables_q |v'#0@@115|) (PivotBetree.Variables.Variables_q |v'#0@@115|)))))))) (and (=> (= (ControlFlow 0 81670) 81677) anon11_Then_correct) (=> (= (ControlFlow 0 81670) 81712) anon11_Else_correct)))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and ($IsGoodHeap $Heap@@111) ($IsHeapAnchor $Heap@@111)) (=> (and (and (and (and (and ($Is |v#0@@176| Tclass.PivotBetree.Variables) ($IsAlloc |v#0@@176| Tclass.PivotBetree.Variables $Heap@@111)) (|$IsA#PivotBetree.Variables| |v#0@@176|)) (and (and ($Is |v'#0@@115| Tclass.PivotBetree.Variables) ($IsAlloc |v'#0@@115| Tclass.PivotBetree.Variables $Heap@@111)) (|$IsA#PivotBetree.Variables| |v'#0@@115|))) (and (and (and ($Is |lbl#0@@123| Tclass.PivotBetree.TransitionLabel) ($IsAlloc |lbl#0@@123| Tclass.PivotBetree.TransitionLabel $Heap@@111)) (|$IsA#PivotBetree.TransitionLabel| |lbl#0@@123|)) (and ($Is |step#0_0| Tclass.PivotBetree.Step) ($IsAlloc |step#0_0| Tclass.PivotBetree.Step $Heap@@111)))) (and (and (and (and ($Is |compactedNode#0_2_0| Tclass.PivotBetree.BetreeNode) ($IsAlloc |compactedNode#0_2_0| Tclass.PivotBetree.BetreeNode $Heap@@111)) (= 17 $FunctionContextHeight)) (and (|PivotBetreeRefinement.__default.Inv#canCall| |v#0@@176|) (and (PivotBetreeRefinement.__default.Inv |v#0@@176|) (and (PivotBetree.Variables.WF |v#0@@176|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Variables.root |v#0@@176|)) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Variables.root |v#0@@176|)) DomainMod.__default.TotalDomain)))))) (and (and (|PivotBetree.__default.Next#canCall| |v#0@@176| |v'#0@@115| |lbl#0@@123|) (and (PivotBetree.__default.Next |v#0@@176| |v'#0@@115| |lbl#0@@123|) (exists ((|step#1@@3| T@U) ) (!  (and (= (type |step#1@@3|) DatatypeTypeType) (and ($Is |step#1@@3| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| |step#1@@3|)))
 :qid |PivotBetreeidfy.660:12|
 :skolemid |1411|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@176| |v'#0@@115| |lbl#0@@123| |step#1@@3|))
)))) (= (ControlFlow 0 1316568) 81670)))) anon0_correct))))
PreconditionGeneratedEntry_correct)))))))))))))))
))
(check-sat)
(get-info :reason-unknown)
(get-value ((ControlFlow 0 0)))
(get-value ((ControlFlow 0 1316568)))
(get-value ((ControlFlow 0 81670)))
(get-value ((ControlFlow 0 81677)))
(get-value ((ControlFlow 0 81679)))
(get-value ((ControlFlow 0 81688)))
(get-value ((ControlFlow 0 81697)))
(get-value ((ControlFlow 0 81706)))
(get-value ((ControlFlow 0 81710)))
(get-value ((ControlFlow 0 1316501)))
(assert (not (= (ControlFlow 0 1316501) (- 1341924))))
(check-sat)
(pop 1)
; Invalid
