(set-option :print-success false)
(set-info :smt-lib-version 2.6)
(set-option :auto_config false)
(set-option :type_check true)
(set-option :smt.case_split 3)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.delay_units true)
(set-option :smt.arith.solver 2)
(set-option :smt.arith.nl false)
(set-option :smt.mbqi false)
(set-option :model.compact false)
(set-option :model.v2 true)
(set-option :pp.bv_literals false)
; done setting options


(set-info :category "industrial")
(declare-sort |T@U| 0)
(declare-sort |T@T| 0)
(declare-fun real_pow (Real Real) Real)
(declare-fun UOrdering2 (|T@U| |T@U|) Bool)
(declare-fun UOrdering3 (|T@T| |T@U| |T@U|) Bool)
(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun U_2_int (T@U) Int)
(declare-fun U_2_bool (T@U) Bool)
(declare-fun Ctor (T@T) Int)
(declare-fun intType () T@T)
(declare-fun realType () T@T)
(declare-fun boolType () T@T)
(declare-fun rmodeType () T@T)
(declare-fun stringType () T@T)
(declare-fun regexType () T@T)
(declare-fun int_2_U (Int) T@U)
(declare-fun type (T@U) T@T)
(declare-fun real_2_U (Real) T@U)
(declare-fun U_2_real (T@U) Real)
(declare-fun bool_2_U (Bool) T@U)
(declare-fun rmode_2_U (RoundingMode) T@U)
(declare-fun U_2_rmode (T@U) RoundingMode)
(declare-fun string_2_U (String) T@U)
(declare-fun U_2_string (T@U) String)
(declare-fun regex_2_U ((RegEx String)) T@U)
(declare-fun U_2_regex (T@U) (RegEx String))
(declare-fun TBool () T@U)
(declare-fun TChar () T@U)
(declare-fun TInt () T@U)
(declare-fun TReal () T@U)
(declare-fun TORDINAL () T@U)
(declare-fun TagBool () T@U)
(declare-fun TagChar () T@U)
(declare-fun TagInt () T@U)
(declare-fun TagReal () T@U)
(declare-fun TagORDINAL () T@U)
(declare-fun TagSet () T@U)
(declare-fun TagISet () T@U)
(declare-fun TagMultiSet () T@U)
(declare-fun TagSeq () T@U)
(declare-fun TagMap () T@U)
(declare-fun TagIMap () T@U)
(declare-fun TagClass () T@U)
(declare-fun class._System.int () T@U)
(declare-fun class._System.bool () T@U)
(declare-fun class._System.set () T@U)
(declare-fun class._System.seq () T@U)
(declare-fun class._System.multiset () T@U)
(declare-fun alloc () T@U)
(declare-fun allocName () T@U)
(declare-fun Tagclass._System.nat () T@U)
(declare-fun class._System.object? () T@U)
(declare-fun Tagclass._System.object? () T@U)
(declare-fun Tagclass._System.object () T@U)
(declare-fun class._System.array? () T@U)
(declare-fun Tagclass._System.array? () T@U)
(declare-fun Tagclass._System.array () T@U)
(declare-fun Tagclass._System.___hFunc1 () T@U)
(declare-fun Tagclass._System.___hPartialFunc1 () T@U)
(declare-fun Tagclass._System.___hTotalFunc1 () T@U)
(declare-fun Tagclass._System.___hFunc0 () T@U)
(declare-fun Tagclass._System.___hPartialFunc0 () T@U)
(declare-fun Tagclass._System.___hTotalFunc0 () T@U)
(declare-fun class._System.__default () T@U)
(declare-fun Tagclass._System.__default () T@U)
(declare-fun Tagclass._System.___hFunc2 () T@U)
(declare-fun Tagclass._System.___hPartialFunc2 () T@U)
(declare-fun Tagclass._System.___hTotalFunc2 () T@U)
(declare-fun |##_System._tuple#2._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2 () T@U)
(declare-fun class._System.Tuple2 () T@U)
(declare-fun Tagclass._System.___hFunc4 () T@U)
(declare-fun Tagclass._System.___hPartialFunc4 () T@U)
(declare-fun Tagclass._System.___hTotalFunc4 () T@U)
(declare-fun Tagclass._System.___hFunc3 () T@U)
(declare-fun Tagclass._System.___hPartialFunc3 () T@U)
(declare-fun Tagclass._System.___hTotalFunc3 () T@U)
(declare-fun Tagclass._System.___hFunc2OSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2OSO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2OSO () T@U)
(declare-fun Tagclass._System.___hFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOO () T@U)
(declare-fun Tagclass._System.___hFunc1OS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OS () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OS () T@U)
(declare-fun Tagclass._System.___hFunc0L () T@U)
(declare-fun Tagclass._System.___hPartialFunc0L () T@U)
(declare-fun Tagclass._System.___hTotalFunc0L () T@U)
(declare-fun Tagclass._System.___hFunc2LOO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LOO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LOO () T@U)
(declare-fun |##_System._tuple#0._#Make0| () T@U)
(declare-fun Tagclass._System.Tuple0 () T@U)
(declare-fun class._System.Tuple0 () T@U)
(declare-fun Tagclass._System.___hFunc1OL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1OL () T@U)
(declare-fun Tagclass._System.___hTotalFunc1OL () T@U)
(declare-fun Tagclass._System.___hFunc1LO () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LO () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LO () T@U)
(declare-fun |##_System._tuple#2OLL._#Make2| () T@U)
(declare-fun Tagclass._System.Tuple2OLL () T@U)
(declare-fun class._System.Tuple2OLL () T@U)
(declare-fun Tagclass._System.___hFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hPartialFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hTotalFunc3LLOL () T@U)
(declare-fun Tagclass._System.___hFunc2SSO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2SSO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2SSO () T@U)
(declare-fun Tagclass._System.___hFunc2LLO () T@U)
(declare-fun Tagclass._System.___hPartialFunc2LLO () T@U)
(declare-fun Tagclass._System.___hTotalFunc2LLO () T@U)
(declare-fun Tagclass._System.___hFunc1SS () T@U)
(declare-fun Tagclass._System.___hPartialFunc1SS () T@U)
(declare-fun Tagclass._System.___hTotalFunc1SS () T@U)
(declare-fun Tagclass._System.___hFunc1LL () T@U)
(declare-fun Tagclass._System.___hPartialFunc1LL () T@U)
(declare-fun Tagclass._System.___hTotalFunc1LL () T@U)
(declare-fun |##PivotBetree.TransitionLabel.QueryLabel| () T@U)
(declare-fun Tagclass.KeyType.Key () T@U)
(declare-fun Tagclass.ValueType.Value () T@U)
(declare-fun Tagclass.PivotBetree.TransitionLabel () T@U)
(declare-fun |##PivotBetree.TransitionLabel.PutLabel| () T@U)
(declare-fun Tagclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun |##PivotBetree.TransitionLabel.QueryEndLsnLabel| () T@U)
(declare-fun |##PivotBetree.TransitionLabel.FreezeAsLabel| () T@U)
(declare-fun Tagclass.PivotBetree.BetreeNode () T@U)
(declare-fun Tagclass.StampedMod.Stamped () T@U)
(declare-fun |##PivotBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun class.PivotBetree.TransitionLabel () T@U)
(declare-fun |##PivotBetree.BetreeNode.Nil| () T@U)
(declare-fun |##PivotBetree.BetreeNode.BetreeNode| () T@U)
(declare-fun Tagclass.Buffers.BufferStack () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun class.PivotBetree.BetreeNode () T@U)
(declare-fun Tagclass.DomainMod.Domain () T@U)
(declare-fun Tagclass.SplitRequestMod.SplitRequest () T@U)
(declare-fun Tagclass.NativeTypes.byte () T@U)
(declare-fun |##PivotBetree.QueryReceiptLine.QueryReceiptLine| () T@U)
(declare-fun Tagclass.ValueMessage.Message () T@U)
(declare-fun Tagclass.PivotBetree.QueryReceiptLine () T@U)
(declare-fun class.PivotBetree.QueryReceiptLine () T@U)
(declare-fun |##PivotBetree.QueryReceipt.QueryReceipt| () T@U)
(declare-fun Tagclass.PivotBetree.QueryReceipt () T@U)
(declare-fun class.PivotBetree.QueryReceipt () T@U)
(declare-fun |##PivotBetree.Variables.Variables| () T@U)
(declare-fun Tagclass.MemtableMod.Memtable () T@U)
(declare-fun Tagclass.PivotBetree.Variables () T@U)
(declare-fun class.PivotBetree.Variables () T@U)
(declare-fun |##PivotBetree.Path.Path| () T@U)
(declare-fun Tagclass.PivotBetree.Path () T@U)
(declare-fun class.PivotBetree.Path () T@U)
(declare-fun |##PivotBetree.Step.QueryStep| () T@U)
(declare-fun Tagclass.PivotBetree.Step () T@U)
(declare-fun |##PivotBetree.Step.PutStep| () T@U)
(declare-fun |##PivotBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun |##PivotBetree.Step.FreezeAsStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalGrowStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalSplitStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalFlushStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalCompactStep| () T@U)
(declare-fun |##PivotBetree.Step.InternalNoOpStep| () T@U)
(declare-fun class.PivotBetree.Step () T@U)
(declare-fun class.PivotBetree.__default () T@U)
(declare-fun Tagclass.PivotBetree.__default () T@U)
(declare-fun Tagclass.Buffers.Buffer () T@U)
(declare-fun |##Options.Option.None| () T@U)
(declare-fun Tagclass.Options.Option () T@U)
(declare-fun |##Options.Option.Some| () T@U)
(declare-fun class.Options.Option () T@U)
(declare-fun class.Options.__default () T@U)
(declare-fun Tagclass.Options.__default () T@U)
(declare-fun Tagclass.NativeTypes.sbyte () T@U)
(declare-fun class.NativeTypes.sbyte () T@U)
(declare-fun class.NativeTypes.byte () T@U)
(declare-fun Tagclass.NativeTypes.int16 () T@U)
(declare-fun class.NativeTypes.int16 () T@U)
(declare-fun Tagclass.NativeTypes.uint16 () T@U)
(declare-fun class.NativeTypes.uint16 () T@U)
(declare-fun Tagclass.NativeTypes.int32 () T@U)
(declare-fun class.NativeTypes.int32 () T@U)
(declare-fun Tagclass.NativeTypes.uint32 () T@U)
(declare-fun class.NativeTypes.uint32 () T@U)
(declare-fun Tagclass.NativeTypes.int64 () T@U)
(declare-fun class.NativeTypes.int64 () T@U)
(declare-fun Tagclass.NativeTypes.uint64 () T@U)
(declare-fun class.NativeTypes.uint64 () T@U)
(declare-fun Tagclass.NativeTypes.nat8 () T@U)
(declare-fun class.NativeTypes.nat8 () T@U)
(declare-fun Tagclass.NativeTypes.nat16 () T@U)
(declare-fun class.NativeTypes.nat16 () T@U)
(declare-fun Tagclass.NativeTypes.nat32 () T@U)
(declare-fun class.NativeTypes.nat32 () T@U)
(declare-fun Tagclass.NativeTypes.nat64 () T@U)
(declare-fun class.NativeTypes.nat64 () T@U)
(declare-fun Tagclass.NativeTypes.uint128 () T@U)
(declare-fun class.NativeTypes.uint128 () T@U)
(declare-fun class.NativeTypes.__default () T@U)
(declare-fun Tagclass.NativeTypes.__default () T@U)
(declare-fun class.KeyType.__default () T@U)
(declare-fun Tagclass.KeyType.__default () T@U)
(declare-fun class.ValueType.__default () T@U)
(declare-fun Tagclass.ValueType.__default () T@U)
(declare-fun class.LinearMaybe.predefined () T@U)
(declare-fun class.LinearMaybe.__default () T@U)
(declare-fun Tagclass.LinearMaybe.__default () T@U)
(declare-fun class.LinearExtern.predefined () T@U)
(declare-fun class.LinearExtern.__default () T@U)
(declare-fun Tagclass.LinearExtern.__default () T@U)
(declare-fun |##ValueMessage.Delta.NoDelta| () T@U)
(declare-fun Tagclass.ValueMessage.Delta () T@U)
(declare-fun class.ValueMessage.Delta () T@U)
(declare-fun class.ValueMessage.__default () T@U)
(declare-fun Tagclass.ValueMessage.__default () T@U)
(declare-fun |##ValueMessage.Message.Define| () T@U)
(declare-fun |##ValueMessage.Message.Update| () T@U)
(declare-fun class.ValueMessage.Message () T@U)
(declare-fun class.TotalKMMapMod.__default () T@U)
(declare-fun Tagclass.TotalKMMapMod.__default () T@U)
(declare-fun Tagclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun class.LSNMod.__default () T@U)
(declare-fun Tagclass.LSNMod.__default () T@U)
(declare-fun |##StampedMod.Stamped.Stamped| () T@U)
(declare-fun class.StampedMod.Stamped () T@U)
(declare-fun class.StampedMod.__default () T@U)
(declare-fun Tagclass.StampedMod.__default () T@U)
(declare-fun class.SequencesLite.__default () T@U)
(declare-fun Tagclass.SequencesLite.__default () T@U)
(declare-fun class.Mathematics.__default () T@U)
(declare-fun Tagclass.Mathematics.__default () T@U)
(declare-fun class.LinearSequence__i.__default () T@U)
(declare-fun Tagclass.LinearSequence__i.__default () T@U)
(declare-fun class.Sequences.__default () T@U)
(declare-fun Tagclass.Sequences.__default () T@U)
(declare-fun class.MapRemove_s.__default () T@U)
(declare-fun Tagclass.MapRemove_s.__default () T@U)
(declare-fun class.Maps.__default () T@U)
(declare-fun Tagclass.Maps.__default () T@U)
(declare-fun |##MsgHistoryMod.KeyedMessage.KeyedMessage| () T@U)
(declare-fun Tagclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun class.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun |##MsgHistoryMod.MsgHistory.MsgHistory| () T@U)
(declare-fun class.MsgHistoryMod.MsgHistory () T@U)
(declare-fun class.MsgHistoryMod.__default () T@U)
(declare-fun Tagclass.MsgHistoryMod.__default () T@U)
(declare-fun |##Buffers.Buffer.Buffer| () T@U)
(declare-fun class.Buffers.Buffer () T@U)
(declare-fun |##Buffers.BufferStack.BufferStack| () T@U)
(declare-fun class.Buffers.BufferStack () T@U)
(declare-fun class.Buffers.__default () T@U)
(declare-fun Tagclass.Buffers.__default () T@U)
(declare-fun |##MemtableMod.Memtable.Memtable| () T@U)
(declare-fun class.MemtableMod.Memtable () T@U)
(declare-fun class.MemtableMod.__default () T@U)
(declare-fun Tagclass.MemtableMod.__default () T@U)
(declare-fun class.Sets.__default () T@U)
(declare-fun Tagclass.Sets.__default () T@U)
(declare-fun class.SeqComparison.__default () T@U)
(declare-fun Tagclass.SeqComparison.__default () T@U)
(declare-fun class.NativeArrays.__default () T@U)
(declare-fun Tagclass.NativeArrays.__default () T@U)
(declare-fun class.Byte__Order.__default () T@U)
(declare-fun Tagclass.Byte__Order.__default () T@U)
(declare-fun class.Lexicographic__Byte__Order.__default () T@U)
(declare-fun Tagclass.Lexicographic__Byte__Order.__default () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun |##Upperbounded_Lexicographic_Byte_Order.Element.Element| () T@U)
(declare-fun |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun class.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun class.BoundedPivotsLib.__default () T@U)
(declare-fun Tagclass.BoundedPivotsLib.__default () T@U)
(declare-fun |##DomainMod.Domain.EmptyDomain| () T@U)
(declare-fun |##DomainMod.Domain.Domain| () T@U)
(declare-fun class.DomainMod.Domain () T@U)
(declare-fun class.DomainMod.__default () T@U)
(declare-fun Tagclass.DomainMod.__default () T@U)
(declare-fun |##SplitRequestMod.SplitRequest.SplitLeaf| () T@U)
(declare-fun |##SplitRequestMod.SplitRequest.SplitIndex| () T@U)
(declare-fun class.SplitRequestMod.SplitRequest () T@U)
(declare-fun class.SplitRequestMod.__default () T@U)
(declare-fun Tagclass.SplitRequestMod.__default () T@U)
(declare-fun tytagFamily$nat () T@U)
(declare-fun tytagFamily$object () T@U)
(declare-fun tytagFamily$array () T@U)
(declare-fun |tytagFamily$_#Func1| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1| () T@U)
(declare-fun |tytagFamily$_#Func0| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0| () T@U)
(declare-fun tytagFamily$_default () T@U)
(declare-fun |tytagFamily$_#Func2| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2| () T@U)
(declare-fun |tytagFamily$_tuple#2| () T@U)
(declare-fun |tytagFamily$_#Func4| () T@U)
(declare-fun |tytagFamily$_#PartialFunc4| () T@U)
(declare-fun |tytagFamily$_#TotalFunc4| () T@U)
(declare-fun |tytagFamily$_#Func3| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3| () T@U)
(declare-fun |tytagFamily$_#Func2OSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2OSO| () T@U)
(declare-fun |tytagFamily$_#Func3LLOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOO| () T@U)
(declare-fun |tytagFamily$_#Func1OS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OS| () T@U)
(declare-fun |tytagFamily$_#Func0L| () T@U)
(declare-fun |tytagFamily$_#PartialFunc0L| () T@U)
(declare-fun |tytagFamily$_#TotalFunc0L| () T@U)
(declare-fun |tytagFamily$_#Func2LOO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LOO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LOO| () T@U)
(declare-fun |tytagFamily$_tuple#0| () T@U)
(declare-fun |tytagFamily$_#Func1OL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1OL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1OL| () T@U)
(declare-fun |tytagFamily$_#Func1LO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LO| () T@U)
(declare-fun |tytagFamily$_tuple#2OLL| () T@U)
(declare-fun |tytagFamily$_#Func3LLOL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc3LLOL| () T@U)
(declare-fun |tytagFamily$_#Func2SSO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2SSO| () T@U)
(declare-fun |tytagFamily$_#Func2LLO| () T@U)
(declare-fun |tytagFamily$_#PartialFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#TotalFunc2LLO| () T@U)
(declare-fun |tytagFamily$_#Func1SS| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1SS| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1SS| () T@U)
(declare-fun |tytagFamily$_#Func1LL| () T@U)
(declare-fun |tytagFamily$_#PartialFunc1LL| () T@U)
(declare-fun |tytagFamily$_#TotalFunc1LL| () T@U)
(declare-fun tytagFamily$Key () T@U)
(declare-fun tytagFamily$Value () T@U)
(declare-fun tytagFamily$TransitionLabel () T@U)
(declare-fun tytagFamily$MsgHistory () T@U)
(declare-fun tytagFamily$BetreeNode () T@U)
(declare-fun tytagFamily$Stamped () T@U)
(declare-fun tytagFamily$BufferStack () T@U)
(declare-fun tytagFamily$Element () T@U)
(declare-fun tytagFamily$Domain () T@U)
(declare-fun tytagFamily$SplitRequest () T@U)
(declare-fun tytagFamily$byte () T@U)
(declare-fun tytagFamily$Message () T@U)
(declare-fun tytagFamily$QueryReceiptLine () T@U)
(declare-fun tytagFamily$QueryReceipt () T@U)
(declare-fun tytagFamily$Memtable () T@U)
(declare-fun tytagFamily$Variables () T@U)
(declare-fun tytagFamily$Path () T@U)
(declare-fun tytagFamily$Step () T@U)
(declare-fun tytagFamily$Buffer () T@U)
(declare-fun tytagFamily$Option () T@U)
(declare-fun tytagFamily$sbyte () T@U)
(declare-fun tytagFamily$int16 () T@U)
(declare-fun tytagFamily$uint16 () T@U)
(declare-fun tytagFamily$int32 () T@U)
(declare-fun tytagFamily$uint32 () T@U)
(declare-fun tytagFamily$int64 () T@U)
(declare-fun tytagFamily$uint64 () T@U)
(declare-fun tytagFamily$nat8 () T@U)
(declare-fun tytagFamily$nat16 () T@U)
(declare-fun tytagFamily$nat32 () T@U)
(declare-fun tytagFamily$nat64 () T@U)
(declare-fun tytagFamily$uint128 () T@U)
(declare-fun tytagFamily$Delta () T@U)
(declare-fun tytagFamily$TotalMap () T@U)
(declare-fun tytagFamily$KeyedMessage () T@U)
(declare-fun TyType () T@T)
(declare-fun TyTagType () T@T)
(declare-fun ClassNameType () T@T)
(declare-fun FieldType (T@T) T@T)
(declare-fun FieldTypeInv0 (T@T) T@T)
(declare-fun NameFamilyType () T@T)
(declare-fun DtCtorIdType () T@T)
(declare-fun TyTagFamilyType () T@T)
(declare-fun $$Language$Dafny () Bool)
(declare-fun TBitvector (Int) T@U)
(declare-fun Inv0_TBitvector (T@U) Int)
(declare-fun TSet (T@U) T@U)
(declare-fun Inv0_TSet (T@U) T@U)
(declare-fun TISet (T@U) T@U)
(declare-fun Inv0_TISet (T@U) T@U)
(declare-fun TSeq (T@U) T@U)
(declare-fun Inv0_TSeq (T@U) T@U)
(declare-fun TMultiSet (T@U) T@U)
(declare-fun Inv0_TMultiSet (T@U) T@U)
(declare-fun TMap (T@U T@U) T@U)
(declare-fun Inv0_TMap (T@U) T@U)
(declare-fun Inv1_TMap (T@U) T@U)
(declare-fun TIMap (T@U T@U) T@U)
(declare-fun Inv0_TIMap (T@U) T@U)
(declare-fun Inv1_TIMap (T@U) T@U)
(declare-fun Tag (T@U) T@U)
(declare-fun Lit (T@U) T@U)
(declare-fun $Box (T@U) T@U)
(declare-fun BoxType () T@T)
(declare-fun LitInt (Int) Int)
(declare-fun LitReal (Real) Real)
(declare-fun |char#ToInt| (T@U) Int)
(declare-fun charType () T@T)
(declare-fun |char#FromInt| (Int) T@U)
(declare-fun |char#Plus| (T@U T@U) T@U)
(declare-fun |char#Minus| (T@U T@U) T@U)
(declare-fun $Unbox (T@T T@U) T@U)
(declare-fun $IsBox (T@U T@U) Bool)
(declare-fun $Is (T@U T@U) Bool)
(declare-fun MapType0Type (T@T T@T) T@T)
(declare-fun MapType0TypeInv0 (T@T) T@T)
(declare-fun MapType0TypeInv1 (T@T) T@T)
(declare-fun MapType0Select (T@U T@U) T@U)
(declare-fun MapType0Store (T@U T@U T@U) T@U)
(declare-fun SeqType (T@T) T@T)
(declare-fun SeqTypeInv0 (T@T) T@T)
(declare-fun MapType (T@T T@T) T@T)
(declare-fun MapTypeInv0 (T@T) T@T)
(declare-fun MapTypeInv1 (T@T) T@T)
(declare-fun IMapType (T@T T@T) T@T)
(declare-fun IMapTypeInv0 (T@T) T@T)
(declare-fun IMapTypeInv1 (T@T) T@T)
(declare-fun $IsAllocBox (T@U T@U T@U) Bool)
(declare-fun refType () T@T)
(declare-fun MapType1Type () T@T)
(declare-fun $IsAlloc (T@U T@U T@U) Bool)
(declare-fun MapType1Select (T@U T@U) T@U)
(declare-fun MapType1Store (T@U T@U T@U) T@U)
(declare-fun $IsGoodMultiSet (T@U) Bool)
(declare-fun |Seq#Index| (T@U Int) T@U)
(declare-fun |Seq#Length| (T@U) Int)
(declare-fun |Map#Elements| (T@U) T@U)
(declare-fun |Map#Domain| (T@U) T@U)
(declare-fun |Map#Values| (T@U) T@U)
(declare-fun |Map#Items| (T@U) T@U)
(declare-fun Tclass._System.Tuple2 (T@U T@U) T@U)
(declare-fun |IMap#Elements| (T@U) T@U)
(declare-fun |IMap#Domain| (T@U) T@U)
(declare-fun |IMap#Values| (T@U) T@U)
(declare-fun |IMap#Items| (T@U) T@U)
(declare-fun TypeTuple (T@U T@U) T@U)
(declare-fun TypeTupleCar (T@U) T@U)
(declare-fun TypeTupleCdr (T@U) T@U)
(declare-fun SetRef_to_SetBox (T@U) T@U)
(declare-fun Tclass._System.object? () T@U)
(declare-fun BoxRank (T@U) Int)
(declare-fun DatatypeTypeType () T@T)
(declare-fun DtRank (T@U) Int)
(declare-fun |ORD#Offset| (T@U) Int)
(declare-fun |ORD#FromNat| (Int) T@U)
(declare-fun |ORD#IsNat| (T@U) Bool)
(declare-fun |ORD#Less| (T@U T@U) Bool)
(declare-fun |ORD#LessThanLimit| (T@U T@U) Bool)
(declare-fun |ORD#Plus| (T@U T@U) T@U)
(declare-fun |ORD#Minus| (T@U T@U) T@U)
(declare-fun AtLayer (T@U T@U) T@U)
(declare-fun LayerTypeType () T@T)
(declare-fun $LS (T@U) T@U)
(declare-fun IndexField (Int) T@U)
(declare-fun FDim (T@U) Int)
(declare-fun IndexField_Inverse (T@U) Int)
(declare-fun MultiIndexField (T@U Int) T@U)
(declare-fun MultiIndexField_Inverse0 (T@U) T@U)
(declare-fun MultiIndexField_Inverse1 (T@U) Int)
(declare-fun FieldOfDecl (T@T T@U T@U) T@U)
(declare-fun DeclType (T@U) T@U)
(declare-fun DeclName (T@U) T@U)
(declare-fun $HeapSucc (T@U T@U) Bool)
(declare-fun $IsGhostField (T@U) Bool)
(declare-fun _System.array.Length (T@U) Int)
(declare-fun q@Int (Real) Int)
(declare-fun q@Real (Int) Real)
(declare-fun $IsGoodHeap (T@U) Bool)
(declare-fun $OneHeap () T@U)
(declare-fun $HeapSuccGhost (T@U T@U) Bool)
(declare-fun |Set#Card| (T@U) Int)
(declare-fun |Set#Empty| (T@T) T@U)
(declare-fun |Set#Singleton| (T@U) T@U)
(declare-fun |Set#UnionOne| (T@U T@U) T@U)
(declare-fun |Set#Union| (T@U T@U) T@U)
(declare-fun |Set#Disjoint| (T@U T@U) Bool)
(declare-fun |Set#Difference| (T@U T@U) T@U)
(declare-fun |Set#Intersection| (T@U T@U) T@U)
(declare-fun |Set#Subset| (T@U T@U) Bool)
(declare-fun |Set#Equal| (T@U T@U) Bool)
(declare-fun |ISet#Empty| (T@T) T@U)
(declare-fun |ISet#UnionOne| (T@U T@U) T@U)
(declare-fun |ISet#Union| (T@U T@U) T@U)
(declare-fun |ISet#Disjoint| (T@U T@U) Bool)
(declare-fun |ISet#Difference| (T@U T@U) T@U)
(declare-fun |ISet#Intersection| (T@U T@U) T@U)
(declare-fun |ISet#Subset| (T@U T@U) Bool)
(declare-fun |ISet#Equal| (T@U T@U) Bool)
(declare-fun |Math#min| (Int Int) Int)
(declare-fun |Math#clip| (Int) Int)
(declare-fun |MultiSet#Card| (T@U) Int)
(declare-fun |MultiSet#Empty| (T@T) T@U)
(declare-fun |MultiSet#Singleton| (T@U) T@U)
(declare-fun |MultiSet#UnionOne| (T@U T@U) T@U)
(declare-fun |MultiSet#Union| (T@U T@U) T@U)
(declare-fun |MultiSet#Intersection| (T@U T@U) T@U)
(declare-fun |MultiSet#Difference| (T@U T@U) T@U)
(declare-fun |MultiSet#Subset| (T@U T@U) Bool)
(declare-fun |MultiSet#Equal| (T@U T@U) Bool)
(declare-fun |MultiSet#Disjoint| (T@U T@U) Bool)
(declare-fun |MultiSet#FromSet| (T@U) T@U)
(declare-fun |MultiSet#FromSeq| (T@U) T@U)
(declare-fun |Seq#Build| (T@U T@U) T@U)
(declare-fun |Seq#Empty| (T@T) T@U)
(declare-fun |Seq#Append| (T@U T@U) T@U)
(declare-fun |Seq#Update| (T@U Int T@U) T@U)
(declare-fun |Seq#Singleton| (T@U) T@U)
(declare-fun |Seq#Build_inv0| (T@U) T@U)
(declare-fun |Seq#Build_inv1| (T@U) T@U)
(declare-fun |Seq#Create| (T@U T@U Int T@U) T@U)
(declare-fun HandleTypeType () T@T)
(declare-fun Apply1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Seq#Contains| (T@U T@U) Bool)
(declare-fun |Seq#Take| (T@U Int) T@U)
(declare-fun |Seq#Drop| (T@U Int) T@U)
(declare-fun |Seq#Equal| (T@U T@U) Bool)
(declare-fun |Seq#SameUntil| (T@U T@U Int) Bool)
(declare-fun |Seq#FromArray| (T@U T@U) T@U)
(declare-fun |Seq#Rank| (T@U) Int)
(declare-fun |Map#Card| (T@U) Int)
(declare-fun |Map#Empty| (T@T T@T) T@U)
(declare-fun |#_System._tuple#2._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2._0 (T@U) T@U)
(declare-fun _System.Tuple2._1 (T@U) T@U)
(declare-fun |Map#Glue| (T@U T@U T@U) T@U)
(declare-fun |Map#Build| (T@U T@U T@U) T@U)
(declare-fun |Map#Merge| (T@U T@U) T@U)
(declare-fun |Map#Subtract| (T@U T@U) T@U)
(declare-fun |Map#Equal| (T@U T@U) Bool)
(declare-fun |Map#Disjoint| (T@U T@U) Bool)
(declare-fun |IMap#Empty| (T@T T@T) T@U)
(declare-fun |IMap#Glue| (T@U T@U T@U) T@U)
(declare-fun |IMap#Build| (T@U T@U T@U) T@U)
(declare-fun |IMap#Equal| (T@U T@U) Bool)
(declare-fun |IMap#Merge| (T@U T@U) T@U)
(declare-fun |IMap#Subtract| (T@U T@U) T@U)
(declare-fun INTERNAL_add_boogie (Int Int) Int)
(declare-fun INTERNAL_sub_boogie (Int Int) Int)
(declare-fun INTERNAL_mul_boogie (Int Int) Int)
(declare-fun INTERNAL_div_boogie (Int Int) Int)
(declare-fun INTERNAL_mod_boogie (Int Int) Int)
(declare-fun INTERNAL_lt_boogie (Int Int) Bool)
(declare-fun INTERNAL_le_boogie (Int Int) Bool)
(declare-fun INTERNAL_gt_boogie (Int Int) Bool)
(declare-fun INTERNAL_ge_boogie (Int Int) Bool)
(declare-fun Mul (Int Int) Int)
(declare-fun Div (Int Int) Int)
(declare-fun Mod (Int Int) Int)
(declare-fun Add (Int Int) Int)
(declare-fun Sub (Int Int) Int)
(declare-fun _System.__default.rank__is__less__than (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.nat () T@U)
(declare-fun TagFamily (T@U) T@U)
(declare-fun null () T@U)
(declare-fun Tclass._System.object () T@U)
(declare-fun Tclass._System.array? (T@U) T@U)
(declare-fun Tclass._System.array?_0 (T@U) T@U)
(declare-fun dtype (T@U) T@U)
(declare-fun Tclass._System.array (T@U) T@U)
(declare-fun Tclass._System.array_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1_1 (T@U) T@U)
(declare-fun Handle1 (T@U T@U T@U) T@U)
(declare-fun MapType2Type (T@T T@T T@T) T@T)
(declare-fun MapType2Select (T@U T@U T@U) T@U)
(declare-fun MapType2TypeInv0 (T@T) T@T)
(declare-fun MapType2TypeInv1 (T@T) T@T)
(declare-fun MapType2TypeInv2 (T@T) T@T)
(declare-fun MapType2Store (T@U T@U T@U T@U) T@U)
(declare-fun Requires1 (T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1 (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0_0 (T@U) T@U)
(declare-fun Apply0 (T@U T@U T@U) T@U)
(declare-fun Handle0 (T@U T@U T@U) T@U)
(declare-fun Requires0 (T@U T@U T@U) Bool)
(declare-fun Reads0 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0_0 (T@U) T@U)
(declare-fun Tclass._System.__default () T@U)
(declare-fun |_System.__default.rank__is__less__than#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |_System.__default.rank__is__less__than#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2_2 (T@U) T@U)
(declare-fun Apply2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle2 (T@U T@U T@U) T@U)
(declare-fun MapType3Type (T@T T@T T@T T@T) T@T)
(declare-fun MapType3Select (T@U T@U T@U T@U) T@U)
(declare-fun MapType3TypeInv0 (T@T) T@T)
(declare-fun MapType3TypeInv1 (T@T) T@T)
(declare-fun MapType3TypeInv2 (T@T) T@T)
(declare-fun MapType3TypeInv3 (T@T) T@T)
(declare-fun MapType3Store (T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires2 (T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads2 (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2 (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2_2 (T@U) T@U)
(declare-fun DatatypeCtorId (T@U) T@U)
(declare-fun _System.Tuple2.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2_1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2| (T@U) Bool)
(declare-fun |_System.Tuple2#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc4_4 (T@U) T@U)
(declare-fun Apply4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle4 (T@U T@U T@U) T@U)
(declare-fun MapType4Type (T@T T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType4Select (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType4TypeInv0 (T@T) T@T)
(declare-fun MapType4TypeInv1 (T@T) T@T)
(declare-fun MapType4TypeInv2 (T@T) T@T)
(declare-fun MapType4TypeInv3 (T@T) T@T)
(declare-fun MapType4TypeInv4 (T@T) T@T)
(declare-fun MapType4TypeInv5 (T@T) T@T)
(declare-fun MapType4Store (T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads4 (T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4 (T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc4_4 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3_3 (T@U) T@U)
(declare-fun Apply3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Handle3 (T@U T@U T@U) T@U)
(declare-fun MapType5Type (T@T T@T T@T T@T T@T) T@T)
(declare-fun MapType5Select (T@U T@U T@U T@U T@U) T@U)
(declare-fun MapType5TypeInv0 (T@T) T@T)
(declare-fun MapType5TypeInv1 (T@T) T@T)
(declare-fun MapType5TypeInv2 (T@T) T@T)
(declare-fun MapType5TypeInv3 (T@T) T@T)
(declare-fun MapType5TypeInv4 (T@T) T@T)
(declare-fun MapType5Store (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Requires3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Reads3 (T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3 (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2OSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOO_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc0L_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LOO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LOO_2 (T@U) T@U)
(declare-fun |#_System._tuple#0._#Make0| () T@U)
(declare-fun _System.Tuple0.___hMake0_q (T@U) Bool)
(declare-fun Tclass._System.Tuple0 () T@U)
(declare-fun |$IsA#_System.Tuple0| (T@U) Bool)
(declare-fun |_System.Tuple0#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1OL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LO_1 (T@U) T@U)
(declare-fun |#_System._tuple#2OLL._#Make2| (T@U T@U) T@U)
(declare-fun _System.Tuple2OLL.___hMake2_q (T@U) Bool)
(declare-fun Tclass._System.Tuple2OLL (T@U T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_0 (T@U) T@U)
(declare-fun Tclass._System.Tuple2OLL_1 (T@U) T@U)
(declare-fun _System.Tuple2OLL._0 (T@U) T@U)
(declare-fun _System.Tuple2OLL._1 (T@U) T@U)
(declare-fun |$IsA#_System.Tuple2OLL| (T@U) Bool)
(declare-fun |_System.Tuple2OLL#Equal| (T@U T@U) Bool)
(declare-fun Tclass._System.___hFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL (T@U T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc3LLOL_3 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2SSO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO (T@U T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc2LLO_2 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1SS_1 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hPartialFunc1LL_1 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL (T@U T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_0 (T@U) T@U)
(declare-fun Tclass._System.___hTotalFunc1LL_1 (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.QueryLabel| (Int T@U T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.QueryLabel_q (T@U) Bool)
(declare-fun Tclass.KeyType.Key () T@U)
(declare-fun Tclass.ValueType.Value () T@U)
(declare-fun Tclass.PivotBetree.TransitionLabel () T@U)
(declare-fun PivotBetree.TransitionLabel.endLsn (T@U) Int)
(declare-fun PivotBetree.TransitionLabel.key (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.value (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.PutLabel| (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.PutLabel_q (T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.MsgHistory () T@U)
(declare-fun PivotBetree.TransitionLabel.puts (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.QueryEndLsnLabel| (Int) T@U)
(declare-fun PivotBetree.TransitionLabel.QueryEndLsnLabel_q (T@U) Bool)
(declare-fun |#PivotBetree.TransitionLabel.FreezeAsLabel| (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.FreezeAsLabel_q (T@U) Bool)
(declare-fun Tclass.PivotBetree.BetreeNode () T@U)
(declare-fun Tclass.StampedMod.Stamped (T@U) T@U)
(declare-fun Tclass.StampedMod.Stamped_0 (T@U) T@U)
(declare-fun PivotBetree.TransitionLabel.stampedBetree (T@U) T@U)
(declare-fun |#PivotBetree.TransitionLabel.InternalLabel| () T@U)
(declare-fun PivotBetree.TransitionLabel.InternalLabel_q (T@U) Bool)
(declare-fun |$IsA#PivotBetree.TransitionLabel| (T@U) Bool)
(declare-fun |PivotBetree.TransitionLabel#Equal| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory#Equal| (T@U T@U) Bool)
(declare-fun |StampedMod.Stamped#Equal| (T@U T@U) Bool)
(declare-fun |#PivotBetree.BetreeNode.Nil| () T@U)
(declare-fun PivotBetree.BetreeNode.Nil_q (T@U) Bool)
(declare-fun |#PivotBetree.BetreeNode.BetreeNode| (T@U T@U T@U) T@U)
(declare-fun PivotBetree.BetreeNode.BetreeNode_q (T@U) Bool)
(declare-fun Tclass.Buffers.BufferStack () T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order.Element () T@U)
(declare-fun PivotBetree.BetreeNode.buffers (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.pivotTable (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.children (T@U) T@U)
(declare-fun |$IsA#PivotBetree.BetreeNode| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode#Equal| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack#Equal| (T@U T@U) Bool)
(declare-fun $FunctionContextHeight () Int)
(declare-fun PivotBetree.BetreeNode.LocalStructure (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LocalStructure#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LocalStructure#requires| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.WFPivots#canCall| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.WFPivots (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.NumBuckets#canCall| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.NumBuckets (T@U) Int)
(declare-fun PivotBetree.BetreeNode.ValidChildIndex (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.ValidChildIndex#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.ValidChildIndex#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.LinkedChildren (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LinkedChildren#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.LinkedChildren#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.DomainRoutedToChild (T@U Int) T@U)
(declare-fun |$IsA#DomainMod.Domain| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.MyDomain (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.MyDomain#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (T@U Int) Bool)
(declare-fun |DomainMod.Domain#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.WF (T@U T@U) Bool)
(declare-fun AsFuelBottom (T@U) T@U)
(declare-fun $LZ () T@U)
(declare-fun |PivotBetree.BetreeNode.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.WF#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.WFChildren#canCall| (T@U) Bool)
(declare-fun PivotBetree.__default.WFChildren (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.PushBufferStack (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.PushBufferStack#canCall| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.PushBufferStack (T@U T@U) T@U)
(declare-fun PivotBetree.BetreeNode.IsLeaf (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsLeaf#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsLeaf#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.IsIndex (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsIndex#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.IsIndex#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.SplitLeaf (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#canCall| (T@U T@U) Bool)
(declare-fun DomainMod.Domain.Contains (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.e (T@U) T@U)
(declare-fun DomainMod.Domain.start (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#requires| (T@U T@U) Bool)
(declare-fun |#DomainMod.Domain.Domain| (T@U T@U) T@U)
(declare-fun |#Upperbounded_Lexicographic_Byte_Order.Element.Element| (T@U) T@U)
(declare-fun DomainMod.Domain.end (T@U) T@U)
(declare-fun |DomainMod.Domain.KeySet#canCall| (T@U) Bool)
(declare-fun |Buffers.BufferStack.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun DomainMod.Domain.KeySet (T@U) T@U)
(declare-fun Buffers.BufferStack.ApplyFilter (T@U T@U) T@U)
(declare-fun Tclass.DomainMod.Domain () T@U)
(declare-fun PivotBetree.BetreeNode.SplitIndex (T@U Int) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#requires| (T@U Int) Bool)
(declare-fun Tclass.SplitRequestMod.SplitRequest () T@U)
(declare-fun PivotBetree.BetreeNode.CanSplitParent (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.CanSplitParent#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.CanSplitParent#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitLeaf#Handle| (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitIndex#Handle| (T@U) T@U)
(declare-fun SplitRequestMod.SplitRequest.SplitLeaf_q (T@U) Bool)
(declare-fun SplitRequestMod.SplitRequest.SplitIndex_q (T@U) Bool)
(declare-fun SplitRequestMod.SplitRequest.childIdx (T@U) Int)
(declare-fun SplitRequestMod.SplitRequest.splitKey (T@U) T@U)
(declare-fun SplitRequestMod.SplitRequest.childPivotIdx (T@U) Int)
(declare-fun Tclass.NativeTypes.byte () T@U)
(declare-fun PivotBetree.BetreeNode.SplitKey (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitKey#canCall| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.PivotInsertable (T@U Int T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitKey#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.SplitParentDefn (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#requires| (T@U T@U) Bool)
(declare-fun |Sequences.__default.replace1with2#canCall| (T@U T@U T@U T@U Int) Bool)
(declare-fun |BoundedPivotsLib.__default.InsertPivot#canCall| (T@U Int T@U) Bool)
(declare-fun Sequences.__default.replace1with2 (T@U T@U T@U T@U T@U Int) T@U)
(declare-fun StartFuel_Sequences._default.replace1with2 () T@U)
(declare-fun BoundedPivotsLib.__default.InsertPivot (T@U Int T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParentDefn#Handle| (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.SplitParent (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.SplitParent#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.SplitParent#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.Promote (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Promote#canCall| (T@U T@U) Bool)
(declare-fun DomainMod.Domain.WF (T@U) Bool)
(declare-fun DomainMod.Domain.Domain_q (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Promote#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.EmptyRoot#canCall| (T@U) Bool)
(declare-fun PivotBetree.__default.EmptyRoot (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.MyDomain#requires| (T@U) Bool)
(declare-fun |Sequences.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun Sequences.__default.Last (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.DomainRoutedToChild#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.CanFlush (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.CanFlush#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.CanFlush#requires| (T@U Int) Bool)
(declare-fun PivotBetree.BetreeNode.Flush (T@U Int) T@U)
(declare-fun |PivotBetree.BetreeNode.Flush#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.BetreeNode.Flush#requires| (T@U Int) Bool)
(declare-fun |Buffers.__default.AllKeys#canCall| () Bool)
(declare-fun Buffers.__default.AllKeys () T@U)
(declare-fun PivotBetree.BetreeNode.Buffers (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Buffers#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Buffers#requires| (T@U) Bool)
(declare-fun |#Buffers.BufferStack.BufferStack| (T@U) T@U)
(declare-fun PivotBetree.BetreeNode.Children (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Children#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Children#requires| (T@U) Bool)
(declare-fun PivotBetree.BetreeNode.KeyInDomain (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeyInDomain#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeyInDomain#requires| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKey#canCall| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedKey (T@U T@U) Bool)
(declare-fun PivotBetree.BetreeNode.KeySet (T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.KeySet#canCall| (T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.KeySet#requires| (T@U) Bool)
(declare-fun |lambda#44| (T@U T@U) T@U)
(declare-fun PivotBetree.BetreeNode.Child (T@U T@U) T@U)
(declare-fun |PivotBetree.BetreeNode.Child#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.BetreeNode.Child#requires| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.Route#canCall| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.Route (T@U T@U) Int)
(declare-fun |#PivotBetree.QueryReceiptLine.QueryReceiptLine| (T@U T@U) T@U)
(declare-fun PivotBetree.QueryReceiptLine.QueryReceiptLine_q (T@U) Bool)
(declare-fun Tclass.ValueMessage.Message () T@U)
(declare-fun Tclass.PivotBetree.QueryReceiptLine () T@U)
(declare-fun PivotBetree.QueryReceiptLine.node (T@U) T@U)
(declare-fun PivotBetree.QueryReceiptLine.result (T@U) T@U)
(declare-fun |$IsA#PivotBetree.QueryReceiptLine| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine#Equal| (T@U T@U) Bool)
(declare-fun |ValueMessage.Message#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.QueryReceiptLine.WF (T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceiptLine.WF#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.Define_q (T@U) Bool)
(declare-fun |#PivotBetree.QueryReceipt.QueryReceipt| (T@U T@U T@U) T@U)
(declare-fun PivotBetree.QueryReceipt.QueryReceipt_q (T@U) Bool)
(declare-fun Tclass.PivotBetree.QueryReceipt () T@U)
(declare-fun PivotBetree.QueryReceipt.key (T@U) T@U)
(declare-fun PivotBetree.QueryReceipt.root (T@U) T@U)
(declare-fun PivotBetree.QueryReceipt.lines (T@U) T@U)
(declare-fun |$IsA#PivotBetree.QueryReceipt| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Structure (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Structure#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Structure#requires| (T@U) Bool)
(declare-fun |$IsA#ValueMessage.Message| (T@U) Bool)
(declare-fun |ValueMessage.__default.DefaultValue#canCall| () Bool)
(declare-fun |#ValueMessage.Message.Define| (T@U) T@U)
(declare-fun ValueMessage.__default.DefaultValue () T@U)
(declare-fun PivotBetree.QueryReceipt.AllLinesWF (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.AllLinesWF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.AllLinesWF#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.ChildAt (T@U Int) T@U)
(declare-fun |PivotBetree.QueryReceipt.ChildAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ChildLinkedAt (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ChildLinkedAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ResultAt (T@U Int) T@U)
(declare-fun |PivotBetree.QueryReceipt.ResultAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultAt#requires| (T@U Int) Bool)
(declare-fun PivotBetree.QueryReceipt.ResultLinkedAt (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (T@U Int) Bool)
(declare-fun |PivotBetree.QueryReceipt.ResultLinkedAt#requires| (T@U Int) Bool)
(declare-fun ValueMessage.__default.Merge (T@U T@U) T@U)
(declare-fun Buffers.BufferStack.Query (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.Query#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.Merge#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Valid (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Valid#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Valid#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.Result (T@U) T@U)
(declare-fun |PivotBetree.QueryReceipt.Result#canCall| (T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.Result#requires| (T@U) Bool)
(declare-fun PivotBetree.QueryReceipt.ValidFor (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.ValidFor#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.QueryReceipt.ValidFor#requires| (T@U T@U T@U) Bool)
(declare-fun |#PivotBetree.Variables.Variables| (T@U T@U) T@U)
(declare-fun PivotBetree.Variables.Variables_q (T@U) Bool)
(declare-fun Tclass.MemtableMod.Memtable () T@U)
(declare-fun Tclass.PivotBetree.Variables () T@U)
(declare-fun PivotBetree.Variables.memtable (T@U) T@U)
(declare-fun PivotBetree.Variables.root (T@U) T@U)
(declare-fun |$IsA#PivotBetree.Variables| (T@U) Bool)
(declare-fun |PivotBetree.Variables#Equal| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.Variables.WF (T@U) Bool)
(declare-fun |PivotBetree.Variables.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Variables.WF#requires| (T@U) Bool)
(declare-fun |#PivotBetree.Path.Path| (T@U T@U Int) T@U)
(declare-fun PivotBetree.Path.Path_q (T@U) Bool)
(declare-fun Tclass.PivotBetree.Path () T@U)
(declare-fun PivotBetree.Path.node (T@U) T@U)
(declare-fun PivotBetree.Path.key (T@U) T@U)
(declare-fun PivotBetree.Path.depth (T@U) Int)
(declare-fun |$IsA#PivotBetree.Path| (T@U) Bool)
(declare-fun |PivotBetree.Path#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.Subpath (T@U) T@U)
(declare-fun |PivotBetree.Path.Subpath#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Path.Subpath#requires| (T@U) Bool)
(declare-fun PivotBetree.Path.Valid (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Valid#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Path.Valid#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.Target (T@U T@U) T@U)
(declare-fun |PivotBetree.Path.Target#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Path.Target#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ChildrenHaveMatchingDomains (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ChildrenHaveMatchingDomains#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ReplacedChildren (T@U T@U T@U) T@U)
(declare-fun |PivotBetree.Path.ReplacedChildren#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.ValidReplacement (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ReplacedChildren#requires| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Substitute#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.Path.Substitute (T@U T@U T@U) T@U)
(declare-fun |PivotBetree.Path.ValidReplacement#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.ValidReplacement#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.Path.Substitute#requires| (T@U T@U T@U) Bool)
(declare-fun |#PivotBetree.Step.QueryStep| (T@U) T@U)
(declare-fun PivotBetree.Step.QueryStep_q (T@U) Bool)
(declare-fun Tclass.PivotBetree.Step () T@U)
(declare-fun PivotBetree.Step.receipt (T@U) T@U)
(declare-fun |#PivotBetree.Step.PutStep| () T@U)
(declare-fun PivotBetree.Step.PutStep_q (T@U) Bool)
(declare-fun |#PivotBetree.Step.QueryEndLsnStep| () T@U)
(declare-fun PivotBetree.Step.QueryEndLsnStep_q (T@U) Bool)
(declare-fun |#PivotBetree.Step.FreezeAsStep| () T@U)
(declare-fun PivotBetree.Step.FreezeAsStep_q (T@U) Bool)
(declare-fun |#PivotBetree.Step.InternalGrowStep| () T@U)
(declare-fun PivotBetree.Step.InternalGrowStep_q (T@U) Bool)
(declare-fun |#PivotBetree.Step.InternalSplitStep| (T@U T@U) T@U)
(declare-fun PivotBetree.Step.InternalSplitStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.path (T@U) T@U)
(declare-fun PivotBetree.Step.request (T@U) T@U)
(declare-fun |#PivotBetree.Step.InternalFlushMemtableStep| () T@U)
(declare-fun PivotBetree.Step.InternalFlushMemtableStep_q (T@U) Bool)
(declare-fun |#PivotBetree.Step.InternalFlushStep| (T@U Int) T@U)
(declare-fun PivotBetree.Step.InternalFlushStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.childIdx (T@U) Int)
(declare-fun |#PivotBetree.Step.InternalCompactStep| (T@U T@U) T@U)
(declare-fun PivotBetree.Step.InternalCompactStep_q (T@U) Bool)
(declare-fun PivotBetree.Step.compactedBuffers (T@U) T@U)
(declare-fun |#PivotBetree.Step.InternalNoOpStep| () T@U)
(declare-fun PivotBetree.Step.InternalNoOpStep_q (T@U) Bool)
(declare-fun |$IsA#PivotBetree.Step| (T@U) Bool)
(declare-fun |PivotBetree.Step#Equal| (T@U T@U) Bool)
(declare-fun |SplitRequestMod.SplitRequest#Equal| (T@U T@U) Bool)
(declare-fun PivotBetree.Step.WF (T@U) Bool)
(declare-fun |PivotBetree.Step.WF#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Step.WF#requires| (T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#canCall| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.Equivalent (T@U T@U) Bool)
(declare-fun PivotBetree.Step.SplitKey (T@U) T@U)
(declare-fun |PivotBetree.Step.SplitKey#canCall| (T@U) Bool)
(declare-fun |PivotBetree.Step.SplitKey#requires| (T@U) Bool)
(declare-fun Tclass.PivotBetree.__default () T@U)
(declare-fun |PivotBetree.__default.WFChildren#requires| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.EmptyRoot#requires| (T@U) Bool)
(declare-fun |PivotBetree.__default.EmptyImage#canCall| () Bool)
(declare-fun PivotBetree.__default.EmptyImage () T@U)
(declare-fun |PivotBetree.__default.EmptyImage#requires| () Bool)
(declare-fun |#StampedMod.Stamped.Stamped| (T@U Int) T@U)
(declare-fun PivotBetree.__default.PushMemtable (T@U T@U) T@U)
(declare-fun |PivotBetree.__default.PushMemtable#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.PushMemtable#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Memtable_q (T@U) Bool)
(declare-fun |#Buffers.Buffer.Buffer| (T@U) T@U)
(declare-fun MemtableMod.Memtable.mapp (T@U) T@U)
(declare-fun |DomainMod.__default.TotalDomain#canCall| () Bool)
(declare-fun DomainMod.__default.TotalDomain () T@U)
(declare-fun MemtableMod.Memtable.seqEnd (T@U) Int)
(declare-fun Tclass.Buffers.Buffer () T@U)
(declare-fun PivotBetree.__default.Query (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Query#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Query#requires| (T@U T@U T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.Query (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Query#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.Put (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Put#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Put#requires| (T@U T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#canCall| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.WF (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.MsgHistory_q (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.seqStart (T@U) Int)
(declare-fun MemtableMod.Memtable.ApplyPuts (T@U T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPuts#canCall| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.QueryEndLsn (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.QueryEndLsn#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.QueryEndLsn#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.FreezeAs (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.FreezeAs#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.FreezeAs#requires| (T@U T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#canCall| (T@U) Bool)
(declare-fun MemtableMod.Memtable.IsEmpty (T@U) Bool)
(declare-fun |$IsA#StampedMod.Stamped| (T@U) Bool)
(declare-fun PivotBetree.__default.InternalFlushMemtable (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlushMemtable#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlushMemtable#requires| (T@U T@U T@U) Bool)
(declare-fun StampedMod.Stamped.value (T@U) T@U)
(declare-fun MemtableMod.Memtable.Drain (T@U) T@U)
(declare-fun StampedMod.Stamped.Stamped_q (T@U) Bool)
(declare-fun |MemtableMod.Memtable.Drain#canCall| (T@U) Bool)
(declare-fun PivotBetree.__default.InternalGrow (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalGrow#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalGrow#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalSplit (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalSplit#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalSplit#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalFlush (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlush#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalFlush#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.CompactedNode (T@U T@U) T@U)
(declare-fun |PivotBetree.__default.CompactedNode#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.CompactedNode#requires| (T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalCompact (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalCompact#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalCompact#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.InternalNoOp (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalNoOp#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.InternalNoOp#requires| (T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.Init (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Init#canCall| (T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Init#requires| (T@U T@U) Bool)
(declare-fun |MemtableMod.__default.EmptyMemtable#canCall| (Int) Bool)
(declare-fun StampedMod.Stamped.seqEnd (T@U) Int)
(declare-fun MemtableMod.__default.EmptyMemtable (Int) T@U)
(declare-fun PivotBetree.__default.NextStep (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.NextStep#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.NextStep#requires| (T@U T@U T@U T@U) Bool)
(declare-fun PivotBetree.__default.Next (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Next#canCall| (T@U T@U T@U) Bool)
(declare-fun |PivotBetree.__default.Next#requires| (T@U T@U T@U) Bool)
(declare-fun |#Options.Option.None| () T@U)
(declare-fun Options.Option.None_q (T@U) Bool)
(declare-fun Tclass.Options.Option (T@U) T@U)
(declare-fun Tclass.Options.Option_0 (T@U) T@U)
(declare-fun |#Options.Option.Some| (T@U) T@U)
(declare-fun Options.Option.Some_q (T@U) Bool)
(declare-fun Options.Option.value (T@U) T@U)
(declare-fun |$IsA#Options.Option| (T@U) Bool)
(declare-fun |Options.Option#Equal| (T@U T@U) Bool)
(declare-fun Tclass.Options.__default () T@U)
(declare-fun $IsHeapAnchor (T@U) Bool)
(declare-fun Options.__default.MapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Options.__default.MapOption#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Options.__default.MapOption#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Options.__default.FlatMapOption (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Options.__default.FlatMapOption#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Options.__default.FlatMapOption#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Tclass.NativeTypes.sbyte () T@U)
(declare-fun Tclass.NativeTypes.int16 () T@U)
(declare-fun Tclass.NativeTypes.uint16 () T@U)
(declare-fun Tclass.NativeTypes.int32 () T@U)
(declare-fun Tclass.NativeTypes.uint32 () T@U)
(declare-fun Tclass.NativeTypes.int64 () T@U)
(declare-fun Tclass.NativeTypes.uint64 () T@U)
(declare-fun Tclass.NativeTypes.nat8 () T@U)
(declare-fun Tclass.NativeTypes.nat16 () T@U)
(declare-fun Tclass.NativeTypes.nat32 () T@U)
(declare-fun Tclass.NativeTypes.nat64 () T@U)
(declare-fun Tclass.NativeTypes.uint128 () T@U)
(declare-fun Tclass.NativeTypes.__default () T@U)
(declare-fun NativeTypes.__default.Uint64Size () Int)
(declare-fun |NativeTypes.__default.Uint64Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32Size () Int)
(declare-fun |NativeTypes.__default.Uint32Size#requires| () Bool)
(declare-fun NativeTypes.__default.Uint16Size () Int)
(declare-fun |NativeTypes.__default.Uint16Size#requires| () Bool)
(declare-fun |NativeTypes.__default.Uint64UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint64UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint32UpperBound#requires| () Bool)
(declare-fun NativeTypes.__default.Uint32UpperBound () Int)
(declare-fun NativeTypes.__default.Uint8UpperBound () Int)
(declare-fun |NativeTypes.__default.Uint8UpperBound#requires| () Bool)
(declare-fun Tclass.KeyType.__default () T@U)
(declare-fun KeyType.__default.MaxLen () Int)
(declare-fun |KeyType.__default.MaxLen#requires| () Bool)
(declare-fun Tclass.ValueType.__default () T@U)
(declare-fun ValueType.__default.MaxLen () Int)
(declare-fun |ValueType.__default.MaxLen#requires| () Bool)
(declare-fun ValueType.__default.DefaultValue () T@U)
(declare-fun |ValueType.__default.DefaultValue#requires| () Bool)
(declare-fun ValueType.__default.Len (T@U) Int)
(declare-fun |ValueType.__default.Len#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.Len#requires| (T@U) Bool)
(declare-fun ValueType.__default.ValidMessageBytestring (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestring#requires| (T@U) Bool)
(declare-fun |ValueType.__default.MaxLen#canCall| () Bool)
(declare-fun ValueType.__default.ValidMessageBytestrings (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#canCall| (T@U) Bool)
(declare-fun |ValueType.__default.ValidMessageBytestrings#requires| (T@U) Bool)
(declare-fun Tclass.LinearMaybe.__default () T@U)
(declare-fun LinearMaybe.__default.has (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.has#canCall| (T@U T@U) Bool)
(declare-fun |#$maybe| (T@U) T@U)
(declare-fun |LinearMaybe.__default.has#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.read (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.read#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.read#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.peek (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.peek#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.peek#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.unwrap (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.unwrap#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.unwrap#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.give (T@U T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.give#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.give#requires| (T@U T@U T@U) Bool)
(declare-fun LinearMaybe.__default.empty (T@U) T@U)
(declare-fun |LinearMaybe.__default.empty#requires| (T@U) Bool)
(declare-fun LinearMaybe.__default.discard (T@U T@U) T@U)
(declare-fun |LinearMaybe.__default.discard#canCall| (T@U T@U) Bool)
(declare-fun |LinearMaybe.__default.discard#requires| (T@U T@U) Bool)
(declare-fun LinearMaybe.__default.imagine (T@U Bool T@U) T@U)
(declare-fun |LinearMaybe.__default.imagine#canCall| (T@U Bool T@U) Bool)
(declare-fun |LinearMaybe.__default.imagine#requires| (T@U Bool T@U) Bool)
(declare-fun Tclass.LinearExtern.__default () T@U)
(declare-fun LinearExtern.__default.seq_get (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.seq_get#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.seq_get#requires| (T@U T@U Int) Bool)
(declare-fun LinearExtern.__default.seq_set (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_set#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_set#requires| (T@U T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_length (T@U T@U) Int)
(declare-fun |LinearExtern.__default.seq_length#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_length#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_empty (T@U) T@U)
(declare-fun |LinearExtern.__default.seq_empty#requires| (T@U) Bool)
(declare-fun LinearExtern.__default.seq_alloc (T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.seq_alloc#canCall| (T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.seq_alloc#requires| (T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.seq_free (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_free#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_free#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.seq_unleash (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.seq_unleash#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.seq_unleash#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseqs__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseqs__raw#canCall| (T@U T@U) Bool)
(declare-fun |#$lseq| (T@U) T@U)
(declare-fun |LinearExtern.__default.lseqs__raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq__has (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq__has#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq__has#requires| (T@U T@U) Bool)
(declare-fun |lambda#131| (T@U) T@U)
(declare-fun |lambda#127| (T@U T@U) T@U)
(declare-fun |lambda#128| (T@U Int Int) T@U)
(declare-fun |lambda#130| (T@U) T@U)
(declare-fun |lambda#129| (Bool) T@U)
(declare-fun LinearExtern.__default.imagine__lseq__raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.imagine__lseq__raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_length_raw (T@U T@U) Int)
(declare-fun |LinearExtern.__default.lseq_length_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_length_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_alloc_raw (T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#canCall| (T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_alloc_raw#requires| (T@U Int) Bool)
(declare-fun LinearExtern.__default.lseq_free_raw (T@U T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_free_raw#canCall| (T@U T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_free_raw#requires| (T@U T@U) Bool)
(declare-fun LinearExtern.__default.lseq_swap_raw_fun (T@U T@U Int T@U) T@U)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |LinearExtern.__default.lseq_swap_raw_fun#requires| (T@U T@U Int T@U) Bool)
(declare-fun LinearExtern.__default.lseq_share_raw (T@U T@U Int) T@U)
(declare-fun |LinearExtern.__default.lseq_share_raw#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearExtern.__default.lseq_share_raw#requires| (T@U T@U Int) Bool)
(declare-fun |#ValueMessage.Delta.NoDelta| () T@U)
(declare-fun ValueMessage.Delta.NoDelta_q (T@U) Bool)
(declare-fun Tclass.ValueMessage.Delta () T@U)
(declare-fun |$IsA#ValueMessage.Delta| (T@U) Bool)
(declare-fun |ValueMessage.Delta#Equal| (T@U T@U) Bool)
(declare-fun Tclass.ValueMessage.__default () T@U)
(declare-fun ValueMessage.__default.NopDelta () T@U)
(declare-fun |ValueMessage.__default.NopDelta#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultValue#requires| () Bool)
(declare-fun |ValueType.__default.DefaultValue#canCall| () Bool)
(declare-fun ValueMessage.__default.CombineDeltas (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.CombineDeltas#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.CombineDeltas#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.__default.ApplyDelta (T@U T@U) T@U)
(declare-fun |ValueMessage.__default.ApplyDelta#canCall| (T@U T@U) Bool)
(declare-fun |ValueMessage.__default.ApplyDelta#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.__default.MakeValueMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.MakeValueMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.MakeValueMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.__default.EncodableMessage (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EncodableMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.__default.EvaluateMessage (T@U) T@U)
(declare-fun |ValueMessage.__default.EvaluateMessage#canCall| (T@U) Bool)
(declare-fun |ValueMessage.__default.EvaluateMessage#requires| (T@U) Bool)
(declare-fun ValueMessage.Message.value (T@U) T@U)
(declare-fun |ValueMessage.__default.Merge#requires| (T@U T@U) Bool)
(declare-fun ValueMessage.Message.delta (T@U) T@U)
(declare-fun |#ValueMessage.Message.Update| (T@U) T@U)
(declare-fun ValueMessage.__default.IdentityMessage () T@U)
(declare-fun |ValueMessage.__default.IdentityMessage#requires| () Bool)
(declare-fun |ValueMessage.__default.NopDelta#canCall| () Bool)
(declare-fun ValueMessage.__default.DefaultMessage () T@U)
(declare-fun |ValueMessage.__default.DefaultMessage#requires| () Bool)
(declare-fun ValueMessage.Message.Update_q (T@U) Bool)
(declare-fun Tclass.TotalKMMapMod.__default () T@U)
(declare-fun TotalKMMapMod.__default.TerminalValue (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TerminalValue#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.DefaultV () T@U)
(declare-fun |TotalKMMapMod.__default.DefaultV#requires| () Bool)
(declare-fun |ValueMessage.__default.DefaultMessage#canCall| () Bool)
(declare-fun TotalKMMapMod.__default.AnyKey (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.AnyKey#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.Defined (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#canCall| (T@U T@U) Bool)
(declare-fun |TotalKMMapMod.__default.Defined#requires| (T@U T@U) Bool)
(declare-fun TotalKMMapMod.__default.TotalMapIsFull (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#canCall| (T@U) Bool)
(declare-fun |TotalKMMapMod.__default.TotalMapIsFull#requires| (T@U) Bool)
(declare-fun TotalKMMapMod.__default.EmptyTotalMap () T@U)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#requires| () Bool)
(declare-fun |TotalKMMapMod.__default.DefaultV#canCall| () Bool)
(declare-fun |lambda#137| (T@U) T@U)
(declare-fun |lambda#138| (T@U) T@U)
(declare-fun TotalKMMapMod.__default.Witness () T@U)
(declare-fun |TotalKMMapMod.__default.Witness#requires| () Bool)
(declare-fun Tclass.TotalKMMapMod.TotalMap () T@U)
(declare-fun Tclass.LSNMod.__default () T@U)
(declare-fun Tclass.StampedMod.__default () T@U)
(declare-fun StampedMod.__default.Empty () T@U)
(declare-fun |StampedMod.__default.Empty#requires| () Bool)
(declare-fun |TotalKMMapMod.__default.EmptyTotalMap#canCall| () Bool)
(declare-fun Tclass.SequencesLite.__default () T@U)
(declare-fun SequencesLite.__default.Last (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.Last#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.Last#requires| (T@U T@U) Bool)
(declare-fun SequencesLite.__default.DropLast (T@U T@U) T@U)
(declare-fun |SequencesLite.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |SequencesLite.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Tclass.Mathematics.__default () T@U)
(declare-fun Mathematics.__default.min (Int Int) Int)
(declare-fun |Mathematics.__default.min#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.max (Int Int) Int)
(declare-fun |Mathematics.__default.max#requires| (Int Int) Bool)
(declare-fun Mathematics.__default.Set (T@U T@U) T@U)
(declare-fun |Mathematics.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.Set#requires| (T@U T@U) Bool)
(declare-fun |lambda#141| (T@U T@U Int) T@U)
(declare-fun Mathematics.__default.ISet (T@U T@U) T@U)
(declare-fun |Mathematics.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun |lambda#143| (T@U T@U) T@U)
(declare-fun Tclass.LinearSequence__i.__default () T@U)
(declare-fun LinearSequence__i.__default.seq__alloc__init (T@U Int T@U) T@U)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#canCall| (T@U Int T@U) Bool)
(declare-fun |LinearSequence__i.__default.seq__alloc__init#requires| (T@U Int T@U) Bool)
(declare-fun LinearSequence__i.__default.lseqs (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseqs#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseqs#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.imagine__lseq (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.imagine__lseq#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.imagine__lseq#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.linLast (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.linLast#canCall| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.operator_kcardinality_qlseq (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.linLast#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.ldroplast (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.ldroplast#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.ldroplast#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__has__all (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__has__all#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__length__as__uint64 (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__length__as__uint64#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__length (T@U T@U) Int)
(declare-fun |LinearSequence__i.__default.lseq__length#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__length#requires| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.operator_kcardinality_qlseq#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.operator_ksubscript_qlseq (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_ksubscript_qlseq#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.operator_kin_qlseq (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.operator_kin_qlseq#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__add (T@U T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__add#canCall| (T@U T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__add#requires| (T@U T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__peek (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__peek#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.lseq__peek#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__free__fun (T@U T@U) T@U)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__free__fun#requires| (T@U T@U) Bool)
(declare-fun LinearSequence__i.__default.lseq__take__fun (T@U T@U Int) T@U)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#canCall| (T@U T@U Int) Bool)
(declare-fun |LinearSequence__i.__default.lseq__take__fun#requires| (T@U T@U Int) Bool)
(declare-fun LinearSequence__i.__default.lseq__full (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#canCall| (T@U T@U) Bool)
(declare-fun |LinearSequence__i.__default.lseq__full#requires| (T@U T@U) Bool)
(declare-fun Tclass.Sequences.__default () T@U)
(declare-fun |Sequences.__default.Last#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.FirstOpt (T@U T@U) T@U)
(declare-fun |Sequences.__default.FirstOpt#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FirstOpt#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.DropLast (T@U T@U) T@U)
(declare-fun |Sequences.__default.DropLast#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.DropLast#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Set (T@U T@U) T@U)
(declare-fun |Sequences.__default.Set#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.Set#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.ISet (T@U T@U) T@U)
(declare-fun |Sequences.__default.ISet#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.ISet#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.NoDupes (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.NoDupes#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IndexOf (T@U T@U T@U) Int)
(declare-fun |Sequences.__default.IndexOf#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IndexOf#requires| (T@U T@U T@U) Bool)
(declare-fun |$let#0_i| (T@U T@U T@U) Int)
(declare-fun |$let#0$canCall| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Range (T@U Int) T@U)
(declare-fun |Sequences.__default.Range#canCall| (Int) Bool)
(declare-fun |Sequences.__default.Range#requires| (T@U Int) Bool)
(declare-fun Sequences.__default.Apply (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Apply#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Apply#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#149| (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#150| (T@U Int Int T@U T@U T@U T@U) T@U)
(declare-fun |lambda#152| (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun Sequences.__default.ApplyOpaque (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.ApplyOpaque#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.ApplyOpaque#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Filter (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Filter#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Filter#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldLeft (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldLeft#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldLeft#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldRight#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldRight#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldFromRight (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldFromRight#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldFromRight#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FoldSets (T@U T@U) T@U)
(declare-fun |Sequences.__default.FoldSets#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FoldSets#requires| (T@U T@U) Bool)
(declare-fun |lambda#164| () T@U)
(declare-fun |lambda#165| (T@U T@U) T@U)
(declare-fun |lambda#167| (T@U) T@U)
(declare-fun Sequences.__default.remove (T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.remove#canCall| (T@U T@U Int) Bool)
(declare-fun |Sequences.__default.remove#requires| (T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.RemoveOneValue (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.RemoveOneValue#canCall| (T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.NoDupes () T@U)
(declare-fun |Sequences.__default.RemoveOneValue#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |$let#4_i| (T@U T@U T@U) Int)
(declare-fun |$let#4$canCall| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Sequences._default.NoDupes0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.NoDupes () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes1 () T@U)
(declare-fun MoreFuel_Sequences._default.NoDupes2 () T@U)
(declare-fun Sequences.__default.insert (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.insert#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.insert#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.replace1with2#requires| (T@U T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.replace2with1 (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.replace2with1#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.replace2with1#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.concat (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concat3 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concat3#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.concat3#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.concatSeq (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.concatSeq#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.concatSeq#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsPrefix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsPrefix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.IsSuffix (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.IsSuffix#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.SeqIndexIterate (T@U T@U T@U T@U Int) T@U)
(declare-fun |Sequences.__default.SeqIndexIterate#canCall| (T@U T@U T@U Int) Bool)
(declare-fun |Sequences.__default.SeqIndexIterate#requires| (T@U T@U T@U T@U Int) Bool)
(declare-fun Sequences.__default.SeqIndex (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.SeqIndex#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqIndex#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.SeqIndexIterate () T@U)
(declare-fun Sequences.__default.SeqOfLength (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqOfLength#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.SeqOfLength#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqIndexUpdate (T@U T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.SeqIndexUpdate#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |Sequences.__default.SeqIndexUpdate#requires| (T@U T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.Zip (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Zip#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Zip#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.Unzip (T@U T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Unzip#canCall| (T@U T@U T@U) Bool)
(declare-fun |Sequences.__default.Unzip#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenShape (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.FlattenShape#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.FlattenShape#requires| (T@U T@U T@U) Bool)
(declare-fun Sequences.__default.FlattenLength (T@U T@U) Int)
(declare-fun |Sequences.__default.FlattenLength#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.FlattenLength#requires| (T@U T@U) Bool)
(declare-fun Sequences.__default.Flatten (T@U T@U T@U) T@U)
(declare-fun |Sequences.__default.Flatten#canCall| (T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.FlattenLength () T@U)
(declare-fun StartFuel_Sequences._default.FlattenShape () T@U)
(declare-fun |Sequences.__default.Flatten#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Sequences._default.FlattenShape0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.FlattenShape () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenShape1 () T@U)
(declare-fun Sequences.__default.FlattenIndex (T@U Int Int) Int)
(declare-fun |Sequences.__default.FlattenIndex#canCall| (T@U Int Int) Bool)
(declare-fun |Sequences.__default.FlattenIndex#requires| (T@U Int Int) Bool)
(declare-fun Sequences.__default.UnflattenIndex (T@U T@U Int) T@U)
(declare-fun |Sequences.__default.UnflattenIndex#canCall| (T@U Int) Bool)
(declare-fun |Sequences.__default.UnflattenIndex#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Sequences._default.FlattenLength0 () T@U)
(declare-fun StartFuelAssert_Sequences._default.FlattenLength () T@U)
(declare-fun MoreFuel_Sequences._default.FlattenLength1 () T@U)
(declare-fun Sequences.__default.seqMax (T@U T@U) Int)
(declare-fun |Sequences.__default.seqMax#canCall| (T@U) Bool)
(declare-fun |Sequences.__default.seqMax#requires| (T@U T@U) Bool)
(declare-fun |Mathematics.__default.max#canCall| (Int Int) Bool)
(declare-fun Sequences.__default.fill (T@U T@U Int T@U) T@U)
(declare-fun |Sequences.__default.fill#canCall| (T@U Int T@U) Bool)
(declare-fun |Sequences.__default.fill#requires| (T@U T@U Int T@U) Bool)
(declare-fun Sequences.__default.SeqHasUniqueElems (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#canCall| (T@U T@U) Bool)
(declare-fun |Sequences.__default.SeqHasUniqueElems#requires| (T@U T@U) Bool)
(declare-fun Tclass.MapRemove_s.__default () T@U)
(declare-fun MapRemove_s.__default.MapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |MapRemove_s.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |MapRemove_s.__default.MapRemove1#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#184| (T@U T@U T@U) T@U)
(declare-fun |lambda#185| (T@U) T@U)
(declare-fun Tclass.Maps.__default () T@U)
(declare-fun Maps.__default.IMapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsTo (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsTo#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapInjective (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInjective#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgreeOnKey#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapsAgreeOnKey (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapsAgreeOnKey#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IsSubIMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubIMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IsSubMap (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IsSubMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapsAgree (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapsAgree#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#190| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapRemoveStrong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemoveStrong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemoveStrong#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove0 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemove () T@U)
(declare-fun MoreFuel_Maps._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1 (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun Maps.__default.MapRemove1Strong (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRemove1Strong#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRemove1Strong#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove10 () T@U)
(declare-fun StartFuelAssert_MapRemove_s._default.MapRemove1 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove11 () T@U)
(declare-fun MoreFuel_MapRemove_s._default.MapRemove12 () T@U)
(declare-fun Maps.__default.IMapInvert (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapInvert#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapInvert#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |$let#8_a| (T@U T@U T@U T@U) T@U)
(declare-fun |$let#8$canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#195| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.IMapRemove (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRemove1 (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRemove1#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRemove1#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#206| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapIRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapIRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapIRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapRestrict (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapRestrict#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapRestrict#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapDisjointUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapDisjointUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapDisjointUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#221| (T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferA#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnionPreferB#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapUnionPreferA () T@U)
(declare-fun Maps.__default.IMapUnionPreferA (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferA#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferA#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapUnionPreferB (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnionPreferB#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnionPreferB#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.IMapUnion (T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.IMapUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.IMapUnion#requires| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.IMapUnionPreferA () T@U)
(declare-fun Maps.__default.MapDisjointUnion3 (T@U T@U T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapDisjointUnion3#canCall| (T@U T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Maps._default.MapDisjointUnion () T@U)
(declare-fun |Maps.__default.MapDisjointUnion3#requires| (T@U T@U T@U T@U T@U T@U) Bool)
(declare-fun |lambda#241| (T@U T@U T@U T@U T@U) T@U)
(declare-fun Maps.__default.MapToImap (T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapToImap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapToImap#requires| (T@U T@U T@U) Bool)
(declare-fun Maps.__default.MapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.MapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.MapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun Maps.__default.ImapLookupOption (T@U T@U T@U T@U) T@U)
(declare-fun |Maps.__default.ImapLookupOption#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Maps.__default.ImapLookupOption#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.KeyedMessage.KeyedMessage| (T@U T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.KeyedMessage_q (T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.KeyedMessage () T@U)
(declare-fun MsgHistoryMod.KeyedMessage.key (T@U) T@U)
(declare-fun MsgHistoryMod.KeyedMessage.message (T@U) T@U)
(declare-fun |$IsA#MsgHistoryMod.KeyedMessage| (T@U) Bool)
(declare-fun |MsgHistoryMod.KeyedMessage#Equal| (T@U T@U) Bool)
(declare-fun |#MsgHistoryMod.MsgHistory.MsgHistory| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.msgs (T@U) T@U)
(declare-fun MsgHistoryMod.MsgHistory.seqEnd (T@U) Int)
(declare-fun |$IsA#MsgHistoryMod.MsgHistory| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.WF#requires| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ContainsExactly (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ContainsExactly#requires| (T@U T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Contains (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Contains#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.LSNSet (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.LSNSet#requires| (T@U T@U) Bool)
(declare-fun |lambda#248| (T@U Int Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.IsEmpty (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IsEmpty#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Len (T@U) Int)
(declare-fun |MsgHistoryMod.MsgHistory.Len#canCall| (T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.Len#requires| (T@U) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanConcat (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanConcat#requires| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#canCall| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.CanFollow (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.Concat (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#canCall| (T@U T@U) Bool)
(declare-fun StartFuel_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun |MsgHistoryMod.MsgHistory.Concat#requires| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanFollow#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.ApplyToStampedMap (T@U T@U T@U) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| (T@U T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardRecent (T@U Int) T@U)
(declare-fun MsgHistoryMod.MsgHistory.CanDiscardTo (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.CanDiscardTo#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.DiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardOld#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.MaybeDiscardOld (T@U Int) T@U)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| (T@U Int) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.DiscardRecent#requires| (T@U Int) Bool)
(declare-fun MsgHistoryMod.MsgHistory.IncludesSubseq (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.MsgHistory.IncludesSubseq#requires| (T@U T@U) Bool)
(declare-fun Tclass.MsgHistoryMod.__default () T@U)
(declare-fun MsgHistoryMod.__default.EmptyHistoryAt (Int) T@U)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#canCall| (Int) Bool)
(declare-fun |MsgHistoryMod.__default.EmptyHistoryAt#requires| (Int) Bool)
(declare-fun MsgHistoryMod.__default.SingletonAt (Int T@U) T@U)
(declare-fun |MsgHistoryMod.__default.SingletonAt#canCall| (Int T@U) Bool)
(declare-fun |MsgHistoryMod.__default.SingletonAt#requires| (Int T@U) Bool)
(declare-fun MsgHistoryMod.__default.MapPlusHistory (T@U T@U) T@U)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#canCall| (T@U T@U) Bool)
(declare-fun |MsgHistoryMod.__default.MapPlusHistory#requires| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.Buffer_q (T@U) Bool)
(declare-fun Buffers.Buffer.mapp (T@U) T@U)
(declare-fun |$IsA#Buffers.Buffer| (T@U) Bool)
(declare-fun |Buffers.Buffer#Equal| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.Query (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.Query#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.Query#requires| (T@U T@U) Bool)
(declare-fun Buffers.Buffer.ApplyFilter (T@U T@U) T@U)
(declare-fun |Buffers.Buffer.ApplyFilter#canCall| (T@U T@U) Bool)
(declare-fun |Buffers.Buffer.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun Buffers.BufferStack.BufferStack_q (T@U) Bool)
(declare-fun Buffers.BufferStack.buffers (T@U) T@U)
(declare-fun |$IsA#Buffers.BufferStack| (T@U) Bool)
(declare-fun Buffers.BufferStack.QueryUpTo (T@U T@U T@U Int) T@U)
(declare-fun |Buffers.BufferStack.QueryUpTo#canCall| (T@U T@U Int) Bool)
(declare-fun |Buffers.BufferStack.QueryUpTo#requires| (T@U T@U T@U Int) Bool)
(declare-fun |Buffers.BufferStack.Query#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.ApplyFilter#requires| (T@U T@U) Bool)
(declare-fun |lambda#264| (T@U T@U) T@U)
(declare-fun |Buffers.BufferStack.PushBufferStack#requires| (T@U T@U) Bool)
(declare-fun |Buffers.BufferStack.Equivalent#requires| (T@U T@U) Bool)
(declare-fun Buffers.__default.AnyKey (T@U) Bool)
(declare-fun |Buffers.__default.AnyKey#canCall| (T@U) Bool)
(declare-fun Tclass.Buffers.__default () T@U)
(declare-fun |Buffers.__default.AnyKey#requires| (T@U) Bool)
(declare-fun Buffers.__default.Total (T@U) Bool)
(declare-fun |Buffers.__default.Total#canCall| (T@U) Bool)
(declare-fun |Buffers.__default.Total#requires| (T@U) Bool)
(declare-fun |Buffers.__default.AllKeys#requires| () Bool)
(declare-fun |lambda#279| (T@U) T@U)
(declare-fun |#MemtableMod.Memtable.Memtable| (T@U Int) T@U)
(declare-fun |$IsA#MemtableMod.Memtable| (T@U) Bool)
(declare-fun MemtableMod.Memtable.Get (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.Get#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Get#requires| (T@U T@U) Bool)
(declare-fun MemtableMod.Memtable.ApplyPut (T@U T@U) T@U)
(declare-fun |MemtableMod.Memtable.ApplyPut#canCall| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPut#requires| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.ApplyPuts#requires| (T@U T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Query#requires| (T@U T@U) Bool)
(declare-fun |MemtableMod.Memtable.Drain#requires| (T@U) Bool)
(declare-fun |MemtableMod.Memtable.IsEmpty#requires| (T@U) Bool)
(declare-fun Tclass.MemtableMod.__default () T@U)
(declare-fun |MemtableMod.__default.EmptyMemtable#requires| (Int) Bool)
(declare-fun Tclass.Sets.__default () T@U)
(declare-fun Sets.__default.SetRange (Int) T@U)
(declare-fun |Sets.__default.SetRange#requires| (Int) Bool)
(declare-fun Sets.__default.SetMax (T@U T@U) Int)
(declare-fun |Sets.__default.SetMax#canCall| (T@U) Bool)
(declare-fun |Sets.__default.SetMax#requires| (T@U T@U) Bool)
(declare-fun |$let#13_e| (T@U) Int)
(declare-fun |$let#13$canCall| (T@U) Bool)
(declare-fun Sets.__default.UnionSeqOfSets (T@U T@U T@U) T@U)
(declare-fun |Sets.__default.UnionSeqOfSets#canCall| (T@U T@U) Bool)
(declare-fun |Sets.__default.UnionSeqOfSets#requires| (T@U T@U T@U) Bool)
(declare-fun Tclass.SeqComparison.__default () T@U)
(declare-fun SeqComparison.__default.lte (T@U T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lte#requires| (T@U T@U T@U) Bool)
(declare-fun SeqComparison.__default.lt (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun |SeqComparison.__default.lt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_SeqComparison._default.lte () T@U)
(declare-fun Tclass.NativeArrays.__default () T@U)
(declare-fun Tclass.Byte__Order.__default () T@U)
(declare-fun Byte__Order.__default.SomeElement () Int)
(declare-fun |Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun Byte__Order.__default.lte (T@U Int Int) Bool)
(declare-fun |Byte__Order.__default.lte#canCall| (Int Int) Bool)
(declare-fun Byte__Order.__default.ltedef (T@U Int Int) Bool)
(declare-fun StartFuel_Byte_Order._default.ltedef () T@U)
(declare-fun |Byte__Order.__default.lte#requires| (T@U Int Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.ltedef0 () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.ltedef () T@U)
(declare-fun MoreFuel_Byte_Order._default.ltedef1 () T@U)
(declare-fun |Byte__Order.__default.ltedef#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.ltedef#requires| (T@U Int Int) Bool)
(declare-fun Byte__Order.__default.LargestLteDefn (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLteDefn#canCall| (T@U Int) Bool)
(declare-fun Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.IsSorted () T@U)
(declare-fun |Byte__Order.__default.LargestLteDefn#requires| (T@U T@U Int) Bool)
(declare-fun |Byte__Order.__default.lt#canCall| (Int Int) Bool)
(declare-fun Byte__Order.__default.lt (Int Int) Bool)
(declare-fun Byte__Order.__default.LargestLte (T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLte#canCall| (T@U Int) Bool)
(declare-fun StartFuel_Byte_Order._default.lte () T@U)
(declare-fun |Byte__Order.__default.LargestLte#requires| (T@U Int) Bool)
(declare-fun Byte__Order.__default.LargestLt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.LargestLt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.LargestLt#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Byte__Order.__default.IndexOfFirstGte (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.IndexOfFirstGte#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U Int Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U Int Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U Int Int Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U Int Int) Bool)
(declare-fun Byte__Order.__default.IndexOfFirstGt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.IndexOfFirstGt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U Int) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U Int Int Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U Int Int Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U Int Int Int) Bool)
(declare-fun Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U Int) Int)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.NotMinimum (T@U Int) Bool)
(declare-fun |Byte__Order.__default.NotMinimum#canCall| (Int) Bool)
(declare-fun |Byte__Order.__default.NotMinimum#requires| (T@U Int) Bool)
(declare-fun Byte__Order.__default.MapPivotedUnion (T@U T@U Int T@U) T@U)
(declare-fun |Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U Int T@U) Bool)
(declare-fun |Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U Int T@U) Bool)
(declare-fun |lambda#283| (T@U Int) T@U)
(declare-fun |lambda#285| (T@U T@U Int) T@U)
(declare-fun Byte__Order.__default.SetSuccessor (T@U Int) T@U)
(declare-fun |Byte__Order.__default.SetSuccessor#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.SetSuccessor#requires| (T@U Int) Bool)
(declare-fun |$let#16_next| (T@U Int) Int)
(declare-fun |$let#16$canCall| (T@U Int) Bool)
(declare-fun Byte__Order.__default.MapSuccessor (T@U T@U Int) T@U)
(declare-fun |Byte__Order.__default.MapSuccessor#canCall| (T@U T@U Int) Bool)
(declare-fun |Byte__Order.__default.MapSuccessor#requires| (T@U T@U Int) Bool)
(declare-fun Byte__Order.__default.SeqSuccessor (T@U Int) T@U)
(declare-fun |Byte__Order.__default.SeqSuccessor#canCall| (T@U Int) Bool)
(declare-fun |Byte__Order.__default.SeqSuccessor#requires| (T@U Int) Bool)
(declare-fun |lambda#295| (T@U T@U) T@U)
(declare-fun Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun StartFuel_Sequences._default.Unzip () T@U)
(declare-fun |Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Byte__Order.__default.minimum (T@U T@U) Int)
(declare-fun |Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#19_a| (T@U) Int)
(declare-fun |$let#19$canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.minimum () T@U)
(declare-fun Byte__Order.__default.maximum (T@U T@U) Int)
(declare-fun |Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#22_a| (T@U) Int)
(declare-fun |$let#22$canCall| (T@U) Bool)
(declare-fun Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Byte_Order._default.maximum () T@U)
(declare-fun |Byte__Order.__default.lt#requires| (Int Int) Bool)
(declare-fun Byte__Order.__default.Min (Int Int) Int)
(declare-fun |Byte__Order.__default.Min#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.Min#requires| (Int Int) Bool)
(declare-fun Byte__Order.__default.Max (Int Int) Int)
(declare-fun |Byte__Order.__default.Max#canCall| (Int Int) Bool)
(declare-fun |Byte__Order.__default.Max#requires| (Int Int) Bool)
(declare-fun |Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Byte__Order.__default.BiggestInSet (Int T@U) Bool)
(declare-fun |Byte__Order.__default.BiggestInSet#canCall| (Int T@U) Bool)
(declare-fun |Byte__Order.__default.BiggestInSet#requires| (Int T@U) Bool)
(declare-fun Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#25_e| (T@U) Int)
(declare-fun |$let#25$canCall| (T@U) Bool)
(declare-fun MoreFuel_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Lexicographic__Byte__Order.__default () T@U)
(declare-fun Lexicographic__Byte__Order.__default.SomeElement () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun Lexicographic__Byte__Order.__default.lte (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.ltedef (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lte#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.ltedef#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.ltedef#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsSmallestElement (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSmallestElement#requires| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.lt (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.NotMinimum (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.NotMinimum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.GetSmallestElement () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| () Bool)
(declare-fun |$let#28$canCall| () Bool)
(declare-fun |$let#28_b| () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| () Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLteDefn (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLteDefn#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLte (T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLte#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.LargestLt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.LargestLt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.IndexOfFirstGte (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U T@U Int Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U T@U Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U T@U Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U T@U Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IndexOfFirstGt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U T@U Int Int) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U T@U) Int)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.NotMinimum#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.MapPivotedUnion (T@U T@U T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#299| (T@U T@U) T@U)
(declare-fun |lambda#301| (T@U T@U) T@U)
(declare-fun Lexicographic__Byte__Order.__default.SetSuccessor (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SetSuccessor#requires| (T@U T@U) Bool)
(declare-fun |$let#31_next| (T@U T@U) T@U)
(declare-fun |$let#31$canCall| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.MapSuccessor (T@U T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.MapSuccessor#canCall| (T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.MapSuccessor#requires| (T@U T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SeqSuccessor (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SeqSuccessor#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Lexicographic__Byte__Order.__default.minimum (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#34_a| (T@U) T@U)
(declare-fun |$let#34$canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun Lexicographic__Byte__Order.__default.maximum (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#37_a| (T@U) T@U)
(declare-fun |$let#37$canCall| (T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun |Lexicographic__Byte__Order.__default.lt#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.Min (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.Min#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.Min#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.Max (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.Max#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.Max#requires| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.BiggestInSet (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (T@U T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.BiggestInSet#requires| (T@U T@U) Bool)
(declare-fun Lexicographic__Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Lexicographic__Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Lexicographic__Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#40_e| (T@U) T@U)
(declare-fun |$let#40$canCall| (T@U) Bool)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Lexicographic_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order.__default () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.Element_q (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.lt (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| () Bool)
(declare-fun |$let#43$canCall| () Bool)
(declare-fun |$let#43_b| () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| () Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SomeElement () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SomeElement#requires| () Bool)
(declare-fun |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.ToElements (T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| (T@U) Bool)
(declare-fun |lambda#315| (T@U) T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.lte (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.ltedef (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.Element#Equal| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsSorted (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.LargestLt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0 () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (T@U T@U T@U Int Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (T@U T@U T@U Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (T@U T@U Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| (T@U T@U T@U Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| (T@U T@U T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5 () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (T@U T@U T@U Int Int) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (T@U T@U Int Int) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| (T@U T@U T@U Int Int) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (T@U T@U T@U) Int)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion (T@U T@U T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |lambda#325| (T@U T@U) T@U)
(declare-fun |lambda#327| (T@U T@U) T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| (T@U T@U) Bool)
(declare-fun |$let#46_next| (T@U T@U) T@U)
(declare-fun |$let#46$canCall| (T@U T@U) Bool)
(declare-fun |$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor (T@U T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| (T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| (T@U T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| (T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| (T@U T@U T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.minimum (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| (T@U T@U) Bool)
(declare-fun |$let#49_a| (T@U) T@U)
(declare-fun |$let#49$canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.maximum (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| (T@U T@U) Bool)
(declare-fun |$let#52_a| (T@U) T@U)
(declare-fun |$let#52$canCall| (T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| (T@U T@U) Bool)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.Min (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.Max (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (T@U T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| (T@U T@U) Bool)
(declare-fun Upperbounded__Lexicographic__Byte__Order.__default.SortSet (T@U T@U) T@U)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (T@U) Bool)
(declare-fun |Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| (T@U T@U) Bool)
(declare-fun |$let#55_e| (T@U) T@U)
(declare-fun |$let#55$canCall| (T@U) Bool)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6 () T@U)
(declare-fun MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7 () T@U)
(declare-fun Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default () T@U)
(declare-fun Tclass.BoundedPivotsLib.__default () T@U)
(declare-fun BoundedPivotsLib.__default.ElementIsKey (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementIsKey#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementIsKey#requires| (T@U) Bool)
(declare-fun |KeyType.__default.MaxLen#canCall| () Bool)
(declare-fun BoundedPivotsLib.__default.ElementsAreKeys (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementsAreKeys#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ElementsAreKeys#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.KeyToElement (T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.KeyToElement#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.KeyToElement#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.KeysToElements (T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.KeysToElements#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.KeysToElements#requires| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.WFPivots#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.ContainsAllKeys (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsAllKeys#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsAllKeys#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.ContainsRange (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsRange#canCall| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ContainsRange#requires| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKey#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedKeySeq (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKeySeq#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedKeySeq#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.BoundedSortedKeySeq (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.ValidLeftCutOffKey (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.NumBuckets#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.PivotSize (T@U) Int)
(declare-fun |BoundedPivotsLib.__default.PivotSize#canCall| (T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotSize#requires| (T@U) Bool)
(declare-fun BoundedPivotsLib.__default.InBetween (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InBetween#canCall| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InBetween#requires| (T@U T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.Route#requires| (T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.InitPivotTable () T@U)
(declare-fun |BoundedPivotsLib.__default.InitPivotTable#requires| () Bool)
(declare-fun BoundedPivotsLib.__default.GetKey (T@U Int) T@U)
(declare-fun |BoundedPivotsLib.__default.GetKey#canCall| (T@U Int) Bool)
(declare-fun |BoundedPivotsLib.__default.GetKey#requires| (T@U Int) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotInsertable#canCall| (T@U Int T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotInsertable#requires| (T@U Int T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.InsertPivot#requires| (T@U Int T@U) Bool)
(declare-fun StartFuel_Sequences._default.insert () T@U)
(declare-fun BoundedPivotsLib.__default.CutoffForLeft (T@U T@U T@U) Int)
(declare-fun |BoundedPivotsLib.__default.CutoffForLeft#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.CutoffForLeft#requires| (T@U T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.SplitLeft (T@U T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.SplitLeft#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.SplitLeft#requires| (T@U T@U) Bool)
(declare-fun StartFuel_BoundedPivotsLib._default.CutoffForLeft () T@U)
(declare-fun BoundedPivotsLib.__default.CutoffForRight (T@U T@U T@U) Int)
(declare-fun |BoundedPivotsLib.__default.CutoffForRight#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.CutoffForRight#requires| (T@U T@U T@U) Bool)
(declare-fun BoundedPivotsLib.__default.SplitRight (T@U T@U) T@U)
(declare-fun |BoundedPivotsLib.__default.SplitRight#canCall| (T@U T@U) Bool)
(declare-fun |BoundedPivotsLib.__default.SplitRight#requires| (T@U T@U) Bool)
(declare-fun StartFuel_BoundedPivotsLib._default.CutoffForRight () T@U)
(declare-fun BoundedPivotsLib.__default.PivotTableBucketKeySet (T@U Int) T@U)
(declare-fun |BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (T@U Int) Bool)
(declare-fun |BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| (T@U Int) Bool)
(declare-fun |lambda#351| (T@U T@U T@U Int) T@U)
(declare-fun |#DomainMod.Domain.EmptyDomain| () T@U)
(declare-fun DomainMod.Domain.EmptyDomain_q (T@U) Bool)
(declare-fun DomainMod.Domain.SaneKeys (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.SaneKeys#canCall| (T@U) Bool)
(declare-fun |DomainMod.Domain.SaneKeys#requires| (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.WF#canCall| (T@U) Bool)
(declare-fun |DomainMod.Domain.WF#requires| (T@U) Bool)
(declare-fun StartFuel_DomainMod.Domain.SaneKeys () T@U)
(declare-fun |DomainMod.Domain.Contains#canCall| (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.Contains#requires| (T@U T@U) Bool)
(declare-fun |DomainMod.Domain.KeySet#requires| (T@U) Bool)
(declare-fun |lambda#353| (T@U T@U) T@U)
(declare-fun Tclass.DomainMod.__default () T@U)
(declare-fun |DomainMod.__default.TotalDomain#requires| () Bool)
(declare-fun |#SplitRequestMod.SplitRequest.SplitLeaf| (Int T@U) T@U)
(declare-fun |#SplitRequestMod.SplitRequest.SplitIndex| (Int Int) T@U)
(declare-fun |$IsA#SplitRequestMod.SplitRequest| (T@U) Bool)
(declare-fun Tclass.SplitRequestMod.__default () T@U)
(declare-fun MapType6Select (T@U T@U T@U) T@U)
(declare-fun |lambda#0| (T@U T@U T@U Bool) T@U)
(declare-fun MapType6Type (T@T T@T) T@T)
(declare-fun MapType6TypeInv0 (T@T) T@T)
(declare-fun MapType6TypeInv1 (T@T) T@T)
(declare-fun MapType6Store (T@U T@U T@U T@U) T@U)
(declare-fun |lambda#1| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#2| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#3| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#4| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#5| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#6| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#7| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#8| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#9| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#10| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#11| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#12| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#13| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#14| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#15| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#16| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#17| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#18| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#19| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#20| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#21| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#22| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#23| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#24| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#25| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#26| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#27| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#28| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#29| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#30| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#31| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#32| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#33| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#34| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#35| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#36| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#37| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#38| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#39| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#40| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#41| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#42| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#43| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#46| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#47| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#49| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#50| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#51| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#52| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#53| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#54| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#55| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#56| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#57| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#58| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#59| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#60| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#61| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#62| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#63| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#64| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#65| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#66| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#67| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#68| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#69| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#70| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#71| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#72| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#73| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#74| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#75| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#76| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#77| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#78| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#79| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#80| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#81| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#82| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#83| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#84| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#85| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#86| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#87| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#88| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#89| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#90| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#91| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#92| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#93| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#94| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#95| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#96| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#97| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#98| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#99| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#100| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#101| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#102| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#103| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#104| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#105| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#106| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#107| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#108| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#109| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#110| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#111| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#112| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#113| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#114| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#115| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#116| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#117| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#118| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#119| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#120| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#121| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#122| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#123| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#124| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#125| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#126| (T@U T@U T@U Bool) T@U)
(declare-fun |lambda#151| (T@U Int Int T@U T@U T@U T@U T@U T@U T@U T@U T@U T@U) T@U)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor intType) 0) (= (Ctor realType) 1)) (= (Ctor boolType) 2)) (= (Ctor rmodeType) 3)) (= (Ctor stringType) 4)) (= (Ctor regexType) 5)) (forall ((arg0 Int) ) (! (= (U_2_int (int_2_U arg0)) arg0)
 :qid |typeInv:U_2_int|
 :pattern ( (int_2_U arg0))
))) (forall ((x T@U) ) (!  (=> (= (type x) intType) (= (int_2_U (U_2_int x)) x))
 :qid |cast:U_2_int|
 :pattern ( (U_2_int x))
))) (forall ((arg0@@0 Int) ) (! (= (type (int_2_U arg0@@0)) intType)
 :qid |funType:int_2_U|
 :pattern ( (int_2_U arg0@@0))
))) (forall ((arg0@@1 Real) ) (! (= (U_2_real (real_2_U arg0@@1)) arg0@@1)
 :qid |typeInv:U_2_real|
 :pattern ( (real_2_U arg0@@1))
))) (forall ((x@@0 T@U) ) (!  (=> (= (type x@@0) realType) (= (real_2_U (U_2_real x@@0)) x@@0))
 :qid |cast:U_2_real|
 :pattern ( (U_2_real x@@0))
))) (forall ((arg0@@2 Real) ) (! (= (type (real_2_U arg0@@2)) realType)
 :qid |funType:real_2_U|
 :pattern ( (real_2_U arg0@@2))
))) (forall ((arg0@@3 Bool) ) (! (= (U_2_bool (bool_2_U arg0@@3)) arg0@@3)
 :qid |typeInv:U_2_bool|
 :pattern ( (bool_2_U arg0@@3))
))) (forall ((x@@1 T@U) ) (!  (=> (= (type x@@1) boolType) (= (bool_2_U (U_2_bool x@@1)) x@@1))
 :qid |cast:U_2_bool|
 :pattern ( (U_2_bool x@@1))
))) (forall ((arg0@@4 Bool) ) (! (= (type (bool_2_U arg0@@4)) boolType)
 :qid |funType:bool_2_U|
 :pattern ( (bool_2_U arg0@@4))
))) (forall ((arg0@@5 RoundingMode) ) (! (= (U_2_rmode (rmode_2_U arg0@@5)) arg0@@5)
 :qid |typeInv:U_2_rmode|
 :pattern ( (rmode_2_U arg0@@5))
))) (forall ((x@@2 T@U) ) (!  (=> (= (type x@@2) rmodeType) (= (rmode_2_U (U_2_rmode x@@2)) x@@2))
 :qid |cast:U_2_rmode|
 :pattern ( (U_2_rmode x@@2))
))) (forall ((arg0@@6 RoundingMode) ) (! (= (type (rmode_2_U arg0@@6)) rmodeType)
 :qid |funType:rmode_2_U|
 :pattern ( (rmode_2_U arg0@@6))
))) (forall ((arg0@@7 String) ) (! (= (U_2_string (string_2_U arg0@@7)) arg0@@7)
 :qid |typeInv:U_2_string|
 :pattern ( (string_2_U arg0@@7))
))) (forall ((x@@3 T@U) ) (!  (=> (= (type x@@3) stringType) (= (string_2_U (U_2_string x@@3)) x@@3))
 :qid |cast:U_2_string|
 :pattern ( (U_2_string x@@3))
))) (forall ((arg0@@8 String) ) (! (= (type (string_2_U arg0@@8)) stringType)
 :qid |funType:string_2_U|
 :pattern ( (string_2_U arg0@@8))
))) (forall ((arg0@@9 (RegEx String)) ) (! (= (U_2_regex (regex_2_U arg0@@9)) arg0@@9)
 :qid |typeInv:U_2_regex|
 :pattern ( (regex_2_U arg0@@9))
))) (forall ((x@@4 T@U) ) (!  (=> (= (type x@@4) regexType) (= (regex_2_U (U_2_regex x@@4)) x@@4))
 :qid |cast:U_2_regex|
 :pattern ( (U_2_regex x@@4))
))) (forall ((arg0@@10 (RegEx String)) ) (! (= (type (regex_2_U arg0@@10)) regexType)
 :qid |funType:regex_2_U|
 :pattern ( (regex_2_U arg0@@10))
))))
(assert (forall ((x@@5 T@U) ) (! (UOrdering2 x@@5 x@@5)
 :qid |bg:subtype-refl|
 :no-pattern (U_2_int x@@5)
 :no-pattern (U_2_bool x@@5)
)))
(assert (forall ((x@@6 T@U) (y T@U) (z T@U) ) (! (let ((alpha (type x@@6)))
 (=> (and (and (= (type y) alpha) (= (type z) alpha)) (and (UOrdering2 x@@6 y) (UOrdering2 y z))) (UOrdering2 x@@6 z)))
 :qid |bg:subtype-trans|
 :pattern ( (UOrdering2 x@@6 y) (UOrdering2 y z))
)))
(assert (forall ((x@@7 T@U) (y@@0 T@U) ) (! (let ((alpha@@0 (type x@@7)))
 (=> (= (type y@@0) alpha@@0) (=> (and (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7)) (= x@@7 y@@0))))
 :qid |bg:subtype-antisymm|
 :pattern ( (UOrdering2 x@@7 y@@0) (UOrdering2 y@@0 x@@7))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (Ctor TyType) 6) (= (type TBool) TyType)) (= (type TChar) TyType)) (= (type TInt) TyType)) (= (type TReal) TyType)) (= (type TORDINAL) TyType)) (= (Ctor TyTagType) 7)) (= (type TagBool) TyTagType)) (= (type TagChar) TyTagType)) (= (type TagInt) TyTagType)) (= (type TagReal) TyTagType)) (= (type TagORDINAL) TyTagType)) (= (type TagSet) TyTagType)) (= (type TagISet) TyTagType)) (= (type TagMultiSet) TyTagType)) (= (type TagSeq) TyTagType)) (= (type TagMap) TyTagType)) (= (type TagIMap) TyTagType)) (= (type TagClass) TyTagType)) (= (Ctor ClassNameType) 8)) (= (type class._System.int) ClassNameType)) (= (type class._System.bool) ClassNameType)) (= (type class._System.set) ClassNameType)) (= (type class._System.seq) ClassNameType)) (= (type class._System.multiset) ClassNameType)) (forall ((arg0@@11 T@T) ) (! (= (Ctor (FieldType arg0@@11)) 9)
 :qid |ctor:FieldType|
))) (forall ((arg0@@12 T@T) ) (! (= (FieldTypeInv0 (FieldType arg0@@12)) arg0@@12)
 :qid |typeInv:FieldTypeInv0|
 :pattern ( (FieldType arg0@@12))
))) (= (type alloc) (FieldType boolType))) (= (Ctor NameFamilyType) 10)) (= (type allocName) NameFamilyType)) (= (type Tagclass._System.nat) TyTagType)) (= (type class._System.object?) ClassNameType)) (= (type Tagclass._System.object?) TyTagType)) (= (type Tagclass._System.object) TyTagType)) (= (type class._System.array?) ClassNameType)) (= (type Tagclass._System.array?) TyTagType)) (= (type Tagclass._System.array) TyTagType)) (= (type Tagclass._System.___hFunc1) TyTagType)) (= (type Tagclass._System.___hPartialFunc1) TyTagType)) (= (type Tagclass._System.___hTotalFunc1) TyTagType)) (= (type Tagclass._System.___hFunc0) TyTagType)) (= (type Tagclass._System.___hPartialFunc0) TyTagType)) (= (type Tagclass._System.___hTotalFunc0) TyTagType)) (= (type class._System.__default) ClassNameType)) (= (type Tagclass._System.__default) TyTagType)) (= (type Tagclass._System.___hFunc2) TyTagType)) (= (type Tagclass._System.___hPartialFunc2) TyTagType)) (= (type Tagclass._System.___hTotalFunc2) TyTagType)) (= (Ctor DtCtorIdType) 11)) (= (type |##_System._tuple#2._#Make2|) DtCtorIdType)) (= (type Tagclass._System.Tuple2) TyTagType)) (= (type class._System.Tuple2) ClassNameType)) (= (type Tagclass._System.___hFunc4) TyTagType)) (= (type Tagclass._System.___hPartialFunc4) TyTagType)) (= (type Tagclass._System.___hTotalFunc4) TyTagType)) (= (type Tagclass._System.___hFunc3) TyTagType)) (= (type Tagclass._System.___hPartialFunc3) TyTagType)) (= (type Tagclass._System.___hTotalFunc3) TyTagType)) (= (type Tagclass._System.___hFunc2OSO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2OSO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2OSO) TyTagType)) (= (type Tagclass._System.___hFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hPartialFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hTotalFunc3LLOO) TyTagType)) (= (type Tagclass._System.___hFunc1OS) TyTagType)) (= (type Tagclass._System.___hPartialFunc1OS) TyTagType)) (= (type Tagclass._System.___hTotalFunc1OS) TyTagType)) (= (type Tagclass._System.___hFunc0L) TyTagType)) (= (type Tagclass._System.___hPartialFunc0L) TyTagType)) (= (type Tagclass._System.___hTotalFunc0L) TyTagType)) (= (type Tagclass._System.___hFunc2LOO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2LOO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2LOO) TyTagType)) (= (type |##_System._tuple#0._#Make0|) DtCtorIdType)) (= (type Tagclass._System.Tuple0) TyTagType)) (= (type class._System.Tuple0) ClassNameType)) (= (type Tagclass._System.___hFunc1OL) TyTagType)) (= (type Tagclass._System.___hPartialFunc1OL) TyTagType)) (= (type Tagclass._System.___hTotalFunc1OL) TyTagType)) (= (type Tagclass._System.___hFunc1LO) TyTagType)) (= (type Tagclass._System.___hPartialFunc1LO) TyTagType)) (= (type Tagclass._System.___hTotalFunc1LO) TyTagType)) (= (type |##_System._tuple#2OLL._#Make2|) DtCtorIdType)) (= (type Tagclass._System.Tuple2OLL) TyTagType)) (= (type class._System.Tuple2OLL) ClassNameType)) (= (type Tagclass._System.___hFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hPartialFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hTotalFunc3LLOL) TyTagType)) (= (type Tagclass._System.___hFunc2SSO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2SSO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2SSO) TyTagType)) (= (type Tagclass._System.___hFunc2LLO) TyTagType)) (= (type Tagclass._System.___hPartialFunc2LLO) TyTagType)) (= (type Tagclass._System.___hTotalFunc2LLO) TyTagType)) (= (type Tagclass._System.___hFunc1SS) TyTagType)) (= (type Tagclass._System.___hPartialFunc1SS) TyTagType)) (= (type Tagclass._System.___hTotalFunc1SS) TyTagType)) (= (type Tagclass._System.___hFunc1LL) TyTagType)) (= (type Tagclass._System.___hPartialFunc1LL) TyTagType)) (= (type Tagclass._System.___hTotalFunc1LL) TyTagType)) (= (type |##PivotBetree.TransitionLabel.QueryLabel|) DtCtorIdType)) (= (type Tagclass.KeyType.Key) TyTagType)) (= (type Tagclass.ValueType.Value) TyTagType)) (= (type Tagclass.PivotBetree.TransitionLabel) TyTagType)) (= (type |##PivotBetree.TransitionLabel.PutLabel|) DtCtorIdType)) (= (type Tagclass.MsgHistoryMod.MsgHistory) TyTagType)) (= (type |##PivotBetree.TransitionLabel.QueryEndLsnLabel|) DtCtorIdType)) (= (type |##PivotBetree.TransitionLabel.FreezeAsLabel|) DtCtorIdType)) (= (type Tagclass.PivotBetree.BetreeNode) TyTagType)) (= (type Tagclass.StampedMod.Stamped) TyTagType)) (= (type |##PivotBetree.TransitionLabel.InternalLabel|) DtCtorIdType)) (= (type class.PivotBetree.TransitionLabel) ClassNameType)) (= (type |##PivotBetree.BetreeNode.Nil|) DtCtorIdType)) (= (type |##PivotBetree.BetreeNode.BetreeNode|) DtCtorIdType)) (= (type Tagclass.Buffers.BufferStack) TyTagType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order.Element) TyTagType)) (= (type class.PivotBetree.BetreeNode) ClassNameType)) (= (type Tagclass.DomainMod.Domain) TyTagType)) (= (type Tagclass.SplitRequestMod.SplitRequest) TyTagType)) (= (type Tagclass.NativeTypes.byte) TyTagType)) (= (type |##PivotBetree.QueryReceiptLine.QueryReceiptLine|) DtCtorIdType)) (= (type Tagclass.ValueMessage.Message) TyTagType)) (= (type Tagclass.PivotBetree.QueryReceiptLine) TyTagType)) (= (type class.PivotBetree.QueryReceiptLine) ClassNameType)) (= (type |##PivotBetree.QueryReceipt.QueryReceipt|) DtCtorIdType)) (= (type Tagclass.PivotBetree.QueryReceipt) TyTagType)) (= (type class.PivotBetree.QueryReceipt) ClassNameType)) (= (type |##PivotBetree.Variables.Variables|) DtCtorIdType)) (= (type Tagclass.MemtableMod.Memtable) TyTagType)) (= (type Tagclass.PivotBetree.Variables) TyTagType)) (= (type class.PivotBetree.Variables) ClassNameType)) (= (type |##PivotBetree.Path.Path|) DtCtorIdType)) (= (type Tagclass.PivotBetree.Path) TyTagType)) (= (type class.PivotBetree.Path) ClassNameType)) (= (type |##PivotBetree.Step.QueryStep|) DtCtorIdType)) (= (type Tagclass.PivotBetree.Step) TyTagType)) (= (type |##PivotBetree.Step.PutStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.QueryEndLsnStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.FreezeAsStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalGrowStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalSplitStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalFlushMemtableStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalFlushStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalCompactStep|) DtCtorIdType)) (= (type |##PivotBetree.Step.InternalNoOpStep|) DtCtorIdType)) (= (type class.PivotBetree.Step) ClassNameType)) (= (type class.PivotBetree.__default) ClassNameType)) (= (type Tagclass.PivotBetree.__default) TyTagType)) (= (type Tagclass.Buffers.Buffer) TyTagType)) (= (type |##Options.Option.None|) DtCtorIdType)) (= (type Tagclass.Options.Option) TyTagType)) (= (type |##Options.Option.Some|) DtCtorIdType)) (= (type class.Options.Option) ClassNameType)) (= (type class.Options.__default) ClassNameType)) (= (type Tagclass.Options.__default) TyTagType)) (= (type Tagclass.NativeTypes.sbyte) TyTagType)) (= (type class.NativeTypes.sbyte) ClassNameType)) (= (type class.NativeTypes.byte) ClassNameType)) (= (type Tagclass.NativeTypes.int16) TyTagType)) (= (type class.NativeTypes.int16) ClassNameType)) (= (type Tagclass.NativeTypes.uint16) TyTagType)) (= (type class.NativeTypes.uint16) ClassNameType)) (= (type Tagclass.NativeTypes.int32) TyTagType)) (= (type class.NativeTypes.int32) ClassNameType)) (= (type Tagclass.NativeTypes.uint32) TyTagType)) (= (type class.NativeTypes.uint32) ClassNameType)) (= (type Tagclass.NativeTypes.int64) TyTagType)) (= (type class.NativeTypes.int64) ClassNameType)) (= (type Tagclass.NativeTypes.uint64) TyTagType)) (= (type class.NativeTypes.uint64) ClassNameType)) (= (type Tagclass.NativeTypes.nat8) TyTagType)) (= (type class.NativeTypes.nat8) ClassNameType)) (= (type Tagclass.NativeTypes.nat16) TyTagType)) (= (type class.NativeTypes.nat16) ClassNameType)) (= (type Tagclass.NativeTypes.nat32) TyTagType)) (= (type class.NativeTypes.nat32) ClassNameType)) (= (type Tagclass.NativeTypes.nat64) TyTagType)) (= (type class.NativeTypes.nat64) ClassNameType)) (= (type Tagclass.NativeTypes.uint128) TyTagType)) (= (type class.NativeTypes.uint128) ClassNameType)) (= (type class.NativeTypes.__default) ClassNameType)) (= (type Tagclass.NativeTypes.__default) TyTagType)) (= (type class.KeyType.__default) ClassNameType)) (= (type Tagclass.KeyType.__default) TyTagType)) (= (type class.ValueType.__default) ClassNameType)) (= (type Tagclass.ValueType.__default) TyTagType)) (= (type class.LinearMaybe.predefined) ClassNameType)) (= (type class.LinearMaybe.__default) ClassNameType)) (= (type Tagclass.LinearMaybe.__default) TyTagType)) (= (type class.LinearExtern.predefined) ClassNameType)) (= (type class.LinearExtern.__default) ClassNameType)) (= (type Tagclass.LinearExtern.__default) TyTagType)) (= (type |##ValueMessage.Delta.NoDelta|) DtCtorIdType)) (= (type Tagclass.ValueMessage.Delta) TyTagType)) (= (type class.ValueMessage.Delta) ClassNameType)) (= (type class.ValueMessage.__default) ClassNameType)) (= (type Tagclass.ValueMessage.__default) TyTagType)) (= (type |##ValueMessage.Message.Define|) DtCtorIdType)) (= (type |##ValueMessage.Message.Update|) DtCtorIdType)) (= (type class.ValueMessage.Message) ClassNameType)) (= (type class.TotalKMMapMod.__default) ClassNameType)) (= (type Tagclass.TotalKMMapMod.__default) TyTagType)) (= (type Tagclass.TotalKMMapMod.TotalMap) TyTagType)) (= (type class.LSNMod.__default) ClassNameType)) (= (type Tagclass.LSNMod.__default) TyTagType)) (= (type |##StampedMod.Stamped.Stamped|) DtCtorIdType)) (= (type class.StampedMod.Stamped) ClassNameType)) (= (type class.StampedMod.__default) ClassNameType)) (= (type Tagclass.StampedMod.__default) TyTagType)) (= (type class.SequencesLite.__default) ClassNameType)) (= (type Tagclass.SequencesLite.__default) TyTagType)) (= (type class.Mathematics.__default) ClassNameType)) (= (type Tagclass.Mathematics.__default) TyTagType)) (= (type class.LinearSequence__i.__default) ClassNameType)) (= (type Tagclass.LinearSequence__i.__default) TyTagType)) (= (type class.Sequences.__default) ClassNameType)) (= (type Tagclass.Sequences.__default) TyTagType)) (= (type class.MapRemove_s.__default) ClassNameType)) (= (type Tagclass.MapRemove_s.__default) TyTagType)) (= (type class.Maps.__default) ClassNameType)) (= (type Tagclass.Maps.__default) TyTagType)) (= (type |##MsgHistoryMod.KeyedMessage.KeyedMessage|) DtCtorIdType)) (= (type Tagclass.MsgHistoryMod.KeyedMessage) TyTagType)) (= (type class.MsgHistoryMod.KeyedMessage) ClassNameType)) (= (type |##MsgHistoryMod.MsgHistory.MsgHistory|) DtCtorIdType)) (= (type class.MsgHistoryMod.MsgHistory) ClassNameType)) (= (type class.MsgHistoryMod.__default) ClassNameType)) (= (type Tagclass.MsgHistoryMod.__default) TyTagType)) (= (type |##Buffers.Buffer.Buffer|) DtCtorIdType)) (= (type class.Buffers.Buffer) ClassNameType)) (= (type |##Buffers.BufferStack.BufferStack|) DtCtorIdType)) (= (type class.Buffers.BufferStack) ClassNameType)) (= (type class.Buffers.__default) ClassNameType)) (= (type Tagclass.Buffers.__default) TyTagType)) (= (type |##MemtableMod.Memtable.Memtable|) DtCtorIdType)) (= (type class.MemtableMod.Memtable) ClassNameType)) (= (type class.MemtableMod.__default) ClassNameType)) (= (type Tagclass.MemtableMod.__default) TyTagType)) (= (type class.Sets.__default) ClassNameType)) (= (type Tagclass.Sets.__default) TyTagType)) (= (type class.SeqComparison.__default) ClassNameType)) (= (type Tagclass.SeqComparison.__default) TyTagType)) (= (type class.NativeArrays.__default) ClassNameType)) (= (type Tagclass.NativeArrays.__default) TyTagType)) (= (type class.Byte__Order.__default) ClassNameType)) (= (type Tagclass.Byte__Order.__default) TyTagType)) (= (type class.Lexicographic__Byte__Order.__default) ClassNameType)) (= (type Tagclass.Lexicographic__Byte__Order.__default) TyTagType)) (= (type class.Upperbounded__Lexicographic__Byte__Order.__default) ClassNameType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order.__default) TyTagType)) (= (type |##Upperbounded_Lexicographic_Byte_Order.Element.Element|) DtCtorIdType)) (= (type |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) DtCtorIdType)) (= (type class.Upperbounded__Lexicographic__Byte__Order.Element) ClassNameType)) (= (type class.Upperbounded__Lexicographic__Byte__Order__Impl.__default) ClassNameType)) (= (type Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) TyTagType)) (= (type class.BoundedPivotsLib.__default) ClassNameType)) (= (type Tagclass.BoundedPivotsLib.__default) TyTagType)) (= (type |##DomainMod.Domain.EmptyDomain|) DtCtorIdType)) (= (type |##DomainMod.Domain.Domain|) DtCtorIdType)) (= (type class.DomainMod.Domain) ClassNameType)) (= (type class.DomainMod.__default) ClassNameType)) (= (type Tagclass.DomainMod.__default) TyTagType)) (= (type |##SplitRequestMod.SplitRequest.SplitLeaf|) DtCtorIdType)) (= (type |##SplitRequestMod.SplitRequest.SplitIndex|) DtCtorIdType)) (= (type class.SplitRequestMod.SplitRequest) ClassNameType)) (= (type class.SplitRequestMod.__default) ClassNameType)) (= (type Tagclass.SplitRequestMod.__default) TyTagType)) (= (Ctor TyTagFamilyType) 12)) (= (type tytagFamily$nat) TyTagFamilyType)) (= (type tytagFamily$object) TyTagFamilyType)) (= (type tytagFamily$array) TyTagFamilyType)) (= (type |tytagFamily$_#Func1|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1|) TyTagFamilyType)) (= (type |tytagFamily$_#Func0|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc0|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc0|) TyTagFamilyType)) (= (type tytagFamily$_default) TyTagFamilyType)) (= (type |tytagFamily$_#Func2|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#2|) TyTagFamilyType)) (= (type |tytagFamily$_#Func4|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc4|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc4|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2OSO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3LLOO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1OS|) TyTagFamilyType)) (= (type |tytagFamily$_#Func0L|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc0L|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc0L|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2LOO|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#0|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1OL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1LO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1LO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1LO|) TyTagFamilyType)) (= (type |tytagFamily$_tuple#2OLL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc3LLOL|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2SSO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc2LLO|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1SS|) TyTagFamilyType)) (= (type |tytagFamily$_#Func1LL|) TyTagFamilyType)) (= (type |tytagFamily$_#PartialFunc1LL|) TyTagFamilyType)) (= (type |tytagFamily$_#TotalFunc1LL|) TyTagFamilyType)) (= (type tytagFamily$Key) TyTagFamilyType)) (= (type tytagFamily$Value) TyTagFamilyType)) (= (type tytagFamily$TransitionLabel) TyTagFamilyType)) (= (type tytagFamily$MsgHistory) TyTagFamilyType)) (= (type tytagFamily$BetreeNode) TyTagFamilyType)) (= (type tytagFamily$Stamped) TyTagFamilyType)) (= (type tytagFamily$BufferStack) TyTagFamilyType)) (= (type tytagFamily$Element) TyTagFamilyType)) (= (type tytagFamily$Domain) TyTagFamilyType)) (= (type tytagFamily$SplitRequest) TyTagFamilyType)) (= (type tytagFamily$byte) TyTagFamilyType)) (= (type tytagFamily$Message) TyTagFamilyType)) (= (type tytagFamily$QueryReceiptLine) TyTagFamilyType)) (= (type tytagFamily$QueryReceipt) TyTagFamilyType)) (= (type tytagFamily$Memtable) TyTagFamilyType)) (= (type tytagFamily$Variables) TyTagFamilyType)) (= (type tytagFamily$Path) TyTagFamilyType)) (= (type tytagFamily$Step) TyTagFamilyType)) (= (type tytagFamily$Buffer) TyTagFamilyType)) (= (type tytagFamily$Option) TyTagFamilyType)) (= (type tytagFamily$sbyte) TyTagFamilyType)) (= (type tytagFamily$int16) TyTagFamilyType)) (= (type tytagFamily$uint16) TyTagFamilyType)) (= (type tytagFamily$int32) TyTagFamilyType)) (= (type tytagFamily$uint32) TyTagFamilyType)) (= (type tytagFamily$int64) TyTagFamilyType)) (= (type tytagFamily$uint64) TyTagFamilyType)) (= (type tytagFamily$nat8) TyTagFamilyType)) (= (type tytagFamily$nat16) TyTagFamilyType)) (= (type tytagFamily$nat32) TyTagFamilyType)) (= (type tytagFamily$nat64) TyTagFamilyType)) (= (type tytagFamily$uint128) TyTagFamilyType)) (= (type tytagFamily$Delta) TyTagFamilyType)) (= (type tytagFamily$TotalMap) TyTagFamilyType)) (= (type tytagFamily$KeyedMessage) TyTagFamilyType)))
(assert (distinct TBool TChar TInt TReal TORDINAL TagBool TagChar TagInt TagReal TagORDINAL TagSet TagISet TagMultiSet TagSeq TagMap TagIMap TagClass class._System.int class._System.bool class._System.set class._System.seq class._System.multiset alloc allocName Tagclass._System.nat class._System.object? Tagclass._System.object? Tagclass._System.object class._System.array? Tagclass._System.array? Tagclass._System.array Tagclass._System.___hFunc1 Tagclass._System.___hPartialFunc1 Tagclass._System.___hTotalFunc1 Tagclass._System.___hFunc0 Tagclass._System.___hPartialFunc0 Tagclass._System.___hTotalFunc0 class._System.__default Tagclass._System.__default Tagclass._System.___hFunc2 Tagclass._System.___hPartialFunc2 Tagclass._System.___hTotalFunc2 |##_System._tuple#2._#Make2| Tagclass._System.Tuple2 class._System.Tuple2 Tagclass._System.___hFunc4 Tagclass._System.___hPartialFunc4 Tagclass._System.___hTotalFunc4 Tagclass._System.___hFunc3 Tagclass._System.___hPartialFunc3 Tagclass._System.___hTotalFunc3 Tagclass._System.___hFunc2OSO Tagclass._System.___hPartialFunc2OSO Tagclass._System.___hTotalFunc2OSO Tagclass._System.___hFunc3LLOO Tagclass._System.___hPartialFunc3LLOO Tagclass._System.___hTotalFunc3LLOO Tagclass._System.___hFunc1OS Tagclass._System.___hPartialFunc1OS Tagclass._System.___hTotalFunc1OS Tagclass._System.___hFunc0L Tagclass._System.___hPartialFunc0L Tagclass._System.___hTotalFunc0L Tagclass._System.___hFunc2LOO Tagclass._System.___hPartialFunc2LOO Tagclass._System.___hTotalFunc2LOO |##_System._tuple#0._#Make0| Tagclass._System.Tuple0 class._System.Tuple0 Tagclass._System.___hFunc1OL Tagclass._System.___hPartialFunc1OL Tagclass._System.___hTotalFunc1OL Tagclass._System.___hFunc1LO Tagclass._System.___hPartialFunc1LO Tagclass._System.___hTotalFunc1LO |##_System._tuple#2OLL._#Make2| Tagclass._System.Tuple2OLL class._System.Tuple2OLL Tagclass._System.___hFunc3LLOL Tagclass._System.___hPartialFunc3LLOL Tagclass._System.___hTotalFunc3LLOL Tagclass._System.___hFunc2SSO Tagclass._System.___hPartialFunc2SSO Tagclass._System.___hTotalFunc2SSO Tagclass._System.___hFunc2LLO Tagclass._System.___hPartialFunc2LLO Tagclass._System.___hTotalFunc2LLO Tagclass._System.___hFunc1SS Tagclass._System.___hPartialFunc1SS Tagclass._System.___hTotalFunc1SS Tagclass._System.___hFunc1LL Tagclass._System.___hPartialFunc1LL Tagclass._System.___hTotalFunc1LL |##PivotBetree.TransitionLabel.QueryLabel| Tagclass.KeyType.Key Tagclass.ValueType.Value Tagclass.PivotBetree.TransitionLabel |##PivotBetree.TransitionLabel.PutLabel| Tagclass.MsgHistoryMod.MsgHistory |##PivotBetree.TransitionLabel.QueryEndLsnLabel| |##PivotBetree.TransitionLabel.FreezeAsLabel| Tagclass.PivotBetree.BetreeNode Tagclass.StampedMod.Stamped |##PivotBetree.TransitionLabel.InternalLabel| class.PivotBetree.TransitionLabel |##PivotBetree.BetreeNode.Nil| |##PivotBetree.BetreeNode.BetreeNode| Tagclass.Buffers.BufferStack Tagclass.Upperbounded__Lexicographic__Byte__Order.Element class.PivotBetree.BetreeNode Tagclass.DomainMod.Domain Tagclass.SplitRequestMod.SplitRequest Tagclass.NativeTypes.byte |##PivotBetree.QueryReceiptLine.QueryReceiptLine| Tagclass.ValueMessage.Message Tagclass.PivotBetree.QueryReceiptLine class.PivotBetree.QueryReceiptLine |##PivotBetree.QueryReceipt.QueryReceipt| Tagclass.PivotBetree.QueryReceipt class.PivotBetree.QueryReceipt |##PivotBetree.Variables.Variables| Tagclass.MemtableMod.Memtable Tagclass.PivotBetree.Variables class.PivotBetree.Variables |##PivotBetree.Path.Path| Tagclass.PivotBetree.Path class.PivotBetree.Path |##PivotBetree.Step.QueryStep| Tagclass.PivotBetree.Step |##PivotBetree.Step.PutStep| |##PivotBetree.Step.QueryEndLsnStep| |##PivotBetree.Step.FreezeAsStep| |##PivotBetree.Step.InternalGrowStep| |##PivotBetree.Step.InternalSplitStep| |##PivotBetree.Step.InternalFlushMemtableStep| |##PivotBetree.Step.InternalFlushStep| |##PivotBetree.Step.InternalCompactStep| |##PivotBetree.Step.InternalNoOpStep| class.PivotBetree.Step class.PivotBetree.__default Tagclass.PivotBetree.__default Tagclass.Buffers.Buffer |##Options.Option.None| Tagclass.Options.Option |##Options.Option.Some| class.Options.Option class.Options.__default Tagclass.Options.__default Tagclass.NativeTypes.sbyte class.NativeTypes.sbyte class.NativeTypes.byte Tagclass.NativeTypes.int16 class.NativeTypes.int16 Tagclass.NativeTypes.uint16 class.NativeTypes.uint16 Tagclass.NativeTypes.int32 class.NativeTypes.int32 Tagclass.NativeTypes.uint32 class.NativeTypes.uint32 Tagclass.NativeTypes.int64 class.NativeTypes.int64 Tagclass.NativeTypes.uint64 class.NativeTypes.uint64 Tagclass.NativeTypes.nat8 class.NativeTypes.nat8 Tagclass.NativeTypes.nat16 class.NativeTypes.nat16 Tagclass.NativeTypes.nat32 class.NativeTypes.nat32 Tagclass.NativeTypes.nat64 class.NativeTypes.nat64 Tagclass.NativeTypes.uint128 class.NativeTypes.uint128 class.NativeTypes.__default Tagclass.NativeTypes.__default class.KeyType.__default Tagclass.KeyType.__default class.ValueType.__default Tagclass.ValueType.__default class.LinearMaybe.predefined class.LinearMaybe.__default Tagclass.LinearMaybe.__default class.LinearExtern.predefined class.LinearExtern.__default Tagclass.LinearExtern.__default |##ValueMessage.Delta.NoDelta| Tagclass.ValueMessage.Delta class.ValueMessage.Delta class.ValueMessage.__default Tagclass.ValueMessage.__default |##ValueMessage.Message.Define| |##ValueMessage.Message.Update| class.ValueMessage.Message class.TotalKMMapMod.__default Tagclass.TotalKMMapMod.__default Tagclass.TotalKMMapMod.TotalMap class.LSNMod.__default Tagclass.LSNMod.__default |##StampedMod.Stamped.Stamped| class.StampedMod.Stamped class.StampedMod.__default Tagclass.StampedMod.__default class.SequencesLite.__default Tagclass.SequencesLite.__default class.Mathematics.__default Tagclass.Mathematics.__default class.LinearSequence__i.__default Tagclass.LinearSequence__i.__default class.Sequences.__default Tagclass.Sequences.__default class.MapRemove_s.__default Tagclass.MapRemove_s.__default class.Maps.__default Tagclass.Maps.__default |##MsgHistoryMod.KeyedMessage.KeyedMessage| Tagclass.MsgHistoryMod.KeyedMessage class.MsgHistoryMod.KeyedMessage |##MsgHistoryMod.MsgHistory.MsgHistory| class.MsgHistoryMod.MsgHistory class.MsgHistoryMod.__default Tagclass.MsgHistoryMod.__default |##Buffers.Buffer.Buffer| class.Buffers.Buffer |##Buffers.BufferStack.BufferStack| class.Buffers.BufferStack class.Buffers.__default Tagclass.Buffers.__default |##MemtableMod.Memtable.Memtable| class.MemtableMod.Memtable class.MemtableMod.__default Tagclass.MemtableMod.__default class.Sets.__default Tagclass.Sets.__default class.SeqComparison.__default Tagclass.SeqComparison.__default class.NativeArrays.__default Tagclass.NativeArrays.__default class.Byte__Order.__default Tagclass.Byte__Order.__default class.Lexicographic__Byte__Order.__default Tagclass.Lexicographic__Byte__Order.__default class.Upperbounded__Lexicographic__Byte__Order.__default Tagclass.Upperbounded__Lexicographic__Byte__Order.__default |##Upperbounded_Lexicographic_Byte_Order.Element.Element| |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| class.Upperbounded__Lexicographic__Byte__Order.Element class.Upperbounded__Lexicographic__Byte__Order__Impl.__default Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default class.BoundedPivotsLib.__default Tagclass.BoundedPivotsLib.__default |##DomainMod.Domain.EmptyDomain| |##DomainMod.Domain.Domain| class.DomainMod.Domain class.DomainMod.__default Tagclass.DomainMod.__default |##SplitRequestMod.SplitRequest.SplitLeaf| |##SplitRequestMod.SplitRequest.SplitIndex| class.SplitRequestMod.SplitRequest class.SplitRequestMod.__default Tagclass.SplitRequestMod.__default tytagFamily$nat tytagFamily$object tytagFamily$array |tytagFamily$_#Func1| |tytagFamily$_#PartialFunc1| |tytagFamily$_#TotalFunc1| |tytagFamily$_#Func0| |tytagFamily$_#PartialFunc0| |tytagFamily$_#TotalFunc0| tytagFamily$_default |tytagFamily$_#Func2| |tytagFamily$_#PartialFunc2| |tytagFamily$_#TotalFunc2| |tytagFamily$_tuple#2| |tytagFamily$_#Func4| |tytagFamily$_#PartialFunc4| |tytagFamily$_#TotalFunc4| |tytagFamily$_#Func3| |tytagFamily$_#PartialFunc3| |tytagFamily$_#TotalFunc3| |tytagFamily$_#Func2OSO| |tytagFamily$_#PartialFunc2OSO| |tytagFamily$_#TotalFunc2OSO| |tytagFamily$_#Func3LLOO| |tytagFamily$_#PartialFunc3LLOO| |tytagFamily$_#TotalFunc3LLOO| |tytagFamily$_#Func1OS| |tytagFamily$_#PartialFunc1OS| |tytagFamily$_#TotalFunc1OS| |tytagFamily$_#Func0L| |tytagFamily$_#PartialFunc0L| |tytagFamily$_#TotalFunc0L| |tytagFamily$_#Func2LOO| |tytagFamily$_#PartialFunc2LOO| |tytagFamily$_#TotalFunc2LOO| |tytagFamily$_tuple#0| |tytagFamily$_#Func1OL| |tytagFamily$_#PartialFunc1OL| |tytagFamily$_#TotalFunc1OL| |tytagFamily$_#Func1LO| |tytagFamily$_#PartialFunc1LO| |tytagFamily$_#TotalFunc1LO| |tytagFamily$_tuple#2OLL| |tytagFamily$_#Func3LLOL| |tytagFamily$_#PartialFunc3LLOL| |tytagFamily$_#TotalFunc3LLOL| |tytagFamily$_#Func2SSO| |tytagFamily$_#PartialFunc2SSO| |tytagFamily$_#TotalFunc2SSO| |tytagFamily$_#Func2LLO| |tytagFamily$_#PartialFunc2LLO| |tytagFamily$_#TotalFunc2LLO| |tytagFamily$_#Func1SS| |tytagFamily$_#PartialFunc1SS| |tytagFamily$_#TotalFunc1SS| |tytagFamily$_#Func1LL| |tytagFamily$_#PartialFunc1LL| |tytagFamily$_#TotalFunc1LL| tytagFamily$Key tytagFamily$Value tytagFamily$TransitionLabel tytagFamily$MsgHistory tytagFamily$BetreeNode tytagFamily$Stamped tytagFamily$BufferStack tytagFamily$Element tytagFamily$Domain tytagFamily$SplitRequest tytagFamily$byte tytagFamily$Message tytagFamily$QueryReceiptLine tytagFamily$QueryReceipt tytagFamily$Memtable tytagFamily$Variables tytagFamily$Path tytagFamily$Step tytagFamily$Buffer tytagFamily$Option tytagFamily$sbyte tytagFamily$int16 tytagFamily$uint16 tytagFamily$int32 tytagFamily$uint32 tytagFamily$int64 tytagFamily$uint64 tytagFamily$nat8 tytagFamily$nat16 tytagFamily$nat32 tytagFamily$nat64 tytagFamily$uint128 tytagFamily$Delta tytagFamily$TotalMap tytagFamily$KeyedMessage)
)
(assert $$Language$Dafny)
(assert (forall ((arg0@@13 Int) ) (! (= (type (TBitvector arg0@@13)) TyType)
 :qid |funType:TBitvector|
 :pattern ( (TBitvector arg0@@13))
)))
(assert (forall ((w Int) ) (! (= (Inv0_TBitvector (TBitvector w)) w)
 :qid |DafnyPreludebpl.34:15|
 :skolemid |347|
 :pattern ( (TBitvector w))
)))
(assert  (and (forall ((arg0@@14 T@U) ) (! (= (type (TSet arg0@@14)) TyType)
 :qid |funType:TSet|
 :pattern ( (TSet arg0@@14))
)) (forall ((arg0@@15 T@U) ) (! (= (type (Inv0_TSet arg0@@15)) TyType)
 :qid |funType:Inv0_TSet|
 :pattern ( (Inv0_TSet arg0@@15))
))))
(assert (forall ((t T@U) ) (!  (=> (= (type t) TyType) (= (Inv0_TSet (TSet t)) t))
 :qid |DafnyPreludebpl.36:15|
 :skolemid |348|
 :pattern ( (TSet t))
)))
(assert  (and (forall ((arg0@@16 T@U) ) (! (= (type (TISet arg0@@16)) TyType)
 :qid |funType:TISet|
 :pattern ( (TISet arg0@@16))
)) (forall ((arg0@@17 T@U) ) (! (= (type (Inv0_TISet arg0@@17)) TyType)
 :qid |funType:Inv0_TISet|
 :pattern ( (Inv0_TISet arg0@@17))
))))
(assert (forall ((t@@0 T@U) ) (!  (=> (= (type t@@0) TyType) (= (Inv0_TISet (TISet t@@0)) t@@0))
 :qid |DafnyPreludebpl.38:15|
 :skolemid |349|
 :pattern ( (TISet t@@0))
)))
(assert  (and (forall ((arg0@@18 T@U) ) (! (= (type (TSeq arg0@@18)) TyType)
 :qid |funType:TSeq|
 :pattern ( (TSeq arg0@@18))
)) (forall ((arg0@@19 T@U) ) (! (= (type (Inv0_TSeq arg0@@19)) TyType)
 :qid |funType:Inv0_TSeq|
 :pattern ( (Inv0_TSeq arg0@@19))
))))
(assert (forall ((t@@1 T@U) ) (!  (=> (= (type t@@1) TyType) (= (Inv0_TSeq (TSeq t@@1)) t@@1))
 :qid |DafnyPreludebpl.40:15|
 :skolemid |350|
 :pattern ( (TSeq t@@1))
)))
(assert  (and (forall ((arg0@@20 T@U) ) (! (= (type (TMultiSet arg0@@20)) TyType)
 :qid |funType:TMultiSet|
 :pattern ( (TMultiSet arg0@@20))
)) (forall ((arg0@@21 T@U) ) (! (= (type (Inv0_TMultiSet arg0@@21)) TyType)
 :qid |funType:Inv0_TMultiSet|
 :pattern ( (Inv0_TMultiSet arg0@@21))
))))
(assert (forall ((t@@2 T@U) ) (!  (=> (= (type t@@2) TyType) (= (Inv0_TMultiSet (TMultiSet t@@2)) t@@2))
 :qid |DafnyPreludebpl.42:15|
 :skolemid |351|
 :pattern ( (TMultiSet t@@2))
)))
(assert  (and (forall ((arg0@@22 T@U) (arg1 T@U) ) (! (= (type (TMap arg0@@22 arg1)) TyType)
 :qid |funType:TMap|
 :pattern ( (TMap arg0@@22 arg1))
)) (forall ((arg0@@23 T@U) ) (! (= (type (Inv0_TMap arg0@@23)) TyType)
 :qid |funType:Inv0_TMap|
 :pattern ( (Inv0_TMap arg0@@23))
))))
(assert (forall ((t@@3 T@U) (u T@U) ) (!  (=> (and (= (type t@@3) TyType) (= (type u) TyType)) (= (Inv0_TMap (TMap t@@3 u)) t@@3))
 :qid |DafnyPreludebpl.45:15|
 :skolemid |352|
 :pattern ( (TMap t@@3 u))
)))
(assert (forall ((arg0@@24 T@U) ) (! (= (type (Inv1_TMap arg0@@24)) TyType)
 :qid |funType:Inv1_TMap|
 :pattern ( (Inv1_TMap arg0@@24))
)))
(assert (forall ((t@@4 T@U) (u@@0 T@U) ) (!  (=> (and (= (type t@@4) TyType) (= (type u@@0) TyType)) (= (Inv1_TMap (TMap t@@4 u@@0)) u@@0))
 :qid |DafnyPreludebpl.46:15|
 :skolemid |353|
 :pattern ( (TMap t@@4 u@@0))
)))
(assert  (and (forall ((arg0@@25 T@U) (arg1@@0 T@U) ) (! (= (type (TIMap arg0@@25 arg1@@0)) TyType)
 :qid |funType:TIMap|
 :pattern ( (TIMap arg0@@25 arg1@@0))
)) (forall ((arg0@@26 T@U) ) (! (= (type (Inv0_TIMap arg0@@26)) TyType)
 :qid |funType:Inv0_TIMap|
 :pattern ( (Inv0_TIMap arg0@@26))
))))
(assert (forall ((t@@5 T@U) (u@@1 T@U) ) (!  (=> (and (= (type t@@5) TyType) (= (type u@@1) TyType)) (= (Inv0_TIMap (TIMap t@@5 u@@1)) t@@5))
 :qid |DafnyPreludebpl.49:15|
 :skolemid |354|
 :pattern ( (TIMap t@@5 u@@1))
)))
(assert (forall ((arg0@@27 T@U) ) (! (= (type (Inv1_TIMap arg0@@27)) TyType)
 :qid |funType:Inv1_TIMap|
 :pattern ( (Inv1_TIMap arg0@@27))
)))
(assert (forall ((t@@6 T@U) (u@@2 T@U) ) (!  (=> (and (= (type t@@6) TyType) (= (type u@@2) TyType)) (= (Inv1_TIMap (TIMap t@@6 u@@2)) u@@2))
 :qid |DafnyPreludebpl.50:15|
 :skolemid |355|
 :pattern ( (TIMap t@@6 u@@2))
)))
(assert (forall ((arg0@@28 T@U) ) (! (= (type (Tag arg0@@28)) TyTagType)
 :qid |funType:Tag|
 :pattern ( (Tag arg0@@28))
)))
(assert (= (Tag TBool) TagBool))
(assert (= (Tag TChar) TagChar))
(assert (= (Tag TInt) TagInt))
(assert (= (Tag TReal) TagReal))
(assert (= (Tag TORDINAL) TagORDINAL))
(assert (forall ((t@@7 T@U) ) (!  (=> (= (type t@@7) TyType) (= (Tag (TSet t@@7)) TagSet))
 :qid |DafnyPreludebpl.76:15|
 :skolemid |356|
 :pattern ( (TSet t@@7))
)))
(assert (forall ((t@@8 T@U) ) (!  (=> (= (type t@@8) TyType) (= (Tag (TISet t@@8)) TagISet))
 :qid |DafnyPreludebpl.77:15|
 :skolemid |357|
 :pattern ( (TISet t@@8))
)))
(assert (forall ((t@@9 T@U) ) (!  (=> (= (type t@@9) TyType) (= (Tag (TMultiSet t@@9)) TagMultiSet))
 :qid |DafnyPreludebpl.78:15|
 :skolemid |358|
 :pattern ( (TMultiSet t@@9))
)))
(assert (forall ((t@@10 T@U) ) (!  (=> (= (type t@@10) TyType) (= (Tag (TSeq t@@10)) TagSeq))
 :qid |DafnyPreludebpl.79:15|
 :skolemid |359|
 :pattern ( (TSeq t@@10))
)))
(assert (forall ((t@@11 T@U) (u@@3 T@U) ) (!  (=> (and (= (type t@@11) TyType) (= (type u@@3) TyType)) (= (Tag (TMap t@@11 u@@3)) TagMap))
 :qid |DafnyPreludebpl.80:15|
 :skolemid |360|
 :pattern ( (TMap t@@11 u@@3))
)))
(assert (forall ((t@@12 T@U) (u@@4 T@U) ) (!  (=> (and (= (type t@@12) TyType) (= (type u@@4) TyType)) (= (Tag (TIMap t@@12 u@@4)) TagIMap))
 :qid |DafnyPreludebpl.81:15|
 :skolemid |361|
 :pattern ( (TIMap t@@12 u@@4))
)))
(assert (forall ((arg0@@29 T@U) ) (! (let ((T (type arg0@@29)))
(= (type (Lit arg0@@29)) T))
 :qid |funType:Lit|
 :pattern ( (Lit arg0@@29))
)))
(assert (forall ((x@@8 T@U) ) (! (= (Lit x@@8) x@@8)
 :qid |DafnyPreludebpl.89:29|
 :skolemid |362|
 :pattern ( (Lit x@@8))
)))
(assert  (and (= (Ctor BoxType) 13) (forall ((arg0@@30 T@U) ) (! (= (type ($Box arg0@@30)) BoxType)
 :qid |funType:$Box|
 :pattern ( ($Box arg0@@30))
))))
(assert (forall ((x@@9 T@U) ) (! (= ($Box (Lit x@@9)) (Lit ($Box x@@9)))
 :qid |DafnyPreludebpl.90:18|
 :skolemid |363|
 :pattern ( ($Box (Lit x@@9)))
)))
(assert (forall ((x@@10 Int) ) (! (= (LitInt x@@10) x@@10)
 :qid |DafnyPreludebpl.95:29|
 :skolemid |364|
 :pattern ( (LitInt x@@10))
)))
(assert (forall ((x@@11 Int) ) (! (= ($Box (int_2_U (LitInt x@@11))) (Lit ($Box (int_2_U x@@11))))
 :qid |DafnyPreludebpl.96:15|
 :skolemid |365|
 :pattern ( ($Box (int_2_U (LitInt x@@11))))
)))
(assert (forall ((x@@12 Real) ) (! (= (LitReal x@@12) x@@12)
 :qid |DafnyPreludebpl.97:30|
 :skolemid |366|
 :pattern ( (LitReal x@@12))
)))
(assert (forall ((x@@13 Real) ) (! (= ($Box (real_2_U (LitReal x@@13))) (Lit ($Box (real_2_U x@@13))))
 :qid |DafnyPreludebpl.98:15|
 :skolemid |367|
 :pattern ( ($Box (real_2_U (LitReal x@@13))))
)))
(assert  (and (= (Ctor charType) 14) (forall ((arg0@@31 Int) ) (! (= (type (|char#FromInt| arg0@@31)) charType)
 :qid |funType:char#FromInt|
 :pattern ( (|char#FromInt| arg0@@31))
))))
(assert (forall ((ch T@U) ) (!  (=> (= (type ch) charType) (and (and (= (|char#FromInt| (|char#ToInt| ch)) ch) (<= 0 (|char#ToInt| ch))) (< (|char#ToInt| ch) 65536)))
 :qid |DafnyPreludebpl.107:15|
 :skolemid |368|
 :pattern ( (|char#ToInt| ch))
)))
(assert (forall ((n Int) ) (!  (=> (and (<= 0 n) (< n 65536)) (= (|char#ToInt| (|char#FromInt| n)) n))
 :qid |DafnyPreludebpl.111:15|
 :skolemid |369|
 :pattern ( (|char#FromInt| n))
)))
(assert (forall ((arg0@@32 T@U) (arg1@@1 T@U) ) (! (= (type (|char#Plus| arg0@@32 arg1@@1)) charType)
 :qid |funType:char#Plus|
 :pattern ( (|char#Plus| arg0@@32 arg1@@1))
)))
(assert (forall ((a T@U) (b T@U) ) (!  (=> (and (= (type a) charType) (= (type b) charType)) (= (|char#Plus| a b) (|char#FromInt| (+ (|char#ToInt| a) (|char#ToInt| b)))))
 :qid |DafnyPreludebpl.117:15|
 :skolemid |370|
 :pattern ( (|char#Plus| a b))
)))
(assert (forall ((arg0@@33 T@U) (arg1@@2 T@U) ) (! (= (type (|char#Minus| arg0@@33 arg1@@2)) charType)
 :qid |funType:char#Minus|
 :pattern ( (|char#Minus| arg0@@33 arg1@@2))
)))
(assert (forall ((a@@0 T@U) (b@@0 T@U) ) (!  (=> (and (= (type a@@0) charType) (= (type b@@0) charType)) (= (|char#Minus| a@@0 b@@0) (|char#FromInt| (- (|char#ToInt| a@@0) (|char#ToInt| b@@0)))))
 :qid |DafnyPreludebpl.120:15|
 :skolemid |371|
 :pattern ( (|char#Minus| a@@0 b@@0))
)))
(assert (forall ((T@@0 T@T) (arg0@@34 T@U) ) (! (= (type ($Unbox T@@0 arg0@@34)) T@@0)
 :qid |funType:$Unbox|
 :pattern ( ($Unbox T@@0 arg0@@34))
)))
(assert (forall ((x@@14 T@U) ) (! (let ((T@@1 (type x@@14)))
(= ($Unbox T@@1 ($Box x@@14)) x@@14))
 :qid |DafnyPreludebpl.141:18|
 :skolemid |372|
 :pattern ( ($Box x@@14))
)))
(assert (forall ((bx T@U) ) (!  (=> (and (= (type bx) BoxType) ($IsBox bx TInt)) (and (= ($Box ($Unbox intType bx)) bx) ($Is ($Unbox intType bx) TInt)))
 :qid |DafnyPreludebpl.143:15|
 :skolemid |373|
 :pattern ( ($IsBox bx TInt))
)))
(assert (forall ((bx@@0 T@U) ) (!  (=> (and (= (type bx@@0) BoxType) ($IsBox bx@@0 TReal)) (and (= ($Box ($Unbox realType bx@@0)) bx@@0) ($Is ($Unbox realType bx@@0) TReal)))
 :qid |DafnyPreludebpl.146:15|
 :skolemid |374|
 :pattern ( ($IsBox bx@@0 TReal))
)))
(assert (forall ((bx@@1 T@U) ) (!  (=> (and (= (type bx@@1) BoxType) ($IsBox bx@@1 TBool)) (and (= ($Box ($Unbox boolType bx@@1)) bx@@1) ($Is ($Unbox boolType bx@@1) TBool)))
 :qid |DafnyPreludebpl.149:15|
 :skolemid |375|
 :pattern ( ($IsBox bx@@1 TBool))
)))
(assert (forall ((bx@@2 T@U) ) (!  (=> (and (= (type bx@@2) BoxType) ($IsBox bx@@2 TChar)) (and (= ($Box ($Unbox charType bx@@2)) bx@@2) ($Is ($Unbox charType bx@@2) TChar)))
 :qid |DafnyPreludebpl.152:15|
 :skolemid |376|
 :pattern ( ($IsBox bx@@2 TChar))
)))
(assert  (and (and (and (and (and (and (forall ((arg0@@35 T@T) (arg1@@3 T@T) ) (! (= (Ctor (MapType0Type arg0@@35 arg1@@3)) 15)
 :qid |ctor:MapType0Type|
)) (forall ((arg0@@36 T@T) (arg1@@4 T@T) ) (! (= (MapType0TypeInv0 (MapType0Type arg0@@36 arg1@@4)) arg0@@36)
 :qid |typeInv:MapType0TypeInv0|
 :pattern ( (MapType0Type arg0@@36 arg1@@4))
))) (forall ((arg0@@37 T@T) (arg1@@5 T@T) ) (! (= (MapType0TypeInv1 (MapType0Type arg0@@37 arg1@@5)) arg1@@5)
 :qid |typeInv:MapType0TypeInv1|
 :pattern ( (MapType0Type arg0@@37 arg1@@5))
))) (forall ((arg0@@38 T@U) (arg1@@6 T@U) ) (! (let ((aVar1 (MapType0TypeInv1 (type arg0@@38))))
(= (type (MapType0Select arg0@@38 arg1@@6)) aVar1))
 :qid |funType:MapType0Select|
 :pattern ( (MapType0Select arg0@@38 arg1@@6))
))) (forall ((arg0@@39 T@U) (arg1@@7 T@U) (arg2 T@U) ) (! (let ((aVar1@@0 (type arg2)))
(let ((aVar0 (type arg1@@7)))
(= (type (MapType0Store arg0@@39 arg1@@7 arg2)) (MapType0Type aVar0 aVar1@@0))))
 :qid |funType:MapType0Store|
 :pattern ( (MapType0Store arg0@@39 arg1@@7 arg2))
))) (forall ((m T@U) (x0 T@U) (val T@U) ) (! (let ((aVar1@@1 (MapType0TypeInv1 (type m))))
 (=> (= (type val) aVar1@@1) (= (MapType0Select (MapType0Store m x0 val) x0) val)))
 :qid |mapAx0:MapType0Select|
 :weight 0
))) (and (forall ((val@@0 T@U) (m@@0 T@U) (x0@@0 T@U) (y0 T@U) ) (!  (or (= x0@@0 y0) (= (MapType0Select (MapType0Store m@@0 x0@@0 val@@0) y0) (MapType0Select m@@0 y0)))
 :qid |mapAx1:MapType0Select:0|
 :weight 0
)) (forall ((val@@1 T@U) (m@@1 T@U) (x0@@1 T@U) (y0@@0 T@U) ) (!  (or true (= (MapType0Select (MapType0Store m@@1 x0@@1 val@@1) y0@@0) (MapType0Select m@@1 y0@@0)))
 :qid |mapAx2:MapType0Select|
 :weight 0
)))))
(assert (forall ((bx@@3 T@U) ) (!  (=> (and (= (type bx@@3) BoxType) ($IsBox bx@@3 (TBitvector 0))) (and (= ($Box ($Unbox intType bx@@3)) bx@@3) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@3) (TBitvector 0))))
 :qid |DafnyPreludebpl.158:15|
 :skolemid |377|
 :pattern ( ($IsBox bx@@3 (TBitvector 0)))
)))
(assert (forall ((bx@@4 T@U) (t@@13 T@U) ) (!  (=> (and (and (= (type bx@@4) BoxType) (= (type t@@13) TyType)) ($IsBox bx@@4 (TSet t@@13))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@4)) bx@@4) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@4) (TSet t@@13))))
 :qid |DafnyPreludebpl.162:15|
 :skolemid |378|
 :pattern ( ($IsBox bx@@4 (TSet t@@13)))
)))
(assert (forall ((bx@@5 T@U) (t@@14 T@U) ) (!  (=> (and (and (= (type bx@@5) BoxType) (= (type t@@14) TyType)) ($IsBox bx@@5 (TISet t@@14))) (and (= ($Box ($Unbox (MapType0Type BoxType boolType) bx@@5)) bx@@5) ($Is ($Unbox (MapType0Type BoxType boolType) bx@@5) (TISet t@@14))))
 :qid |DafnyPreludebpl.165:15|
 :skolemid |379|
 :pattern ( ($IsBox bx@@5 (TISet t@@14)))
)))
(assert (forall ((bx@@6 T@U) (t@@15 T@U) ) (!  (=> (and (and (= (type bx@@6) BoxType) (= (type t@@15) TyType)) ($IsBox bx@@6 (TMultiSet t@@15))) (and (= ($Box ($Unbox (MapType0Type BoxType intType) bx@@6)) bx@@6) ($Is ($Unbox (MapType0Type BoxType intType) bx@@6) (TMultiSet t@@15))))
 :qid |DafnyPreludebpl.168:15|
 :skolemid |380|
 :pattern ( ($IsBox bx@@6 (TMultiSet t@@15)))
)))
(assert  (and (forall ((arg0@@40 T@T) ) (! (= (Ctor (SeqType arg0@@40)) 16)
 :qid |ctor:SeqType|
)) (forall ((arg0@@41 T@T) ) (! (= (SeqTypeInv0 (SeqType arg0@@41)) arg0@@41)
 :qid |typeInv:SeqTypeInv0|
 :pattern ( (SeqType arg0@@41))
))))
(assert (forall ((bx@@7 T@U) (t@@16 T@U) ) (!  (=> (and (and (= (type bx@@7) BoxType) (= (type t@@16) TyType)) ($IsBox bx@@7 (TSeq t@@16))) (and (= ($Box ($Unbox (SeqType BoxType) bx@@7)) bx@@7) ($Is ($Unbox (SeqType BoxType) bx@@7) (TSeq t@@16))))
 :qid |DafnyPreludebpl.171:15|
 :skolemid |381|
 :pattern ( ($IsBox bx@@7 (TSeq t@@16)))
)))
(assert  (and (and (forall ((arg0@@42 T@T) (arg1@@8 T@T) ) (! (= (Ctor (MapType arg0@@42 arg1@@8)) 17)
 :qid |ctor:MapType|
)) (forall ((arg0@@43 T@T) (arg1@@9 T@T) ) (! (= (MapTypeInv0 (MapType arg0@@43 arg1@@9)) arg0@@43)
 :qid |typeInv:MapTypeInv0|
 :pattern ( (MapType arg0@@43 arg1@@9))
))) (forall ((arg0@@44 T@T) (arg1@@10 T@T) ) (! (= (MapTypeInv1 (MapType arg0@@44 arg1@@10)) arg1@@10)
 :qid |typeInv:MapTypeInv1|
 :pattern ( (MapType arg0@@44 arg1@@10))
))))
(assert (forall ((bx@@8 T@U) (s T@U) (t@@17 T@U) ) (!  (=> (and (and (and (= (type bx@@8) BoxType) (= (type s) TyType)) (= (type t@@17) TyType)) ($IsBox bx@@8 (TMap s t@@17))) (and (= ($Box ($Unbox (MapType BoxType BoxType) bx@@8)) bx@@8) ($Is ($Unbox (MapType BoxType BoxType) bx@@8) (TMap s t@@17))))
 :qid |DafnyPreludebpl.174:15|
 :skolemid |382|
 :pattern ( ($IsBox bx@@8 (TMap s t@@17)))
)))
(assert  (and (and (forall ((arg0@@45 T@T) (arg1@@11 T@T) ) (! (= (Ctor (IMapType arg0@@45 arg1@@11)) 18)
 :qid |ctor:IMapType|
)) (forall ((arg0@@46 T@T) (arg1@@12 T@T) ) (! (= (IMapTypeInv0 (IMapType arg0@@46 arg1@@12)) arg0@@46)
 :qid |typeInv:IMapTypeInv0|
 :pattern ( (IMapType arg0@@46 arg1@@12))
))) (forall ((arg0@@47 T@T) (arg1@@13 T@T) ) (! (= (IMapTypeInv1 (IMapType arg0@@47 arg1@@13)) arg1@@13)
 :qid |typeInv:IMapTypeInv1|
 :pattern ( (IMapType arg0@@47 arg1@@13))
))))
(assert (forall ((bx@@9 T@U) (s@@0 T@U) (t@@18 T@U) ) (!  (=> (and (and (and (= (type bx@@9) BoxType) (= (type s@@0) TyType)) (= (type t@@18) TyType)) ($IsBox bx@@9 (TIMap s@@0 t@@18))) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@9)) bx@@9) ($Is ($Unbox (IMapType BoxType BoxType) bx@@9) (TIMap s@@0 t@@18))))
 :qid |DafnyPreludebpl.177:15|
 :skolemid |383|
 :pattern ( ($IsBox bx@@9 (TIMap s@@0 t@@18)))
)))
(assert (forall ((v T@U) (t@@19 T@U) ) (!  (=> (= (type t@@19) TyType) (= ($IsBox ($Box v) t@@19) ($Is v t@@19)))
 :qid |DafnyPreludebpl.181:18|
 :skolemid |384|
 :pattern ( ($IsBox ($Box v) t@@19))
)))
(assert  (and (and (and (and (and (forall ((arg0@@48 T@U) (arg1@@14 T@U) ) (! (let ((alpha@@1 (FieldTypeInv0 (type arg1@@14))))
(= (type (MapType1Select arg0@@48 arg1@@14)) alpha@@1))
 :qid |funType:MapType1Select|
 :pattern ( (MapType1Select arg0@@48 arg1@@14))
)) (= (Ctor MapType1Type) 19)) (forall ((arg0@@49 T@U) (arg1@@15 T@U) (arg2@@0 T@U) ) (! (= (type (MapType1Store arg0@@49 arg1@@15 arg2@@0)) MapType1Type)
 :qid |funType:MapType1Store|
 :pattern ( (MapType1Store arg0@@49 arg1@@15 arg2@@0))
))) (forall ((m@@2 T@U) (x0@@2 T@U) (val@@2 T@U) ) (! (let ((alpha@@2 (FieldTypeInv0 (type x0@@2))))
 (=> (= (type val@@2) alpha@@2) (= (MapType1Select (MapType1Store m@@2 x0@@2 val@@2) x0@@2) val@@2)))
 :qid |mapAx0:MapType1Select|
 :weight 0
))) (and (forall ((val@@3 T@U) (m@@3 T@U) (x0@@3 T@U) (y0@@1 T@U) ) (!  (or (= x0@@3 y0@@1) (= (MapType1Select (MapType1Store m@@3 x0@@3 val@@3) y0@@1) (MapType1Select m@@3 y0@@1)))
 :qid |mapAx1:MapType1Select:0|
 :weight 0
)) (forall ((val@@4 T@U) (m@@4 T@U) (x0@@4 T@U) (y0@@2 T@U) ) (!  (or true (= (MapType1Select (MapType1Store m@@4 x0@@4 val@@4) y0@@2) (MapType1Select m@@4 y0@@2)))
 :qid |mapAx2:MapType1Select|
 :weight 0
)))) (= (Ctor refType) 20)))
(assert (forall ((v@@0 T@U) (t@@20 T@U) (h T@U) ) (!  (=> (and (= (type t@@20) TyType) (= (type h) (MapType0Type refType MapType1Type))) (= ($IsAllocBox ($Box v@@0) t@@20 h) ($IsAlloc v@@0 t@@20 h)))
 :qid |DafnyPreludebpl.184:18|
 :skolemid |385|
 :pattern ( ($IsAllocBox ($Box v@@0) t@@20 h))
)))
(assert (forall ((v@@1 T@U) ) (!  (=> (= (type v@@1) intType) ($Is v@@1 TInt))
 :qid |DafnyPreludebpl.202:14|
 :skolemid |386|
 :pattern ( ($Is v@@1 TInt))
)))
(assert (forall ((v@@2 T@U) ) (!  (=> (= (type v@@2) realType) ($Is v@@2 TReal))
 :qid |DafnyPreludebpl.203:14|
 :skolemid |387|
 :pattern ( ($Is v@@2 TReal))
)))
(assert (forall ((v@@3 T@U) ) (!  (=> (= (type v@@3) boolType) ($Is v@@3 TBool))
 :qid |DafnyPreludebpl.204:14|
 :skolemid |388|
 :pattern ( ($Is v@@3 TBool))
)))
(assert (forall ((v@@4 T@U) ) (!  (=> (= (type v@@4) charType) ($Is v@@4 TChar))
 :qid |DafnyPreludebpl.205:14|
 :skolemid |389|
 :pattern ( ($Is v@@4 TChar))
)))
(assert (forall ((v@@5 T@U) ) (!  (=> (= (type v@@5) BoxType) ($Is v@@5 TORDINAL))
 :qid |DafnyPreludebpl.206:14|
 :skolemid |390|
 :pattern ( ($Is v@@5 TORDINAL))
)))
(assert (forall ((h@@0 T@U) (v@@6 T@U) ) (!  (=> (and (= (type h@@0) (MapType0Type refType MapType1Type)) (= (type v@@6) intType)) ($IsAlloc v@@6 TInt h@@0))
 :qid |DafnyPreludebpl.208:14|
 :skolemid |391|
 :pattern ( ($IsAlloc v@@6 TInt h@@0))
)))
(assert (forall ((h@@1 T@U) (v@@7 T@U) ) (!  (=> (and (= (type h@@1) (MapType0Type refType MapType1Type)) (= (type v@@7) realType)) ($IsAlloc v@@7 TReal h@@1))
 :qid |DafnyPreludebpl.209:14|
 :skolemid |392|
 :pattern ( ($IsAlloc v@@7 TReal h@@1))
)))
(assert (forall ((h@@2 T@U) (v@@8 T@U) ) (!  (=> (and (= (type h@@2) (MapType0Type refType MapType1Type)) (= (type v@@8) boolType)) ($IsAlloc v@@8 TBool h@@2))
 :qid |DafnyPreludebpl.210:14|
 :skolemid |393|
 :pattern ( ($IsAlloc v@@8 TBool h@@2))
)))
(assert (forall ((h@@3 T@U) (v@@9 T@U) ) (!  (=> (and (= (type h@@3) (MapType0Type refType MapType1Type)) (= (type v@@9) charType)) ($IsAlloc v@@9 TChar h@@3))
 :qid |DafnyPreludebpl.211:14|
 :skolemid |394|
 :pattern ( ($IsAlloc v@@9 TChar h@@3))
)))
(assert (forall ((h@@4 T@U) (v@@10 T@U) ) (!  (=> (and (= (type h@@4) (MapType0Type refType MapType1Type)) (= (type v@@10) BoxType)) ($IsAlloc v@@10 TORDINAL h@@4))
 :qid |DafnyPreludebpl.212:14|
 :skolemid |395|
 :pattern ( ($IsAlloc v@@10 TORDINAL h@@4))
)))
(assert (forall ((v@@11 T@U) ) (!  (=> (= (type v@@11) intType) ($Is v@@11 (TBitvector 0)))
 :qid |DafnyPreludebpl.216:15|
 :skolemid |396|
 :pattern ( ($Is v@@11 (TBitvector 0)))
)))
(assert (forall ((v@@12 T@U) (h@@5 T@U) ) (!  (=> (and (= (type v@@12) intType) (= (type h@@5) (MapType0Type refType MapType1Type))) ($IsAlloc v@@12 (TBitvector 0) h@@5))
 :qid |DafnyPreludebpl.217:15|
 :skolemid |397|
 :pattern ( ($IsAlloc v@@12 (TBitvector 0) h@@5))
)))
(assert (forall ((v@@13 T@U) (t0 T@U) ) (!  (=> (and (= (type v@@13) (MapType0Type BoxType boolType)) (= (type t0) TyType)) (= ($Is v@@13 (TSet t0)) (forall ((bx@@10 T@U) ) (!  (=> (and (= (type bx@@10) BoxType) (U_2_bool (MapType0Select v@@13 bx@@10))) ($IsBox bx@@10 t0))
 :qid |DafnyPreludebpl.221:11|
 :skolemid |398|
 :pattern ( (MapType0Select v@@13 bx@@10))
))))
 :qid |DafnyPreludebpl.219:15|
 :skolemid |399|
 :pattern ( ($Is v@@13 (TSet t0)))
)))
(assert (forall ((v@@14 T@U) (t0@@0 T@U) ) (!  (=> (and (= (type v@@14) (MapType0Type BoxType boolType)) (= (type t0@@0) TyType)) (= ($Is v@@14 (TISet t0@@0)) (forall ((bx@@11 T@U) ) (!  (=> (and (= (type bx@@11) BoxType) (U_2_bool (MapType0Select v@@14 bx@@11))) ($IsBox bx@@11 t0@@0))
 :qid |DafnyPreludebpl.225:11|
 :skolemid |400|
 :pattern ( (MapType0Select v@@14 bx@@11))
))))
 :qid |DafnyPreludebpl.223:15|
 :skolemid |401|
 :pattern ( ($Is v@@14 (TISet t0@@0)))
)))
(assert (forall ((v@@15 T@U) (t0@@1 T@U) ) (!  (=> (and (= (type v@@15) (MapType0Type BoxType intType)) (= (type t0@@1) TyType)) (= ($Is v@@15 (TMultiSet t0@@1)) (forall ((bx@@12 T@U) ) (!  (=> (and (= (type bx@@12) BoxType) (< 0 (U_2_int (MapType0Select v@@15 bx@@12)))) ($IsBox bx@@12 t0@@1))
 :qid |DafnyPreludebpl.229:11|
 :skolemid |402|
 :pattern ( (MapType0Select v@@15 bx@@12))
))))
 :qid |DafnyPreludebpl.227:15|
 :skolemid |403|
 :pattern ( ($Is v@@15 (TMultiSet t0@@1)))
)))
(assert (forall ((v@@16 T@U) (t0@@2 T@U) ) (!  (=> (and (and (= (type v@@16) (MapType0Type BoxType intType)) (= (type t0@@2) TyType)) ($Is v@@16 (TMultiSet t0@@2))) ($IsGoodMultiSet v@@16))
 :qid |DafnyPreludebpl.231:15|
 :skolemid |404|
 :pattern ( ($Is v@@16 (TMultiSet t0@@2)))
)))
(assert (forall ((arg0@@50 T@U) (arg1@@16 Int) ) (! (let ((T@@2 (SeqTypeInv0 (type arg0@@50))))
(= (type (|Seq#Index| arg0@@50 arg1@@16)) T@@2))
 :qid |funType:Seq#Index|
 :pattern ( (|Seq#Index| arg0@@50 arg1@@16))
)))
(assert (forall ((v@@17 T@U) (t0@@3 T@U) ) (!  (=> (and (= (type v@@17) (SeqType BoxType)) (= (type t0@@3) TyType)) (= ($Is v@@17 (TSeq t0@@3)) (forall ((i Int) ) (!  (=> (and (<= 0 i) (< i (|Seq#Length| v@@17))) ($IsBox (|Seq#Index| v@@17 i) t0@@3))
 :qid |DafnyPreludebpl.235:11|
 :skolemid |405|
 :pattern ( (|Seq#Index| v@@17 i))
))))
 :qid |DafnyPreludebpl.233:15|
 :skolemid |406|
 :pattern ( ($Is v@@17 (TSeq t0@@3)))
)))
(assert (forall ((v@@18 T@U) (t0@@4 T@U) (h@@6 T@U) ) (!  (=> (and (and (= (type v@@18) (MapType0Type BoxType boolType)) (= (type t0@@4) TyType)) (= (type h@@6) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@18 (TSet t0@@4) h@@6) (forall ((bx@@13 T@U) ) (!  (=> (and (= (type bx@@13) BoxType) (U_2_bool (MapType0Select v@@18 bx@@13))) ($IsAllocBox bx@@13 t0@@4 h@@6))
 :qid |DafnyPreludebpl.240:11|
 :skolemid |407|
 :pattern ( (MapType0Select v@@18 bx@@13))
))))
 :qid |DafnyPreludebpl.238:15|
 :skolemid |408|
 :pattern ( ($IsAlloc v@@18 (TSet t0@@4) h@@6))
)))
(assert (forall ((v@@19 T@U) (t0@@5 T@U) (h@@7 T@U) ) (!  (=> (and (and (= (type v@@19) (MapType0Type BoxType boolType)) (= (type t0@@5) TyType)) (= (type h@@7) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@19 (TISet t0@@5) h@@7) (forall ((bx@@14 T@U) ) (!  (=> (and (= (type bx@@14) BoxType) (U_2_bool (MapType0Select v@@19 bx@@14))) ($IsAllocBox bx@@14 t0@@5 h@@7))
 :qid |DafnyPreludebpl.244:11|
 :skolemid |409|
 :pattern ( (MapType0Select v@@19 bx@@14))
))))
 :qid |DafnyPreludebpl.242:15|
 :skolemid |410|
 :pattern ( ($IsAlloc v@@19 (TISet t0@@5) h@@7))
)))
(assert (forall ((v@@20 T@U) (t0@@6 T@U) (h@@8 T@U) ) (!  (=> (and (and (= (type v@@20) (MapType0Type BoxType intType)) (= (type t0@@6) TyType)) (= (type h@@8) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@20 (TMultiSet t0@@6) h@@8) (forall ((bx@@15 T@U) ) (!  (=> (and (= (type bx@@15) BoxType) (< 0 (U_2_int (MapType0Select v@@20 bx@@15)))) ($IsAllocBox bx@@15 t0@@6 h@@8))
 :qid |DafnyPreludebpl.248:11|
 :skolemid |411|
 :pattern ( (MapType0Select v@@20 bx@@15))
))))
 :qid |DafnyPreludebpl.246:15|
 :skolemid |412|
 :pattern ( ($IsAlloc v@@20 (TMultiSet t0@@6) h@@8))
)))
(assert (forall ((v@@21 T@U) (t0@@7 T@U) (h@@9 T@U) ) (!  (=> (and (and (= (type v@@21) (SeqType BoxType)) (= (type t0@@7) TyType)) (= (type h@@9) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@21 (TSeq t0@@7) h@@9) (forall ((i@@0 Int) ) (!  (=> (and (<= 0 i@@0) (< i@@0 (|Seq#Length| v@@21))) ($IsAllocBox (|Seq#Index| v@@21 i@@0) t0@@7 h@@9))
 :qid |DafnyPreludebpl.252:11|
 :skolemid |413|
 :pattern ( (|Seq#Index| v@@21 i@@0))
))))
 :qid |DafnyPreludebpl.250:15|
 :skolemid |414|
 :pattern ( ($IsAlloc v@@21 (TSeq t0@@7) h@@9))
)))
(assert  (and (forall ((arg0@@51 T@U) ) (! (let ((V (MapTypeInv1 (type arg0@@51))))
(let ((U (MapTypeInv0 (type arg0@@51))))
(= (type (|Map#Elements| arg0@@51)) (MapType0Type U V))))
 :qid |funType:Map#Elements|
 :pattern ( (|Map#Elements| arg0@@51))
)) (forall ((arg0@@52 T@U) ) (! (let ((U@@0 (MapTypeInv0 (type arg0@@52))))
(= (type (|Map#Domain| arg0@@52)) (MapType0Type U@@0 boolType)))
 :qid |funType:Map#Domain|
 :pattern ( (|Map#Domain| arg0@@52))
))))
(assert (forall ((v@@22 T@U) (t0@@8 T@U) (t1 T@U) ) (!  (=> (and (and (= (type v@@22) (MapType BoxType BoxType)) (= (type t0@@8) TyType)) (= (type t1) TyType)) (= ($Is v@@22 (TMap t0@@8 t1)) (forall ((bx@@16 T@U) ) (!  (=> (and (= (type bx@@16) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@22) bx@@16))) (and ($IsBox (MapType0Select (|Map#Elements| v@@22) bx@@16) t1) ($IsBox bx@@16 t0@@8)))
 :qid |DafnyPreludebpl.259:19|
 :skolemid |415|
 :pattern ( (MapType0Select (|Map#Elements| v@@22) bx@@16))
 :pattern ( (MapType0Select (|Map#Domain| v@@22) bx@@16))
))))
 :qid |DafnyPreludebpl.256:15|
 :skolemid |416|
 :pattern ( ($Is v@@22 (TMap t0@@8 t1)))
)))
(assert (forall ((v@@23 T@U) (t0@@9 T@U) (t1@@0 T@U) (h@@10 T@U) ) (!  (=> (and (and (and (= (type v@@23) (MapType BoxType BoxType)) (= (type t0@@9) TyType)) (= (type t1@@0) TyType)) (= (type h@@10) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10) (forall ((bx@@17 T@U) ) (!  (=> (and (= (type bx@@17) BoxType) (U_2_bool (MapType0Select (|Map#Domain| v@@23) bx@@17))) (and ($IsAllocBox (MapType0Select (|Map#Elements| v@@23) bx@@17) t1@@0 h@@10) ($IsAllocBox bx@@17 t0@@9 h@@10)))
 :qid |DafnyPreludebpl.267:19|
 :skolemid |417|
 :pattern ( (MapType0Select (|Map#Elements| v@@23) bx@@17))
 :pattern ( (MapType0Select (|Map#Domain| v@@23) bx@@17))
))))
 :qid |DafnyPreludebpl.264:15|
 :skolemid |418|
 :pattern ( ($IsAlloc v@@23 (TMap t0@@9 t1@@0) h@@10))
)))
(assert  (and (and (forall ((arg0@@53 T@U) ) (! (let ((V@@0 (MapTypeInv1 (type arg0@@53))))
(= (type (|Map#Values| arg0@@53)) (MapType0Type V@@0 boolType)))
 :qid |funType:Map#Values|
 :pattern ( (|Map#Values| arg0@@53))
)) (forall ((arg0@@54 T@U) ) (! (= (type (|Map#Items| arg0@@54)) (MapType0Type BoxType boolType))
 :qid |funType:Map#Items|
 :pattern ( (|Map#Items| arg0@@54))
))) (forall ((arg0@@55 T@U) (arg1@@17 T@U) ) (! (= (type (Tclass._System.Tuple2 arg0@@55 arg1@@17)) TyType)
 :qid |funType:Tclass._System.Tuple2|
 :pattern ( (Tclass._System.Tuple2 arg0@@55 arg1@@17))
))))
(assert (forall ((v@@24 T@U) (t0@@10 T@U) (t1@@1 T@U) ) (!  (=> (and (and (and (= (type v@@24) (MapType BoxType BoxType)) (= (type t0@@10) TyType)) (= (type t1@@1) TyType)) ($Is v@@24 (TMap t0@@10 t1@@1))) (and (and ($Is (|Map#Domain| v@@24) (TSet t0@@10)) ($Is (|Map#Values| v@@24) (TSet t1@@1))) ($Is (|Map#Items| v@@24) (TSet (Tclass._System.Tuple2 t0@@10 t1@@1)))))
 :qid |DafnyPreludebpl.272:15|
 :skolemid |419|
 :pattern ( ($Is v@@24 (TMap t0@@10 t1@@1)))
)))
(assert  (and (forall ((arg0@@56 T@U) ) (! (let ((V@@1 (IMapTypeInv1 (type arg0@@56))))
(let ((U@@1 (IMapTypeInv0 (type arg0@@56))))
(= (type (|IMap#Elements| arg0@@56)) (MapType0Type U@@1 V@@1))))
 :qid |funType:IMap#Elements|
 :pattern ( (|IMap#Elements| arg0@@56))
)) (forall ((arg0@@57 T@U) ) (! (let ((U@@2 (IMapTypeInv0 (type arg0@@57))))
(= (type (|IMap#Domain| arg0@@57)) (MapType0Type U@@2 boolType)))
 :qid |funType:IMap#Domain|
 :pattern ( (|IMap#Domain| arg0@@57))
))))
(assert (forall ((v@@25 T@U) (t0@@11 T@U) (t1@@2 T@U) ) (!  (=> (and (and (= (type v@@25) (IMapType BoxType BoxType)) (= (type t0@@11) TyType)) (= (type t1@@2) TyType)) (= ($Is v@@25 (TIMap t0@@11 t1@@2)) (forall ((bx@@18 T@U) ) (!  (=> (and (= (type bx@@18) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@25) bx@@18))) (and ($IsBox (MapType0Select (|IMap#Elements| v@@25) bx@@18) t1@@2) ($IsBox bx@@18 t0@@11)))
 :qid |DafnyPreludebpl.282:19|
 :skolemid |420|
 :pattern ( (MapType0Select (|IMap#Elements| v@@25) bx@@18))
 :pattern ( (MapType0Select (|IMap#Domain| v@@25) bx@@18))
))))
 :qid |DafnyPreludebpl.279:15|
 :skolemid |421|
 :pattern ( ($Is v@@25 (TIMap t0@@11 t1@@2)))
)))
(assert (forall ((v@@26 T@U) (t0@@12 T@U) (t1@@3 T@U) (h@@11 T@U) ) (!  (=> (and (and (and (= (type v@@26) (IMapType BoxType BoxType)) (= (type t0@@12) TyType)) (= (type t1@@3) TyType)) (= (type h@@11) (MapType0Type refType MapType1Type))) (= ($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11) (forall ((bx@@19 T@U) ) (!  (=> (and (= (type bx@@19) BoxType) (U_2_bool (MapType0Select (|IMap#Domain| v@@26) bx@@19))) (and ($IsAllocBox (MapType0Select (|IMap#Elements| v@@26) bx@@19) t1@@3 h@@11) ($IsAllocBox bx@@19 t0@@12 h@@11)))
 :qid |DafnyPreludebpl.290:19|
 :skolemid |422|
 :pattern ( (MapType0Select (|IMap#Elements| v@@26) bx@@19))
 :pattern ( (MapType0Select (|IMap#Domain| v@@26) bx@@19))
))))
 :qid |DafnyPreludebpl.287:15|
 :skolemid |423|
 :pattern ( ($IsAlloc v@@26 (TIMap t0@@12 t1@@3) h@@11))
)))
(assert  (and (forall ((arg0@@58 T@U) ) (! (let ((V@@2 (IMapTypeInv1 (type arg0@@58))))
(= (type (|IMap#Values| arg0@@58)) (MapType0Type V@@2 boolType)))
 :qid |funType:IMap#Values|
 :pattern ( (|IMap#Values| arg0@@58))
)) (forall ((arg0@@59 T@U) ) (! (= (type (|IMap#Items| arg0@@59)) (MapType0Type BoxType boolType))
 :qid |funType:IMap#Items|
 :pattern ( (|IMap#Items| arg0@@59))
))))
(assert (forall ((v@@27 T@U) (t0@@13 T@U) (t1@@4 T@U) ) (!  (=> (and (and (and (= (type v@@27) (IMapType BoxType BoxType)) (= (type t0@@13) TyType)) (= (type t1@@4) TyType)) ($Is v@@27 (TIMap t0@@13 t1@@4))) (and (and ($Is (|IMap#Domain| v@@27) (TISet t0@@13)) ($Is (|IMap#Values| v@@27) (TISet t1@@4))) ($Is (|IMap#Items| v@@27) (TISet (Tclass._System.Tuple2 t0@@13 t1@@4)))))
 :qid |DafnyPreludebpl.295:15|
 :skolemid |424|
 :pattern ( ($Is v@@27 (TIMap t0@@13 t1@@4)))
)))
(assert  (and (and (forall ((arg0@@60 T@U) (arg1@@18 T@U) ) (! (= (type (TypeTuple arg0@@60 arg1@@18)) ClassNameType)
 :qid |funType:TypeTuple|
 :pattern ( (TypeTuple arg0@@60 arg1@@18))
)) (forall ((arg0@@61 T@U) ) (! (= (type (TypeTupleCar arg0@@61)) ClassNameType)
 :qid |funType:TypeTupleCar|
 :pattern ( (TypeTupleCar arg0@@61))
))) (forall ((arg0@@62 T@U) ) (! (= (type (TypeTupleCdr arg0@@62)) ClassNameType)
 :qid |funType:TypeTupleCdr|
 :pattern ( (TypeTupleCdr arg0@@62))
))))
(assert (forall ((a@@1 T@U) (b@@1 T@U) ) (!  (=> (and (= (type a@@1) ClassNameType) (= (type b@@1) ClassNameType)) (and (= (TypeTupleCar (TypeTuple a@@1 b@@1)) a@@1) (= (TypeTupleCdr (TypeTuple a@@1 b@@1)) b@@1)))
 :qid |DafnyPreludebpl.322:15|
 :skolemid |425|
 :pattern ( (TypeTuple a@@1 b@@1))
)))
(assert (forall ((arg0@@63 T@U) ) (! (= (type (SetRef_to_SetBox arg0@@63)) (MapType0Type BoxType boolType))
 :qid |funType:SetRef_to_SetBox|
 :pattern ( (SetRef_to_SetBox arg0@@63))
)))
(assert (forall ((s@@1 T@U) (bx@@20 T@U) ) (!  (=> (and (= (type s@@1) (MapType0Type refType boolType)) (= (type bx@@20) BoxType)) (= (U_2_bool (MapType0Select (SetRef_to_SetBox s@@1) bx@@20)) (U_2_bool (MapType0Select s@@1 ($Unbox refType bx@@20)))))
 :qid |DafnyPreludebpl.331:15|
 :skolemid |426|
 :pattern ( (MapType0Select (SetRef_to_SetBox s@@1) bx@@20))
)))
(assert (= (type Tclass._System.object?) TyType))
(assert (forall ((s@@2 T@U) ) (!  (=> (= (type s@@2) (MapType0Type refType boolType)) ($Is (SetRef_to_SetBox s@@2) (TSet Tclass._System.object?)))
 :qid |DafnyPreludebpl.333:15|
 :skolemid |427|
 :pattern ( (SetRef_to_SetBox s@@2))
)))
(assert (= (Ctor DatatypeTypeType) 21))
(assert (forall ((d T@U) ) (!  (=> (= (type d) DatatypeTypeType) (= (BoxRank ($Box d)) (DtRank d)))
 :qid |DafnyPreludebpl.352:15|
 :skolemid |428|
 :pattern ( (BoxRank ($Box d)))
)))
(assert (forall ((o T@U) ) (!  (=> (= (type o) BoxType) (<= 0 (|ORD#Offset| o)))
 :qid |DafnyPreludebpl.367:15|
 :skolemid |429|
 :pattern ( (|ORD#Offset| o))
)))
(assert (forall ((arg0@@64 Int) ) (! (= (type (|ORD#FromNat| arg0@@64)) BoxType)
 :qid |funType:ORD#FromNat|
 :pattern ( (|ORD#FromNat| arg0@@64))
)))
(assert (forall ((n@@0 Int) ) (!  (=> (<= 0 n@@0) (and (|ORD#IsNat| (|ORD#FromNat| n@@0)) (= (|ORD#Offset| (|ORD#FromNat| n@@0)) n@@0)))
 :qid |DafnyPreludebpl.373:15|
 :skolemid |430|
 :pattern ( (|ORD#FromNat| n@@0))
)))
(assert (forall ((o@@0 T@U) ) (!  (=> (and (= (type o@@0) BoxType) (|ORD#IsNat| o@@0)) (= o@@0 (|ORD#FromNat| (|ORD#Offset| o@@0))))
 :qid |DafnyPreludebpl.375:15|
 :skolemid |431|
 :pattern ( (|ORD#Offset| o@@0))
 :pattern ( (|ORD#IsNat| o@@0))
)))
(assert (forall ((o@@1 T@U) (p T@U) ) (!  (=> (and (= (type o@@1) BoxType) (= (type p) BoxType)) (and (and (and (=> (|ORD#Less| o@@1 p) (not (= o@@1 p))) (=> (and (|ORD#IsNat| o@@1) (not (|ORD#IsNat| p))) (|ORD#Less| o@@1 p))) (=> (and (|ORD#IsNat| o@@1) (|ORD#IsNat| p)) (= (|ORD#Less| o@@1 p) (< (|ORD#Offset| o@@1) (|ORD#Offset| p))))) (=> (and (|ORD#Less| o@@1 p) (|ORD#IsNat| p)) (|ORD#IsNat| o@@1))))
 :qid |DafnyPreludebpl.379:15|
 :skolemid |432|
 :pattern ( (|ORD#Less| o@@1 p))
)))
(assert (forall ((o@@2 T@U) (p@@0 T@U) ) (!  (=> (and (= (type o@@2) BoxType) (= (type p@@0) BoxType)) (or (or (|ORD#Less| o@@2 p@@0) (= o@@2 p@@0)) (|ORD#Less| p@@0 o@@2)))
 :qid |DafnyPreludebpl.385:15|
 :skolemid |433|
 :pattern ( (|ORD#Less| o@@2 p@@0) (|ORD#Less| p@@0 o@@2))
)))
(assert (forall ((o@@3 T@U) (p@@1 T@U) (r T@U) ) (!  (=> (and (and (and (= (type o@@3) BoxType) (= (type p@@1) BoxType)) (= (type r) BoxType)) (and (|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 r))) (|ORD#Less| o@@3 r))
 :qid |DafnyPreludebpl.388:15|
 :skolemid |434|
 :pattern ( (|ORD#Less| o@@3 p@@1) (|ORD#Less| p@@1 r))
 :pattern ( (|ORD#Less| o@@3 p@@1) (|ORD#Less| o@@3 r))
)))
(assert (forall ((o@@4 T@U) (p@@2 T@U) ) (!  (=> (and (= (type o@@4) BoxType) (= (type p@@2) BoxType)) (= (|ORD#LessThanLimit| o@@4 p@@2) (|ORD#Less| o@@4 p@@2)))
 :qid |DafnyPreludebpl.395:15|
 :skolemid |435|
 :pattern ( (|ORD#LessThanLimit| o@@4 p@@2))
)))
(assert (forall ((arg0@@65 T@U) (arg1@@19 T@U) ) (! (= (type (|ORD#Plus| arg0@@65 arg1@@19)) BoxType)
 :qid |funType:ORD#Plus|
 :pattern ( (|ORD#Plus| arg0@@65 arg1@@19))
)))
(assert (forall ((o@@5 T@U) (p@@3 T@U) ) (!  (=> (and (= (type o@@5) BoxType) (= (type p@@3) BoxType)) (and (=> (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3)) (and (|ORD#IsNat| o@@5) (|ORD#IsNat| p@@3))) (=> (|ORD#IsNat| p@@3) (and (= (|ORD#IsNat| (|ORD#Plus| o@@5 p@@3)) (|ORD#IsNat| o@@5)) (= (|ORD#Offset| (|ORD#Plus| o@@5 p@@3)) (+ (|ORD#Offset| o@@5) (|ORD#Offset| p@@3)))))))
 :qid |DafnyPreludebpl.399:15|
 :skolemid |436|
 :pattern ( (|ORD#Plus| o@@5 p@@3))
)))
(assert (forall ((o@@6 T@U) (p@@4 T@U) ) (!  (=> (and (= (type o@@6) BoxType) (= (type p@@4) BoxType)) (and (or (= o@@6 (|ORD#Plus| o@@6 p@@4)) (|ORD#Less| o@@6 (|ORD#Plus| o@@6 p@@4))) (or (= p@@4 (|ORD#Plus| o@@6 p@@4)) (|ORD#Less| p@@4 (|ORD#Plus| o@@6 p@@4)))))
 :qid |DafnyPreludebpl.404:15|
 :skolemid |437|
 :pattern ( (|ORD#Plus| o@@6 p@@4))
)))
(assert (forall ((o@@7 T@U) (p@@5 T@U) ) (!  (=> (and (= (type o@@7) BoxType) (= (type p@@5) BoxType)) (and (=> (= o@@7 (|ORD#FromNat| 0)) (= (|ORD#Plus| o@@7 p@@5) p@@5)) (=> (= p@@5 (|ORD#FromNat| 0)) (= (|ORD#Plus| o@@7 p@@5) o@@7))))
 :qid |DafnyPreludebpl.407:15|
 :skolemid |438|
 :pattern ( (|ORD#Plus| o@@7 p@@5))
)))
(assert (forall ((arg0@@66 T@U) (arg1@@20 T@U) ) (! (= (type (|ORD#Minus| arg0@@66 arg1@@20)) BoxType)
 :qid |funType:ORD#Minus|
 :pattern ( (|ORD#Minus| arg0@@66 arg1@@20))
)))
(assert (forall ((o@@8 T@U) (p@@6 T@U) ) (!  (=> (and (and (= (type o@@8) BoxType) (= (type p@@6) BoxType)) (and (|ORD#IsNat| p@@6) (<= (|ORD#Offset| p@@6) (|ORD#Offset| o@@8)))) (and (= (|ORD#IsNat| (|ORD#Minus| o@@8 p@@6)) (|ORD#IsNat| o@@8)) (= (|ORD#Offset| (|ORD#Minus| o@@8 p@@6)) (- (|ORD#Offset| o@@8) (|ORD#Offset| p@@6)))))
 :qid |DafnyPreludebpl.412:15|
 :skolemid |439|
 :pattern ( (|ORD#Minus| o@@8 p@@6))
)))
(assert (forall ((o@@9 T@U) (p@@7 T@U) ) (!  (=> (and (and (= (type o@@9) BoxType) (= (type p@@7) BoxType)) (and (|ORD#IsNat| p@@7) (<= (|ORD#Offset| p@@7) (|ORD#Offset| o@@9)))) (or (and (= p@@7 (|ORD#FromNat| 0)) (= (|ORD#Minus| o@@9 p@@7) o@@9)) (and (not (= p@@7 (|ORD#FromNat| 0))) (|ORD#Less| (|ORD#Minus| o@@9 p@@7) o@@9))))
 :qid |DafnyPreludebpl.416:15|
 :skolemid |440|
 :pattern ( (|ORD#Minus| o@@9 p@@7))
)))
(assert (forall ((o@@10 T@U) (m@@5 Int) (n@@1 Int) ) (!  (=> (= (type o@@10) BoxType) (=> (and (<= 0 m@@5) (<= 0 n@@1)) (= (|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5)) (|ORD#FromNat| n@@1)) (|ORD#Plus| o@@10 (|ORD#FromNat| (+ m@@5 n@@1))))))
 :qid |DafnyPreludebpl.422:15|
 :skolemid |441|
 :pattern ( (|ORD#Plus| (|ORD#Plus| o@@10 (|ORD#FromNat| m@@5)) (|ORD#FromNat| n@@1)))
)))
(assert (forall ((o@@11 T@U) (m@@6 Int) (n@@2 Int) ) (!  (=> (= (type o@@11) BoxType) (=> (and (and (<= 0 m@@6) (<= 0 n@@2)) (<= (+ m@@6 n@@2) (|ORD#Offset| o@@11))) (= (|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6)) (|ORD#FromNat| n@@2)) (|ORD#Minus| o@@11 (|ORD#FromNat| (+ m@@6 n@@2))))))
 :qid |DafnyPreludebpl.427:15|
 :skolemid |442|
 :pattern ( (|ORD#Minus| (|ORD#Minus| o@@11 (|ORD#FromNat| m@@6)) (|ORD#FromNat| n@@2)))
)))
(assert (forall ((o@@12 T@U) (m@@7 Int) (n@@3 Int) ) (!  (=> (= (type o@@12) BoxType) (=> (and (and (<= 0 m@@7) (<= 0 n@@3)) (<= n@@3 (+ (|ORD#Offset| o@@12) m@@7))) (and (=> (<= 0 (- m@@7 n@@3)) (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)) (|ORD#Plus| o@@12 (|ORD#FromNat| (- m@@7 n@@3))))) (=> (<= (- m@@7 n@@3) 0) (= (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)) (|ORD#Minus| o@@12 (|ORD#FromNat| (- n@@3 m@@7))))))))
 :qid |DafnyPreludebpl.432:15|
 :skolemid |443|
 :pattern ( (|ORD#Minus| (|ORD#Plus| o@@12 (|ORD#FromNat| m@@7)) (|ORD#FromNat| n@@3)))
)))
(assert (forall ((o@@13 T@U) (m@@8 Int) (n@@4 Int) ) (!  (=> (= (type o@@13) BoxType) (=> (and (and (<= 0 m@@8) (<= 0 n@@4)) (<= n@@4 (+ (|ORD#Offset| o@@13) m@@8))) (and (=> (<= 0 (- m@@8 n@@4)) (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)) (|ORD#Minus| o@@13 (|ORD#FromNat| (- m@@8 n@@4))))) (=> (<= (- m@@8 n@@4) 0) (= (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)) (|ORD#Plus| o@@13 (|ORD#FromNat| (- n@@4 m@@8))))))))
 :qid |DafnyPreludebpl.438:15|
 :skolemid |444|
 :pattern ( (|ORD#Plus| (|ORD#Minus| o@@13 (|ORD#FromNat| m@@8)) (|ORD#FromNat| n@@4)))
)))
(assert  (and (= (Ctor LayerTypeType) 22) (forall ((arg0@@67 T@U) (arg1@@21 T@U) ) (! (let ((A (MapType0TypeInv1 (type arg0@@67))))
(= (type (AtLayer arg0@@67 arg1@@21)) A))
 :qid |funType:AtLayer|
 :pattern ( (AtLayer arg0@@67 arg1@@21))
))))
(assert (forall ((f T@U) (ly T@U) ) (! (let ((A@@0 (MapType0TypeInv1 (type f))))
 (=> (and (= (type f) (MapType0Type LayerTypeType A@@0)) (= (type ly) LayerTypeType)) (= (AtLayer f ly) (MapType0Select f ly))))
 :qid |DafnyPreludebpl.462:18|
 :skolemid |445|
 :pattern ( (AtLayer f ly))
)))
(assert (forall ((arg0@@68 T@U) ) (! (= (type ($LS arg0@@68)) LayerTypeType)
 :qid |funType:$LS|
 :pattern ( ($LS arg0@@68))
)))
(assert (forall ((f@@0 T@U) (ly@@0 T@U) ) (! (let ((A@@1 (MapType0TypeInv1 (type f@@0))))
 (=> (and (= (type f@@0) (MapType0Type LayerTypeType A@@1)) (= (type ly@@0) LayerTypeType)) (= (AtLayer f@@0 ($LS ly@@0)) (AtLayer f@@0 ly@@0))))
 :qid |DafnyPreludebpl.463:18|
 :skolemid |446|
 :pattern ( (AtLayer f@@0 ($LS ly@@0)))
)))
(assert (forall ((arg0@@69 Int) ) (! (= (type (IndexField arg0@@69)) (FieldType BoxType))
 :qid |funType:IndexField|
 :pattern ( (IndexField arg0@@69))
)))
(assert (forall ((i@@1 Int) ) (! (= (FDim (IndexField i@@1)) 1)
 :qid |DafnyPreludebpl.474:15|
 :skolemid |447|
 :pattern ( (IndexField i@@1))
)))
(assert (forall ((i@@2 Int) ) (! (= (IndexField_Inverse (IndexField i@@2)) i@@2)
 :qid |DafnyPreludebpl.476:15|
 :skolemid |448|
 :pattern ( (IndexField i@@2))
)))
(assert (forall ((arg0@@70 T@U) (arg1@@22 Int) ) (! (= (type (MultiIndexField arg0@@70 arg1@@22)) (FieldType BoxType))
 :qid |funType:MultiIndexField|
 :pattern ( (MultiIndexField arg0@@70 arg1@@22))
)))
(assert (forall ((f@@1 T@U) (i@@3 Int) ) (!  (=> (= (type f@@1) (FieldType BoxType)) (= (FDim (MultiIndexField f@@1 i@@3)) (+ (FDim f@@1) 1)))
 :qid |DafnyPreludebpl.479:15|
 :skolemid |449|
 :pattern ( (MultiIndexField f@@1 i@@3))
)))
(assert (forall ((arg0@@71 T@U) ) (! (let ((T@@3 (FieldTypeInv0 (type arg0@@71))))
(= (type (MultiIndexField_Inverse0 arg0@@71)) (FieldType T@@3)))
 :qid |funType:MultiIndexField_Inverse0|
 :pattern ( (MultiIndexField_Inverse0 arg0@@71))
)))
(assert (forall ((f@@2 T@U) (i@@4 Int) ) (!  (=> (= (type f@@2) (FieldType BoxType)) (and (= (MultiIndexField_Inverse0 (MultiIndexField f@@2 i@@4)) f@@2) (= (MultiIndexField_Inverse1 (MultiIndexField f@@2 i@@4)) i@@4)))
 :qid |DafnyPreludebpl.482:15|
 :skolemid |450|
 :pattern ( (MultiIndexField f@@2 i@@4))
)))
(assert  (and (and (forall ((alpha@@3 T@T) (arg0@@72 T@U) (arg1@@23 T@U) ) (! (= (type (FieldOfDecl alpha@@3 arg0@@72 arg1@@23)) (FieldType alpha@@3))
 :qid |funType:FieldOfDecl|
 :pattern ( (FieldOfDecl alpha@@3 arg0@@72 arg1@@23))
)) (forall ((arg0@@73 T@U) ) (! (= (type (DeclType arg0@@73)) ClassNameType)
 :qid |funType:DeclType|
 :pattern ( (DeclType arg0@@73))
))) (forall ((arg0@@74 T@U) ) (! (= (type (DeclName arg0@@74)) NameFamilyType)
 :qid |funType:DeclName|
 :pattern ( (DeclName arg0@@74))
))))
(assert (forall ((cl T@U) (nm T@U) (T@@4 T@T) ) (!  (=> (and (= (type cl) ClassNameType) (= (type nm) NameFamilyType)) (and (= (DeclType (FieldOfDecl T@@4 cl nm)) cl) (= (DeclName (FieldOfDecl T@@4 cl nm)) nm)))
 :qid |DafnyPreludebpl.491:18|
 :skolemid |451|
 :pattern ( (FieldOfDecl T@@4 cl nm))
)))
(assert (forall ((h@@12 T@U) (k T@U) (v@@28 T@U) (t@@21 T@U) ) (!  (=> (and (and (and (and (= (type h@@12) (MapType0Type refType MapType1Type)) (= (type k) (MapType0Type refType MapType1Type))) (= (type t@@21) TyType)) ($HeapSucc h@@12 k)) ($IsAlloc v@@28 t@@21 h@@12)) ($IsAlloc v@@28 t@@21 k))
 :qid |DafnyPreludebpl.504:17|
 :skolemid |452|
 :pattern ( ($HeapSucc h@@12 k) ($IsAlloc v@@28 t@@21 h@@12))
)))
(assert (forall ((h@@13 T@U) (k@@0 T@U) (bx@@21 T@U) (t@@22 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@13) (MapType0Type refType MapType1Type)) (= (type k@@0) (MapType0Type refType MapType1Type))) (= (type bx@@21) BoxType)) (= (type t@@22) TyType)) ($HeapSucc h@@13 k@@0)) ($IsAllocBox bx@@21 t@@22 h@@13)) ($IsAllocBox bx@@21 t@@22 k@@0))
 :qid |DafnyPreludebpl.507:14|
 :skolemid |453|
 :pattern ( ($HeapSucc h@@13 k@@0) ($IsAllocBox bx@@21 t@@22 h@@13))
)))
(assert (= (FDim alloc) 0))
(assert (= (DeclName alloc) allocName))
(assert  (not ($IsGhostField alloc)))
(assert (forall ((o@@14 T@U) ) (!  (=> (= (type o@@14) refType) (<= 0 (_System.array.Length o@@14)))
 :qid |DafnyPreludebpl.524:15|
 :skolemid |454|
 :no-pattern (type o@@14)
 :no-pattern (U_2_int o@@14)
 :no-pattern (U_2_bool o@@14)
)))
(assert (forall ((x@@15 Real) ) (! (= (q@Int x@@15) (to_int x@@15))
 :qid |DafnyPreludebpl.530:14|
 :skolemid |455|
 :pattern ( (q@Int x@@15))
)))
(assert (forall ((x@@16 Int) ) (! (= (q@Real x@@16) (to_real x@@16))
 :qid |DafnyPreludebpl.531:15|
 :skolemid |456|
 :pattern ( (q@Real x@@16))
)))
(assert (forall ((i@@5 Int) ) (! (= (q@Int (q@Real i@@5)) i@@5)
 :qid |DafnyPreludebpl.532:15|
 :skolemid |457|
 :pattern ( (q@Int (q@Real i@@5)))
)))
(assert (= (type $OneHeap) (MapType0Type refType MapType1Type)))
(assert ($IsGoodHeap $OneHeap))
(assert (forall ((h@@14 T@U) (r@@0 T@U) (f@@3 T@U) (x@@17 T@U) ) (! (let ((alpha@@4 (type x@@17)))
 (=> (and (and (and (= (type h@@14) (MapType0Type refType MapType1Type)) (= (type r@@0) refType)) (= (type f@@3) (FieldType alpha@@4))) ($IsGoodHeap (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))) ($HeapSucc h@@14 (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))))
 :qid |DafnyPreludebpl.554:22|
 :skolemid |458|
 :pattern ( (MapType0Store h@@14 r@@0 (MapType1Store (MapType0Select h@@14 r@@0) f@@3 x@@17)))
)))
(assert (forall ((a@@2 T@U) (b@@2 T@U) (c T@U) ) (!  (=> (and (and (and (and (= (type a@@2) (MapType0Type refType MapType1Type)) (= (type b@@2) (MapType0Type refType MapType1Type))) (= (type c) (MapType0Type refType MapType1Type))) (not (= a@@2 c))) (and ($HeapSucc a@@2 b@@2) ($HeapSucc b@@2 c))) ($HeapSucc a@@2 c))
 :qid |DafnyPreludebpl.557:15|
 :skolemid |459|
 :pattern ( ($HeapSucc a@@2 b@@2) ($HeapSucc b@@2 c))
)))
(assert (forall ((h@@15 T@U) (k@@1 T@U) ) (!  (=> (and (and (= (type h@@15) (MapType0Type refType MapType1Type)) (= (type k@@1) (MapType0Type refType MapType1Type))) ($HeapSucc h@@15 k@@1)) (forall ((o@@15 T@U) ) (!  (=> (and (= (type o@@15) refType) (U_2_bool (MapType1Select (MapType0Select h@@15 o@@15) alloc))) (U_2_bool (MapType1Select (MapType0Select k@@1 o@@15) alloc)))
 :qid |DafnyPreludebpl.560:30|
 :skolemid |460|
 :pattern ( (MapType1Select (MapType0Select k@@1 o@@15) alloc))
)))
 :qid |DafnyPreludebpl.559:15|
 :skolemid |461|
 :pattern ( ($HeapSucc h@@15 k@@1))
)))
(assert (forall ((h@@16 T@U) (k@@2 T@U) ) (!  (=> (and (and (= (type h@@16) (MapType0Type refType MapType1Type)) (= (type k@@2) (MapType0Type refType MapType1Type))) ($HeapSuccGhost h@@16 k@@2)) (and ($HeapSucc h@@16 k@@2) (forall ((o@@16 T@U) (f@@4 T@U) ) (! (let ((alpha@@5 (FieldTypeInv0 (type f@@4))))
 (=> (and (and (= (type o@@16) refType) (= (type f@@4) (FieldType alpha@@5))) (not ($IsGhostField f@@4))) (= (MapType1Select (MapType0Select h@@16 o@@16) f@@4) (MapType1Select (MapType0Select k@@2 o@@16) f@@4))))
 :qid |DafnyPreludebpl.566:20|
 :skolemid |462|
 :pattern ( (MapType1Select (MapType0Select k@@2 o@@16) f@@4))
))))
 :qid |DafnyPreludebpl.563:15|
 :skolemid |463|
 :pattern ( ($HeapSuccGhost h@@16 k@@2))
)))
(assert (forall ((s@@3 T@U) ) (! (let ((T@@5 (MapType0TypeInv0 (type s@@3))))
 (=> (= (type s@@3) (MapType0Type T@@5 boolType)) (<= 0 (|Set#Card| s@@3))))
 :qid |DafnyPreludebpl.624:18|
 :skolemid |468|
 :pattern ( (|Set#Card| s@@3))
)))
(assert (forall ((T@@6 T@T) ) (! (= (type (|Set#Empty| T@@6)) (MapType0Type T@@6 boolType))
 :qid |funType:Set#Empty|
 :pattern ( (|Set#Empty| T@@6))
)))
(assert (forall ((o@@17 T@U) ) (! (let ((T@@7 (type o@@17)))
 (not (U_2_bool (MapType0Select (|Set#Empty| T@@7) o@@17))))
 :qid |DafnyPreludebpl.627:18|
 :skolemid |469|
 :pattern ( (let ((T@@7 (type o@@17)))
(MapType0Select (|Set#Empty| T@@7) o@@17)))
)))
(assert (forall ((s@@4 T@U) ) (! (let ((T@@8 (MapType0TypeInv0 (type s@@4))))
 (=> (= (type s@@4) (MapType0Type T@@8 boolType)) (and (= (= (|Set#Card| s@@4) 0) (= s@@4 (|Set#Empty| T@@8))) (=> (not (= (|Set#Card| s@@4) 0)) (exists ((x@@18 T@U) ) (!  (and (= (type x@@18) T@@8) (U_2_bool (MapType0Select s@@4 x@@18)))
 :qid |DafnyPreludebpl.630:33|
 :skolemid |470|
 :no-pattern (type x@@18)
 :no-pattern (U_2_int x@@18)
 :no-pattern (U_2_bool x@@18)
))))))
 :qid |DafnyPreludebpl.628:18|
 :skolemid |471|
 :pattern ( (|Set#Card| s@@4))
)))
(assert (forall ((arg0@@75 T@U) ) (! (let ((T@@9 (type arg0@@75)))
(= (type (|Set#Singleton| arg0@@75)) (MapType0Type T@@9 boolType)))
 :qid |funType:Set#Singleton|
 :pattern ( (|Set#Singleton| arg0@@75))
)))
(assert (forall ((r@@1 T@U) ) (! (U_2_bool (MapType0Select (|Set#Singleton| r@@1) r@@1))
 :qid |DafnyPreludebpl.636:18|
 :skolemid |472|
 :pattern ( (|Set#Singleton| r@@1))
)))
(assert (forall ((r@@2 T@U) (o@@18 T@U) ) (! (let ((T@@10 (type r@@2)))
 (=> (= (type o@@18) T@@10) (= (U_2_bool (MapType0Select (|Set#Singleton| r@@2) o@@18)) (= r@@2 o@@18))))
 :qid |DafnyPreludebpl.637:18|
 :skolemid |473|
 :pattern ( (MapType0Select (|Set#Singleton| r@@2) o@@18))
)))
(assert (forall ((r@@3 T@U) ) (! (= (|Set#Card| (|Set#Singleton| r@@3)) 1)
 :qid |DafnyPreludebpl.638:18|
 :skolemid |474|
 :pattern ( (|Set#Card| (|Set#Singleton| r@@3)))
)))
(assert (forall ((arg0@@76 T@U) (arg1@@24 T@U) ) (! (let ((T@@11 (type arg1@@24)))
(= (type (|Set#UnionOne| arg0@@76 arg1@@24)) (MapType0Type T@@11 boolType)))
 :qid |funType:Set#UnionOne|
 :pattern ( (|Set#UnionOne| arg0@@76 arg1@@24))
)))
(assert (forall ((a@@3 T@U) (x@@19 T@U) (o@@19 T@U) ) (! (let ((T@@12 (type x@@19)))
 (=> (and (= (type a@@3) (MapType0Type T@@12 boolType)) (= (type o@@19) T@@12)) (= (U_2_bool (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))  (or (= o@@19 x@@19) (U_2_bool (MapType0Select a@@3 o@@19))))))
 :qid |DafnyPreludebpl.641:18|
 :skolemid |475|
 :pattern ( (MapType0Select (|Set#UnionOne| a@@3 x@@19) o@@19))
)))
(assert (forall ((a@@4 T@U) (x@@20 T@U) ) (! (let ((T@@13 (type x@@20)))
 (=> (= (type a@@4) (MapType0Type T@@13 boolType)) (U_2_bool (MapType0Select (|Set#UnionOne| a@@4 x@@20) x@@20))))
 :qid |DafnyPreludebpl.643:18|
 :skolemid |476|
 :pattern ( (|Set#UnionOne| a@@4 x@@20))
)))
(assert (forall ((a@@5 T@U) (x@@21 T@U) (y@@1 T@U) ) (! (let ((T@@14 (type x@@21)))
 (=> (and (and (= (type a@@5) (MapType0Type T@@14 boolType)) (= (type y@@1) T@@14)) (U_2_bool (MapType0Select a@@5 y@@1))) (U_2_bool (MapType0Select (|Set#UnionOne| a@@5 x@@21) y@@1))))
 :qid |DafnyPreludebpl.645:18|
 :skolemid |477|
 :pattern ( (|Set#UnionOne| a@@5 x@@21) (MapType0Select a@@5 y@@1))
)))
(assert (forall ((a@@6 T@U) (x@@22 T@U) ) (! (let ((T@@15 (type x@@22)))
 (=> (and (= (type a@@6) (MapType0Type T@@15 boolType)) (U_2_bool (MapType0Select a@@6 x@@22))) (= (|Set#Card| (|Set#UnionOne| a@@6 x@@22)) (|Set#Card| a@@6))))
 :qid |DafnyPreludebpl.647:18|
 :skolemid |478|
 :pattern ( (|Set#Card| (|Set#UnionOne| a@@6 x@@22)))
)))
(assert (forall ((a@@7 T@U) (x@@23 T@U) ) (! (let ((T@@16 (type x@@23)))
 (=> (and (= (type a@@7) (MapType0Type T@@16 boolType)) (not (U_2_bool (MapType0Select a@@7 x@@23)))) (= (|Set#Card| (|Set#UnionOne| a@@7 x@@23)) (+ (|Set#Card| a@@7) 1))))
 :qid |DafnyPreludebpl.649:18|
 :skolemid |479|
 :pattern ( (|Set#Card| (|Set#UnionOne| a@@7 x@@23)))
)))
(assert (forall ((arg0@@77 T@U) (arg1@@25 T@U) ) (! (let ((T@@17 (MapType0TypeInv0 (type arg0@@77))))
(= (type (|Set#Union| arg0@@77 arg1@@25)) (MapType0Type T@@17 boolType)))
 :qid |funType:Set#Union|
 :pattern ( (|Set#Union| arg0@@77 arg1@@25))
)))
(assert (forall ((a@@8 T@U) (b@@3 T@U) (o@@20 T@U) ) (! (let ((T@@18 (type o@@20)))
 (=> (and (= (type a@@8) (MapType0Type T@@18 boolType)) (= (type b@@3) (MapType0Type T@@18 boolType))) (= (U_2_bool (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))  (or (U_2_bool (MapType0Select a@@8 o@@20)) (U_2_bool (MapType0Select b@@3 o@@20))))))
 :qid |DafnyPreludebpl.653:18|
 :skolemid |480|
 :pattern ( (MapType0Select (|Set#Union| a@@8 b@@3) o@@20))
)))
(assert (forall ((a@@9 T@U) (b@@4 T@U) (y@@2 T@U) ) (! (let ((T@@19 (type y@@2)))
 (=> (and (and (= (type a@@9) (MapType0Type T@@19 boolType)) (= (type b@@4) (MapType0Type T@@19 boolType))) (U_2_bool (MapType0Select a@@9 y@@2))) (U_2_bool (MapType0Select (|Set#Union| a@@9 b@@4) y@@2))))
 :qid |DafnyPreludebpl.655:18|
 :skolemid |481|
 :pattern ( (|Set#Union| a@@9 b@@4) (MapType0Select a@@9 y@@2))
)))
(assert (forall ((a@@10 T@U) (b@@5 T@U) (y@@3 T@U) ) (! (let ((T@@20 (type y@@3)))
 (=> (and (and (= (type a@@10) (MapType0Type T@@20 boolType)) (= (type b@@5) (MapType0Type T@@20 boolType))) (U_2_bool (MapType0Select b@@5 y@@3))) (U_2_bool (MapType0Select (|Set#Union| a@@10 b@@5) y@@3))))
 :qid |DafnyPreludebpl.657:18|
 :skolemid |482|
 :pattern ( (|Set#Union| a@@10 b@@5) (MapType0Select b@@5 y@@3))
)))
(assert (forall ((arg0@@78 T@U) (arg1@@26 T@U) ) (! (let ((T@@21 (MapType0TypeInv0 (type arg0@@78))))
(= (type (|Set#Difference| arg0@@78 arg1@@26)) (MapType0Type T@@21 boolType)))
 :qid |funType:Set#Difference|
 :pattern ( (|Set#Difference| arg0@@78 arg1@@26))
)))
(assert (forall ((a@@11 T@U) (b@@6 T@U) ) (! (let ((T@@22 (MapType0TypeInv0 (type a@@11))))
 (=> (and (and (= (type a@@11) (MapType0Type T@@22 boolType)) (= (type b@@6) (MapType0Type T@@22 boolType))) (|Set#Disjoint| a@@11 b@@6)) (and (= (|Set#Difference| (|Set#Union| a@@11 b@@6) a@@11) b@@6) (= (|Set#Difference| (|Set#Union| a@@11 b@@6) b@@6) a@@11))))
 :qid |DafnyPreludebpl.659:18|
 :skolemid |483|
 :pattern ( (|Set#Union| a@@11 b@@6))
)))
(assert (forall ((arg0@@79 T@U) (arg1@@27 T@U) ) (! (let ((T@@23 (MapType0TypeInv0 (type arg0@@79))))
(= (type (|Set#Intersection| arg0@@79 arg1@@27)) (MapType0Type T@@23 boolType)))
 :qid |funType:Set#Intersection|
 :pattern ( (|Set#Intersection| arg0@@79 arg1@@27))
)))
(assert (forall ((a@@12 T@U) (b@@7 T@U) (o@@21 T@U) ) (! (let ((T@@24 (type o@@21)))
 (=> (and (= (type a@@12) (MapType0Type T@@24 boolType)) (= (type b@@7) (MapType0Type T@@24 boolType))) (= (U_2_bool (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))  (and (U_2_bool (MapType0Select a@@12 o@@21)) (U_2_bool (MapType0Select b@@7 o@@21))))))
 :qid |DafnyPreludebpl.669:18|
 :skolemid |484|
 :pattern ( (MapType0Select (|Set#Intersection| a@@12 b@@7) o@@21))
)))
(assert (forall ((a@@13 T@U) (b@@8 T@U) ) (! (let ((T@@25 (MapType0TypeInv0 (type a@@13))))
 (=> (and (= (type a@@13) (MapType0Type T@@25 boolType)) (= (type b@@8) (MapType0Type T@@25 boolType))) (= (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8) (|Set#Union| a@@13 b@@8))))
 :qid |DafnyPreludebpl.672:18|
 :skolemid |485|
 :pattern ( (|Set#Union| (|Set#Union| a@@13 b@@8) b@@8))
)))
(assert (forall ((a@@14 T@U) (b@@9 T@U) ) (! (let ((T@@26 (MapType0TypeInv0 (type a@@14))))
 (=> (and (= (type a@@14) (MapType0Type T@@26 boolType)) (= (type b@@9) (MapType0Type T@@26 boolType))) (= (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)) (|Set#Union| a@@14 b@@9))))
 :qid |DafnyPreludebpl.674:18|
 :skolemid |486|
 :pattern ( (|Set#Union| a@@14 (|Set#Union| a@@14 b@@9)))
)))
(assert (forall ((a@@15 T@U) (b@@10 T@U) ) (! (let ((T@@27 (MapType0TypeInv0 (type a@@15))))
 (=> (and (= (type a@@15) (MapType0Type T@@27 boolType)) (= (type b@@10) (MapType0Type T@@27 boolType))) (= (|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10) (|Set#Intersection| a@@15 b@@10))))
 :qid |DafnyPreludebpl.676:18|
 :skolemid |487|
 :pattern ( (|Set#Intersection| (|Set#Intersection| a@@15 b@@10) b@@10))
)))
(assert (forall ((a@@16 T@U) (b@@11 T@U) ) (! (let ((T@@28 (MapType0TypeInv0 (type a@@16))))
 (=> (and (= (type a@@16) (MapType0Type T@@28 boolType)) (= (type b@@11) (MapType0Type T@@28 boolType))) (= (|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11)) (|Set#Intersection| a@@16 b@@11))))
 :qid |DafnyPreludebpl.678:18|
 :skolemid |488|
 :pattern ( (|Set#Intersection| a@@16 (|Set#Intersection| a@@16 b@@11)))
)))
(assert (forall ((a@@17 T@U) (b@@12 T@U) ) (! (let ((T@@29 (MapType0TypeInv0 (type a@@17))))
 (=> (and (= (type a@@17) (MapType0Type T@@29 boolType)) (= (type b@@12) (MapType0Type T@@29 boolType))) (= (+ (|Set#Card| (|Set#Union| a@@17 b@@12)) (|Set#Card| (|Set#Intersection| a@@17 b@@12))) (+ (|Set#Card| a@@17) (|Set#Card| b@@12)))))
 :qid |DafnyPreludebpl.680:18|
 :skolemid |489|
 :pattern ( (|Set#Card| (|Set#Union| a@@17 b@@12)))
 :pattern ( (|Set#Card| (|Set#Intersection| a@@17 b@@12)))
)))
(assert (forall ((a@@18 T@U) (b@@13 T@U) (o@@22 T@U) ) (! (let ((T@@30 (type o@@22)))
 (=> (and (= (type a@@18) (MapType0Type T@@30 boolType)) (= (type b@@13) (MapType0Type T@@30 boolType))) (= (U_2_bool (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))  (and (U_2_bool (MapType0Select a@@18 o@@22)) (not (U_2_bool (MapType0Select b@@13 o@@22)))))))
 :qid |DafnyPreludebpl.684:18|
 :skolemid |490|
 :pattern ( (MapType0Select (|Set#Difference| a@@18 b@@13) o@@22))
)))
(assert (forall ((a@@19 T@U) (b@@14 T@U) (y@@4 T@U) ) (! (let ((T@@31 (type y@@4)))
 (=> (and (and (= (type a@@19) (MapType0Type T@@31 boolType)) (= (type b@@14) (MapType0Type T@@31 boolType))) (U_2_bool (MapType0Select b@@14 y@@4))) (not (U_2_bool (MapType0Select (|Set#Difference| a@@19 b@@14) y@@4)))))
 :qid |DafnyPreludebpl.686:18|
 :skolemid |491|
 :pattern ( (|Set#Difference| a@@19 b@@14) (MapType0Select b@@14 y@@4))
)))
(assert (forall ((a@@20 T@U) (b@@15 T@U) ) (! (let ((T@@32 (MapType0TypeInv0 (type a@@20))))
 (=> (and (= (type a@@20) (MapType0Type T@@32 boolType)) (= (type b@@15) (MapType0Type T@@32 boolType))) (and (= (+ (+ (|Set#Card| (|Set#Difference| a@@20 b@@15)) (|Set#Card| (|Set#Difference| b@@15 a@@20))) (|Set#Card| (|Set#Intersection| a@@20 b@@15))) (|Set#Card| (|Set#Union| a@@20 b@@15))) (= (|Set#Card| (|Set#Difference| a@@20 b@@15)) (- (|Set#Card| a@@20) (|Set#Card| (|Set#Intersection| a@@20 b@@15)))))))
 :qid |DafnyPreludebpl.688:18|
 :skolemid |492|
 :pattern ( (|Set#Card| (|Set#Difference| a@@20 b@@15)))
)))
(assert (forall ((a@@21 T@U) (b@@16 T@U) ) (! (let ((T@@33 (MapType0TypeInv0 (type a@@21))))
 (=> (and (= (type a@@21) (MapType0Type T@@33 boolType)) (= (type b@@16) (MapType0Type T@@33 boolType))) (= (|Set#Subset| a@@21 b@@16) (forall ((o@@23 T@U) ) (!  (=> (and (= (type o@@23) T@@33) (U_2_bool (MapType0Select a@@21 o@@23))) (U_2_bool (MapType0Select b@@16 o@@23)))
 :qid |DafnyPreludebpl.697:32|
 :skolemid |493|
 :pattern ( (MapType0Select a@@21 o@@23))
 :pattern ( (MapType0Select b@@16 o@@23))
)))))
 :qid |DafnyPreludebpl.696:17|
 :skolemid |494|
 :pattern ( (|Set#Subset| a@@21 b@@16))
)))
(assert (forall ((a@@22 T@U) (b@@17 T@U) ) (! (let ((T@@34 (MapType0TypeInv0 (type a@@22))))
 (=> (and (= (type a@@22) (MapType0Type T@@34 boolType)) (= (type b@@17) (MapType0Type T@@34 boolType))) (= (|Set#Equal| a@@22 b@@17) (forall ((o@@24 T@U) ) (!  (=> (= (type o@@24) T@@34) (= (U_2_bool (MapType0Select a@@22 o@@24)) (U_2_bool (MapType0Select b@@17 o@@24))))
 :qid |DafnyPreludebpl.705:31|
 :skolemid |495|
 :pattern ( (MapType0Select a@@22 o@@24))
 :pattern ( (MapType0Select b@@17 o@@24))
)))))
 :qid |DafnyPreludebpl.704:17|
 :skolemid |496|
 :pattern ( (|Set#Equal| a@@22 b@@17))
)))
(assert (forall ((a@@23 T@U) (b@@18 T@U) ) (! (let ((T@@35 (MapType0TypeInv0 (type a@@23))))
 (=> (and (and (= (type a@@23) (MapType0Type T@@35 boolType)) (= (type b@@18) (MapType0Type T@@35 boolType))) (|Set#Equal| a@@23 b@@18)) (= a@@23 b@@18)))
 :qid |DafnyPreludebpl.706:17|
 :skolemid |497|
 :pattern ( (|Set#Equal| a@@23 b@@18))
)))
(assert (forall ((a@@24 T@U) (b@@19 T@U) ) (! (let ((T@@36 (MapType0TypeInv0 (type a@@24))))
 (=> (and (= (type a@@24) (MapType0Type T@@36 boolType)) (= (type b@@19) (MapType0Type T@@36 boolType))) (= (|Set#Disjoint| a@@24 b@@19) (forall ((o@@25 T@U) ) (!  (=> (= (type o@@25) T@@36) (or (not (U_2_bool (MapType0Select a@@24 o@@25))) (not (U_2_bool (MapType0Select b@@19 o@@25)))))
 :qid |DafnyPreludebpl.711:34|
 :skolemid |498|
 :pattern ( (MapType0Select a@@24 o@@25))
 :pattern ( (MapType0Select b@@19 o@@25))
)))))
 :qid |DafnyPreludebpl.710:18|
 :skolemid |499|
 :pattern ( (|Set#Disjoint| a@@24 b@@19))
)))
(assert (forall ((T@@37 T@T) ) (! (= (type (|ISet#Empty| T@@37)) (MapType0Type T@@37 boolType))
 :qid |funType:ISet#Empty|
 :pattern ( (|ISet#Empty| T@@37))
)))
(assert (forall ((o@@26 T@U) ) (! (let ((T@@38 (type o@@26)))
 (not (U_2_bool (MapType0Select (|ISet#Empty| T@@38) o@@26))))
 :qid |DafnyPreludebpl.720:18|
 :skolemid |500|
 :pattern ( (let ((T@@38 (type o@@26)))
(MapType0Select (|ISet#Empty| T@@38) o@@26)))
)))
(assert (forall ((arg0@@80 T@U) (arg1@@28 T@U) ) (! (let ((T@@39 (type arg1@@28)))
(= (type (|ISet#UnionOne| arg0@@80 arg1@@28)) (MapType0Type T@@39 boolType)))
 :qid |funType:ISet#UnionOne|
 :pattern ( (|ISet#UnionOne| arg0@@80 arg1@@28))
)))
(assert (forall ((a@@25 T@U) (x@@24 T@U) (o@@27 T@U) ) (! (let ((T@@40 (type x@@24)))
 (=> (and (= (type a@@25) (MapType0Type T@@40 boolType)) (= (type o@@27) T@@40)) (= (U_2_bool (MapType0Select (|ISet#UnionOne| a@@25 x@@24) o@@27))  (or (= o@@27 x@@24) (U_2_bool (MapType0Select a@@25 o@@27))))))
 :qid |DafnyPreludebpl.727:18|
 :skolemid |501|
 :pattern ( (MapType0Select (|ISet#UnionOne| a@@25 x@@24) o@@27))
)))
(assert (forall ((a@@26 T@U) (x@@25 T@U) ) (! (let ((T@@41 (type x@@25)))
 (=> (= (type a@@26) (MapType0Type T@@41 boolType)) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@26 x@@25) x@@25))))
 :qid |DafnyPreludebpl.729:18|
 :skolemid |502|
 :pattern ( (|ISet#UnionOne| a@@26 x@@25))
)))
(assert (forall ((a@@27 T@U) (x@@26 T@U) (y@@5 T@U) ) (! (let ((T@@42 (type x@@26)))
 (=> (and (and (= (type a@@27) (MapType0Type T@@42 boolType)) (= (type y@@5) T@@42)) (U_2_bool (MapType0Select a@@27 y@@5))) (U_2_bool (MapType0Select (|ISet#UnionOne| a@@27 x@@26) y@@5))))
 :qid |DafnyPreludebpl.731:18|
 :skolemid |503|
 :pattern ( (|ISet#UnionOne| a@@27 x@@26) (MapType0Select a@@27 y@@5))
)))
(assert (forall ((arg0@@81 T@U) (arg1@@29 T@U) ) (! (let ((T@@43 (MapType0TypeInv0 (type arg0@@81))))
(= (type (|ISet#Union| arg0@@81 arg1@@29)) (MapType0Type T@@43 boolType)))
 :qid |funType:ISet#Union|
 :pattern ( (|ISet#Union| arg0@@81 arg1@@29))
)))
(assert (forall ((a@@28 T@U) (b@@20 T@U) (o@@28 T@U) ) (! (let ((T@@44 (type o@@28)))
 (=> (and (= (type a@@28) (MapType0Type T@@44 boolType)) (= (type b@@20) (MapType0Type T@@44 boolType))) (= (U_2_bool (MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))  (or (U_2_bool (MapType0Select a@@28 o@@28)) (U_2_bool (MapType0Select b@@20 o@@28))))))
 :qid |DafnyPreludebpl.735:18|
 :skolemid |504|
 :pattern ( (MapType0Select (|ISet#Union| a@@28 b@@20) o@@28))
)))
(assert (forall ((a@@29 T@U) (b@@21 T@U) (y@@6 T@U) ) (! (let ((T@@45 (type y@@6)))
 (=> (and (and (= (type a@@29) (MapType0Type T@@45 boolType)) (= (type b@@21) (MapType0Type T@@45 boolType))) (U_2_bool (MapType0Select a@@29 y@@6))) (U_2_bool (MapType0Select (|ISet#Union| a@@29 b@@21) y@@6))))
 :qid |DafnyPreludebpl.737:18|
 :skolemid |505|
 :pattern ( (|ISet#Union| a@@29 b@@21) (MapType0Select a@@29 y@@6))
)))
(assert (forall ((a@@30 T@U) (b@@22 T@U) (y@@7 T@U) ) (! (let ((T@@46 (type y@@7)))
 (=> (and (and (= (type a@@30) (MapType0Type T@@46 boolType)) (= (type b@@22) (MapType0Type T@@46 boolType))) (U_2_bool (MapType0Select b@@22 y@@7))) (U_2_bool (MapType0Select (|ISet#Union| a@@30 b@@22) y@@7))))
 :qid |DafnyPreludebpl.739:18|
 :skolemid |506|
 :pattern ( (|ISet#Union| a@@30 b@@22) (MapType0Select b@@22 y@@7))
)))
(assert (forall ((arg0@@82 T@U) (arg1@@30 T@U) ) (! (let ((T@@47 (MapType0TypeInv0 (type arg0@@82))))
(= (type (|ISet#Difference| arg0@@82 arg1@@30)) (MapType0Type T@@47 boolType)))
 :qid |funType:ISet#Difference|
 :pattern ( (|ISet#Difference| arg0@@82 arg1@@30))
)))
(assert (forall ((a@@31 T@U) (b@@23 T@U) ) (! (let ((T@@48 (MapType0TypeInv0 (type a@@31))))
 (=> (and (and (= (type a@@31) (MapType0Type T@@48 boolType)) (= (type b@@23) (MapType0Type T@@48 boolType))) (|ISet#Disjoint| a@@31 b@@23)) (and (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) a@@31) b@@23) (= (|ISet#Difference| (|ISet#Union| a@@31 b@@23) b@@23) a@@31))))
 :qid |DafnyPreludebpl.741:18|
 :skolemid |507|
 :pattern ( (|ISet#Union| a@@31 b@@23))
)))
(assert (forall ((arg0@@83 T@U) (arg1@@31 T@U) ) (! (let ((T@@49 (MapType0TypeInv0 (type arg0@@83))))
(= (type (|ISet#Intersection| arg0@@83 arg1@@31)) (MapType0Type T@@49 boolType)))
 :qid |funType:ISet#Intersection|
 :pattern ( (|ISet#Intersection| arg0@@83 arg1@@31))
)))
(assert (forall ((a@@32 T@U) (b@@24 T@U) (o@@29 T@U) ) (! (let ((T@@50 (type o@@29)))
 (=> (and (= (type a@@32) (MapType0Type T@@50 boolType)) (= (type b@@24) (MapType0Type T@@50 boolType))) (= (U_2_bool (MapType0Select (|ISet#Intersection| a@@32 b@@24) o@@29))  (and (U_2_bool (MapType0Select a@@32 o@@29)) (U_2_bool (MapType0Select b@@24 o@@29))))))
 :qid |DafnyPreludebpl.747:18|
 :skolemid |508|
 :pattern ( (MapType0Select (|ISet#Intersection| a@@32 b@@24) o@@29))
)))
(assert (forall ((a@@33 T@U) (b@@25 T@U) ) (! (let ((T@@51 (MapType0TypeInv0 (type a@@33))))
 (=> (and (= (type a@@33) (MapType0Type T@@51 boolType)) (= (type b@@25) (MapType0Type T@@51 boolType))) (= (|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25) (|ISet#Union| a@@33 b@@25))))
 :qid |DafnyPreludebpl.750:18|
 :skolemid |509|
 :pattern ( (|ISet#Union| (|ISet#Union| a@@33 b@@25) b@@25))
)))
(assert (forall ((a@@34 T@U) (b@@26 T@U) ) (! (let ((T@@52 (MapType0TypeInv0 (type a@@34))))
 (=> (and (= (type a@@34) (MapType0Type T@@52 boolType)) (= (type b@@26) (MapType0Type T@@52 boolType))) (= (|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26)) (|ISet#Union| a@@34 b@@26))))
 :qid |DafnyPreludebpl.752:18|
 :skolemid |510|
 :pattern ( (|ISet#Union| a@@34 (|ISet#Union| a@@34 b@@26)))
)))
(assert (forall ((a@@35 T@U) (b@@27 T@U) ) (! (let ((T@@53 (MapType0TypeInv0 (type a@@35))))
 (=> (and (= (type a@@35) (MapType0Type T@@53 boolType)) (= (type b@@27) (MapType0Type T@@53 boolType))) (= (|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27) (|ISet#Intersection| a@@35 b@@27))))
 :qid |DafnyPreludebpl.754:18|
 :skolemid |511|
 :pattern ( (|ISet#Intersection| (|ISet#Intersection| a@@35 b@@27) b@@27))
)))
(assert (forall ((a@@36 T@U) (b@@28 T@U) ) (! (let ((T@@54 (MapType0TypeInv0 (type a@@36))))
 (=> (and (= (type a@@36) (MapType0Type T@@54 boolType)) (= (type b@@28) (MapType0Type T@@54 boolType))) (= (|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28)) (|ISet#Intersection| a@@36 b@@28))))
 :qid |DafnyPreludebpl.756:18|
 :skolemid |512|
 :pattern ( (|ISet#Intersection| a@@36 (|ISet#Intersection| a@@36 b@@28)))
)))
(assert (forall ((a@@37 T@U) (b@@29 T@U) (o@@30 T@U) ) (! (let ((T@@55 (type o@@30)))
 (=> (and (= (type a@@37) (MapType0Type T@@55 boolType)) (= (type b@@29) (MapType0Type T@@55 boolType))) (= (U_2_bool (MapType0Select (|ISet#Difference| a@@37 b@@29) o@@30))  (and (U_2_bool (MapType0Select a@@37 o@@30)) (not (U_2_bool (MapType0Select b@@29 o@@30)))))))
 :qid |DafnyPreludebpl.761:18|
 :skolemid |513|
 :pattern ( (MapType0Select (|ISet#Difference| a@@37 b@@29) o@@30))
)))
(assert (forall ((a@@38 T@U) (b@@30 T@U) (y@@8 T@U) ) (! (let ((T@@56 (type y@@8)))
 (=> (and (and (= (type a@@38) (MapType0Type T@@56 boolType)) (= (type b@@30) (MapType0Type T@@56 boolType))) (U_2_bool (MapType0Select b@@30 y@@8))) (not (U_2_bool (MapType0Select (|ISet#Difference| a@@38 b@@30) y@@8)))))
 :qid |DafnyPreludebpl.763:18|
 :skolemid |514|
 :pattern ( (|ISet#Difference| a@@38 b@@30) (MapType0Select b@@30 y@@8))
)))
(assert (forall ((a@@39 T@U) (b@@31 T@U) ) (! (let ((T@@57 (MapType0TypeInv0 (type a@@39))))
 (=> (and (= (type a@@39) (MapType0Type T@@57 boolType)) (= (type b@@31) (MapType0Type T@@57 boolType))) (= (|ISet#Subset| a@@39 b@@31) (forall ((o@@31 T@U) ) (!  (=> (and (= (type o@@31) T@@57) (U_2_bool (MapType0Select a@@39 o@@31))) (U_2_bool (MapType0Select b@@31 o@@31)))
 :qid |DafnyPreludebpl.768:33|
 :skolemid |515|
 :pattern ( (MapType0Select a@@39 o@@31))
 :pattern ( (MapType0Select b@@31 o@@31))
)))))
 :qid |DafnyPreludebpl.767:17|
 :skolemid |516|
 :pattern ( (|ISet#Subset| a@@39 b@@31))
)))
(assert (forall ((a@@40 T@U) (b@@32 T@U) ) (! (let ((T@@58 (MapType0TypeInv0 (type a@@40))))
 (=> (and (= (type a@@40) (MapType0Type T@@58 boolType)) (= (type b@@32) (MapType0Type T@@58 boolType))) (= (|ISet#Equal| a@@40 b@@32) (forall ((o@@32 T@U) ) (!  (=> (= (type o@@32) T@@58) (= (U_2_bool (MapType0Select a@@40 o@@32)) (U_2_bool (MapType0Select b@@32 o@@32))))
 :qid |DafnyPreludebpl.772:32|
 :skolemid |517|
 :pattern ( (MapType0Select a@@40 o@@32))
 :pattern ( (MapType0Select b@@32 o@@32))
)))))
 :qid |DafnyPreludebpl.771:17|
 :skolemid |518|
 :pattern ( (|ISet#Equal| a@@40 b@@32))
)))
(assert (forall ((a@@41 T@U) (b@@33 T@U) ) (! (let ((T@@59 (MapType0TypeInv0 (type a@@41))))
 (=> (and (and (= (type a@@41) (MapType0Type T@@59 boolType)) (= (type b@@33) (MapType0Type T@@59 boolType))) (|ISet#Equal| a@@41 b@@33)) (= a@@41 b@@33)))
 :qid |DafnyPreludebpl.773:17|
 :skolemid |519|
 :pattern ( (|ISet#Equal| a@@41 b@@33))
)))
(assert (forall ((a@@42 T@U) (b@@34 T@U) ) (! (let ((T@@60 (MapType0TypeInv0 (type a@@42))))
 (=> (and (= (type a@@42) (MapType0Type T@@60 boolType)) (= (type b@@34) (MapType0Type T@@60 boolType))) (= (|ISet#Disjoint| a@@42 b@@34) (forall ((o@@33 T@U) ) (!  (=> (= (type o@@33) T@@60) (or (not (U_2_bool (MapType0Select a@@42 o@@33))) (not (U_2_bool (MapType0Select b@@34 o@@33)))))
 :qid |DafnyPreludebpl.778:35|
 :skolemid |520|
 :pattern ( (MapType0Select a@@42 o@@33))
 :pattern ( (MapType0Select b@@34 o@@33))
)))))
 :qid |DafnyPreludebpl.777:18|
 :skolemid |521|
 :pattern ( (|ISet#Disjoint| a@@42 b@@34))
)))
(assert (forall ((a@@43 Int) (b@@35 Int) ) (! (= (<= a@@43 b@@35) (= (|Math#min| a@@43 b@@35) a@@43))
 :qid |DafnyPreludebpl.785:15|
 :skolemid |522|
 :pattern ( (|Math#min| a@@43 b@@35))
)))
(assert (forall ((a@@44 Int) (b@@36 Int) ) (! (= (<= b@@36 a@@44) (= (|Math#min| a@@44 b@@36) b@@36))
 :qid |DafnyPreludebpl.786:15|
 :skolemid |523|
 :pattern ( (|Math#min| a@@44 b@@36))
)))
(assert (forall ((a@@45 Int) (b@@37 Int) ) (!  (or (= (|Math#min| a@@45 b@@37) a@@45) (= (|Math#min| a@@45 b@@37) b@@37))
 :qid |DafnyPreludebpl.787:15|
 :skolemid |524|
 :pattern ( (|Math#min| a@@45 b@@37))
)))
(assert (forall ((a@@46 Int) ) (!  (=> (<= 0 a@@46) (= (|Math#clip| a@@46) a@@46))
 :qid |DafnyPreludebpl.790:15|
 :skolemid |525|
 :pattern ( (|Math#clip| a@@46))
)))
(assert (forall ((a@@47 Int) ) (!  (=> (< a@@47 0) (= (|Math#clip| a@@47) 0))
 :qid |DafnyPreludebpl.791:15|
 :skolemid |526|
 :pattern ( (|Math#clip| a@@47))
)))
(assert (forall ((ms T@U) ) (! (let ((T@@61 (MapType0TypeInv0 (type ms))))
 (=> (= (type ms) (MapType0Type T@@61 intType)) (= ($IsGoodMultiSet ms) (forall ((bx@@22 T@U) ) (!  (=> (= (type bx@@22) T@@61) (and (<= 0 (U_2_int (MapType0Select ms bx@@22))) (<= (U_2_int (MapType0Select ms bx@@22)) (|MultiSet#Card| ms))))
 :qid |DafnyPreludebpl.799:11|
 :skolemid |527|
 :pattern ( (MapType0Select ms bx@@22))
)))))
 :qid |DafnyPreludebpl.797:18|
 :skolemid |528|
 :pattern ( ($IsGoodMultiSet ms))
)))
(assert (forall ((s@@5 T@U) ) (! (let ((T@@62 (MapType0TypeInv0 (type s@@5))))
 (=> (= (type s@@5) (MapType0Type T@@62 intType)) (<= 0 (|MultiSet#Card| s@@5))))
 :qid |DafnyPreludebpl.802:18|
 :skolemid |529|
 :pattern ( (|MultiSet#Card| s@@5))
)))
(assert (forall ((s@@6 T@U) (x@@27 T@U) (n@@5 T@U) ) (! (let ((T@@63 (type x@@27)))
 (=> (and (and (= (type s@@6) (MapType0Type T@@63 intType)) (= (type n@@5) intType)) (<= 0 (U_2_int n@@5))) (= (|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)) (+ (- (|MultiSet#Card| s@@6) (U_2_int (MapType0Select s@@6 x@@27))) (U_2_int n@@5)))))
 :qid |DafnyPreludebpl.803:18|
 :skolemid |530|
 :pattern ( (|MultiSet#Card| (MapType0Store s@@6 x@@27 n@@5)))
)))
(assert (forall ((T@@64 T@T) ) (! (= (type (|MultiSet#Empty| T@@64)) (MapType0Type T@@64 intType))
 :qid |funType:MultiSet#Empty|
 :pattern ( (|MultiSet#Empty| T@@64))
)))
(assert (forall ((o@@34 T@U) ) (! (let ((T@@65 (type o@@34)))
(= (U_2_int (MapType0Select (|MultiSet#Empty| T@@65) o@@34)) 0))
 :qid |DafnyPreludebpl.807:18|
 :skolemid |531|
 :pattern ( (let ((T@@65 (type o@@34)))
(MapType0Select (|MultiSet#Empty| T@@65) o@@34)))
)))
(assert (forall ((s@@7 T@U) ) (! (let ((T@@66 (MapType0TypeInv0 (type s@@7))))
 (=> (= (type s@@7) (MapType0Type T@@66 intType)) (and (= (= (|MultiSet#Card| s@@7) 0) (= s@@7 (|MultiSet#Empty| T@@66))) (=> (not (= (|MultiSet#Card| s@@7) 0)) (exists ((x@@28 T@U) ) (!  (and (= (type x@@28) T@@66) (< 0 (U_2_int (MapType0Select s@@7 x@@28))))
 :qid |DafnyPreludebpl.810:38|
 :skolemid |532|
 :no-pattern (type x@@28)
 :no-pattern (U_2_int x@@28)
 :no-pattern (U_2_bool x@@28)
))))))
 :qid |DafnyPreludebpl.808:18|
 :skolemid |533|
 :pattern ( (|MultiSet#Card| s@@7))
)))
(assert (forall ((arg0@@84 T@U) ) (! (let ((T@@67 (type arg0@@84)))
(= (type (|MultiSet#Singleton| arg0@@84)) (MapType0Type T@@67 intType)))
 :qid |funType:MultiSet#Singleton|
 :pattern ( (|MultiSet#Singleton| arg0@@84))
)))
(assert (forall ((r@@4 T@U) (o@@35 T@U) ) (! (let ((T@@68 (type r@@4)))
 (=> (= (type o@@35) T@@68) (and (= (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35)) 1) (= r@@4 o@@35)) (= (= (U_2_int (MapType0Select (|MultiSet#Singleton| r@@4) o@@35)) 0) (not (= r@@4 o@@35))))))
 :qid |DafnyPreludebpl.813:18|
 :skolemid |534|
 :pattern ( (MapType0Select (|MultiSet#Singleton| r@@4) o@@35))
)))
(assert (forall ((arg0@@85 T@U) (arg1@@32 T@U) ) (! (let ((T@@69 (type arg1@@32)))
(= (type (|MultiSet#UnionOne| arg0@@85 arg1@@32)) (MapType0Type T@@69 intType)))
 :qid |funType:MultiSet#UnionOne|
 :pattern ( (|MultiSet#UnionOne| arg0@@85 arg1@@32))
)))
(assert (forall ((r@@5 T@U) ) (! (let ((T@@70 (type r@@5)))
(= (|MultiSet#Singleton| r@@5) (|MultiSet#UnionOne| (|MultiSet#Empty| T@@70) r@@5)))
 :qid |DafnyPreludebpl.815:18|
 :skolemid |535|
 :pattern ( (|MultiSet#Singleton| r@@5))
)))
(assert (forall ((a@@48 T@U) (x@@29 T@U) (o@@36 T@U) ) (! (let ((T@@71 (type x@@29)))
 (=> (and (= (type a@@48) (MapType0Type T@@71 intType)) (= (type o@@36) T@@71)) (= (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@48 x@@29) o@@36)))  (or (= o@@36 x@@29) (< 0 (U_2_int (MapType0Select a@@48 o@@36)))))))
 :qid |DafnyPreludebpl.819:18|
 :skolemid |536|
 :pattern ( (MapType0Select (|MultiSet#UnionOne| a@@48 x@@29) o@@36))
)))
(assert (forall ((a@@49 T@U) (x@@30 T@U) ) (! (let ((T@@72 (type x@@30)))
 (=> (= (type a@@49) (MapType0Type T@@72 intType)) (= (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@49 x@@30) x@@30)) (+ (U_2_int (MapType0Select a@@49 x@@30)) 1))))
 :qid |DafnyPreludebpl.822:18|
 :skolemid |537|
 :pattern ( (|MultiSet#UnionOne| a@@49 x@@30))
)))
(assert (forall ((a@@50 T@U) (x@@31 T@U) (y@@9 T@U) ) (! (let ((T@@73 (type x@@31)))
 (=> (and (and (= (type a@@50) (MapType0Type T@@73 intType)) (= (type y@@9) T@@73)) (< 0 (U_2_int (MapType0Select a@@50 y@@9)))) (< 0 (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@50 x@@31) y@@9)))))
 :qid |DafnyPreludebpl.825:18|
 :skolemid |538|
 :pattern ( (|MultiSet#UnionOne| a@@50 x@@31) (MapType0Select a@@50 y@@9))
)))
(assert (forall ((a@@51 T@U) (x@@32 T@U) (y@@10 T@U) ) (! (let ((T@@74 (type x@@32)))
 (=> (and (and (= (type a@@51) (MapType0Type T@@74 intType)) (= (type y@@10) T@@74)) (not (= x@@32 y@@10))) (= (U_2_int (MapType0Select a@@51 y@@10)) (U_2_int (MapType0Select (|MultiSet#UnionOne| a@@51 x@@32) y@@10)))))
 :qid |DafnyPreludebpl.828:18|
 :skolemid |539|
 :pattern ( (|MultiSet#UnionOne| a@@51 x@@32) (MapType0Select a@@51 y@@10))
)))
(assert (forall ((a@@52 T@U) (x@@33 T@U) ) (! (let ((T@@75 (type x@@33)))
 (=> (= (type a@@52) (MapType0Type T@@75 intType)) (= (|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33)) (+ (|MultiSet#Card| a@@52) 1))))
 :qid |DafnyPreludebpl.830:18|
 :skolemid |540|
 :pattern ( (|MultiSet#Card| (|MultiSet#UnionOne| a@@52 x@@33)))
)))
(assert (forall ((arg0@@86 T@U) (arg1@@33 T@U) ) (! (let ((T@@76 (MapType0TypeInv0 (type arg0@@86))))
(= (type (|MultiSet#Union| arg0@@86 arg1@@33)) (MapType0Type T@@76 intType)))
 :qid |funType:MultiSet#Union|
 :pattern ( (|MultiSet#Union| arg0@@86 arg1@@33))
)))
(assert (forall ((a@@53 T@U) (b@@38 T@U) (o@@37 T@U) ) (! (let ((T@@77 (type o@@37)))
 (=> (and (= (type a@@53) (MapType0Type T@@77 intType)) (= (type b@@38) (MapType0Type T@@77 intType))) (= (U_2_int (MapType0Select (|MultiSet#Union| a@@53 b@@38) o@@37)) (+ (U_2_int (MapType0Select a@@53 o@@37)) (U_2_int (MapType0Select b@@38 o@@37))))))
 :qid |DafnyPreludebpl.836:18|
 :skolemid |541|
 :pattern ( (MapType0Select (|MultiSet#Union| a@@53 b@@38) o@@37))
)))
(assert (forall ((a@@54 T@U) (b@@39 T@U) ) (! (let ((T@@78 (MapType0TypeInv0 (type a@@54))))
 (=> (and (= (type a@@54) (MapType0Type T@@78 intType)) (= (type b@@39) (MapType0Type T@@78 intType))) (= (|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39)) (+ (|MultiSet#Card| a@@54) (|MultiSet#Card| b@@39)))))
 :qid |DafnyPreludebpl.838:18|
 :skolemid |542|
 :pattern ( (|MultiSet#Card| (|MultiSet#Union| a@@54 b@@39)))
)))
(assert (forall ((arg0@@87 T@U) (arg1@@34 T@U) ) (! (let ((T@@79 (MapType0TypeInv0 (type arg0@@87))))
(= (type (|MultiSet#Intersection| arg0@@87 arg1@@34)) (MapType0Type T@@79 intType)))
 :qid |funType:MultiSet#Intersection|
 :pattern ( (|MultiSet#Intersection| arg0@@87 arg1@@34))
)))
(assert (forall ((a@@55 T@U) (b@@40 T@U) (o@@38 T@U) ) (! (let ((T@@80 (type o@@38)))
 (=> (and (= (type a@@55) (MapType0Type T@@80 intType)) (= (type b@@40) (MapType0Type T@@80 intType))) (= (U_2_int (MapType0Select (|MultiSet#Intersection| a@@55 b@@40) o@@38)) (|Math#min| (U_2_int (MapType0Select a@@55 o@@38)) (U_2_int (MapType0Select b@@40 o@@38))))))
 :qid |DafnyPreludebpl.842:18|
 :skolemid |543|
 :pattern ( (MapType0Select (|MultiSet#Intersection| a@@55 b@@40) o@@38))
)))
(assert (forall ((a@@56 T@U) (b@@41 T@U) ) (! (let ((T@@81 (MapType0TypeInv0 (type a@@56))))
 (=> (and (= (type a@@56) (MapType0Type T@@81 intType)) (= (type b@@41) (MapType0Type T@@81 intType))) (= (|MultiSet#Intersection| (|MultiSet#Intersection| a@@56 b@@41) b@@41) (|MultiSet#Intersection| a@@56 b@@41))))
 :qid |DafnyPreludebpl.846:18|
 :skolemid |544|
 :pattern ( (|MultiSet#Intersection| (|MultiSet#Intersection| a@@56 b@@41) b@@41))
)))
(assert (forall ((a@@57 T@U) (b@@42 T@U) ) (! (let ((T@@82 (MapType0TypeInv0 (type a@@57))))
 (=> (and (= (type a@@57) (MapType0Type T@@82 intType)) (= (type b@@42) (MapType0Type T@@82 intType))) (= (|MultiSet#Intersection| a@@57 (|MultiSet#Intersection| a@@57 b@@42)) (|MultiSet#Intersection| a@@57 b@@42))))
 :qid |DafnyPreludebpl.848:18|
 :skolemid |545|
 :pattern ( (|MultiSet#Intersection| a@@57 (|MultiSet#Intersection| a@@57 b@@42)))
)))
(assert (forall ((arg0@@88 T@U) (arg1@@35 T@U) ) (! (let ((T@@83 (MapType0TypeInv0 (type arg0@@88))))
(= (type (|MultiSet#Difference| arg0@@88 arg1@@35)) (MapType0Type T@@83 intType)))
 :qid |funType:MultiSet#Difference|
 :pattern ( (|MultiSet#Difference| arg0@@88 arg1@@35))
)))
(assert (forall ((a@@58 T@U) (b@@43 T@U) (o@@39 T@U) ) (! (let ((T@@84 (type o@@39)))
 (=> (and (= (type a@@58) (MapType0Type T@@84 intType)) (= (type b@@43) (MapType0Type T@@84 intType))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@58 b@@43) o@@39)) (|Math#clip| (- (U_2_int (MapType0Select a@@58 o@@39)) (U_2_int (MapType0Select b@@43 o@@39)))))))
 :qid |DafnyPreludebpl.853:18|
 :skolemid |546|
 :pattern ( (MapType0Select (|MultiSet#Difference| a@@58 b@@43) o@@39))
)))
(assert (forall ((a@@59 T@U) (b@@44 T@U) (y@@11 T@U) ) (! (let ((T@@85 (type y@@11)))
 (=> (and (and (= (type a@@59) (MapType0Type T@@85 intType)) (= (type b@@44) (MapType0Type T@@85 intType))) (<= (U_2_int (MapType0Select a@@59 y@@11)) (U_2_int (MapType0Select b@@44 y@@11)))) (= (U_2_int (MapType0Select (|MultiSet#Difference| a@@59 b@@44) y@@11)) 0)))
 :qid |DafnyPreludebpl.855:18|
 :skolemid |547|
 :pattern ( (|MultiSet#Difference| a@@59 b@@44) (MapType0Select b@@44 y@@11) (MapType0Select a@@59 y@@11))
)))
(assert (forall ((a@@60 T@U) (b@@45 T@U) ) (! (let ((T@@86 (MapType0TypeInv0 (type a@@60))))
 (=> (and (= (type a@@60) (MapType0Type T@@86 intType)) (= (type b@@45) (MapType0Type T@@86 intType))) (and (= (+ (+ (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)) (|MultiSet#Card| (|MultiSet#Difference| b@@45 a@@60))) (* 2 (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45)))) (|MultiSet#Card| (|MultiSet#Union| a@@60 b@@45))) (= (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)) (- (|MultiSet#Card| a@@60) (|MultiSet#Card| (|MultiSet#Intersection| a@@60 b@@45)))))))
 :qid |DafnyPreludebpl.857:18|
 :skolemid |548|
 :pattern ( (|MultiSet#Card| (|MultiSet#Difference| a@@60 b@@45)))
)))
(assert (forall ((a@@61 T@U) (b@@46 T@U) ) (! (let ((T@@87 (MapType0TypeInv0 (type a@@61))))
 (=> (and (= (type a@@61) (MapType0Type T@@87 intType)) (= (type b@@46) (MapType0Type T@@87 intType))) (= (|MultiSet#Subset| a@@61 b@@46) (forall ((o@@40 T@U) ) (!  (=> (= (type o@@40) T@@87) (<= (U_2_int (MapType0Select a@@61 o@@40)) (U_2_int (MapType0Select b@@46 o@@40))))
 :qid |DafnyPreludebpl.867:37|
 :skolemid |549|
 :pattern ( (MapType0Select a@@61 o@@40))
 :pattern ( (MapType0Select b@@46 o@@40))
)))))
 :qid |DafnyPreludebpl.866:17|
 :skolemid |550|
 :pattern ( (|MultiSet#Subset| a@@61 b@@46))
)))
(assert (forall ((a@@62 T@U) (b@@47 T@U) ) (! (let ((T@@88 (MapType0TypeInv0 (type a@@62))))
 (=> (and (= (type a@@62) (MapType0Type T@@88 intType)) (= (type b@@47) (MapType0Type T@@88 intType))) (= (|MultiSet#Equal| a@@62 b@@47) (forall ((o@@41 T@U) ) (!  (=> (= (type o@@41) T@@88) (= (U_2_int (MapType0Select a@@62 o@@41)) (U_2_int (MapType0Select b@@47 o@@41))))
 :qid |DafnyPreludebpl.871:36|
 :skolemid |551|
 :pattern ( (MapType0Select a@@62 o@@41))
 :pattern ( (MapType0Select b@@47 o@@41))
)))))
 :qid |DafnyPreludebpl.870:17|
 :skolemid |552|
 :pattern ( (|MultiSet#Equal| a@@62 b@@47))
)))
(assert (forall ((a@@63 T@U) (b@@48 T@U) ) (! (let ((T@@89 (MapType0TypeInv0 (type a@@63))))
 (=> (and (and (= (type a@@63) (MapType0Type T@@89 intType)) (= (type b@@48) (MapType0Type T@@89 intType))) (|MultiSet#Equal| a@@63 b@@48)) (= a@@63 b@@48)))
 :qid |DafnyPreludebpl.873:17|
 :skolemid |553|
 :pattern ( (|MultiSet#Equal| a@@63 b@@48))
)))
(assert (forall ((a@@64 T@U) (b@@49 T@U) ) (! (let ((T@@90 (MapType0TypeInv0 (type a@@64))))
 (=> (and (= (type a@@64) (MapType0Type T@@90 intType)) (= (type b@@49) (MapType0Type T@@90 intType))) (= (|MultiSet#Disjoint| a@@64 b@@49) (forall ((o@@42 T@U) ) (!  (=> (= (type o@@42) T@@90) (or (= (U_2_int (MapType0Select a@@64 o@@42)) 0) (= (U_2_int (MapType0Select b@@49 o@@42)) 0)))
 :qid |DafnyPreludebpl.878:39|
 :skolemid |554|
 :pattern ( (MapType0Select a@@64 o@@42))
 :pattern ( (MapType0Select b@@49 o@@42))
)))))
 :qid |DafnyPreludebpl.877:18|
 :skolemid |555|
 :pattern ( (|MultiSet#Disjoint| a@@64 b@@49))
)))
(assert (forall ((arg0@@89 T@U) ) (! (let ((T@@91 (MapType0TypeInv0 (type arg0@@89))))
(= (type (|MultiSet#FromSet| arg0@@89)) (MapType0Type T@@91 intType)))
 :qid |funType:MultiSet#FromSet|
 :pattern ( (|MultiSet#FromSet| arg0@@89))
)))
(assert (forall ((s@@8 T@U) (a@@65 T@U) ) (! (let ((T@@92 (type a@@65)))
 (=> (= (type s@@8) (MapType0Type T@@92 boolType)) (and (= (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 0)  (not (U_2_bool (MapType0Select s@@8 a@@65)))) (= (= (U_2_int (MapType0Select (|MultiSet#FromSet| s@@8) a@@65)) 1) (U_2_bool (MapType0Select s@@8 a@@65))))))
 :qid |DafnyPreludebpl.882:18|
 :skolemid |556|
 :pattern ( (MapType0Select (|MultiSet#FromSet| s@@8) a@@65))
)))
(assert (forall ((s@@9 T@U) ) (! (let ((T@@93 (MapType0TypeInv0 (type s@@9))))
 (=> (= (type s@@9) (MapType0Type T@@93 boolType)) (= (|MultiSet#Card| (|MultiSet#FromSet| s@@9)) (|Set#Card| s@@9))))
 :qid |DafnyPreludebpl.885:18|
 :skolemid |557|
 :pattern ( (|MultiSet#Card| (|MultiSet#FromSet| s@@9)))
)))
(assert (forall ((arg0@@90 T@U) ) (! (let ((T@@94 (SeqTypeInv0 (type arg0@@90))))
(= (type (|MultiSet#FromSeq| arg0@@90)) (MapType0Type T@@94 intType)))
 :qid |funType:MultiSet#FromSeq|
 :pattern ( (|MultiSet#FromSeq| arg0@@90))
)))
(assert (forall ((s@@10 T@U) ) (! (let ((T@@95 (SeqTypeInv0 (type s@@10))))
 (=> (= (type s@@10) (SeqType T@@95)) ($IsGoodMultiSet (|MultiSet#FromSeq| s@@10))))
 :qid |DafnyPreludebpl.891:18|
 :skolemid |558|
 :pattern ( (|MultiSet#FromSeq| s@@10))
)))
(assert (forall ((s@@11 T@U) ) (! (let ((T@@96 (SeqTypeInv0 (type s@@11))))
 (=> (= (type s@@11) (SeqType T@@96)) (= (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)) (|Seq#Length| s@@11))))
 :qid |DafnyPreludebpl.893:18|
 :skolemid |559|
 :pattern ( (|MultiSet#Card| (|MultiSet#FromSeq| s@@11)))
)))
(assert (forall ((arg0@@91 T@U) (arg1@@36 T@U) ) (! (let ((T@@97 (type arg1@@36)))
(= (type (|Seq#Build| arg0@@91 arg1@@36)) (SeqType T@@97)))
 :qid |funType:Seq#Build|
 :pattern ( (|Seq#Build| arg0@@91 arg1@@36))
)))
(assert (forall ((s@@12 T@U) (v@@29 T@U) ) (! (let ((T@@98 (type v@@29)))
 (=> (= (type s@@12) (SeqType T@@98)) (= (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29)) (|MultiSet#UnionOne| (|MultiSet#FromSeq| s@@12) v@@29))))
 :qid |DafnyPreludebpl.897:18|
 :skolemid |560|
 :pattern ( (|MultiSet#FromSeq| (|Seq#Build| s@@12 v@@29)))
)))
(assert (forall ((T@@99 T@T) ) (! (= (type (|Seq#Empty| T@@99)) (SeqType T@@99))
 :qid |funType:Seq#Empty|
 :pattern ( (|Seq#Empty| T@@99))
)))
(assert (forall ((T@@100 T@T) ) (! (= (|MultiSet#FromSeq| (|Seq#Empty| T@@100)) (|MultiSet#Empty| T@@100))
 :skolemid |561|
)))
(assert (forall ((arg0@@92 T@U) (arg1@@37 T@U) ) (! (let ((T@@101 (SeqTypeInv0 (type arg0@@92))))
(= (type (|Seq#Append| arg0@@92 arg1@@37)) (SeqType T@@101)))
 :qid |funType:Seq#Append|
 :pattern ( (|Seq#Append| arg0@@92 arg1@@37))
)))
(assert (forall ((a@@66 T@U) (b@@50 T@U) ) (! (let ((T@@102 (SeqTypeInv0 (type a@@66))))
 (=> (and (= (type a@@66) (SeqType T@@102)) (= (type b@@50) (SeqType T@@102))) (= (|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50)) (|MultiSet#Union| (|MultiSet#FromSeq| a@@66) (|MultiSet#FromSeq| b@@50)))))
 :qid |DafnyPreludebpl.904:18|
 :skolemid |562|
 :pattern ( (|MultiSet#FromSeq| (|Seq#Append| a@@66 b@@50)))
)))
(assert (forall ((arg0@@93 T@U) (arg1@@38 Int) (arg2@@1 T@U) ) (! (let ((T@@103 (type arg2@@1)))
(= (type (|Seq#Update| arg0@@93 arg1@@38 arg2@@1)) (SeqType T@@103)))
 :qid |funType:Seq#Update|
 :pattern ( (|Seq#Update| arg0@@93 arg1@@38 arg2@@1))
)))
(assert (forall ((s@@13 T@U) (i@@6 Int) (v@@30 T@U) (x@@34 T@U) ) (! (let ((T@@104 (type v@@30)))
 (=> (and (and (= (type s@@13) (SeqType T@@104)) (= (type x@@34) T@@104)) (and (<= 0 i@@6) (< i@@6 (|Seq#Length| s@@13)))) (= (U_2_int (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@6 v@@30)) x@@34)) (U_2_int (MapType0Select (|MultiSet#Union| (|MultiSet#Difference| (|MultiSet#FromSeq| s@@13) (|MultiSet#Singleton| (|Seq#Index| s@@13 i@@6))) (|MultiSet#Singleton| v@@30)) x@@34)))))
 :qid |DafnyPreludebpl.909:18|
 :skolemid |563|
 :pattern ( (MapType0Select (|MultiSet#FromSeq| (|Seq#Update| s@@13 i@@6 v@@30)) x@@34))
)))
(assert (forall ((s@@14 T@U) (x@@35 T@U) ) (! (let ((T@@105 (type x@@35)))
 (=> (= (type s@@14) (SeqType T@@105)) (= (exists ((i@@7 Int) ) (!  (and (and (<= 0 i@@7) (< i@@7 (|Seq#Length| s@@14))) (= x@@35 (|Seq#Index| s@@14 i@@7)))
 :qid |DafnyPreludebpl.916:11|
 :skolemid |564|
 :pattern ( (|Seq#Index| s@@14 i@@7))
)) (< 0 (U_2_int (MapType0Select (|MultiSet#FromSeq| s@@14) x@@35))))))
 :qid |DafnyPreludebpl.915:18|
 :skolemid |565|
 :pattern ( (MapType0Select (|MultiSet#FromSeq| s@@14) x@@35))
)))
(assert (forall ((s@@15 T@U) ) (! (let ((T@@106 (SeqTypeInv0 (type s@@15))))
 (=> (= (type s@@15) (SeqType T@@106)) (<= 0 (|Seq#Length| s@@15))))
 :qid |DafnyPreludebpl.925:18|
 :skolemid |566|
 :pattern ( (|Seq#Length| s@@15))
)))
(assert (forall ((T@@107 T@T) ) (! (= (|Seq#Length| (|Seq#Empty| T@@107)) 0)
 :skolemid |567|
 :pattern ( (|Seq#Empty| T@@107))
)))
(assert (forall ((s@@16 T@U) ) (! (let ((T@@108 (SeqTypeInv0 (type s@@16))))
 (=> (and (= (type s@@16) (SeqType T@@108)) (= (|Seq#Length| s@@16) 0)) (= s@@16 (|Seq#Empty| T@@108))))
 :qid |DafnyPreludebpl.929:18|
 :skolemid |568|
 :pattern ( (|Seq#Length| s@@16))
)))
(assert (forall ((arg0@@94 T@U) ) (! (let ((T@@109 (type arg0@@94)))
(= (type (|Seq#Singleton| arg0@@94)) (SeqType T@@109)))
 :qid |funType:Seq#Singleton|
 :pattern ( (|Seq#Singleton| arg0@@94))
)))
(assert (forall ((t@@23 T@U) ) (! (= (|Seq#Length| (|Seq#Singleton| t@@23)) 1)
 :qid |DafnyPreludebpl.942:18|
 :skolemid |569|
 :pattern ( (|Seq#Length| (|Seq#Singleton| t@@23)))
)))
(assert  (and (forall ((arg0@@95 T@U) ) (! (let ((T@@110 (SeqTypeInv0 (type arg0@@95))))
(= (type (|Seq#Build_inv0| arg0@@95)) (SeqType T@@110)))
 :qid |funType:Seq#Build_inv0|
 :pattern ( (|Seq#Build_inv0| arg0@@95))
)) (forall ((arg0@@96 T@U) ) (! (let ((T@@111 (SeqTypeInv0 (type arg0@@96))))
(= (type (|Seq#Build_inv1| arg0@@96)) T@@111))
 :qid |funType:Seq#Build_inv1|
 :pattern ( (|Seq#Build_inv1| arg0@@96))
))))
(assert (forall ((s@@17 T@U) (val@@5 T@U) ) (! (let ((T@@112 (type val@@5)))
 (=> (= (type s@@17) (SeqType T@@112)) (and (= (|Seq#Build_inv0| (|Seq#Build| s@@17 val@@5)) s@@17) (= (|Seq#Build_inv1| (|Seq#Build| s@@17 val@@5)) val@@5))))
 :qid |DafnyPreludebpl.947:18|
 :skolemid |570|
 :pattern ( (|Seq#Build| s@@17 val@@5))
)))
(assert (forall ((s@@18 T@U) (v@@31 T@U) ) (! (let ((T@@113 (type v@@31)))
 (=> (= (type s@@18) (SeqType T@@113)) (= (|Seq#Length| (|Seq#Build| s@@18 v@@31)) (+ 1 (|Seq#Length| s@@18)))))
 :qid |DafnyPreludebpl.952:18|
 :skolemid |571|
 :pattern ( (|Seq#Build| s@@18 v@@31))
)))
(assert (forall ((s@@19 T@U) (i@@8 Int) (v@@32 T@U) ) (! (let ((T@@114 (type v@@32)))
 (=> (= (type s@@19) (SeqType T@@114)) (and (=> (= i@@8 (|Seq#Length| s@@19)) (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8) v@@32)) (=> (not (= i@@8 (|Seq#Length| s@@19))) (= (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8) (|Seq#Index| s@@19 i@@8))))))
 :qid |DafnyPreludebpl.955:18|
 :skolemid |572|
 :pattern ( (|Seq#Index| (|Seq#Build| s@@19 v@@32) i@@8))
)))
(assert (forall ((s@@20 T@U) (bx@@23 T@U) (t@@24 T@U) ) (!  (=> (and (and (and (= (type s@@20) (SeqType BoxType)) (= (type bx@@23) BoxType)) (= (type t@@24) TyType)) (and ($Is s@@20 (TSeq t@@24)) ($IsBox bx@@23 t@@24))) ($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
 :qid |DafnyPreludebpl.960:15|
 :skolemid |573|
 :pattern ( ($Is (|Seq#Build| s@@20 bx@@23) (TSeq t@@24)))
)))
(assert  (and (= (Ctor HandleTypeType) 23) (forall ((arg0@@97 T@U) (arg1@@39 T@U) (arg2@@2 Int) (arg3 T@U) ) (! (= (type (|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3)) (SeqType BoxType))
 :qid |funType:Seq#Create|
 :pattern ( (|Seq#Create| arg0@@97 arg1@@39 arg2@@2 arg3))
))))
(assert (forall ((ty T@U) (heap T@U) (len Int) (init T@U) ) (!  (=> (and (and (and (= (type ty) TyType) (= (type heap) (MapType0Type refType MapType1Type))) (= (type init) HandleTypeType)) (and ($IsGoodHeap heap) (<= 0 len))) (= (|Seq#Length| (|Seq#Create| ty heap len init)) len))
 :qid |DafnyPreludebpl.964:15|
 :skolemid |574|
 :pattern ( (|Seq#Length| (|Seq#Create| ty heap len init)))
)))
(assert (forall ((arg0@@98 T@U) (arg1@@40 T@U) (arg2@@3 T@U) (arg3@@0 T@U) (arg4 T@U) ) (! (= (type (Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4)) BoxType)
 :qid |funType:Apply1|
 :pattern ( (Apply1 arg0@@98 arg1@@40 arg2@@3 arg3@@0 arg4))
)))
(assert (forall ((ty@@0 T@U) (heap@@0 T@U) (len@@0 Int) (init@@0 T@U) (i@@9 Int) ) (!  (=> (and (and (and (= (type ty@@0) TyType) (= (type heap@@0) (MapType0Type refType MapType1Type))) (= (type init@@0) HandleTypeType)) (and (and ($IsGoodHeap heap@@0) (<= 0 i@@9)) (< i@@9 len@@0))) (= (|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0) i@@9) (Apply1 TInt (TSeq ty@@0) heap@@0 init@@0 ($Box (int_2_U i@@9)))))
 :qid |DafnyPreludebpl.968:15|
 :skolemid |575|
 :pattern ( (|Seq#Index| (|Seq#Create| ty@@0 heap@@0 len@@0 init@@0) i@@9))
)))
(assert (forall ((s0 T@U) (s1 T@U) ) (! (let ((T@@115 (SeqTypeInv0 (type s0))))
 (=> (and (= (type s0) (SeqType T@@115)) (= (type s1) (SeqType T@@115))) (= (|Seq#Length| (|Seq#Append| s0 s1)) (+ (|Seq#Length| s0) (|Seq#Length| s1)))))
 :qid |DafnyPreludebpl.974:18|
 :skolemid |576|
 :pattern ( (|Seq#Length| (|Seq#Append| s0 s1)))
)))
(assert (forall ((t@@25 T@U) ) (! (= (|Seq#Index| (|Seq#Singleton| t@@25) 0) t@@25)
 :qid |DafnyPreludebpl.978:18|
 :skolemid |577|
 :pattern ( (|Seq#Index| (|Seq#Singleton| t@@25) 0))
)))
(assert (forall ((s0@@0 T@U) (s1@@0 T@U) (n@@6 Int) ) (! (let ((T@@116 (SeqTypeInv0 (type s0@@0))))
 (=> (and (= (type s0@@0) (SeqType T@@116)) (= (type s1@@0) (SeqType T@@116))) (and (=> (< n@@6 (|Seq#Length| s0@@0)) (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6) (|Seq#Index| s0@@0 n@@6))) (=> (<= (|Seq#Length| s0@@0) n@@6) (= (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6) (|Seq#Index| s1@@0 (- n@@6 (|Seq#Length| s0@@0))))))))
 :qid |DafnyPreludebpl.979:18|
 :skolemid |578|
 :pattern ( (|Seq#Index| (|Seq#Append| s0@@0 s1@@0) n@@6))
)))
(assert (forall ((s@@21 T@U) (i@@10 Int) (v@@33 T@U) ) (! (let ((T@@117 (type v@@33)))
 (=> (= (type s@@21) (SeqType T@@117)) (=> (and (<= 0 i@@10) (< i@@10 (|Seq#Length| s@@21))) (= (|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33)) (|Seq#Length| s@@21)))))
 :qid |DafnyPreludebpl.984:18|
 :skolemid |579|
 :pattern ( (|Seq#Length| (|Seq#Update| s@@21 i@@10 v@@33)))
)))
(assert (forall ((s@@22 T@U) (i@@11 Int) (v@@34 T@U) (n@@7 Int) ) (! (let ((T@@118 (type v@@34)))
 (=> (= (type s@@22) (SeqType T@@118)) (=> (and (<= 0 n@@7) (< n@@7 (|Seq#Length| s@@22))) (and (=> (= i@@11 n@@7) (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7) v@@34)) (=> (not (= i@@11 n@@7)) (= (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7) (|Seq#Index| s@@22 n@@7)))))))
 :qid |DafnyPreludebpl.986:18|
 :skolemid |580|
 :pattern ( (|Seq#Index| (|Seq#Update| s@@22 i@@11 v@@34) n@@7))
)))
(assert (forall ((s@@23 T@U) (x@@36 T@U) ) (! (let ((T@@119 (type x@@36)))
 (=> (= (type s@@23) (SeqType T@@119)) (= (|Seq#Contains| s@@23 x@@36) (exists ((i@@12 Int) ) (!  (and (and (<= 0 i@@12) (< i@@12 (|Seq#Length| s@@23))) (= (|Seq#Index| s@@23 i@@12) x@@36))
 :qid |DafnyPreludebpl.994:13|
 :skolemid |581|
 :pattern ( (|Seq#Index| s@@23 i@@12))
)))))
 :qid |DafnyPreludebpl.992:18|
 :skolemid |582|
 :pattern ( (|Seq#Contains| s@@23 x@@36))
)))
(assert (forall ((x@@37 T@U) ) (! (let ((T@@120 (type x@@37)))
 (not (|Seq#Contains| (|Seq#Empty| T@@120) x@@37)))
 :qid |DafnyPreludebpl.995:18|
 :skolemid |583|
 :pattern ( (let ((T@@120 (type x@@37)))
(|Seq#Contains| (|Seq#Empty| T@@120) x@@37)))
)))
(assert (forall ((s0@@1 T@U) (s1@@1 T@U) (x@@38 T@U) ) (! (let ((T@@121 (type x@@38)))
 (=> (and (= (type s0@@1) (SeqType T@@121)) (= (type s1@@1) (SeqType T@@121))) (= (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38)  (or (|Seq#Contains| s0@@1 x@@38) (|Seq#Contains| s1@@1 x@@38)))))
 :qid |DafnyPreludebpl.999:18|
 :skolemid |584|
 :pattern ( (|Seq#Contains| (|Seq#Append| s0@@1 s1@@1) x@@38))
)))
(assert (forall ((s@@24 T@U) (v@@35 T@U) (x@@39 T@U) ) (! (let ((T@@122 (type v@@35)))
 (=> (and (= (type s@@24) (SeqType T@@122)) (= (type x@@39) T@@122)) (= (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39)  (or (= v@@35 x@@39) (|Seq#Contains| s@@24 x@@39)))))
 :qid |DafnyPreludebpl.1004:18|
 :skolemid |585|
 :pattern ( (|Seq#Contains| (|Seq#Build| s@@24 v@@35) x@@39))
)))
(assert (forall ((arg0@@99 T@U) (arg1@@41 Int) ) (! (let ((T@@123 (SeqTypeInv0 (type arg0@@99))))
(= (type (|Seq#Take| arg0@@99 arg1@@41)) (SeqType T@@123)))
 :qid |funType:Seq#Take|
 :pattern ( (|Seq#Take| arg0@@99 arg1@@41))
)))
(assert (forall ((s@@25 T@U) (n@@8 Int) (x@@40 T@U) ) (! (let ((T@@124 (type x@@40)))
 (=> (= (type s@@25) (SeqType T@@124)) (= (|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40) (exists ((i@@13 Int) ) (!  (and (and (and (<= 0 i@@13) (< i@@13 n@@8)) (< i@@13 (|Seq#Length| s@@25))) (= (|Seq#Index| s@@25 i@@13) x@@40))
 :qid |DafnyPreludebpl.1011:13|
 :skolemid |586|
 :pattern ( (|Seq#Index| s@@25 i@@13))
)))))
 :qid |DafnyPreludebpl.1008:18|
 :skolemid |587|
 :pattern ( (|Seq#Contains| (|Seq#Take| s@@25 n@@8) x@@40))
)))
(assert (forall ((arg0@@100 T@U) (arg1@@42 Int) ) (! (let ((T@@125 (SeqTypeInv0 (type arg0@@100))))
(= (type (|Seq#Drop| arg0@@100 arg1@@42)) (SeqType T@@125)))
 :qid |funType:Seq#Drop|
 :pattern ( (|Seq#Drop| arg0@@100 arg1@@42))
)))
(assert (forall ((s@@26 T@U) (n@@9 Int) (x@@41 T@U) ) (! (let ((T@@126 (type x@@41)))
 (=> (= (type s@@26) (SeqType T@@126)) (= (|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41) (exists ((i@@14 Int) ) (!  (and (and (and (<= 0 n@@9) (<= n@@9 i@@14)) (< i@@14 (|Seq#Length| s@@26))) (= (|Seq#Index| s@@26 i@@14) x@@41))
 :qid |DafnyPreludebpl.1016:13|
 :skolemid |588|
 :pattern ( (|Seq#Index| s@@26 i@@14))
)))))
 :qid |DafnyPreludebpl.1013:18|
 :skolemid |589|
 :pattern ( (|Seq#Contains| (|Seq#Drop| s@@26 n@@9) x@@41))
)))
(assert (forall ((s0@@2 T@U) (s1@@2 T@U) ) (! (let ((T@@127 (SeqTypeInv0 (type s0@@2))))
 (=> (and (= (type s0@@2) (SeqType T@@127)) (= (type s1@@2) (SeqType T@@127))) (= (|Seq#Equal| s0@@2 s1@@2)  (and (= (|Seq#Length| s0@@2) (|Seq#Length| s1@@2)) (forall ((j Int) ) (!  (=> (and (<= 0 j) (< j (|Seq#Length| s0@@2))) (= (|Seq#Index| s0@@2 j) (|Seq#Index| s1@@2 j)))
 :qid |DafnyPreludebpl.1023:13|
 :skolemid |590|
 :pattern ( (|Seq#Index| s0@@2 j))
 :pattern ( (|Seq#Index| s1@@2 j))
))))))
 :qid |DafnyPreludebpl.1020:18|
 :skolemid |591|
 :pattern ( (|Seq#Equal| s0@@2 s1@@2))
)))
(assert (forall ((a@@67 T@U) (b@@51 T@U) ) (! (let ((T@@128 (SeqTypeInv0 (type a@@67))))
 (=> (and (and (= (type a@@67) (SeqType T@@128)) (= (type b@@51) (SeqType T@@128))) (|Seq#Equal| a@@67 b@@51)) (= a@@67 b@@51)))
 :qid |DafnyPreludebpl.1025:18|
 :skolemid |592|
 :pattern ( (|Seq#Equal| a@@67 b@@51))
)))
(assert (forall ((s0@@3 T@U) (s1@@3 T@U) (n@@10 Int) ) (! (let ((T@@129 (SeqTypeInv0 (type s0@@3))))
 (=> (and (= (type s0@@3) (SeqType T@@129)) (= (type s1@@3) (SeqType T@@129))) (= (|Seq#SameUntil| s0@@3 s1@@3 n@@10) (forall ((j@@0 Int) ) (!  (=> (and (<= 0 j@@0) (< j@@0 n@@10)) (= (|Seq#Index| s0@@3 j@@0) (|Seq#Index| s1@@3 j@@0)))
 :qid |DafnyPreludebpl.1031:13|
 :skolemid |593|
 :pattern ( (|Seq#Index| s0@@3 j@@0))
 :pattern ( (|Seq#Index| s1@@3 j@@0))
)))))
 :qid |DafnyPreludebpl.1029:18|
 :skolemid |594|
 :pattern ( (|Seq#SameUntil| s0@@3 s1@@3 n@@10))
)))
(assert (forall ((s@@27 T@U) (n@@11 Int) ) (! (let ((T@@130 (SeqTypeInv0 (type s@@27))))
 (=> (= (type s@@27) (SeqType T@@130)) (=> (and (<= 0 n@@11) (<= n@@11 (|Seq#Length| s@@27))) (= (|Seq#Length| (|Seq#Take| s@@27 n@@11)) n@@11))))
 :qid |DafnyPreludebpl.1035:18|
 :skolemid |595|
 :pattern ( (|Seq#Length| (|Seq#Take| s@@27 n@@11)))
)))
(assert (forall ((s@@28 T@U) (n@@12 Int) (j@@1 Int) ) (! (let ((T@@131 (SeqTypeInv0 (type s@@28))))
 (=> (= (type s@@28) (SeqType T@@131)) (=> (and (and (<= 0 j@@1) (< j@@1 n@@12)) (< j@@1 (|Seq#Length| s@@28))) (= (|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1) (|Seq#Index| s@@28 j@@1)))))
 :qid |DafnyPreludebpl.1037:18|
 :weight 25
 :skolemid |596|
 :pattern ( (|Seq#Index| (|Seq#Take| s@@28 n@@12) j@@1))
 :pattern ( (|Seq#Index| s@@28 j@@1) (|Seq#Take| s@@28 n@@12))
)))
(assert (forall ((s@@29 T@U) (n@@13 Int) ) (! (let ((T@@132 (SeqTypeInv0 (type s@@29))))
 (=> (= (type s@@29) (SeqType T@@132)) (=> (and (<= 0 n@@13) (<= n@@13 (|Seq#Length| s@@29))) (= (|Seq#Length| (|Seq#Drop| s@@29 n@@13)) (- (|Seq#Length| s@@29) n@@13)))))
 :qid |DafnyPreludebpl.1045:18|
 :skolemid |597|
 :pattern ( (|Seq#Length| (|Seq#Drop| s@@29 n@@13)))
)))
(assert (forall ((s@@30 T@U) (n@@14 Int) (j@@2 Int) ) (! (let ((T@@133 (SeqTypeInv0 (type s@@30))))
 (=> (= (type s@@30) (SeqType T@@133)) (=> (and (and (<= 0 n@@14) (<= 0 j@@2)) (< j@@2 (- (|Seq#Length| s@@30) n@@14))) (= (|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2) (|Seq#Index| s@@30 (+ j@@2 n@@14))))))
 :qid |DafnyPreludebpl.1047:18|
 :weight 25
 :skolemid |598|
 :pattern ( (|Seq#Index| (|Seq#Drop| s@@30 n@@14) j@@2))
)))
(assert (forall ((s@@31 T@U) (n@@15 Int) (k@@3 Int) ) (! (let ((T@@134 (SeqTypeInv0 (type s@@31))))
 (=> (= (type s@@31) (SeqType T@@134)) (=> (and (and (<= 0 n@@15) (<= n@@15 k@@3)) (< k@@3 (|Seq#Length| s@@31))) (= (|Seq#Index| (|Seq#Drop| s@@31 n@@15) (- k@@3 n@@15)) (|Seq#Index| s@@31 k@@3)))))
 :qid |DafnyPreludebpl.1052:18|
 :weight 25
 :skolemid |599|
 :pattern ( (|Seq#Index| s@@31 k@@3) (|Seq#Drop| s@@31 n@@15))
)))
(assert (forall ((s@@32 T@U) (t@@26 T@U) (n@@16 Int) ) (! (let ((T@@135 (SeqTypeInv0 (type s@@32))))
 (=> (and (and (= (type s@@32) (SeqType T@@135)) (= (type t@@26) (SeqType T@@135))) (= n@@16 (|Seq#Length| s@@32))) (and (= (|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16) s@@32) (= (|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16) t@@26))))
 :qid |DafnyPreludebpl.1058:18|
 :skolemid |600|
 :pattern ( (|Seq#Take| (|Seq#Append| s@@32 t@@26) n@@16))
 :pattern ( (|Seq#Drop| (|Seq#Append| s@@32 t@@26) n@@16))
)))
(assert (forall ((arg0@@101 T@U) (arg1@@43 T@U) ) (! (= (type (|Seq#FromArray| arg0@@101 arg1@@43)) (SeqType BoxType))
 :qid |funType:Seq#FromArray|
 :pattern ( (|Seq#FromArray| arg0@@101 arg1@@43))
)))
(assert (forall ((h@@17 T@U) (a@@68 T@U) ) (!  (=> (and (= (type h@@17) (MapType0Type refType MapType1Type)) (= (type a@@68) refType)) (= (|Seq#Length| (|Seq#FromArray| h@@17 a@@68)) (_System.array.Length a@@68)))
 :qid |DafnyPreludebpl.1067:15|
 :skolemid |601|
 :pattern ( (|Seq#Length| (|Seq#FromArray| h@@17 a@@68)))
)))
(assert (forall ((h@@18 T@U) (a@@69 T@U) ) (!  (=> (and (= (type h@@18) (MapType0Type refType MapType1Type)) (= (type a@@69) refType)) (forall ((i@@15 Int) ) (!  (=> (and (<= 0 i@@15) (< i@@15 (|Seq#Length| (|Seq#FromArray| h@@18 a@@69)))) (= (|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15) (MapType1Select (MapType0Select h@@18 a@@69) (IndexField i@@15))))
 :qid |DafnyPreludebpl.1072:11|
 :skolemid |602|
 :pattern ( (MapType1Select (MapType0Select h@@18 a@@69) (IndexField i@@15)))
 :pattern ( (|Seq#Index| (|Seq#FromArray| h@@18 a@@69) i@@15))
)))
 :qid |DafnyPreludebpl.1070:15|
 :skolemid |603|
 :pattern ( (|Seq#FromArray| h@@18 a@@69))
)))
(assert (forall ((h0 T@U) (h1 T@U) (a@@70 T@U) ) (!  (=> (and (and (= (type h0) (MapType0Type refType MapType1Type)) (= (type h1) (MapType0Type refType MapType1Type))) (= (type a@@70) refType)) (=> (and (and (and ($IsGoodHeap h0) ($IsGoodHeap h1)) ($HeapSucc h0 h1)) (= (MapType0Select h0 a@@70) (MapType0Select h1 a@@70))) (= (|Seq#FromArray| h0 a@@70) (|Seq#FromArray| h1 a@@70))))
 :qid |DafnyPreludebpl.1082:15|
 :skolemid |604|
 :pattern ( (|Seq#FromArray| h1 a@@70) ($HeapSucc h0 h1))
)))
(assert (forall ((h@@19 T@U) (i@@16 Int) (v@@36 T@U) (a@@71 T@U) ) (!  (=> (and (and (and (= (type h@@19) (MapType0Type refType MapType1Type)) (= (type v@@36) BoxType)) (= (type a@@71) refType)) (and (<= 0 i@@16) (< i@@16 (_System.array.Length a@@71)))) (= (|Seq#FromArray| (MapType0Store h@@19 a@@71 (MapType1Store (MapType0Select h@@19 a@@71) (IndexField i@@16) v@@36)) a@@71) (|Seq#Update| (|Seq#FromArray| h@@19 a@@71) i@@16 v@@36)))
 :qid |DafnyPreludebpl.1087:15|
 :skolemid |605|
 :pattern ( (|Seq#FromArray| (MapType0Store h@@19 a@@71 (MapType1Store (MapType0Select h@@19 a@@71) (IndexField i@@16) v@@36)) a@@71))
)))
(assert (forall ((s@@33 T@U) (i@@17 Int) (v@@37 T@U) (n@@17 Int) ) (! (let ((T@@136 (type v@@37)))
 (=> (= (type s@@33) (SeqType T@@136)) (=> (and (and (<= 0 i@@17) (< i@@17 n@@17)) (<= n@@17 (|Seq#Length| s@@33))) (= (|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17) (|Seq#Update| (|Seq#Take| s@@33 n@@17) i@@17 v@@37)))))
 :qid |DafnyPreludebpl.1092:18|
 :skolemid |606|
 :pattern ( (|Seq#Take| (|Seq#Update| s@@33 i@@17 v@@37) n@@17))
)))
(assert (forall ((s@@34 T@U) (i@@18 Int) (v@@38 T@U) (n@@18 Int) ) (! (let ((T@@137 (type v@@38)))
 (=> (= (type s@@34) (SeqType T@@137)) (=> (and (<= n@@18 i@@18) (< i@@18 (|Seq#Length| s@@34))) (= (|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18) (|Seq#Take| s@@34 n@@18)))))
 :qid |DafnyPreludebpl.1095:18|
 :skolemid |607|
 :pattern ( (|Seq#Take| (|Seq#Update| s@@34 i@@18 v@@38) n@@18))
)))
(assert (forall ((s@@35 T@U) (i@@19 Int) (v@@39 T@U) (n@@19 Int) ) (! (let ((T@@138 (type v@@39)))
 (=> (= (type s@@35) (SeqType T@@138)) (=> (and (and (<= 0 n@@19) (<= n@@19 i@@19)) (< i@@19 (|Seq#Length| s@@35))) (= (|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19) (|Seq#Update| (|Seq#Drop| s@@35 n@@19) (- i@@19 n@@19) v@@39)))))
 :qid |DafnyPreludebpl.1098:18|
 :skolemid |608|
 :pattern ( (|Seq#Drop| (|Seq#Update| s@@35 i@@19 v@@39) n@@19))
)))
(assert (forall ((s@@36 T@U) (i@@20 Int) (v@@40 T@U) (n@@20 Int) ) (! (let ((T@@139 (type v@@40)))
 (=> (= (type s@@36) (SeqType T@@139)) (=> (and (and (<= 0 i@@20) (< i@@20 n@@20)) (< n@@20 (|Seq#Length| s@@36))) (= (|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20) (|Seq#Drop| s@@36 n@@20)))))
 :qid |DafnyPreludebpl.1101:18|
 :skolemid |609|
 :pattern ( (|Seq#Drop| (|Seq#Update| s@@36 i@@20 v@@40) n@@20))
)))
(assert (forall ((h@@20 T@U) (a@@72 T@U) (n0 Int) (n1 Int) ) (!  (=> (and (= (type h@@20) (MapType0Type refType MapType1Type)) (= (type a@@72) refType)) (=> (and (and (= (+ n0 1) n1) (<= 0 n0)) (<= n1 (_System.array.Length a@@72))) (= (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1) (|Seq#Build| (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0) (MapType1Select (MapType0Select h@@20 a@@72) (IndexField n0))))))
 :qid |DafnyPreludebpl.1105:15|
 :skolemid |610|
 :pattern ( (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n0) (|Seq#Take| (|Seq#FromArray| h@@20 a@@72) n1))
)))
(assert (forall ((s@@37 T@U) (v@@41 T@U) (n@@21 Int) ) (! (let ((T@@140 (type v@@41)))
 (=> (= (type s@@37) (SeqType T@@140)) (=> (and (<= 0 n@@21) (<= n@@21 (|Seq#Length| s@@37))) (= (|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21) (|Seq#Build| (|Seq#Drop| s@@37 n@@21) v@@41)))))
 :qid |DafnyPreludebpl.1109:18|
 :skolemid |611|
 :pattern ( (|Seq#Drop| (|Seq#Build| s@@37 v@@41) n@@21))
)))
(assert (forall ((s@@38 T@U) (i@@21 Int) ) (!  (=> (= (type s@@38) (SeqType BoxType)) (=> (and (<= 0 i@@21) (< i@@21 (|Seq#Length| s@@38))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21))) (|Seq#Rank| s@@38))))
 :qid |DafnyPreludebpl.1114:15|
 :skolemid |612|
 :pattern ( (DtRank ($Unbox DatatypeTypeType (|Seq#Index| s@@38 i@@21))))
)))
(assert (forall ((s@@39 T@U) (i@@22 Int) ) (! (let ((T@@141 (SeqTypeInv0 (type s@@39))))
 (=> (= (type s@@39) (SeqType T@@141)) (=> (and (< 0 i@@22) (<= i@@22 (|Seq#Length| s@@39))) (< (|Seq#Rank| (|Seq#Drop| s@@39 i@@22)) (|Seq#Rank| s@@39)))))
 :qid |DafnyPreludebpl.1117:18|
 :skolemid |613|
 :pattern ( (|Seq#Rank| (|Seq#Drop| s@@39 i@@22)))
)))
(assert (forall ((s@@40 T@U) (i@@23 Int) ) (! (let ((T@@142 (SeqTypeInv0 (type s@@40))))
 (=> (= (type s@@40) (SeqType T@@142)) (=> (and (<= 0 i@@23) (< i@@23 (|Seq#Length| s@@40))) (< (|Seq#Rank| (|Seq#Take| s@@40 i@@23)) (|Seq#Rank| s@@40)))))
 :qid |DafnyPreludebpl.1120:18|
 :skolemid |614|
 :pattern ( (|Seq#Rank| (|Seq#Take| s@@40 i@@23)))
)))
(assert (forall ((s@@41 T@U) (i@@24 Int) (j@@3 Int) ) (! (let ((T@@143 (SeqTypeInv0 (type s@@41))))
 (=> (= (type s@@41) (SeqType T@@143)) (=> (and (and (<= 0 i@@24) (< i@@24 j@@3)) (<= j@@3 (|Seq#Length| s@@41))) (< (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24) (|Seq#Drop| s@@41 j@@3))) (|Seq#Rank| s@@41)))))
 :qid |DafnyPreludebpl.1123:18|
 :skolemid |615|
 :pattern ( (|Seq#Rank| (|Seq#Append| (|Seq#Take| s@@41 i@@24) (|Seq#Drop| s@@41 j@@3))))
)))
(assert (forall ((s@@42 T@U) (n@@22 Int) ) (! (let ((T@@144 (SeqTypeInv0 (type s@@42))))
 (=> (and (= (type s@@42) (SeqType T@@144)) (= n@@22 0)) (= (|Seq#Drop| s@@42 n@@22) s@@42)))
 :qid |DafnyPreludebpl.1128:18|
 :skolemid |616|
 :pattern ( (|Seq#Drop| s@@42 n@@22))
)))
(assert (forall ((s@@43 T@U) (n@@23 Int) ) (! (let ((T@@145 (SeqTypeInv0 (type s@@43))))
 (=> (and (= (type s@@43) (SeqType T@@145)) (= n@@23 0)) (= (|Seq#Take| s@@43 n@@23) (|Seq#Empty| T@@145))))
 :qid |DafnyPreludebpl.1130:18|
 :skolemid |617|
 :pattern ( (|Seq#Take| s@@43 n@@23))
)))
(assert (forall ((s@@44 T@U) (m@@9 Int) (n@@24 Int) ) (! (let ((T@@146 (SeqTypeInv0 (type s@@44))))
 (=> (= (type s@@44) (SeqType T@@146)) (=> (and (and (<= 0 m@@9) (<= 0 n@@24)) (<= (+ m@@9 n@@24) (|Seq#Length| s@@44))) (= (|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24) (|Seq#Drop| s@@44 (+ m@@9 n@@24))))))
 :qid |DafnyPreludebpl.1132:18|
 :skolemid |618|
 :pattern ( (|Seq#Drop| (|Seq#Drop| s@@44 m@@9) n@@24))
)))
(assert (forall ((m@@10 T@U) ) (! (let ((V@@3 (MapTypeInv1 (type m@@10))))
(let ((U@@3 (MapTypeInv0 (type m@@10))))
 (=> (= (type m@@10) (MapType U@@3 V@@3)) (<= 0 (|Map#Card| m@@10)))))
 :qid |DafnyPreludebpl.1150:20|
 :skolemid |619|
 :pattern ( (|Map#Card| m@@10))
)))
(assert (forall ((U@@4 T@T) (V@@4 T@T) ) (! (= (type (|Map#Empty| U@@4 V@@4)) (MapType U@@4 V@@4))
 :qid |funType:Map#Empty|
 :pattern ( (|Map#Empty| U@@4 V@@4))
)))
(assert (forall ((m@@11 T@U) ) (! (let ((V@@5 (MapTypeInv1 (type m@@11))))
(let ((U@@5 (MapTypeInv0 (type m@@11))))
 (=> (= (type m@@11) (MapType U@@5 V@@5)) (= (= (|Map#Card| m@@11) 0) (= m@@11 (|Map#Empty| U@@5 V@@5))))))
 :qid |DafnyPreludebpl.1152:21|
 :skolemid |620|
 :pattern ( (|Map#Card| m@@11))
)))
(assert (forall ((m@@12 T@U) ) (! (let ((V@@6 (MapTypeInv1 (type m@@12))))
(let ((U@@6 (MapTypeInv0 (type m@@12))))
 (=> (= (type m@@12) (MapType U@@6 V@@6)) (or (= m@@12 (|Map#Empty| U@@6 V@@6)) (exists ((k@@4 T@U) ) (!  (and (= (type k@@4) U@@6) (U_2_bool (MapType0Select (|Map#Domain| m@@12) k@@4)))
 :qid |DafnyPreludebpl.1158:31|
 :skolemid |621|
 :no-pattern (type k@@4)
 :no-pattern (U_2_int k@@4)
 :no-pattern (U_2_bool k@@4)
))))))
 :qid |DafnyPreludebpl.1156:21|
 :skolemid |622|
 :pattern ( (|Map#Domain| m@@12))
)))
(assert (forall ((m@@13 T@U) ) (! (let ((V@@7 (MapTypeInv1 (type m@@13))))
(let ((U@@7 (MapTypeInv0 (type m@@13))))
 (=> (= (type m@@13) (MapType U@@7 V@@7)) (or (= m@@13 (|Map#Empty| U@@7 V@@7)) (exists ((v@@42 T@U) ) (!  (and (= (type v@@42) V@@7) (U_2_bool (MapType0Select (|Map#Values| m@@13) v@@42)))
 :qid |DafnyPreludebpl.1161:31|
 :skolemid |623|
 :no-pattern (type v@@42)
 :no-pattern (U_2_int v@@42)
 :no-pattern (U_2_bool v@@42)
))))))
 :qid |DafnyPreludebpl.1159:21|
 :skolemid |624|
 :pattern ( (|Map#Values| m@@13))
)))
(assert (forall ((arg0@@102 T@U) (arg1@@44 T@U) ) (! (= (type (|#_System._tuple#2._#Make2| arg0@@102 arg1@@44)) DatatypeTypeType)
 :qid |funType:#_System._tuple#2._#Make2|
 :pattern ( (|#_System._tuple#2._#Make2| arg0@@102 arg1@@44))
)))
(assert (forall ((m@@14 T@U) ) (! (let ((V@@8 (MapTypeInv1 (type m@@14))))
(let ((U@@8 (MapTypeInv0 (type m@@14))))
 (=> (= (type m@@14) (MapType U@@8 V@@8)) (or (= m@@14 (|Map#Empty| U@@8 V@@8)) (exists ((k@@5 T@U) (v@@43 T@U) ) (!  (and (and (= (type k@@5) BoxType) (= (type v@@43) BoxType)) (U_2_bool (MapType0Select (|Map#Items| m@@14) ($Box (|#_System._tuple#2._#Make2| k@@5 v@@43)))))
 :qid |DafnyPreludebpl.1164:31|
 :skolemid |625|
 :no-pattern (type k@@5)
 :no-pattern (type v@@43)
 :no-pattern (U_2_int k@@5)
 :no-pattern (U_2_bool k@@5)
 :no-pattern (U_2_int v@@43)
 :no-pattern (U_2_bool v@@43)
))))))
 :qid |DafnyPreludebpl.1162:21|
 :skolemid |626|
 :pattern ( (|Map#Items| m@@14))
)))
(assert (forall ((m@@15 T@U) ) (! (let ((V@@9 (MapTypeInv1 (type m@@15))))
(let ((U@@9 (MapTypeInv0 (type m@@15))))
 (=> (= (type m@@15) (MapType U@@9 V@@9)) (= (|Set#Card| (|Map#Domain| m@@15)) (|Map#Card| m@@15)))))
 :qid |DafnyPreludebpl.1166:21|
 :skolemid |627|
 :pattern ( (|Set#Card| (|Map#Domain| m@@15)))
)))
(assert (forall ((m@@16 T@U) ) (! (let ((V@@10 (MapTypeInv1 (type m@@16))))
(let ((U@@10 (MapTypeInv0 (type m@@16))))
 (=> (= (type m@@16) (MapType U@@10 V@@10)) (<= (|Set#Card| (|Map#Values| m@@16)) (|Map#Card| m@@16)))))
 :qid |DafnyPreludebpl.1169:21|
 :skolemid |628|
 :pattern ( (|Set#Card| (|Map#Values| m@@16)))
)))
(assert (forall ((m@@17 T@U) ) (! (let ((V@@11 (MapTypeInv1 (type m@@17))))
(let ((U@@11 (MapTypeInv0 (type m@@17))))
 (=> (= (type m@@17) (MapType U@@11 V@@11)) (= (|Set#Card| (|Map#Items| m@@17)) (|Map#Card| m@@17)))))
 :qid |DafnyPreludebpl.1172:21|
 :skolemid |629|
 :pattern ( (|Set#Card| (|Map#Items| m@@17)))
)))
(assert (forall ((m@@18 T@U) (v@@44 T@U) ) (! (let ((V@@12 (type v@@44)))
(let ((U@@12 (MapTypeInv0 (type m@@18))))
 (=> (= (type m@@18) (MapType U@@12 V@@12)) (= (U_2_bool (MapType0Select (|Map#Values| m@@18) v@@44)) (exists ((u@@5 T@U) ) (!  (and (= (type u@@5) U@@12) (and (U_2_bool (MapType0Select (|Map#Domain| m@@18) u@@5)) (= v@@44 (MapType0Select (|Map#Elements| m@@18) u@@5))))
 :qid |DafnyPreludebpl.1185:10|
 :skolemid |630|
 :pattern ( (MapType0Select (|Map#Domain| m@@18) u@@5))
 :pattern ( (MapType0Select (|Map#Elements| m@@18) u@@5))
))))))
 :qid |DafnyPreludebpl.1183:20|
 :skolemid |631|
 :pattern ( (MapType0Select (|Map#Values| m@@18) v@@44))
)))
(assert  (and (forall ((arg0@@103 T@U) ) (! (= (type (_System.Tuple2._0 arg0@@103)) BoxType)
 :qid |funType:_System.Tuple2._0|
 :pattern ( (_System.Tuple2._0 arg0@@103))
)) (forall ((arg0@@104 T@U) ) (! (= (type (_System.Tuple2._1 arg0@@104)) BoxType)
 :qid |funType:_System.Tuple2._1|
 :pattern ( (_System.Tuple2._1 arg0@@104))
))))
(assert (forall ((m@@19 T@U) (item T@U) ) (!  (=> (and (= (type m@@19) (MapType BoxType BoxType)) (= (type item) BoxType)) (= (U_2_bool (MapType0Select (|Map#Items| m@@19) item))  (and (U_2_bool (MapType0Select (|Map#Domain| m@@19) (_System.Tuple2._0 ($Unbox DatatypeTypeType item)))) (= (MapType0Select (|Map#Elements| m@@19) (_System.Tuple2._0 ($Unbox DatatypeTypeType item))) (_System.Tuple2._1 ($Unbox DatatypeTypeType item))))))
 :qid |DafnyPreludebpl.1204:15|
 :skolemid |632|
 :pattern ( (MapType0Select (|Map#Items| m@@19) item))
)))
(assert (forall ((u@@6 T@U) (V@@13 T@T) ) (! (let ((U@@13 (type u@@6)))
 (not (U_2_bool (MapType0Select (|Map#Domain| (|Map#Empty| U@@13 V@@13)) u@@6))))
 :qid |DafnyPreludebpl.1212:21|
 :skolemid |633|
 :pattern ( (let ((U@@13 (type u@@6)))
(MapType0Select (|Map#Domain| (|Map#Empty| U@@13 V@@13)) u@@6)))
)))
(assert (forall ((arg0@@105 T@U) (arg1@@45 T@U) (arg2@@4 T@U) ) (! (let ((V@@14 (MapType0TypeInv1 (type arg1@@45))))
(let ((U@@14 (MapType0TypeInv0 (type arg0@@105))))
(= (type (|Map#Glue| arg0@@105 arg1@@45 arg2@@4)) (MapType U@@14 V@@14))))
 :qid |funType:Map#Glue|
 :pattern ( (|Map#Glue| arg0@@105 arg1@@45 arg2@@4))
)))
(assert (forall ((a@@73 T@U) (b@@52 T@U) (t@@27 T@U) ) (! (let ((V@@15 (MapType0TypeInv1 (type b@@52))))
(let ((U@@15 (MapType0TypeInv0 (type a@@73))))
 (=> (and (and (= (type a@@73) (MapType0Type U@@15 boolType)) (= (type b@@52) (MapType0Type U@@15 V@@15))) (= (type t@@27) TyType)) (= (|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)) a@@73))))
 :qid |DafnyPreludebpl.1217:21|
 :skolemid |634|
 :pattern ( (|Map#Domain| (|Map#Glue| a@@73 b@@52 t@@27)))
)))
(assert (forall ((a@@74 T@U) (b@@53 T@U) (t@@28 T@U) ) (! (let ((V@@16 (MapType0TypeInv1 (type b@@53))))
(let ((U@@16 (MapType0TypeInv0 (type a@@74))))
 (=> (and (and (= (type a@@74) (MapType0Type U@@16 boolType)) (= (type b@@53) (MapType0Type U@@16 V@@16))) (= (type t@@28) TyType)) (= (|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)) b@@53))))
 :qid |DafnyPreludebpl.1220:21|
 :skolemid |635|
 :pattern ( (|Map#Elements| (|Map#Glue| a@@74 b@@53 t@@28)))
)))
(assert (forall ((a@@75 T@U) (b@@54 T@U) (t0@@14 T@U) (t1@@5 T@U) ) (!  (=> (and (and (and (and (= (type a@@75) (MapType0Type BoxType boolType)) (= (type b@@54) (MapType0Type BoxType BoxType))) (= (type t0@@14) TyType)) (= (type t1@@5) TyType)) (forall ((bx@@24 T@U) ) (!  (=> (and (= (type bx@@24) BoxType) (U_2_bool (MapType0Select a@@75 bx@@24))) (and ($IsBox bx@@24 t0@@14) ($IsBox (MapType0Select b@@54 bx@@24) t1@@5)))
 :qid |DafnyPreludebpl.1226:11|
 :skolemid |636|
 :no-pattern (type bx@@24)
 :no-pattern (U_2_int bx@@24)
 :no-pattern (U_2_bool bx@@24)
))) ($Is (|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5)) (TMap t0@@14 t1@@5)))
 :qid |DafnyPreludebpl.1223:15|
 :skolemid |637|
 :pattern ( (|Map#Glue| a@@75 b@@54 (TMap t0@@14 t1@@5)))
)))
(assert (forall ((arg0@@106 T@U) (arg1@@46 T@U) (arg2@@5 T@U) ) (! (let ((V@@17 (type arg2@@5)))
(let ((U@@17 (type arg1@@46)))
(= (type (|Map#Build| arg0@@106 arg1@@46 arg2@@5)) (MapType U@@17 V@@17))))
 :qid |funType:Map#Build|
 :pattern ( (|Map#Build| arg0@@106 arg1@@46 arg2@@5))
)))
(assert (forall ((m@@20 T@U) (u@@7 T@U) (|u'| T@U) (v@@45 T@U) ) (! (let ((V@@18 (type v@@45)))
(let ((U@@18 (type u@@7)))
 (=> (and (= (type m@@20) (MapType U@@18 V@@18)) (= (type |u'|) U@@18)) (and (=> (= |u'| u@@7) (and (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|)) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|) v@@45))) (=> (not (= |u'| u@@7)) (and (= (U_2_bool (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|)) (U_2_bool (MapType0Select (|Map#Domain| m@@20) |u'|))) (= (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|) (MapType0Select (|Map#Elements| m@@20) |u'|))))))))
 :qid |DafnyPreludebpl.1237:21|
 :skolemid |638|
 :pattern ( (MapType0Select (|Map#Domain| (|Map#Build| m@@20 u@@7 v@@45)) |u'|))
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Build| m@@20 u@@7 v@@45)) |u'|))
)))
(assert (forall ((m@@21 T@U) (u@@8 T@U) (v@@46 T@U) ) (! (let ((V@@19 (type v@@46)))
(let ((U@@19 (type u@@8)))
 (=> (and (= (type m@@21) (MapType U@@19 V@@19)) (U_2_bool (MapType0Select (|Map#Domain| m@@21) u@@8))) (= (|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)) (|Map#Card| m@@21)))))
 :qid |DafnyPreludebpl.1243:21|
 :skolemid |639|
 :pattern ( (|Map#Card| (|Map#Build| m@@21 u@@8 v@@46)))
)))
(assert (forall ((m@@22 T@U) (u@@9 T@U) (v@@47 T@U) ) (! (let ((V@@20 (type v@@47)))
(let ((U@@20 (type u@@9)))
 (=> (and (= (type m@@22) (MapType U@@20 V@@20)) (not (U_2_bool (MapType0Select (|Map#Domain| m@@22) u@@9)))) (= (|Map#Card| (|Map#Build| m@@22 u@@9 v@@47)) (+ (|Map#Card| m@@22) 1)))))
 :qid |DafnyPreludebpl.1245:21|
 :skolemid |640|
 :pattern ( (|Map#Card| (|Map#Build| m@@22 u@@9 v@@47)))
)))
(assert (forall ((arg0@@107 T@U) (arg1@@47 T@U) ) (! (let ((V@@21 (MapTypeInv1 (type arg0@@107))))
(let ((U@@21 (MapTypeInv0 (type arg0@@107))))
(= (type (|Map#Merge| arg0@@107 arg1@@47)) (MapType U@@21 V@@21))))
 :qid |funType:Map#Merge|
 :pattern ( (|Map#Merge| arg0@@107 arg1@@47))
)))
(assert (forall ((m@@23 T@U) (n@@25 T@U) ) (! (let ((V@@22 (MapTypeInv1 (type m@@23))))
(let ((U@@22 (MapTypeInv0 (type m@@23))))
 (=> (and (= (type m@@23) (MapType U@@22 V@@22)) (= (type n@@25) (MapType U@@22 V@@22))) (= (|Map#Domain| (|Map#Merge| m@@23 n@@25)) (|Set#Union| (|Map#Domain| m@@23) (|Map#Domain| n@@25))))))
 :qid |DafnyPreludebpl.1250:21|
 :skolemid |641|
 :pattern ( (|Map#Domain| (|Map#Merge| m@@23 n@@25)))
)))
(assert (forall ((m@@24 T@U) (n@@26 T@U) (u@@10 T@U) ) (! (let ((V@@23 (MapTypeInv1 (type m@@24))))
(let ((U@@23 (type u@@10)))
 (=> (and (and (= (type m@@24) (MapType U@@23 V@@23)) (= (type n@@26) (MapType U@@23 V@@23))) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Merge| m@@24 n@@26)) u@@10))) (and (=> (not (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10))) (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10) (MapType0Select (|Map#Elements| m@@24) u@@10))) (=> (U_2_bool (MapType0Select (|Map#Domain| n@@26) u@@10)) (= (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10) (MapType0Select (|Map#Elements| n@@26) u@@10)))))))
 :qid |DafnyPreludebpl.1253:21|
 :skolemid |642|
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Merge| m@@24 n@@26)) u@@10))
)))
(assert (forall ((arg0@@108 T@U) (arg1@@48 T@U) ) (! (let ((V@@24 (MapTypeInv1 (type arg0@@108))))
(let ((U@@24 (MapTypeInv0 (type arg0@@108))))
(= (type (|Map#Subtract| arg0@@108 arg1@@48)) (MapType U@@24 V@@24))))
 :qid |funType:Map#Subtract|
 :pattern ( (|Map#Subtract| arg0@@108 arg1@@48))
)))
(assert (forall ((m@@25 T@U) (s@@45 T@U) ) (! (let ((V@@25 (MapTypeInv1 (type m@@25))))
(let ((U@@25 (MapTypeInv0 (type m@@25))))
 (=> (and (= (type m@@25) (MapType U@@25 V@@25)) (= (type s@@45) (MapType0Type U@@25 boolType))) (= (|Map#Domain| (|Map#Subtract| m@@25 s@@45)) (|Set#Difference| (|Map#Domain| m@@25) s@@45)))))
 :qid |DafnyPreludebpl.1260:21|
 :skolemid |643|
 :pattern ( (|Map#Domain| (|Map#Subtract| m@@25 s@@45)))
)))
(assert (forall ((m@@26 T@U) (s@@46 T@U) (u@@11 T@U) ) (! (let ((V@@26 (MapTypeInv1 (type m@@26))))
(let ((U@@26 (type u@@11)))
 (=> (and (and (= (type m@@26) (MapType U@@26 V@@26)) (= (type s@@46) (MapType0Type U@@26 boolType))) (U_2_bool (MapType0Select (|Map#Domain| (|Map#Subtract| m@@26 s@@46)) u@@11))) (= (MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46)) u@@11) (MapType0Select (|Map#Elements| m@@26) u@@11)))))
 :qid |DafnyPreludebpl.1263:21|
 :skolemid |644|
 :pattern ( (MapType0Select (|Map#Elements| (|Map#Subtract| m@@26 s@@46)) u@@11))
)))
(assert (forall ((m@@27 T@U) (|m'| T@U) ) (! (let ((V@@27 (MapTypeInv1 (type m@@27))))
(let ((U@@27 (MapTypeInv0 (type m@@27))))
 (=> (and (= (type m@@27) (MapType U@@27 V@@27)) (= (type |m'|) (MapType U@@27 V@@27))) (= (|Map#Equal| m@@27 |m'|)  (and (forall ((u@@12 T@U) ) (!  (=> (= (type u@@12) U@@27) (= (U_2_bool (MapType0Select (|Map#Domain| m@@27) u@@12)) (U_2_bool (MapType0Select (|Map#Domain| |m'|) u@@12))))
 :qid |DafnyPreludebpl.1272:35|
 :skolemid |645|
 :no-pattern (type u@@12)
 :no-pattern (U_2_int u@@12)
 :no-pattern (U_2_bool u@@12)
)) (forall ((u@@13 T@U) ) (!  (=> (and (= (type u@@13) U@@27) (U_2_bool (MapType0Select (|Map#Domain| m@@27) u@@13))) (= (MapType0Select (|Map#Elements| m@@27) u@@13) (MapType0Select (|Map#Elements| |m'|) u@@13)))
 :qid |DafnyPreludebpl.1273:35|
 :skolemid |646|
 :no-pattern (type u@@13)
 :no-pattern (U_2_int u@@13)
 :no-pattern (U_2_bool u@@13)
)))))))
 :qid |DafnyPreludebpl.1270:21|
 :skolemid |647|
 :pattern ( (|Map#Equal| m@@27 |m'|))
)))
(assert (forall ((m@@28 T@U) (|m'@@0| T@U) ) (! (let ((V@@28 (MapTypeInv1 (type m@@28))))
(let ((U@@28 (MapTypeInv0 (type m@@28))))
 (=> (and (and (= (type m@@28) (MapType U@@28 V@@28)) (= (type |m'@@0|) (MapType U@@28 V@@28))) (|Map#Equal| m@@28 |m'@@0|)) (= m@@28 |m'@@0|))))
 :qid |DafnyPreludebpl.1275:21|
 :skolemid |648|
 :pattern ( (|Map#Equal| m@@28 |m'@@0|))
)))
(assert (forall ((m@@29 T@U) (|m'@@1| T@U) ) (! (let ((V@@29 (MapTypeInv1 (type m@@29))))
(let ((U@@29 (MapTypeInv0 (type m@@29))))
 (=> (and (= (type m@@29) (MapType U@@29 V@@29)) (= (type |m'@@1|) (MapType U@@29 V@@29))) (= (|Map#Disjoint| m@@29 |m'@@1|) (forall ((o@@43 T@U) ) (!  (=> (= (type o@@43) U@@29) (or (not (U_2_bool (MapType0Select (|Map#Domain| m@@29) o@@43))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'@@1|) o@@43)))))
 :qid |DafnyPreludebpl.1282:38|
 :skolemid |649|
 :pattern ( (MapType0Select (|Map#Domain| m@@29) o@@43))
 :pattern ( (MapType0Select (|Map#Domain| |m'@@1|) o@@43))
))))))
 :qid |DafnyPreludebpl.1280:21|
 :skolemid |650|
 :pattern ( (|Map#Disjoint| m@@29 |m'@@1|))
)))
(assert (forall ((U@@30 T@T) (V@@30 T@T) ) (! (= (type (|IMap#Empty| U@@30 V@@30)) (IMapType U@@30 V@@30))
 :qid |funType:IMap#Empty|
 :pattern ( (|IMap#Empty| U@@30 V@@30))
)))
(assert (forall ((m@@30 T@U) ) (! (let ((V@@31 (IMapTypeInv1 (type m@@30))))
(let ((U@@31 (IMapTypeInv0 (type m@@30))))
 (=> (= (type m@@30) (IMapType U@@31 V@@31)) (or (= m@@30 (|IMap#Empty| U@@31 V@@31)) (exists ((k@@6 T@U) ) (!  (and (= (type k@@6) U@@31) (U_2_bool (MapType0Select (|IMap#Domain| m@@30) k@@6)))
 :qid |DafnyPreludebpl.1298:32|
 :skolemid |651|
 :no-pattern (type k@@6)
 :no-pattern (U_2_int k@@6)
 :no-pattern (U_2_bool k@@6)
))))))
 :qid |DafnyPreludebpl.1296:21|
 :skolemid |652|
 :pattern ( (|IMap#Domain| m@@30))
)))
(assert (forall ((m@@31 T@U) ) (! (let ((V@@32 (IMapTypeInv1 (type m@@31))))
(let ((U@@32 (IMapTypeInv0 (type m@@31))))
 (=> (= (type m@@31) (IMapType U@@32 V@@32)) (or (= m@@31 (|IMap#Empty| U@@32 V@@32)) (exists ((v@@48 T@U) ) (!  (and (= (type v@@48) V@@32) (U_2_bool (MapType0Select (|IMap#Values| m@@31) v@@48)))
 :qid |DafnyPreludebpl.1301:32|
 :skolemid |653|
 :no-pattern (type v@@48)
 :no-pattern (U_2_int v@@48)
 :no-pattern (U_2_bool v@@48)
))))))
 :qid |DafnyPreludebpl.1299:21|
 :skolemid |654|
 :pattern ( (|IMap#Values| m@@31))
)))
(assert (forall ((m@@32 T@U) ) (! (let ((V@@33 (IMapTypeInv1 (type m@@32))))
(let ((U@@33 (IMapTypeInv0 (type m@@32))))
 (=> (= (type m@@32) (IMapType U@@33 V@@33)) (or (= m@@32 (|IMap#Empty| U@@33 V@@33)) (exists ((k@@7 T@U) (v@@49 T@U) ) (!  (and (and (= (type k@@7) BoxType) (= (type v@@49) BoxType)) (U_2_bool (MapType0Select (|IMap#Items| m@@32) ($Box (|#_System._tuple#2._#Make2| k@@7 v@@49)))))
 :qid |DafnyPreludebpl.1304:32|
 :skolemid |655|
 :no-pattern (type k@@7)
 :no-pattern (type v@@49)
 :no-pattern (U_2_int k@@7)
 :no-pattern (U_2_bool k@@7)
 :no-pattern (U_2_int v@@49)
 :no-pattern (U_2_bool v@@49)
))))))
 :qid |DafnyPreludebpl.1302:21|
 :skolemid |656|
 :pattern ( (|IMap#Items| m@@32))
)))
(assert (forall ((m@@33 T@U) ) (! (let ((V@@34 (IMapTypeInv1 (type m@@33))))
(let ((U@@34 (IMapTypeInv0 (type m@@33))))
 (=> (= (type m@@33) (IMapType U@@34 V@@34)) (= (= m@@33 (|IMap#Empty| U@@34 V@@34)) (= (|IMap#Domain| m@@33) (|ISet#Empty| U@@34))))))
 :qid |DafnyPreludebpl.1306:21|
 :skolemid |657|
 :pattern ( (|IMap#Domain| m@@33))
)))
(assert (forall ((m@@34 T@U) ) (! (let ((V@@35 (IMapTypeInv1 (type m@@34))))
(let ((U@@35 (IMapTypeInv0 (type m@@34))))
 (=> (= (type m@@34) (IMapType U@@35 V@@35)) (= (= m@@34 (|IMap#Empty| U@@35 V@@35)) (= (|IMap#Values| m@@34) (|ISet#Empty| V@@35))))))
 :qid |DafnyPreludebpl.1309:21|
 :skolemid |658|
 :pattern ( (|IMap#Values| m@@34))
)))
(assert (forall ((m@@35 T@U) ) (! (let ((V@@36 (IMapTypeInv1 (type m@@35))))
(let ((U@@36 (IMapTypeInv0 (type m@@35))))
 (=> (= (type m@@35) (IMapType U@@36 V@@36)) (= (= m@@35 (|IMap#Empty| U@@36 V@@36)) (= (|IMap#Items| m@@35) (|ISet#Empty| BoxType))))))
 :qid |DafnyPreludebpl.1312:21|
 :skolemid |659|
 :pattern ( (|IMap#Items| m@@35))
)))
(assert (forall ((m@@36 T@U) (v@@50 T@U) ) (! (let ((V@@37 (type v@@50)))
(let ((U@@37 (IMapTypeInv0 (type m@@36))))
 (=> (= (type m@@36) (IMapType U@@37 V@@37)) (= (U_2_bool (MapType0Select (|IMap#Values| m@@36) v@@50)) (exists ((u@@14 T@U) ) (!  (and (= (type u@@14) U@@37) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@36) u@@14)) (= v@@50 (MapType0Select (|IMap#Elements| m@@36) u@@14))))
 :qid |DafnyPreludebpl.1325:10|
 :skolemid |660|
 :pattern ( (MapType0Select (|IMap#Domain| m@@36) u@@14))
 :pattern ( (MapType0Select (|IMap#Elements| m@@36) u@@14))
))))))
 :qid |DafnyPreludebpl.1323:20|
 :skolemid |661|
 :pattern ( (MapType0Select (|IMap#Values| m@@36) v@@50))
)))
(assert (forall ((m@@37 T@U) (item@@0 T@U) ) (!  (=> (and (= (type m@@37) (IMapType BoxType BoxType)) (= (type item@@0) BoxType)) (= (U_2_bool (MapType0Select (|IMap#Items| m@@37) item@@0))  (and (U_2_bool (MapType0Select (|IMap#Domain| m@@37) (_System.Tuple2._0 ($Unbox DatatypeTypeType item@@0)))) (= (MapType0Select (|IMap#Elements| m@@37) (_System.Tuple2._0 ($Unbox DatatypeTypeType item@@0))) (_System.Tuple2._1 ($Unbox DatatypeTypeType item@@0))))))
 :qid |DafnyPreludebpl.1340:15|
 :skolemid |662|
 :pattern ( (MapType0Select (|IMap#Items| m@@37) item@@0))
)))
(assert (forall ((u@@15 T@U) (V@@38 T@T) ) (! (let ((U@@38 (type u@@15)))
 (not (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Empty| U@@38 V@@38)) u@@15))))
 :qid |DafnyPreludebpl.1347:21|
 :skolemid |663|
 :pattern ( (let ((U@@38 (type u@@15)))
(MapType0Select (|IMap#Domain| (|IMap#Empty| U@@38 V@@38)) u@@15)))
)))
(assert (forall ((arg0@@109 T@U) (arg1@@49 T@U) (arg2@@6 T@U) ) (! (let ((V@@39 (MapType0TypeInv1 (type arg1@@49))))
(let ((U@@39 (MapType0TypeInv0 (type arg0@@109))))
(= (type (|IMap#Glue| arg0@@109 arg1@@49 arg2@@6)) (IMapType U@@39 V@@39))))
 :qid |funType:IMap#Glue|
 :pattern ( (|IMap#Glue| arg0@@109 arg1@@49 arg2@@6))
)))
(assert (forall ((a@@76 T@U) (b@@55 T@U) (t@@29 T@U) ) (! (let ((V@@40 (MapType0TypeInv1 (type b@@55))))
(let ((U@@40 (MapType0TypeInv0 (type a@@76))))
 (=> (and (and (= (type a@@76) (MapType0Type U@@40 boolType)) (= (type b@@55) (MapType0Type U@@40 V@@40))) (= (type t@@29) TyType)) (= (|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)) a@@76))))
 :qid |DafnyPreludebpl.1352:21|
 :skolemid |664|
 :pattern ( (|IMap#Domain| (|IMap#Glue| a@@76 b@@55 t@@29)))
)))
(assert (forall ((a@@77 T@U) (b@@56 T@U) (t@@30 T@U) ) (! (let ((V@@41 (MapType0TypeInv1 (type b@@56))))
(let ((U@@41 (MapType0TypeInv0 (type a@@77))))
 (=> (and (and (= (type a@@77) (MapType0Type U@@41 boolType)) (= (type b@@56) (MapType0Type U@@41 V@@41))) (= (type t@@30) TyType)) (= (|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)) b@@56))))
 :qid |DafnyPreludebpl.1355:21|
 :skolemid |665|
 :pattern ( (|IMap#Elements| (|IMap#Glue| a@@77 b@@56 t@@30)))
)))
(assert (forall ((a@@78 T@U) (b@@57 T@U) (t0@@15 T@U) (t1@@6 T@U) ) (!  (=> (and (and (and (and (= (type a@@78) (MapType0Type BoxType boolType)) (= (type b@@57) (MapType0Type BoxType BoxType))) (= (type t0@@15) TyType)) (= (type t1@@6) TyType)) (forall ((bx@@25 T@U) ) (!  (=> (and (= (type bx@@25) BoxType) (U_2_bool (MapType0Select a@@78 bx@@25))) (and ($IsBox bx@@25 t0@@15) ($IsBox (MapType0Select b@@57 bx@@25) t1@@6)))
 :qid |DafnyPreludebpl.1361:11|
 :skolemid |666|
 :no-pattern (type bx@@25)
 :no-pattern (U_2_int bx@@25)
 :no-pattern (U_2_bool bx@@25)
))) ($Is (|Map#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6)) (TIMap t0@@15 t1@@6)))
 :qid |DafnyPreludebpl.1358:15|
 :skolemid |667|
 :pattern ( (|IMap#Glue| a@@78 b@@57 (TIMap t0@@15 t1@@6)))
)))
(assert (forall ((arg0@@110 T@U) (arg1@@50 T@U) (arg2@@7 T@U) ) (! (let ((V@@42 (type arg2@@7)))
(let ((U@@42 (type arg1@@50)))
(= (type (|IMap#Build| arg0@@110 arg1@@50 arg2@@7)) (IMapType U@@42 V@@42))))
 :qid |funType:IMap#Build|
 :pattern ( (|IMap#Build| arg0@@110 arg1@@50 arg2@@7))
)))
(assert (forall ((m@@38 T@U) (u@@16 T@U) (|u'@@0| T@U) (v@@51 T@U) ) (! (let ((V@@43 (type v@@51)))
(let ((U@@43 (type u@@16)))
 (=> (and (= (type m@@38) (IMapType U@@43 V@@43)) (= (type |u'@@0|) U@@43)) (and (=> (= |u'@@0| u@@16) (and (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|)) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|) v@@51))) (=> (not (= |u'@@0| u@@16)) (and (= (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|)) (U_2_bool (MapType0Select (|IMap#Domain| m@@38) |u'@@0|))) (= (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|) (MapType0Select (|IMap#Elements| m@@38) |u'@@0|))))))))
 :qid |DafnyPreludebpl.1371:21|
 :skolemid |668|
 :pattern ( (MapType0Select (|IMap#Domain| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|))
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Build| m@@38 u@@16 v@@51)) |u'@@0|))
)))
(assert (forall ((m@@39 T@U) (|m'@@2| T@U) ) (! (let ((V@@44 (IMapTypeInv1 (type m@@39))))
(let ((U@@44 (IMapTypeInv0 (type m@@39))))
 (=> (and (= (type m@@39) (IMapType U@@44 V@@44)) (= (type |m'@@2|) (IMapType U@@44 V@@44))) (= (|IMap#Equal| m@@39 |m'@@2|)  (and (forall ((u@@17 T@U) ) (!  (=> (= (type u@@17) U@@44) (= (U_2_bool (MapType0Select (|IMap#Domain| m@@39) u@@17)) (U_2_bool (MapType0Select (|IMap#Domain| |m'@@2|) u@@17))))
 :qid |DafnyPreludebpl.1382:36|
 :skolemid |669|
 :no-pattern (type u@@17)
 :no-pattern (U_2_int u@@17)
 :no-pattern (U_2_bool u@@17)
)) (forall ((u@@18 T@U) ) (!  (=> (and (= (type u@@18) U@@44) (U_2_bool (MapType0Select (|IMap#Domain| m@@39) u@@18))) (= (MapType0Select (|IMap#Elements| m@@39) u@@18) (MapType0Select (|IMap#Elements| |m'@@2|) u@@18)))
 :qid |DafnyPreludebpl.1383:35|
 :skolemid |670|
 :no-pattern (type u@@18)
 :no-pattern (U_2_int u@@18)
 :no-pattern (U_2_bool u@@18)
)))))))
 :qid |DafnyPreludebpl.1380:21|
 :skolemid |671|
 :pattern ( (|IMap#Equal| m@@39 |m'@@2|))
)))
(assert (forall ((m@@40 T@U) (|m'@@3| T@U) ) (! (let ((V@@45 (IMapTypeInv1 (type m@@40))))
(let ((U@@45 (IMapTypeInv0 (type m@@40))))
 (=> (and (and (= (type m@@40) (IMapType U@@45 V@@45)) (= (type |m'@@3|) (IMapType U@@45 V@@45))) (|IMap#Equal| m@@40 |m'@@3|)) (= m@@40 |m'@@3|))))
 :qid |DafnyPreludebpl.1385:21|
 :skolemid |672|
 :pattern ( (|IMap#Equal| m@@40 |m'@@3|))
)))
(assert (forall ((arg0@@111 T@U) (arg1@@51 T@U) ) (! (let ((V@@46 (IMapTypeInv1 (type arg0@@111))))
(let ((U@@46 (IMapTypeInv0 (type arg0@@111))))
(= (type (|IMap#Merge| arg0@@111 arg1@@51)) (IMapType U@@46 V@@46))))
 :qid |funType:IMap#Merge|
 :pattern ( (|IMap#Merge| arg0@@111 arg1@@51))
)))
(assert (forall ((m@@41 T@U) (n@@27 T@U) ) (! (let ((V@@47 (IMapTypeInv1 (type m@@41))))
(let ((U@@47 (IMapTypeInv0 (type m@@41))))
 (=> (and (= (type m@@41) (IMapType U@@47 V@@47)) (= (type n@@27) (IMapType U@@47 V@@47))) (= (|IMap#Domain| (|IMap#Merge| m@@41 n@@27)) (|Set#Union| (|IMap#Domain| m@@41) (|IMap#Domain| n@@27))))))
 :qid |DafnyPreludebpl.1391:21|
 :skolemid |673|
 :pattern ( (|IMap#Domain| (|IMap#Merge| m@@41 n@@27)))
)))
(assert (forall ((m@@42 T@U) (n@@28 T@U) (u@@19 T@U) ) (! (let ((V@@48 (IMapTypeInv1 (type m@@42))))
(let ((U@@48 (type u@@19)))
 (=> (and (and (= (type m@@42) (IMapType U@@48 V@@48)) (= (type n@@28) (IMapType U@@48 V@@48))) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Merge| m@@42 n@@28)) u@@19))) (and (=> (not (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19))) (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19) (MapType0Select (|IMap#Elements| m@@42) u@@19))) (=> (U_2_bool (MapType0Select (|IMap#Domain| n@@28) u@@19)) (= (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19) (MapType0Select (|IMap#Elements| n@@28) u@@19)))))))
 :qid |DafnyPreludebpl.1394:21|
 :skolemid |674|
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Merge| m@@42 n@@28)) u@@19))
)))
(assert (forall ((arg0@@112 T@U) (arg1@@52 T@U) ) (! (let ((V@@49 (IMapTypeInv1 (type arg0@@112))))
(let ((U@@49 (IMapTypeInv0 (type arg0@@112))))
(= (type (|IMap#Subtract| arg0@@112 arg1@@52)) (IMapType U@@49 V@@49))))
 :qid |funType:IMap#Subtract|
 :pattern ( (|IMap#Subtract| arg0@@112 arg1@@52))
)))
(assert (forall ((m@@43 T@U) (s@@47 T@U) ) (! (let ((V@@50 (IMapTypeInv1 (type m@@43))))
(let ((U@@50 (IMapTypeInv0 (type m@@43))))
 (=> (and (= (type m@@43) (IMapType U@@50 V@@50)) (= (type s@@47) (MapType0Type U@@50 boolType))) (= (|IMap#Domain| (|IMap#Subtract| m@@43 s@@47)) (|Set#Difference| (|IMap#Domain| m@@43) s@@47)))))
 :qid |DafnyPreludebpl.1401:21|
 :skolemid |675|
 :pattern ( (|IMap#Domain| (|IMap#Subtract| m@@43 s@@47)))
)))
(assert (forall ((m@@44 T@U) (s@@48 T@U) (u@@20 T@U) ) (! (let ((V@@51 (IMapTypeInv1 (type m@@44))))
(let ((U@@51 (type u@@20)))
 (=> (and (and (= (type m@@44) (IMapType U@@51 V@@51)) (= (type s@@48) (MapType0Type U@@51 boolType))) (U_2_bool (MapType0Select (|IMap#Domain| (|IMap#Subtract| m@@44 s@@48)) u@@20))) (= (MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44 s@@48)) u@@20) (MapType0Select (|IMap#Elements| m@@44) u@@20)))))
 :qid |DafnyPreludebpl.1404:21|
 :skolemid |676|
 :pattern ( (MapType0Select (|IMap#Elements| (|IMap#Subtract| m@@44 s@@48)) u@@20))
)))
(assert (forall ((x@@42 Int) (y@@12 Int) ) (! (= (INTERNAL_add_boogie x@@42 y@@12) (+ x@@42 y@@12))
 :qid |DafnyPreludebpl.1413:30|
 :skolemid |677|
 :pattern ( (INTERNAL_add_boogie x@@42 y@@12))
)))
(assert (forall ((x@@43 Int) (y@@13 Int) ) (! (= (INTERNAL_sub_boogie x@@43 y@@13) (- x@@43 y@@13))
 :qid |DafnyPreludebpl.1414:30|
 :skolemid |678|
 :pattern ( (INTERNAL_sub_boogie x@@43 y@@13))
)))
(assert (forall ((x@@44 Int) (y@@14 Int) ) (! (= (INTERNAL_mul_boogie x@@44 y@@14) (* x@@44 y@@14))
 :qid |DafnyPreludebpl.1415:30|
 :skolemid |679|
 :pattern ( (INTERNAL_mul_boogie x@@44 y@@14))
)))
(assert (forall ((x@@45 Int) (y@@15 Int) ) (! (= (INTERNAL_div_boogie x@@45 y@@15) (div x@@45 y@@15))
 :qid |DafnyPreludebpl.1416:30|
 :skolemid |680|
 :pattern ( (INTERNAL_div_boogie x@@45 y@@15))
)))
(assert (forall ((x@@46 Int) (y@@16 Int) ) (! (= (INTERNAL_mod_boogie x@@46 y@@16) (mod x@@46 y@@16))
 :qid |DafnyPreludebpl.1417:30|
 :skolemid |681|
 :pattern ( (INTERNAL_mod_boogie x@@46 y@@16))
)))
(assert (forall ((x@@47 Int) (y@@17 Int) ) (! (= (INTERNAL_lt_boogie x@@47 y@@17) (< x@@47 y@@17))
 :qid |DafnyPreludebpl.1418:51|
 :skolemid |682|
 :pattern ( (INTERNAL_lt_boogie x@@47 y@@17))
)))
(assert (forall ((x@@48 Int) (y@@18 Int) ) (! (= (INTERNAL_le_boogie x@@48 y@@18) (<= x@@48 y@@18))
 :qid |DafnyPreludebpl.1419:51|
 :skolemid |683|
 :pattern ( (INTERNAL_le_boogie x@@48 y@@18))
)))
(assert (forall ((x@@49 Int) (y@@19 Int) ) (! (= (INTERNAL_gt_boogie x@@49 y@@19) (> x@@49 y@@19))
 :qid |DafnyPreludebpl.1420:51|
 :skolemid |684|
 :pattern ( (INTERNAL_gt_boogie x@@49 y@@19))
)))
(assert (forall ((x@@50 Int) (y@@20 Int) ) (! (= (INTERNAL_ge_boogie x@@50 y@@20) (>= x@@50 y@@20))
 :qid |DafnyPreludebpl.1421:51|
 :skolemid |685|
 :pattern ( (INTERNAL_ge_boogie x@@50 y@@20))
)))
(assert (forall ((x@@51 Int) (y@@21 Int) ) (! (= (Mul x@@51 y@@21) (* x@@51 y@@21))
 :qid |DafnyPreludebpl.1423:14|
 :skolemid |686|
 :pattern ( (Mul x@@51 y@@21))
)))
(assert (forall ((x@@52 Int) (y@@22 Int) ) (! (= (Div x@@52 y@@22) (div x@@52 y@@22))
 :qid |DafnyPreludebpl.1424:14|
 :skolemid |687|
 :pattern ( (Div x@@52 y@@22))
)))
(assert (forall ((x@@53 Int) (y@@23 Int) ) (! (= (Mod x@@53 y@@23) (mod x@@53 y@@23))
 :qid |DafnyPreludebpl.1425:14|
 :skolemid |688|
 :pattern ( (Mod x@@53 y@@23))
)))
(assert (forall ((x@@54 Int) (y@@24 Int) ) (! (= (Add x@@54 y@@24) (+ x@@54 y@@24))
 :qid |DafnyPreludebpl.1426:14|
 :skolemid |689|
 :pattern ( (Add x@@54 y@@24))
)))
(assert (forall ((x@@55 Int) (y@@25 Int) ) (! (= (Sub x@@55 y@@25) (- x@@55 y@@25))
 :qid |DafnyPreludebpl.1427:14|
 :skolemid |690|
 :pattern ( (Sub x@@55 y@@25))
)))
(assert (forall ((A@@2 T@U) (B T@U) (a@@79 T@U) (b@@58 T@U) ) (!  (=> (and (and (and (and (= (type A@@2) TyType) (= (type B) TyType)) (= (type a@@79) BoxType)) (= (type b@@58) BoxType)) (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58)) (< (BoxRank a@@79) (BoxRank b@@58)))
 :qid |DafnyPreludebpl.1468:15|
 :skolemid |691|
 :pattern ( (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58) (BoxRank a@@79))
 :pattern ( (_System.__default.rank__is__less__than A@@2 B a@@79 b@@58) (BoxRank b@@58))
)))
(assert (forall ((A@@3 T@U) (B@@0 T@U) (a@@80 T@U) (b@@59 T@U) ) (!  (=> (and (and (and (and (= (type A@@3) TyType) (= (type B@@0) TyType)) (= (type a@@80) BoxType)) (= (type b@@59) (SeqType BoxType))) (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59))) (< (BoxRank a@@80) (|Seq#Rank| b@@59)))
 :qid |DafnyPreludebpl.1473:15|
 :skolemid |692|
 :pattern ( (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59)) (BoxRank a@@80))
 :pattern ( (_System.__default.rank__is__less__than A@@3 B@@0 a@@80 ($Box b@@59)) (|Seq#Rank| b@@59))
)))
(assert (forall ((A@@4 T@U) (B@@1 T@U) (a@@81 T@U) (b@@60 T@U) ) (!  (=> (and (and (and (and (= (type A@@4) TyType) (= (type B@@1) TyType)) (= (type a@@81) (SeqType BoxType))) (= (type b@@60) BoxType)) (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60)) (< (|Seq#Rank| a@@81) (BoxRank b@@60)))
 :qid |DafnyPreludebpl.1478:15|
 :skolemid |693|
 :pattern ( (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60) (|Seq#Rank| a@@81))
 :pattern ( (_System.__default.rank__is__less__than A@@4 B@@1 ($Box a@@81) b@@60) (BoxRank b@@60))
)))
(assert (= (type Tclass._System.nat) TyType))
(assert (= (Tag Tclass._System.nat) Tagclass._System.nat))
(assert (forall ((arg0@@113 T@U) ) (! (= (type (TagFamily arg0@@113)) TyTagFamilyType)
 :qid |funType:TagFamily|
 :pattern ( (TagFamily arg0@@113))
)))
(assert (= (TagFamily Tclass._System.nat) tytagFamily$nat))
(assert (forall ((bx@@26 T@U) ) (!  (=> (and (= (type bx@@26) BoxType) ($IsBox bx@@26 Tclass._System.nat)) (and (= ($Box ($Unbox intType bx@@26)) bx@@26) ($Is ($Unbox intType bx@@26) Tclass._System.nat)))
 :qid |unknown.0:0|
 :skolemid |694|
 :pattern ( ($IsBox bx@@26 Tclass._System.nat))
)))
(assert (forall ((|x#0| T@U) ) (!  (=> (= (type |x#0|) intType) (= ($Is |x#0| Tclass._System.nat) (INTERNAL_le_boogie 0 (U_2_int |x#0|))))
 :qid |unknown.0:0|
 :skolemid |695|
 :pattern ( ($Is |x#0| Tclass._System.nat))
)))
(assert (forall ((|x#0@@0| T@U) ($h T@U) ) (!  (=> (and (= (type |x#0@@0|) intType) (= (type $h) (MapType0Type refType MapType1Type))) ($IsAlloc |x#0@@0| Tclass._System.nat $h))
 :qid |unknown.0:0|
 :skolemid |696|
 :pattern ( ($IsAlloc |x#0@@0| Tclass._System.nat $h))
)))
(assert (= (Tag Tclass._System.object?) Tagclass._System.object?))
(assert (= (TagFamily Tclass._System.object?) tytagFamily$object))
(assert (forall ((bx@@27 T@U) ) (!  (=> (and (= (type bx@@27) BoxType) ($IsBox bx@@27 Tclass._System.object?)) (and (= ($Box ($Unbox refType bx@@27)) bx@@27) ($Is ($Unbox refType bx@@27) Tclass._System.object?)))
 :qid |unknown.0:0|
 :skolemid |697|
 :pattern ( ($IsBox bx@@27 Tclass._System.object?))
)))
(assert (forall (($o T@U) ) (!  (=> (= (type $o) refType) ($Is $o Tclass._System.object?))
 :qid |unknown.0:0|
 :skolemid |698|
 :pattern ( ($Is $o Tclass._System.object?))
)))
(assert (= (type null) refType))
(assert (forall (($o@@0 T@U) ($h@@0 T@U) ) (!  (=> (and (= (type $o@@0) refType) (= (type $h@@0) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@0 Tclass._System.object? $h@@0)  (or (= $o@@0 null) (U_2_bool (MapType1Select (MapType0Select $h@@0 $o@@0) alloc)))))
 :qid |unknown.0:0|
 :skolemid |699|
 :pattern ( ($IsAlloc $o@@0 Tclass._System.object? $h@@0))
)))
(assert (= (type Tclass._System.object) TyType))
(assert (= (Tag Tclass._System.object) Tagclass._System.object))
(assert (= (TagFamily Tclass._System.object) tytagFamily$object))
(assert (forall ((bx@@28 T@U) ) (!  (=> (and (= (type bx@@28) BoxType) ($IsBox bx@@28 Tclass._System.object)) (and (= ($Box ($Unbox refType bx@@28)) bx@@28) ($Is ($Unbox refType bx@@28) Tclass._System.object)))
 :qid |unknown.0:0|
 :skolemid |700|
 :pattern ( ($IsBox bx@@28 Tclass._System.object))
)))
(assert (forall ((|c#0| T@U) ) (!  (=> (= (type |c#0|) refType) (= ($Is |c#0| Tclass._System.object)  (and ($Is |c#0| Tclass._System.object?) (not (= |c#0| null)))))
 :qid |unknown.0:0|
 :skolemid |701|
 :pattern ( ($Is |c#0| Tclass._System.object))
)))
(assert (forall ((|c#0@@0| T@U) ($h@@1 T@U) ) (!  (=> (and (= (type |c#0@@0|) refType) (= (type $h@@1) (MapType0Type refType MapType1Type))) (= ($IsAlloc |c#0@@0| Tclass._System.object $h@@1) ($IsAlloc |c#0@@0| Tclass._System.object? $h@@1)))
 :qid |unknown.0:0|
 :skolemid |702|
 :pattern ( ($IsAlloc |c#0@@0| Tclass._System.object $h@@1))
)))
(assert (forall ((arg0@@114 T@U) ) (! (= (type (Tclass._System.array? arg0@@114)) TyType)
 :qid |funType:Tclass._System.array?|
 :pattern ( (Tclass._System.array? arg0@@114))
)))
(assert (forall ((_System.array$arg T@U) ) (!  (=> (= (type _System.array$arg) TyType) (and (= (Tag (Tclass._System.array? _System.array$arg)) Tagclass._System.array?) (= (TagFamily (Tclass._System.array? _System.array$arg)) tytagFamily$array)))
 :qid |unknown.0:0|
 :skolemid |703|
 :pattern ( (Tclass._System.array? _System.array$arg))
)))
(assert (forall ((arg0@@115 T@U) ) (! (= (type (Tclass._System.array?_0 arg0@@115)) TyType)
 :qid |funType:Tclass._System.array?_0|
 :pattern ( (Tclass._System.array?_0 arg0@@115))
)))
(assert (forall ((_System.array$arg@@0 T@U) ) (!  (=> (= (type _System.array$arg@@0) TyType) (= (Tclass._System.array?_0 (Tclass._System.array? _System.array$arg@@0)) _System.array$arg@@0))
 :qid |unknown.0:0|
 :skolemid |704|
 :pattern ( (Tclass._System.array? _System.array$arg@@0))
)))
(assert (forall ((_System.array$arg@@1 T@U) (bx@@29 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@1) TyType) (= (type bx@@29) BoxType)) ($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1))) (and (= ($Box ($Unbox refType bx@@29)) bx@@29) ($Is ($Unbox refType bx@@29) (Tclass._System.array? _System.array$arg@@1))))
 :qid |unknown.0:0|
 :skolemid |705|
 :pattern ( ($IsBox bx@@29 (Tclass._System.array? _System.array$arg@@1)))
)))
(assert (forall ((arg0@@116 T@U) ) (! (= (type (dtype arg0@@116)) TyType)
 :qid |funType:dtype|
 :pattern ( (dtype arg0@@116))
)))
(assert (forall ((_System.array$arg@@2 T@U) ($h@@2 T@U) ($o@@1 T@U) ($i0 Int) ) (!  (=> (and (and (and (= (type _System.array$arg@@2) TyType) (= (type $h@@2) (MapType0Type refType MapType1Type))) (= (type $o@@1) refType)) (and (and ($IsGoodHeap $h@@2) (and (not (= $o@@1 null)) (= (dtype $o@@1) (Tclass._System.array? _System.array$arg@@2)))) (and (<= 0 $i0) (< $i0 (_System.array.Length $o@@1))))) ($IsBox (MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0)) _System.array$arg@@2))
 :qid |unknown.0:0|
 :skolemid |706|
 :pattern ( (MapType1Select (MapType0Select $h@@2 $o@@1) (IndexField $i0)) (Tclass._System.array? _System.array$arg@@2))
)))
(assert (forall ((_System.array$arg@@3 T@U) ($h@@3 T@U) ($o@@2 T@U) ($i0@@0 Int) ) (!  (=> (and (and (= (type _System.array$arg@@3) TyType) (= (type $h@@3) (MapType0Type refType MapType1Type))) (= (type $o@@2) refType)) (=> (and (and (and ($IsGoodHeap $h@@3) (and (not (= $o@@2 null)) (= (dtype $o@@2) (Tclass._System.array? _System.array$arg@@3)))) (and (<= 0 $i0@@0) (< $i0@@0 (_System.array.Length $o@@2)))) (U_2_bool (MapType1Select (MapType0Select $h@@3 $o@@2) alloc))) ($IsAllocBox (MapType1Select (MapType0Select $h@@3 $o@@2) (IndexField $i0@@0)) _System.array$arg@@3 $h@@3)))
 :qid |unknown.0:0|
 :skolemid |707|
 :pattern ( (MapType1Select (MapType0Select $h@@3 $o@@2) (IndexField $i0@@0)) (Tclass._System.array? _System.array$arg@@3))
)))
(assert (forall ((_System.array$arg@@4 T@U) ($o@@3 T@U) ) (!  (=> (and (= (type _System.array$arg@@4) TyType) (= (type $o@@3) refType)) (= ($Is $o@@3 (Tclass._System.array? _System.array$arg@@4))  (or (= $o@@3 null) (= (dtype $o@@3) (Tclass._System.array? _System.array$arg@@4)))))
 :qid |unknown.0:0|
 :skolemid |708|
 :pattern ( ($Is $o@@3 (Tclass._System.array? _System.array$arg@@4)))
)))
(assert (forall ((_System.array$arg@@5 T@U) ($o@@4 T@U) ($h@@4 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@5) TyType) (= (type $o@@4) refType)) (= (type $h@@4) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@4 (Tclass._System.array? _System.array$arg@@5) $h@@4)  (or (= $o@@4 null) (U_2_bool (MapType1Select (MapType0Select $h@@4 $o@@4) alloc)))))
 :qid |unknown.0:0|
 :skolemid |709|
 :pattern ( ($IsAlloc $o@@4 (Tclass._System.array? _System.array$arg@@5) $h@@4))
)))
(assert (forall ((_System.array$arg@@6 T@U) ($o@@5 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@6) TyType) (= (type $o@@5) refType)) (and (not (= $o@@5 null)) (= (dtype $o@@5) (Tclass._System.array? _System.array$arg@@6)))) ($Is (int_2_U (_System.array.Length $o@@5)) TInt))
 :qid |unknown.0:0|
 :skolemid |710|
 :pattern ( (_System.array.Length $o@@5) (Tclass._System.array? _System.array$arg@@6))
)))
(assert (forall ((_System.array$arg@@7 T@U) ($h@@5 T@U) ($o@@6 T@U) ) (!  (=> (and (and (and (= (type _System.array$arg@@7) TyType) (= (type $h@@5) (MapType0Type refType MapType1Type))) (= (type $o@@6) refType)) (and (and ($IsGoodHeap $h@@5) (and (not (= $o@@6 null)) (= (dtype $o@@6) (Tclass._System.array? _System.array$arg@@7)))) (U_2_bool (MapType1Select (MapType0Select $h@@5 $o@@6) alloc)))) ($IsAlloc (int_2_U (_System.array.Length $o@@6)) TInt $h@@5))
 :qid |unknown.0:0|
 :skolemid |711|
 :pattern ( (_System.array.Length $o@@6) (MapType1Select (MapType0Select $h@@5 $o@@6) alloc) (Tclass._System.array? _System.array$arg@@7))
)))
(assert (forall ((arg0@@117 T@U) ) (! (= (type (Tclass._System.array arg0@@117)) TyType)
 :qid |funType:Tclass._System.array|
 :pattern ( (Tclass._System.array arg0@@117))
)))
(assert (forall ((_System.array$arg@@8 T@U) ) (!  (=> (= (type _System.array$arg@@8) TyType) (and (= (Tag (Tclass._System.array _System.array$arg@@8)) Tagclass._System.array) (= (TagFamily (Tclass._System.array _System.array$arg@@8)) tytagFamily$array)))
 :qid |unknown.0:0|
 :skolemid |712|
 :pattern ( (Tclass._System.array _System.array$arg@@8))
)))
(assert (forall ((arg0@@118 T@U) ) (! (= (type (Tclass._System.array_0 arg0@@118)) TyType)
 :qid |funType:Tclass._System.array_0|
 :pattern ( (Tclass._System.array_0 arg0@@118))
)))
(assert (forall ((_System.array$arg@@9 T@U) ) (!  (=> (= (type _System.array$arg@@9) TyType) (= (Tclass._System.array_0 (Tclass._System.array _System.array$arg@@9)) _System.array$arg@@9))
 :qid |unknown.0:0|
 :skolemid |713|
 :pattern ( (Tclass._System.array _System.array$arg@@9))
)))
(assert (forall ((_System.array$arg@@10 T@U) (bx@@30 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@10) TyType) (= (type bx@@30) BoxType)) ($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10))) (and (= ($Box ($Unbox refType bx@@30)) bx@@30) ($Is ($Unbox refType bx@@30) (Tclass._System.array _System.array$arg@@10))))
 :qid |unknown.0:0|
 :skolemid |714|
 :pattern ( ($IsBox bx@@30 (Tclass._System.array _System.array$arg@@10)))
)))
(assert (forall ((_System.array$arg@@11 T@U) (|c#0@@1| T@U) ) (!  (=> (and (= (type _System.array$arg@@11) TyType) (= (type |c#0@@1|) refType)) (= ($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11))  (and ($Is |c#0@@1| (Tclass._System.array? _System.array$arg@@11)) (not (= |c#0@@1| null)))))
 :qid |unknown.0:0|
 :skolemid |715|
 :pattern ( ($Is |c#0@@1| (Tclass._System.array _System.array$arg@@11)))
)))
(assert (forall ((_System.array$arg@@12 T@U) (|c#0@@2| T@U) ($h@@6 T@U) ) (!  (=> (and (and (= (type _System.array$arg@@12) TyType) (= (type |c#0@@2|) refType)) (= (type $h@@6) (MapType0Type refType MapType1Type))) (= ($IsAlloc |c#0@@2| (Tclass._System.array _System.array$arg@@12) $h@@6) ($IsAlloc |c#0@@2| (Tclass._System.array? _System.array$arg@@12) $h@@6)))
 :qid |unknown.0:0|
 :skolemid |716|
 :pattern ( ($IsAlloc |c#0@@2| (Tclass._System.array _System.array$arg@@12) $h@@6))
)))
(assert (forall ((arg0@@119 T@U) (arg1@@53 T@U) ) (! (= (type (Tclass._System.___hFunc1 arg0@@119 arg1@@53)) TyType)
 :qid |funType:Tclass._System.___hFunc1|
 :pattern ( (Tclass._System.___hFunc1 arg0@@119 arg1@@53))
)))
(assert (forall ((|#$T0| T@U) (|#$R| T@U) ) (!  (=> (and (= (type |#$T0|) TyType) (= (type |#$R|) TyType)) (and (= (Tag (Tclass._System.___hFunc1 |#$T0| |#$R|)) Tagclass._System.___hFunc1) (= (TagFamily (Tclass._System.___hFunc1 |#$T0| |#$R|)) |tytagFamily$_#Func1|)))
 :qid |unknown.0:0|
 :skolemid |717|
 :pattern ( (Tclass._System.___hFunc1 |#$T0| |#$R|))
)))
(assert (forall ((arg0@@120 T@U) ) (! (= (type (Tclass._System.___hFunc1_0 arg0@@120)) TyType)
 :qid |funType:Tclass._System.___hFunc1_0|
 :pattern ( (Tclass._System.___hFunc1_0 arg0@@120))
)))
(assert (forall ((|#$T0@@0| T@U) (|#$R@@0| T@U) ) (!  (=> (and (= (type |#$T0@@0|) TyType) (= (type |#$R@@0|) TyType)) (= (Tclass._System.___hFunc1_0 (Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|)) |#$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |718|
 :pattern ( (Tclass._System.___hFunc1 |#$T0@@0| |#$R@@0|))
)))
(assert (forall ((arg0@@121 T@U) ) (! (= (type (Tclass._System.___hFunc1_1 arg0@@121)) TyType)
 :qid |funType:Tclass._System.___hFunc1_1|
 :pattern ( (Tclass._System.___hFunc1_1 arg0@@121))
)))
(assert (forall ((|#$T0@@1| T@U) (|#$R@@1| T@U) ) (!  (=> (and (= (type |#$T0@@1|) TyType) (= (type |#$R@@1|) TyType)) (= (Tclass._System.___hFunc1_1 (Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|)) |#$R@@1|))
 :qid |unknown.0:0|
 :skolemid |719|
 :pattern ( (Tclass._System.___hFunc1 |#$T0@@1| |#$R@@1|))
)))
(assert (forall ((|#$T0@@2| T@U) (|#$R@@2| T@U) (bx@@31 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@2|) TyType) (= (type |#$R@@2|) TyType)) (= (type bx@@31) BoxType)) ($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|))) (and (= ($Box ($Unbox HandleTypeType bx@@31)) bx@@31) ($Is ($Unbox HandleTypeType bx@@31) (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|))))
 :qid |unknown.0:0|
 :skolemid |720|
 :pattern ( ($IsBox bx@@31 (Tclass._System.___hFunc1 |#$T0@@2| |#$R@@2|)))
)))
(assert  (and (and (and (and (and (and (and (and (forall ((arg0@@122 T@T) (arg1@@54 T@T) (arg2@@8 T@T) ) (! (= (Ctor (MapType2Type arg0@@122 arg1@@54 arg2@@8)) 24)
 :qid |ctor:MapType2Type|
)) (forall ((arg0@@123 T@T) (arg1@@55 T@T) (arg2@@9 T@T) ) (! (= (MapType2TypeInv0 (MapType2Type arg0@@123 arg1@@55 arg2@@9)) arg0@@123)
 :qid |typeInv:MapType2TypeInv0|
 :pattern ( (MapType2Type arg0@@123 arg1@@55 arg2@@9))
))) (forall ((arg0@@124 T@T) (arg1@@56 T@T) (arg2@@10 T@T) ) (! (= (MapType2TypeInv1 (MapType2Type arg0@@124 arg1@@56 arg2@@10)) arg1@@56)
 :qid |typeInv:MapType2TypeInv1|
 :pattern ( (MapType2Type arg0@@124 arg1@@56 arg2@@10))
))) (forall ((arg0@@125 T@T) (arg1@@57 T@T) (arg2@@11 T@T) ) (! (= (MapType2TypeInv2 (MapType2Type arg0@@125 arg1@@57 arg2@@11)) arg2@@11)
 :qid |typeInv:MapType2TypeInv2|
 :pattern ( (MapType2Type arg0@@125 arg1@@57 arg2@@11))
))) (forall ((arg0@@126 T@U) (arg1@@58 T@U) (arg2@@12 T@U) ) (! (let ((aVar2 (MapType2TypeInv2 (type arg0@@126))))
(= (type (MapType2Select arg0@@126 arg1@@58 arg2@@12)) aVar2))
 :qid |funType:MapType2Select|
 :pattern ( (MapType2Select arg0@@126 arg1@@58 arg2@@12))
))) (forall ((arg0@@127 T@U) (arg1@@59 T@U) (arg2@@13 T@U) (arg3@@1 T@U) ) (! (let ((aVar2@@0 (type arg3@@1)))
(let ((aVar1@@2 (type arg2@@13)))
(let ((aVar0@@0 (type arg1@@59)))
(= (type (MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1)) (MapType2Type aVar0@@0 aVar1@@2 aVar2@@0)))))
 :qid |funType:MapType2Store|
 :pattern ( (MapType2Store arg0@@127 arg1@@59 arg2@@13 arg3@@1))
))) (forall ((m@@45 T@U) (x0@@5 T@U) (x1 T@U) (val@@6 T@U) ) (! (let ((aVar2@@1 (MapType2TypeInv2 (type m@@45))))
 (=> (= (type val@@6) aVar2@@1) (= (MapType2Select (MapType2Store m@@45 x0@@5 x1 val@@6) x0@@5 x1) val@@6)))
 :qid |mapAx0:MapType2Select|
 :weight 0
))) (and (and (forall ((val@@7 T@U) (m@@46 T@U) (x0@@6 T@U) (x1@@0 T@U) (y0@@3 T@U) (y1 T@U) ) (!  (or (= x0@@6 y0@@3) (= (MapType2Select (MapType2Store m@@46 x0@@6 x1@@0 val@@7) y0@@3 y1) (MapType2Select m@@46 y0@@3 y1)))
 :qid |mapAx1:MapType2Select:0|
 :weight 0
)) (forall ((val@@8 T@U) (m@@47 T@U) (x0@@7 T@U) (x1@@1 T@U) (y0@@4 T@U) (y1@@0 T@U) ) (!  (or (= x1@@1 y1@@0) (= (MapType2Select (MapType2Store m@@47 x0@@7 x1@@1 val@@8) y0@@4 y1@@0) (MapType2Select m@@47 y0@@4 y1@@0)))
 :qid |mapAx1:MapType2Select:1|
 :weight 0
))) (forall ((val@@9 T@U) (m@@48 T@U) (x0@@8 T@U) (x1@@2 T@U) (y0@@5 T@U) (y1@@1 T@U) ) (!  (or true (= (MapType2Select (MapType2Store m@@48 x0@@8 x1@@2 val@@9) y0@@5 y1@@1) (MapType2Select m@@48 y0@@5 y1@@1)))
 :qid |mapAx2:MapType2Select|
 :weight 0
)))) (forall ((arg0@@128 T@U) (arg1@@60 T@U) (arg2@@14 T@U) ) (! (= (type (Handle1 arg0@@128 arg1@@60 arg2@@14)) HandleTypeType)
 :qid |funType:Handle1|
 :pattern ( (Handle1 arg0@@128 arg1@@60 arg2@@14))
))))
(assert (forall ((t0@@16 T@U) (t1@@7 T@U) (heap@@1 T@U) (h@@21 T@U) (r@@6 T@U) (rd T@U) (bx0 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@16) TyType) (= (type t1@@7) TyType)) (= (type heap@@1) (MapType0Type refType MapType1Type))) (= (type h@@21) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@6) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0) BoxType)) (= (Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0) (MapType2Select h@@21 heap@@1 bx0)))
 :qid |unknown.0:0|
 :skolemid |721|
 :pattern ( (Apply1 t0@@16 t1@@7 heap@@1 (Handle1 h@@21 r@@6 rd) bx0))
)))
(assert (forall ((t0@@17 T@U) (t1@@8 T@U) (heap@@2 T@U) (h@@22 T@U) (r@@7 T@U) (rd@@0 T@U) (bx0@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@17) TyType) (= (type t1@@8) TyType)) (= (type heap@@2) (MapType0Type refType MapType1Type))) (= (type h@@22) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@7) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd@@0) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@0) BoxType)) (U_2_bool (MapType2Select r@@7 heap@@2 bx0@@0))) (Requires1 t0@@17 t1@@8 heap@@2 (Handle1 h@@22 r@@7 rd@@0) bx0@@0))
 :qid |unknown.0:0|
 :skolemid |722|
 :pattern ( (Requires1 t0@@17 t1@@8 heap@@2 (Handle1 h@@22 r@@7 rd@@0) bx0@@0))
)))
(assert (forall ((arg0@@129 T@U) (arg1@@61 T@U) (arg2@@15 T@U) (arg3@@2 T@U) (arg4@@0 T@U) ) (! (= (type (Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads1|
 :pattern ( (Reads1 arg0@@129 arg1@@61 arg2@@15 arg3@@2 arg4@@0))
)))
(assert (forall ((t0@@18 T@U) (t1@@9 T@U) (heap@@3 T@U) (h@@23 T@U) (r@@8 T@U) (rd@@1 T@U) (bx0@@1 T@U) (bx@@32 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@18) TyType) (= (type t1@@9) TyType)) (= (type heap@@3) (MapType0Type refType MapType1Type))) (= (type h@@23) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))) (= (type r@@8) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))) (= (type rd@@1) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@1) BoxType)) (= (type bx@@32) BoxType)) (= (U_2_bool (MapType0Select (Reads1 t0@@18 t1@@9 heap@@3 (Handle1 h@@23 r@@8 rd@@1) bx0@@1) bx@@32)) (U_2_bool (MapType0Select (MapType2Select rd@@1 heap@@3 bx0@@1) bx@@32))))
 :qid |unknown.0:0|
 :skolemid |723|
 :pattern ( (MapType0Select (Reads1 t0@@18 t1@@9 heap@@3 (Handle1 h@@23 r@@8 rd@@1) bx0@@1) bx@@32))
)))
(assert (forall ((t0@@19 T@U) (t1@@10 T@U) (h0@@0 T@U) (h1@@0 T@U) (f@@5 T@U) (bx0@@2 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@19) TyType) (= (type t1@@10) TyType)) (= (type h0@@0) (MapType0Type refType MapType1Type))) (= (type h1@@0) (MapType0Type refType MapType1Type))) (= (type f@@5) HandleTypeType)) (= (type bx0@@2) BoxType)) (and (and (and ($HeapSucc h0@@0 h1@@0) (and ($IsGoodHeap h0@@0) ($IsGoodHeap h1@@0))) (and ($IsBox bx0@@2 t0@@19) ($Is f@@5 (Tclass._System.___hFunc1 t0@@19 t1@@10)))) (forall ((o@@44 T@U) (fld T@U) ) (! (let ((a@@82 (FieldTypeInv0 (type fld))))
 (=> (and (and (= (type o@@44) refType) (= (type fld) (FieldType a@@82))) (and (not (= o@@44 null)) (U_2_bool (MapType0Select (Reads1 t0@@19 t1@@10 h0@@0 f@@5 bx0@@2) ($Box o@@44))))) (= (MapType1Select (MapType0Select h0@@0 o@@44) fld) (MapType1Select (MapType0Select h1@@0 o@@44) fld))))
 :qid |unknown.0:0|
 :skolemid |724|
 :no-pattern (type o@@44)
 :no-pattern (type fld)
 :no-pattern (U_2_int o@@44)
 :no-pattern (U_2_bool o@@44)
 :no-pattern (U_2_int fld)
 :no-pattern (U_2_bool fld)
)))) (= (Reads1 t0@@19 t1@@10 h0@@0 f@@5 bx0@@2) (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2)))
 :qid |unknown.0:0|
 :skolemid |725|
 :pattern ( ($HeapSucc h0@@0 h1@@0) (Reads1 t0@@19 t1@@10 h1@@0 f@@5 bx0@@2))
)))
(assert (forall ((t0@@20 T@U) (t1@@11 T@U) (h0@@1 T@U) (h1@@1 T@U) (f@@6 T@U) (bx0@@3 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@20) TyType) (= (type t1@@11) TyType)) (= (type h0@@1) (MapType0Type refType MapType1Type))) (= (type h1@@1) (MapType0Type refType MapType1Type))) (= (type f@@6) HandleTypeType)) (= (type bx0@@3) BoxType)) (and (and (and ($HeapSucc h0@@1 h1@@1) (and ($IsGoodHeap h0@@1) ($IsGoodHeap h1@@1))) (and ($IsBox bx0@@3 t0@@20) ($Is f@@6 (Tclass._System.___hFunc1 t0@@20 t1@@11)))) (forall ((o@@45 T@U) (fld@@0 T@U) ) (! (let ((a@@83 (FieldTypeInv0 (type fld@@0))))
 (=> (and (and (= (type o@@45) refType) (= (type fld@@0) (FieldType a@@83))) (and (not (= o@@45 null)) (U_2_bool (MapType0Select (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3) ($Box o@@45))))) (= (MapType1Select (MapType0Select h0@@1 o@@45) fld@@0) (MapType1Select (MapType0Select h1@@1 o@@45) fld@@0))))
 :qid |unknown.0:0|
 :skolemid |726|
 :no-pattern (type o@@45)
 :no-pattern (type fld@@0)
 :no-pattern (U_2_int o@@45)
 :no-pattern (U_2_bool o@@45)
 :no-pattern (U_2_int fld@@0)
 :no-pattern (U_2_bool fld@@0)
)))) (= (Reads1 t0@@20 t1@@11 h0@@1 f@@6 bx0@@3) (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3)))
 :qid |unknown.0:0|
 :skolemid |727|
 :pattern ( ($HeapSucc h0@@1 h1@@1) (Reads1 t0@@20 t1@@11 h1@@1 f@@6 bx0@@3))
)))
(assert (forall ((t0@@21 T@U) (t1@@12 T@U) (h0@@2 T@U) (h1@@2 T@U) (f@@7 T@U) (bx0@@4 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@21) TyType) (= (type t1@@12) TyType)) (= (type h0@@2) (MapType0Type refType MapType1Type))) (= (type h1@@2) (MapType0Type refType MapType1Type))) (= (type f@@7) HandleTypeType)) (= (type bx0@@4) BoxType)) (and (and (and ($HeapSucc h0@@2 h1@@2) (and ($IsGoodHeap h0@@2) ($IsGoodHeap h1@@2))) (and ($IsBox bx0@@4 t0@@21) ($Is f@@7 (Tclass._System.___hFunc1 t0@@21 t1@@12)))) (forall ((o@@46 T@U) (fld@@1 T@U) ) (! (let ((a@@84 (FieldTypeInv0 (type fld@@1))))
 (=> (and (and (= (type o@@46) refType) (= (type fld@@1) (FieldType a@@84))) (and (not (= o@@46 null)) (U_2_bool (MapType0Select (Reads1 t0@@21 t1@@12 h0@@2 f@@7 bx0@@4) ($Box o@@46))))) (= (MapType1Select (MapType0Select h0@@2 o@@46) fld@@1) (MapType1Select (MapType0Select h1@@2 o@@46) fld@@1))))
 :qid |unknown.0:0|
 :skolemid |728|
 :no-pattern (type o@@46)
 :no-pattern (type fld@@1)
 :no-pattern (U_2_int o@@46)
 :no-pattern (U_2_bool o@@46)
 :no-pattern (U_2_int fld@@1)
 :no-pattern (U_2_bool fld@@1)
)))) (= (Requires1 t0@@21 t1@@12 h0@@2 f@@7 bx0@@4) (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4)))
 :qid |unknown.0:0|
 :skolemid |729|
 :pattern ( ($HeapSucc h0@@2 h1@@2) (Requires1 t0@@21 t1@@12 h1@@2 f@@7 bx0@@4))
)))
(assert (forall ((t0@@22 T@U) (t1@@13 T@U) (h0@@3 T@U) (h1@@3 T@U) (f@@8 T@U) (bx0@@5 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@22) TyType) (= (type t1@@13) TyType)) (= (type h0@@3) (MapType0Type refType MapType1Type))) (= (type h1@@3) (MapType0Type refType MapType1Type))) (= (type f@@8) HandleTypeType)) (= (type bx0@@5) BoxType)) (and (and (and ($HeapSucc h0@@3 h1@@3) (and ($IsGoodHeap h0@@3) ($IsGoodHeap h1@@3))) (and ($IsBox bx0@@5 t0@@22) ($Is f@@8 (Tclass._System.___hFunc1 t0@@22 t1@@13)))) (forall ((o@@47 T@U) (fld@@2 T@U) ) (! (let ((a@@85 (FieldTypeInv0 (type fld@@2))))
 (=> (and (and (= (type o@@47) refType) (= (type fld@@2) (FieldType a@@85))) (and (not (= o@@47 null)) (U_2_bool (MapType0Select (Reads1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5) ($Box o@@47))))) (= (MapType1Select (MapType0Select h0@@3 o@@47) fld@@2) (MapType1Select (MapType0Select h1@@3 o@@47) fld@@2))))
 :qid |unknown.0:0|
 :skolemid |730|
 :no-pattern (type o@@47)
 :no-pattern (type fld@@2)
 :no-pattern (U_2_int o@@47)
 :no-pattern (U_2_bool o@@47)
 :no-pattern (U_2_int fld@@2)
 :no-pattern (U_2_bool fld@@2)
)))) (= (Requires1 t0@@22 t1@@13 h0@@3 f@@8 bx0@@5) (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5)))
 :qid |unknown.0:0|
 :skolemid |731|
 :pattern ( ($HeapSucc h0@@3 h1@@3) (Requires1 t0@@22 t1@@13 h1@@3 f@@8 bx0@@5))
)))
(assert (forall ((t0@@23 T@U) (t1@@14 T@U) (h0@@4 T@U) (h1@@4 T@U) (f@@9 T@U) (bx0@@6 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@23) TyType) (= (type t1@@14) TyType)) (= (type h0@@4) (MapType0Type refType MapType1Type))) (= (type h1@@4) (MapType0Type refType MapType1Type))) (= (type f@@9) HandleTypeType)) (= (type bx0@@6) BoxType)) (and (and (and ($HeapSucc h0@@4 h1@@4) (and ($IsGoodHeap h0@@4) ($IsGoodHeap h1@@4))) (and ($IsBox bx0@@6 t0@@23) ($Is f@@9 (Tclass._System.___hFunc1 t0@@23 t1@@14)))) (forall ((o@@48 T@U) (fld@@3 T@U) ) (! (let ((a@@86 (FieldTypeInv0 (type fld@@3))))
 (=> (and (and (= (type o@@48) refType) (= (type fld@@3) (FieldType a@@86))) (and (not (= o@@48 null)) (U_2_bool (MapType0Select (Reads1 t0@@23 t1@@14 h0@@4 f@@9 bx0@@6) ($Box o@@48))))) (= (MapType1Select (MapType0Select h0@@4 o@@48) fld@@3) (MapType1Select (MapType0Select h1@@4 o@@48) fld@@3))))
 :qid |unknown.0:0|
 :skolemid |732|
 :no-pattern (type o@@48)
 :no-pattern (type fld@@3)
 :no-pattern (U_2_int o@@48)
 :no-pattern (U_2_bool o@@48)
 :no-pattern (U_2_int fld@@3)
 :no-pattern (U_2_bool fld@@3)
)))) (= (Apply1 t0@@23 t1@@14 h0@@4 f@@9 bx0@@6) (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6)))
 :qid |unknown.0:0|
 :skolemid |733|
 :pattern ( ($HeapSucc h0@@4 h1@@4) (Apply1 t0@@23 t1@@14 h1@@4 f@@9 bx0@@6))
)))
(assert (forall ((t0@@24 T@U) (t1@@15 T@U) (h0@@5 T@U) (h1@@5 T@U) (f@@10 T@U) (bx0@@7 T@U) ) (!  (=> (and (and (and (and (and (and (= (type t0@@24) TyType) (= (type t1@@15) TyType)) (= (type h0@@5) (MapType0Type refType MapType1Type))) (= (type h1@@5) (MapType0Type refType MapType1Type))) (= (type f@@10) HandleTypeType)) (= (type bx0@@7) BoxType)) (and (and (and ($HeapSucc h0@@5 h1@@5) (and ($IsGoodHeap h0@@5) ($IsGoodHeap h1@@5))) (and ($IsBox bx0@@7 t0@@24) ($Is f@@10 (Tclass._System.___hFunc1 t0@@24 t1@@15)))) (forall ((o@@49 T@U) (fld@@4 T@U) ) (! (let ((a@@87 (FieldTypeInv0 (type fld@@4))))
 (=> (and (and (= (type o@@49) refType) (= (type fld@@4) (FieldType a@@87))) (and (not (= o@@49 null)) (U_2_bool (MapType0Select (Reads1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7) ($Box o@@49))))) (= (MapType1Select (MapType0Select h0@@5 o@@49) fld@@4) (MapType1Select (MapType0Select h1@@5 o@@49) fld@@4))))
 :qid |unknown.0:0|
 :skolemid |734|
 :no-pattern (type o@@49)
 :no-pattern (type fld@@4)
 :no-pattern (U_2_int o@@49)
 :no-pattern (U_2_bool o@@49)
 :no-pattern (U_2_int fld@@4)
 :no-pattern (U_2_bool fld@@4)
)))) (= (Apply1 t0@@24 t1@@15 h0@@5 f@@10 bx0@@7) (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7)))
 :qid |unknown.0:0|
 :skolemid |735|
 :pattern ( ($HeapSucc h0@@5 h1@@5) (Apply1 t0@@24 t1@@15 h1@@5 f@@10 bx0@@7))
)))
(assert (forall ((t0@@25 T@U) (t1@@16 T@U) (heap@@4 T@U) (f@@11 T@U) (bx0@@8 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@25) TyType) (= (type t1@@16) TyType)) (= (type heap@@4) (MapType0Type refType MapType1Type))) (= (type f@@11) HandleTypeType)) (= (type bx0@@8) BoxType)) (and ($IsGoodHeap heap@@4) (and ($IsBox bx0@@8 t0@@25) ($Is f@@11 (Tclass._System.___hFunc1 t0@@25 t1@@16))))) (= (|Set#Equal| (Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |736|
 :pattern ( (Reads1 t0@@25 t1@@16 $OneHeap f@@11 bx0@@8) ($IsGoodHeap heap@@4))
 :pattern ( (Reads1 t0@@25 t1@@16 heap@@4 f@@11 bx0@@8))
)))
(assert (forall ((t0@@26 T@U) (t1@@17 T@U) (heap@@5 T@U) (f@@12 T@U) (bx0@@9 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@26) TyType) (= (type t1@@17) TyType)) (= (type heap@@5) (MapType0Type refType MapType1Type))) (= (type f@@12) HandleTypeType)) (= (type bx0@@9) BoxType)) (and (and ($IsGoodHeap heap@@5) (and ($IsBox bx0@@9 t0@@26) ($Is f@@12 (Tclass._System.___hFunc1 t0@@26 t1@@17)))) (|Set#Equal| (Reads1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) (|Set#Empty| BoxType)))) (= (Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) (Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9)))
 :qid |unknown.0:0|
 :skolemid |737|
 :pattern ( (Requires1 t0@@26 t1@@17 $OneHeap f@@12 bx0@@9) ($IsGoodHeap heap@@5))
 :pattern ( (Requires1 t0@@26 t1@@17 heap@@5 f@@12 bx0@@9))
)))
(assert (forall ((f@@13 T@U) (t0@@27 T@U) (t1@@18 T@U) ) (!  (=> (and (and (= (type f@@13) HandleTypeType) (= (type t0@@27) TyType)) (= (type t1@@18) TyType)) (= ($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)) (forall ((h@@24 T@U) (bx0@@10 T@U) ) (!  (=> (and (= (type h@@24) (MapType0Type refType MapType1Type)) (= (type bx0@@10) BoxType)) (=> (and (and ($IsGoodHeap h@@24) ($IsBox bx0@@10 t0@@27)) (Requires1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10)) ($IsBox (Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10) t1@@18)))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |738|
 :pattern ( (Apply1 t0@@27 t1@@18 h@@24 f@@13 bx0@@10))
))))
 :qid |unknown.0:0|
 :skolemid |739|
 :pattern ( ($Is f@@13 (Tclass._System.___hFunc1 t0@@27 t1@@18)))
)))
(assert (forall ((f@@14 T@U) (t0@@28 T@U) (t1@@19 T@U) (u0 T@U) (u1 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@14) HandleTypeType) (= (type t0@@28) TyType)) (= (type t1@@19) TyType)) (= (type u0) TyType)) (= (type u1) TyType)) (and (and ($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19)) (forall ((bx@@33 T@U) ) (!  (=> (and (= (type bx@@33) BoxType) ($IsBox bx@@33 u0)) ($IsBox bx@@33 t0@@28))
 :qid |unknown.0:0|
 :skolemid |740|
 :pattern ( ($IsBox bx@@33 u0))
 :pattern ( ($IsBox bx@@33 t0@@28))
))) (forall ((bx@@34 T@U) ) (!  (=> (and (= (type bx@@34) BoxType) ($IsBox bx@@34 t1@@19)) ($IsBox bx@@34 u1))
 :qid |unknown.0:0|
 :skolemid |741|
 :pattern ( ($IsBox bx@@34 t1@@19))
 :pattern ( ($IsBox bx@@34 u1))
)))) ($Is f@@14 (Tclass._System.___hFunc1 u0 u1)))
 :qid |unknown.0:0|
 :skolemid |742|
 :pattern ( ($Is f@@14 (Tclass._System.___hFunc1 t0@@28 t1@@19)) ($Is f@@14 (Tclass._System.___hFunc1 u0 u1)))
)))
(assert (forall ((f@@15 T@U) (t0@@29 T@U) (t1@@20 T@U) (h@@25 T@U) ) (!  (=> (and (and (and (and (= (type f@@15) HandleTypeType) (= (type t0@@29) TyType)) (= (type t1@@20) TyType)) (= (type h@@25) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@25)) (= ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25) (forall ((bx0@@11 T@U) ) (!  (=> (= (type bx0@@11) BoxType) (=> (and (and ($IsBox bx0@@11 t0@@29) ($IsAllocBox bx0@@11 t0@@29 h@@25)) (Requires1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11)) (forall ((r@@9 T@U) ) (!  (=> (= (type r@@9) refType) (=> (and (not (= r@@9 null)) (U_2_bool (MapType0Select (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11) ($Box r@@9)))) (U_2_bool (MapType1Select (MapType0Select h@@25 r@@9) alloc))))
 :qid |unknown.0:0|
 :skolemid |743|
 :pattern ( (MapType0Select (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11) ($Box r@@9)))
))))
 :qid |unknown.0:0|
 :skolemid |744|
 :pattern ( (Apply1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
 :pattern ( (Reads1 t0@@29 t1@@20 h@@25 f@@15 bx0@@11))
))))
 :qid |unknown.0:0|
 :skolemid |745|
 :pattern ( ($IsAlloc f@@15 (Tclass._System.___hFunc1 t0@@29 t1@@20) h@@25))
)))
(assert (forall ((f@@16 T@U) (t0@@30 T@U) (t1@@21 T@U) (h@@26 T@U) ) (!  (=> (and (and (and (and (= (type f@@16) HandleTypeType) (= (type t0@@30) TyType)) (= (type t1@@21) TyType)) (= (type h@@26) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@26) ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))) (forall ((bx0@@12 T@U) ) (!  (=> (= (type bx0@@12) BoxType) (=> (and ($IsAllocBox bx0@@12 t0@@30 h@@26) (Requires1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12)) ($IsAllocBox (Apply1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12) t1@@21 h@@26)))
 :qid |unknown.0:0|
 :skolemid |746|
 :pattern ( (Apply1 t0@@30 t1@@21 h@@26 f@@16 bx0@@12))
)))
 :qid |unknown.0:0|
 :skolemid |747|
 :pattern ( ($IsAlloc f@@16 (Tclass._System.___hFunc1 t0@@30 t1@@21) h@@26))
)))
(assert (forall ((arg0@@130 T@U) (arg1@@62 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1|
 :pattern ( (Tclass._System.___hPartialFunc1 arg0@@130 arg1@@62))
)))
(assert (forall ((|#$T0@@3| T@U) (|#$R@@3| T@U) ) (!  (=> (and (= (type |#$T0@@3|) TyType) (= (type |#$R@@3|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|)) Tagclass._System.___hPartialFunc1) (= (TagFamily (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|)) |tytagFamily$_#PartialFunc1|)))
 :qid |unknown.0:0|
 :skolemid |748|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@3| |#$R@@3|))
)))
(assert (forall ((arg0@@131 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1_0 arg0@@131)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1_0|
 :pattern ( (Tclass._System.___hPartialFunc1_0 arg0@@131))
)))
(assert (forall ((|#$T0@@4| T@U) (|#$R@@4| T@U) ) (!  (=> (and (= (type |#$T0@@4|) TyType) (= (type |#$R@@4|) TyType)) (= (Tclass._System.___hPartialFunc1_0 (Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|)) |#$T0@@4|))
 :qid |unknown.0:0|
 :skolemid |749|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@4| |#$R@@4|))
)))
(assert (forall ((arg0@@132 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1_1 arg0@@132)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1_1|
 :pattern ( (Tclass._System.___hPartialFunc1_1 arg0@@132))
)))
(assert (forall ((|#$T0@@5| T@U) (|#$R@@5| T@U) ) (!  (=> (and (= (type |#$T0@@5|) TyType) (= (type |#$R@@5|) TyType)) (= (Tclass._System.___hPartialFunc1_1 (Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|)) |#$R@@5|))
 :qid |unknown.0:0|
 :skolemid |750|
 :pattern ( (Tclass._System.___hPartialFunc1 |#$T0@@5| |#$R@@5|))
)))
(assert (forall ((|#$T0@@6| T@U) (|#$R@@6| T@U) (bx@@35 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@6|) TyType) (= (type |#$R@@6|) TyType)) (= (type bx@@35) BoxType)) ($IsBox bx@@35 (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|))) (and (= ($Box ($Unbox HandleTypeType bx@@35)) bx@@35) ($Is ($Unbox HandleTypeType bx@@35) (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|))))
 :qid |unknown.0:0|
 :skolemid |751|
 :pattern ( ($IsBox bx@@35 (Tclass._System.___hPartialFunc1 |#$T0@@6| |#$R@@6|)))
)))
(assert (forall ((|#$T0@@7| T@U) (|#$R@@7| T@U) (|f#0| T@U) ) (!  (=> (and (and (= (type |#$T0@@7|) TyType) (= (type |#$R@@7|) TyType)) (= (type |f#0|) HandleTypeType)) (= ($Is |f#0| (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|))  (and ($Is |f#0| (Tclass._System.___hFunc1 |#$T0@@7| |#$R@@7|)) (forall ((|x0#0| T@U) ) (!  (=> (and (= (type |x0#0|) BoxType) ($IsBox |x0#0| |#$T0@@7|)) (|Set#Equal| (Reads1 |#$T0@@7| |#$R@@7| $OneHeap |f#0| |x0#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |752|
 :no-pattern (type |x0#0|)
 :no-pattern (U_2_int |x0#0|)
 :no-pattern (U_2_bool |x0#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |753|
 :pattern ( ($Is |f#0| (Tclass._System.___hPartialFunc1 |#$T0@@7| |#$R@@7|)))
)))
(assert (forall ((|#$T0@@8| T@U) (|#$R@@8| T@U) (|f#0@@0| T@U) ($h@@7 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@8|) TyType) (= (type |#$R@@8|) TyType)) (= (type |f#0@@0|) HandleTypeType)) (= (type $h@@7) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@0| (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|) $h@@7) ($IsAlloc |f#0@@0| (Tclass._System.___hFunc1 |#$T0@@8| |#$R@@8|) $h@@7)))
 :qid |unknown.0:0|
 :skolemid |754|
 :pattern ( ($IsAlloc |f#0@@0| (Tclass._System.___hPartialFunc1 |#$T0@@8| |#$R@@8|) $h@@7))
)))
(assert (forall ((arg0@@133 T@U) (arg1@@63 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1|
 :pattern ( (Tclass._System.___hTotalFunc1 arg0@@133 arg1@@63))
)))
(assert (forall ((|#$T0@@9| T@U) (|#$R@@9| T@U) ) (!  (=> (and (= (type |#$T0@@9|) TyType) (= (type |#$R@@9|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|)) Tagclass._System.___hTotalFunc1) (= (TagFamily (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|)) |tytagFamily$_#TotalFunc1|)))
 :qid |unknown.0:0|
 :skolemid |755|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@9| |#$R@@9|))
)))
(assert (forall ((arg0@@134 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1_0 arg0@@134)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1_0|
 :pattern ( (Tclass._System.___hTotalFunc1_0 arg0@@134))
)))
(assert (forall ((|#$T0@@10| T@U) (|#$R@@10| T@U) ) (!  (=> (and (= (type |#$T0@@10|) TyType) (= (type |#$R@@10|) TyType)) (= (Tclass._System.___hTotalFunc1_0 (Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|)) |#$T0@@10|))
 :qid |unknown.0:0|
 :skolemid |756|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@10| |#$R@@10|))
)))
(assert (forall ((arg0@@135 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1_1 arg0@@135)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1_1|
 :pattern ( (Tclass._System.___hTotalFunc1_1 arg0@@135))
)))
(assert (forall ((|#$T0@@11| T@U) (|#$R@@11| T@U) ) (!  (=> (and (= (type |#$T0@@11|) TyType) (= (type |#$R@@11|) TyType)) (= (Tclass._System.___hTotalFunc1_1 (Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|)) |#$R@@11|))
 :qid |unknown.0:0|
 :skolemid |757|
 :pattern ( (Tclass._System.___hTotalFunc1 |#$T0@@11| |#$R@@11|))
)))
(assert (forall ((|#$T0@@12| T@U) (|#$R@@12| T@U) (bx@@36 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@12|) TyType) (= (type |#$R@@12|) TyType)) (= (type bx@@36) BoxType)) ($IsBox bx@@36 (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|))) (and (= ($Box ($Unbox HandleTypeType bx@@36)) bx@@36) ($Is ($Unbox HandleTypeType bx@@36) (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|))))
 :qid |unknown.0:0|
 :skolemid |758|
 :pattern ( ($IsBox bx@@36 (Tclass._System.___hTotalFunc1 |#$T0@@12| |#$R@@12|)))
)))
(assert (forall ((|#$T0@@13| T@U) (|#$R@@13| T@U) (|f#0@@1| T@U) ) (!  (=> (and (and (= (type |#$T0@@13|) TyType) (= (type |#$R@@13|) TyType)) (= (type |f#0@@1|) HandleTypeType)) (= ($Is |f#0@@1| (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|))  (and ($Is |f#0@@1| (Tclass._System.___hPartialFunc1 |#$T0@@13| |#$R@@13|)) (forall ((|x0#0@@0| T@U) ) (!  (=> (and (= (type |x0#0@@0|) BoxType) ($IsBox |x0#0@@0| |#$T0@@13|)) (Requires1 |#$T0@@13| |#$R@@13| $OneHeap |f#0@@1| |x0#0@@0|))
 :qid |unknown.0:0|
 :skolemid |759|
 :no-pattern (type |x0#0@@0|)
 :no-pattern (U_2_int |x0#0@@0|)
 :no-pattern (U_2_bool |x0#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |760|
 :pattern ( ($Is |f#0@@1| (Tclass._System.___hTotalFunc1 |#$T0@@13| |#$R@@13|)))
)))
(assert (forall ((|#$T0@@14| T@U) (|#$R@@14| T@U) (|f#0@@2| T@U) ($h@@8 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@14|) TyType) (= (type |#$R@@14|) TyType)) (= (type |f#0@@2|) HandleTypeType)) (= (type $h@@8) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@2| (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|) $h@@8) ($IsAlloc |f#0@@2| (Tclass._System.___hPartialFunc1 |#$T0@@14| |#$R@@14|) $h@@8)))
 :qid |unknown.0:0|
 :skolemid |761|
 :pattern ( ($IsAlloc |f#0@@2| (Tclass._System.___hTotalFunc1 |#$T0@@14| |#$R@@14|) $h@@8))
)))
(assert (forall ((arg0@@136 T@U) ) (! (= (type (Tclass._System.___hFunc0 arg0@@136)) TyType)
 :qid |funType:Tclass._System.___hFunc0|
 :pattern ( (Tclass._System.___hFunc0 arg0@@136))
)))
(assert (forall ((|#$R@@15| T@U) ) (!  (=> (= (type |#$R@@15|) TyType) (and (= (Tag (Tclass._System.___hFunc0 |#$R@@15|)) Tagclass._System.___hFunc0) (= (TagFamily (Tclass._System.___hFunc0 |#$R@@15|)) |tytagFamily$_#Func0|)))
 :qid |unknown.0:0|
 :skolemid |762|
 :pattern ( (Tclass._System.___hFunc0 |#$R@@15|))
)))
(assert (forall ((arg0@@137 T@U) ) (! (= (type (Tclass._System.___hFunc0_0 arg0@@137)) TyType)
 :qid |funType:Tclass._System.___hFunc0_0|
 :pattern ( (Tclass._System.___hFunc0_0 arg0@@137))
)))
(assert (forall ((|#$R@@16| T@U) ) (!  (=> (= (type |#$R@@16|) TyType) (= (Tclass._System.___hFunc0_0 (Tclass._System.___hFunc0 |#$R@@16|)) |#$R@@16|))
 :qid |unknown.0:0|
 :skolemid |763|
 :pattern ( (Tclass._System.___hFunc0 |#$R@@16|))
)))
(assert (forall ((|#$R@@17| T@U) (bx@@37 T@U) ) (!  (=> (and (and (= (type |#$R@@17|) TyType) (= (type bx@@37) BoxType)) ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|))) (and (= ($Box ($Unbox HandleTypeType bx@@37)) bx@@37) ($Is ($Unbox HandleTypeType bx@@37) (Tclass._System.___hFunc0 |#$R@@17|))))
 :qid |unknown.0:0|
 :skolemid |764|
 :pattern ( ($IsBox bx@@37 (Tclass._System.___hFunc0 |#$R@@17|)))
)))
(assert  (and (forall ((arg0@@138 T@U) (arg1@@64 T@U) (arg2@@16 T@U) ) (! (= (type (Apply0 arg0@@138 arg1@@64 arg2@@16)) BoxType)
 :qid |funType:Apply0|
 :pattern ( (Apply0 arg0@@138 arg1@@64 arg2@@16))
)) (forall ((arg0@@139 T@U) (arg1@@65 T@U) (arg2@@17 T@U) ) (! (= (type (Handle0 arg0@@139 arg1@@65 arg2@@17)) HandleTypeType)
 :qid |funType:Handle0|
 :pattern ( (Handle0 arg0@@139 arg1@@65 arg2@@17))
))))
(assert (forall ((t0@@31 T@U) (heap@@6 T@U) (h@@27 T@U) (r@@10 T@U) (rd@@2 T@U) ) (!  (=> (and (and (and (and (= (type t0@@31) TyType) (= (type heap@@6) (MapType0Type refType MapType1Type))) (= (type h@@27) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@10) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@2) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (= (Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2)) (MapType0Select h@@27 heap@@6)))
 :qid |unknown.0:0|
 :skolemid |765|
 :pattern ( (Apply0 t0@@31 heap@@6 (Handle0 h@@27 r@@10 rd@@2)))
)))
(assert (forall ((t0@@32 T@U) (heap@@7 T@U) (h@@28 T@U) (r@@11 T@U) (rd@@3 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@32) TyType) (= (type heap@@7) (MapType0Type refType MapType1Type))) (= (type h@@28) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@11) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@3) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (U_2_bool (MapType0Select r@@11 heap@@7))) (Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3)))
 :qid |unknown.0:0|
 :skolemid |766|
 :pattern ( (Requires0 t0@@32 heap@@7 (Handle0 h@@28 r@@11 rd@@3)))
)))
(assert (forall ((arg0@@140 T@U) (arg1@@66 T@U) (arg2@@18 T@U) ) (! (= (type (Reads0 arg0@@140 arg1@@66 arg2@@18)) (MapType0Type BoxType boolType))
 :qid |funType:Reads0|
 :pattern ( (Reads0 arg0@@140 arg1@@66 arg2@@18))
)))
(assert (forall ((t0@@33 T@U) (heap@@8 T@U) (h@@29 T@U) (r@@12 T@U) (rd@@4 T@U) (bx@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type t0@@33) TyType) (= (type heap@@8) (MapType0Type refType MapType1Type))) (= (type h@@29) (MapType0Type (MapType0Type refType MapType1Type) BoxType))) (= (type r@@12) (MapType0Type (MapType0Type refType MapType1Type) boolType))) (= (type rd@@4) (MapType0Type (MapType0Type refType MapType1Type) (MapType0Type BoxType boolType)))) (= (type bx@@38) BoxType)) (= (U_2_bool (MapType0Select (Reads0 t0@@33 heap@@8 (Handle0 h@@29 r@@12 rd@@4)) bx@@38)) (U_2_bool (MapType0Select (MapType0Select rd@@4 heap@@8) bx@@38))))
 :qid |unknown.0:0|
 :skolemid |767|
 :pattern ( (MapType0Select (Reads0 t0@@33 heap@@8 (Handle0 h@@29 r@@12 rd@@4)) bx@@38))
)))
(assert (forall ((t0@@34 T@U) (h0@@6 T@U) (h1@@6 T@U) (f@@17 T@U) ) (!  (=> (and (and (and (and (= (type t0@@34) TyType) (= (type h0@@6) (MapType0Type refType MapType1Type))) (= (type h1@@6) (MapType0Type refType MapType1Type))) (= (type f@@17) HandleTypeType)) (and (and (and ($HeapSucc h0@@6 h1@@6) (and ($IsGoodHeap h0@@6) ($IsGoodHeap h1@@6))) ($Is f@@17 (Tclass._System.___hFunc0 t0@@34))) (forall ((o@@50 T@U) (fld@@5 T@U) ) (! (let ((a@@88 (FieldTypeInv0 (type fld@@5))))
 (=> (and (and (= (type o@@50) refType) (= (type fld@@5) (FieldType a@@88))) (and (not (= o@@50 null)) (U_2_bool (MapType0Select (Reads0 t0@@34 h0@@6 f@@17) ($Box o@@50))))) (= (MapType1Select (MapType0Select h0@@6 o@@50) fld@@5) (MapType1Select (MapType0Select h1@@6 o@@50) fld@@5))))
 :qid |unknown.0:0|
 :skolemid |768|
 :no-pattern (type o@@50)
 :no-pattern (type fld@@5)
 :no-pattern (U_2_int o@@50)
 :no-pattern (U_2_bool o@@50)
 :no-pattern (U_2_int fld@@5)
 :no-pattern (U_2_bool fld@@5)
)))) (= (Reads0 t0@@34 h0@@6 f@@17) (Reads0 t0@@34 h1@@6 f@@17)))
 :qid |unknown.0:0|
 :skolemid |769|
 :pattern ( ($HeapSucc h0@@6 h1@@6) (Reads0 t0@@34 h1@@6 f@@17))
)))
(assert (forall ((t0@@35 T@U) (h0@@7 T@U) (h1@@7 T@U) (f@@18 T@U) ) (!  (=> (and (and (and (and (= (type t0@@35) TyType) (= (type h0@@7) (MapType0Type refType MapType1Type))) (= (type h1@@7) (MapType0Type refType MapType1Type))) (= (type f@@18) HandleTypeType)) (and (and (and ($HeapSucc h0@@7 h1@@7) (and ($IsGoodHeap h0@@7) ($IsGoodHeap h1@@7))) ($Is f@@18 (Tclass._System.___hFunc0 t0@@35))) (forall ((o@@51 T@U) (fld@@6 T@U) ) (! (let ((a@@89 (FieldTypeInv0 (type fld@@6))))
 (=> (and (and (= (type o@@51) refType) (= (type fld@@6) (FieldType a@@89))) (and (not (= o@@51 null)) (U_2_bool (MapType0Select (Reads0 t0@@35 h1@@7 f@@18) ($Box o@@51))))) (= (MapType1Select (MapType0Select h0@@7 o@@51) fld@@6) (MapType1Select (MapType0Select h1@@7 o@@51) fld@@6))))
 :qid |unknown.0:0|
 :skolemid |770|
 :no-pattern (type o@@51)
 :no-pattern (type fld@@6)
 :no-pattern (U_2_int o@@51)
 :no-pattern (U_2_bool o@@51)
 :no-pattern (U_2_int fld@@6)
 :no-pattern (U_2_bool fld@@6)
)))) (= (Reads0 t0@@35 h0@@7 f@@18) (Reads0 t0@@35 h1@@7 f@@18)))
 :qid |unknown.0:0|
 :skolemid |771|
 :pattern ( ($HeapSucc h0@@7 h1@@7) (Reads0 t0@@35 h1@@7 f@@18))
)))
(assert (forall ((t0@@36 T@U) (h0@@8 T@U) (h1@@8 T@U) (f@@19 T@U) ) (!  (=> (and (and (and (and (= (type t0@@36) TyType) (= (type h0@@8) (MapType0Type refType MapType1Type))) (= (type h1@@8) (MapType0Type refType MapType1Type))) (= (type f@@19) HandleTypeType)) (and (and (and ($HeapSucc h0@@8 h1@@8) (and ($IsGoodHeap h0@@8) ($IsGoodHeap h1@@8))) ($Is f@@19 (Tclass._System.___hFunc0 t0@@36))) (forall ((o@@52 T@U) (fld@@7 T@U) ) (! (let ((a@@90 (FieldTypeInv0 (type fld@@7))))
 (=> (and (and (= (type o@@52) refType) (= (type fld@@7) (FieldType a@@90))) (and (not (= o@@52 null)) (U_2_bool (MapType0Select (Reads0 t0@@36 h0@@8 f@@19) ($Box o@@52))))) (= (MapType1Select (MapType0Select h0@@8 o@@52) fld@@7) (MapType1Select (MapType0Select h1@@8 o@@52) fld@@7))))
 :qid |unknown.0:0|
 :skolemid |772|
 :no-pattern (type o@@52)
 :no-pattern (type fld@@7)
 :no-pattern (U_2_int o@@52)
 :no-pattern (U_2_bool o@@52)
 :no-pattern (U_2_int fld@@7)
 :no-pattern (U_2_bool fld@@7)
)))) (= (Requires0 t0@@36 h0@@8 f@@19) (Requires0 t0@@36 h1@@8 f@@19)))
 :qid |unknown.0:0|
 :skolemid |773|
 :pattern ( ($HeapSucc h0@@8 h1@@8) (Requires0 t0@@36 h1@@8 f@@19))
)))
(assert (forall ((t0@@37 T@U) (h0@@9 T@U) (h1@@9 T@U) (f@@20 T@U) ) (!  (=> (and (and (and (and (= (type t0@@37) TyType) (= (type h0@@9) (MapType0Type refType MapType1Type))) (= (type h1@@9) (MapType0Type refType MapType1Type))) (= (type f@@20) HandleTypeType)) (and (and (and ($HeapSucc h0@@9 h1@@9) (and ($IsGoodHeap h0@@9) ($IsGoodHeap h1@@9))) ($Is f@@20 (Tclass._System.___hFunc0 t0@@37))) (forall ((o@@53 T@U) (fld@@8 T@U) ) (! (let ((a@@91 (FieldTypeInv0 (type fld@@8))))
 (=> (and (and (= (type o@@53) refType) (= (type fld@@8) (FieldType a@@91))) (and (not (= o@@53 null)) (U_2_bool (MapType0Select (Reads0 t0@@37 h1@@9 f@@20) ($Box o@@53))))) (= (MapType1Select (MapType0Select h0@@9 o@@53) fld@@8) (MapType1Select (MapType0Select h1@@9 o@@53) fld@@8))))
 :qid |unknown.0:0|
 :skolemid |774|
 :no-pattern (type o@@53)
 :no-pattern (type fld@@8)
 :no-pattern (U_2_int o@@53)
 :no-pattern (U_2_bool o@@53)
 :no-pattern (U_2_int fld@@8)
 :no-pattern (U_2_bool fld@@8)
)))) (= (Requires0 t0@@37 h0@@9 f@@20) (Requires0 t0@@37 h1@@9 f@@20)))
 :qid |unknown.0:0|
 :skolemid |775|
 :pattern ( ($HeapSucc h0@@9 h1@@9) (Requires0 t0@@37 h1@@9 f@@20))
)))
(assert (forall ((t0@@38 T@U) (h0@@10 T@U) (h1@@10 T@U) (f@@21 T@U) ) (!  (=> (and (and (and (and (= (type t0@@38) TyType) (= (type h0@@10) (MapType0Type refType MapType1Type))) (= (type h1@@10) (MapType0Type refType MapType1Type))) (= (type f@@21) HandleTypeType)) (and (and (and ($HeapSucc h0@@10 h1@@10) (and ($IsGoodHeap h0@@10) ($IsGoodHeap h1@@10))) ($Is f@@21 (Tclass._System.___hFunc0 t0@@38))) (forall ((o@@54 T@U) (fld@@9 T@U) ) (! (let ((a@@92 (FieldTypeInv0 (type fld@@9))))
 (=> (and (and (= (type o@@54) refType) (= (type fld@@9) (FieldType a@@92))) (and (not (= o@@54 null)) (U_2_bool (MapType0Select (Reads0 t0@@38 h0@@10 f@@21) ($Box o@@54))))) (= (MapType1Select (MapType0Select h0@@10 o@@54) fld@@9) (MapType1Select (MapType0Select h1@@10 o@@54) fld@@9))))
 :qid |unknown.0:0|
 :skolemid |776|
 :no-pattern (type o@@54)
 :no-pattern (type fld@@9)
 :no-pattern (U_2_int o@@54)
 :no-pattern (U_2_bool o@@54)
 :no-pattern (U_2_int fld@@9)
 :no-pattern (U_2_bool fld@@9)
)))) (= (Apply0 t0@@38 h0@@10 f@@21) (Apply0 t0@@38 h1@@10 f@@21)))
 :qid |unknown.0:0|
 :skolemid |777|
 :pattern ( ($HeapSucc h0@@10 h1@@10) (Apply0 t0@@38 h1@@10 f@@21))
)))
(assert (forall ((t0@@39 T@U) (h0@@11 T@U) (h1@@11 T@U) (f@@22 T@U) ) (!  (=> (and (and (and (and (= (type t0@@39) TyType) (= (type h0@@11) (MapType0Type refType MapType1Type))) (= (type h1@@11) (MapType0Type refType MapType1Type))) (= (type f@@22) HandleTypeType)) (and (and (and ($HeapSucc h0@@11 h1@@11) (and ($IsGoodHeap h0@@11) ($IsGoodHeap h1@@11))) ($Is f@@22 (Tclass._System.___hFunc0 t0@@39))) (forall ((o@@55 T@U) (fld@@10 T@U) ) (! (let ((a@@93 (FieldTypeInv0 (type fld@@10))))
 (=> (and (and (= (type o@@55) refType) (= (type fld@@10) (FieldType a@@93))) (and (not (= o@@55 null)) (U_2_bool (MapType0Select (Reads0 t0@@39 h1@@11 f@@22) ($Box o@@55))))) (= (MapType1Select (MapType0Select h0@@11 o@@55) fld@@10) (MapType1Select (MapType0Select h1@@11 o@@55) fld@@10))))
 :qid |unknown.0:0|
 :skolemid |778|
 :no-pattern (type o@@55)
 :no-pattern (type fld@@10)
 :no-pattern (U_2_int o@@55)
 :no-pattern (U_2_bool o@@55)
 :no-pattern (U_2_int fld@@10)
 :no-pattern (U_2_bool fld@@10)
)))) (= (Apply0 t0@@39 h0@@11 f@@22) (Apply0 t0@@39 h1@@11 f@@22)))
 :qid |unknown.0:0|
 :skolemid |779|
 :pattern ( ($HeapSucc h0@@11 h1@@11) (Apply0 t0@@39 h1@@11 f@@22))
)))
(assert (forall ((t0@@40 T@U) (heap@@9 T@U) (f@@23 T@U) ) (!  (=> (and (and (and (= (type t0@@40) TyType) (= (type heap@@9) (MapType0Type refType MapType1Type))) (= (type f@@23) HandleTypeType)) (and ($IsGoodHeap heap@@9) ($Is f@@23 (Tclass._System.___hFunc0 t0@@40)))) (= (|Set#Equal| (Reads0 t0@@40 $OneHeap f@@23) (|Set#Empty| BoxType)) (|Set#Equal| (Reads0 t0@@40 heap@@9 f@@23) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |780|
 :pattern ( (Reads0 t0@@40 $OneHeap f@@23) ($IsGoodHeap heap@@9))
 :pattern ( (Reads0 t0@@40 heap@@9 f@@23))
)))
(assert (forall ((t0@@41 T@U) (heap@@10 T@U) (f@@24 T@U) ) (!  (=> (and (and (and (= (type t0@@41) TyType) (= (type heap@@10) (MapType0Type refType MapType1Type))) (= (type f@@24) HandleTypeType)) (and (and ($IsGoodHeap heap@@10) ($Is f@@24 (Tclass._System.___hFunc0 t0@@41))) (|Set#Equal| (Reads0 t0@@41 $OneHeap f@@24) (|Set#Empty| BoxType)))) (= (Requires0 t0@@41 $OneHeap f@@24) (Requires0 t0@@41 heap@@10 f@@24)))
 :qid |unknown.0:0|
 :skolemid |781|
 :pattern ( (Requires0 t0@@41 $OneHeap f@@24) ($IsGoodHeap heap@@10))
 :pattern ( (Requires0 t0@@41 heap@@10 f@@24))
)))
(assert (forall ((f@@25 T@U) (t0@@42 T@U) ) (!  (=> (and (= (type f@@25) HandleTypeType) (= (type t0@@42) TyType)) (= ($Is f@@25 (Tclass._System.___hFunc0 t0@@42)) (forall ((h@@30 T@U) ) (!  (=> (= (type h@@30) (MapType0Type refType MapType1Type)) (=> (and ($IsGoodHeap h@@30) (Requires0 t0@@42 h@@30 f@@25)) ($IsBox (Apply0 t0@@42 h@@30 f@@25) t0@@42)))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |782|
 :pattern ( (Apply0 t0@@42 h@@30 f@@25))
))))
 :qid |unknown.0:0|
 :skolemid |783|
 :pattern ( ($Is f@@25 (Tclass._System.___hFunc0 t0@@42)))
)))
(assert (forall ((f@@26 T@U) (t0@@43 T@U) (u0@@0 T@U) ) (!  (=> (and (and (and (= (type f@@26) HandleTypeType) (= (type t0@@43) TyType)) (= (type u0@@0) TyType)) (and ($Is f@@26 (Tclass._System.___hFunc0 t0@@43)) (forall ((bx@@39 T@U) ) (!  (=> (and (= (type bx@@39) BoxType) ($IsBox bx@@39 t0@@43)) ($IsBox bx@@39 u0@@0))
 :qid |unknown.0:0|
 :skolemid |784|
 :pattern ( ($IsBox bx@@39 t0@@43))
 :pattern ( ($IsBox bx@@39 u0@@0))
)))) ($Is f@@26 (Tclass._System.___hFunc0 u0@@0)))
 :qid |unknown.0:0|
 :skolemid |785|
 :pattern ( ($Is f@@26 (Tclass._System.___hFunc0 t0@@43)) ($Is f@@26 (Tclass._System.___hFunc0 u0@@0)))
)))
(assert (forall ((f@@27 T@U) (t0@@44 T@U) (h@@31 T@U) ) (!  (=> (and (and (and (= (type f@@27) HandleTypeType) (= (type t0@@44) TyType)) (= (type h@@31) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@31)) (= ($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31)  (=> (Requires0 t0@@44 h@@31 f@@27) (forall ((r@@13 T@U) ) (!  (=> (= (type r@@13) refType) (=> (and (not (= r@@13 null)) (U_2_bool (MapType0Select (Reads0 t0@@44 h@@31 f@@27) ($Box r@@13)))) (U_2_bool (MapType1Select (MapType0Select h@@31 r@@13) alloc))))
 :qid |unknown.0:0|
 :skolemid |786|
 :pattern ( (MapType0Select (Reads0 t0@@44 h@@31 f@@27) ($Box r@@13)))
)))))
 :qid |unknown.0:0|
 :skolemid |787|
 :pattern ( ($IsAlloc f@@27 (Tclass._System.___hFunc0 t0@@44) h@@31))
)))
(assert (forall ((f@@28 T@U) (t0@@45 T@U) (h@@32 T@U) ) (!  (=> (and (and (and (and (= (type f@@28) HandleTypeType) (= (type t0@@45) TyType)) (= (type h@@32) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@32) ($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32))) (Requires0 t0@@45 h@@32 f@@28)) ($IsAllocBox (Apply0 t0@@45 h@@32 f@@28) t0@@45 h@@32))
 :qid |unknown.0:0|
 :skolemid |788|
 :pattern ( ($IsAlloc f@@28 (Tclass._System.___hFunc0 t0@@45) h@@32))
)))
(assert (forall ((arg0@@141 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0 arg0@@141)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0|
 :pattern ( (Tclass._System.___hPartialFunc0 arg0@@141))
)))
(assert (forall ((|#$R@@18| T@U) ) (!  (=> (= (type |#$R@@18|) TyType) (and (= (Tag (Tclass._System.___hPartialFunc0 |#$R@@18|)) Tagclass._System.___hPartialFunc0) (= (TagFamily (Tclass._System.___hPartialFunc0 |#$R@@18|)) |tytagFamily$_#PartialFunc0|)))
 :qid |unknown.0:0|
 :skolemid |789|
 :pattern ( (Tclass._System.___hPartialFunc0 |#$R@@18|))
)))
(assert (forall ((arg0@@142 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0_0 arg0@@142)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0_0|
 :pattern ( (Tclass._System.___hPartialFunc0_0 arg0@@142))
)))
(assert (forall ((|#$R@@19| T@U) ) (!  (=> (= (type |#$R@@19|) TyType) (= (Tclass._System.___hPartialFunc0_0 (Tclass._System.___hPartialFunc0 |#$R@@19|)) |#$R@@19|))
 :qid |unknown.0:0|
 :skolemid |790|
 :pattern ( (Tclass._System.___hPartialFunc0 |#$R@@19|))
)))
(assert (forall ((|#$R@@20| T@U) (bx@@40 T@U) ) (!  (=> (and (and (= (type |#$R@@20|) TyType) (= (type bx@@40) BoxType)) ($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|))) (and (= ($Box ($Unbox HandleTypeType bx@@40)) bx@@40) ($Is ($Unbox HandleTypeType bx@@40) (Tclass._System.___hPartialFunc0 |#$R@@20|))))
 :qid |unknown.0:0|
 :skolemid |791|
 :pattern ( ($IsBox bx@@40 (Tclass._System.___hPartialFunc0 |#$R@@20|)))
)))
(assert (forall ((|#$R@@21| T@U) (|f#0@@3| T@U) ) (!  (=> (and (= (type |#$R@@21|) TyType) (= (type |f#0@@3|) HandleTypeType)) (= ($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|))  (and ($Is |f#0@@3| (Tclass._System.___hFunc0 |#$R@@21|)) (|Set#Equal| (Reads0 |#$R@@21| $OneHeap |f#0@@3|) (|Set#Empty| BoxType)))))
 :qid |unknown.0:0|
 :skolemid |792|
 :pattern ( ($Is |f#0@@3| (Tclass._System.___hPartialFunc0 |#$R@@21|)))
)))
(assert (forall ((|#$R@@22| T@U) (|f#0@@4| T@U) ($h@@9 T@U) ) (!  (=> (and (and (= (type |#$R@@22|) TyType) (= (type |f#0@@4|) HandleTypeType)) (= (type $h@@9) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@4| (Tclass._System.___hPartialFunc0 |#$R@@22|) $h@@9) ($IsAlloc |f#0@@4| (Tclass._System.___hFunc0 |#$R@@22|) $h@@9)))
 :qid |unknown.0:0|
 :skolemid |793|
 :pattern ( ($IsAlloc |f#0@@4| (Tclass._System.___hPartialFunc0 |#$R@@22|) $h@@9))
)))
(assert (forall ((arg0@@143 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0 arg0@@143)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0|
 :pattern ( (Tclass._System.___hTotalFunc0 arg0@@143))
)))
(assert (forall ((|#$R@@23| T@U) ) (!  (=> (= (type |#$R@@23|) TyType) (and (= (Tag (Tclass._System.___hTotalFunc0 |#$R@@23|)) Tagclass._System.___hTotalFunc0) (= (TagFamily (Tclass._System.___hTotalFunc0 |#$R@@23|)) |tytagFamily$_#TotalFunc0|)))
 :qid |unknown.0:0|
 :skolemid |794|
 :pattern ( (Tclass._System.___hTotalFunc0 |#$R@@23|))
)))
(assert (forall ((arg0@@144 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0_0 arg0@@144)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0_0|
 :pattern ( (Tclass._System.___hTotalFunc0_0 arg0@@144))
)))
(assert (forall ((|#$R@@24| T@U) ) (!  (=> (= (type |#$R@@24|) TyType) (= (Tclass._System.___hTotalFunc0_0 (Tclass._System.___hTotalFunc0 |#$R@@24|)) |#$R@@24|))
 :qid |unknown.0:0|
 :skolemid |795|
 :pattern ( (Tclass._System.___hTotalFunc0 |#$R@@24|))
)))
(assert (forall ((|#$R@@25| T@U) (bx@@41 T@U) ) (!  (=> (and (and (= (type |#$R@@25|) TyType) (= (type bx@@41) BoxType)) ($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|))) (and (= ($Box ($Unbox HandleTypeType bx@@41)) bx@@41) ($Is ($Unbox HandleTypeType bx@@41) (Tclass._System.___hTotalFunc0 |#$R@@25|))))
 :qid |unknown.0:0|
 :skolemid |796|
 :pattern ( ($IsBox bx@@41 (Tclass._System.___hTotalFunc0 |#$R@@25|)))
)))
(assert (forall ((|#$R@@26| T@U) (|f#0@@5| T@U) ) (!  (=> (and (= (type |#$R@@26|) TyType) (= (type |f#0@@5|) HandleTypeType)) (= ($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|))  (and ($Is |f#0@@5| (Tclass._System.___hPartialFunc0 |#$R@@26|)) (Requires0 |#$R@@26| $OneHeap |f#0@@5|))))
 :qid |unknown.0:0|
 :skolemid |797|
 :pattern ( ($Is |f#0@@5| (Tclass._System.___hTotalFunc0 |#$R@@26|)))
)))
(assert (forall ((|#$R@@27| T@U) (|f#0@@6| T@U) ($h@@10 T@U) ) (!  (=> (and (and (= (type |#$R@@27|) TyType) (= (type |f#0@@6|) HandleTypeType)) (= (type $h@@10) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@6| (Tclass._System.___hTotalFunc0 |#$R@@27|) $h@@10) ($IsAlloc |f#0@@6| (Tclass._System.___hPartialFunc0 |#$R@@27|) $h@@10)))
 :qid |unknown.0:0|
 :skolemid |798|
 :pattern ( ($IsAlloc |f#0@@6| (Tclass._System.___hTotalFunc0 |#$R@@27|) $h@@10))
)))
(assert (= (type Tclass._System.__default) TyType))
(assert (= (Tag Tclass._System.__default) Tagclass._System.__default))
(assert (= (TagFamily Tclass._System.__default) tytagFamily$_default))
(assert (forall ((bx@@42 T@U) ) (!  (=> (and (= (type bx@@42) BoxType) ($IsBox bx@@42 Tclass._System.__default)) (and (= ($Box ($Unbox refType bx@@42)) bx@@42) ($Is ($Unbox refType bx@@42) Tclass._System.__default)))
 :qid |unknown.0:0|
 :skolemid |799|
 :pattern ( ($IsBox bx@@42 Tclass._System.__default))
)))
(assert (forall (($o@@7 T@U) ) (!  (=> (= (type $o@@7) refType) (= ($Is $o@@7 Tclass._System.__default)  (or (= $o@@7 null) (= (dtype $o@@7) Tclass._System.__default))))
 :qid |unknown.0:0|
 :skolemid |800|
 :pattern ( ($Is $o@@7 Tclass._System.__default))
)))
(assert (forall (($o@@8 T@U) ($h@@11 T@U) ) (!  (=> (and (= (type $o@@8) refType) (= (type $h@@11) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@8 Tclass._System.__default $h@@11)  (or (= $o@@8 null) (U_2_bool (MapType1Select (MapType0Select $h@@11 $o@@8) alloc)))))
 :qid |unknown.0:0|
 :skolemid |801|
 :pattern ( ($IsAlloc $o@@8 Tclass._System.__default $h@@11))
)))
(assert  (=> true (forall ((|#$A| T@U) (|#$B| T@U) (|a#0| T@U) (|b#0| T@U) ) (!  (=> (and (and (and (and (= (type |#$A|) TyType) (= (type |#$B|) TyType)) (= (type |a#0|) BoxType)) (= (type |b#0|) BoxType)) (or (|_System.__default.rank__is__less__than#canCall| |#$A| |#$B| |a#0| |b#0|) (and ($IsBox |a#0| |#$A|) ($IsBox |b#0| |#$B|)))) true)
 :qid |unknown.0:0|
 :skolemid |802|
 :pattern ( (_System.__default.rank__is__less__than |#$A| |#$B| |a#0| |b#0|))
))))
(assert (forall ((|#$A@@0| T@U) (|#$B@@0| T@U) (|a#0@@0| T@U) (|b#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |#$A@@0|) TyType) (= (type |#$B@@0|) TyType)) (= (type |a#0@@0|) BoxType)) (= (type |b#0@@0|) BoxType)) (and ($IsBox |a#0@@0| |#$A@@0|) ($IsBox |b#0@@0| |#$B@@0|))) (= (|_System.__default.rank__is__less__than#requires| |#$A@@0| |#$B@@0| |a#0@@0| |b#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |803|
 :pattern ( (|_System.__default.rank__is__less__than#requires| |#$A@@0| |#$B@@0| |a#0@@0| |b#0@@0|))
)))
(assert (forall ((arg0@@145 T@U) (arg1@@67 T@U) (arg2@@19 T@U) ) (! (= (type (Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19)) TyType)
 :qid |funType:Tclass._System.___hFunc2|
 :pattern ( (Tclass._System.___hFunc2 arg0@@145 arg1@@67 arg2@@19))
)))
(assert (forall ((|#$T0@@15| T@U) (|#$T1| T@U) (|#$R@@28| T@U) ) (!  (=> (and (and (= (type |#$T0@@15|) TyType) (= (type |#$T1|) TyType)) (= (type |#$R@@28|) TyType)) (and (= (Tag (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|)) Tagclass._System.___hFunc2) (= (TagFamily (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|)) |tytagFamily$_#Func2|)))
 :qid |unknown.0:0|
 :skolemid |804|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@15| |#$T1| |#$R@@28|))
)))
(assert (forall ((arg0@@146 T@U) ) (! (= (type (Tclass._System.___hFunc2_0 arg0@@146)) TyType)
 :qid |funType:Tclass._System.___hFunc2_0|
 :pattern ( (Tclass._System.___hFunc2_0 arg0@@146))
)))
(assert (forall ((|#$T0@@16| T@U) (|#$T1@@0| T@U) (|#$R@@29| T@U) ) (!  (=> (and (and (= (type |#$T0@@16|) TyType) (= (type |#$T1@@0|) TyType)) (= (type |#$R@@29|) TyType)) (= (Tclass._System.___hFunc2_0 (Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|)) |#$T0@@16|))
 :qid |unknown.0:0|
 :skolemid |805|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@16| |#$T1@@0| |#$R@@29|))
)))
(assert (forall ((arg0@@147 T@U) ) (! (= (type (Tclass._System.___hFunc2_1 arg0@@147)) TyType)
 :qid |funType:Tclass._System.___hFunc2_1|
 :pattern ( (Tclass._System.___hFunc2_1 arg0@@147))
)))
(assert (forall ((|#$T0@@17| T@U) (|#$T1@@1| T@U) (|#$R@@30| T@U) ) (!  (=> (and (and (= (type |#$T0@@17|) TyType) (= (type |#$T1@@1|) TyType)) (= (type |#$R@@30|) TyType)) (= (Tclass._System.___hFunc2_1 (Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|)) |#$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |806|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@17| |#$T1@@1| |#$R@@30|))
)))
(assert (forall ((arg0@@148 T@U) ) (! (= (type (Tclass._System.___hFunc2_2 arg0@@148)) TyType)
 :qid |funType:Tclass._System.___hFunc2_2|
 :pattern ( (Tclass._System.___hFunc2_2 arg0@@148))
)))
(assert (forall ((|#$T0@@18| T@U) (|#$T1@@2| T@U) (|#$R@@31| T@U) ) (!  (=> (and (and (= (type |#$T0@@18|) TyType) (= (type |#$T1@@2|) TyType)) (= (type |#$R@@31|) TyType)) (= (Tclass._System.___hFunc2_2 (Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|)) |#$R@@31|))
 :qid |unknown.0:0|
 :skolemid |807|
 :pattern ( (Tclass._System.___hFunc2 |#$T0@@18| |#$T1@@2| |#$R@@31|))
)))
(assert (forall ((|#$T0@@19| T@U) (|#$T1@@3| T@U) (|#$R@@32| T@U) (bx@@43 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@19|) TyType) (= (type |#$T1@@3|) TyType)) (= (type |#$R@@32|) TyType)) (= (type bx@@43) BoxType)) ($IsBox bx@@43 (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|))) (and (= ($Box ($Unbox HandleTypeType bx@@43)) bx@@43) ($Is ($Unbox HandleTypeType bx@@43) (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|))))
 :qid |unknown.0:0|
 :skolemid |808|
 :pattern ( ($IsBox bx@@43 (Tclass._System.___hFunc2 |#$T0@@19| |#$T1@@3| |#$R@@32|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@149 T@T) (arg1@@68 T@T) (arg2@@20 T@T) (arg3@@3 T@T) ) (! (= (Ctor (MapType3Type arg0@@149 arg1@@68 arg2@@20 arg3@@3)) 25)
 :qid |ctor:MapType3Type|
)) (forall ((arg0@@150 T@T) (arg1@@69 T@T) (arg2@@21 T@T) (arg3@@4 T@T) ) (! (= (MapType3TypeInv0 (MapType3Type arg0@@150 arg1@@69 arg2@@21 arg3@@4)) arg0@@150)
 :qid |typeInv:MapType3TypeInv0|
 :pattern ( (MapType3Type arg0@@150 arg1@@69 arg2@@21 arg3@@4))
))) (forall ((arg0@@151 T@T) (arg1@@70 T@T) (arg2@@22 T@T) (arg3@@5 T@T) ) (! (= (MapType3TypeInv1 (MapType3Type arg0@@151 arg1@@70 arg2@@22 arg3@@5)) arg1@@70)
 :qid |typeInv:MapType3TypeInv1|
 :pattern ( (MapType3Type arg0@@151 arg1@@70 arg2@@22 arg3@@5))
))) (forall ((arg0@@152 T@T) (arg1@@71 T@T) (arg2@@23 T@T) (arg3@@6 T@T) ) (! (= (MapType3TypeInv2 (MapType3Type arg0@@152 arg1@@71 arg2@@23 arg3@@6)) arg2@@23)
 :qid |typeInv:MapType3TypeInv2|
 :pattern ( (MapType3Type arg0@@152 arg1@@71 arg2@@23 arg3@@6))
))) (forall ((arg0@@153 T@T) (arg1@@72 T@T) (arg2@@24 T@T) (arg3@@7 T@T) ) (! (= (MapType3TypeInv3 (MapType3Type arg0@@153 arg1@@72 arg2@@24 arg3@@7)) arg3@@7)
 :qid |typeInv:MapType3TypeInv3|
 :pattern ( (MapType3Type arg0@@153 arg1@@72 arg2@@24 arg3@@7))
))) (forall ((arg0@@154 T@U) (arg1@@73 T@U) (arg2@@25 T@U) (arg3@@8 T@U) ) (! (let ((aVar3 (MapType3TypeInv3 (type arg0@@154))))
(= (type (MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8)) aVar3))
 :qid |funType:MapType3Select|
 :pattern ( (MapType3Select arg0@@154 arg1@@73 arg2@@25 arg3@@8))
))) (forall ((arg0@@155 T@U) (arg1@@74 T@U) (arg2@@26 T@U) (arg3@@9 T@U) (arg4@@1 T@U) ) (! (let ((aVar3@@0 (type arg4@@1)))
(let ((aVar2@@2 (type arg3@@9)))
(let ((aVar1@@3 (type arg2@@26)))
(let ((aVar0@@1 (type arg1@@74)))
(= (type (MapType3Store arg0@@155 arg1@@74 arg2@@26 arg3@@9 arg4@@1)) (MapType3Type aVar0@@1 aVar1@@3 aVar2@@2 aVar3@@0))))))
 :qid |funType:MapType3Store|
 :pattern ( (MapType3Store arg0@@155 arg1@@74 arg2@@26 arg3@@9 arg4@@1))
))) (forall ((m@@49 T@U) (x0@@9 T@U) (x1@@3 T@U) (x2 T@U) (val@@10 T@U) ) (! (let ((aVar3@@1 (MapType3TypeInv3 (type m@@49))))
 (=> (= (type val@@10) aVar3@@1) (= (MapType3Select (MapType3Store m@@49 x0@@9 x1@@3 x2 val@@10) x0@@9 x1@@3 x2) val@@10)))
 :qid |mapAx0:MapType3Select|
 :weight 0
))) (and (and (and (forall ((val@@11 T@U) (m@@50 T@U) (x0@@10 T@U) (x1@@4 T@U) (x2@@0 T@U) (y0@@6 T@U) (y1@@2 T@U) (y2 T@U) ) (!  (or (= x0@@10 y0@@6) (= (MapType3Select (MapType3Store m@@50 x0@@10 x1@@4 x2@@0 val@@11) y0@@6 y1@@2 y2) (MapType3Select m@@50 y0@@6 y1@@2 y2)))
 :qid |mapAx1:MapType3Select:0|
 :weight 0
)) (forall ((val@@12 T@U) (m@@51 T@U) (x0@@11 T@U) (x1@@5 T@U) (x2@@1 T@U) (y0@@7 T@U) (y1@@3 T@U) (y2@@0 T@U) ) (!  (or (= x1@@5 y1@@3) (= (MapType3Select (MapType3Store m@@51 x0@@11 x1@@5 x2@@1 val@@12) y0@@7 y1@@3 y2@@0) (MapType3Select m@@51 y0@@7 y1@@3 y2@@0)))
 :qid |mapAx1:MapType3Select:1|
 :weight 0
))) (forall ((val@@13 T@U) (m@@52 T@U) (x0@@12 T@U) (x1@@6 T@U) (x2@@2 T@U) (y0@@8 T@U) (y1@@4 T@U) (y2@@1 T@U) ) (!  (or (= x2@@2 y2@@1) (= (MapType3Select (MapType3Store m@@52 x0@@12 x1@@6 x2@@2 val@@13) y0@@8 y1@@4 y2@@1) (MapType3Select m@@52 y0@@8 y1@@4 y2@@1)))
 :qid |mapAx1:MapType3Select:2|
 :weight 0
))) (forall ((val@@14 T@U) (m@@53 T@U) (x0@@13 T@U) (x1@@7 T@U) (x2@@3 T@U) (y0@@9 T@U) (y1@@5 T@U) (y2@@2 T@U) ) (!  (or true (= (MapType3Select (MapType3Store m@@53 x0@@13 x1@@7 x2@@3 val@@14) y0@@9 y1@@5 y2@@2) (MapType3Select m@@53 y0@@9 y1@@5 y2@@2)))
 :qid |mapAx2:MapType3Select|
 :weight 0
)))) (forall ((arg0@@156 T@U) (arg1@@75 T@U) (arg2@@27 T@U) (arg3@@10 T@U) (arg4@@2 T@U) (arg5 T@U) (arg6 T@U) ) (! (= (type (Apply2 arg0@@156 arg1@@75 arg2@@27 arg3@@10 arg4@@2 arg5 arg6)) BoxType)
 :qid |funType:Apply2|
 :pattern ( (Apply2 arg0@@156 arg1@@75 arg2@@27 arg3@@10 arg4@@2 arg5 arg6))
))) (forall ((arg0@@157 T@U) (arg1@@76 T@U) (arg2@@28 T@U) ) (! (= (type (Handle2 arg0@@157 arg1@@76 arg2@@28)) HandleTypeType)
 :qid |funType:Handle2|
 :pattern ( (Handle2 arg0@@157 arg1@@76 arg2@@28))
))))
(assert (forall ((t0@@46 T@U) (t1@@22 T@U) (t2 T@U) (heap@@11 T@U) (h@@33 T@U) (r@@14 T@U) (rd@@5 T@U) (bx0@@13 T@U) (bx1 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@46) TyType) (= (type t1@@22) TyType)) (= (type t2) TyType)) (= (type heap@@11) (MapType0Type refType MapType1Type))) (= (type h@@33) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@14) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@5) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@13) BoxType)) (= (type bx1) BoxType)) (= (Apply2 t0@@46 t1@@22 t2 heap@@11 (Handle2 h@@33 r@@14 rd@@5) bx0@@13 bx1) (MapType3Select h@@33 heap@@11 bx0@@13 bx1)))
 :qid |unknown.0:0|
 :skolemid |809|
 :pattern ( (Apply2 t0@@46 t1@@22 t2 heap@@11 (Handle2 h@@33 r@@14 rd@@5) bx0@@13 bx1))
)))
(assert (forall ((t0@@47 T@U) (t1@@23 T@U) (t2@@0 T@U) (heap@@12 T@U) (h@@34 T@U) (r@@15 T@U) (rd@@6 T@U) (bx0@@14 T@U) (bx1@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@47) TyType) (= (type t1@@23) TyType)) (= (type t2@@0) TyType)) (= (type heap@@12) (MapType0Type refType MapType1Type))) (= (type h@@34) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@15) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@6) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@14) BoxType)) (= (type bx1@@0) BoxType)) (U_2_bool (MapType3Select r@@15 heap@@12 bx0@@14 bx1@@0))) (Requires2 t0@@47 t1@@23 t2@@0 heap@@12 (Handle2 h@@34 r@@15 rd@@6) bx0@@14 bx1@@0))
 :qid |unknown.0:0|
 :skolemid |810|
 :pattern ( (Requires2 t0@@47 t1@@23 t2@@0 heap@@12 (Handle2 h@@34 r@@15 rd@@6) bx0@@14 bx1@@0))
)))
(assert (forall ((arg0@@158 T@U) (arg1@@77 T@U) (arg2@@29 T@U) (arg3@@11 T@U) (arg4@@3 T@U) (arg5@@0 T@U) (arg6@@0 T@U) ) (! (= (type (Reads2 arg0@@158 arg1@@77 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads2|
 :pattern ( (Reads2 arg0@@158 arg1@@77 arg2@@29 arg3@@11 arg4@@3 arg5@@0 arg6@@0))
)))
(assert (forall ((t0@@48 T@U) (t1@@24 T@U) (t2@@1 T@U) (heap@@13 T@U) (h@@35 T@U) (r@@16 T@U) (rd@@7 T@U) (bx0@@15 T@U) (bx1@@1 T@U) (bx@@44 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@48) TyType) (= (type t1@@24) TyType)) (= (type t2@@1) TyType)) (= (type heap@@13) (MapType0Type refType MapType1Type))) (= (type h@@35) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType))) (= (type r@@16) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))) (= (type rd@@7) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@15) BoxType)) (= (type bx1@@1) BoxType)) (= (type bx@@44) BoxType)) (= (U_2_bool (MapType0Select (Reads2 t0@@48 t1@@24 t2@@1 heap@@13 (Handle2 h@@35 r@@16 rd@@7) bx0@@15 bx1@@1) bx@@44)) (U_2_bool (MapType0Select (MapType3Select rd@@7 heap@@13 bx0@@15 bx1@@1) bx@@44))))
 :qid |unknown.0:0|
 :skolemid |811|
 :pattern ( (MapType0Select (Reads2 t0@@48 t1@@24 t2@@1 heap@@13 (Handle2 h@@35 r@@16 rd@@7) bx0@@15 bx1@@1) bx@@44))
)))
(assert (forall ((t0@@49 T@U) (t1@@25 T@U) (t2@@2 T@U) (h0@@12 T@U) (h1@@12 T@U) (f@@29 T@U) (bx0@@16 T@U) (bx1@@2 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@49) TyType) (= (type t1@@25) TyType)) (= (type t2@@2) TyType)) (= (type h0@@12) (MapType0Type refType MapType1Type))) (= (type h1@@12) (MapType0Type refType MapType1Type))) (= (type f@@29) HandleTypeType)) (= (type bx0@@16) BoxType)) (= (type bx1@@2) BoxType)) (and (and (and ($HeapSucc h0@@12 h1@@12) (and ($IsGoodHeap h0@@12) ($IsGoodHeap h1@@12))) (and (and ($IsBox bx0@@16 t0@@49) ($IsBox bx1@@2 t1@@25)) ($Is f@@29 (Tclass._System.___hFunc2 t0@@49 t1@@25 t2@@2)))) (forall ((o@@56 T@U) (fld@@11 T@U) ) (! (let ((a@@94 (FieldTypeInv0 (type fld@@11))))
 (=> (and (and (= (type o@@56) refType) (= (type fld@@11) (FieldType a@@94))) (and (not (= o@@56 null)) (U_2_bool (MapType0Select (Reads2 t0@@49 t1@@25 t2@@2 h0@@12 f@@29 bx0@@16 bx1@@2) ($Box o@@56))))) (= (MapType1Select (MapType0Select h0@@12 o@@56) fld@@11) (MapType1Select (MapType0Select h1@@12 o@@56) fld@@11))))
 :qid |unknown.0:0|
 :skolemid |812|
 :no-pattern (type o@@56)
 :no-pattern (type fld@@11)
 :no-pattern (U_2_int o@@56)
 :no-pattern (U_2_bool o@@56)
 :no-pattern (U_2_int fld@@11)
 :no-pattern (U_2_bool fld@@11)
)))) (= (Reads2 t0@@49 t1@@25 t2@@2 h0@@12 f@@29 bx0@@16 bx1@@2) (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2)))
 :qid |unknown.0:0|
 :skolemid |813|
 :pattern ( ($HeapSucc h0@@12 h1@@12) (Reads2 t0@@49 t1@@25 t2@@2 h1@@12 f@@29 bx0@@16 bx1@@2))
)))
(assert (forall ((t0@@50 T@U) (t1@@26 T@U) (t2@@3 T@U) (h0@@13 T@U) (h1@@13 T@U) (f@@30 T@U) (bx0@@17 T@U) (bx1@@3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@50) TyType) (= (type t1@@26) TyType)) (= (type t2@@3) TyType)) (= (type h0@@13) (MapType0Type refType MapType1Type))) (= (type h1@@13) (MapType0Type refType MapType1Type))) (= (type f@@30) HandleTypeType)) (= (type bx0@@17) BoxType)) (= (type bx1@@3) BoxType)) (and (and (and ($HeapSucc h0@@13 h1@@13) (and ($IsGoodHeap h0@@13) ($IsGoodHeap h1@@13))) (and (and ($IsBox bx0@@17 t0@@50) ($IsBox bx1@@3 t1@@26)) ($Is f@@30 (Tclass._System.___hFunc2 t0@@50 t1@@26 t2@@3)))) (forall ((o@@57 T@U) (fld@@12 T@U) ) (! (let ((a@@95 (FieldTypeInv0 (type fld@@12))))
 (=> (and (and (= (type o@@57) refType) (= (type fld@@12) (FieldType a@@95))) (and (not (= o@@57 null)) (U_2_bool (MapType0Select (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3) ($Box o@@57))))) (= (MapType1Select (MapType0Select h0@@13 o@@57) fld@@12) (MapType1Select (MapType0Select h1@@13 o@@57) fld@@12))))
 :qid |unknown.0:0|
 :skolemid |814|
 :no-pattern (type o@@57)
 :no-pattern (type fld@@12)
 :no-pattern (U_2_int o@@57)
 :no-pattern (U_2_bool o@@57)
 :no-pattern (U_2_int fld@@12)
 :no-pattern (U_2_bool fld@@12)
)))) (= (Reads2 t0@@50 t1@@26 t2@@3 h0@@13 f@@30 bx0@@17 bx1@@3) (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3)))
 :qid |unknown.0:0|
 :skolemid |815|
 :pattern ( ($HeapSucc h0@@13 h1@@13) (Reads2 t0@@50 t1@@26 t2@@3 h1@@13 f@@30 bx0@@17 bx1@@3))
)))
(assert (forall ((t0@@51 T@U) (t1@@27 T@U) (t2@@4 T@U) (h0@@14 T@U) (h1@@14 T@U) (f@@31 T@U) (bx0@@18 T@U) (bx1@@4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@51) TyType) (= (type t1@@27) TyType)) (= (type t2@@4) TyType)) (= (type h0@@14) (MapType0Type refType MapType1Type))) (= (type h1@@14) (MapType0Type refType MapType1Type))) (= (type f@@31) HandleTypeType)) (= (type bx0@@18) BoxType)) (= (type bx1@@4) BoxType)) (and (and (and ($HeapSucc h0@@14 h1@@14) (and ($IsGoodHeap h0@@14) ($IsGoodHeap h1@@14))) (and (and ($IsBox bx0@@18 t0@@51) ($IsBox bx1@@4 t1@@27)) ($Is f@@31 (Tclass._System.___hFunc2 t0@@51 t1@@27 t2@@4)))) (forall ((o@@58 T@U) (fld@@13 T@U) ) (! (let ((a@@96 (FieldTypeInv0 (type fld@@13))))
 (=> (and (and (= (type o@@58) refType) (= (type fld@@13) (FieldType a@@96))) (and (not (= o@@58 null)) (U_2_bool (MapType0Select (Reads2 t0@@51 t1@@27 t2@@4 h0@@14 f@@31 bx0@@18 bx1@@4) ($Box o@@58))))) (= (MapType1Select (MapType0Select h0@@14 o@@58) fld@@13) (MapType1Select (MapType0Select h1@@14 o@@58) fld@@13))))
 :qid |unknown.0:0|
 :skolemid |816|
 :no-pattern (type o@@58)
 :no-pattern (type fld@@13)
 :no-pattern (U_2_int o@@58)
 :no-pattern (U_2_bool o@@58)
 :no-pattern (U_2_int fld@@13)
 :no-pattern (U_2_bool fld@@13)
)))) (= (Requires2 t0@@51 t1@@27 t2@@4 h0@@14 f@@31 bx0@@18 bx1@@4) (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4)))
 :qid |unknown.0:0|
 :skolemid |817|
 :pattern ( ($HeapSucc h0@@14 h1@@14) (Requires2 t0@@51 t1@@27 t2@@4 h1@@14 f@@31 bx0@@18 bx1@@4))
)))
(assert (forall ((t0@@52 T@U) (t1@@28 T@U) (t2@@5 T@U) (h0@@15 T@U) (h1@@15 T@U) (f@@32 T@U) (bx0@@19 T@U) (bx1@@5 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@52) TyType) (= (type t1@@28) TyType)) (= (type t2@@5) TyType)) (= (type h0@@15) (MapType0Type refType MapType1Type))) (= (type h1@@15) (MapType0Type refType MapType1Type))) (= (type f@@32) HandleTypeType)) (= (type bx0@@19) BoxType)) (= (type bx1@@5) BoxType)) (and (and (and ($HeapSucc h0@@15 h1@@15) (and ($IsGoodHeap h0@@15) ($IsGoodHeap h1@@15))) (and (and ($IsBox bx0@@19 t0@@52) ($IsBox bx1@@5 t1@@28)) ($Is f@@32 (Tclass._System.___hFunc2 t0@@52 t1@@28 t2@@5)))) (forall ((o@@59 T@U) (fld@@14 T@U) ) (! (let ((a@@97 (FieldTypeInv0 (type fld@@14))))
 (=> (and (and (= (type o@@59) refType) (= (type fld@@14) (FieldType a@@97))) (and (not (= o@@59 null)) (U_2_bool (MapType0Select (Reads2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5) ($Box o@@59))))) (= (MapType1Select (MapType0Select h0@@15 o@@59) fld@@14) (MapType1Select (MapType0Select h1@@15 o@@59) fld@@14))))
 :qid |unknown.0:0|
 :skolemid |818|
 :no-pattern (type o@@59)
 :no-pattern (type fld@@14)
 :no-pattern (U_2_int o@@59)
 :no-pattern (U_2_bool o@@59)
 :no-pattern (U_2_int fld@@14)
 :no-pattern (U_2_bool fld@@14)
)))) (= (Requires2 t0@@52 t1@@28 t2@@5 h0@@15 f@@32 bx0@@19 bx1@@5) (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5)))
 :qid |unknown.0:0|
 :skolemid |819|
 :pattern ( ($HeapSucc h0@@15 h1@@15) (Requires2 t0@@52 t1@@28 t2@@5 h1@@15 f@@32 bx0@@19 bx1@@5))
)))
(assert (forall ((t0@@53 T@U) (t1@@29 T@U) (t2@@6 T@U) (h0@@16 T@U) (h1@@16 T@U) (f@@33 T@U) (bx0@@20 T@U) (bx1@@6 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@53) TyType) (= (type t1@@29) TyType)) (= (type t2@@6) TyType)) (= (type h0@@16) (MapType0Type refType MapType1Type))) (= (type h1@@16) (MapType0Type refType MapType1Type))) (= (type f@@33) HandleTypeType)) (= (type bx0@@20) BoxType)) (= (type bx1@@6) BoxType)) (and (and (and ($HeapSucc h0@@16 h1@@16) (and ($IsGoodHeap h0@@16) ($IsGoodHeap h1@@16))) (and (and ($IsBox bx0@@20 t0@@53) ($IsBox bx1@@6 t1@@29)) ($Is f@@33 (Tclass._System.___hFunc2 t0@@53 t1@@29 t2@@6)))) (forall ((o@@60 T@U) (fld@@15 T@U) ) (! (let ((a@@98 (FieldTypeInv0 (type fld@@15))))
 (=> (and (and (= (type o@@60) refType) (= (type fld@@15) (FieldType a@@98))) (and (not (= o@@60 null)) (U_2_bool (MapType0Select (Reads2 t0@@53 t1@@29 t2@@6 h0@@16 f@@33 bx0@@20 bx1@@6) ($Box o@@60))))) (= (MapType1Select (MapType0Select h0@@16 o@@60) fld@@15) (MapType1Select (MapType0Select h1@@16 o@@60) fld@@15))))
 :qid |unknown.0:0|
 :skolemid |820|
 :no-pattern (type o@@60)
 :no-pattern (type fld@@15)
 :no-pattern (U_2_int o@@60)
 :no-pattern (U_2_bool o@@60)
 :no-pattern (U_2_int fld@@15)
 :no-pattern (U_2_bool fld@@15)
)))) (= (Apply2 t0@@53 t1@@29 t2@@6 h0@@16 f@@33 bx0@@20 bx1@@6) (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6)))
 :qid |unknown.0:0|
 :skolemid |821|
 :pattern ( ($HeapSucc h0@@16 h1@@16) (Apply2 t0@@53 t1@@29 t2@@6 h1@@16 f@@33 bx0@@20 bx1@@6))
)))
(assert (forall ((t0@@54 T@U) (t1@@30 T@U) (t2@@7 T@U) (h0@@17 T@U) (h1@@17 T@U) (f@@34 T@U) (bx0@@21 T@U) (bx1@@7 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (= (type t0@@54) TyType) (= (type t1@@30) TyType)) (= (type t2@@7) TyType)) (= (type h0@@17) (MapType0Type refType MapType1Type))) (= (type h1@@17) (MapType0Type refType MapType1Type))) (= (type f@@34) HandleTypeType)) (= (type bx0@@21) BoxType)) (= (type bx1@@7) BoxType)) (and (and (and ($HeapSucc h0@@17 h1@@17) (and ($IsGoodHeap h0@@17) ($IsGoodHeap h1@@17))) (and (and ($IsBox bx0@@21 t0@@54) ($IsBox bx1@@7 t1@@30)) ($Is f@@34 (Tclass._System.___hFunc2 t0@@54 t1@@30 t2@@7)))) (forall ((o@@61 T@U) (fld@@16 T@U) ) (! (let ((a@@99 (FieldTypeInv0 (type fld@@16))))
 (=> (and (and (= (type o@@61) refType) (= (type fld@@16) (FieldType a@@99))) (and (not (= o@@61 null)) (U_2_bool (MapType0Select (Reads2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7) ($Box o@@61))))) (= (MapType1Select (MapType0Select h0@@17 o@@61) fld@@16) (MapType1Select (MapType0Select h1@@17 o@@61) fld@@16))))
 :qid |unknown.0:0|
 :skolemid |822|
 :no-pattern (type o@@61)
 :no-pattern (type fld@@16)
 :no-pattern (U_2_int o@@61)
 :no-pattern (U_2_bool o@@61)
 :no-pattern (U_2_int fld@@16)
 :no-pattern (U_2_bool fld@@16)
)))) (= (Apply2 t0@@54 t1@@30 t2@@7 h0@@17 f@@34 bx0@@21 bx1@@7) (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7)))
 :qid |unknown.0:0|
 :skolemid |823|
 :pattern ( ($HeapSucc h0@@17 h1@@17) (Apply2 t0@@54 t1@@30 t2@@7 h1@@17 f@@34 bx0@@21 bx1@@7))
)))
(assert (forall ((t0@@55 T@U) (t1@@31 T@U) (t2@@8 T@U) (heap@@14 T@U) (f@@35 T@U) (bx0@@22 T@U) (bx1@@8 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@55) TyType) (= (type t1@@31) TyType)) (= (type t2@@8) TyType)) (= (type heap@@14) (MapType0Type refType MapType1Type))) (= (type f@@35) HandleTypeType)) (= (type bx0@@22) BoxType)) (= (type bx1@@8) BoxType)) (and ($IsGoodHeap heap@@14) (and (and ($IsBox bx0@@22 t0@@55) ($IsBox bx1@@8 t1@@31)) ($Is f@@35 (Tclass._System.___hFunc2 t0@@55 t1@@31 t2@@8))))) (= (|Set#Equal| (Reads2 t0@@55 t1@@31 t2@@8 $OneHeap f@@35 bx0@@22 bx1@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads2 t0@@55 t1@@31 t2@@8 heap@@14 f@@35 bx0@@22 bx1@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |824|
 :pattern ( (Reads2 t0@@55 t1@@31 t2@@8 $OneHeap f@@35 bx0@@22 bx1@@8) ($IsGoodHeap heap@@14))
 :pattern ( (Reads2 t0@@55 t1@@31 t2@@8 heap@@14 f@@35 bx0@@22 bx1@@8))
)))
(assert (forall ((t0@@56 T@U) (t1@@32 T@U) (t2@@9 T@U) (heap@@15 T@U) (f@@36 T@U) (bx0@@23 T@U) (bx1@@9 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type t0@@56) TyType) (= (type t1@@32) TyType)) (= (type t2@@9) TyType)) (= (type heap@@15) (MapType0Type refType MapType1Type))) (= (type f@@36) HandleTypeType)) (= (type bx0@@23) BoxType)) (= (type bx1@@9) BoxType)) (and (and ($IsGoodHeap heap@@15) (and (and ($IsBox bx0@@23 t0@@56) ($IsBox bx1@@9 t1@@32)) ($Is f@@36 (Tclass._System.___hFunc2 t0@@56 t1@@32 t2@@9)))) (|Set#Equal| (Reads2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) (|Set#Empty| BoxType)))) (= (Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) (Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9)))
 :qid |unknown.0:0|
 :skolemid |825|
 :pattern ( (Requires2 t0@@56 t1@@32 t2@@9 $OneHeap f@@36 bx0@@23 bx1@@9) ($IsGoodHeap heap@@15))
 :pattern ( (Requires2 t0@@56 t1@@32 t2@@9 heap@@15 f@@36 bx0@@23 bx1@@9))
)))
(assert (forall ((f@@37 T@U) (t0@@57 T@U) (t1@@33 T@U) (t2@@10 T@U) ) (!  (=> (and (and (and (= (type f@@37) HandleTypeType) (= (type t0@@57) TyType)) (= (type t1@@33) TyType)) (= (type t2@@10) TyType)) (= ($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)) (forall ((h@@36 T@U) (bx0@@24 T@U) (bx1@@10 T@U) ) (!  (=> (and (and (and (= (type h@@36) (MapType0Type refType MapType1Type)) (= (type bx0@@24) BoxType)) (= (type bx1@@10) BoxType)) (and (and ($IsGoodHeap h@@36) (and ($IsBox bx0@@24 t0@@57) ($IsBox bx1@@10 t1@@33))) (Requires2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10))) ($IsBox (Apply2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10) t2@@10))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |826|
 :pattern ( (Apply2 t0@@57 t1@@33 t2@@10 h@@36 f@@37 bx0@@24 bx1@@10))
))))
 :qid |unknown.0:0|
 :skolemid |827|
 :pattern ( ($Is f@@37 (Tclass._System.___hFunc2 t0@@57 t1@@33 t2@@10)))
)))
(assert (forall ((f@@38 T@U) (t0@@58 T@U) (t1@@34 T@U) (t2@@11 T@U) (u0@@1 T@U) (u1@@0 T@U) (u2 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@38) HandleTypeType) (= (type t0@@58) TyType)) (= (type t1@@34) TyType)) (= (type t2@@11) TyType)) (= (type u0@@1) TyType)) (= (type u1@@0) TyType)) (= (type u2) TyType)) (and (and (and ($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11)) (forall ((bx@@45 T@U) ) (!  (=> (and (= (type bx@@45) BoxType) ($IsBox bx@@45 u0@@1)) ($IsBox bx@@45 t0@@58))
 :qid |unknown.0:0|
 :skolemid |828|
 :pattern ( ($IsBox bx@@45 u0@@1))
 :pattern ( ($IsBox bx@@45 t0@@58))
))) (forall ((bx@@46 T@U) ) (!  (=> (and (= (type bx@@46) BoxType) ($IsBox bx@@46 u1@@0)) ($IsBox bx@@46 t1@@34))
 :qid |unknown.0:0|
 :skolemid |829|
 :pattern ( ($IsBox bx@@46 u1@@0))
 :pattern ( ($IsBox bx@@46 t1@@34))
))) (forall ((bx@@47 T@U) ) (!  (=> (and (= (type bx@@47) BoxType) ($IsBox bx@@47 t2@@11)) ($IsBox bx@@47 u2))
 :qid |unknown.0:0|
 :skolemid |830|
 :pattern ( ($IsBox bx@@47 t2@@11))
 :pattern ( ($IsBox bx@@47 u2))
)))) ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2)))
 :qid |unknown.0:0|
 :skolemid |831|
 :pattern ( ($Is f@@38 (Tclass._System.___hFunc2 t0@@58 t1@@34 t2@@11)) ($Is f@@38 (Tclass._System.___hFunc2 u0@@1 u1@@0 u2)))
)))
(assert (forall ((f@@39 T@U) (t0@@59 T@U) (t1@@35 T@U) (t2@@12 T@U) (h@@37 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@39) HandleTypeType) (= (type t0@@59) TyType)) (= (type t1@@35) TyType)) (= (type t2@@12) TyType)) (= (type h@@37) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@37)) (= ($IsAlloc f@@39 (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12) h@@37) (forall ((bx0@@25 T@U) (bx1@@11 T@U) ) (!  (=> (and (= (type bx0@@25) BoxType) (= (type bx1@@11) BoxType)) (=> (and (and (and ($IsBox bx0@@25 t0@@59) ($IsAllocBox bx0@@25 t0@@59 h@@37)) (and ($IsBox bx1@@11 t1@@35) ($IsAllocBox bx1@@11 t1@@35 h@@37))) (Requires2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11)) (forall ((r@@17 T@U) ) (!  (=> (= (type r@@17) refType) (=> (and (not (= r@@17 null)) (U_2_bool (MapType0Select (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11) ($Box r@@17)))) (U_2_bool (MapType1Select (MapType0Select h@@37 r@@17) alloc))))
 :qid |unknown.0:0|
 :skolemid |832|
 :pattern ( (MapType0Select (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11) ($Box r@@17)))
))))
 :qid |unknown.0:0|
 :skolemid |833|
 :pattern ( (Apply2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11))
 :pattern ( (Reads2 t0@@59 t1@@35 t2@@12 h@@37 f@@39 bx0@@25 bx1@@11))
))))
 :qid |unknown.0:0|
 :skolemid |834|
 :pattern ( ($IsAlloc f@@39 (Tclass._System.___hFunc2 t0@@59 t1@@35 t2@@12) h@@37))
)))
(assert (forall ((f@@40 T@U) (t0@@60 T@U) (t1@@36 T@U) (t2@@13 T@U) (h@@38 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@40) HandleTypeType) (= (type t0@@60) TyType)) (= (type t1@@36) TyType)) (= (type t2@@13) TyType)) (= (type h@@38) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@38) ($IsAlloc f@@40 (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13) h@@38))) (forall ((bx0@@26 T@U) (bx1@@12 T@U) ) (!  (=> (and (= (type bx0@@26) BoxType) (= (type bx1@@12) BoxType)) (=> (and (and ($IsAllocBox bx0@@26 t0@@60 h@@38) ($IsAllocBox bx1@@12 t1@@36 h@@38)) (Requires2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12)) ($IsAllocBox (Apply2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12) t2@@13 h@@38)))
 :qid |unknown.0:0|
 :skolemid |835|
 :pattern ( (Apply2 t0@@60 t1@@36 t2@@13 h@@38 f@@40 bx0@@26 bx1@@12))
)))
 :qid |unknown.0:0|
 :skolemid |836|
 :pattern ( ($IsAlloc f@@40 (Tclass._System.___hFunc2 t0@@60 t1@@36 t2@@13) h@@38))
)))
(assert (forall ((arg0@@159 T@U) (arg1@@78 T@U) (arg2@@30 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2|
 :pattern ( (Tclass._System.___hPartialFunc2 arg0@@159 arg1@@78 arg2@@30))
)))
(assert (forall ((|#$T0@@20| T@U) (|#$T1@@4| T@U) (|#$R@@33| T@U) ) (!  (=> (and (and (= (type |#$T0@@20|) TyType) (= (type |#$T1@@4|) TyType)) (= (type |#$R@@33|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|)) Tagclass._System.___hPartialFunc2) (= (TagFamily (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|)) |tytagFamily$_#PartialFunc2|)))
 :qid |unknown.0:0|
 :skolemid |837|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@20| |#$T1@@4| |#$R@@33|))
)))
(assert (forall ((arg0@@160 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_0 arg0@@160)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_0|
 :pattern ( (Tclass._System.___hPartialFunc2_0 arg0@@160))
)))
(assert (forall ((|#$T0@@21| T@U) (|#$T1@@5| T@U) (|#$R@@34| T@U) ) (!  (=> (and (and (= (type |#$T0@@21|) TyType) (= (type |#$T1@@5|) TyType)) (= (type |#$R@@34|) TyType)) (= (Tclass._System.___hPartialFunc2_0 (Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|)) |#$T0@@21|))
 :qid |unknown.0:0|
 :skolemid |838|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@21| |#$T1@@5| |#$R@@34|))
)))
(assert (forall ((arg0@@161 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_1 arg0@@161)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_1|
 :pattern ( (Tclass._System.___hPartialFunc2_1 arg0@@161))
)))
(assert (forall ((|#$T0@@22| T@U) (|#$T1@@6| T@U) (|#$R@@35| T@U) ) (!  (=> (and (and (= (type |#$T0@@22|) TyType) (= (type |#$T1@@6|) TyType)) (= (type |#$R@@35|) TyType)) (= (Tclass._System.___hPartialFunc2_1 (Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|)) |#$T1@@6|))
 :qid |unknown.0:0|
 :skolemid |839|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@22| |#$T1@@6| |#$R@@35|))
)))
(assert (forall ((arg0@@162 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2_2 arg0@@162)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2_2|
 :pattern ( (Tclass._System.___hPartialFunc2_2 arg0@@162))
)))
(assert (forall ((|#$T0@@23| T@U) (|#$T1@@7| T@U) (|#$R@@36| T@U) ) (!  (=> (and (and (= (type |#$T0@@23|) TyType) (= (type |#$T1@@7|) TyType)) (= (type |#$R@@36|) TyType)) (= (Tclass._System.___hPartialFunc2_2 (Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|)) |#$R@@36|))
 :qid |unknown.0:0|
 :skolemid |840|
 :pattern ( (Tclass._System.___hPartialFunc2 |#$T0@@23| |#$T1@@7| |#$R@@36|))
)))
(assert (forall ((|#$T0@@24| T@U) (|#$T1@@8| T@U) (|#$R@@37| T@U) (bx@@48 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@24|) TyType) (= (type |#$T1@@8|) TyType)) (= (type |#$R@@37|) TyType)) (= (type bx@@48) BoxType)) ($IsBox bx@@48 (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|))) (and (= ($Box ($Unbox HandleTypeType bx@@48)) bx@@48) ($Is ($Unbox HandleTypeType bx@@48) (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|))))
 :qid |unknown.0:0|
 :skolemid |841|
 :pattern ( ($IsBox bx@@48 (Tclass._System.___hPartialFunc2 |#$T0@@24| |#$T1@@8| |#$R@@37|)))
)))
(assert (forall ((|#$T0@@25| T@U) (|#$T1@@9| T@U) (|#$R@@38| T@U) (|f#0@@7| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@25|) TyType) (= (type |#$T1@@9|) TyType)) (= (type |#$R@@38|) TyType)) (= (type |f#0@@7|) HandleTypeType)) (= ($Is |f#0@@7| (Tclass._System.___hPartialFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|))  (and ($Is |f#0@@7| (Tclass._System.___hFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|)) (forall ((|x0#0@@1| T@U) (|x1#0| T@U) ) (!  (=> (and (and (= (type |x0#0@@1|) BoxType) (= (type |x1#0|) BoxType)) (and ($IsBox |x0#0@@1| |#$T0@@25|) ($IsBox |x1#0| |#$T1@@9|))) (|Set#Equal| (Reads2 |#$T0@@25| |#$T1@@9| |#$R@@38| $OneHeap |f#0@@7| |x0#0@@1| |x1#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |842|
 :no-pattern (type |x0#0@@1|)
 :no-pattern (type |x1#0|)
 :no-pattern (U_2_int |x0#0@@1|)
 :no-pattern (U_2_bool |x0#0@@1|)
 :no-pattern (U_2_int |x1#0|)
 :no-pattern (U_2_bool |x1#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |843|
 :pattern ( ($Is |f#0@@7| (Tclass._System.___hPartialFunc2 |#$T0@@25| |#$T1@@9| |#$R@@38|)))
)))
(assert (forall ((|#$T0@@26| T@U) (|#$T1@@10| T@U) (|#$R@@39| T@U) (|f#0@@8| T@U) ($h@@12 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@26|) TyType) (= (type |#$T1@@10|) TyType)) (= (type |#$R@@39|) TyType)) (= (type |f#0@@8|) HandleTypeType)) (= (type $h@@12) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@8| (Tclass._System.___hPartialFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12) ($IsAlloc |f#0@@8| (Tclass._System.___hFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12)))
 :qid |unknown.0:0|
 :skolemid |844|
 :pattern ( ($IsAlloc |f#0@@8| (Tclass._System.___hPartialFunc2 |#$T0@@26| |#$T1@@10| |#$R@@39|) $h@@12))
)))
(assert (forall ((arg0@@163 T@U) (arg1@@79 T@U) (arg2@@31 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2|
 :pattern ( (Tclass._System.___hTotalFunc2 arg0@@163 arg1@@79 arg2@@31))
)))
(assert (forall ((|#$T0@@27| T@U) (|#$T1@@11| T@U) (|#$R@@40| T@U) ) (!  (=> (and (and (= (type |#$T0@@27|) TyType) (= (type |#$T1@@11|) TyType)) (= (type |#$R@@40|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|)) Tagclass._System.___hTotalFunc2) (= (TagFamily (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|)) |tytagFamily$_#TotalFunc2|)))
 :qid |unknown.0:0|
 :skolemid |845|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@27| |#$T1@@11| |#$R@@40|))
)))
(assert (forall ((arg0@@164 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_0 arg0@@164)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_0|
 :pattern ( (Tclass._System.___hTotalFunc2_0 arg0@@164))
)))
(assert (forall ((|#$T0@@28| T@U) (|#$T1@@12| T@U) (|#$R@@41| T@U) ) (!  (=> (and (and (= (type |#$T0@@28|) TyType) (= (type |#$T1@@12|) TyType)) (= (type |#$R@@41|) TyType)) (= (Tclass._System.___hTotalFunc2_0 (Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|)) |#$T0@@28|))
 :qid |unknown.0:0|
 :skolemid |846|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@28| |#$T1@@12| |#$R@@41|))
)))
(assert (forall ((arg0@@165 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_1 arg0@@165)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_1|
 :pattern ( (Tclass._System.___hTotalFunc2_1 arg0@@165))
)))
(assert (forall ((|#$T0@@29| T@U) (|#$T1@@13| T@U) (|#$R@@42| T@U) ) (!  (=> (and (and (= (type |#$T0@@29|) TyType) (= (type |#$T1@@13|) TyType)) (= (type |#$R@@42|) TyType)) (= (Tclass._System.___hTotalFunc2_1 (Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|)) |#$T1@@13|))
 :qid |unknown.0:0|
 :skolemid |847|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@29| |#$T1@@13| |#$R@@42|))
)))
(assert (forall ((arg0@@166 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2_2 arg0@@166)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2_2|
 :pattern ( (Tclass._System.___hTotalFunc2_2 arg0@@166))
)))
(assert (forall ((|#$T0@@30| T@U) (|#$T1@@14| T@U) (|#$R@@43| T@U) ) (!  (=> (and (and (= (type |#$T0@@30|) TyType) (= (type |#$T1@@14|) TyType)) (= (type |#$R@@43|) TyType)) (= (Tclass._System.___hTotalFunc2_2 (Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|)) |#$R@@43|))
 :qid |unknown.0:0|
 :skolemid |848|
 :pattern ( (Tclass._System.___hTotalFunc2 |#$T0@@30| |#$T1@@14| |#$R@@43|))
)))
(assert (forall ((|#$T0@@31| T@U) (|#$T1@@15| T@U) (|#$R@@44| T@U) (bx@@49 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@31|) TyType) (= (type |#$T1@@15|) TyType)) (= (type |#$R@@44|) TyType)) (= (type bx@@49) BoxType)) ($IsBox bx@@49 (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|))) (and (= ($Box ($Unbox HandleTypeType bx@@49)) bx@@49) ($Is ($Unbox HandleTypeType bx@@49) (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|))))
 :qid |unknown.0:0|
 :skolemid |849|
 :pattern ( ($IsBox bx@@49 (Tclass._System.___hTotalFunc2 |#$T0@@31| |#$T1@@15| |#$R@@44|)))
)))
(assert (forall ((|#$T0@@32| T@U) (|#$T1@@16| T@U) (|#$R@@45| T@U) (|f#0@@9| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@32|) TyType) (= (type |#$T1@@16|) TyType)) (= (type |#$R@@45|) TyType)) (= (type |f#0@@9|) HandleTypeType)) (= ($Is |f#0@@9| (Tclass._System.___hTotalFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|))  (and ($Is |f#0@@9| (Tclass._System.___hPartialFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|)) (forall ((|x0#0@@2| T@U) (|x1#0@@0| T@U) ) (!  (=> (and (and (= (type |x0#0@@2|) BoxType) (= (type |x1#0@@0|) BoxType)) (and ($IsBox |x0#0@@2| |#$T0@@32|) ($IsBox |x1#0@@0| |#$T1@@16|))) (Requires2 |#$T0@@32| |#$T1@@16| |#$R@@45| $OneHeap |f#0@@9| |x0#0@@2| |x1#0@@0|))
 :qid |unknown.0:0|
 :skolemid |850|
 :no-pattern (type |x0#0@@2|)
 :no-pattern (type |x1#0@@0|)
 :no-pattern (U_2_int |x0#0@@2|)
 :no-pattern (U_2_bool |x0#0@@2|)
 :no-pattern (U_2_int |x1#0@@0|)
 :no-pattern (U_2_bool |x1#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |851|
 :pattern ( ($Is |f#0@@9| (Tclass._System.___hTotalFunc2 |#$T0@@32| |#$T1@@16| |#$R@@45|)))
)))
(assert (forall ((|#$T0@@33| T@U) (|#$T1@@17| T@U) (|#$R@@46| T@U) (|f#0@@10| T@U) ($h@@13 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@33|) TyType) (= (type |#$T1@@17|) TyType)) (= (type |#$R@@46|) TyType)) (= (type |f#0@@10|) HandleTypeType)) (= (type $h@@13) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@10| (Tclass._System.___hTotalFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13) ($IsAlloc |f#0@@10| (Tclass._System.___hPartialFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13)))
 :qid |unknown.0:0|
 :skolemid |852|
 :pattern ( ($IsAlloc |f#0@@10| (Tclass._System.___hTotalFunc2 |#$T0@@33| |#$T1@@17| |#$R@@46|) $h@@13))
)))
(assert (forall ((arg0@@167 T@U) ) (! (= (type (DatatypeCtorId arg0@@167)) DtCtorIdType)
 :qid |funType:DatatypeCtorId|
 :pattern ( (DatatypeCtorId arg0@@167))
)))
(assert (forall ((|a#0#0#0| T@U) (|a#0#1#0| T@U) ) (!  (=> (and (= (type |a#0#0#0|) BoxType) (= (type |a#0#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|)) |##_System._tuple#2._#Make2|))
 :qid |unknown.0:0|
 :skolemid |853|
 :pattern ( (|#_System._tuple#2._#Make2| |a#0#0#0| |a#0#1#0|))
)))
(assert (forall ((d@@0 T@U) ) (!  (=> (= (type d@@0) DatatypeTypeType) (= (_System.Tuple2.___hMake2_q d@@0) (= (DatatypeCtorId d@@0) |##_System._tuple#2._#Make2|)))
 :qid |unknown.0:0|
 :skolemid |854|
 :pattern ( (_System.Tuple2.___hMake2_q d@@0))
)))
(assert (forall ((d@@1 T@U) ) (!  (=> (and (= (type d@@1) DatatypeTypeType) (_System.Tuple2.___hMake2_q d@@1)) (exists ((|a#1#0#0| T@U) (|a#1#1#0| T@U) ) (!  (and (and (= (type |a#1#0#0|) BoxType) (= (type |a#1#1#0|) BoxType)) (= d@@1 (|#_System._tuple#2._#Make2| |a#1#0#0| |a#1#1#0|)))
 :qid |unknown.0:0|
 :skolemid |855|
 :no-pattern (type |a#1#0#0|)
 :no-pattern (type |a#1#1#0|)
 :no-pattern (U_2_int |a#1#0#0|)
 :no-pattern (U_2_bool |a#1#0#0|)
 :no-pattern (U_2_int |a#1#1#0|)
 :no-pattern (U_2_bool |a#1#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |856|
 :pattern ( (_System.Tuple2.___hMake2_q d@@1))
)))
(assert (forall ((|_System._tuple#2$T0| T@U) (|_System._tuple#2$T1| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0|) TyType) (= (type |_System._tuple#2$T1|) TyType)) (and (= (Tag (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)) Tagclass._System.Tuple2) (= (TagFamily (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|)) |tytagFamily$_tuple#2|)))
 :qid |unknown.0:0|
 :skolemid |857|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0| |_System._tuple#2$T1|))
)))
(assert (forall ((arg0@@168 T@U) ) (! (= (type (Tclass._System.Tuple2_0 arg0@@168)) TyType)
 :qid |funType:Tclass._System.Tuple2_0|
 :pattern ( (Tclass._System.Tuple2_0 arg0@@168))
)))
(assert (forall ((|_System._tuple#2$T0@@0| T@U) (|_System._tuple#2$T1@@0| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0@@0|) TyType) (= (type |_System._tuple#2$T1@@0|) TyType)) (= (Tclass._System.Tuple2_0 (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|)) |_System._tuple#2$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |858|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@0| |_System._tuple#2$T1@@0|))
)))
(assert (forall ((arg0@@169 T@U) ) (! (= (type (Tclass._System.Tuple2_1 arg0@@169)) TyType)
 :qid |funType:Tclass._System.Tuple2_1|
 :pattern ( (Tclass._System.Tuple2_1 arg0@@169))
)))
(assert (forall ((|_System._tuple#2$T0@@1| T@U) (|_System._tuple#2$T1@@1| T@U) ) (!  (=> (and (= (type |_System._tuple#2$T0@@1|) TyType) (= (type |_System._tuple#2$T1@@1|) TyType)) (= (Tclass._System.Tuple2_1 (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|)) |_System._tuple#2$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |859|
 :pattern ( (Tclass._System.Tuple2 |_System._tuple#2$T0@@1| |_System._tuple#2$T1@@1|))
)))
(assert (forall ((|_System._tuple#2$T0@@2| T@U) (|_System._tuple#2$T1@@2| T@U) (bx@@50 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@2|) TyType) (= (type |_System._tuple#2$T1@@2|) TyType)) (= (type bx@@50) BoxType)) ($IsBox bx@@50 (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@50)) bx@@50) ($Is ($Unbox DatatypeTypeType bx@@50) (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|))))
 :qid |unknown.0:0|
 :skolemid |860|
 :pattern ( ($IsBox bx@@50 (Tclass._System.Tuple2 |_System._tuple#2$T0@@2| |_System._tuple#2$T1@@2|)))
)))
(assert (forall ((|_System._tuple#2$T0@@3| T@U) (|_System._tuple#2$T1@@3| T@U) (|a#2#0#0| T@U) (|a#2#1#0| T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@3|) TyType) (= (type |_System._tuple#2$T1@@3|) TyType)) (= (type |a#2#0#0|) BoxType)) (= (type |a#2#1#0|) BoxType)) (= ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|))  (and ($IsBox |a#2#0#0| |_System._tuple#2$T0@@3|) ($IsBox |a#2#1#0| |_System._tuple#2$T1@@3|))))
 :qid |unknown.0:0|
 :skolemid |861|
 :pattern ( ($Is (|#_System._tuple#2._#Make2| |a#2#0#0| |a#2#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@3| |_System._tuple#2$T1@@3|)))
)))
(assert (forall ((|_System._tuple#2$T0@@4| T@U) (|_System._tuple#2$T1@@4| T@U) (|a#3#0#0| T@U) (|a#3#1#0| T@U) ($h@@14 T@U) ) (!  (=> (and (and (and (and (and (= (type |_System._tuple#2$T0@@4|) TyType) (= (type |_System._tuple#2$T1@@4|) TyType)) (= (type |a#3#0#0|) BoxType)) (= (type |a#3#1#0|) BoxType)) (= (type $h@@14) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@14)) (= ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|) $h@@14)  (and ($IsAllocBox |a#3#0#0| |_System._tuple#2$T0@@4| $h@@14) ($IsAllocBox |a#3#1#0| |_System._tuple#2$T1@@4| $h@@14))))
 :qid |unknown.0:0|
 :skolemid |862|
 :pattern ( ($IsAlloc (|#_System._tuple#2._#Make2| |a#3#0#0| |a#3#1#0|) (Tclass._System.Tuple2 |_System._tuple#2$T0@@4| |_System._tuple#2$T1@@4|) $h@@14))
)))
(assert (forall ((d@@2 T@U) (|_System._tuple#2$T0@@5| T@U) ($h@@15 T@U) ) (!  (=> (and (and (and (= (type d@@2) DatatypeTypeType) (= (type |_System._tuple#2$T0@@5|) TyType)) (= (type $h@@15) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@15) (and (_System.Tuple2.___hMake2_q d@@2) (exists ((|_System._tuple#2$T1@@5| T@U) ) (!  (and (= (type |_System._tuple#2$T1@@5|) TyType) ($IsAlloc d@@2 (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|) $h@@15))
 :qid |unknown.0:0|
 :skolemid |863|
 :pattern ( ($IsAlloc d@@2 (Tclass._System.Tuple2 |_System._tuple#2$T0@@5| |_System._tuple#2$T1@@5|) $h@@15))
))))) ($IsAllocBox (_System.Tuple2._0 d@@2) |_System._tuple#2$T0@@5| $h@@15))
 :qid |unknown.0:0|
 :skolemid |864|
 :pattern ( ($IsAllocBox (_System.Tuple2._0 d@@2) |_System._tuple#2$T0@@5| $h@@15))
)))
(assert (forall ((d@@3 T@U) (|_System._tuple#2$T1@@6| T@U) ($h@@16 T@U) ) (!  (=> (and (and (and (= (type d@@3) DatatypeTypeType) (= (type |_System._tuple#2$T1@@6|) TyType)) (= (type $h@@16) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@16) (and (_System.Tuple2.___hMake2_q d@@3) (exists ((|_System._tuple#2$T0@@6| T@U) ) (!  (and (= (type |_System._tuple#2$T0@@6|) TyType) ($IsAlloc d@@3 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@16))
 :qid |unknown.0:0|
 :skolemid |865|
 :pattern ( ($IsAlloc d@@3 (Tclass._System.Tuple2 |_System._tuple#2$T0@@6| |_System._tuple#2$T1@@6|) $h@@16))
))))) ($IsAllocBox (_System.Tuple2._1 d@@3) |_System._tuple#2$T1@@6| $h@@16))
 :qid |unknown.0:0|
 :skolemid |866|
 :pattern ( ($IsAllocBox (_System.Tuple2._1 d@@3) |_System._tuple#2$T1@@6| $h@@16))
)))
(assert (forall ((|a#4#0#0| T@U) (|a#4#1#0| T@U) ) (!  (=> (and (= (type |a#4#0#0|) BoxType) (= (type |a#4#1#0|) BoxType)) (= (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)) (Lit (|#_System._tuple#2._#Make2| |a#4#0#0| |a#4#1#0|))))
 :qid |unknown.0:0|
 :skolemid |867|
 :pattern ( (|#_System._tuple#2._#Make2| (Lit |a#4#0#0|) (Lit |a#4#1#0|)))
)))
(assert (forall ((|a#5#0#0| T@U) (|a#5#1#0| T@U) ) (!  (=> (and (= (type |a#5#0#0|) BoxType) (= (type |a#5#1#0|) BoxType)) (= (_System.Tuple2._0 (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|)) |a#5#0#0|))
 :qid |unknown.0:0|
 :skolemid |868|
 :pattern ( (|#_System._tuple#2._#Make2| |a#5#0#0| |a#5#1#0|))
)))
(assert (forall ((|a#6#0#0| T@U) (|a#6#1#0| T@U) ) (!  (=> (and (= (type |a#6#0#0|) BoxType) (= (type |a#6#1#0|) BoxType)) (< (BoxRank |a#6#0#0|) (DtRank (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))))
 :qid |unknown.0:0|
 :skolemid |869|
 :pattern ( (|#_System._tuple#2._#Make2| |a#6#0#0| |a#6#1#0|))
)))
(assert (forall ((|a#7#0#0| T@U) (|a#7#1#0| T@U) ) (!  (=> (and (= (type |a#7#0#0|) BoxType) (= (type |a#7#1#0|) BoxType)) (= (_System.Tuple2._1 (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|)) |a#7#1#0|))
 :qid |unknown.0:0|
 :skolemid |870|
 :pattern ( (|#_System._tuple#2._#Make2| |a#7#0#0| |a#7#1#0|))
)))
(assert (forall ((|a#8#0#0| T@U) (|a#8#1#0| T@U) ) (!  (=> (and (= (type |a#8#0#0|) BoxType) (= (type |a#8#1#0|) BoxType)) (< (BoxRank |a#8#1#0|) (DtRank (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))))
 :qid |unknown.0:0|
 :skolemid |871|
 :pattern ( (|#_System._tuple#2._#Make2| |a#8#0#0| |a#8#1#0|))
)))
(assert (forall ((d@@4 T@U) ) (!  (=> (and (= (type d@@4) DatatypeTypeType) (|$IsA#_System.Tuple2| d@@4)) (_System.Tuple2.___hMake2_q d@@4))
 :qid |unknown.0:0|
 :skolemid |872|
 :pattern ( (|$IsA#_System.Tuple2| d@@4))
)))
(assert (forall ((|_System._tuple#2$T0@@7| T@U) (|_System._tuple#2$T1@@7| T@U) (d@@5 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2$T0@@7|) TyType) (= (type |_System._tuple#2$T1@@7|) TyType)) (= (type d@@5) DatatypeTypeType)) ($Is d@@5 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|))) (_System.Tuple2.___hMake2_q d@@5))
 :qid |unknown.0:0|
 :skolemid |873|
 :pattern ( (_System.Tuple2.___hMake2_q d@@5) ($Is d@@5 (Tclass._System.Tuple2 |_System._tuple#2$T0@@7| |_System._tuple#2$T1@@7|)))
)))
(assert (forall ((a@@100 T@U) (b@@61 T@U) ) (!  (=> (and (and (= (type a@@100) DatatypeTypeType) (= (type b@@61) DatatypeTypeType)) true) (= (|_System.Tuple2#Equal| a@@100 b@@61)  (and (= (_System.Tuple2._0 a@@100) (_System.Tuple2._0 b@@61)) (= (_System.Tuple2._1 a@@100) (_System.Tuple2._1 b@@61)))))
 :qid |unknown.0:0|
 :skolemid |874|
 :pattern ( (|_System.Tuple2#Equal| a@@100 b@@61))
)))
(assert (forall ((a@@101 T@U) (b@@62 T@U) ) (!  (=> (and (= (type a@@101) DatatypeTypeType) (= (type b@@62) DatatypeTypeType)) (= (|_System.Tuple2#Equal| a@@101 b@@62) (= a@@101 b@@62)))
 :qid |unknown.0:0|
 :skolemid |875|
 :pattern ( (|_System.Tuple2#Equal| a@@101 b@@62))
)))
(assert (forall ((arg0@@170 T@U) (arg1@@80 T@U) (arg2@@32 T@U) (arg3@@12 T@U) (arg4@@4 T@U) ) (! (= (type (Tclass._System.___hFunc4 arg0@@170 arg1@@80 arg2@@32 arg3@@12 arg4@@4)) TyType)
 :qid |funType:Tclass._System.___hFunc4|
 :pattern ( (Tclass._System.___hFunc4 arg0@@170 arg1@@80 arg2@@32 arg3@@12 arg4@@4))
)))
(assert (forall ((|#$T0@@34| T@U) (|#$T1@@18| T@U) (|#$T2| T@U) (|#$T3| T@U) (|#$R@@47| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@34|) TyType) (= (type |#$T1@@18|) TyType)) (= (type |#$T2|) TyType)) (= (type |#$T3|) TyType)) (= (type |#$R@@47|) TyType)) (and (= (Tag (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|)) Tagclass._System.___hFunc4) (= (TagFamily (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|)) |tytagFamily$_#Func4|)))
 :qid |unknown.0:0|
 :skolemid |876|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@34| |#$T1@@18| |#$T2| |#$T3| |#$R@@47|))
)))
(assert (forall ((arg0@@171 T@U) ) (! (= (type (Tclass._System.___hFunc4_0 arg0@@171)) TyType)
 :qid |funType:Tclass._System.___hFunc4_0|
 :pattern ( (Tclass._System.___hFunc4_0 arg0@@171))
)))
(assert (forall ((|#$T0@@35| T@U) (|#$T1@@19| T@U) (|#$T2@@0| T@U) (|#$T3@@0| T@U) (|#$R@@48| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@35|) TyType) (= (type |#$T1@@19|) TyType)) (= (type |#$T2@@0|) TyType)) (= (type |#$T3@@0|) TyType)) (= (type |#$R@@48|) TyType)) (= (Tclass._System.___hFunc4_0 (Tclass._System.___hFunc4 |#$T0@@35| |#$T1@@19| |#$T2@@0| |#$T3@@0| |#$R@@48|)) |#$T0@@35|))
 :qid |unknown.0:0|
 :skolemid |877|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@35| |#$T1@@19| |#$T2@@0| |#$T3@@0| |#$R@@48|))
)))
(assert (forall ((arg0@@172 T@U) ) (! (= (type (Tclass._System.___hFunc4_1 arg0@@172)) TyType)
 :qid |funType:Tclass._System.___hFunc4_1|
 :pattern ( (Tclass._System.___hFunc4_1 arg0@@172))
)))
(assert (forall ((|#$T0@@36| T@U) (|#$T1@@20| T@U) (|#$T2@@1| T@U) (|#$T3@@1| T@U) (|#$R@@49| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@36|) TyType) (= (type |#$T1@@20|) TyType)) (= (type |#$T2@@1|) TyType)) (= (type |#$T3@@1|) TyType)) (= (type |#$R@@49|) TyType)) (= (Tclass._System.___hFunc4_1 (Tclass._System.___hFunc4 |#$T0@@36| |#$T1@@20| |#$T2@@1| |#$T3@@1| |#$R@@49|)) |#$T1@@20|))
 :qid |unknown.0:0|
 :skolemid |878|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@36| |#$T1@@20| |#$T2@@1| |#$T3@@1| |#$R@@49|))
)))
(assert (forall ((arg0@@173 T@U) ) (! (= (type (Tclass._System.___hFunc4_2 arg0@@173)) TyType)
 :qid |funType:Tclass._System.___hFunc4_2|
 :pattern ( (Tclass._System.___hFunc4_2 arg0@@173))
)))
(assert (forall ((|#$T0@@37| T@U) (|#$T1@@21| T@U) (|#$T2@@2| T@U) (|#$T3@@2| T@U) (|#$R@@50| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@37|) TyType) (= (type |#$T1@@21|) TyType)) (= (type |#$T2@@2|) TyType)) (= (type |#$T3@@2|) TyType)) (= (type |#$R@@50|) TyType)) (= (Tclass._System.___hFunc4_2 (Tclass._System.___hFunc4 |#$T0@@37| |#$T1@@21| |#$T2@@2| |#$T3@@2| |#$R@@50|)) |#$T2@@2|))
 :qid |unknown.0:0|
 :skolemid |879|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@37| |#$T1@@21| |#$T2@@2| |#$T3@@2| |#$R@@50|))
)))
(assert (forall ((arg0@@174 T@U) ) (! (= (type (Tclass._System.___hFunc4_3 arg0@@174)) TyType)
 :qid |funType:Tclass._System.___hFunc4_3|
 :pattern ( (Tclass._System.___hFunc4_3 arg0@@174))
)))
(assert (forall ((|#$T0@@38| T@U) (|#$T1@@22| T@U) (|#$T2@@3| T@U) (|#$T3@@3| T@U) (|#$R@@51| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@38|) TyType) (= (type |#$T1@@22|) TyType)) (= (type |#$T2@@3|) TyType)) (= (type |#$T3@@3|) TyType)) (= (type |#$R@@51|) TyType)) (= (Tclass._System.___hFunc4_3 (Tclass._System.___hFunc4 |#$T0@@38| |#$T1@@22| |#$T2@@3| |#$T3@@3| |#$R@@51|)) |#$T3@@3|))
 :qid |unknown.0:0|
 :skolemid |880|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@38| |#$T1@@22| |#$T2@@3| |#$T3@@3| |#$R@@51|))
)))
(assert (forall ((arg0@@175 T@U) ) (! (= (type (Tclass._System.___hFunc4_4 arg0@@175)) TyType)
 :qid |funType:Tclass._System.___hFunc4_4|
 :pattern ( (Tclass._System.___hFunc4_4 arg0@@175))
)))
(assert (forall ((|#$T0@@39| T@U) (|#$T1@@23| T@U) (|#$T2@@4| T@U) (|#$T3@@4| T@U) (|#$R@@52| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@39|) TyType) (= (type |#$T1@@23|) TyType)) (= (type |#$T2@@4|) TyType)) (= (type |#$T3@@4|) TyType)) (= (type |#$R@@52|) TyType)) (= (Tclass._System.___hFunc4_4 (Tclass._System.___hFunc4 |#$T0@@39| |#$T1@@23| |#$T2@@4| |#$T3@@4| |#$R@@52|)) |#$R@@52|))
 :qid |unknown.0:0|
 :skolemid |881|
 :pattern ( (Tclass._System.___hFunc4 |#$T0@@39| |#$T1@@23| |#$T2@@4| |#$T3@@4| |#$R@@52|))
)))
(assert (forall ((|#$T0@@40| T@U) (|#$T1@@24| T@U) (|#$T2@@5| T@U) (|#$T3@@5| T@U) (|#$R@@53| T@U) (bx@@51 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@40|) TyType) (= (type |#$T1@@24|) TyType)) (= (type |#$T2@@5|) TyType)) (= (type |#$T3@@5|) TyType)) (= (type |#$R@@53|) TyType)) (= (type bx@@51) BoxType)) ($IsBox bx@@51 (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|))) (and (= ($Box ($Unbox HandleTypeType bx@@51)) bx@@51) ($Is ($Unbox HandleTypeType bx@@51) (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|))))
 :qid |unknown.0:0|
 :skolemid |882|
 :pattern ( ($IsBox bx@@51 (Tclass._System.___hFunc4 |#$T0@@40| |#$T1@@24| |#$T2@@5| |#$T3@@5| |#$R@@53|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@176 T@T) (arg1@@81 T@T) (arg2@@33 T@T) (arg3@@13 T@T) (arg4@@5 T@T) (arg5@@1 T@T) ) (! (= (Ctor (MapType4Type arg0@@176 arg1@@81 arg2@@33 arg3@@13 arg4@@5 arg5@@1)) 26)
 :qid |ctor:MapType4Type|
)) (forall ((arg0@@177 T@T) (arg1@@82 T@T) (arg2@@34 T@T) (arg3@@14 T@T) (arg4@@6 T@T) (arg5@@2 T@T) ) (! (= (MapType4TypeInv0 (MapType4Type arg0@@177 arg1@@82 arg2@@34 arg3@@14 arg4@@6 arg5@@2)) arg0@@177)
 :qid |typeInv:MapType4TypeInv0|
 :pattern ( (MapType4Type arg0@@177 arg1@@82 arg2@@34 arg3@@14 arg4@@6 arg5@@2))
))) (forall ((arg0@@178 T@T) (arg1@@83 T@T) (arg2@@35 T@T) (arg3@@15 T@T) (arg4@@7 T@T) (arg5@@3 T@T) ) (! (= (MapType4TypeInv1 (MapType4Type arg0@@178 arg1@@83 arg2@@35 arg3@@15 arg4@@7 arg5@@3)) arg1@@83)
 :qid |typeInv:MapType4TypeInv1|
 :pattern ( (MapType4Type arg0@@178 arg1@@83 arg2@@35 arg3@@15 arg4@@7 arg5@@3))
))) (forall ((arg0@@179 T@T) (arg1@@84 T@T) (arg2@@36 T@T) (arg3@@16 T@T) (arg4@@8 T@T) (arg5@@4 T@T) ) (! (= (MapType4TypeInv2 (MapType4Type arg0@@179 arg1@@84 arg2@@36 arg3@@16 arg4@@8 arg5@@4)) arg2@@36)
 :qid |typeInv:MapType4TypeInv2|
 :pattern ( (MapType4Type arg0@@179 arg1@@84 arg2@@36 arg3@@16 arg4@@8 arg5@@4))
))) (forall ((arg0@@180 T@T) (arg1@@85 T@T) (arg2@@37 T@T) (arg3@@17 T@T) (arg4@@9 T@T) (arg5@@5 T@T) ) (! (= (MapType4TypeInv3 (MapType4Type arg0@@180 arg1@@85 arg2@@37 arg3@@17 arg4@@9 arg5@@5)) arg3@@17)
 :qid |typeInv:MapType4TypeInv3|
 :pattern ( (MapType4Type arg0@@180 arg1@@85 arg2@@37 arg3@@17 arg4@@9 arg5@@5))
))) (forall ((arg0@@181 T@T) (arg1@@86 T@T) (arg2@@38 T@T) (arg3@@18 T@T) (arg4@@10 T@T) (arg5@@6 T@T) ) (! (= (MapType4TypeInv4 (MapType4Type arg0@@181 arg1@@86 arg2@@38 arg3@@18 arg4@@10 arg5@@6)) arg4@@10)
 :qid |typeInv:MapType4TypeInv4|
 :pattern ( (MapType4Type arg0@@181 arg1@@86 arg2@@38 arg3@@18 arg4@@10 arg5@@6))
))) (forall ((arg0@@182 T@T) (arg1@@87 T@T) (arg2@@39 T@T) (arg3@@19 T@T) (arg4@@11 T@T) (arg5@@7 T@T) ) (! (= (MapType4TypeInv5 (MapType4Type arg0@@182 arg1@@87 arg2@@39 arg3@@19 arg4@@11 arg5@@7)) arg5@@7)
 :qid |typeInv:MapType4TypeInv5|
 :pattern ( (MapType4Type arg0@@182 arg1@@87 arg2@@39 arg3@@19 arg4@@11 arg5@@7))
))) (forall ((arg0@@183 T@U) (arg1@@88 T@U) (arg2@@40 T@U) (arg3@@20 T@U) (arg4@@12 T@U) (arg5@@8 T@U) ) (! (let ((aVar5 (MapType4TypeInv5 (type arg0@@183))))
(= (type (MapType4Select arg0@@183 arg1@@88 arg2@@40 arg3@@20 arg4@@12 arg5@@8)) aVar5))
 :qid |funType:MapType4Select|
 :pattern ( (MapType4Select arg0@@183 arg1@@88 arg2@@40 arg3@@20 arg4@@12 arg5@@8))
))) (forall ((arg0@@184 T@U) (arg1@@89 T@U) (arg2@@41 T@U) (arg3@@21 T@U) (arg4@@13 T@U) (arg5@@9 T@U) (arg6@@1 T@U) ) (! (let ((aVar5@@0 (type arg6@@1)))
(let ((aVar4 (type arg5@@9)))
(let ((aVar3@@2 (type arg4@@13)))
(let ((aVar2@@3 (type arg3@@21)))
(let ((aVar1@@4 (type arg2@@41)))
(let ((aVar0@@2 (type arg1@@89)))
(= (type (MapType4Store arg0@@184 arg1@@89 arg2@@41 arg3@@21 arg4@@13 arg5@@9 arg6@@1)) (MapType4Type aVar0@@2 aVar1@@4 aVar2@@3 aVar3@@2 aVar4 aVar5@@0))))))))
 :qid |funType:MapType4Store|
 :pattern ( (MapType4Store arg0@@184 arg1@@89 arg2@@41 arg3@@21 arg4@@13 arg5@@9 arg6@@1))
))) (forall ((m@@54 T@U) (x0@@14 T@U) (x1@@8 T@U) (x2@@4 T@U) (x3 T@U) (x4 T@U) (val@@15 T@U) ) (! (let ((aVar5@@1 (MapType4TypeInv5 (type m@@54))))
 (=> (= (type val@@15) aVar5@@1) (= (MapType4Select (MapType4Store m@@54 x0@@14 x1@@8 x2@@4 x3 x4 val@@15) x0@@14 x1@@8 x2@@4 x3 x4) val@@15)))
 :qid |mapAx0:MapType4Select|
 :weight 0
))) (and (and (and (and (and (forall ((val@@16 T@U) (m@@55 T@U) (x0@@15 T@U) (x1@@9 T@U) (x2@@5 T@U) (x3@@0 T@U) (x4@@0 T@U) (y0@@10 T@U) (y1@@6 T@U) (y2@@3 T@U) (y3 T@U) (y4 T@U) ) (!  (or (= x0@@15 y0@@10) (= (MapType4Select (MapType4Store m@@55 x0@@15 x1@@9 x2@@5 x3@@0 x4@@0 val@@16) y0@@10 y1@@6 y2@@3 y3 y4) (MapType4Select m@@55 y0@@10 y1@@6 y2@@3 y3 y4)))
 :qid |mapAx1:MapType4Select:0|
 :weight 0
)) (forall ((val@@17 T@U) (m@@56 T@U) (x0@@16 T@U) (x1@@10 T@U) (x2@@6 T@U) (x3@@1 T@U) (x4@@1 T@U) (y0@@11 T@U) (y1@@7 T@U) (y2@@4 T@U) (y3@@0 T@U) (y4@@0 T@U) ) (!  (or (= x1@@10 y1@@7) (= (MapType4Select (MapType4Store m@@56 x0@@16 x1@@10 x2@@6 x3@@1 x4@@1 val@@17) y0@@11 y1@@7 y2@@4 y3@@0 y4@@0) (MapType4Select m@@56 y0@@11 y1@@7 y2@@4 y3@@0 y4@@0)))
 :qid |mapAx1:MapType4Select:1|
 :weight 0
))) (forall ((val@@18 T@U) (m@@57 T@U) (x0@@17 T@U) (x1@@11 T@U) (x2@@7 T@U) (x3@@2 T@U) (x4@@2 T@U) (y0@@12 T@U) (y1@@8 T@U) (y2@@5 T@U) (y3@@1 T@U) (y4@@1 T@U) ) (!  (or (= x2@@7 y2@@5) (= (MapType4Select (MapType4Store m@@57 x0@@17 x1@@11 x2@@7 x3@@2 x4@@2 val@@18) y0@@12 y1@@8 y2@@5 y3@@1 y4@@1) (MapType4Select m@@57 y0@@12 y1@@8 y2@@5 y3@@1 y4@@1)))
 :qid |mapAx1:MapType4Select:2|
 :weight 0
))) (forall ((val@@19 T@U) (m@@58 T@U) (x0@@18 T@U) (x1@@12 T@U) (x2@@8 T@U) (x3@@3 T@U) (x4@@3 T@U) (y0@@13 T@U) (y1@@9 T@U) (y2@@6 T@U) (y3@@2 T@U) (y4@@2 T@U) ) (!  (or (= x3@@3 y3@@2) (= (MapType4Select (MapType4Store m@@58 x0@@18 x1@@12 x2@@8 x3@@3 x4@@3 val@@19) y0@@13 y1@@9 y2@@6 y3@@2 y4@@2) (MapType4Select m@@58 y0@@13 y1@@9 y2@@6 y3@@2 y4@@2)))
 :qid |mapAx1:MapType4Select:3|
 :weight 0
))) (forall ((val@@20 T@U) (m@@59 T@U) (x0@@19 T@U) (x1@@13 T@U) (x2@@9 T@U) (x3@@4 T@U) (x4@@4 T@U) (y0@@14 T@U) (y1@@10 T@U) (y2@@7 T@U) (y3@@3 T@U) (y4@@3 T@U) ) (!  (or (= x4@@4 y4@@3) (= (MapType4Select (MapType4Store m@@59 x0@@19 x1@@13 x2@@9 x3@@4 x4@@4 val@@20) y0@@14 y1@@10 y2@@7 y3@@3 y4@@3) (MapType4Select m@@59 y0@@14 y1@@10 y2@@7 y3@@3 y4@@3)))
 :qid |mapAx1:MapType4Select:4|
 :weight 0
))) (forall ((val@@21 T@U) (m@@60 T@U) (x0@@20 T@U) (x1@@14 T@U) (x2@@10 T@U) (x3@@5 T@U) (x4@@5 T@U) (y0@@15 T@U) (y1@@11 T@U) (y2@@8 T@U) (y3@@4 T@U) (y4@@4 T@U) ) (!  (or true (= (MapType4Select (MapType4Store m@@60 x0@@20 x1@@14 x2@@10 x3@@5 x4@@5 val@@21) y0@@15 y1@@11 y2@@8 y3@@4 y4@@4) (MapType4Select m@@60 y0@@15 y1@@11 y2@@8 y3@@4 y4@@4)))
 :qid |mapAx2:MapType4Select|
 :weight 0
)))) (forall ((arg0@@185 T@U) (arg1@@90 T@U) (arg2@@42 T@U) (arg3@@22 T@U) (arg4@@14 T@U) (arg5@@10 T@U) (arg6@@2 T@U) (arg7 T@U) (arg8 T@U) (arg9 T@U) (arg10 T@U) ) (! (= (type (Apply4 arg0@@185 arg1@@90 arg2@@42 arg3@@22 arg4@@14 arg5@@10 arg6@@2 arg7 arg8 arg9 arg10)) BoxType)
 :qid |funType:Apply4|
 :pattern ( (Apply4 arg0@@185 arg1@@90 arg2@@42 arg3@@22 arg4@@14 arg5@@10 arg6@@2 arg7 arg8 arg9 arg10))
))) (forall ((arg0@@186 T@U) (arg1@@91 T@U) (arg2@@43 T@U) ) (! (= (type (Handle4 arg0@@186 arg1@@91 arg2@@43)) HandleTypeType)
 :qid |funType:Handle4|
 :pattern ( (Handle4 arg0@@186 arg1@@91 arg2@@43))
))))
(assert (forall ((t0@@61 T@U) (t1@@37 T@U) (t2@@14 T@U) (t3 T@U) (t4 T@U) (heap@@16 T@U) (h@@39 T@U) (r@@18 T@U) (rd@@8 T@U) (bx0@@27 T@U) (bx1@@13 T@U) (bx2 T@U) (bx3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@61) TyType) (= (type t1@@37) TyType)) (= (type t2@@14) TyType)) (= (type t3) TyType)) (= (type t4) TyType)) (= (type heap@@16) (MapType0Type refType MapType1Type))) (= (type h@@39) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@18) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@8) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@27) BoxType)) (= (type bx1@@13) BoxType)) (= (type bx2) BoxType)) (= (type bx3) BoxType)) (= (Apply4 t0@@61 t1@@37 t2@@14 t3 t4 heap@@16 (Handle4 h@@39 r@@18 rd@@8) bx0@@27 bx1@@13 bx2 bx3) (MapType4Select h@@39 heap@@16 bx0@@27 bx1@@13 bx2 bx3)))
 :qid |unknown.0:0|
 :skolemid |883|
 :pattern ( (Apply4 t0@@61 t1@@37 t2@@14 t3 t4 heap@@16 (Handle4 h@@39 r@@18 rd@@8) bx0@@27 bx1@@13 bx2 bx3))
)))
(assert (forall ((t0@@62 T@U) (t1@@38 T@U) (t2@@15 T@U) (t3@@0 T@U) (t4@@0 T@U) (heap@@17 T@U) (h@@40 T@U) (r@@19 T@U) (rd@@9 T@U) (bx0@@28 T@U) (bx1@@14 T@U) (bx2@@0 T@U) (bx3@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@62) TyType) (= (type t1@@38) TyType)) (= (type t2@@15) TyType)) (= (type t3@@0) TyType)) (= (type t4@@0) TyType)) (= (type heap@@17) (MapType0Type refType MapType1Type))) (= (type h@@40) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@19) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@9) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@28) BoxType)) (= (type bx1@@14) BoxType)) (= (type bx2@@0) BoxType)) (= (type bx3@@0) BoxType)) (U_2_bool (MapType4Select r@@19 heap@@17 bx0@@28 bx1@@14 bx2@@0 bx3@@0))) (Requires4 t0@@62 t1@@38 t2@@15 t3@@0 t4@@0 heap@@17 (Handle4 h@@40 r@@19 rd@@9) bx0@@28 bx1@@14 bx2@@0 bx3@@0))
 :qid |unknown.0:0|
 :skolemid |884|
 :pattern ( (Requires4 t0@@62 t1@@38 t2@@15 t3@@0 t4@@0 heap@@17 (Handle4 h@@40 r@@19 rd@@9) bx0@@28 bx1@@14 bx2@@0 bx3@@0))
)))
(assert (forall ((arg0@@187 T@U) (arg1@@92 T@U) (arg2@@44 T@U) (arg3@@23 T@U) (arg4@@15 T@U) (arg5@@11 T@U) (arg6@@3 T@U) (arg7@@0 T@U) (arg8@@0 T@U) (arg9@@0 T@U) (arg10@@0 T@U) ) (! (= (type (Reads4 arg0@@187 arg1@@92 arg2@@44 arg3@@23 arg4@@15 arg5@@11 arg6@@3 arg7@@0 arg8@@0 arg9@@0 arg10@@0)) (MapType0Type BoxType boolType))
 :qid |funType:Reads4|
 :pattern ( (Reads4 arg0@@187 arg1@@92 arg2@@44 arg3@@23 arg4@@15 arg5@@11 arg6@@3 arg7@@0 arg8@@0 arg9@@0 arg10@@0))
)))
(assert (forall ((t0@@63 T@U) (t1@@39 T@U) (t2@@16 T@U) (t3@@1 T@U) (t4@@1 T@U) (heap@@18 T@U) (h@@41 T@U) (r@@20 T@U) (rd@@10 T@U) (bx0@@29 T@U) (bx1@@15 T@U) (bx2@@1 T@U) (bx3@@1 T@U) (bx@@52 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@63) TyType) (= (type t1@@39) TyType)) (= (type t2@@16) TyType)) (= (type t3@@1) TyType)) (= (type t4@@1) TyType)) (= (type heap@@18) (MapType0Type refType MapType1Type))) (= (type h@@41) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType BoxType))) (= (type r@@20) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType boolType))) (= (type rd@@10) (MapType4Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@29) BoxType)) (= (type bx1@@15) BoxType)) (= (type bx2@@1) BoxType)) (= (type bx3@@1) BoxType)) (= (type bx@@52) BoxType)) (= (U_2_bool (MapType0Select (Reads4 t0@@63 t1@@39 t2@@16 t3@@1 t4@@1 heap@@18 (Handle4 h@@41 r@@20 rd@@10) bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52)) (U_2_bool (MapType0Select (MapType4Select rd@@10 heap@@18 bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52))))
 :qid |unknown.0:0|
 :skolemid |885|
 :pattern ( (MapType0Select (Reads4 t0@@63 t1@@39 t2@@16 t3@@1 t4@@1 heap@@18 (Handle4 h@@41 r@@20 rd@@10) bx0@@29 bx1@@15 bx2@@1 bx3@@1) bx@@52))
)))
(assert (forall ((t0@@64 T@U) (t1@@40 T@U) (t2@@17 T@U) (t3@@2 T@U) (t4@@2 T@U) (h0@@18 T@U) (h1@@18 T@U) (f@@41 T@U) (bx0@@30 T@U) (bx1@@16 T@U) (bx2@@2 T@U) (bx3@@2 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@64) TyType) (= (type t1@@40) TyType)) (= (type t2@@17) TyType)) (= (type t3@@2) TyType)) (= (type t4@@2) TyType)) (= (type h0@@18) (MapType0Type refType MapType1Type))) (= (type h1@@18) (MapType0Type refType MapType1Type))) (= (type f@@41) HandleTypeType)) (= (type bx0@@30) BoxType)) (= (type bx1@@16) BoxType)) (= (type bx2@@2) BoxType)) (= (type bx3@@2) BoxType)) (and (and (and ($HeapSucc h0@@18 h1@@18) (and ($IsGoodHeap h0@@18) ($IsGoodHeap h1@@18))) (and (and (and (and ($IsBox bx0@@30 t0@@64) ($IsBox bx1@@16 t1@@40)) ($IsBox bx2@@2 t2@@17)) ($IsBox bx3@@2 t3@@2)) ($Is f@@41 (Tclass._System.___hFunc4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2)))) (forall ((o@@62 T@U) (fld@@17 T@U) ) (! (let ((a@@102 (FieldTypeInv0 (type fld@@17))))
 (=> (and (and (= (type o@@62) refType) (= (type fld@@17) (FieldType a@@102))) (and (not (= o@@62 null)) (U_2_bool (MapType0Select (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h0@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2) ($Box o@@62))))) (= (MapType1Select (MapType0Select h0@@18 o@@62) fld@@17) (MapType1Select (MapType0Select h1@@18 o@@62) fld@@17))))
 :qid |unknown.0:0|
 :skolemid |886|
 :no-pattern (type o@@62)
 :no-pattern (type fld@@17)
 :no-pattern (U_2_int o@@62)
 :no-pattern (U_2_bool o@@62)
 :no-pattern (U_2_int fld@@17)
 :no-pattern (U_2_bool fld@@17)
)))) (= (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h0@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2) (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h1@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2)))
 :qid |unknown.0:0|
 :skolemid |887|
 :pattern ( ($HeapSucc h0@@18 h1@@18) (Reads4 t0@@64 t1@@40 t2@@17 t3@@2 t4@@2 h1@@18 f@@41 bx0@@30 bx1@@16 bx2@@2 bx3@@2))
)))
(assert (forall ((t0@@65 T@U) (t1@@41 T@U) (t2@@18 T@U) (t3@@3 T@U) (t4@@3 T@U) (h0@@19 T@U) (h1@@19 T@U) (f@@42 T@U) (bx0@@31 T@U) (bx1@@17 T@U) (bx2@@3 T@U) (bx3@@3 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@65) TyType) (= (type t1@@41) TyType)) (= (type t2@@18) TyType)) (= (type t3@@3) TyType)) (= (type t4@@3) TyType)) (= (type h0@@19) (MapType0Type refType MapType1Type))) (= (type h1@@19) (MapType0Type refType MapType1Type))) (= (type f@@42) HandleTypeType)) (= (type bx0@@31) BoxType)) (= (type bx1@@17) BoxType)) (= (type bx2@@3) BoxType)) (= (type bx3@@3) BoxType)) (and (and (and ($HeapSucc h0@@19 h1@@19) (and ($IsGoodHeap h0@@19) ($IsGoodHeap h1@@19))) (and (and (and (and ($IsBox bx0@@31 t0@@65) ($IsBox bx1@@17 t1@@41)) ($IsBox bx2@@3 t2@@18)) ($IsBox bx3@@3 t3@@3)) ($Is f@@42 (Tclass._System.___hFunc4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3)))) (forall ((o@@63 T@U) (fld@@18 T@U) ) (! (let ((a@@103 (FieldTypeInv0 (type fld@@18))))
 (=> (and (and (= (type o@@63) refType) (= (type fld@@18) (FieldType a@@103))) (and (not (= o@@63 null)) (U_2_bool (MapType0Select (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3) ($Box o@@63))))) (= (MapType1Select (MapType0Select h0@@19 o@@63) fld@@18) (MapType1Select (MapType0Select h1@@19 o@@63) fld@@18))))
 :qid |unknown.0:0|
 :skolemid |888|
 :no-pattern (type o@@63)
 :no-pattern (type fld@@18)
 :no-pattern (U_2_int o@@63)
 :no-pattern (U_2_bool o@@63)
 :no-pattern (U_2_int fld@@18)
 :no-pattern (U_2_bool fld@@18)
)))) (= (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h0@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3) (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3)))
 :qid |unknown.0:0|
 :skolemid |889|
 :pattern ( ($HeapSucc h0@@19 h1@@19) (Reads4 t0@@65 t1@@41 t2@@18 t3@@3 t4@@3 h1@@19 f@@42 bx0@@31 bx1@@17 bx2@@3 bx3@@3))
)))
(assert (forall ((t0@@66 T@U) (t1@@42 T@U) (t2@@19 T@U) (t3@@4 T@U) (t4@@4 T@U) (h0@@20 T@U) (h1@@20 T@U) (f@@43 T@U) (bx0@@32 T@U) (bx1@@18 T@U) (bx2@@4 T@U) (bx3@@4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@66) TyType) (= (type t1@@42) TyType)) (= (type t2@@19) TyType)) (= (type t3@@4) TyType)) (= (type t4@@4) TyType)) (= (type h0@@20) (MapType0Type refType MapType1Type))) (= (type h1@@20) (MapType0Type refType MapType1Type))) (= (type f@@43) HandleTypeType)) (= (type bx0@@32) BoxType)) (= (type bx1@@18) BoxType)) (= (type bx2@@4) BoxType)) (= (type bx3@@4) BoxType)) (and (and (and ($HeapSucc h0@@20 h1@@20) (and ($IsGoodHeap h0@@20) ($IsGoodHeap h1@@20))) (and (and (and (and ($IsBox bx0@@32 t0@@66) ($IsBox bx1@@18 t1@@42)) ($IsBox bx2@@4 t2@@19)) ($IsBox bx3@@4 t3@@4)) ($Is f@@43 (Tclass._System.___hFunc4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4)))) (forall ((o@@64 T@U) (fld@@19 T@U) ) (! (let ((a@@104 (FieldTypeInv0 (type fld@@19))))
 (=> (and (and (= (type o@@64) refType) (= (type fld@@19) (FieldType a@@104))) (and (not (= o@@64 null)) (U_2_bool (MapType0Select (Reads4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h0@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4) ($Box o@@64))))) (= (MapType1Select (MapType0Select h0@@20 o@@64) fld@@19) (MapType1Select (MapType0Select h1@@20 o@@64) fld@@19))))
 :qid |unknown.0:0|
 :skolemid |890|
 :no-pattern (type o@@64)
 :no-pattern (type fld@@19)
 :no-pattern (U_2_int o@@64)
 :no-pattern (U_2_bool o@@64)
 :no-pattern (U_2_int fld@@19)
 :no-pattern (U_2_bool fld@@19)
)))) (= (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h0@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4) (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h1@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4)))
 :qid |unknown.0:0|
 :skolemid |891|
 :pattern ( ($HeapSucc h0@@20 h1@@20) (Requires4 t0@@66 t1@@42 t2@@19 t3@@4 t4@@4 h1@@20 f@@43 bx0@@32 bx1@@18 bx2@@4 bx3@@4))
)))
(assert (forall ((t0@@67 T@U) (t1@@43 T@U) (t2@@20 T@U) (t3@@5 T@U) (t4@@5 T@U) (h0@@21 T@U) (h1@@21 T@U) (f@@44 T@U) (bx0@@33 T@U) (bx1@@19 T@U) (bx2@@5 T@U) (bx3@@5 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@67) TyType) (= (type t1@@43) TyType)) (= (type t2@@20) TyType)) (= (type t3@@5) TyType)) (= (type t4@@5) TyType)) (= (type h0@@21) (MapType0Type refType MapType1Type))) (= (type h1@@21) (MapType0Type refType MapType1Type))) (= (type f@@44) HandleTypeType)) (= (type bx0@@33) BoxType)) (= (type bx1@@19) BoxType)) (= (type bx2@@5) BoxType)) (= (type bx3@@5) BoxType)) (and (and (and ($HeapSucc h0@@21 h1@@21) (and ($IsGoodHeap h0@@21) ($IsGoodHeap h1@@21))) (and (and (and (and ($IsBox bx0@@33 t0@@67) ($IsBox bx1@@19 t1@@43)) ($IsBox bx2@@5 t2@@20)) ($IsBox bx3@@5 t3@@5)) ($Is f@@44 (Tclass._System.___hFunc4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5)))) (forall ((o@@65 T@U) (fld@@20 T@U) ) (! (let ((a@@105 (FieldTypeInv0 (type fld@@20))))
 (=> (and (and (= (type o@@65) refType) (= (type fld@@20) (FieldType a@@105))) (and (not (= o@@65 null)) (U_2_bool (MapType0Select (Reads4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5) ($Box o@@65))))) (= (MapType1Select (MapType0Select h0@@21 o@@65) fld@@20) (MapType1Select (MapType0Select h1@@21 o@@65) fld@@20))))
 :qid |unknown.0:0|
 :skolemid |892|
 :no-pattern (type o@@65)
 :no-pattern (type fld@@20)
 :no-pattern (U_2_int o@@65)
 :no-pattern (U_2_bool o@@65)
 :no-pattern (U_2_int fld@@20)
 :no-pattern (U_2_bool fld@@20)
)))) (= (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h0@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5) (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5)))
 :qid |unknown.0:0|
 :skolemid |893|
 :pattern ( ($HeapSucc h0@@21 h1@@21) (Requires4 t0@@67 t1@@43 t2@@20 t3@@5 t4@@5 h1@@21 f@@44 bx0@@33 bx1@@19 bx2@@5 bx3@@5))
)))
(assert (forall ((t0@@68 T@U) (t1@@44 T@U) (t2@@21 T@U) (t3@@6 T@U) (t4@@6 T@U) (h0@@22 T@U) (h1@@22 T@U) (f@@45 T@U) (bx0@@34 T@U) (bx1@@20 T@U) (bx2@@6 T@U) (bx3@@6 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@68) TyType) (= (type t1@@44) TyType)) (= (type t2@@21) TyType)) (= (type t3@@6) TyType)) (= (type t4@@6) TyType)) (= (type h0@@22) (MapType0Type refType MapType1Type))) (= (type h1@@22) (MapType0Type refType MapType1Type))) (= (type f@@45) HandleTypeType)) (= (type bx0@@34) BoxType)) (= (type bx1@@20) BoxType)) (= (type bx2@@6) BoxType)) (= (type bx3@@6) BoxType)) (and (and (and ($HeapSucc h0@@22 h1@@22) (and ($IsGoodHeap h0@@22) ($IsGoodHeap h1@@22))) (and (and (and (and ($IsBox bx0@@34 t0@@68) ($IsBox bx1@@20 t1@@44)) ($IsBox bx2@@6 t2@@21)) ($IsBox bx3@@6 t3@@6)) ($Is f@@45 (Tclass._System.___hFunc4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6)))) (forall ((o@@66 T@U) (fld@@21 T@U) ) (! (let ((a@@106 (FieldTypeInv0 (type fld@@21))))
 (=> (and (and (= (type o@@66) refType) (= (type fld@@21) (FieldType a@@106))) (and (not (= o@@66 null)) (U_2_bool (MapType0Select (Reads4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h0@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6) ($Box o@@66))))) (= (MapType1Select (MapType0Select h0@@22 o@@66) fld@@21) (MapType1Select (MapType0Select h1@@22 o@@66) fld@@21))))
 :qid |unknown.0:0|
 :skolemid |894|
 :no-pattern (type o@@66)
 :no-pattern (type fld@@21)
 :no-pattern (U_2_int o@@66)
 :no-pattern (U_2_bool o@@66)
 :no-pattern (U_2_int fld@@21)
 :no-pattern (U_2_bool fld@@21)
)))) (= (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h0@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6) (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h1@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6)))
 :qid |unknown.0:0|
 :skolemid |895|
 :pattern ( ($HeapSucc h0@@22 h1@@22) (Apply4 t0@@68 t1@@44 t2@@21 t3@@6 t4@@6 h1@@22 f@@45 bx0@@34 bx1@@20 bx2@@6 bx3@@6))
)))
(assert (forall ((t0@@69 T@U) (t1@@45 T@U) (t2@@22 T@U) (t3@@7 T@U) (t4@@7 T@U) (h0@@23 T@U) (h1@@23 T@U) (f@@46 T@U) (bx0@@35 T@U) (bx1@@21 T@U) (bx2@@7 T@U) (bx3@@7 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@69) TyType) (= (type t1@@45) TyType)) (= (type t2@@22) TyType)) (= (type t3@@7) TyType)) (= (type t4@@7) TyType)) (= (type h0@@23) (MapType0Type refType MapType1Type))) (= (type h1@@23) (MapType0Type refType MapType1Type))) (= (type f@@46) HandleTypeType)) (= (type bx0@@35) BoxType)) (= (type bx1@@21) BoxType)) (= (type bx2@@7) BoxType)) (= (type bx3@@7) BoxType)) (and (and (and ($HeapSucc h0@@23 h1@@23) (and ($IsGoodHeap h0@@23) ($IsGoodHeap h1@@23))) (and (and (and (and ($IsBox bx0@@35 t0@@69) ($IsBox bx1@@21 t1@@45)) ($IsBox bx2@@7 t2@@22)) ($IsBox bx3@@7 t3@@7)) ($Is f@@46 (Tclass._System.___hFunc4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7)))) (forall ((o@@67 T@U) (fld@@22 T@U) ) (! (let ((a@@107 (FieldTypeInv0 (type fld@@22))))
 (=> (and (and (= (type o@@67) refType) (= (type fld@@22) (FieldType a@@107))) (and (not (= o@@67 null)) (U_2_bool (MapType0Select (Reads4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7) ($Box o@@67))))) (= (MapType1Select (MapType0Select h0@@23 o@@67) fld@@22) (MapType1Select (MapType0Select h1@@23 o@@67) fld@@22))))
 :qid |unknown.0:0|
 :skolemid |896|
 :no-pattern (type o@@67)
 :no-pattern (type fld@@22)
 :no-pattern (U_2_int o@@67)
 :no-pattern (U_2_bool o@@67)
 :no-pattern (U_2_int fld@@22)
 :no-pattern (U_2_bool fld@@22)
)))) (= (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h0@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7) (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7)))
 :qid |unknown.0:0|
 :skolemid |897|
 :pattern ( ($HeapSucc h0@@23 h1@@23) (Apply4 t0@@69 t1@@45 t2@@22 t3@@7 t4@@7 h1@@23 f@@46 bx0@@35 bx1@@21 bx2@@7 bx3@@7))
)))
(assert (forall ((t0@@70 T@U) (t1@@46 T@U) (t2@@23 T@U) (t3@@8 T@U) (t4@@8 T@U) (heap@@19 T@U) (f@@47 T@U) (bx0@@36 T@U) (bx1@@22 T@U) (bx2@@8 T@U) (bx3@@8 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@70) TyType) (= (type t1@@46) TyType)) (= (type t2@@23) TyType)) (= (type t3@@8) TyType)) (= (type t4@@8) TyType)) (= (type heap@@19) (MapType0Type refType MapType1Type))) (= (type f@@47) HandleTypeType)) (= (type bx0@@36) BoxType)) (= (type bx1@@22) BoxType)) (= (type bx2@@8) BoxType)) (= (type bx3@@8) BoxType)) (and ($IsGoodHeap heap@@19) (and (and (and (and ($IsBox bx0@@36 t0@@70) ($IsBox bx1@@22 t1@@46)) ($IsBox bx2@@8 t2@@23)) ($IsBox bx3@@8 t3@@8)) ($Is f@@47 (Tclass._System.___hFunc4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8))))) (= (|Set#Equal| (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 $OneHeap f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) (|Set#Empty| BoxType)) (|Set#Equal| (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 heap@@19 f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |898|
 :pattern ( (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 $OneHeap f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8) ($IsGoodHeap heap@@19))
 :pattern ( (Reads4 t0@@70 t1@@46 t2@@23 t3@@8 t4@@8 heap@@19 f@@47 bx0@@36 bx1@@22 bx2@@8 bx3@@8))
)))
(assert (forall ((t0@@71 T@U) (t1@@47 T@U) (t2@@24 T@U) (t3@@9 T@U) (t4@@9 T@U) (heap@@20 T@U) (f@@48 T@U) (bx0@@37 T@U) (bx1@@23 T@U) (bx2@@9 T@U) (bx3@@9 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@71) TyType) (= (type t1@@47) TyType)) (= (type t2@@24) TyType)) (= (type t3@@9) TyType)) (= (type t4@@9) TyType)) (= (type heap@@20) (MapType0Type refType MapType1Type))) (= (type f@@48) HandleTypeType)) (= (type bx0@@37) BoxType)) (= (type bx1@@23) BoxType)) (= (type bx2@@9) BoxType)) (= (type bx3@@9) BoxType)) (and (and ($IsGoodHeap heap@@20) (and (and (and (and ($IsBox bx0@@37 t0@@71) ($IsBox bx1@@23 t1@@47)) ($IsBox bx2@@9 t2@@24)) ($IsBox bx3@@9 t3@@9)) ($Is f@@48 (Tclass._System.___hFunc4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9)))) (|Set#Equal| (Reads4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) (|Set#Empty| BoxType)))) (= (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 heap@@20 f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9)))
 :qid |unknown.0:0|
 :skolemid |899|
 :pattern ( (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 $OneHeap f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9) ($IsGoodHeap heap@@20))
 :pattern ( (Requires4 t0@@71 t1@@47 t2@@24 t3@@9 t4@@9 heap@@20 f@@48 bx0@@37 bx1@@23 bx2@@9 bx3@@9))
)))
(assert (forall ((f@@49 T@U) (t0@@72 T@U) (t1@@48 T@U) (t2@@25 T@U) (t3@@10 T@U) (t4@@10 T@U) ) (!  (=> (and (and (and (and (and (= (type f@@49) HandleTypeType) (= (type t0@@72) TyType)) (= (type t1@@48) TyType)) (= (type t2@@25) TyType)) (= (type t3@@10) TyType)) (= (type t4@@10) TyType)) (= ($Is f@@49 (Tclass._System.___hFunc4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10)) (forall ((h@@42 T@U) (bx0@@38 T@U) (bx1@@24 T@U) (bx2@@10 T@U) (bx3@@10 T@U) ) (!  (=> (and (and (and (and (and (= (type h@@42) (MapType0Type refType MapType1Type)) (= (type bx0@@38) BoxType)) (= (type bx1@@24) BoxType)) (= (type bx2@@10) BoxType)) (= (type bx3@@10) BoxType)) (and (and ($IsGoodHeap h@@42) (and (and (and ($IsBox bx0@@38 t0@@72) ($IsBox bx1@@24 t1@@48)) ($IsBox bx2@@10 t2@@25)) ($IsBox bx3@@10 t3@@10))) (Requires4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10))) ($IsBox (Apply4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10) t4@@10))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |900|
 :pattern ( (Apply4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10 h@@42 f@@49 bx0@@38 bx1@@24 bx2@@10 bx3@@10))
))))
 :qid |unknown.0:0|
 :skolemid |901|
 :pattern ( ($Is f@@49 (Tclass._System.___hFunc4 t0@@72 t1@@48 t2@@25 t3@@10 t4@@10)))
)))
(assert (forall ((f@@50 T@U) (t0@@73 T@U) (t1@@49 T@U) (t2@@26 T@U) (t3@@11 T@U) (t4@@11 T@U) (u0@@2 T@U) (u1@@1 T@U) (u2@@0 T@U) (u3 T@U) (u4 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type f@@50) HandleTypeType) (= (type t0@@73) TyType)) (= (type t1@@49) TyType)) (= (type t2@@26) TyType)) (= (type t3@@11) TyType)) (= (type t4@@11) TyType)) (= (type u0@@2) TyType)) (= (type u1@@1) TyType)) (= (type u2@@0) TyType)) (= (type u3) TyType)) (= (type u4) TyType)) (and (and (and (and (and ($Is f@@50 (Tclass._System.___hFunc4 t0@@73 t1@@49 t2@@26 t3@@11 t4@@11)) (forall ((bx@@53 T@U) ) (!  (=> (and (= (type bx@@53) BoxType) ($IsBox bx@@53 u0@@2)) ($IsBox bx@@53 t0@@73))
 :qid |unknown.0:0|
 :skolemid |902|
 :pattern ( ($IsBox bx@@53 u0@@2))
 :pattern ( ($IsBox bx@@53 t0@@73))
))) (forall ((bx@@54 T@U) ) (!  (=> (and (= (type bx@@54) BoxType) ($IsBox bx@@54 u1@@1)) ($IsBox bx@@54 t1@@49))
 :qid |unknown.0:0|
 :skolemid |903|
 :pattern ( ($IsBox bx@@54 u1@@1))
 :pattern ( ($IsBox bx@@54 t1@@49))
))) (forall ((bx@@55 T@U) ) (!  (=> (and (= (type bx@@55) BoxType) ($IsBox bx@@55 u2@@0)) ($IsBox bx@@55 t2@@26))
 :qid |unknown.0:0|
 :skolemid |904|
 :pattern ( ($IsBox bx@@55 u2@@0))
 :pattern ( ($IsBox bx@@55 t2@@26))
))) (forall ((bx@@56 T@U) ) (!  (=> (and (= (type bx@@56) BoxType) ($IsBox bx@@56 u3)) ($IsBox bx@@56 t3@@11))
 :qid |unknown.0:0|
 :skolemid |905|
 :pattern ( ($IsBox bx@@56 u3))
 :pattern ( ($IsBox bx@@56 t3@@11))
))) (forall ((bx@@57 T@U) ) (!  (=> (and (= (type bx@@57) BoxType) ($IsBox bx@@57 t4@@11)) ($IsBox bx@@57 u4))
 :qid |unknown.0:0|
 :skolemid |906|
 :pattern ( ($IsBox bx@@57 t4@@11))
 :pattern ( ($IsBox bx@@57 u4))
)))) ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4)))
 :qid |unknown.0:0|
 :skolemid |907|
 :pattern ( ($Is f@@50 (Tclass._System.___hFunc4 t0@@73 t1@@49 t2@@26 t3@@11 t4@@11)) ($Is f@@50 (Tclass._System.___hFunc4 u0@@2 u1@@1 u2@@0 u3 u4)))
)))
(assert (forall ((f@@51 T@U) (t0@@74 T@U) (t1@@50 T@U) (t2@@27 T@U) (t3@@12 T@U) (t4@@12 T@U) (h@@43 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@51) HandleTypeType) (= (type t0@@74) TyType)) (= (type t1@@50) TyType)) (= (type t2@@27) TyType)) (= (type t3@@12) TyType)) (= (type t4@@12) TyType)) (= (type h@@43) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@43)) (= ($IsAlloc f@@51 (Tclass._System.___hFunc4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12) h@@43) (forall ((bx0@@39 T@U) (bx1@@25 T@U) (bx2@@11 T@U) (bx3@@11 T@U) ) (!  (=> (and (and (and (= (type bx0@@39) BoxType) (= (type bx1@@25) BoxType)) (= (type bx2@@11) BoxType)) (= (type bx3@@11) BoxType)) (=> (and (and (and (and (and ($IsBox bx0@@39 t0@@74) ($IsAllocBox bx0@@39 t0@@74 h@@43)) (and ($IsBox bx1@@25 t1@@50) ($IsAllocBox bx1@@25 t1@@50 h@@43))) (and ($IsBox bx2@@11 t2@@27) ($IsAllocBox bx2@@11 t2@@27 h@@43))) (and ($IsBox bx3@@11 t3@@12) ($IsAllocBox bx3@@11 t3@@12 h@@43))) (Requires4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11)) (forall ((r@@21 T@U) ) (!  (=> (= (type r@@21) refType) (=> (and (not (= r@@21 null)) (U_2_bool (MapType0Select (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11) ($Box r@@21)))) (U_2_bool (MapType1Select (MapType0Select h@@43 r@@21) alloc))))
 :qid |unknown.0:0|
 :skolemid |908|
 :pattern ( (MapType0Select (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11) ($Box r@@21)))
))))
 :qid |unknown.0:0|
 :skolemid |909|
 :pattern ( (Apply4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11))
 :pattern ( (Reads4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12 h@@43 f@@51 bx0@@39 bx1@@25 bx2@@11 bx3@@11))
))))
 :qid |unknown.0:0|
 :skolemid |910|
 :pattern ( ($IsAlloc f@@51 (Tclass._System.___hFunc4 t0@@74 t1@@50 t2@@27 t3@@12 t4@@12) h@@43))
)))
(assert (forall ((f@@52 T@U) (t0@@75 T@U) (t1@@51 T@U) (t2@@28 T@U) (t3@@13 T@U) (t4@@13 T@U) (h@@44 T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type f@@52) HandleTypeType) (= (type t0@@75) TyType)) (= (type t1@@51) TyType)) (= (type t2@@28) TyType)) (= (type t3@@13) TyType)) (= (type t4@@13) TyType)) (= (type h@@44) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@44) ($IsAlloc f@@52 (Tclass._System.___hFunc4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13) h@@44))) (forall ((bx0@@40 T@U) (bx1@@26 T@U) (bx2@@12 T@U) (bx3@@12 T@U) ) (!  (=> (and (and (and (= (type bx0@@40) BoxType) (= (type bx1@@26) BoxType)) (= (type bx2@@12) BoxType)) (= (type bx3@@12) BoxType)) (=> (and (and (and (and ($IsAllocBox bx0@@40 t0@@75 h@@44) ($IsAllocBox bx1@@26 t1@@51 h@@44)) ($IsAllocBox bx2@@12 t2@@28 h@@44)) ($IsAllocBox bx3@@12 t3@@13 h@@44)) (Requires4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12)) ($IsAllocBox (Apply4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12) t4@@13 h@@44)))
 :qid |unknown.0:0|
 :skolemid |911|
 :pattern ( (Apply4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13 h@@44 f@@52 bx0@@40 bx1@@26 bx2@@12 bx3@@12))
)))
 :qid |unknown.0:0|
 :skolemid |912|
 :pattern ( ($IsAlloc f@@52 (Tclass._System.___hFunc4 t0@@75 t1@@51 t2@@28 t3@@13 t4@@13) h@@44))
)))
(assert (forall ((arg0@@188 T@U) (arg1@@93 T@U) (arg2@@45 T@U) (arg3@@24 T@U) (arg4@@16 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4 arg0@@188 arg1@@93 arg2@@45 arg3@@24 arg4@@16)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4|
 :pattern ( (Tclass._System.___hPartialFunc4 arg0@@188 arg1@@93 arg2@@45 arg3@@24 arg4@@16))
)))
(assert (forall ((|#$T0@@41| T@U) (|#$T1@@25| T@U) (|#$T2@@6| T@U) (|#$T3@@6| T@U) (|#$R@@54| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@41|) TyType) (= (type |#$T1@@25|) TyType)) (= (type |#$T2@@6|) TyType)) (= (type |#$T3@@6|) TyType)) (= (type |#$R@@54|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|)) Tagclass._System.___hPartialFunc4) (= (TagFamily (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|)) |tytagFamily$_#PartialFunc4|)))
 :qid |unknown.0:0|
 :skolemid |913|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@41| |#$T1@@25| |#$T2@@6| |#$T3@@6| |#$R@@54|))
)))
(assert (forall ((arg0@@189 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_0 arg0@@189)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_0|
 :pattern ( (Tclass._System.___hPartialFunc4_0 arg0@@189))
)))
(assert (forall ((|#$T0@@42| T@U) (|#$T1@@26| T@U) (|#$T2@@7| T@U) (|#$T3@@7| T@U) (|#$R@@55| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@42|) TyType) (= (type |#$T1@@26|) TyType)) (= (type |#$T2@@7|) TyType)) (= (type |#$T3@@7|) TyType)) (= (type |#$R@@55|) TyType)) (= (Tclass._System.___hPartialFunc4_0 (Tclass._System.___hPartialFunc4 |#$T0@@42| |#$T1@@26| |#$T2@@7| |#$T3@@7| |#$R@@55|)) |#$T0@@42|))
 :qid |unknown.0:0|
 :skolemid |914|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@42| |#$T1@@26| |#$T2@@7| |#$T3@@7| |#$R@@55|))
)))
(assert (forall ((arg0@@190 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_1 arg0@@190)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_1|
 :pattern ( (Tclass._System.___hPartialFunc4_1 arg0@@190))
)))
(assert (forall ((|#$T0@@43| T@U) (|#$T1@@27| T@U) (|#$T2@@8| T@U) (|#$T3@@8| T@U) (|#$R@@56| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@43|) TyType) (= (type |#$T1@@27|) TyType)) (= (type |#$T2@@8|) TyType)) (= (type |#$T3@@8|) TyType)) (= (type |#$R@@56|) TyType)) (= (Tclass._System.___hPartialFunc4_1 (Tclass._System.___hPartialFunc4 |#$T0@@43| |#$T1@@27| |#$T2@@8| |#$T3@@8| |#$R@@56|)) |#$T1@@27|))
 :qid |unknown.0:0|
 :skolemid |915|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@43| |#$T1@@27| |#$T2@@8| |#$T3@@8| |#$R@@56|))
)))
(assert (forall ((arg0@@191 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_2 arg0@@191)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_2|
 :pattern ( (Tclass._System.___hPartialFunc4_2 arg0@@191))
)))
(assert (forall ((|#$T0@@44| T@U) (|#$T1@@28| T@U) (|#$T2@@9| T@U) (|#$T3@@9| T@U) (|#$R@@57| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@44|) TyType) (= (type |#$T1@@28|) TyType)) (= (type |#$T2@@9|) TyType)) (= (type |#$T3@@9|) TyType)) (= (type |#$R@@57|) TyType)) (= (Tclass._System.___hPartialFunc4_2 (Tclass._System.___hPartialFunc4 |#$T0@@44| |#$T1@@28| |#$T2@@9| |#$T3@@9| |#$R@@57|)) |#$T2@@9|))
 :qid |unknown.0:0|
 :skolemid |916|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@44| |#$T1@@28| |#$T2@@9| |#$T3@@9| |#$R@@57|))
)))
(assert (forall ((arg0@@192 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_3 arg0@@192)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_3|
 :pattern ( (Tclass._System.___hPartialFunc4_3 arg0@@192))
)))
(assert (forall ((|#$T0@@45| T@U) (|#$T1@@29| T@U) (|#$T2@@10| T@U) (|#$T3@@10| T@U) (|#$R@@58| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@45|) TyType) (= (type |#$T1@@29|) TyType)) (= (type |#$T2@@10|) TyType)) (= (type |#$T3@@10|) TyType)) (= (type |#$R@@58|) TyType)) (= (Tclass._System.___hPartialFunc4_3 (Tclass._System.___hPartialFunc4 |#$T0@@45| |#$T1@@29| |#$T2@@10| |#$T3@@10| |#$R@@58|)) |#$T3@@10|))
 :qid |unknown.0:0|
 :skolemid |917|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@45| |#$T1@@29| |#$T2@@10| |#$T3@@10| |#$R@@58|))
)))
(assert (forall ((arg0@@193 T@U) ) (! (= (type (Tclass._System.___hPartialFunc4_4 arg0@@193)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc4_4|
 :pattern ( (Tclass._System.___hPartialFunc4_4 arg0@@193))
)))
(assert (forall ((|#$T0@@46| T@U) (|#$T1@@30| T@U) (|#$T2@@11| T@U) (|#$T3@@11| T@U) (|#$R@@59| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@46|) TyType) (= (type |#$T1@@30|) TyType)) (= (type |#$T2@@11|) TyType)) (= (type |#$T3@@11|) TyType)) (= (type |#$R@@59|) TyType)) (= (Tclass._System.___hPartialFunc4_4 (Tclass._System.___hPartialFunc4 |#$T0@@46| |#$T1@@30| |#$T2@@11| |#$T3@@11| |#$R@@59|)) |#$R@@59|))
 :qid |unknown.0:0|
 :skolemid |918|
 :pattern ( (Tclass._System.___hPartialFunc4 |#$T0@@46| |#$T1@@30| |#$T2@@11| |#$T3@@11| |#$R@@59|))
)))
(assert (forall ((|#$T0@@47| T@U) (|#$T1@@31| T@U) (|#$T2@@12| T@U) (|#$T3@@12| T@U) (|#$R@@60| T@U) (bx@@58 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@47|) TyType) (= (type |#$T1@@31|) TyType)) (= (type |#$T2@@12|) TyType)) (= (type |#$T3@@12|) TyType)) (= (type |#$R@@60|) TyType)) (= (type bx@@58) BoxType)) ($IsBox bx@@58 (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|))) (and (= ($Box ($Unbox HandleTypeType bx@@58)) bx@@58) ($Is ($Unbox HandleTypeType bx@@58) (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|))))
 :qid |unknown.0:0|
 :skolemid |919|
 :pattern ( ($IsBox bx@@58 (Tclass._System.___hPartialFunc4 |#$T0@@47| |#$T1@@31| |#$T2@@12| |#$T3@@12| |#$R@@60|)))
)))
(assert (forall ((|#$T0@@48| T@U) (|#$T1@@32| T@U) (|#$T2@@13| T@U) (|#$T3@@13| T@U) (|#$R@@61| T@U) (|f#0@@11| T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@48|) TyType) (= (type |#$T1@@32|) TyType)) (= (type |#$T2@@13|) TyType)) (= (type |#$T3@@13|) TyType)) (= (type |#$R@@61|) TyType)) (= (type |f#0@@11|) HandleTypeType)) (= ($Is |f#0@@11| (Tclass._System.___hPartialFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|))  (and ($Is |f#0@@11| (Tclass._System.___hFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|)) (forall ((|x0#0@@3| T@U) (|x1#0@@1| T@U) (|x2#0| T@U) (|x3#0| T@U) ) (!  (=> (and (and (and (and (= (type |x0#0@@3|) BoxType) (= (type |x1#0@@1|) BoxType)) (= (type |x2#0|) BoxType)) (= (type |x3#0|) BoxType)) (and (and (and ($IsBox |x0#0@@3| |#$T0@@48|) ($IsBox |x1#0@@1| |#$T1@@32|)) ($IsBox |x2#0| |#$T2@@13|)) ($IsBox |x3#0| |#$T3@@13|))) (|Set#Equal| (Reads4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61| $OneHeap |f#0@@11| |x0#0@@3| |x1#0@@1| |x2#0| |x3#0|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |920|
 :no-pattern (type |x0#0@@3|)
 :no-pattern (type |x1#0@@1|)
 :no-pattern (type |x2#0|)
 :no-pattern (type |x3#0|)
 :no-pattern (U_2_int |x0#0@@3|)
 :no-pattern (U_2_bool |x0#0@@3|)
 :no-pattern (U_2_int |x1#0@@1|)
 :no-pattern (U_2_bool |x1#0@@1|)
 :no-pattern (U_2_int |x2#0|)
 :no-pattern (U_2_bool |x2#0|)
 :no-pattern (U_2_int |x3#0|)
 :no-pattern (U_2_bool |x3#0|)
)))))
 :qid |unknown.0:0|
 :skolemid |921|
 :pattern ( ($Is |f#0@@11| (Tclass._System.___hPartialFunc4 |#$T0@@48| |#$T1@@32| |#$T2@@13| |#$T3@@13| |#$R@@61|)))
)))
(assert (forall ((|#$T0@@49| T@U) (|#$T1@@33| T@U) (|#$T2@@14| T@U) (|#$T3@@14| T@U) (|#$R@@62| T@U) (|f#0@@12| T@U) ($h@@17 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@49|) TyType) (= (type |#$T1@@33|) TyType)) (= (type |#$T2@@14|) TyType)) (= (type |#$T3@@14|) TyType)) (= (type |#$R@@62|) TyType)) (= (type |f#0@@12|) HandleTypeType)) (= (type $h@@17) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@12| (Tclass._System.___hPartialFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17) ($IsAlloc |f#0@@12| (Tclass._System.___hFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17)))
 :qid |unknown.0:0|
 :skolemid |922|
 :pattern ( ($IsAlloc |f#0@@12| (Tclass._System.___hPartialFunc4 |#$T0@@49| |#$T1@@33| |#$T2@@14| |#$T3@@14| |#$R@@62|) $h@@17))
)))
(assert (forall ((arg0@@194 T@U) (arg1@@94 T@U) (arg2@@46 T@U) (arg3@@25 T@U) (arg4@@17 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4 arg0@@194 arg1@@94 arg2@@46 arg3@@25 arg4@@17)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4|
 :pattern ( (Tclass._System.___hTotalFunc4 arg0@@194 arg1@@94 arg2@@46 arg3@@25 arg4@@17))
)))
(assert (forall ((|#$T0@@50| T@U) (|#$T1@@34| T@U) (|#$T2@@15| T@U) (|#$T3@@15| T@U) (|#$R@@63| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@50|) TyType) (= (type |#$T1@@34|) TyType)) (= (type |#$T2@@15|) TyType)) (= (type |#$T3@@15|) TyType)) (= (type |#$R@@63|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|)) Tagclass._System.___hTotalFunc4) (= (TagFamily (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|)) |tytagFamily$_#TotalFunc4|)))
 :qid |unknown.0:0|
 :skolemid |923|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@50| |#$T1@@34| |#$T2@@15| |#$T3@@15| |#$R@@63|))
)))
(assert (forall ((arg0@@195 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_0 arg0@@195)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_0|
 :pattern ( (Tclass._System.___hTotalFunc4_0 arg0@@195))
)))
(assert (forall ((|#$T0@@51| T@U) (|#$T1@@35| T@U) (|#$T2@@16| T@U) (|#$T3@@16| T@U) (|#$R@@64| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@51|) TyType) (= (type |#$T1@@35|) TyType)) (= (type |#$T2@@16|) TyType)) (= (type |#$T3@@16|) TyType)) (= (type |#$R@@64|) TyType)) (= (Tclass._System.___hTotalFunc4_0 (Tclass._System.___hTotalFunc4 |#$T0@@51| |#$T1@@35| |#$T2@@16| |#$T3@@16| |#$R@@64|)) |#$T0@@51|))
 :qid |unknown.0:0|
 :skolemid |924|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@51| |#$T1@@35| |#$T2@@16| |#$T3@@16| |#$R@@64|))
)))
(assert (forall ((arg0@@196 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_1 arg0@@196)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_1|
 :pattern ( (Tclass._System.___hTotalFunc4_1 arg0@@196))
)))
(assert (forall ((|#$T0@@52| T@U) (|#$T1@@36| T@U) (|#$T2@@17| T@U) (|#$T3@@17| T@U) (|#$R@@65| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@52|) TyType) (= (type |#$T1@@36|) TyType)) (= (type |#$T2@@17|) TyType)) (= (type |#$T3@@17|) TyType)) (= (type |#$R@@65|) TyType)) (= (Tclass._System.___hTotalFunc4_1 (Tclass._System.___hTotalFunc4 |#$T0@@52| |#$T1@@36| |#$T2@@17| |#$T3@@17| |#$R@@65|)) |#$T1@@36|))
 :qid |unknown.0:0|
 :skolemid |925|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@52| |#$T1@@36| |#$T2@@17| |#$T3@@17| |#$R@@65|))
)))
(assert (forall ((arg0@@197 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_2 arg0@@197)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_2|
 :pattern ( (Tclass._System.___hTotalFunc4_2 arg0@@197))
)))
(assert (forall ((|#$T0@@53| T@U) (|#$T1@@37| T@U) (|#$T2@@18| T@U) (|#$T3@@18| T@U) (|#$R@@66| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@53|) TyType) (= (type |#$T1@@37|) TyType)) (= (type |#$T2@@18|) TyType)) (= (type |#$T3@@18|) TyType)) (= (type |#$R@@66|) TyType)) (= (Tclass._System.___hTotalFunc4_2 (Tclass._System.___hTotalFunc4 |#$T0@@53| |#$T1@@37| |#$T2@@18| |#$T3@@18| |#$R@@66|)) |#$T2@@18|))
 :qid |unknown.0:0|
 :skolemid |926|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@53| |#$T1@@37| |#$T2@@18| |#$T3@@18| |#$R@@66|))
)))
(assert (forall ((arg0@@198 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_3 arg0@@198)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_3|
 :pattern ( (Tclass._System.___hTotalFunc4_3 arg0@@198))
)))
(assert (forall ((|#$T0@@54| T@U) (|#$T1@@38| T@U) (|#$T2@@19| T@U) (|#$T3@@19| T@U) (|#$R@@67| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@54|) TyType) (= (type |#$T1@@38|) TyType)) (= (type |#$T2@@19|) TyType)) (= (type |#$T3@@19|) TyType)) (= (type |#$R@@67|) TyType)) (= (Tclass._System.___hTotalFunc4_3 (Tclass._System.___hTotalFunc4 |#$T0@@54| |#$T1@@38| |#$T2@@19| |#$T3@@19| |#$R@@67|)) |#$T3@@19|))
 :qid |unknown.0:0|
 :skolemid |927|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@54| |#$T1@@38| |#$T2@@19| |#$T3@@19| |#$R@@67|))
)))
(assert (forall ((arg0@@199 T@U) ) (! (= (type (Tclass._System.___hTotalFunc4_4 arg0@@199)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc4_4|
 :pattern ( (Tclass._System.___hTotalFunc4_4 arg0@@199))
)))
(assert (forall ((|#$T0@@55| T@U) (|#$T1@@39| T@U) (|#$T2@@20| T@U) (|#$T3@@20| T@U) (|#$R@@68| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@55|) TyType) (= (type |#$T1@@39|) TyType)) (= (type |#$T2@@20|) TyType)) (= (type |#$T3@@20|) TyType)) (= (type |#$R@@68|) TyType)) (= (Tclass._System.___hTotalFunc4_4 (Tclass._System.___hTotalFunc4 |#$T0@@55| |#$T1@@39| |#$T2@@20| |#$T3@@20| |#$R@@68|)) |#$R@@68|))
 :qid |unknown.0:0|
 :skolemid |928|
 :pattern ( (Tclass._System.___hTotalFunc4 |#$T0@@55| |#$T1@@39| |#$T2@@20| |#$T3@@20| |#$R@@68|))
)))
(assert (forall ((|#$T0@@56| T@U) (|#$T1@@40| T@U) (|#$T2@@21| T@U) (|#$T3@@21| T@U) (|#$R@@69| T@U) (bx@@59 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@56|) TyType) (= (type |#$T1@@40|) TyType)) (= (type |#$T2@@21|) TyType)) (= (type |#$T3@@21|) TyType)) (= (type |#$R@@69|) TyType)) (= (type bx@@59) BoxType)) ($IsBox bx@@59 (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|))) (and (= ($Box ($Unbox HandleTypeType bx@@59)) bx@@59) ($Is ($Unbox HandleTypeType bx@@59) (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|))))
 :qid |unknown.0:0|
 :skolemid |929|
 :pattern ( ($IsBox bx@@59 (Tclass._System.___hTotalFunc4 |#$T0@@56| |#$T1@@40| |#$T2@@21| |#$T3@@21| |#$R@@69|)))
)))
(assert (forall ((|#$T0@@57| T@U) (|#$T1@@41| T@U) (|#$T2@@22| T@U) (|#$T3@@22| T@U) (|#$R@@70| T@U) (|f#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@57|) TyType) (= (type |#$T1@@41|) TyType)) (= (type |#$T2@@22|) TyType)) (= (type |#$T3@@22|) TyType)) (= (type |#$R@@70|) TyType)) (= (type |f#0@@13|) HandleTypeType)) (= ($Is |f#0@@13| (Tclass._System.___hTotalFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|))  (and ($Is |f#0@@13| (Tclass._System.___hPartialFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|)) (forall ((|x0#0@@4| T@U) (|x1#0@@2| T@U) (|x2#0@@0| T@U) (|x3#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |x0#0@@4|) BoxType) (= (type |x1#0@@2|) BoxType)) (= (type |x2#0@@0|) BoxType)) (= (type |x3#0@@0|) BoxType)) (and (and (and ($IsBox |x0#0@@4| |#$T0@@57|) ($IsBox |x1#0@@2| |#$T1@@41|)) ($IsBox |x2#0@@0| |#$T2@@22|)) ($IsBox |x3#0@@0| |#$T3@@22|))) (Requires4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70| $OneHeap |f#0@@13| |x0#0@@4| |x1#0@@2| |x2#0@@0| |x3#0@@0|))
 :qid |unknown.0:0|
 :skolemid |930|
 :no-pattern (type |x0#0@@4|)
 :no-pattern (type |x1#0@@2|)
 :no-pattern (type |x2#0@@0|)
 :no-pattern (type |x3#0@@0|)
 :no-pattern (U_2_int |x0#0@@4|)
 :no-pattern (U_2_bool |x0#0@@4|)
 :no-pattern (U_2_int |x1#0@@2|)
 :no-pattern (U_2_bool |x1#0@@2|)
 :no-pattern (U_2_int |x2#0@@0|)
 :no-pattern (U_2_bool |x2#0@@0|)
 :no-pattern (U_2_int |x3#0@@0|)
 :no-pattern (U_2_bool |x3#0@@0|)
)))))
 :qid |unknown.0:0|
 :skolemid |931|
 :pattern ( ($Is |f#0@@13| (Tclass._System.___hTotalFunc4 |#$T0@@57| |#$T1@@41| |#$T2@@22| |#$T3@@22| |#$R@@70|)))
)))
(assert (forall ((|#$T0@@58| T@U) (|#$T1@@42| T@U) (|#$T2@@23| T@U) (|#$T3@@23| T@U) (|#$R@@71| T@U) (|f#0@@14| T@U) ($h@@18 T@U) ) (!  (=> (and (and (and (and (and (and (= (type |#$T0@@58|) TyType) (= (type |#$T1@@42|) TyType)) (= (type |#$T2@@23|) TyType)) (= (type |#$T3@@23|) TyType)) (= (type |#$R@@71|) TyType)) (= (type |f#0@@14|) HandleTypeType)) (= (type $h@@18) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@14| (Tclass._System.___hTotalFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18) ($IsAlloc |f#0@@14| (Tclass._System.___hPartialFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18)))
 :qid |unknown.0:0|
 :skolemid |932|
 :pattern ( ($IsAlloc |f#0@@14| (Tclass._System.___hTotalFunc4 |#$T0@@58| |#$T1@@42| |#$T2@@23| |#$T3@@23| |#$R@@71|) $h@@18))
)))
(assert (forall ((arg0@@200 T@U) (arg1@@95 T@U) (arg2@@47 T@U) (arg3@@26 T@U) ) (! (= (type (Tclass._System.___hFunc3 arg0@@200 arg1@@95 arg2@@47 arg3@@26)) TyType)
 :qid |funType:Tclass._System.___hFunc3|
 :pattern ( (Tclass._System.___hFunc3 arg0@@200 arg1@@95 arg2@@47 arg3@@26))
)))
(assert (forall ((|#$T0@@59| T@U) (|#$T1@@43| T@U) (|#$T2@@24| T@U) (|#$R@@72| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@59|) TyType) (= (type |#$T1@@43|) TyType)) (= (type |#$T2@@24|) TyType)) (= (type |#$R@@72|) TyType)) (and (= (Tag (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|)) Tagclass._System.___hFunc3) (= (TagFamily (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|)) |tytagFamily$_#Func3|)))
 :qid |unknown.0:0|
 :skolemid |933|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@59| |#$T1@@43| |#$T2@@24| |#$R@@72|))
)))
(assert (forall ((arg0@@201 T@U) ) (! (= (type (Tclass._System.___hFunc3_0 arg0@@201)) TyType)
 :qid |funType:Tclass._System.___hFunc3_0|
 :pattern ( (Tclass._System.___hFunc3_0 arg0@@201))
)))
(assert (forall ((|#$T0@@60| T@U) (|#$T1@@44| T@U) (|#$T2@@25| T@U) (|#$R@@73| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@60|) TyType) (= (type |#$T1@@44|) TyType)) (= (type |#$T2@@25|) TyType)) (= (type |#$R@@73|) TyType)) (= (Tclass._System.___hFunc3_0 (Tclass._System.___hFunc3 |#$T0@@60| |#$T1@@44| |#$T2@@25| |#$R@@73|)) |#$T0@@60|))
 :qid |unknown.0:0|
 :skolemid |934|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@60| |#$T1@@44| |#$T2@@25| |#$R@@73|))
)))
(assert (forall ((arg0@@202 T@U) ) (! (= (type (Tclass._System.___hFunc3_1 arg0@@202)) TyType)
 :qid |funType:Tclass._System.___hFunc3_1|
 :pattern ( (Tclass._System.___hFunc3_1 arg0@@202))
)))
(assert (forall ((|#$T0@@61| T@U) (|#$T1@@45| T@U) (|#$T2@@26| T@U) (|#$R@@74| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@61|) TyType) (= (type |#$T1@@45|) TyType)) (= (type |#$T2@@26|) TyType)) (= (type |#$R@@74|) TyType)) (= (Tclass._System.___hFunc3_1 (Tclass._System.___hFunc3 |#$T0@@61| |#$T1@@45| |#$T2@@26| |#$R@@74|)) |#$T1@@45|))
 :qid |unknown.0:0|
 :skolemid |935|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@61| |#$T1@@45| |#$T2@@26| |#$R@@74|))
)))
(assert (forall ((arg0@@203 T@U) ) (! (= (type (Tclass._System.___hFunc3_2 arg0@@203)) TyType)
 :qid |funType:Tclass._System.___hFunc3_2|
 :pattern ( (Tclass._System.___hFunc3_2 arg0@@203))
)))
(assert (forall ((|#$T0@@62| T@U) (|#$T1@@46| T@U) (|#$T2@@27| T@U) (|#$R@@75| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@62|) TyType) (= (type |#$T1@@46|) TyType)) (= (type |#$T2@@27|) TyType)) (= (type |#$R@@75|) TyType)) (= (Tclass._System.___hFunc3_2 (Tclass._System.___hFunc3 |#$T0@@62| |#$T1@@46| |#$T2@@27| |#$R@@75|)) |#$T2@@27|))
 :qid |unknown.0:0|
 :skolemid |936|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@62| |#$T1@@46| |#$T2@@27| |#$R@@75|))
)))
(assert (forall ((arg0@@204 T@U) ) (! (= (type (Tclass._System.___hFunc3_3 arg0@@204)) TyType)
 :qid |funType:Tclass._System.___hFunc3_3|
 :pattern ( (Tclass._System.___hFunc3_3 arg0@@204))
)))
(assert (forall ((|#$T0@@63| T@U) (|#$T1@@47| T@U) (|#$T2@@28| T@U) (|#$R@@76| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@63|) TyType) (= (type |#$T1@@47|) TyType)) (= (type |#$T2@@28|) TyType)) (= (type |#$R@@76|) TyType)) (= (Tclass._System.___hFunc3_3 (Tclass._System.___hFunc3 |#$T0@@63| |#$T1@@47| |#$T2@@28| |#$R@@76|)) |#$R@@76|))
 :qid |unknown.0:0|
 :skolemid |937|
 :pattern ( (Tclass._System.___hFunc3 |#$T0@@63| |#$T1@@47| |#$T2@@28| |#$R@@76|))
)))
(assert (forall ((|#$T0@@64| T@U) (|#$T1@@48| T@U) (|#$T2@@29| T@U) (|#$R@@77| T@U) (bx@@60 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@64|) TyType) (= (type |#$T1@@48|) TyType)) (= (type |#$T2@@29|) TyType)) (= (type |#$R@@77|) TyType)) (= (type bx@@60) BoxType)) ($IsBox bx@@60 (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|))) (and (= ($Box ($Unbox HandleTypeType bx@@60)) bx@@60) ($Is ($Unbox HandleTypeType bx@@60) (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|))))
 :qid |unknown.0:0|
 :skolemid |938|
 :pattern ( ($IsBox bx@@60 (Tclass._System.___hFunc3 |#$T0@@64| |#$T1@@48| |#$T2@@29| |#$R@@77|)))
)))
(assert  (and (and (and (and (and (and (and (and (and (and (and (forall ((arg0@@205 T@T) (arg1@@96 T@T) (arg2@@48 T@T) (arg3@@27 T@T) (arg4@@18 T@T) ) (! (= (Ctor (MapType5Type arg0@@205 arg1@@96 arg2@@48 arg3@@27 arg4@@18)) 27)
 :qid |ctor:MapType5Type|
)) (forall ((arg0@@206 T@T) (arg1@@97 T@T) (arg2@@49 T@T) (arg3@@28 T@T) (arg4@@19 T@T) ) (! (= (MapType5TypeInv0 (MapType5Type arg0@@206 arg1@@97 arg2@@49 arg3@@28 arg4@@19)) arg0@@206)
 :qid |typeInv:MapType5TypeInv0|
 :pattern ( (MapType5Type arg0@@206 arg1@@97 arg2@@49 arg3@@28 arg4@@19))
))) (forall ((arg0@@207 T@T) (arg1@@98 T@T) (arg2@@50 T@T) (arg3@@29 T@T) (arg4@@20 T@T) ) (! (= (MapType5TypeInv1 (MapType5Type arg0@@207 arg1@@98 arg2@@50 arg3@@29 arg4@@20)) arg1@@98)
 :qid |typeInv:MapType5TypeInv1|
 :pattern ( (MapType5Type arg0@@207 arg1@@98 arg2@@50 arg3@@29 arg4@@20))
))) (forall ((arg0@@208 T@T) (arg1@@99 T@T) (arg2@@51 T@T) (arg3@@30 T@T) (arg4@@21 T@T) ) (! (= (MapType5TypeInv2 (MapType5Type arg0@@208 arg1@@99 arg2@@51 arg3@@30 arg4@@21)) arg2@@51)
 :qid |typeInv:MapType5TypeInv2|
 :pattern ( (MapType5Type arg0@@208 arg1@@99 arg2@@51 arg3@@30 arg4@@21))
))) (forall ((arg0@@209 T@T) (arg1@@100 T@T) (arg2@@52 T@T) (arg3@@31 T@T) (arg4@@22 T@T) ) (! (= (MapType5TypeInv3 (MapType5Type arg0@@209 arg1@@100 arg2@@52 arg3@@31 arg4@@22)) arg3@@31)
 :qid |typeInv:MapType5TypeInv3|
 :pattern ( (MapType5Type arg0@@209 arg1@@100 arg2@@52 arg3@@31 arg4@@22))
))) (forall ((arg0@@210 T@T) (arg1@@101 T@T) (arg2@@53 T@T) (arg3@@32 T@T) (arg4@@23 T@T) ) (! (= (MapType5TypeInv4 (MapType5Type arg0@@210 arg1@@101 arg2@@53 arg3@@32 arg4@@23)) arg4@@23)
 :qid |typeInv:MapType5TypeInv4|
 :pattern ( (MapType5Type arg0@@210 arg1@@101 arg2@@53 arg3@@32 arg4@@23))
))) (forall ((arg0@@211 T@U) (arg1@@102 T@U) (arg2@@54 T@U) (arg3@@33 T@U) (arg4@@24 T@U) ) (! (let ((aVar4@@0 (MapType5TypeInv4 (type arg0@@211))))
(= (type (MapType5Select arg0@@211 arg1@@102 arg2@@54 arg3@@33 arg4@@24)) aVar4@@0))
 :qid |funType:MapType5Select|
 :pattern ( (MapType5Select arg0@@211 arg1@@102 arg2@@54 arg3@@33 arg4@@24))
))) (forall ((arg0@@212 T@U) (arg1@@103 T@U) (arg2@@55 T@U) (arg3@@34 T@U) (arg4@@25 T@U) (arg5@@12 T@U) ) (! (let ((aVar4@@1 (type arg5@@12)))
(let ((aVar3@@3 (type arg4@@25)))
(let ((aVar2@@4 (type arg3@@34)))
(let ((aVar1@@5 (type arg2@@55)))
(let ((aVar0@@3 (type arg1@@103)))
(= (type (MapType5Store arg0@@212 arg1@@103 arg2@@55 arg3@@34 arg4@@25 arg5@@12)) (MapType5Type aVar0@@3 aVar1@@5 aVar2@@4 aVar3@@3 aVar4@@1)))))))
 :qid |funType:MapType5Store|
 :pattern ( (MapType5Store arg0@@212 arg1@@103 arg2@@55 arg3@@34 arg4@@25 arg5@@12))
))) (forall ((m@@61 T@U) (x0@@21 T@U) (x1@@15 T@U) (x2@@11 T@U) (x3@@6 T@U) (val@@22 T@U) ) (! (let ((aVar4@@2 (MapType5TypeInv4 (type m@@61))))
 (=> (= (type val@@22) aVar4@@2) (= (MapType5Select (MapType5Store m@@61 x0@@21 x1@@15 x2@@11 x3@@6 val@@22) x0@@21 x1@@15 x2@@11 x3@@6) val@@22)))
 :qid |mapAx0:MapType5Select|
 :weight 0
))) (and (and (and (and (forall ((val@@23 T@U) (m@@62 T@U) (x0@@22 T@U) (x1@@16 T@U) (x2@@12 T@U) (x3@@7 T@U) (y0@@16 T@U) (y1@@12 T@U) (y2@@9 T@U) (y3@@5 T@U) ) (!  (or (= x0@@22 y0@@16) (= (MapType5Select (MapType5Store m@@62 x0@@22 x1@@16 x2@@12 x3@@7 val@@23) y0@@16 y1@@12 y2@@9 y3@@5) (MapType5Select m@@62 y0@@16 y1@@12 y2@@9 y3@@5)))
 :qid |mapAx1:MapType5Select:0|
 :weight 0
)) (forall ((val@@24 T@U) (m@@63 T@U) (x0@@23 T@U) (x1@@17 T@U) (x2@@13 T@U) (x3@@8 T@U) (y0@@17 T@U) (y1@@13 T@U) (y2@@10 T@U) (y3@@6 T@U) ) (!  (or (= x1@@17 y1@@13) (= (MapType5Select (MapType5Store m@@63 x0@@23 x1@@17 x2@@13 x3@@8 val@@24) y0@@17 y1@@13 y2@@10 y3@@6) (MapType5Select m@@63 y0@@17 y1@@13 y2@@10 y3@@6)))
 :qid |mapAx1:MapType5Select:1|
 :weight 0
))) (forall ((val@@25 T@U) (m@@64 T@U) (x0@@24 T@U) (x1@@18 T@U) (x2@@14 T@U) (x3@@9 T@U) (y0@@18 T@U) (y1@@14 T@U) (y2@@11 T@U) (y3@@7 T@U) ) (!  (or (= x2@@14 y2@@11) (= (MapType5Select (MapType5Store m@@64 x0@@24 x1@@18 x2@@14 x3@@9 val@@25) y0@@18 y1@@14 y2@@11 y3@@7) (MapType5Select m@@64 y0@@18 y1@@14 y2@@11 y3@@7)))
 :qid |mapAx1:MapType5Select:2|
 :weight 0
))) (forall ((val@@26 T@U) (m@@65 T@U) (x0@@25 T@U) (x1@@19 T@U) (x2@@15 T@U) (x3@@10 T@U) (y0@@19 T@U) (y1@@15 T@U) (y2@@12 T@U) (y3@@8 T@U) ) (!  (or (= x3@@10 y3@@8) (= (MapType5Select (MapType5Store m@@65 x0@@25 x1@@19 x2@@15 x3@@10 val@@26) y0@@19 y1@@15 y2@@12 y3@@8) (MapType5Select m@@65 y0@@19 y1@@15 y2@@12 y3@@8)))
 :qid |mapAx1:MapType5Select:3|
 :weight 0
))) (forall ((val@@27 T@U) (m@@66 T@U) (x0@@26 T@U) (x1@@20 T@U) (x2@@16 T@U) (x3@@11 T@U) (y0@@20 T@U) (y1@@16 T@U) (y2@@13 T@U) (y3@@9 T@U) ) (!  (or true (= (MapType5Select (MapType5Store m@@66 x0@@26 x1@@20 x2@@16 x3@@11 val@@27) y0@@20 y1@@16 y2@@13 y3@@9) (MapType5Select m@@66 y0@@20 y1@@16 y2@@13 y3@@9)))
 :qid |mapAx2:MapType5Select|
 :weight 0
)))) (forall ((arg0@@213 T@U) (arg1@@104 T@U) (arg2@@56 T@U) (arg3@@35 T@U) (arg4@@26 T@U) (arg5@@13 T@U) (arg6@@4 T@U) (arg7@@1 T@U) (arg8@@1 T@U) ) (! (= (type (Apply3 arg0@@213 arg1@@104 arg2@@56 arg3@@35 arg4@@26 arg5@@13 arg6@@4 arg7@@1 arg8@@1)) BoxType)
 :qid |funType:Apply3|
 :pattern ( (Apply3 arg0@@213 arg1@@104 arg2@@56 arg3@@35 arg4@@26 arg5@@13 arg6@@4 arg7@@1 arg8@@1))
))) (forall ((arg0@@214 T@U) (arg1@@105 T@U) (arg2@@57 T@U) ) (! (= (type (Handle3 arg0@@214 arg1@@105 arg2@@57)) HandleTypeType)
 :qid |funType:Handle3|
 :pattern ( (Handle3 arg0@@214 arg1@@105 arg2@@57))
))))
(assert (forall ((t0@@76 T@U) (t1@@52 T@U) (t2@@29 T@U) (t3@@14 T@U) (heap@@21 T@U) (h@@45 T@U) (r@@22 T@U) (rd@@11 T@U) (bx0@@41 T@U) (bx1@@27 T@U) (bx2@@13 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@76) TyType) (= (type t1@@52) TyType)) (= (type t2@@29) TyType)) (= (type t3@@14) TyType)) (= (type heap@@21) (MapType0Type refType MapType1Type))) (= (type h@@45) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@22) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@11) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@41) BoxType)) (= (type bx1@@27) BoxType)) (= (type bx2@@13) BoxType)) (= (Apply3 t0@@76 t1@@52 t2@@29 t3@@14 heap@@21 (Handle3 h@@45 r@@22 rd@@11) bx0@@41 bx1@@27 bx2@@13) (MapType5Select h@@45 heap@@21 bx0@@41 bx1@@27 bx2@@13)))
 :qid |unknown.0:0|
 :skolemid |939|
 :pattern ( (Apply3 t0@@76 t1@@52 t2@@29 t3@@14 heap@@21 (Handle3 h@@45 r@@22 rd@@11) bx0@@41 bx1@@27 bx2@@13))
)))
(assert (forall ((t0@@77 T@U) (t1@@53 T@U) (t2@@30 T@U) (t3@@15 T@U) (heap@@22 T@U) (h@@46 T@U) (r@@23 T@U) (rd@@12 T@U) (bx0@@42 T@U) (bx1@@28 T@U) (bx2@@14 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@77) TyType) (= (type t1@@53) TyType)) (= (type t2@@30) TyType)) (= (type t3@@15) TyType)) (= (type heap@@22) (MapType0Type refType MapType1Type))) (= (type h@@46) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@23) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@12) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@42) BoxType)) (= (type bx1@@28) BoxType)) (= (type bx2@@14) BoxType)) (U_2_bool (MapType5Select r@@23 heap@@22 bx0@@42 bx1@@28 bx2@@14))) (Requires3 t0@@77 t1@@53 t2@@30 t3@@15 heap@@22 (Handle3 h@@46 r@@23 rd@@12) bx0@@42 bx1@@28 bx2@@14))
 :qid |unknown.0:0|
 :skolemid |940|
 :pattern ( (Requires3 t0@@77 t1@@53 t2@@30 t3@@15 heap@@22 (Handle3 h@@46 r@@23 rd@@12) bx0@@42 bx1@@28 bx2@@14))
)))
(assert (forall ((arg0@@215 T@U) (arg1@@106 T@U) (arg2@@58 T@U) (arg3@@36 T@U) (arg4@@27 T@U) (arg5@@14 T@U) (arg6@@5 T@U) (arg7@@2 T@U) (arg8@@2 T@U) ) (! (= (type (Reads3 arg0@@215 arg1@@106 arg2@@58 arg3@@36 arg4@@27 arg5@@14 arg6@@5 arg7@@2 arg8@@2)) (MapType0Type BoxType boolType))
 :qid |funType:Reads3|
 :pattern ( (Reads3 arg0@@215 arg1@@106 arg2@@58 arg3@@36 arg4@@27 arg5@@14 arg6@@5 arg7@@2 arg8@@2))
)))
(assert (forall ((t0@@78 T@U) (t1@@54 T@U) (t2@@31 T@U) (t3@@16 T@U) (heap@@23 T@U) (h@@47 T@U) (r@@24 T@U) (rd@@13 T@U) (bx0@@43 T@U) (bx1@@29 T@U) (bx2@@15 T@U) (bx@@61 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type t0@@78) TyType) (= (type t1@@54) TyType)) (= (type t2@@31) TyType)) (= (type t3@@16) TyType)) (= (type heap@@23) (MapType0Type refType MapType1Type))) (= (type h@@47) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType BoxType))) (= (type r@@24) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType boolType))) (= (type rd@@13) (MapType5Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType (MapType0Type BoxType boolType)))) (= (type bx0@@43) BoxType)) (= (type bx1@@29) BoxType)) (= (type bx2@@15) BoxType)) (= (type bx@@61) BoxType)) (= (U_2_bool (MapType0Select (Reads3 t0@@78 t1@@54 t2@@31 t3@@16 heap@@23 (Handle3 h@@47 r@@24 rd@@13) bx0@@43 bx1@@29 bx2@@15) bx@@61)) (U_2_bool (MapType0Select (MapType5Select rd@@13 heap@@23 bx0@@43 bx1@@29 bx2@@15) bx@@61))))
 :qid |unknown.0:0|
 :skolemid |941|
 :pattern ( (MapType0Select (Reads3 t0@@78 t1@@54 t2@@31 t3@@16 heap@@23 (Handle3 h@@47 r@@24 rd@@13) bx0@@43 bx1@@29 bx2@@15) bx@@61))
)))
(assert (forall ((t0@@79 T@U) (t1@@55 T@U) (t2@@32 T@U) (t3@@17 T@U) (h0@@24 T@U) (h1@@24 T@U) (f@@53 T@U) (bx0@@44 T@U) (bx1@@30 T@U) (bx2@@16 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@79) TyType) (= (type t1@@55) TyType)) (= (type t2@@32) TyType)) (= (type t3@@17) TyType)) (= (type h0@@24) (MapType0Type refType MapType1Type))) (= (type h1@@24) (MapType0Type refType MapType1Type))) (= (type f@@53) HandleTypeType)) (= (type bx0@@44) BoxType)) (= (type bx1@@30) BoxType)) (= (type bx2@@16) BoxType)) (and (and (and ($HeapSucc h0@@24 h1@@24) (and ($IsGoodHeap h0@@24) ($IsGoodHeap h1@@24))) (and (and (and ($IsBox bx0@@44 t0@@79) ($IsBox bx1@@30 t1@@55)) ($IsBox bx2@@16 t2@@32)) ($Is f@@53 (Tclass._System.___hFunc3 t0@@79 t1@@55 t2@@32 t3@@17)))) (forall ((o@@68 T@U) (fld@@23 T@U) ) (! (let ((a@@108 (FieldTypeInv0 (type fld@@23))))
 (=> (and (and (= (type o@@68) refType) (= (type fld@@23) (FieldType a@@108))) (and (not (= o@@68 null)) (U_2_bool (MapType0Select (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h0@@24 f@@53 bx0@@44 bx1@@30 bx2@@16) ($Box o@@68))))) (= (MapType1Select (MapType0Select h0@@24 o@@68) fld@@23) (MapType1Select (MapType0Select h1@@24 o@@68) fld@@23))))
 :qid |unknown.0:0|
 :skolemid |942|
 :no-pattern (type o@@68)
 :no-pattern (type fld@@23)
 :no-pattern (U_2_int o@@68)
 :no-pattern (U_2_bool o@@68)
 :no-pattern (U_2_int fld@@23)
 :no-pattern (U_2_bool fld@@23)
)))) (= (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h0@@24 f@@53 bx0@@44 bx1@@30 bx2@@16) (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h1@@24 f@@53 bx0@@44 bx1@@30 bx2@@16)))
 :qid |unknown.0:0|
 :skolemid |943|
 :pattern ( ($HeapSucc h0@@24 h1@@24) (Reads3 t0@@79 t1@@55 t2@@32 t3@@17 h1@@24 f@@53 bx0@@44 bx1@@30 bx2@@16))
)))
(assert (forall ((t0@@80 T@U) (t1@@56 T@U) (t2@@33 T@U) (t3@@18 T@U) (h0@@25 T@U) (h1@@25 T@U) (f@@54 T@U) (bx0@@45 T@U) (bx1@@31 T@U) (bx2@@17 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@80) TyType) (= (type t1@@56) TyType)) (= (type t2@@33) TyType)) (= (type t3@@18) TyType)) (= (type h0@@25) (MapType0Type refType MapType1Type))) (= (type h1@@25) (MapType0Type refType MapType1Type))) (= (type f@@54) HandleTypeType)) (= (type bx0@@45) BoxType)) (= (type bx1@@31) BoxType)) (= (type bx2@@17) BoxType)) (and (and (and ($HeapSucc h0@@25 h1@@25) (and ($IsGoodHeap h0@@25) ($IsGoodHeap h1@@25))) (and (and (and ($IsBox bx0@@45 t0@@80) ($IsBox bx1@@31 t1@@56)) ($IsBox bx2@@17 t2@@33)) ($Is f@@54 (Tclass._System.___hFunc3 t0@@80 t1@@56 t2@@33 t3@@18)))) (forall ((o@@69 T@U) (fld@@24 T@U) ) (! (let ((a@@109 (FieldTypeInv0 (type fld@@24))))
 (=> (and (and (= (type o@@69) refType) (= (type fld@@24) (FieldType a@@109))) (and (not (= o@@69 null)) (U_2_bool (MapType0Select (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17) ($Box o@@69))))) (= (MapType1Select (MapType0Select h0@@25 o@@69) fld@@24) (MapType1Select (MapType0Select h1@@25 o@@69) fld@@24))))
 :qid |unknown.0:0|
 :skolemid |944|
 :no-pattern (type o@@69)
 :no-pattern (type fld@@24)
 :no-pattern (U_2_int o@@69)
 :no-pattern (U_2_bool o@@69)
 :no-pattern (U_2_int fld@@24)
 :no-pattern (U_2_bool fld@@24)
)))) (= (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h0@@25 f@@54 bx0@@45 bx1@@31 bx2@@17) (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17)))
 :qid |unknown.0:0|
 :skolemid |945|
 :pattern ( ($HeapSucc h0@@25 h1@@25) (Reads3 t0@@80 t1@@56 t2@@33 t3@@18 h1@@25 f@@54 bx0@@45 bx1@@31 bx2@@17))
)))
(assert (forall ((t0@@81 T@U) (t1@@57 T@U) (t2@@34 T@U) (t3@@19 T@U) (h0@@26 T@U) (h1@@26 T@U) (f@@55 T@U) (bx0@@46 T@U) (bx1@@32 T@U) (bx2@@18 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@81) TyType) (= (type t1@@57) TyType)) (= (type t2@@34) TyType)) (= (type t3@@19) TyType)) (= (type h0@@26) (MapType0Type refType MapType1Type))) (= (type h1@@26) (MapType0Type refType MapType1Type))) (= (type f@@55) HandleTypeType)) (= (type bx0@@46) BoxType)) (= (type bx1@@32) BoxType)) (= (type bx2@@18) BoxType)) (and (and (and ($HeapSucc h0@@26 h1@@26) (and ($IsGoodHeap h0@@26) ($IsGoodHeap h1@@26))) (and (and (and ($IsBox bx0@@46 t0@@81) ($IsBox bx1@@32 t1@@57)) ($IsBox bx2@@18 t2@@34)) ($Is f@@55 (Tclass._System.___hFunc3 t0@@81 t1@@57 t2@@34 t3@@19)))) (forall ((o@@70 T@U) (fld@@25 T@U) ) (! (let ((a@@110 (FieldTypeInv0 (type fld@@25))))
 (=> (and (and (= (type o@@70) refType) (= (type fld@@25) (FieldType a@@110))) (and (not (= o@@70 null)) (U_2_bool (MapType0Select (Reads3 t0@@81 t1@@57 t2@@34 t3@@19 h0@@26 f@@55 bx0@@46 bx1@@32 bx2@@18) ($Box o@@70))))) (= (MapType1Select (MapType0Select h0@@26 o@@70) fld@@25) (MapType1Select (MapType0Select h1@@26 o@@70) fld@@25))))
 :qid |unknown.0:0|
 :skolemid |946|
 :no-pattern (type o@@70)
 :no-pattern (type fld@@25)
 :no-pattern (U_2_int o@@70)
 :no-pattern (U_2_bool o@@70)
 :no-pattern (U_2_int fld@@25)
 :no-pattern (U_2_bool fld@@25)
)))) (= (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h0@@26 f@@55 bx0@@46 bx1@@32 bx2@@18) (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h1@@26 f@@55 bx0@@46 bx1@@32 bx2@@18)))
 :qid |unknown.0:0|
 :skolemid |947|
 :pattern ( ($HeapSucc h0@@26 h1@@26) (Requires3 t0@@81 t1@@57 t2@@34 t3@@19 h1@@26 f@@55 bx0@@46 bx1@@32 bx2@@18))
)))
(assert (forall ((t0@@82 T@U) (t1@@58 T@U) (t2@@35 T@U) (t3@@20 T@U) (h0@@27 T@U) (h1@@27 T@U) (f@@56 T@U) (bx0@@47 T@U) (bx1@@33 T@U) (bx2@@19 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@82) TyType) (= (type t1@@58) TyType)) (= (type t2@@35) TyType)) (= (type t3@@20) TyType)) (= (type h0@@27) (MapType0Type refType MapType1Type))) (= (type h1@@27) (MapType0Type refType MapType1Type))) (= (type f@@56) HandleTypeType)) (= (type bx0@@47) BoxType)) (= (type bx1@@33) BoxType)) (= (type bx2@@19) BoxType)) (and (and (and ($HeapSucc h0@@27 h1@@27) (and ($IsGoodHeap h0@@27) ($IsGoodHeap h1@@27))) (and (and (and ($IsBox bx0@@47 t0@@82) ($IsBox bx1@@33 t1@@58)) ($IsBox bx2@@19 t2@@35)) ($Is f@@56 (Tclass._System.___hFunc3 t0@@82 t1@@58 t2@@35 t3@@20)))) (forall ((o@@71 T@U) (fld@@26 T@U) ) (! (let ((a@@111 (FieldTypeInv0 (type fld@@26))))
 (=> (and (and (= (type o@@71) refType) (= (type fld@@26) (FieldType a@@111))) (and (not (= o@@71 null)) (U_2_bool (MapType0Select (Reads3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19) ($Box o@@71))))) (= (MapType1Select (MapType0Select h0@@27 o@@71) fld@@26) (MapType1Select (MapType0Select h1@@27 o@@71) fld@@26))))
 :qid |unknown.0:0|
 :skolemid |948|
 :no-pattern (type o@@71)
 :no-pattern (type fld@@26)
 :no-pattern (U_2_int o@@71)
 :no-pattern (U_2_bool o@@71)
 :no-pattern (U_2_int fld@@26)
 :no-pattern (U_2_bool fld@@26)
)))) (= (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h0@@27 f@@56 bx0@@47 bx1@@33 bx2@@19) (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19)))
 :qid |unknown.0:0|
 :skolemid |949|
 :pattern ( ($HeapSucc h0@@27 h1@@27) (Requires3 t0@@82 t1@@58 t2@@35 t3@@20 h1@@27 f@@56 bx0@@47 bx1@@33 bx2@@19))
)))
(assert (forall ((t0@@83 T@U) (t1@@59 T@U) (t2@@36 T@U) (t3@@21 T@U) (h0@@28 T@U) (h1@@28 T@U) (f@@57 T@U) (bx0@@48 T@U) (bx1@@34 T@U) (bx2@@20 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@83) TyType) (= (type t1@@59) TyType)) (= (type t2@@36) TyType)) (= (type t3@@21) TyType)) (= (type h0@@28) (MapType0Type refType MapType1Type))) (= (type h1@@28) (MapType0Type refType MapType1Type))) (= (type f@@57) HandleTypeType)) (= (type bx0@@48) BoxType)) (= (type bx1@@34) BoxType)) (= (type bx2@@20) BoxType)) (and (and (and ($HeapSucc h0@@28 h1@@28) (and ($IsGoodHeap h0@@28) ($IsGoodHeap h1@@28))) (and (and (and ($IsBox bx0@@48 t0@@83) ($IsBox bx1@@34 t1@@59)) ($IsBox bx2@@20 t2@@36)) ($Is f@@57 (Tclass._System.___hFunc3 t0@@83 t1@@59 t2@@36 t3@@21)))) (forall ((o@@72 T@U) (fld@@27 T@U) ) (! (let ((a@@112 (FieldTypeInv0 (type fld@@27))))
 (=> (and (and (= (type o@@72) refType) (= (type fld@@27) (FieldType a@@112))) (and (not (= o@@72 null)) (U_2_bool (MapType0Select (Reads3 t0@@83 t1@@59 t2@@36 t3@@21 h0@@28 f@@57 bx0@@48 bx1@@34 bx2@@20) ($Box o@@72))))) (= (MapType1Select (MapType0Select h0@@28 o@@72) fld@@27) (MapType1Select (MapType0Select h1@@28 o@@72) fld@@27))))
 :qid |unknown.0:0|
 :skolemid |950|
 :no-pattern (type o@@72)
 :no-pattern (type fld@@27)
 :no-pattern (U_2_int o@@72)
 :no-pattern (U_2_bool o@@72)
 :no-pattern (U_2_int fld@@27)
 :no-pattern (U_2_bool fld@@27)
)))) (= (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h0@@28 f@@57 bx0@@48 bx1@@34 bx2@@20) (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h1@@28 f@@57 bx0@@48 bx1@@34 bx2@@20)))
 :qid |unknown.0:0|
 :skolemid |951|
 :pattern ( ($HeapSucc h0@@28 h1@@28) (Apply3 t0@@83 t1@@59 t2@@36 t3@@21 h1@@28 f@@57 bx0@@48 bx1@@34 bx2@@20))
)))
(assert (forall ((t0@@84 T@U) (t1@@60 T@U) (t2@@37 T@U) (t3@@22 T@U) (h0@@29 T@U) (h1@@29 T@U) (f@@58 T@U) (bx0@@49 T@U) (bx1@@35 T@U) (bx2@@21 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type t0@@84) TyType) (= (type t1@@60) TyType)) (= (type t2@@37) TyType)) (= (type t3@@22) TyType)) (= (type h0@@29) (MapType0Type refType MapType1Type))) (= (type h1@@29) (MapType0Type refType MapType1Type))) (= (type f@@58) HandleTypeType)) (= (type bx0@@49) BoxType)) (= (type bx1@@35) BoxType)) (= (type bx2@@21) BoxType)) (and (and (and ($HeapSucc h0@@29 h1@@29) (and ($IsGoodHeap h0@@29) ($IsGoodHeap h1@@29))) (and (and (and ($IsBox bx0@@49 t0@@84) ($IsBox bx1@@35 t1@@60)) ($IsBox bx2@@21 t2@@37)) ($Is f@@58 (Tclass._System.___hFunc3 t0@@84 t1@@60 t2@@37 t3@@22)))) (forall ((o@@73 T@U) (fld@@28 T@U) ) (! (let ((a@@113 (FieldTypeInv0 (type fld@@28))))
 (=> (and (and (= (type o@@73) refType) (= (type fld@@28) (FieldType a@@113))) (and (not (= o@@73 null)) (U_2_bool (MapType0Select (Reads3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21) ($Box o@@73))))) (= (MapType1Select (MapType0Select h0@@29 o@@73) fld@@28) (MapType1Select (MapType0Select h1@@29 o@@73) fld@@28))))
 :qid |unknown.0:0|
 :skolemid |952|
 :no-pattern (type o@@73)
 :no-pattern (type fld@@28)
 :no-pattern (U_2_int o@@73)
 :no-pattern (U_2_bool o@@73)
 :no-pattern (U_2_int fld@@28)
 :no-pattern (U_2_bool fld@@28)
)))) (= (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h0@@29 f@@58 bx0@@49 bx1@@35 bx2@@21) (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21)))
 :qid |unknown.0:0|
 :skolemid |953|
 :pattern ( ($HeapSucc h0@@29 h1@@29) (Apply3 t0@@84 t1@@60 t2@@37 t3@@22 h1@@29 f@@58 bx0@@49 bx1@@35 bx2@@21))
)))
(assert (forall ((t0@@85 T@U) (t1@@61 T@U) (t2@@38 T@U) (t3@@23 T@U) (heap@@24 T@U) (f@@59 T@U) (bx0@@50 T@U) (bx1@@36 T@U) (bx2@@22 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@85) TyType) (= (type t1@@61) TyType)) (= (type t2@@38) TyType)) (= (type t3@@23) TyType)) (= (type heap@@24) (MapType0Type refType MapType1Type))) (= (type f@@59) HandleTypeType)) (= (type bx0@@50) BoxType)) (= (type bx1@@36) BoxType)) (= (type bx2@@22) BoxType)) (and ($IsGoodHeap heap@@24) (and (and (and ($IsBox bx0@@50 t0@@85) ($IsBox bx1@@36 t1@@61)) ($IsBox bx2@@22 t2@@38)) ($Is f@@59 (Tclass._System.___hFunc3 t0@@85 t1@@61 t2@@38 t3@@23))))) (= (|Set#Equal| (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 $OneHeap f@@59 bx0@@50 bx1@@36 bx2@@22) (|Set#Empty| BoxType)) (|Set#Equal| (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 heap@@24 f@@59 bx0@@50 bx1@@36 bx2@@22) (|Set#Empty| BoxType))))
 :qid |unknown.0:0|
 :skolemid |954|
 :pattern ( (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 $OneHeap f@@59 bx0@@50 bx1@@36 bx2@@22) ($IsGoodHeap heap@@24))
 :pattern ( (Reads3 t0@@85 t1@@61 t2@@38 t3@@23 heap@@24 f@@59 bx0@@50 bx1@@36 bx2@@22))
)))
(assert (forall ((t0@@86 T@U) (t1@@62 T@U) (t2@@39 T@U) (t3@@24 T@U) (heap@@25 T@U) (f@@60 T@U) (bx0@@51 T@U) (bx1@@37 T@U) (bx2@@23 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type t0@@86) TyType) (= (type t1@@62) TyType)) (= (type t2@@39) TyType)) (= (type t3@@24) TyType)) (= (type heap@@25) (MapType0Type refType MapType1Type))) (= (type f@@60) HandleTypeType)) (= (type bx0@@51) BoxType)) (= (type bx1@@37) BoxType)) (= (type bx2@@23) BoxType)) (and (and ($IsGoodHeap heap@@25) (and (and (and ($IsBox bx0@@51 t0@@86) ($IsBox bx1@@37 t1@@62)) ($IsBox bx2@@23 t2@@39)) ($Is f@@60 (Tclass._System.___hFunc3 t0@@86 t1@@62 t2@@39 t3@@24)))) (|Set#Equal| (Reads3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) (|Set#Empty| BoxType)))) (= (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 heap@@25 f@@60 bx0@@51 bx1@@37 bx2@@23)))
 :qid |unknown.0:0|
 :skolemid |955|
 :pattern ( (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 $OneHeap f@@60 bx0@@51 bx1@@37 bx2@@23) ($IsGoodHeap heap@@25))
 :pattern ( (Requires3 t0@@86 t1@@62 t2@@39 t3@@24 heap@@25 f@@60 bx0@@51 bx1@@37 bx2@@23))
)))
(assert (forall ((f@@61 T@U) (t0@@87 T@U) (t1@@63 T@U) (t2@@40 T@U) (t3@@25 T@U) ) (!  (=> (and (and (and (and (= (type f@@61) HandleTypeType) (= (type t0@@87) TyType)) (= (type t1@@63) TyType)) (= (type t2@@40) TyType)) (= (type t3@@25) TyType)) (= ($Is f@@61 (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25)) (forall ((h@@48 T@U) (bx0@@52 T@U) (bx1@@38 T@U) (bx2@@24 T@U) ) (!  (=> (and (and (and (and (= (type h@@48) (MapType0Type refType MapType1Type)) (= (type bx0@@52) BoxType)) (= (type bx1@@38) BoxType)) (= (type bx2@@24) BoxType)) (and (and ($IsGoodHeap h@@48) (and (and ($IsBox bx0@@52 t0@@87) ($IsBox bx1@@38 t1@@63)) ($IsBox bx2@@24 t2@@40))) (Requires3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24))) ($IsBox (Apply3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24) t3@@25))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |956|
 :pattern ( (Apply3 t0@@87 t1@@63 t2@@40 t3@@25 h@@48 f@@61 bx0@@52 bx1@@38 bx2@@24))
))))
 :qid |unknown.0:0|
 :skolemid |957|
 :pattern ( ($Is f@@61 (Tclass._System.___hFunc3 t0@@87 t1@@63 t2@@40 t3@@25)))
)))
(assert (forall ((f@@62 T@U) (t0@@88 T@U) (t1@@64 T@U) (t2@@41 T@U) (t3@@26 T@U) (u0@@3 T@U) (u1@@2 T@U) (u2@@1 T@U) (u3@@0 T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (= (type f@@62) HandleTypeType) (= (type t0@@88) TyType)) (= (type t1@@64) TyType)) (= (type t2@@41) TyType)) (= (type t3@@26) TyType)) (= (type u0@@3) TyType)) (= (type u1@@2) TyType)) (= (type u2@@1) TyType)) (= (type u3@@0) TyType)) (and (and (and (and ($Is f@@62 (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26)) (forall ((bx@@62 T@U) ) (!  (=> (and (= (type bx@@62) BoxType) ($IsBox bx@@62 u0@@3)) ($IsBox bx@@62 t0@@88))
 :qid |unknown.0:0|
 :skolemid |958|
 :pattern ( ($IsBox bx@@62 u0@@3))
 :pattern ( ($IsBox bx@@62 t0@@88))
))) (forall ((bx@@63 T@U) ) (!  (=> (and (= (type bx@@63) BoxType) ($IsBox bx@@63 u1@@2)) ($IsBox bx@@63 t1@@64))
 :qid |unknown.0:0|
 :skolemid |959|
 :pattern ( ($IsBox bx@@63 u1@@2))
 :pattern ( ($IsBox bx@@63 t1@@64))
))) (forall ((bx@@64 T@U) ) (!  (=> (and (= (type bx@@64) BoxType) ($IsBox bx@@64 u2@@1)) ($IsBox bx@@64 t2@@41))
 :qid |unknown.0:0|
 :skolemid |960|
 :pattern ( ($IsBox bx@@64 u2@@1))
 :pattern ( ($IsBox bx@@64 t2@@41))
))) (forall ((bx@@65 T@U) ) (!  (=> (and (= (type bx@@65) BoxType) ($IsBox bx@@65 t3@@26)) ($IsBox bx@@65 u3@@0))
 :qid |unknown.0:0|
 :skolemid |961|
 :pattern ( ($IsBox bx@@65 t3@@26))
 :pattern ( ($IsBox bx@@65 u3@@0))
)))) ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0)))
 :qid |unknown.0:0|
 :skolemid |962|
 :pattern ( ($Is f@@62 (Tclass._System.___hFunc3 t0@@88 t1@@64 t2@@41 t3@@26)) ($Is f@@62 (Tclass._System.___hFunc3 u0@@3 u1@@2 u2@@1 u3@@0)))
)))
(assert (forall ((f@@63 T@U) (t0@@89 T@U) (t1@@65 T@U) (t2@@42 T@U) (t3@@27 T@U) (h@@49 T@U) ) (!  (=> (and (and (and (and (and (and (= (type f@@63) HandleTypeType) (= (type t0@@89) TyType)) (= (type t1@@65) TyType)) (= (type t2@@42) TyType)) (= (type t3@@27) TyType)) (= (type h@@49) (MapType0Type refType MapType1Type))) ($IsGoodHeap h@@49)) (= ($IsAlloc f@@63 (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27) h@@49) (forall ((bx0@@53 T@U) (bx1@@39 T@U) (bx2@@25 T@U) ) (!  (=> (and (and (= (type bx0@@53) BoxType) (= (type bx1@@39) BoxType)) (= (type bx2@@25) BoxType)) (=> (and (and (and (and ($IsBox bx0@@53 t0@@89) ($IsAllocBox bx0@@53 t0@@89 h@@49)) (and ($IsBox bx1@@39 t1@@65) ($IsAllocBox bx1@@39 t1@@65 h@@49))) (and ($IsBox bx2@@25 t2@@42) ($IsAllocBox bx2@@25 t2@@42 h@@49))) (Requires3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25)) (forall ((r@@25 T@U) ) (!  (=> (= (type r@@25) refType) (=> (and (not (= r@@25 null)) (U_2_bool (MapType0Select (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25) ($Box r@@25)))) (U_2_bool (MapType1Select (MapType0Select h@@49 r@@25) alloc))))
 :qid |unknown.0:0|
 :skolemid |963|
 :pattern ( (MapType0Select (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25) ($Box r@@25)))
))))
 :qid |unknown.0:0|
 :skolemid |964|
 :pattern ( (Apply3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25))
 :pattern ( (Reads3 t0@@89 t1@@65 t2@@42 t3@@27 h@@49 f@@63 bx0@@53 bx1@@39 bx2@@25))
))))
 :qid |unknown.0:0|
 :skolemid |965|
 :pattern ( ($IsAlloc f@@63 (Tclass._System.___hFunc3 t0@@89 t1@@65 t2@@42 t3@@27) h@@49))
)))
(assert (forall ((f@@64 T@U) (t0@@90 T@U) (t1@@66 T@U) (t2@@43 T@U) (t3@@28 T@U) (h@@50 T@U) ) (!  (=> (and (and (and (and (and (and (= (type f@@64) HandleTypeType) (= (type t0@@90) TyType)) (= (type t1@@66) TyType)) (= (type t2@@43) TyType)) (= (type t3@@28) TyType)) (= (type h@@50) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap h@@50) ($IsAlloc f@@64 (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28) h@@50))) (forall ((bx0@@54 T@U) (bx1@@40 T@U) (bx2@@26 T@U) ) (!  (=> (and (and (= (type bx0@@54) BoxType) (= (type bx1@@40) BoxType)) (= (type bx2@@26) BoxType)) (=> (and (and (and ($IsAllocBox bx0@@54 t0@@90 h@@50) ($IsAllocBox bx1@@40 t1@@66 h@@50)) ($IsAllocBox bx2@@26 t2@@43 h@@50)) (Requires3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26)) ($IsAllocBox (Apply3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26) t3@@28 h@@50)))
 :qid |unknown.0:0|
 :skolemid |966|
 :pattern ( (Apply3 t0@@90 t1@@66 t2@@43 t3@@28 h@@50 f@@64 bx0@@54 bx1@@40 bx2@@26))
)))
 :qid |unknown.0:0|
 :skolemid |967|
 :pattern ( ($IsAlloc f@@64 (Tclass._System.___hFunc3 t0@@90 t1@@66 t2@@43 t3@@28) h@@50))
)))
(assert (forall ((arg0@@216 T@U) (arg1@@107 T@U) (arg2@@59 T@U) (arg3@@37 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3 arg0@@216 arg1@@107 arg2@@59 arg3@@37)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3|
 :pattern ( (Tclass._System.___hPartialFunc3 arg0@@216 arg1@@107 arg2@@59 arg3@@37))
)))
(assert (forall ((|#$T0@@65| T@U) (|#$T1@@49| T@U) (|#$T2@@30| T@U) (|#$R@@78| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@65|) TyType) (= (type |#$T1@@49|) TyType)) (= (type |#$T2@@30|) TyType)) (= (type |#$R@@78|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|)) Tagclass._System.___hPartialFunc3) (= (TagFamily (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|)) |tytagFamily$_#PartialFunc3|)))
 :qid |unknown.0:0|
 :skolemid |968|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@65| |#$T1@@49| |#$T2@@30| |#$R@@78|))
)))
(assert (forall ((arg0@@217 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_0 arg0@@217)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_0|
 :pattern ( (Tclass._System.___hPartialFunc3_0 arg0@@217))
)))
(assert (forall ((|#$T0@@66| T@U) (|#$T1@@50| T@U) (|#$T2@@31| T@U) (|#$R@@79| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@66|) TyType) (= (type |#$T1@@50|) TyType)) (= (type |#$T2@@31|) TyType)) (= (type |#$R@@79|) TyType)) (= (Tclass._System.___hPartialFunc3_0 (Tclass._System.___hPartialFunc3 |#$T0@@66| |#$T1@@50| |#$T2@@31| |#$R@@79|)) |#$T0@@66|))
 :qid |unknown.0:0|
 :skolemid |969|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@66| |#$T1@@50| |#$T2@@31| |#$R@@79|))
)))
(assert (forall ((arg0@@218 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_1 arg0@@218)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_1|
 :pattern ( (Tclass._System.___hPartialFunc3_1 arg0@@218))
)))
(assert (forall ((|#$T0@@67| T@U) (|#$T1@@51| T@U) (|#$T2@@32| T@U) (|#$R@@80| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@67|) TyType) (= (type |#$T1@@51|) TyType)) (= (type |#$T2@@32|) TyType)) (= (type |#$R@@80|) TyType)) (= (Tclass._System.___hPartialFunc3_1 (Tclass._System.___hPartialFunc3 |#$T0@@67| |#$T1@@51| |#$T2@@32| |#$R@@80|)) |#$T1@@51|))
 :qid |unknown.0:0|
 :skolemid |970|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@67| |#$T1@@51| |#$T2@@32| |#$R@@80|))
)))
(assert (forall ((arg0@@219 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_2 arg0@@219)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_2|
 :pattern ( (Tclass._System.___hPartialFunc3_2 arg0@@219))
)))
(assert (forall ((|#$T0@@68| T@U) (|#$T1@@52| T@U) (|#$T2@@33| T@U) (|#$R@@81| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@68|) TyType) (= (type |#$T1@@52|) TyType)) (= (type |#$T2@@33|) TyType)) (= (type |#$R@@81|) TyType)) (= (Tclass._System.___hPartialFunc3_2 (Tclass._System.___hPartialFunc3 |#$T0@@68| |#$T1@@52| |#$T2@@33| |#$R@@81|)) |#$T2@@33|))
 :qid |unknown.0:0|
 :skolemid |971|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@68| |#$T1@@52| |#$T2@@33| |#$R@@81|))
)))
(assert (forall ((arg0@@220 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3_3 arg0@@220)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3_3|
 :pattern ( (Tclass._System.___hPartialFunc3_3 arg0@@220))
)))
(assert (forall ((|#$T0@@69| T@U) (|#$T1@@53| T@U) (|#$T2@@34| T@U) (|#$R@@82| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@69|) TyType) (= (type |#$T1@@53|) TyType)) (= (type |#$T2@@34|) TyType)) (= (type |#$R@@82|) TyType)) (= (Tclass._System.___hPartialFunc3_3 (Tclass._System.___hPartialFunc3 |#$T0@@69| |#$T1@@53| |#$T2@@34| |#$R@@82|)) |#$R@@82|))
 :qid |unknown.0:0|
 :skolemid |972|
 :pattern ( (Tclass._System.___hPartialFunc3 |#$T0@@69| |#$T1@@53| |#$T2@@34| |#$R@@82|))
)))
(assert (forall ((|#$T0@@70| T@U) (|#$T1@@54| T@U) (|#$T2@@35| T@U) (|#$R@@83| T@U) (bx@@66 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@70|) TyType) (= (type |#$T1@@54|) TyType)) (= (type |#$T2@@35|) TyType)) (= (type |#$R@@83|) TyType)) (= (type bx@@66) BoxType)) ($IsBox bx@@66 (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|))) (and (= ($Box ($Unbox HandleTypeType bx@@66)) bx@@66) ($Is ($Unbox HandleTypeType bx@@66) (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|))))
 :qid |unknown.0:0|
 :skolemid |973|
 :pattern ( ($IsBox bx@@66 (Tclass._System.___hPartialFunc3 |#$T0@@70| |#$T1@@54| |#$T2@@35| |#$R@@83|)))
)))
(assert (forall ((|#$T0@@71| T@U) (|#$T1@@55| T@U) (|#$T2@@36| T@U) (|#$R@@84| T@U) (|f#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@71|) TyType) (= (type |#$T1@@55|) TyType)) (= (type |#$T2@@36|) TyType)) (= (type |#$R@@84|) TyType)) (= (type |f#0@@15|) HandleTypeType)) (= ($Is |f#0@@15| (Tclass._System.___hPartialFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|))  (and ($Is |f#0@@15| (Tclass._System.___hFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|)) (forall ((|x0#0@@5| T@U) (|x1#0@@3| T@U) (|x2#0@@1| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@5|) BoxType) (= (type |x1#0@@3|) BoxType)) (= (type |x2#0@@1|) BoxType)) (and (and ($IsBox |x0#0@@5| |#$T0@@71|) ($IsBox |x1#0@@3| |#$T1@@55|)) ($IsBox |x2#0@@1| |#$T2@@36|))) (|Set#Equal| (Reads3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84| $OneHeap |f#0@@15| |x0#0@@5| |x1#0@@3| |x2#0@@1|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |974|
 :no-pattern (type |x0#0@@5|)
 :no-pattern (type |x1#0@@3|)
 :no-pattern (type |x2#0@@1|)
 :no-pattern (U_2_int |x0#0@@5|)
 :no-pattern (U_2_bool |x0#0@@5|)
 :no-pattern (U_2_int |x1#0@@3|)
 :no-pattern (U_2_bool |x1#0@@3|)
 :no-pattern (U_2_int |x2#0@@1|)
 :no-pattern (U_2_bool |x2#0@@1|)
)))))
 :qid |unknown.0:0|
 :skolemid |975|
 :pattern ( ($Is |f#0@@15| (Tclass._System.___hPartialFunc3 |#$T0@@71| |#$T1@@55| |#$T2@@36| |#$R@@84|)))
)))
(assert (forall ((|#$T0@@72| T@U) (|#$T1@@56| T@U) (|#$T2@@37| T@U) (|#$R@@85| T@U) (|f#0@@16| T@U) ($h@@19 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@72|) TyType) (= (type |#$T1@@56|) TyType)) (= (type |#$T2@@37|) TyType)) (= (type |#$R@@85|) TyType)) (= (type |f#0@@16|) HandleTypeType)) (= (type $h@@19) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@16| (Tclass._System.___hPartialFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19) ($IsAlloc |f#0@@16| (Tclass._System.___hFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19)))
 :qid |unknown.0:0|
 :skolemid |976|
 :pattern ( ($IsAlloc |f#0@@16| (Tclass._System.___hPartialFunc3 |#$T0@@72| |#$T1@@56| |#$T2@@37| |#$R@@85|) $h@@19))
)))
(assert (forall ((arg0@@221 T@U) (arg1@@108 T@U) (arg2@@60 T@U) (arg3@@38 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3 arg0@@221 arg1@@108 arg2@@60 arg3@@38)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3|
 :pattern ( (Tclass._System.___hTotalFunc3 arg0@@221 arg1@@108 arg2@@60 arg3@@38))
)))
(assert (forall ((|#$T0@@73| T@U) (|#$T1@@57| T@U) (|#$T2@@38| T@U) (|#$R@@86| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@73|) TyType) (= (type |#$T1@@57|) TyType)) (= (type |#$T2@@38|) TyType)) (= (type |#$R@@86|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|)) Tagclass._System.___hTotalFunc3) (= (TagFamily (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|)) |tytagFamily$_#TotalFunc3|)))
 :qid |unknown.0:0|
 :skolemid |977|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@73| |#$T1@@57| |#$T2@@38| |#$R@@86|))
)))
(assert (forall ((arg0@@222 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_0 arg0@@222)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_0|
 :pattern ( (Tclass._System.___hTotalFunc3_0 arg0@@222))
)))
(assert (forall ((|#$T0@@74| T@U) (|#$T1@@58| T@U) (|#$T2@@39| T@U) (|#$R@@87| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@74|) TyType) (= (type |#$T1@@58|) TyType)) (= (type |#$T2@@39|) TyType)) (= (type |#$R@@87|) TyType)) (= (Tclass._System.___hTotalFunc3_0 (Tclass._System.___hTotalFunc3 |#$T0@@74| |#$T1@@58| |#$T2@@39| |#$R@@87|)) |#$T0@@74|))
 :qid |unknown.0:0|
 :skolemid |978|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@74| |#$T1@@58| |#$T2@@39| |#$R@@87|))
)))
(assert (forall ((arg0@@223 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_1 arg0@@223)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_1|
 :pattern ( (Tclass._System.___hTotalFunc3_1 arg0@@223))
)))
(assert (forall ((|#$T0@@75| T@U) (|#$T1@@59| T@U) (|#$T2@@40| T@U) (|#$R@@88| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@75|) TyType) (= (type |#$T1@@59|) TyType)) (= (type |#$T2@@40|) TyType)) (= (type |#$R@@88|) TyType)) (= (Tclass._System.___hTotalFunc3_1 (Tclass._System.___hTotalFunc3 |#$T0@@75| |#$T1@@59| |#$T2@@40| |#$R@@88|)) |#$T1@@59|))
 :qid |unknown.0:0|
 :skolemid |979|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@75| |#$T1@@59| |#$T2@@40| |#$R@@88|))
)))
(assert (forall ((arg0@@224 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_2 arg0@@224)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_2|
 :pattern ( (Tclass._System.___hTotalFunc3_2 arg0@@224))
)))
(assert (forall ((|#$T0@@76| T@U) (|#$T1@@60| T@U) (|#$T2@@41| T@U) (|#$R@@89| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@76|) TyType) (= (type |#$T1@@60|) TyType)) (= (type |#$T2@@41|) TyType)) (= (type |#$R@@89|) TyType)) (= (Tclass._System.___hTotalFunc3_2 (Tclass._System.___hTotalFunc3 |#$T0@@76| |#$T1@@60| |#$T2@@41| |#$R@@89|)) |#$T2@@41|))
 :qid |unknown.0:0|
 :skolemid |980|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@76| |#$T1@@60| |#$T2@@41| |#$R@@89|))
)))
(assert (forall ((arg0@@225 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3_3 arg0@@225)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3_3|
 :pattern ( (Tclass._System.___hTotalFunc3_3 arg0@@225))
)))
(assert (forall ((|#$T0@@77| T@U) (|#$T1@@61| T@U) (|#$T2@@42| T@U) (|#$R@@90| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@77|) TyType) (= (type |#$T1@@61|) TyType)) (= (type |#$T2@@42|) TyType)) (= (type |#$R@@90|) TyType)) (= (Tclass._System.___hTotalFunc3_3 (Tclass._System.___hTotalFunc3 |#$T0@@77| |#$T1@@61| |#$T2@@42| |#$R@@90|)) |#$R@@90|))
 :qid |unknown.0:0|
 :skolemid |981|
 :pattern ( (Tclass._System.___hTotalFunc3 |#$T0@@77| |#$T1@@61| |#$T2@@42| |#$R@@90|))
)))
(assert (forall ((|#$T0@@78| T@U) (|#$T1@@62| T@U) (|#$T2@@43| T@U) (|#$R@@91| T@U) (bx@@67 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@78|) TyType) (= (type |#$T1@@62|) TyType)) (= (type |#$T2@@43|) TyType)) (= (type |#$R@@91|) TyType)) (= (type bx@@67) BoxType)) ($IsBox bx@@67 (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|))) (and (= ($Box ($Unbox HandleTypeType bx@@67)) bx@@67) ($Is ($Unbox HandleTypeType bx@@67) (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|))))
 :qid |unknown.0:0|
 :skolemid |982|
 :pattern ( ($IsBox bx@@67 (Tclass._System.___hTotalFunc3 |#$T0@@78| |#$T1@@62| |#$T2@@43| |#$R@@91|)))
)))
(assert (forall ((|#$T0@@79| T@U) (|#$T1@@63| T@U) (|#$T2@@44| T@U) (|#$R@@92| T@U) (|f#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@79|) TyType) (= (type |#$T1@@63|) TyType)) (= (type |#$T2@@44|) TyType)) (= (type |#$R@@92|) TyType)) (= (type |f#0@@17|) HandleTypeType)) (= ($Is |f#0@@17| (Tclass._System.___hTotalFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|))  (and ($Is |f#0@@17| (Tclass._System.___hPartialFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|)) (forall ((|x0#0@@6| T@U) (|x1#0@@4| T@U) (|x2#0@@2| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@6|) BoxType) (= (type |x1#0@@4|) BoxType)) (= (type |x2#0@@2|) BoxType)) (and (and ($IsBox |x0#0@@6| |#$T0@@79|) ($IsBox |x1#0@@4| |#$T1@@63|)) ($IsBox |x2#0@@2| |#$T2@@44|))) (Requires3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92| $OneHeap |f#0@@17| |x0#0@@6| |x1#0@@4| |x2#0@@2|))
 :qid |unknown.0:0|
 :skolemid |983|
 :no-pattern (type |x0#0@@6|)
 :no-pattern (type |x1#0@@4|)
 :no-pattern (type |x2#0@@2|)
 :no-pattern (U_2_int |x0#0@@6|)
 :no-pattern (U_2_bool |x0#0@@6|)
 :no-pattern (U_2_int |x1#0@@4|)
 :no-pattern (U_2_bool |x1#0@@4|)
 :no-pattern (U_2_int |x2#0@@2|)
 :no-pattern (U_2_bool |x2#0@@2|)
)))))
 :qid |unknown.0:0|
 :skolemid |984|
 :pattern ( ($Is |f#0@@17| (Tclass._System.___hTotalFunc3 |#$T0@@79| |#$T1@@63| |#$T2@@44| |#$R@@92|)))
)))
(assert (forall ((|#$T0@@80| T@U) (|#$T1@@64| T@U) (|#$T2@@45| T@U) (|#$R@@93| T@U) (|f#0@@18| T@U) ($h@@20 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@80|) TyType) (= (type |#$T1@@64|) TyType)) (= (type |#$T2@@45|) TyType)) (= (type |#$R@@93|) TyType)) (= (type |f#0@@18|) HandleTypeType)) (= (type $h@@20) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@18| (Tclass._System.___hTotalFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20) ($IsAlloc |f#0@@18| (Tclass._System.___hPartialFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20)))
 :qid |unknown.0:0|
 :skolemid |985|
 :pattern ( ($IsAlloc |f#0@@18| (Tclass._System.___hTotalFunc3 |#$T0@@80| |#$T1@@64| |#$T2@@45| |#$R@@93|) $h@@20))
)))
(assert (forall ((arg0@@226 T@U) (arg1@@109 T@U) (arg2@@61 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO|
 :pattern ( (Tclass._System.___hFunc2OSO arg0@@226 arg1@@109 arg2@@61))
)))
(assert (forall ((|#$T0@@81| T@U) (|#$T1@@65| T@U) (|#$R@@94| T@U) ) (!  (=> (and (and (= (type |#$T0@@81|) TyType) (= (type |#$T1@@65|) TyType)) (= (type |#$R@@94|) TyType)) (and (= (Tag (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|)) Tagclass._System.___hFunc2OSO) (= (TagFamily (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|)) |tytagFamily$_#Func2OSO|)))
 :qid |unknown.0:0|
 :skolemid |986|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@81| |#$T1@@65| |#$R@@94|))
)))
(assert (forall ((arg0@@227 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_0 arg0@@227)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_0|
 :pattern ( (Tclass._System.___hFunc2OSO_0 arg0@@227))
)))
(assert (forall ((|#$T0@@82| T@U) (|#$T1@@66| T@U) (|#$R@@95| T@U) ) (!  (=> (and (and (= (type |#$T0@@82|) TyType) (= (type |#$T1@@66|) TyType)) (= (type |#$R@@95|) TyType)) (= (Tclass._System.___hFunc2OSO_0 (Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|)) |#$T0@@82|))
 :qid |unknown.0:0|
 :skolemid |987|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@82| |#$T1@@66| |#$R@@95|))
)))
(assert (forall ((arg0@@228 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_1 arg0@@228)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_1|
 :pattern ( (Tclass._System.___hFunc2OSO_1 arg0@@228))
)))
(assert (forall ((|#$T0@@83| T@U) (|#$T1@@67| T@U) (|#$R@@96| T@U) ) (!  (=> (and (and (= (type |#$T0@@83|) TyType) (= (type |#$T1@@67|) TyType)) (= (type |#$R@@96|) TyType)) (= (Tclass._System.___hFunc2OSO_1 (Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|)) |#$T1@@67|))
 :qid |unknown.0:0|
 :skolemid |988|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@83| |#$T1@@67| |#$R@@96|))
)))
(assert (forall ((arg0@@229 T@U) ) (! (= (type (Tclass._System.___hFunc2OSO_2 arg0@@229)) TyType)
 :qid |funType:Tclass._System.___hFunc2OSO_2|
 :pattern ( (Tclass._System.___hFunc2OSO_2 arg0@@229))
)))
(assert (forall ((|#$T0@@84| T@U) (|#$T1@@68| T@U) (|#$R@@97| T@U) ) (!  (=> (and (and (= (type |#$T0@@84|) TyType) (= (type |#$T1@@68|) TyType)) (= (type |#$R@@97|) TyType)) (= (Tclass._System.___hFunc2OSO_2 (Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|)) |#$R@@97|))
 :qid |unknown.0:0|
 :skolemid |989|
 :pattern ( (Tclass._System.___hFunc2OSO |#$T0@@84| |#$T1@@68| |#$R@@97|))
)))
(assert (forall ((|#$T0@@85| T@U) (|#$T1@@69| T@U) (|#$R@@98| T@U) (bx@@68 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@85|) TyType) (= (type |#$T1@@69|) TyType)) (= (type |#$R@@98|) TyType)) (= (type bx@@68) BoxType)) ($IsBox bx@@68 (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|))) (and (= ($Box ($Unbox HandleTypeType bx@@68)) bx@@68) ($Is ($Unbox HandleTypeType bx@@68) (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|))))
 :qid |unknown.0:0|
 :skolemid |990|
 :pattern ( ($IsBox bx@@68 (Tclass._System.___hFunc2OSO |#$T0@@85| |#$T1@@69| |#$R@@98|)))
)))
(assert (forall ((arg0@@230 T@U) (arg1@@110 T@U) (arg2@@62 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO|
 :pattern ( (Tclass._System.___hPartialFunc2OSO arg0@@230 arg1@@110 arg2@@62))
)))
(assert (forall ((|#$T0@@86| T@U) (|#$T1@@70| T@U) (|#$R@@99| T@U) ) (!  (=> (and (and (= (type |#$T0@@86|) TyType) (= (type |#$T1@@70|) TyType)) (= (type |#$R@@99|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|)) Tagclass._System.___hPartialFunc2OSO) (= (TagFamily (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|)) |tytagFamily$_#PartialFunc2OSO|)))
 :qid |unknown.0:0|
 :skolemid |991|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@86| |#$T1@@70| |#$R@@99|))
)))
(assert (forall ((arg0@@231 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_0 arg0@@231)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_0|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_0 arg0@@231))
)))
(assert (forall ((|#$T0@@87| T@U) (|#$T1@@71| T@U) (|#$R@@100| T@U) ) (!  (=> (and (and (= (type |#$T0@@87|) TyType) (= (type |#$T1@@71|) TyType)) (= (type |#$R@@100|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_0 (Tclass._System.___hPartialFunc2OSO |#$T0@@87| |#$T1@@71| |#$R@@100|)) |#$T0@@87|))
 :qid |unknown.0:0|
 :skolemid |992|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@87| |#$T1@@71| |#$R@@100|))
)))
(assert (forall ((arg0@@232 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_1 arg0@@232)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_1|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_1 arg0@@232))
)))
(assert (forall ((|#$T0@@88| T@U) (|#$T1@@72| T@U) (|#$R@@101| T@U) ) (!  (=> (and (and (= (type |#$T0@@88|) TyType) (= (type |#$T1@@72|) TyType)) (= (type |#$R@@101|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_1 (Tclass._System.___hPartialFunc2OSO |#$T0@@88| |#$T1@@72| |#$R@@101|)) |#$T1@@72|))
 :qid |unknown.0:0|
 :skolemid |993|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@88| |#$T1@@72| |#$R@@101|))
)))
(assert (forall ((arg0@@233 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2OSO_2 arg0@@233)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2OSO_2|
 :pattern ( (Tclass._System.___hPartialFunc2OSO_2 arg0@@233))
)))
(assert (forall ((|#$T0@@89| T@U) (|#$T1@@73| T@U) (|#$R@@102| T@U) ) (!  (=> (and (and (= (type |#$T0@@89|) TyType) (= (type |#$T1@@73|) TyType)) (= (type |#$R@@102|) TyType)) (= (Tclass._System.___hPartialFunc2OSO_2 (Tclass._System.___hPartialFunc2OSO |#$T0@@89| |#$T1@@73| |#$R@@102|)) |#$R@@102|))
 :qid |unknown.0:0|
 :skolemid |994|
 :pattern ( (Tclass._System.___hPartialFunc2OSO |#$T0@@89| |#$T1@@73| |#$R@@102|))
)))
(assert (forall ((|#$T0@@90| T@U) (|#$T1@@74| T@U) (|#$R@@103| T@U) (bx@@69 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@90|) TyType) (= (type |#$T1@@74|) TyType)) (= (type |#$R@@103|) TyType)) (= (type bx@@69) BoxType)) ($IsBox bx@@69 (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|))) (and (= ($Box ($Unbox HandleTypeType bx@@69)) bx@@69) ($Is ($Unbox HandleTypeType bx@@69) (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|))))
 :qid |unknown.0:0|
 :skolemid |995|
 :pattern ( ($IsBox bx@@69 (Tclass._System.___hPartialFunc2OSO |#$T0@@90| |#$T1@@74| |#$R@@103|)))
)))
(assert (forall ((|#$T0@@91| T@U) (|#$T1@@75| T@U) (|#$R@@104| T@U) (|f#0@@19| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@91|) TyType) (= (type |#$T1@@75|) TyType)) (= (type |#$R@@104|) TyType)) (= (type |f#0@@19|) HandleTypeType)) (= ($Is |f#0@@19| (Tclass._System.___hPartialFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|))  (and ($Is |f#0@@19| (Tclass._System.___hFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|)) (forall ((|x0#0@@7| T@U) (|x1#0@@5| T@U) ) (!  (=> (and (and (= (type |x0#0@@7|) BoxType) (= (type |x1#0@@5|) BoxType)) (and ($IsBox |x0#0@@7| |#$T0@@91|) ($IsBox |x1#0@@5| |#$T1@@75|))) (|Set#Equal| (Reads2 |#$T0@@91| |#$T1@@75| |#$R@@104| $OneHeap |f#0@@19| |x0#0@@7| |x1#0@@5|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |996|
 :no-pattern (type |x0#0@@7|)
 :no-pattern (type |x1#0@@5|)
 :no-pattern (U_2_int |x0#0@@7|)
 :no-pattern (U_2_bool |x0#0@@7|)
 :no-pattern (U_2_int |x1#0@@5|)
 :no-pattern (U_2_bool |x1#0@@5|)
)))))
 :qid |unknown.0:0|
 :skolemid |997|
 :pattern ( ($Is |f#0@@19| (Tclass._System.___hPartialFunc2OSO |#$T0@@91| |#$T1@@75| |#$R@@104|)))
)))
(assert (forall ((|#$T0@@92| T@U) (|#$T1@@76| T@U) (|#$R@@105| T@U) (|f#0@@20| T@U) ($h@@21 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@92|) TyType) (= (type |#$T1@@76|) TyType)) (= (type |#$R@@105|) TyType)) (= (type |f#0@@20|) HandleTypeType)) (= (type $h@@21) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@20| (Tclass._System.___hPartialFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21) ($IsAlloc |f#0@@20| (Tclass._System.___hFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21)))
 :qid |unknown.0:0|
 :skolemid |998|
 :pattern ( ($IsAlloc |f#0@@20| (Tclass._System.___hPartialFunc2OSO |#$T0@@92| |#$T1@@76| |#$R@@105|) $h@@21))
)))
(assert (forall ((arg0@@234 T@U) (arg1@@111 T@U) (arg2@@63 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO|
 :pattern ( (Tclass._System.___hTotalFunc2OSO arg0@@234 arg1@@111 arg2@@63))
)))
(assert (forall ((|#$T0@@93| T@U) (|#$T1@@77| T@U) (|#$R@@106| T@U) ) (!  (=> (and (and (= (type |#$T0@@93|) TyType) (= (type |#$T1@@77|) TyType)) (= (type |#$R@@106|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|)) Tagclass._System.___hTotalFunc2OSO) (= (TagFamily (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|)) |tytagFamily$_#TotalFunc2OSO|)))
 :qid |unknown.0:0|
 :skolemid |999|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@93| |#$T1@@77| |#$R@@106|))
)))
(assert (forall ((arg0@@235 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_0 arg0@@235)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_0|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_0 arg0@@235))
)))
(assert (forall ((|#$T0@@94| T@U) (|#$T1@@78| T@U) (|#$R@@107| T@U) ) (!  (=> (and (and (= (type |#$T0@@94|) TyType) (= (type |#$T1@@78|) TyType)) (= (type |#$R@@107|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_0 (Tclass._System.___hTotalFunc2OSO |#$T0@@94| |#$T1@@78| |#$R@@107|)) |#$T0@@94|))
 :qid |unknown.0:0|
 :skolemid |1000|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@94| |#$T1@@78| |#$R@@107|))
)))
(assert (forall ((arg0@@236 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_1 arg0@@236)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_1|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_1 arg0@@236))
)))
(assert (forall ((|#$T0@@95| T@U) (|#$T1@@79| T@U) (|#$R@@108| T@U) ) (!  (=> (and (and (= (type |#$T0@@95|) TyType) (= (type |#$T1@@79|) TyType)) (= (type |#$R@@108|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_1 (Tclass._System.___hTotalFunc2OSO |#$T0@@95| |#$T1@@79| |#$R@@108|)) |#$T1@@79|))
 :qid |unknown.0:0|
 :skolemid |1001|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@95| |#$T1@@79| |#$R@@108|))
)))
(assert (forall ((arg0@@237 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2OSO_2 arg0@@237)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2OSO_2|
 :pattern ( (Tclass._System.___hTotalFunc2OSO_2 arg0@@237))
)))
(assert (forall ((|#$T0@@96| T@U) (|#$T1@@80| T@U) (|#$R@@109| T@U) ) (!  (=> (and (and (= (type |#$T0@@96|) TyType) (= (type |#$T1@@80|) TyType)) (= (type |#$R@@109|) TyType)) (= (Tclass._System.___hTotalFunc2OSO_2 (Tclass._System.___hTotalFunc2OSO |#$T0@@96| |#$T1@@80| |#$R@@109|)) |#$R@@109|))
 :qid |unknown.0:0|
 :skolemid |1002|
 :pattern ( (Tclass._System.___hTotalFunc2OSO |#$T0@@96| |#$T1@@80| |#$R@@109|))
)))
(assert (forall ((|#$T0@@97| T@U) (|#$T1@@81| T@U) (|#$R@@110| T@U) (bx@@70 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@97|) TyType) (= (type |#$T1@@81|) TyType)) (= (type |#$R@@110|) TyType)) (= (type bx@@70) BoxType)) ($IsBox bx@@70 (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|))) (and (= ($Box ($Unbox HandleTypeType bx@@70)) bx@@70) ($Is ($Unbox HandleTypeType bx@@70) (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|))))
 :qid |unknown.0:0|
 :skolemid |1003|
 :pattern ( ($IsBox bx@@70 (Tclass._System.___hTotalFunc2OSO |#$T0@@97| |#$T1@@81| |#$R@@110|)))
)))
(assert (forall ((|#$T0@@98| T@U) (|#$T1@@82| T@U) (|#$R@@111| T@U) (|f#0@@21| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@98|) TyType) (= (type |#$T1@@82|) TyType)) (= (type |#$R@@111|) TyType)) (= (type |f#0@@21|) HandleTypeType)) (= ($Is |f#0@@21| (Tclass._System.___hTotalFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|))  (and ($Is |f#0@@21| (Tclass._System.___hPartialFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|)) (forall ((|x0#0@@8| T@U) (|x1#0@@6| T@U) ) (!  (=> (and (and (= (type |x0#0@@8|) BoxType) (= (type |x1#0@@6|) BoxType)) (and ($IsBox |x0#0@@8| |#$T0@@98|) ($IsBox |x1#0@@6| |#$T1@@82|))) (Requires2 |#$T0@@98| |#$T1@@82| |#$R@@111| $OneHeap |f#0@@21| |x0#0@@8| |x1#0@@6|))
 :qid |unknown.0:0|
 :skolemid |1004|
 :no-pattern (type |x0#0@@8|)
 :no-pattern (type |x1#0@@6|)
 :no-pattern (U_2_int |x0#0@@8|)
 :no-pattern (U_2_bool |x0#0@@8|)
 :no-pattern (U_2_int |x1#0@@6|)
 :no-pattern (U_2_bool |x1#0@@6|)
)))))
 :qid |unknown.0:0|
 :skolemid |1005|
 :pattern ( ($Is |f#0@@21| (Tclass._System.___hTotalFunc2OSO |#$T0@@98| |#$T1@@82| |#$R@@111|)))
)))
(assert (forall ((|#$T0@@99| T@U) (|#$T1@@83| T@U) (|#$R@@112| T@U) (|f#0@@22| T@U) ($h@@22 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@99|) TyType) (= (type |#$T1@@83|) TyType)) (= (type |#$R@@112|) TyType)) (= (type |f#0@@22|) HandleTypeType)) (= (type $h@@22) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@22| (Tclass._System.___hTotalFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22) ($IsAlloc |f#0@@22| (Tclass._System.___hPartialFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22)))
 :qid |unknown.0:0|
 :skolemid |1006|
 :pattern ( ($IsAlloc |f#0@@22| (Tclass._System.___hTotalFunc2OSO |#$T0@@99| |#$T1@@83| |#$R@@112|) $h@@22))
)))
(assert (forall ((arg0@@238 T@U) (arg1@@112 T@U) (arg2@@64 T@U) (arg3@@39 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO arg0@@238 arg1@@112 arg2@@64 arg3@@39)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO|
 :pattern ( (Tclass._System.___hFunc3LLOO arg0@@238 arg1@@112 arg2@@64 arg3@@39))
)))
(assert (forall ((|#$T0@@100| T@U) (|#$T1@@84| T@U) (|#$T2@@46| T@U) (|#$R@@113| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@100|) TyType) (= (type |#$T1@@84|) TyType)) (= (type |#$T2@@46|) TyType)) (= (type |#$R@@113|) TyType)) (and (= (Tag (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|)) Tagclass._System.___hFunc3LLOO) (= (TagFamily (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|)) |tytagFamily$_#Func3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1007|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@100| |#$T1@@84| |#$T2@@46| |#$R@@113|))
)))
(assert (forall ((arg0@@239 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_0 arg0@@239)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_0|
 :pattern ( (Tclass._System.___hFunc3LLOO_0 arg0@@239))
)))
(assert (forall ((|#$T0@@101| T@U) (|#$T1@@85| T@U) (|#$T2@@47| T@U) (|#$R@@114| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@101|) TyType) (= (type |#$T1@@85|) TyType)) (= (type |#$T2@@47|) TyType)) (= (type |#$R@@114|) TyType)) (= (Tclass._System.___hFunc3LLOO_0 (Tclass._System.___hFunc3LLOO |#$T0@@101| |#$T1@@85| |#$T2@@47| |#$R@@114|)) |#$T0@@101|))
 :qid |unknown.0:0|
 :skolemid |1008|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@101| |#$T1@@85| |#$T2@@47| |#$R@@114|))
)))
(assert (forall ((arg0@@240 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_1 arg0@@240)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_1|
 :pattern ( (Tclass._System.___hFunc3LLOO_1 arg0@@240))
)))
(assert (forall ((|#$T0@@102| T@U) (|#$T1@@86| T@U) (|#$T2@@48| T@U) (|#$R@@115| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@102|) TyType) (= (type |#$T1@@86|) TyType)) (= (type |#$T2@@48|) TyType)) (= (type |#$R@@115|) TyType)) (= (Tclass._System.___hFunc3LLOO_1 (Tclass._System.___hFunc3LLOO |#$T0@@102| |#$T1@@86| |#$T2@@48| |#$R@@115|)) |#$T1@@86|))
 :qid |unknown.0:0|
 :skolemid |1009|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@102| |#$T1@@86| |#$T2@@48| |#$R@@115|))
)))
(assert (forall ((arg0@@241 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_2 arg0@@241)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_2|
 :pattern ( (Tclass._System.___hFunc3LLOO_2 arg0@@241))
)))
(assert (forall ((|#$T0@@103| T@U) (|#$T1@@87| T@U) (|#$T2@@49| T@U) (|#$R@@116| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@103|) TyType) (= (type |#$T1@@87|) TyType)) (= (type |#$T2@@49|) TyType)) (= (type |#$R@@116|) TyType)) (= (Tclass._System.___hFunc3LLOO_2 (Tclass._System.___hFunc3LLOO |#$T0@@103| |#$T1@@87| |#$T2@@49| |#$R@@116|)) |#$T2@@49|))
 :qid |unknown.0:0|
 :skolemid |1010|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@103| |#$T1@@87| |#$T2@@49| |#$R@@116|))
)))
(assert (forall ((arg0@@242 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOO_3 arg0@@242)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOO_3|
 :pattern ( (Tclass._System.___hFunc3LLOO_3 arg0@@242))
)))
(assert (forall ((|#$T0@@104| T@U) (|#$T1@@88| T@U) (|#$T2@@50| T@U) (|#$R@@117| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@104|) TyType) (= (type |#$T1@@88|) TyType)) (= (type |#$T2@@50|) TyType)) (= (type |#$R@@117|) TyType)) (= (Tclass._System.___hFunc3LLOO_3 (Tclass._System.___hFunc3LLOO |#$T0@@104| |#$T1@@88| |#$T2@@50| |#$R@@117|)) |#$R@@117|))
 :qid |unknown.0:0|
 :skolemid |1011|
 :pattern ( (Tclass._System.___hFunc3LLOO |#$T0@@104| |#$T1@@88| |#$T2@@50| |#$R@@117|))
)))
(assert (forall ((|#$T0@@105| T@U) (|#$T1@@89| T@U) (|#$T2@@51| T@U) (|#$R@@118| T@U) (bx@@71 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@105|) TyType) (= (type |#$T1@@89|) TyType)) (= (type |#$T2@@51|) TyType)) (= (type |#$R@@118|) TyType)) (= (type bx@@71) BoxType)) ($IsBox bx@@71 (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|))) (and (= ($Box ($Unbox HandleTypeType bx@@71)) bx@@71) ($Is ($Unbox HandleTypeType bx@@71) (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|))))
 :qid |unknown.0:0|
 :skolemid |1012|
 :pattern ( ($IsBox bx@@71 (Tclass._System.___hFunc3LLOO |#$T0@@105| |#$T1@@89| |#$T2@@51| |#$R@@118|)))
)))
(assert (forall ((arg0@@243 T@U) (arg1@@113 T@U) (arg2@@65 T@U) (arg3@@40 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO arg0@@243 arg1@@113 arg2@@65 arg3@@40)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO arg0@@243 arg1@@113 arg2@@65 arg3@@40))
)))
(assert (forall ((|#$T0@@106| T@U) (|#$T1@@90| T@U) (|#$T2@@52| T@U) (|#$R@@119| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@106|) TyType) (= (type |#$T1@@90|) TyType)) (= (type |#$T2@@52|) TyType)) (= (type |#$R@@119|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|)) Tagclass._System.___hPartialFunc3LLOO) (= (TagFamily (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|)) |tytagFamily$_#PartialFunc3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1013|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@106| |#$T1@@90| |#$T2@@52| |#$R@@119|))
)))
(assert (forall ((arg0@@244 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_0 arg0@@244)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_0|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_0 arg0@@244))
)))
(assert (forall ((|#$T0@@107| T@U) (|#$T1@@91| T@U) (|#$T2@@53| T@U) (|#$R@@120| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@107|) TyType) (= (type |#$T1@@91|) TyType)) (= (type |#$T2@@53|) TyType)) (= (type |#$R@@120|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_0 (Tclass._System.___hPartialFunc3LLOO |#$T0@@107| |#$T1@@91| |#$T2@@53| |#$R@@120|)) |#$T0@@107|))
 :qid |unknown.0:0|
 :skolemid |1014|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@107| |#$T1@@91| |#$T2@@53| |#$R@@120|))
)))
(assert (forall ((arg0@@245 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_1 arg0@@245)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_1|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_1 arg0@@245))
)))
(assert (forall ((|#$T0@@108| T@U) (|#$T1@@92| T@U) (|#$T2@@54| T@U) (|#$R@@121| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@108|) TyType) (= (type |#$T1@@92|) TyType)) (= (type |#$T2@@54|) TyType)) (= (type |#$R@@121|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_1 (Tclass._System.___hPartialFunc3LLOO |#$T0@@108| |#$T1@@92| |#$T2@@54| |#$R@@121|)) |#$T1@@92|))
 :qid |unknown.0:0|
 :skolemid |1015|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@108| |#$T1@@92| |#$T2@@54| |#$R@@121|))
)))
(assert (forall ((arg0@@246 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_2 arg0@@246)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_2|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_2 arg0@@246))
)))
(assert (forall ((|#$T0@@109| T@U) (|#$T1@@93| T@U) (|#$T2@@55| T@U) (|#$R@@122| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@109|) TyType) (= (type |#$T1@@93|) TyType)) (= (type |#$T2@@55|) TyType)) (= (type |#$R@@122|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_2 (Tclass._System.___hPartialFunc3LLOO |#$T0@@109| |#$T1@@93| |#$T2@@55| |#$R@@122|)) |#$T2@@55|))
 :qid |unknown.0:0|
 :skolemid |1016|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@109| |#$T1@@93| |#$T2@@55| |#$R@@122|))
)))
(assert (forall ((arg0@@247 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOO_3 arg0@@247)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOO_3|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO_3 arg0@@247))
)))
(assert (forall ((|#$T0@@110| T@U) (|#$T1@@94| T@U) (|#$T2@@56| T@U) (|#$R@@123| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@110|) TyType) (= (type |#$T1@@94|) TyType)) (= (type |#$T2@@56|) TyType)) (= (type |#$R@@123|) TyType)) (= (Tclass._System.___hPartialFunc3LLOO_3 (Tclass._System.___hPartialFunc3LLOO |#$T0@@110| |#$T1@@94| |#$T2@@56| |#$R@@123|)) |#$R@@123|))
 :qid |unknown.0:0|
 :skolemid |1017|
 :pattern ( (Tclass._System.___hPartialFunc3LLOO |#$T0@@110| |#$T1@@94| |#$T2@@56| |#$R@@123|))
)))
(assert (forall ((|#$T0@@111| T@U) (|#$T1@@95| T@U) (|#$T2@@57| T@U) (|#$R@@124| T@U) (bx@@72 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@111|) TyType) (= (type |#$T1@@95|) TyType)) (= (type |#$T2@@57|) TyType)) (= (type |#$R@@124|) TyType)) (= (type bx@@72) BoxType)) ($IsBox bx@@72 (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|))) (and (= ($Box ($Unbox HandleTypeType bx@@72)) bx@@72) ($Is ($Unbox HandleTypeType bx@@72) (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|))))
 :qid |unknown.0:0|
 :skolemid |1018|
 :pattern ( ($IsBox bx@@72 (Tclass._System.___hPartialFunc3LLOO |#$T0@@111| |#$T1@@95| |#$T2@@57| |#$R@@124|)))
)))
(assert (forall ((|#$T0@@112| T@U) (|#$T1@@96| T@U) (|#$T2@@58| T@U) (|#$R@@125| T@U) (|f#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@112|) TyType) (= (type |#$T1@@96|) TyType)) (= (type |#$T2@@58|) TyType)) (= (type |#$R@@125|) TyType)) (= (type |f#0@@23|) HandleTypeType)) (= ($Is |f#0@@23| (Tclass._System.___hPartialFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|))  (and ($Is |f#0@@23| (Tclass._System.___hFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|)) (forall ((|x0#0@@9| T@U) (|x1#0@@7| T@U) (|x2#0@@3| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@9|) BoxType) (= (type |x1#0@@7|) BoxType)) (= (type |x2#0@@3|) BoxType)) (and (and ($IsBox |x0#0@@9| |#$T0@@112|) ($IsBox |x1#0@@7| |#$T1@@96|)) ($IsBox |x2#0@@3| |#$T2@@58|))) (|Set#Equal| (Reads3 |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125| $OneHeap |f#0@@23| |x0#0@@9| |x1#0@@7| |x2#0@@3|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1019|
 :no-pattern (type |x0#0@@9|)
 :no-pattern (type |x1#0@@7|)
 :no-pattern (type |x2#0@@3|)
 :no-pattern (U_2_int |x0#0@@9|)
 :no-pattern (U_2_bool |x0#0@@9|)
 :no-pattern (U_2_int |x1#0@@7|)
 :no-pattern (U_2_bool |x1#0@@7|)
 :no-pattern (U_2_int |x2#0@@3|)
 :no-pattern (U_2_bool |x2#0@@3|)
)))))
 :qid |unknown.0:0|
 :skolemid |1020|
 :pattern ( ($Is |f#0@@23| (Tclass._System.___hPartialFunc3LLOO |#$T0@@112| |#$T1@@96| |#$T2@@58| |#$R@@125|)))
)))
(assert (forall ((|#$T0@@113| T@U) (|#$T1@@97| T@U) (|#$T2@@59| T@U) (|#$R@@126| T@U) (|f#0@@24| T@U) ($h@@23 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@113|) TyType) (= (type |#$T1@@97|) TyType)) (= (type |#$T2@@59|) TyType)) (= (type |#$R@@126|) TyType)) (= (type |f#0@@24|) HandleTypeType)) (= (type $h@@23) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@24| (Tclass._System.___hPartialFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23) ($IsAlloc |f#0@@24| (Tclass._System.___hFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23)))
 :qid |unknown.0:0|
 :skolemid |1021|
 :pattern ( ($IsAlloc |f#0@@24| (Tclass._System.___hPartialFunc3LLOO |#$T0@@113| |#$T1@@97| |#$T2@@59| |#$R@@126|) $h@@23))
)))
(assert (forall ((arg0@@248 T@U) (arg1@@114 T@U) (arg2@@66 T@U) (arg3@@41 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO arg0@@248 arg1@@114 arg2@@66 arg3@@41)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO arg0@@248 arg1@@114 arg2@@66 arg3@@41))
)))
(assert (forall ((|#$T0@@114| T@U) (|#$T1@@98| T@U) (|#$T2@@60| T@U) (|#$R@@127| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@114|) TyType) (= (type |#$T1@@98|) TyType)) (= (type |#$T2@@60|) TyType)) (= (type |#$R@@127|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|)) Tagclass._System.___hTotalFunc3LLOO) (= (TagFamily (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|)) |tytagFamily$_#TotalFunc3LLOO|)))
 :qid |unknown.0:0|
 :skolemid |1022|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@114| |#$T1@@98| |#$T2@@60| |#$R@@127|))
)))
(assert (forall ((arg0@@249 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_0 arg0@@249)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_0|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_0 arg0@@249))
)))
(assert (forall ((|#$T0@@115| T@U) (|#$T1@@99| T@U) (|#$T2@@61| T@U) (|#$R@@128| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@115|) TyType) (= (type |#$T1@@99|) TyType)) (= (type |#$T2@@61|) TyType)) (= (type |#$R@@128|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_0 (Tclass._System.___hTotalFunc3LLOO |#$T0@@115| |#$T1@@99| |#$T2@@61| |#$R@@128|)) |#$T0@@115|))
 :qid |unknown.0:0|
 :skolemid |1023|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@115| |#$T1@@99| |#$T2@@61| |#$R@@128|))
)))
(assert (forall ((arg0@@250 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_1 arg0@@250)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_1|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_1 arg0@@250))
)))
(assert (forall ((|#$T0@@116| T@U) (|#$T1@@100| T@U) (|#$T2@@62| T@U) (|#$R@@129| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@116|) TyType) (= (type |#$T1@@100|) TyType)) (= (type |#$T2@@62|) TyType)) (= (type |#$R@@129|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_1 (Tclass._System.___hTotalFunc3LLOO |#$T0@@116| |#$T1@@100| |#$T2@@62| |#$R@@129|)) |#$T1@@100|))
 :qid |unknown.0:0|
 :skolemid |1024|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@116| |#$T1@@100| |#$T2@@62| |#$R@@129|))
)))
(assert (forall ((arg0@@251 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_2 arg0@@251)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_2|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_2 arg0@@251))
)))
(assert (forall ((|#$T0@@117| T@U) (|#$T1@@101| T@U) (|#$T2@@63| T@U) (|#$R@@130| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@117|) TyType) (= (type |#$T1@@101|) TyType)) (= (type |#$T2@@63|) TyType)) (= (type |#$R@@130|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_2 (Tclass._System.___hTotalFunc3LLOO |#$T0@@117| |#$T1@@101| |#$T2@@63| |#$R@@130|)) |#$T2@@63|))
 :qid |unknown.0:0|
 :skolemid |1025|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@117| |#$T1@@101| |#$T2@@63| |#$R@@130|))
)))
(assert (forall ((arg0@@252 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOO_3 arg0@@252)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOO_3|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO_3 arg0@@252))
)))
(assert (forall ((|#$T0@@118| T@U) (|#$T1@@102| T@U) (|#$T2@@64| T@U) (|#$R@@131| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@118|) TyType) (= (type |#$T1@@102|) TyType)) (= (type |#$T2@@64|) TyType)) (= (type |#$R@@131|) TyType)) (= (Tclass._System.___hTotalFunc3LLOO_3 (Tclass._System.___hTotalFunc3LLOO |#$T0@@118| |#$T1@@102| |#$T2@@64| |#$R@@131|)) |#$R@@131|))
 :qid |unknown.0:0|
 :skolemid |1026|
 :pattern ( (Tclass._System.___hTotalFunc3LLOO |#$T0@@118| |#$T1@@102| |#$T2@@64| |#$R@@131|))
)))
(assert (forall ((|#$T0@@119| T@U) (|#$T1@@103| T@U) (|#$T2@@65| T@U) (|#$R@@132| T@U) (bx@@73 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@119|) TyType) (= (type |#$T1@@103|) TyType)) (= (type |#$T2@@65|) TyType)) (= (type |#$R@@132|) TyType)) (= (type bx@@73) BoxType)) ($IsBox bx@@73 (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|))) (and (= ($Box ($Unbox HandleTypeType bx@@73)) bx@@73) ($Is ($Unbox HandleTypeType bx@@73) (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|))))
 :qid |unknown.0:0|
 :skolemid |1027|
 :pattern ( ($IsBox bx@@73 (Tclass._System.___hTotalFunc3LLOO |#$T0@@119| |#$T1@@103| |#$T2@@65| |#$R@@132|)))
)))
(assert (forall ((|#$T0@@120| T@U) (|#$T1@@104| T@U) (|#$T2@@66| T@U) (|#$R@@133| T@U) (|f#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@120|) TyType) (= (type |#$T1@@104|) TyType)) (= (type |#$T2@@66|) TyType)) (= (type |#$R@@133|) TyType)) (= (type |f#0@@25|) HandleTypeType)) (= ($Is |f#0@@25| (Tclass._System.___hTotalFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|))  (and ($Is |f#0@@25| (Tclass._System.___hPartialFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|)) (forall ((|x0#0@@10| T@U) (|x1#0@@8| T@U) (|x2#0@@4| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@10|) BoxType) (= (type |x1#0@@8|) BoxType)) (= (type |x2#0@@4|) BoxType)) (and (and ($IsBox |x0#0@@10| |#$T0@@120|) ($IsBox |x1#0@@8| |#$T1@@104|)) ($IsBox |x2#0@@4| |#$T2@@66|))) (Requires3 |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133| $OneHeap |f#0@@25| |x0#0@@10| |x1#0@@8| |x2#0@@4|))
 :qid |unknown.0:0|
 :skolemid |1028|
 :no-pattern (type |x0#0@@10|)
 :no-pattern (type |x1#0@@8|)
 :no-pattern (type |x2#0@@4|)
 :no-pattern (U_2_int |x0#0@@10|)
 :no-pattern (U_2_bool |x0#0@@10|)
 :no-pattern (U_2_int |x1#0@@8|)
 :no-pattern (U_2_bool |x1#0@@8|)
 :no-pattern (U_2_int |x2#0@@4|)
 :no-pattern (U_2_bool |x2#0@@4|)
)))))
 :qid |unknown.0:0|
 :skolemid |1029|
 :pattern ( ($Is |f#0@@25| (Tclass._System.___hTotalFunc3LLOO |#$T0@@120| |#$T1@@104| |#$T2@@66| |#$R@@133|)))
)))
(assert (forall ((|#$T0@@121| T@U) (|#$T1@@105| T@U) (|#$T2@@67| T@U) (|#$R@@134| T@U) (|f#0@@26| T@U) ($h@@24 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@121|) TyType) (= (type |#$T1@@105|) TyType)) (= (type |#$T2@@67|) TyType)) (= (type |#$R@@134|) TyType)) (= (type |f#0@@26|) HandleTypeType)) (= (type $h@@24) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@26| (Tclass._System.___hTotalFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24) ($IsAlloc |f#0@@26| (Tclass._System.___hPartialFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24)))
 :qid |unknown.0:0|
 :skolemid |1030|
 :pattern ( ($IsAlloc |f#0@@26| (Tclass._System.___hTotalFunc3LLOO |#$T0@@121| |#$T1@@105| |#$T2@@67| |#$R@@134|) $h@@24))
)))
(assert (forall ((arg0@@253 T@U) (arg1@@115 T@U) ) (! (= (type (Tclass._System.___hFunc1OS arg0@@253 arg1@@115)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS|
 :pattern ( (Tclass._System.___hFunc1OS arg0@@253 arg1@@115))
)))
(assert (forall ((|#$T0@@122| T@U) (|#$R@@135| T@U) ) (!  (=> (and (= (type |#$T0@@122|) TyType) (= (type |#$R@@135|) TyType)) (and (= (Tag (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|)) Tagclass._System.___hFunc1OS) (= (TagFamily (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|)) |tytagFamily$_#Func1OS|)))
 :qid |unknown.0:0|
 :skolemid |1031|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@122| |#$R@@135|))
)))
(assert (forall ((arg0@@254 T@U) ) (! (= (type (Tclass._System.___hFunc1OS_0 arg0@@254)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS_0|
 :pattern ( (Tclass._System.___hFunc1OS_0 arg0@@254))
)))
(assert (forall ((|#$T0@@123| T@U) (|#$R@@136| T@U) ) (!  (=> (and (= (type |#$T0@@123|) TyType) (= (type |#$R@@136|) TyType)) (= (Tclass._System.___hFunc1OS_0 (Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|)) |#$T0@@123|))
 :qid |unknown.0:0|
 :skolemid |1032|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@123| |#$R@@136|))
)))
(assert (forall ((arg0@@255 T@U) ) (! (= (type (Tclass._System.___hFunc1OS_1 arg0@@255)) TyType)
 :qid |funType:Tclass._System.___hFunc1OS_1|
 :pattern ( (Tclass._System.___hFunc1OS_1 arg0@@255))
)))
(assert (forall ((|#$T0@@124| T@U) (|#$R@@137| T@U) ) (!  (=> (and (= (type |#$T0@@124|) TyType) (= (type |#$R@@137|) TyType)) (= (Tclass._System.___hFunc1OS_1 (Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|)) |#$R@@137|))
 :qid |unknown.0:0|
 :skolemid |1033|
 :pattern ( (Tclass._System.___hFunc1OS |#$T0@@124| |#$R@@137|))
)))
(assert (forall ((|#$T0@@125| T@U) (|#$R@@138| T@U) (bx@@74 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@125|) TyType) (= (type |#$R@@138|) TyType)) (= (type bx@@74) BoxType)) ($IsBox bx@@74 (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|))) (and (= ($Box ($Unbox HandleTypeType bx@@74)) bx@@74) ($Is ($Unbox HandleTypeType bx@@74) (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|))))
 :qid |unknown.0:0|
 :skolemid |1034|
 :pattern ( ($IsBox bx@@74 (Tclass._System.___hFunc1OS |#$T0@@125| |#$R@@138|)))
)))
(assert (forall ((arg0@@256 T@U) (arg1@@116 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS|
 :pattern ( (Tclass._System.___hPartialFunc1OS arg0@@256 arg1@@116))
)))
(assert (forall ((|#$T0@@126| T@U) (|#$R@@139| T@U) ) (!  (=> (and (= (type |#$T0@@126|) TyType) (= (type |#$R@@139|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|)) Tagclass._System.___hPartialFunc1OS) (= (TagFamily (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|)) |tytagFamily$_#PartialFunc1OS|)))
 :qid |unknown.0:0|
 :skolemid |1035|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@126| |#$R@@139|))
)))
(assert (forall ((arg0@@257 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS_0 arg0@@257)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS_0|
 :pattern ( (Tclass._System.___hPartialFunc1OS_0 arg0@@257))
)))
(assert (forall ((|#$T0@@127| T@U) (|#$R@@140| T@U) ) (!  (=> (and (= (type |#$T0@@127|) TyType) (= (type |#$R@@140|) TyType)) (= (Tclass._System.___hPartialFunc1OS_0 (Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|)) |#$T0@@127|))
 :qid |unknown.0:0|
 :skolemid |1036|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@127| |#$R@@140|))
)))
(assert (forall ((arg0@@258 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OS_1 arg0@@258)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OS_1|
 :pattern ( (Tclass._System.___hPartialFunc1OS_1 arg0@@258))
)))
(assert (forall ((|#$T0@@128| T@U) (|#$R@@141| T@U) ) (!  (=> (and (= (type |#$T0@@128|) TyType) (= (type |#$R@@141|) TyType)) (= (Tclass._System.___hPartialFunc1OS_1 (Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|)) |#$R@@141|))
 :qid |unknown.0:0|
 :skolemid |1037|
 :pattern ( (Tclass._System.___hPartialFunc1OS |#$T0@@128| |#$R@@141|))
)))
(assert (forall ((|#$T0@@129| T@U) (|#$R@@142| T@U) (bx@@75 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@129|) TyType) (= (type |#$R@@142|) TyType)) (= (type bx@@75) BoxType)) ($IsBox bx@@75 (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|))) (and (= ($Box ($Unbox HandleTypeType bx@@75)) bx@@75) ($Is ($Unbox HandleTypeType bx@@75) (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|))))
 :qid |unknown.0:0|
 :skolemid |1038|
 :pattern ( ($IsBox bx@@75 (Tclass._System.___hPartialFunc1OS |#$T0@@129| |#$R@@142|)))
)))
(assert (forall ((|#$T0@@130| T@U) (|#$R@@143| T@U) (|f#0@@27| T@U) ) (!  (=> (and (and (= (type |#$T0@@130|) TyType) (= (type |#$R@@143|) TyType)) (= (type |f#0@@27|) HandleTypeType)) (= ($Is |f#0@@27| (Tclass._System.___hPartialFunc1OS |#$T0@@130| |#$R@@143|))  (and ($Is |f#0@@27| (Tclass._System.___hFunc1OS |#$T0@@130| |#$R@@143|)) (forall ((|x0#0@@11| T@U) ) (!  (=> (and (= (type |x0#0@@11|) BoxType) ($IsBox |x0#0@@11| |#$T0@@130|)) (|Set#Equal| (Reads1 |#$T0@@130| |#$R@@143| $OneHeap |f#0@@27| |x0#0@@11|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1039|
 :no-pattern (type |x0#0@@11|)
 :no-pattern (U_2_int |x0#0@@11|)
 :no-pattern (U_2_bool |x0#0@@11|)
)))))
 :qid |unknown.0:0|
 :skolemid |1040|
 :pattern ( ($Is |f#0@@27| (Tclass._System.___hPartialFunc1OS |#$T0@@130| |#$R@@143|)))
)))
(assert (forall ((|#$T0@@131| T@U) (|#$R@@144| T@U) (|f#0@@28| T@U) ($h@@25 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@131|) TyType) (= (type |#$R@@144|) TyType)) (= (type |f#0@@28|) HandleTypeType)) (= (type $h@@25) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@28| (Tclass._System.___hPartialFunc1OS |#$T0@@131| |#$R@@144|) $h@@25) ($IsAlloc |f#0@@28| (Tclass._System.___hFunc1OS |#$T0@@131| |#$R@@144|) $h@@25)))
 :qid |unknown.0:0|
 :skolemid |1041|
 :pattern ( ($IsAlloc |f#0@@28| (Tclass._System.___hPartialFunc1OS |#$T0@@131| |#$R@@144|) $h@@25))
)))
(assert (forall ((arg0@@259 T@U) (arg1@@117 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS|
 :pattern ( (Tclass._System.___hTotalFunc1OS arg0@@259 arg1@@117))
)))
(assert (forall ((|#$T0@@132| T@U) (|#$R@@145| T@U) ) (!  (=> (and (= (type |#$T0@@132|) TyType) (= (type |#$R@@145|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|)) Tagclass._System.___hTotalFunc1OS) (= (TagFamily (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|)) |tytagFamily$_#TotalFunc1OS|)))
 :qid |unknown.0:0|
 :skolemid |1042|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@132| |#$R@@145|))
)))
(assert (forall ((arg0@@260 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS_0 arg0@@260)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS_0|
 :pattern ( (Tclass._System.___hTotalFunc1OS_0 arg0@@260))
)))
(assert (forall ((|#$T0@@133| T@U) (|#$R@@146| T@U) ) (!  (=> (and (= (type |#$T0@@133|) TyType) (= (type |#$R@@146|) TyType)) (= (Tclass._System.___hTotalFunc1OS_0 (Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|)) |#$T0@@133|))
 :qid |unknown.0:0|
 :skolemid |1043|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@133| |#$R@@146|))
)))
(assert (forall ((arg0@@261 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OS_1 arg0@@261)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OS_1|
 :pattern ( (Tclass._System.___hTotalFunc1OS_1 arg0@@261))
)))
(assert (forall ((|#$T0@@134| T@U) (|#$R@@147| T@U) ) (!  (=> (and (= (type |#$T0@@134|) TyType) (= (type |#$R@@147|) TyType)) (= (Tclass._System.___hTotalFunc1OS_1 (Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|)) |#$R@@147|))
 :qid |unknown.0:0|
 :skolemid |1044|
 :pattern ( (Tclass._System.___hTotalFunc1OS |#$T0@@134| |#$R@@147|))
)))
(assert (forall ((|#$T0@@135| T@U) (|#$R@@148| T@U) (bx@@76 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@135|) TyType) (= (type |#$R@@148|) TyType)) (= (type bx@@76) BoxType)) ($IsBox bx@@76 (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|))) (and (= ($Box ($Unbox HandleTypeType bx@@76)) bx@@76) ($Is ($Unbox HandleTypeType bx@@76) (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|))))
 :qid |unknown.0:0|
 :skolemid |1045|
 :pattern ( ($IsBox bx@@76 (Tclass._System.___hTotalFunc1OS |#$T0@@135| |#$R@@148|)))
)))
(assert (forall ((|#$T0@@136| T@U) (|#$R@@149| T@U) (|f#0@@29| T@U) ) (!  (=> (and (and (= (type |#$T0@@136|) TyType) (= (type |#$R@@149|) TyType)) (= (type |f#0@@29|) HandleTypeType)) (= ($Is |f#0@@29| (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|))  (and ($Is |f#0@@29| (Tclass._System.___hPartialFunc1OS |#$T0@@136| |#$R@@149|)) (forall ((|x0#0@@12| T@U) ) (!  (=> (and (= (type |x0#0@@12|) BoxType) ($IsBox |x0#0@@12| |#$T0@@136|)) (Requires1 |#$T0@@136| |#$R@@149| $OneHeap |f#0@@29| |x0#0@@12|))
 :qid |unknown.0:0|
 :skolemid |1046|
 :no-pattern (type |x0#0@@12|)
 :no-pattern (U_2_int |x0#0@@12|)
 :no-pattern (U_2_bool |x0#0@@12|)
)))))
 :qid |unknown.0:0|
 :skolemid |1047|
 :pattern ( ($Is |f#0@@29| (Tclass._System.___hTotalFunc1OS |#$T0@@136| |#$R@@149|)))
)))
(assert (forall ((|#$T0@@137| T@U) (|#$R@@150| T@U) (|f#0@@30| T@U) ($h@@26 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@137|) TyType) (= (type |#$R@@150|) TyType)) (= (type |f#0@@30|) HandleTypeType)) (= (type $h@@26) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@30| (Tclass._System.___hTotalFunc1OS |#$T0@@137| |#$R@@150|) $h@@26) ($IsAlloc |f#0@@30| (Tclass._System.___hPartialFunc1OS |#$T0@@137| |#$R@@150|) $h@@26)))
 :qid |unknown.0:0|
 :skolemid |1048|
 :pattern ( ($IsAlloc |f#0@@30| (Tclass._System.___hTotalFunc1OS |#$T0@@137| |#$R@@150|) $h@@26))
)))
(assert (forall ((arg0@@262 T@U) ) (! (= (type (Tclass._System.___hFunc0L arg0@@262)) TyType)
 :qid |funType:Tclass._System.___hFunc0L|
 :pattern ( (Tclass._System.___hFunc0L arg0@@262))
)))
(assert (forall ((|#$R@@151| T@U) ) (!  (=> (= (type |#$R@@151|) TyType) (and (= (Tag (Tclass._System.___hFunc0L |#$R@@151|)) Tagclass._System.___hFunc0L) (= (TagFamily (Tclass._System.___hFunc0L |#$R@@151|)) |tytagFamily$_#Func0L|)))
 :qid |unknown.0:0|
 :skolemid |1049|
 :pattern ( (Tclass._System.___hFunc0L |#$R@@151|))
)))
(assert (forall ((arg0@@263 T@U) ) (! (= (type (Tclass._System.___hFunc0L_0 arg0@@263)) TyType)
 :qid |funType:Tclass._System.___hFunc0L_0|
 :pattern ( (Tclass._System.___hFunc0L_0 arg0@@263))
)))
(assert (forall ((|#$R@@152| T@U) ) (!  (=> (= (type |#$R@@152|) TyType) (= (Tclass._System.___hFunc0L_0 (Tclass._System.___hFunc0L |#$R@@152|)) |#$R@@152|))
 :qid |unknown.0:0|
 :skolemid |1050|
 :pattern ( (Tclass._System.___hFunc0L |#$R@@152|))
)))
(assert (forall ((|#$R@@153| T@U) (bx@@77 T@U) ) (!  (=> (and (and (= (type |#$R@@153|) TyType) (= (type bx@@77) BoxType)) ($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|))) (and (= ($Box ($Unbox HandleTypeType bx@@77)) bx@@77) ($Is ($Unbox HandleTypeType bx@@77) (Tclass._System.___hFunc0L |#$R@@153|))))
 :qid |unknown.0:0|
 :skolemid |1051|
 :pattern ( ($IsBox bx@@77 (Tclass._System.___hFunc0L |#$R@@153|)))
)))
(assert (forall ((arg0@@264 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0L arg0@@264)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0L|
 :pattern ( (Tclass._System.___hPartialFunc0L arg0@@264))
)))
(assert (forall ((|#$R@@154| T@U) ) (!  (=> (= (type |#$R@@154|) TyType) (and (= (Tag (Tclass._System.___hPartialFunc0L |#$R@@154|)) Tagclass._System.___hPartialFunc0L) (= (TagFamily (Tclass._System.___hPartialFunc0L |#$R@@154|)) |tytagFamily$_#PartialFunc0L|)))
 :qid |unknown.0:0|
 :skolemid |1052|
 :pattern ( (Tclass._System.___hPartialFunc0L |#$R@@154|))
)))
(assert (forall ((arg0@@265 T@U) ) (! (= (type (Tclass._System.___hPartialFunc0L_0 arg0@@265)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc0L_0|
 :pattern ( (Tclass._System.___hPartialFunc0L_0 arg0@@265))
)))
(assert (forall ((|#$R@@155| T@U) ) (!  (=> (= (type |#$R@@155|) TyType) (= (Tclass._System.___hPartialFunc0L_0 (Tclass._System.___hPartialFunc0L |#$R@@155|)) |#$R@@155|))
 :qid |unknown.0:0|
 :skolemid |1053|
 :pattern ( (Tclass._System.___hPartialFunc0L |#$R@@155|))
)))
(assert (forall ((|#$R@@156| T@U) (bx@@78 T@U) ) (!  (=> (and (and (= (type |#$R@@156|) TyType) (= (type bx@@78) BoxType)) ($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|))) (and (= ($Box ($Unbox HandleTypeType bx@@78)) bx@@78) ($Is ($Unbox HandleTypeType bx@@78) (Tclass._System.___hPartialFunc0L |#$R@@156|))))
 :qid |unknown.0:0|
 :skolemid |1054|
 :pattern ( ($IsBox bx@@78 (Tclass._System.___hPartialFunc0L |#$R@@156|)))
)))
(assert (forall ((|#$R@@157| T@U) (|f#0@@31| T@U) ) (!  (=> (and (= (type |#$R@@157|) TyType) (= (type |f#0@@31|) HandleTypeType)) (= ($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|))  (and ($Is |f#0@@31| (Tclass._System.___hFunc0L |#$R@@157|)) (|Set#Equal| (Reads0 |#$R@@157| $OneHeap |f#0@@31|) (|Set#Empty| BoxType)))))
 :qid |unknown.0:0|
 :skolemid |1055|
 :pattern ( ($Is |f#0@@31| (Tclass._System.___hPartialFunc0L |#$R@@157|)))
)))
(assert (forall ((|#$R@@158| T@U) (|f#0@@32| T@U) ($h@@27 T@U) ) (!  (=> (and (and (= (type |#$R@@158|) TyType) (= (type |f#0@@32|) HandleTypeType)) (= (type $h@@27) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@32| (Tclass._System.___hPartialFunc0L |#$R@@158|) $h@@27) ($IsAlloc |f#0@@32| (Tclass._System.___hFunc0L |#$R@@158|) $h@@27)))
 :qid |unknown.0:0|
 :skolemid |1056|
 :pattern ( ($IsAlloc |f#0@@32| (Tclass._System.___hPartialFunc0L |#$R@@158|) $h@@27))
)))
(assert (forall ((arg0@@266 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0L arg0@@266)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0L|
 :pattern ( (Tclass._System.___hTotalFunc0L arg0@@266))
)))
(assert (forall ((|#$R@@159| T@U) ) (!  (=> (= (type |#$R@@159|) TyType) (and (= (Tag (Tclass._System.___hTotalFunc0L |#$R@@159|)) Tagclass._System.___hTotalFunc0L) (= (TagFamily (Tclass._System.___hTotalFunc0L |#$R@@159|)) |tytagFamily$_#TotalFunc0L|)))
 :qid |unknown.0:0|
 :skolemid |1057|
 :pattern ( (Tclass._System.___hTotalFunc0L |#$R@@159|))
)))
(assert (forall ((arg0@@267 T@U) ) (! (= (type (Tclass._System.___hTotalFunc0L_0 arg0@@267)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc0L_0|
 :pattern ( (Tclass._System.___hTotalFunc0L_0 arg0@@267))
)))
(assert (forall ((|#$R@@160| T@U) ) (!  (=> (= (type |#$R@@160|) TyType) (= (Tclass._System.___hTotalFunc0L_0 (Tclass._System.___hTotalFunc0L |#$R@@160|)) |#$R@@160|))
 :qid |unknown.0:0|
 :skolemid |1058|
 :pattern ( (Tclass._System.___hTotalFunc0L |#$R@@160|))
)))
(assert (forall ((|#$R@@161| T@U) (bx@@79 T@U) ) (!  (=> (and (and (= (type |#$R@@161|) TyType) (= (type bx@@79) BoxType)) ($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|))) (and (= ($Box ($Unbox HandleTypeType bx@@79)) bx@@79) ($Is ($Unbox HandleTypeType bx@@79) (Tclass._System.___hTotalFunc0L |#$R@@161|))))
 :qid |unknown.0:0|
 :skolemid |1059|
 :pattern ( ($IsBox bx@@79 (Tclass._System.___hTotalFunc0L |#$R@@161|)))
)))
(assert (forall ((|#$R@@162| T@U) (|f#0@@33| T@U) ) (!  (=> (and (= (type |#$R@@162|) TyType) (= (type |f#0@@33|) HandleTypeType)) (= ($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|))  (and ($Is |f#0@@33| (Tclass._System.___hPartialFunc0L |#$R@@162|)) (Requires0 |#$R@@162| $OneHeap |f#0@@33|))))
 :qid |unknown.0:0|
 :skolemid |1060|
 :pattern ( ($Is |f#0@@33| (Tclass._System.___hTotalFunc0L |#$R@@162|)))
)))
(assert (forall ((|#$R@@163| T@U) (|f#0@@34| T@U) ($h@@28 T@U) ) (!  (=> (and (and (= (type |#$R@@163|) TyType) (= (type |f#0@@34|) HandleTypeType)) (= (type $h@@28) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@34| (Tclass._System.___hTotalFunc0L |#$R@@163|) $h@@28) ($IsAlloc |f#0@@34| (Tclass._System.___hPartialFunc0L |#$R@@163|) $h@@28)))
 :qid |unknown.0:0|
 :skolemid |1061|
 :pattern ( ($IsAlloc |f#0@@34| (Tclass._System.___hTotalFunc0L |#$R@@163|) $h@@28))
)))
(assert (forall ((arg0@@268 T@U) (arg1@@118 T@U) (arg2@@67 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO|
 :pattern ( (Tclass._System.___hFunc2LOO arg0@@268 arg1@@118 arg2@@67))
)))
(assert (forall ((|#$T0@@138| T@U) (|#$T1@@106| T@U) (|#$R@@164| T@U) ) (!  (=> (and (and (= (type |#$T0@@138|) TyType) (= (type |#$T1@@106|) TyType)) (= (type |#$R@@164|) TyType)) (and (= (Tag (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|)) Tagclass._System.___hFunc2LOO) (= (TagFamily (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|)) |tytagFamily$_#Func2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1062|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@138| |#$T1@@106| |#$R@@164|))
)))
(assert (forall ((arg0@@269 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_0 arg0@@269)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_0|
 :pattern ( (Tclass._System.___hFunc2LOO_0 arg0@@269))
)))
(assert (forall ((|#$T0@@139| T@U) (|#$T1@@107| T@U) (|#$R@@165| T@U) ) (!  (=> (and (and (= (type |#$T0@@139|) TyType) (= (type |#$T1@@107|) TyType)) (= (type |#$R@@165|) TyType)) (= (Tclass._System.___hFunc2LOO_0 (Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|)) |#$T0@@139|))
 :qid |unknown.0:0|
 :skolemid |1063|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@139| |#$T1@@107| |#$R@@165|))
)))
(assert (forall ((arg0@@270 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_1 arg0@@270)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_1|
 :pattern ( (Tclass._System.___hFunc2LOO_1 arg0@@270))
)))
(assert (forall ((|#$T0@@140| T@U) (|#$T1@@108| T@U) (|#$R@@166| T@U) ) (!  (=> (and (and (= (type |#$T0@@140|) TyType) (= (type |#$T1@@108|) TyType)) (= (type |#$R@@166|) TyType)) (= (Tclass._System.___hFunc2LOO_1 (Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|)) |#$T1@@108|))
 :qid |unknown.0:0|
 :skolemid |1064|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@140| |#$T1@@108| |#$R@@166|))
)))
(assert (forall ((arg0@@271 T@U) ) (! (= (type (Tclass._System.___hFunc2LOO_2 arg0@@271)) TyType)
 :qid |funType:Tclass._System.___hFunc2LOO_2|
 :pattern ( (Tclass._System.___hFunc2LOO_2 arg0@@271))
)))
(assert (forall ((|#$T0@@141| T@U) (|#$T1@@109| T@U) (|#$R@@167| T@U) ) (!  (=> (and (and (= (type |#$T0@@141|) TyType) (= (type |#$T1@@109|) TyType)) (= (type |#$R@@167|) TyType)) (= (Tclass._System.___hFunc2LOO_2 (Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|)) |#$R@@167|))
 :qid |unknown.0:0|
 :skolemid |1065|
 :pattern ( (Tclass._System.___hFunc2LOO |#$T0@@141| |#$T1@@109| |#$R@@167|))
)))
(assert (forall ((|#$T0@@142| T@U) (|#$T1@@110| T@U) (|#$R@@168| T@U) (bx@@80 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@142|) TyType) (= (type |#$T1@@110|) TyType)) (= (type |#$R@@168|) TyType)) (= (type bx@@80) BoxType)) ($IsBox bx@@80 (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|))) (and (= ($Box ($Unbox HandleTypeType bx@@80)) bx@@80) ($Is ($Unbox HandleTypeType bx@@80) (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|))))
 :qid |unknown.0:0|
 :skolemid |1066|
 :pattern ( ($IsBox bx@@80 (Tclass._System.___hFunc2LOO |#$T0@@142| |#$T1@@110| |#$R@@168|)))
)))
(assert (forall ((arg0@@272 T@U) (arg1@@119 T@U) (arg2@@68 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO|
 :pattern ( (Tclass._System.___hPartialFunc2LOO arg0@@272 arg1@@119 arg2@@68))
)))
(assert (forall ((|#$T0@@143| T@U) (|#$T1@@111| T@U) (|#$R@@169| T@U) ) (!  (=> (and (and (= (type |#$T0@@143|) TyType) (= (type |#$T1@@111|) TyType)) (= (type |#$R@@169|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|)) Tagclass._System.___hPartialFunc2LOO) (= (TagFamily (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|)) |tytagFamily$_#PartialFunc2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1067|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@143| |#$T1@@111| |#$R@@169|))
)))
(assert (forall ((arg0@@273 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_0 arg0@@273)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_0|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_0 arg0@@273))
)))
(assert (forall ((|#$T0@@144| T@U) (|#$T1@@112| T@U) (|#$R@@170| T@U) ) (!  (=> (and (and (= (type |#$T0@@144|) TyType) (= (type |#$T1@@112|) TyType)) (= (type |#$R@@170|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_0 (Tclass._System.___hPartialFunc2LOO |#$T0@@144| |#$T1@@112| |#$R@@170|)) |#$T0@@144|))
 :qid |unknown.0:0|
 :skolemid |1068|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@144| |#$T1@@112| |#$R@@170|))
)))
(assert (forall ((arg0@@274 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_1 arg0@@274)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_1|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_1 arg0@@274))
)))
(assert (forall ((|#$T0@@145| T@U) (|#$T1@@113| T@U) (|#$R@@171| T@U) ) (!  (=> (and (and (= (type |#$T0@@145|) TyType) (= (type |#$T1@@113|) TyType)) (= (type |#$R@@171|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_1 (Tclass._System.___hPartialFunc2LOO |#$T0@@145| |#$T1@@113| |#$R@@171|)) |#$T1@@113|))
 :qid |unknown.0:0|
 :skolemid |1069|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@145| |#$T1@@113| |#$R@@171|))
)))
(assert (forall ((arg0@@275 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LOO_2 arg0@@275)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LOO_2|
 :pattern ( (Tclass._System.___hPartialFunc2LOO_2 arg0@@275))
)))
(assert (forall ((|#$T0@@146| T@U) (|#$T1@@114| T@U) (|#$R@@172| T@U) ) (!  (=> (and (and (= (type |#$T0@@146|) TyType) (= (type |#$T1@@114|) TyType)) (= (type |#$R@@172|) TyType)) (= (Tclass._System.___hPartialFunc2LOO_2 (Tclass._System.___hPartialFunc2LOO |#$T0@@146| |#$T1@@114| |#$R@@172|)) |#$R@@172|))
 :qid |unknown.0:0|
 :skolemid |1070|
 :pattern ( (Tclass._System.___hPartialFunc2LOO |#$T0@@146| |#$T1@@114| |#$R@@172|))
)))
(assert (forall ((|#$T0@@147| T@U) (|#$T1@@115| T@U) (|#$R@@173| T@U) (bx@@81 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@147|) TyType) (= (type |#$T1@@115|) TyType)) (= (type |#$R@@173|) TyType)) (= (type bx@@81) BoxType)) ($IsBox bx@@81 (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|))) (and (= ($Box ($Unbox HandleTypeType bx@@81)) bx@@81) ($Is ($Unbox HandleTypeType bx@@81) (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|))))
 :qid |unknown.0:0|
 :skolemid |1071|
 :pattern ( ($IsBox bx@@81 (Tclass._System.___hPartialFunc2LOO |#$T0@@147| |#$T1@@115| |#$R@@173|)))
)))
(assert (forall ((|#$T0@@148| T@U) (|#$T1@@116| T@U) (|#$R@@174| T@U) (|f#0@@35| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@148|) TyType) (= (type |#$T1@@116|) TyType)) (= (type |#$R@@174|) TyType)) (= (type |f#0@@35|) HandleTypeType)) (= ($Is |f#0@@35| (Tclass._System.___hPartialFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|))  (and ($Is |f#0@@35| (Tclass._System.___hFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|)) (forall ((|x0#0@@13| T@U) (|x1#0@@9| T@U) ) (!  (=> (and (and (= (type |x0#0@@13|) BoxType) (= (type |x1#0@@9|) BoxType)) (and ($IsBox |x0#0@@13| |#$T0@@148|) ($IsBox |x1#0@@9| |#$T1@@116|))) (|Set#Equal| (Reads2 |#$T0@@148| |#$T1@@116| |#$R@@174| $OneHeap |f#0@@35| |x0#0@@13| |x1#0@@9|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1072|
 :no-pattern (type |x0#0@@13|)
 :no-pattern (type |x1#0@@9|)
 :no-pattern (U_2_int |x0#0@@13|)
 :no-pattern (U_2_bool |x0#0@@13|)
 :no-pattern (U_2_int |x1#0@@9|)
 :no-pattern (U_2_bool |x1#0@@9|)
)))))
 :qid |unknown.0:0|
 :skolemid |1073|
 :pattern ( ($Is |f#0@@35| (Tclass._System.___hPartialFunc2LOO |#$T0@@148| |#$T1@@116| |#$R@@174|)))
)))
(assert (forall ((|#$T0@@149| T@U) (|#$T1@@117| T@U) (|#$R@@175| T@U) (|f#0@@36| T@U) ($h@@29 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@149|) TyType) (= (type |#$T1@@117|) TyType)) (= (type |#$R@@175|) TyType)) (= (type |f#0@@36|) HandleTypeType)) (= (type $h@@29) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@36| (Tclass._System.___hPartialFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29) ($IsAlloc |f#0@@36| (Tclass._System.___hFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29)))
 :qid |unknown.0:0|
 :skolemid |1074|
 :pattern ( ($IsAlloc |f#0@@36| (Tclass._System.___hPartialFunc2LOO |#$T0@@149| |#$T1@@117| |#$R@@175|) $h@@29))
)))
(assert (forall ((arg0@@276 T@U) (arg1@@120 T@U) (arg2@@69 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO|
 :pattern ( (Tclass._System.___hTotalFunc2LOO arg0@@276 arg1@@120 arg2@@69))
)))
(assert (forall ((|#$T0@@150| T@U) (|#$T1@@118| T@U) (|#$R@@176| T@U) ) (!  (=> (and (and (= (type |#$T0@@150|) TyType) (= (type |#$T1@@118|) TyType)) (= (type |#$R@@176|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|)) Tagclass._System.___hTotalFunc2LOO) (= (TagFamily (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|)) |tytagFamily$_#TotalFunc2LOO|)))
 :qid |unknown.0:0|
 :skolemid |1075|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@150| |#$T1@@118| |#$R@@176|))
)))
(assert (forall ((arg0@@277 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_0 arg0@@277)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_0|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_0 arg0@@277))
)))
(assert (forall ((|#$T0@@151| T@U) (|#$T1@@119| T@U) (|#$R@@177| T@U) ) (!  (=> (and (and (= (type |#$T0@@151|) TyType) (= (type |#$T1@@119|) TyType)) (= (type |#$R@@177|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_0 (Tclass._System.___hTotalFunc2LOO |#$T0@@151| |#$T1@@119| |#$R@@177|)) |#$T0@@151|))
 :qid |unknown.0:0|
 :skolemid |1076|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@151| |#$T1@@119| |#$R@@177|))
)))
(assert (forall ((arg0@@278 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_1 arg0@@278)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_1|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_1 arg0@@278))
)))
(assert (forall ((|#$T0@@152| T@U) (|#$T1@@120| T@U) (|#$R@@178| T@U) ) (!  (=> (and (and (= (type |#$T0@@152|) TyType) (= (type |#$T1@@120|) TyType)) (= (type |#$R@@178|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_1 (Tclass._System.___hTotalFunc2LOO |#$T0@@152| |#$T1@@120| |#$R@@178|)) |#$T1@@120|))
 :qid |unknown.0:0|
 :skolemid |1077|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@152| |#$T1@@120| |#$R@@178|))
)))
(assert (forall ((arg0@@279 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LOO_2 arg0@@279)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LOO_2|
 :pattern ( (Tclass._System.___hTotalFunc2LOO_2 arg0@@279))
)))
(assert (forall ((|#$T0@@153| T@U) (|#$T1@@121| T@U) (|#$R@@179| T@U) ) (!  (=> (and (and (= (type |#$T0@@153|) TyType) (= (type |#$T1@@121|) TyType)) (= (type |#$R@@179|) TyType)) (= (Tclass._System.___hTotalFunc2LOO_2 (Tclass._System.___hTotalFunc2LOO |#$T0@@153| |#$T1@@121| |#$R@@179|)) |#$R@@179|))
 :qid |unknown.0:0|
 :skolemid |1078|
 :pattern ( (Tclass._System.___hTotalFunc2LOO |#$T0@@153| |#$T1@@121| |#$R@@179|))
)))
(assert (forall ((|#$T0@@154| T@U) (|#$T1@@122| T@U) (|#$R@@180| T@U) (bx@@82 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@154|) TyType) (= (type |#$T1@@122|) TyType)) (= (type |#$R@@180|) TyType)) (= (type bx@@82) BoxType)) ($IsBox bx@@82 (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|))) (and (= ($Box ($Unbox HandleTypeType bx@@82)) bx@@82) ($Is ($Unbox HandleTypeType bx@@82) (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|))))
 :qid |unknown.0:0|
 :skolemid |1079|
 :pattern ( ($IsBox bx@@82 (Tclass._System.___hTotalFunc2LOO |#$T0@@154| |#$T1@@122| |#$R@@180|)))
)))
(assert (forall ((|#$T0@@155| T@U) (|#$T1@@123| T@U) (|#$R@@181| T@U) (|f#0@@37| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@155|) TyType) (= (type |#$T1@@123|) TyType)) (= (type |#$R@@181|) TyType)) (= (type |f#0@@37|) HandleTypeType)) (= ($Is |f#0@@37| (Tclass._System.___hTotalFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|))  (and ($Is |f#0@@37| (Tclass._System.___hPartialFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|)) (forall ((|x0#0@@14| T@U) (|x1#0@@10| T@U) ) (!  (=> (and (and (= (type |x0#0@@14|) BoxType) (= (type |x1#0@@10|) BoxType)) (and ($IsBox |x0#0@@14| |#$T0@@155|) ($IsBox |x1#0@@10| |#$T1@@123|))) (Requires2 |#$T0@@155| |#$T1@@123| |#$R@@181| $OneHeap |f#0@@37| |x0#0@@14| |x1#0@@10|))
 :qid |unknown.0:0|
 :skolemid |1080|
 :no-pattern (type |x0#0@@14|)
 :no-pattern (type |x1#0@@10|)
 :no-pattern (U_2_int |x0#0@@14|)
 :no-pattern (U_2_bool |x0#0@@14|)
 :no-pattern (U_2_int |x1#0@@10|)
 :no-pattern (U_2_bool |x1#0@@10|)
)))))
 :qid |unknown.0:0|
 :skolemid |1081|
 :pattern ( ($Is |f#0@@37| (Tclass._System.___hTotalFunc2LOO |#$T0@@155| |#$T1@@123| |#$R@@181|)))
)))
(assert (forall ((|#$T0@@156| T@U) (|#$T1@@124| T@U) (|#$R@@182| T@U) (|f#0@@38| T@U) ($h@@30 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@156|) TyType) (= (type |#$T1@@124|) TyType)) (= (type |#$R@@182|) TyType)) (= (type |f#0@@38|) HandleTypeType)) (= (type $h@@30) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@38| (Tclass._System.___hTotalFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30) ($IsAlloc |f#0@@38| (Tclass._System.___hPartialFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30)))
 :qid |unknown.0:0|
 :skolemid |1082|
 :pattern ( ($IsAlloc |f#0@@38| (Tclass._System.___hTotalFunc2LOO |#$T0@@156| |#$T1@@124| |#$R@@182|) $h@@30))
)))
(assert (= (type |#_System._tuple#0._#Make0|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#_System._tuple#0._#Make0|) |##_System._tuple#0._#Make0|))
(assert (forall ((d@@6 T@U) ) (!  (=> (= (type d@@6) DatatypeTypeType) (= (_System.Tuple0.___hMake0_q d@@6) (= (DatatypeCtorId d@@6) |##_System._tuple#0._#Make0|)))
 :qid |unknown.0:0|
 :skolemid |1083|
 :pattern ( (_System.Tuple0.___hMake0_q d@@6))
)))
(assert (forall ((d@@7 T@U) ) (!  (=> (and (= (type d@@7) DatatypeTypeType) (_System.Tuple0.___hMake0_q d@@7)) (= d@@7 |#_System._tuple#0._#Make0|))
 :qid |unknown.0:0|
 :skolemid |1084|
 :pattern ( (_System.Tuple0.___hMake0_q d@@7))
)))
(assert (= (type Tclass._System.Tuple0) TyType))
(assert (= (Tag Tclass._System.Tuple0) Tagclass._System.Tuple0))
(assert (= (TagFamily Tclass._System.Tuple0) |tytagFamily$_tuple#0|))
(assert (forall ((bx@@83 T@U) ) (!  (=> (and (= (type bx@@83) BoxType) ($IsBox bx@@83 Tclass._System.Tuple0)) (and (= ($Box ($Unbox DatatypeTypeType bx@@83)) bx@@83) ($Is ($Unbox DatatypeTypeType bx@@83) Tclass._System.Tuple0)))
 :qid |unknown.0:0|
 :skolemid |1085|
 :pattern ( ($IsBox bx@@83 Tclass._System.Tuple0))
)))
(assert ($Is |#_System._tuple#0._#Make0| Tclass._System.Tuple0))
(assert (forall (($h@@31 T@U) ) (!  (=> (and (= (type $h@@31) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@31)) ($IsAlloc |#_System._tuple#0._#Make0| Tclass._System.Tuple0 $h@@31))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |1086|
 :pattern ( ($IsAlloc |#_System._tuple#0._#Make0| Tclass._System.Tuple0 $h@@31))
)))
(assert (= |#_System._tuple#0._#Make0| (Lit |#_System._tuple#0._#Make0|)))
(assert (forall ((d@@8 T@U) ) (!  (=> (and (= (type d@@8) DatatypeTypeType) (|$IsA#_System.Tuple0| d@@8)) (_System.Tuple0.___hMake0_q d@@8))
 :qid |unknown.0:0|
 :skolemid |1087|
 :pattern ( (|$IsA#_System.Tuple0| d@@8))
)))
(assert (forall ((d@@9 T@U) ) (!  (=> (and (= (type d@@9) DatatypeTypeType) ($Is d@@9 Tclass._System.Tuple0)) (_System.Tuple0.___hMake0_q d@@9))
 :qid |unknown.0:0|
 :skolemid |1088|
 :pattern ( (_System.Tuple0.___hMake0_q d@@9) ($Is d@@9 Tclass._System.Tuple0))
)))
(assert (forall ((a@@114 T@U) (b@@63 T@U) ) (!  (=> (and (and (= (type a@@114) DatatypeTypeType) (= (type b@@63) DatatypeTypeType)) true) (= (|_System.Tuple0#Equal| a@@114 b@@63) true))
 :qid |unknown.0:0|
 :skolemid |1089|
 :pattern ( (|_System.Tuple0#Equal| a@@114 b@@63))
)))
(assert (forall ((a@@115 T@U) (b@@64 T@U) ) (!  (=> (and (= (type a@@115) DatatypeTypeType) (= (type b@@64) DatatypeTypeType)) (= (|_System.Tuple0#Equal| a@@115 b@@64) (= a@@115 b@@64)))
 :qid |unknown.0:0|
 :skolemid |1090|
 :pattern ( (|_System.Tuple0#Equal| a@@115 b@@64))
)))
(assert (forall ((arg0@@280 T@U) (arg1@@121 T@U) ) (! (= (type (Tclass._System.___hFunc1OL arg0@@280 arg1@@121)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL|
 :pattern ( (Tclass._System.___hFunc1OL arg0@@280 arg1@@121))
)))
(assert (forall ((|#$T0@@157| T@U) (|#$R@@183| T@U) ) (!  (=> (and (= (type |#$T0@@157|) TyType) (= (type |#$R@@183|) TyType)) (and (= (Tag (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|)) Tagclass._System.___hFunc1OL) (= (TagFamily (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|)) |tytagFamily$_#Func1OL|)))
 :qid |unknown.0:0|
 :skolemid |1091|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@157| |#$R@@183|))
)))
(assert (forall ((arg0@@281 T@U) ) (! (= (type (Tclass._System.___hFunc1OL_0 arg0@@281)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL_0|
 :pattern ( (Tclass._System.___hFunc1OL_0 arg0@@281))
)))
(assert (forall ((|#$T0@@158| T@U) (|#$R@@184| T@U) ) (!  (=> (and (= (type |#$T0@@158|) TyType) (= (type |#$R@@184|) TyType)) (= (Tclass._System.___hFunc1OL_0 (Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|)) |#$T0@@158|))
 :qid |unknown.0:0|
 :skolemid |1092|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@158| |#$R@@184|))
)))
(assert (forall ((arg0@@282 T@U) ) (! (= (type (Tclass._System.___hFunc1OL_1 arg0@@282)) TyType)
 :qid |funType:Tclass._System.___hFunc1OL_1|
 :pattern ( (Tclass._System.___hFunc1OL_1 arg0@@282))
)))
(assert (forall ((|#$T0@@159| T@U) (|#$R@@185| T@U) ) (!  (=> (and (= (type |#$T0@@159|) TyType) (= (type |#$R@@185|) TyType)) (= (Tclass._System.___hFunc1OL_1 (Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|)) |#$R@@185|))
 :qid |unknown.0:0|
 :skolemid |1093|
 :pattern ( (Tclass._System.___hFunc1OL |#$T0@@159| |#$R@@185|))
)))
(assert (forall ((|#$T0@@160| T@U) (|#$R@@186| T@U) (bx@@84 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@160|) TyType) (= (type |#$R@@186|) TyType)) (= (type bx@@84) BoxType)) ($IsBox bx@@84 (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|))) (and (= ($Box ($Unbox HandleTypeType bx@@84)) bx@@84) ($Is ($Unbox HandleTypeType bx@@84) (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|))))
 :qid |unknown.0:0|
 :skolemid |1094|
 :pattern ( ($IsBox bx@@84 (Tclass._System.___hFunc1OL |#$T0@@160| |#$R@@186|)))
)))
(assert (forall ((arg0@@283 T@U) (arg1@@122 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL|
 :pattern ( (Tclass._System.___hPartialFunc1OL arg0@@283 arg1@@122))
)))
(assert (forall ((|#$T0@@161| T@U) (|#$R@@187| T@U) ) (!  (=> (and (= (type |#$T0@@161|) TyType) (= (type |#$R@@187|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|)) Tagclass._System.___hPartialFunc1OL) (= (TagFamily (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|)) |tytagFamily$_#PartialFunc1OL|)))
 :qid |unknown.0:0|
 :skolemid |1095|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@161| |#$R@@187|))
)))
(assert (forall ((arg0@@284 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL_0 arg0@@284)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL_0|
 :pattern ( (Tclass._System.___hPartialFunc1OL_0 arg0@@284))
)))
(assert (forall ((|#$T0@@162| T@U) (|#$R@@188| T@U) ) (!  (=> (and (= (type |#$T0@@162|) TyType) (= (type |#$R@@188|) TyType)) (= (Tclass._System.___hPartialFunc1OL_0 (Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|)) |#$T0@@162|))
 :qid |unknown.0:0|
 :skolemid |1096|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@162| |#$R@@188|))
)))
(assert (forall ((arg0@@285 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1OL_1 arg0@@285)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1OL_1|
 :pattern ( (Tclass._System.___hPartialFunc1OL_1 arg0@@285))
)))
(assert (forall ((|#$T0@@163| T@U) (|#$R@@189| T@U) ) (!  (=> (and (= (type |#$T0@@163|) TyType) (= (type |#$R@@189|) TyType)) (= (Tclass._System.___hPartialFunc1OL_1 (Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|)) |#$R@@189|))
 :qid |unknown.0:0|
 :skolemid |1097|
 :pattern ( (Tclass._System.___hPartialFunc1OL |#$T0@@163| |#$R@@189|))
)))
(assert (forall ((|#$T0@@164| T@U) (|#$R@@190| T@U) (bx@@85 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@164|) TyType) (= (type |#$R@@190|) TyType)) (= (type bx@@85) BoxType)) ($IsBox bx@@85 (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|))) (and (= ($Box ($Unbox HandleTypeType bx@@85)) bx@@85) ($Is ($Unbox HandleTypeType bx@@85) (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|))))
 :qid |unknown.0:0|
 :skolemid |1098|
 :pattern ( ($IsBox bx@@85 (Tclass._System.___hPartialFunc1OL |#$T0@@164| |#$R@@190|)))
)))
(assert (forall ((|#$T0@@165| T@U) (|#$R@@191| T@U) (|f#0@@39| T@U) ) (!  (=> (and (and (= (type |#$T0@@165|) TyType) (= (type |#$R@@191|) TyType)) (= (type |f#0@@39|) HandleTypeType)) (= ($Is |f#0@@39| (Tclass._System.___hPartialFunc1OL |#$T0@@165| |#$R@@191|))  (and ($Is |f#0@@39| (Tclass._System.___hFunc1OL |#$T0@@165| |#$R@@191|)) (forall ((|x0#0@@15| T@U) ) (!  (=> (and (= (type |x0#0@@15|) BoxType) ($IsBox |x0#0@@15| |#$T0@@165|)) (|Set#Equal| (Reads1 |#$T0@@165| |#$R@@191| $OneHeap |f#0@@39| |x0#0@@15|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1099|
 :no-pattern (type |x0#0@@15|)
 :no-pattern (U_2_int |x0#0@@15|)
 :no-pattern (U_2_bool |x0#0@@15|)
)))))
 :qid |unknown.0:0|
 :skolemid |1100|
 :pattern ( ($Is |f#0@@39| (Tclass._System.___hPartialFunc1OL |#$T0@@165| |#$R@@191|)))
)))
(assert (forall ((|#$T0@@166| T@U) (|#$R@@192| T@U) (|f#0@@40| T@U) ($h@@32 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@166|) TyType) (= (type |#$R@@192|) TyType)) (= (type |f#0@@40|) HandleTypeType)) (= (type $h@@32) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@40| (Tclass._System.___hPartialFunc1OL |#$T0@@166| |#$R@@192|) $h@@32) ($IsAlloc |f#0@@40| (Tclass._System.___hFunc1OL |#$T0@@166| |#$R@@192|) $h@@32)))
 :qid |unknown.0:0|
 :skolemid |1101|
 :pattern ( ($IsAlloc |f#0@@40| (Tclass._System.___hPartialFunc1OL |#$T0@@166| |#$R@@192|) $h@@32))
)))
(assert (forall ((arg0@@286 T@U) (arg1@@123 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL|
 :pattern ( (Tclass._System.___hTotalFunc1OL arg0@@286 arg1@@123))
)))
(assert (forall ((|#$T0@@167| T@U) (|#$R@@193| T@U) ) (!  (=> (and (= (type |#$T0@@167|) TyType) (= (type |#$R@@193|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|)) Tagclass._System.___hTotalFunc1OL) (= (TagFamily (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|)) |tytagFamily$_#TotalFunc1OL|)))
 :qid |unknown.0:0|
 :skolemid |1102|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@167| |#$R@@193|))
)))
(assert (forall ((arg0@@287 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL_0 arg0@@287)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL_0|
 :pattern ( (Tclass._System.___hTotalFunc1OL_0 arg0@@287))
)))
(assert (forall ((|#$T0@@168| T@U) (|#$R@@194| T@U) ) (!  (=> (and (= (type |#$T0@@168|) TyType) (= (type |#$R@@194|) TyType)) (= (Tclass._System.___hTotalFunc1OL_0 (Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|)) |#$T0@@168|))
 :qid |unknown.0:0|
 :skolemid |1103|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@168| |#$R@@194|))
)))
(assert (forall ((arg0@@288 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1OL_1 arg0@@288)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1OL_1|
 :pattern ( (Tclass._System.___hTotalFunc1OL_1 arg0@@288))
)))
(assert (forall ((|#$T0@@169| T@U) (|#$R@@195| T@U) ) (!  (=> (and (= (type |#$T0@@169|) TyType) (= (type |#$R@@195|) TyType)) (= (Tclass._System.___hTotalFunc1OL_1 (Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|)) |#$R@@195|))
 :qid |unknown.0:0|
 :skolemid |1104|
 :pattern ( (Tclass._System.___hTotalFunc1OL |#$T0@@169| |#$R@@195|))
)))
(assert (forall ((|#$T0@@170| T@U) (|#$R@@196| T@U) (bx@@86 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@170|) TyType) (= (type |#$R@@196|) TyType)) (= (type bx@@86) BoxType)) ($IsBox bx@@86 (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|))) (and (= ($Box ($Unbox HandleTypeType bx@@86)) bx@@86) ($Is ($Unbox HandleTypeType bx@@86) (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|))))
 :qid |unknown.0:0|
 :skolemid |1105|
 :pattern ( ($IsBox bx@@86 (Tclass._System.___hTotalFunc1OL |#$T0@@170| |#$R@@196|)))
)))
(assert (forall ((|#$T0@@171| T@U) (|#$R@@197| T@U) (|f#0@@41| T@U) ) (!  (=> (and (and (= (type |#$T0@@171|) TyType) (= (type |#$R@@197|) TyType)) (= (type |f#0@@41|) HandleTypeType)) (= ($Is |f#0@@41| (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|))  (and ($Is |f#0@@41| (Tclass._System.___hPartialFunc1OL |#$T0@@171| |#$R@@197|)) (forall ((|x0#0@@16| T@U) ) (!  (=> (and (= (type |x0#0@@16|) BoxType) ($IsBox |x0#0@@16| |#$T0@@171|)) (Requires1 |#$T0@@171| |#$R@@197| $OneHeap |f#0@@41| |x0#0@@16|))
 :qid |unknown.0:0|
 :skolemid |1106|
 :no-pattern (type |x0#0@@16|)
 :no-pattern (U_2_int |x0#0@@16|)
 :no-pattern (U_2_bool |x0#0@@16|)
)))))
 :qid |unknown.0:0|
 :skolemid |1107|
 :pattern ( ($Is |f#0@@41| (Tclass._System.___hTotalFunc1OL |#$T0@@171| |#$R@@197|)))
)))
(assert (forall ((|#$T0@@172| T@U) (|#$R@@198| T@U) (|f#0@@42| T@U) ($h@@33 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@172|) TyType) (= (type |#$R@@198|) TyType)) (= (type |f#0@@42|) HandleTypeType)) (= (type $h@@33) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@42| (Tclass._System.___hTotalFunc1OL |#$T0@@172| |#$R@@198|) $h@@33) ($IsAlloc |f#0@@42| (Tclass._System.___hPartialFunc1OL |#$T0@@172| |#$R@@198|) $h@@33)))
 :qid |unknown.0:0|
 :skolemid |1108|
 :pattern ( ($IsAlloc |f#0@@42| (Tclass._System.___hTotalFunc1OL |#$T0@@172| |#$R@@198|) $h@@33))
)))
(assert (forall ((arg0@@289 T@U) (arg1@@124 T@U) ) (! (= (type (Tclass._System.___hFunc1LO arg0@@289 arg1@@124)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO|
 :pattern ( (Tclass._System.___hFunc1LO arg0@@289 arg1@@124))
)))
(assert (forall ((|#$T0@@173| T@U) (|#$R@@199| T@U) ) (!  (=> (and (= (type |#$T0@@173|) TyType) (= (type |#$R@@199|) TyType)) (and (= (Tag (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|)) Tagclass._System.___hFunc1LO) (= (TagFamily (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|)) |tytagFamily$_#Func1LO|)))
 :qid |unknown.0:0|
 :skolemid |1109|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@173| |#$R@@199|))
)))
(assert (forall ((arg0@@290 T@U) ) (! (= (type (Tclass._System.___hFunc1LO_0 arg0@@290)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO_0|
 :pattern ( (Tclass._System.___hFunc1LO_0 arg0@@290))
)))
(assert (forall ((|#$T0@@174| T@U) (|#$R@@200| T@U) ) (!  (=> (and (= (type |#$T0@@174|) TyType) (= (type |#$R@@200|) TyType)) (= (Tclass._System.___hFunc1LO_0 (Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|)) |#$T0@@174|))
 :qid |unknown.0:0|
 :skolemid |1110|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@174| |#$R@@200|))
)))
(assert (forall ((arg0@@291 T@U) ) (! (= (type (Tclass._System.___hFunc1LO_1 arg0@@291)) TyType)
 :qid |funType:Tclass._System.___hFunc1LO_1|
 :pattern ( (Tclass._System.___hFunc1LO_1 arg0@@291))
)))
(assert (forall ((|#$T0@@175| T@U) (|#$R@@201| T@U) ) (!  (=> (and (= (type |#$T0@@175|) TyType) (= (type |#$R@@201|) TyType)) (= (Tclass._System.___hFunc1LO_1 (Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|)) |#$R@@201|))
 :qid |unknown.0:0|
 :skolemid |1111|
 :pattern ( (Tclass._System.___hFunc1LO |#$T0@@175| |#$R@@201|))
)))
(assert (forall ((|#$T0@@176| T@U) (|#$R@@202| T@U) (bx@@87 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@176|) TyType) (= (type |#$R@@202|) TyType)) (= (type bx@@87) BoxType)) ($IsBox bx@@87 (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|))) (and (= ($Box ($Unbox HandleTypeType bx@@87)) bx@@87) ($Is ($Unbox HandleTypeType bx@@87) (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|))))
 :qid |unknown.0:0|
 :skolemid |1112|
 :pattern ( ($IsBox bx@@87 (Tclass._System.___hFunc1LO |#$T0@@176| |#$R@@202|)))
)))
(assert (forall ((arg0@@292 T@U) (arg1@@125 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO|
 :pattern ( (Tclass._System.___hPartialFunc1LO arg0@@292 arg1@@125))
)))
(assert (forall ((|#$T0@@177| T@U) (|#$R@@203| T@U) ) (!  (=> (and (= (type |#$T0@@177|) TyType) (= (type |#$R@@203|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|)) Tagclass._System.___hPartialFunc1LO) (= (TagFamily (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|)) |tytagFamily$_#PartialFunc1LO|)))
 :qid |unknown.0:0|
 :skolemid |1113|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@177| |#$R@@203|))
)))
(assert (forall ((arg0@@293 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO_0 arg0@@293)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO_0|
 :pattern ( (Tclass._System.___hPartialFunc1LO_0 arg0@@293))
)))
(assert (forall ((|#$T0@@178| T@U) (|#$R@@204| T@U) ) (!  (=> (and (= (type |#$T0@@178|) TyType) (= (type |#$R@@204|) TyType)) (= (Tclass._System.___hPartialFunc1LO_0 (Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|)) |#$T0@@178|))
 :qid |unknown.0:0|
 :skolemid |1114|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@178| |#$R@@204|))
)))
(assert (forall ((arg0@@294 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LO_1 arg0@@294)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LO_1|
 :pattern ( (Tclass._System.___hPartialFunc1LO_1 arg0@@294))
)))
(assert (forall ((|#$T0@@179| T@U) (|#$R@@205| T@U) ) (!  (=> (and (= (type |#$T0@@179|) TyType) (= (type |#$R@@205|) TyType)) (= (Tclass._System.___hPartialFunc1LO_1 (Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|)) |#$R@@205|))
 :qid |unknown.0:0|
 :skolemid |1115|
 :pattern ( (Tclass._System.___hPartialFunc1LO |#$T0@@179| |#$R@@205|))
)))
(assert (forall ((|#$T0@@180| T@U) (|#$R@@206| T@U) (bx@@88 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@180|) TyType) (= (type |#$R@@206|) TyType)) (= (type bx@@88) BoxType)) ($IsBox bx@@88 (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|))) (and (= ($Box ($Unbox HandleTypeType bx@@88)) bx@@88) ($Is ($Unbox HandleTypeType bx@@88) (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|))))
 :qid |unknown.0:0|
 :skolemid |1116|
 :pattern ( ($IsBox bx@@88 (Tclass._System.___hPartialFunc1LO |#$T0@@180| |#$R@@206|)))
)))
(assert (forall ((|#$T0@@181| T@U) (|#$R@@207| T@U) (|f#0@@43| T@U) ) (!  (=> (and (and (= (type |#$T0@@181|) TyType) (= (type |#$R@@207|) TyType)) (= (type |f#0@@43|) HandleTypeType)) (= ($Is |f#0@@43| (Tclass._System.___hPartialFunc1LO |#$T0@@181| |#$R@@207|))  (and ($Is |f#0@@43| (Tclass._System.___hFunc1LO |#$T0@@181| |#$R@@207|)) (forall ((|x0#0@@17| T@U) ) (!  (=> (and (= (type |x0#0@@17|) BoxType) ($IsBox |x0#0@@17| |#$T0@@181|)) (|Set#Equal| (Reads1 |#$T0@@181| |#$R@@207| $OneHeap |f#0@@43| |x0#0@@17|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1117|
 :no-pattern (type |x0#0@@17|)
 :no-pattern (U_2_int |x0#0@@17|)
 :no-pattern (U_2_bool |x0#0@@17|)
)))))
 :qid |unknown.0:0|
 :skolemid |1118|
 :pattern ( ($Is |f#0@@43| (Tclass._System.___hPartialFunc1LO |#$T0@@181| |#$R@@207|)))
)))
(assert (forall ((|#$T0@@182| T@U) (|#$R@@208| T@U) (|f#0@@44| T@U) ($h@@34 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@182|) TyType) (= (type |#$R@@208|) TyType)) (= (type |f#0@@44|) HandleTypeType)) (= (type $h@@34) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@44| (Tclass._System.___hPartialFunc1LO |#$T0@@182| |#$R@@208|) $h@@34) ($IsAlloc |f#0@@44| (Tclass._System.___hFunc1LO |#$T0@@182| |#$R@@208|) $h@@34)))
 :qid |unknown.0:0|
 :skolemid |1119|
 :pattern ( ($IsAlloc |f#0@@44| (Tclass._System.___hPartialFunc1LO |#$T0@@182| |#$R@@208|) $h@@34))
)))
(assert (forall ((arg0@@295 T@U) (arg1@@126 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO|
 :pattern ( (Tclass._System.___hTotalFunc1LO arg0@@295 arg1@@126))
)))
(assert (forall ((|#$T0@@183| T@U) (|#$R@@209| T@U) ) (!  (=> (and (= (type |#$T0@@183|) TyType) (= (type |#$R@@209|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|)) Tagclass._System.___hTotalFunc1LO) (= (TagFamily (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|)) |tytagFamily$_#TotalFunc1LO|)))
 :qid |unknown.0:0|
 :skolemid |1120|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@183| |#$R@@209|))
)))
(assert (forall ((arg0@@296 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO_0 arg0@@296)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO_0|
 :pattern ( (Tclass._System.___hTotalFunc1LO_0 arg0@@296))
)))
(assert (forall ((|#$T0@@184| T@U) (|#$R@@210| T@U) ) (!  (=> (and (= (type |#$T0@@184|) TyType) (= (type |#$R@@210|) TyType)) (= (Tclass._System.___hTotalFunc1LO_0 (Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|)) |#$T0@@184|))
 :qid |unknown.0:0|
 :skolemid |1121|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@184| |#$R@@210|))
)))
(assert (forall ((arg0@@297 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LO_1 arg0@@297)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LO_1|
 :pattern ( (Tclass._System.___hTotalFunc1LO_1 arg0@@297))
)))
(assert (forall ((|#$T0@@185| T@U) (|#$R@@211| T@U) ) (!  (=> (and (= (type |#$T0@@185|) TyType) (= (type |#$R@@211|) TyType)) (= (Tclass._System.___hTotalFunc1LO_1 (Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|)) |#$R@@211|))
 :qid |unknown.0:0|
 :skolemid |1122|
 :pattern ( (Tclass._System.___hTotalFunc1LO |#$T0@@185| |#$R@@211|))
)))
(assert (forall ((|#$T0@@186| T@U) (|#$R@@212| T@U) (bx@@89 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@186|) TyType) (= (type |#$R@@212|) TyType)) (= (type bx@@89) BoxType)) ($IsBox bx@@89 (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|))) (and (= ($Box ($Unbox HandleTypeType bx@@89)) bx@@89) ($Is ($Unbox HandleTypeType bx@@89) (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|))))
 :qid |unknown.0:0|
 :skolemid |1123|
 :pattern ( ($IsBox bx@@89 (Tclass._System.___hTotalFunc1LO |#$T0@@186| |#$R@@212|)))
)))
(assert (forall ((|#$T0@@187| T@U) (|#$R@@213| T@U) (|f#0@@45| T@U) ) (!  (=> (and (and (= (type |#$T0@@187|) TyType) (= (type |#$R@@213|) TyType)) (= (type |f#0@@45|) HandleTypeType)) (= ($Is |f#0@@45| (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|))  (and ($Is |f#0@@45| (Tclass._System.___hPartialFunc1LO |#$T0@@187| |#$R@@213|)) (forall ((|x0#0@@18| T@U) ) (!  (=> (and (= (type |x0#0@@18|) BoxType) ($IsBox |x0#0@@18| |#$T0@@187|)) (Requires1 |#$T0@@187| |#$R@@213| $OneHeap |f#0@@45| |x0#0@@18|))
 :qid |unknown.0:0|
 :skolemid |1124|
 :no-pattern (type |x0#0@@18|)
 :no-pattern (U_2_int |x0#0@@18|)
 :no-pattern (U_2_bool |x0#0@@18|)
)))))
 :qid |unknown.0:0|
 :skolemid |1125|
 :pattern ( ($Is |f#0@@45| (Tclass._System.___hTotalFunc1LO |#$T0@@187| |#$R@@213|)))
)))
(assert (forall ((|#$T0@@188| T@U) (|#$R@@214| T@U) (|f#0@@46| T@U) ($h@@35 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@188|) TyType) (= (type |#$R@@214|) TyType)) (= (type |f#0@@46|) HandleTypeType)) (= (type $h@@35) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@46| (Tclass._System.___hTotalFunc1LO |#$T0@@188| |#$R@@214|) $h@@35) ($IsAlloc |f#0@@46| (Tclass._System.___hPartialFunc1LO |#$T0@@188| |#$R@@214|) $h@@35)))
 :qid |unknown.0:0|
 :skolemid |1126|
 :pattern ( ($IsAlloc |f#0@@46| (Tclass._System.___hTotalFunc1LO |#$T0@@188| |#$R@@214|) $h@@35))
)))
(assert (forall ((arg0@@298 T@U) (arg1@@127 T@U) ) (! (= (type (|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127)) DatatypeTypeType)
 :qid |funType:#_System._tuple#2OLL._#Make2|
 :pattern ( (|#_System._tuple#2OLL._#Make2| arg0@@298 arg1@@127))
)))
(assert (forall ((|a#14#0#0| T@U) (|a#14#1#0| T@U) ) (!  (=> (and (= (type |a#14#0#0|) BoxType) (= (type |a#14#1#0|) BoxType)) (= (DatatypeCtorId (|#_System._tuple#2OLL._#Make2| |a#14#0#0| |a#14#1#0|)) |##_System._tuple#2OLL._#Make2|))
 :qid |unknown.0:0|
 :skolemid |1127|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#14#0#0| |a#14#1#0|))
)))
(assert (forall ((d@@10 T@U) ) (!  (=> (= (type d@@10) DatatypeTypeType) (= (_System.Tuple2OLL.___hMake2_q d@@10) (= (DatatypeCtorId d@@10) |##_System._tuple#2OLL._#Make2|)))
 :qid |unknown.0:0|
 :skolemid |1128|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@10))
)))
(assert (forall ((d@@11 T@U) ) (!  (=> (and (= (type d@@11) DatatypeTypeType) (_System.Tuple2OLL.___hMake2_q d@@11)) (exists ((|a#15#0#0| T@U) (|a#15#1#0| T@U) ) (!  (and (and (= (type |a#15#0#0|) BoxType) (= (type |a#15#1#0|) BoxType)) (= d@@11 (|#_System._tuple#2OLL._#Make2| |a#15#0#0| |a#15#1#0|)))
 :qid |unknown.0:0|
 :skolemid |1129|
 :no-pattern (type |a#15#0#0|)
 :no-pattern (type |a#15#1#0|)
 :no-pattern (U_2_int |a#15#0#0|)
 :no-pattern (U_2_bool |a#15#0#0|)
 :no-pattern (U_2_int |a#15#1#0|)
 :no-pattern (U_2_bool |a#15#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1130|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@11))
)))
(assert (forall ((arg0@@299 T@U) (arg1@@128 T@U) ) (! (= (type (Tclass._System.Tuple2OLL arg0@@299 arg1@@128)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL|
 :pattern ( (Tclass._System.Tuple2OLL arg0@@299 arg1@@128))
)))
(assert (forall ((|_System._tuple#2OLL$T0| T@U) (|_System._tuple#2OLL$T1| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0|) TyType) (= (type |_System._tuple#2OLL$T1|) TyType)) (and (= (Tag (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|)) Tagclass._System.Tuple2OLL) (= (TagFamily (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|)) |tytagFamily$_tuple#2OLL|)))
 :qid |unknown.0:0|
 :skolemid |1131|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0| |_System._tuple#2OLL$T1|))
)))
(assert (forall ((arg0@@300 T@U) ) (! (= (type (Tclass._System.Tuple2OLL_0 arg0@@300)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL_0|
 :pattern ( (Tclass._System.Tuple2OLL_0 arg0@@300))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@0| T@U) (|_System._tuple#2OLL$T1@@0| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0@@0|) TyType) (= (type |_System._tuple#2OLL$T1@@0|) TyType)) (= (Tclass._System.Tuple2OLL_0 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@0| |_System._tuple#2OLL$T1@@0|)) |_System._tuple#2OLL$T0@@0|))
 :qid |unknown.0:0|
 :skolemid |1132|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@0| |_System._tuple#2OLL$T1@@0|))
)))
(assert (forall ((arg0@@301 T@U) ) (! (= (type (Tclass._System.Tuple2OLL_1 arg0@@301)) TyType)
 :qid |funType:Tclass._System.Tuple2OLL_1|
 :pattern ( (Tclass._System.Tuple2OLL_1 arg0@@301))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@1| T@U) (|_System._tuple#2OLL$T1@@1| T@U) ) (!  (=> (and (= (type |_System._tuple#2OLL$T0@@1|) TyType) (= (type |_System._tuple#2OLL$T1@@1|) TyType)) (= (Tclass._System.Tuple2OLL_1 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@1| |_System._tuple#2OLL$T1@@1|)) |_System._tuple#2OLL$T1@@1|))
 :qid |unknown.0:0|
 :skolemid |1133|
 :pattern ( (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@1| |_System._tuple#2OLL$T1@@1|))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@2| T@U) (|_System._tuple#2OLL$T1@@2| T@U) (bx@@90 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@2|) TyType) (= (type |_System._tuple#2OLL$T1@@2|) TyType)) (= (type bx@@90) BoxType)) ($IsBox bx@@90 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|))) (and (= ($Box ($Unbox DatatypeTypeType bx@@90)) bx@@90) ($Is ($Unbox DatatypeTypeType bx@@90) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|))))
 :qid |unknown.0:0|
 :skolemid |1134|
 :pattern ( ($IsBox bx@@90 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@2| |_System._tuple#2OLL$T1@@2|)))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@3| T@U) (|_System._tuple#2OLL$T1@@3| T@U) (|a#16#0#0| T@U) (|a#16#1#0| T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@3|) TyType) (= (type |_System._tuple#2OLL$T1@@3|) TyType)) (= (type |a#16#0#0|) BoxType)) (= (type |a#16#1#0|) BoxType)) (= ($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@3| |_System._tuple#2OLL$T1@@3|))  (and ($IsBox |a#16#0#0| |_System._tuple#2OLL$T0@@3|) ($IsBox |a#16#1#0| |_System._tuple#2OLL$T1@@3|))))
 :qid |unknown.0:0|
 :skolemid |1135|
 :pattern ( ($Is (|#_System._tuple#2OLL._#Make2| |a#16#0#0| |a#16#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@3| |_System._tuple#2OLL$T1@@3|)))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@4| T@U) (|_System._tuple#2OLL$T1@@4| T@U) (|a#17#0#0| T@U) (|a#17#1#0| T@U) ($h@@36 T@U) ) (!  (=> (and (and (and (and (and (= (type |_System._tuple#2OLL$T0@@4|) TyType) (= (type |_System._tuple#2OLL$T1@@4|) TyType)) (= (type |a#17#0#0|) BoxType)) (= (type |a#17#1#0|) BoxType)) (= (type $h@@36) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@36)) (= ($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@4| |_System._tuple#2OLL$T1@@4|) $h@@36)  (and ($IsAllocBox |a#17#0#0| |_System._tuple#2OLL$T0@@4| $h@@36) ($IsAllocBox |a#17#1#0| |_System._tuple#2OLL$T1@@4| $h@@36))))
 :qid |unknown.0:0|
 :skolemid |1136|
 :pattern ( ($IsAlloc (|#_System._tuple#2OLL._#Make2| |a#17#0#0| |a#17#1#0|) (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@4| |_System._tuple#2OLL$T1@@4|) $h@@36))
)))
(assert (forall ((arg0@@302 T@U) ) (! (= (type (_System.Tuple2OLL._0 arg0@@302)) BoxType)
 :qid |funType:_System.Tuple2OLL._0|
 :pattern ( (_System.Tuple2OLL._0 arg0@@302))
)))
(assert (forall ((d@@12 T@U) (|_System._tuple#2OLL$T0@@5| T@U) ($h@@37 T@U) ) (!  (=> (and (and (and (= (type d@@12) DatatypeTypeType) (= (type |_System._tuple#2OLL$T0@@5|) TyType)) (= (type $h@@37) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@37) (and (_System.Tuple2OLL.___hMake2_q d@@12) (exists ((|_System._tuple#2OLL$T1@@5| T@U) ) (!  (and (= (type |_System._tuple#2OLL$T1@@5|) TyType) ($IsAlloc d@@12 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@5| |_System._tuple#2OLL$T1@@5|) $h@@37))
 :qid |unknown.0:0|
 :skolemid |1137|
 :pattern ( ($IsAlloc d@@12 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@5| |_System._tuple#2OLL$T1@@5|) $h@@37))
))))) ($IsAllocBox (_System.Tuple2OLL._0 d@@12) |_System._tuple#2OLL$T0@@5| $h@@37))
 :qid |unknown.0:0|
 :skolemid |1138|
 :pattern ( ($IsAllocBox (_System.Tuple2OLL._0 d@@12) |_System._tuple#2OLL$T0@@5| $h@@37))
)))
(assert (forall ((arg0@@303 T@U) ) (! (= (type (_System.Tuple2OLL._1 arg0@@303)) BoxType)
 :qid |funType:_System.Tuple2OLL._1|
 :pattern ( (_System.Tuple2OLL._1 arg0@@303))
)))
(assert (forall ((d@@13 T@U) (|_System._tuple#2OLL$T1@@6| T@U) ($h@@38 T@U) ) (!  (=> (and (and (and (= (type d@@13) DatatypeTypeType) (= (type |_System._tuple#2OLL$T1@@6|) TyType)) (= (type $h@@38) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@38) (and (_System.Tuple2OLL.___hMake2_q d@@13) (exists ((|_System._tuple#2OLL$T0@@6| T@U) ) (!  (and (= (type |_System._tuple#2OLL$T0@@6|) TyType) ($IsAlloc d@@13 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@6| |_System._tuple#2OLL$T1@@6|) $h@@38))
 :qid |unknown.0:0|
 :skolemid |1139|
 :pattern ( ($IsAlloc d@@13 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@6| |_System._tuple#2OLL$T1@@6|) $h@@38))
))))) ($IsAllocBox (_System.Tuple2OLL._1 d@@13) |_System._tuple#2OLL$T1@@6| $h@@38))
 :qid |unknown.0:0|
 :skolemid |1140|
 :pattern ( ($IsAllocBox (_System.Tuple2OLL._1 d@@13) |_System._tuple#2OLL$T1@@6| $h@@38))
)))
(assert (forall ((|a#18#0#0| T@U) (|a#18#1#0| T@U) ) (!  (=> (and (= (type |a#18#0#0|) BoxType) (= (type |a#18#1#0|) BoxType)) (= (|#_System._tuple#2OLL._#Make2| (Lit |a#18#0#0|) (Lit |a#18#1#0|)) (Lit (|#_System._tuple#2OLL._#Make2| |a#18#0#0| |a#18#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1141|
 :pattern ( (|#_System._tuple#2OLL._#Make2| (Lit |a#18#0#0|) (Lit |a#18#1#0|)))
)))
(assert (forall ((|a#19#0#0| T@U) (|a#19#1#0| T@U) ) (!  (=> (and (= (type |a#19#0#0|) BoxType) (= (type |a#19#1#0|) BoxType)) (= (_System.Tuple2OLL._0 (|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|)) |a#19#0#0|))
 :qid |unknown.0:0|
 :skolemid |1142|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#19#0#0| |a#19#1#0|))
)))
(assert (forall ((|a#20#0#0| T@U) (|a#20#1#0| T@U) ) (!  (=> (and (= (type |a#20#0#0|) BoxType) (= (type |a#20#1#0|) BoxType)) (< (BoxRank |a#20#0#0|) (DtRank (|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1143|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#20#0#0| |a#20#1#0|))
)))
(assert (forall ((|a#21#0#0| T@U) (|a#21#1#0| T@U) ) (!  (=> (and (= (type |a#21#0#0|) BoxType) (= (type |a#21#1#0|) BoxType)) (= (_System.Tuple2OLL._1 (|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|)) |a#21#1#0|))
 :qid |unknown.0:0|
 :skolemid |1144|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#21#0#0| |a#21#1#0|))
)))
(assert (forall ((|a#22#0#0| T@U) (|a#22#1#0| T@U) ) (!  (=> (and (= (type |a#22#0#0|) BoxType) (= (type |a#22#1#0|) BoxType)) (< (BoxRank |a#22#1#0|) (DtRank (|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))))
 :qid |unknown.0:0|
 :skolemid |1145|
 :pattern ( (|#_System._tuple#2OLL._#Make2| |a#22#0#0| |a#22#1#0|))
)))
(assert (forall ((d@@14 T@U) ) (!  (=> (and (= (type d@@14) DatatypeTypeType) (|$IsA#_System.Tuple2OLL| d@@14)) (_System.Tuple2OLL.___hMake2_q d@@14))
 :qid |unknown.0:0|
 :skolemid |1146|
 :pattern ( (|$IsA#_System.Tuple2OLL| d@@14))
)))
(assert (forall ((|_System._tuple#2OLL$T0@@7| T@U) (|_System._tuple#2OLL$T1@@7| T@U) (d@@15 T@U) ) (!  (=> (and (and (and (= (type |_System._tuple#2OLL$T0@@7|) TyType) (= (type |_System._tuple#2OLL$T1@@7|) TyType)) (= (type d@@15) DatatypeTypeType)) ($Is d@@15 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@7| |_System._tuple#2OLL$T1@@7|))) (_System.Tuple2OLL.___hMake2_q d@@15))
 :qid |unknown.0:0|
 :skolemid |1147|
 :pattern ( (_System.Tuple2OLL.___hMake2_q d@@15) ($Is d@@15 (Tclass._System.Tuple2OLL |_System._tuple#2OLL$T0@@7| |_System._tuple#2OLL$T1@@7|)))
)))
(assert (forall ((a@@116 T@U) (b@@65 T@U) ) (!  (=> (and (and (= (type a@@116) DatatypeTypeType) (= (type b@@65) DatatypeTypeType)) true) (= (|_System.Tuple2OLL#Equal| a@@116 b@@65)  (and (= (_System.Tuple2OLL._0 a@@116) (_System.Tuple2OLL._0 b@@65)) (= (_System.Tuple2OLL._1 a@@116) (_System.Tuple2OLL._1 b@@65)))))
 :qid |unknown.0:0|
 :skolemid |1148|
 :pattern ( (|_System.Tuple2OLL#Equal| a@@116 b@@65))
)))
(assert (forall ((a@@117 T@U) (b@@66 T@U) ) (!  (=> (and (= (type a@@117) DatatypeTypeType) (= (type b@@66) DatatypeTypeType)) (= (|_System.Tuple2OLL#Equal| a@@117 b@@66) (= a@@117 b@@66)))
 :qid |unknown.0:0|
 :skolemid |1149|
 :pattern ( (|_System.Tuple2OLL#Equal| a@@117 b@@66))
)))
(assert (forall ((arg0@@304 T@U) (arg1@@129 T@U) (arg2@@70 T@U) (arg3@@42 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL arg0@@304 arg1@@129 arg2@@70 arg3@@42)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL|
 :pattern ( (Tclass._System.___hFunc3LLOL arg0@@304 arg1@@129 arg2@@70 arg3@@42))
)))
(assert (forall ((|#$T0@@189| T@U) (|#$T1@@125| T@U) (|#$T2@@68| T@U) (|#$R@@215| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@189|) TyType) (= (type |#$T1@@125|) TyType)) (= (type |#$T2@@68|) TyType)) (= (type |#$R@@215|) TyType)) (and (= (Tag (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|)) Tagclass._System.___hFunc3LLOL) (= (TagFamily (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|)) |tytagFamily$_#Func3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1150|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@189| |#$T1@@125| |#$T2@@68| |#$R@@215|))
)))
(assert (forall ((arg0@@305 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_0 arg0@@305)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_0|
 :pattern ( (Tclass._System.___hFunc3LLOL_0 arg0@@305))
)))
(assert (forall ((|#$T0@@190| T@U) (|#$T1@@126| T@U) (|#$T2@@69| T@U) (|#$R@@216| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@190|) TyType) (= (type |#$T1@@126|) TyType)) (= (type |#$T2@@69|) TyType)) (= (type |#$R@@216|) TyType)) (= (Tclass._System.___hFunc3LLOL_0 (Tclass._System.___hFunc3LLOL |#$T0@@190| |#$T1@@126| |#$T2@@69| |#$R@@216|)) |#$T0@@190|))
 :qid |unknown.0:0|
 :skolemid |1151|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@190| |#$T1@@126| |#$T2@@69| |#$R@@216|))
)))
(assert (forall ((arg0@@306 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_1 arg0@@306)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_1|
 :pattern ( (Tclass._System.___hFunc3LLOL_1 arg0@@306))
)))
(assert (forall ((|#$T0@@191| T@U) (|#$T1@@127| T@U) (|#$T2@@70| T@U) (|#$R@@217| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@191|) TyType) (= (type |#$T1@@127|) TyType)) (= (type |#$T2@@70|) TyType)) (= (type |#$R@@217|) TyType)) (= (Tclass._System.___hFunc3LLOL_1 (Tclass._System.___hFunc3LLOL |#$T0@@191| |#$T1@@127| |#$T2@@70| |#$R@@217|)) |#$T1@@127|))
 :qid |unknown.0:0|
 :skolemid |1152|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@191| |#$T1@@127| |#$T2@@70| |#$R@@217|))
)))
(assert (forall ((arg0@@307 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_2 arg0@@307)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_2|
 :pattern ( (Tclass._System.___hFunc3LLOL_2 arg0@@307))
)))
(assert (forall ((|#$T0@@192| T@U) (|#$T1@@128| T@U) (|#$T2@@71| T@U) (|#$R@@218| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@192|) TyType) (= (type |#$T1@@128|) TyType)) (= (type |#$T2@@71|) TyType)) (= (type |#$R@@218|) TyType)) (= (Tclass._System.___hFunc3LLOL_2 (Tclass._System.___hFunc3LLOL |#$T0@@192| |#$T1@@128| |#$T2@@71| |#$R@@218|)) |#$T2@@71|))
 :qid |unknown.0:0|
 :skolemid |1153|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@192| |#$T1@@128| |#$T2@@71| |#$R@@218|))
)))
(assert (forall ((arg0@@308 T@U) ) (! (= (type (Tclass._System.___hFunc3LLOL_3 arg0@@308)) TyType)
 :qid |funType:Tclass._System.___hFunc3LLOL_3|
 :pattern ( (Tclass._System.___hFunc3LLOL_3 arg0@@308))
)))
(assert (forall ((|#$T0@@193| T@U) (|#$T1@@129| T@U) (|#$T2@@72| T@U) (|#$R@@219| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@193|) TyType) (= (type |#$T1@@129|) TyType)) (= (type |#$T2@@72|) TyType)) (= (type |#$R@@219|) TyType)) (= (Tclass._System.___hFunc3LLOL_3 (Tclass._System.___hFunc3LLOL |#$T0@@193| |#$T1@@129| |#$T2@@72| |#$R@@219|)) |#$R@@219|))
 :qid |unknown.0:0|
 :skolemid |1154|
 :pattern ( (Tclass._System.___hFunc3LLOL |#$T0@@193| |#$T1@@129| |#$T2@@72| |#$R@@219|))
)))
(assert (forall ((|#$T0@@194| T@U) (|#$T1@@130| T@U) (|#$T2@@73| T@U) (|#$R@@220| T@U) (bx@@91 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@194|) TyType) (= (type |#$T1@@130|) TyType)) (= (type |#$T2@@73|) TyType)) (= (type |#$R@@220|) TyType)) (= (type bx@@91) BoxType)) ($IsBox bx@@91 (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|))) (and (= ($Box ($Unbox HandleTypeType bx@@91)) bx@@91) ($Is ($Unbox HandleTypeType bx@@91) (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|))))
 :qid |unknown.0:0|
 :skolemid |1155|
 :pattern ( ($IsBox bx@@91 (Tclass._System.___hFunc3LLOL |#$T0@@194| |#$T1@@130| |#$T2@@73| |#$R@@220|)))
)))
(assert (forall ((arg0@@309 T@U) (arg1@@130 T@U) (arg2@@71 T@U) (arg3@@43 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL arg0@@309 arg1@@130 arg2@@71 arg3@@43)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL arg0@@309 arg1@@130 arg2@@71 arg3@@43))
)))
(assert (forall ((|#$T0@@195| T@U) (|#$T1@@131| T@U) (|#$T2@@74| T@U) (|#$R@@221| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@195|) TyType) (= (type |#$T1@@131|) TyType)) (= (type |#$T2@@74|) TyType)) (= (type |#$R@@221|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|)) Tagclass._System.___hPartialFunc3LLOL) (= (TagFamily (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|)) |tytagFamily$_#PartialFunc3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1156|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@195| |#$T1@@131| |#$T2@@74| |#$R@@221|))
)))
(assert (forall ((arg0@@310 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_0 arg0@@310)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_0|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_0 arg0@@310))
)))
(assert (forall ((|#$T0@@196| T@U) (|#$T1@@132| T@U) (|#$T2@@75| T@U) (|#$R@@222| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@196|) TyType) (= (type |#$T1@@132|) TyType)) (= (type |#$T2@@75|) TyType)) (= (type |#$R@@222|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_0 (Tclass._System.___hPartialFunc3LLOL |#$T0@@196| |#$T1@@132| |#$T2@@75| |#$R@@222|)) |#$T0@@196|))
 :qid |unknown.0:0|
 :skolemid |1157|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@196| |#$T1@@132| |#$T2@@75| |#$R@@222|))
)))
(assert (forall ((arg0@@311 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_1 arg0@@311)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_1|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_1 arg0@@311))
)))
(assert (forall ((|#$T0@@197| T@U) (|#$T1@@133| T@U) (|#$T2@@76| T@U) (|#$R@@223| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@197|) TyType) (= (type |#$T1@@133|) TyType)) (= (type |#$T2@@76|) TyType)) (= (type |#$R@@223|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_1 (Tclass._System.___hPartialFunc3LLOL |#$T0@@197| |#$T1@@133| |#$T2@@76| |#$R@@223|)) |#$T1@@133|))
 :qid |unknown.0:0|
 :skolemid |1158|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@197| |#$T1@@133| |#$T2@@76| |#$R@@223|))
)))
(assert (forall ((arg0@@312 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_2 arg0@@312)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_2|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_2 arg0@@312))
)))
(assert (forall ((|#$T0@@198| T@U) (|#$T1@@134| T@U) (|#$T2@@77| T@U) (|#$R@@224| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@198|) TyType) (= (type |#$T1@@134|) TyType)) (= (type |#$T2@@77|) TyType)) (= (type |#$R@@224|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_2 (Tclass._System.___hPartialFunc3LLOL |#$T0@@198| |#$T1@@134| |#$T2@@77| |#$R@@224|)) |#$T2@@77|))
 :qid |unknown.0:0|
 :skolemid |1159|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@198| |#$T1@@134| |#$T2@@77| |#$R@@224|))
)))
(assert (forall ((arg0@@313 T@U) ) (! (= (type (Tclass._System.___hPartialFunc3LLOL_3 arg0@@313)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc3LLOL_3|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL_3 arg0@@313))
)))
(assert (forall ((|#$T0@@199| T@U) (|#$T1@@135| T@U) (|#$T2@@78| T@U) (|#$R@@225| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@199|) TyType) (= (type |#$T1@@135|) TyType)) (= (type |#$T2@@78|) TyType)) (= (type |#$R@@225|) TyType)) (= (Tclass._System.___hPartialFunc3LLOL_3 (Tclass._System.___hPartialFunc3LLOL |#$T0@@199| |#$T1@@135| |#$T2@@78| |#$R@@225|)) |#$R@@225|))
 :qid |unknown.0:0|
 :skolemid |1160|
 :pattern ( (Tclass._System.___hPartialFunc3LLOL |#$T0@@199| |#$T1@@135| |#$T2@@78| |#$R@@225|))
)))
(assert (forall ((|#$T0@@200| T@U) (|#$T1@@136| T@U) (|#$T2@@79| T@U) (|#$R@@226| T@U) (bx@@92 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@200|) TyType) (= (type |#$T1@@136|) TyType)) (= (type |#$T2@@79|) TyType)) (= (type |#$R@@226|) TyType)) (= (type bx@@92) BoxType)) ($IsBox bx@@92 (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|))) (and (= ($Box ($Unbox HandleTypeType bx@@92)) bx@@92) ($Is ($Unbox HandleTypeType bx@@92) (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|))))
 :qid |unknown.0:0|
 :skolemid |1161|
 :pattern ( ($IsBox bx@@92 (Tclass._System.___hPartialFunc3LLOL |#$T0@@200| |#$T1@@136| |#$T2@@79| |#$R@@226|)))
)))
(assert (forall ((|#$T0@@201| T@U) (|#$T1@@137| T@U) (|#$T2@@80| T@U) (|#$R@@227| T@U) (|f#0@@47| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@201|) TyType) (= (type |#$T1@@137|) TyType)) (= (type |#$T2@@80|) TyType)) (= (type |#$R@@227|) TyType)) (= (type |f#0@@47|) HandleTypeType)) (= ($Is |f#0@@47| (Tclass._System.___hPartialFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|))  (and ($Is |f#0@@47| (Tclass._System.___hFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|)) (forall ((|x0#0@@19| T@U) (|x1#0@@11| T@U) (|x2#0@@5| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@19|) BoxType) (= (type |x1#0@@11|) BoxType)) (= (type |x2#0@@5|) BoxType)) (and (and ($IsBox |x0#0@@19| |#$T0@@201|) ($IsBox |x1#0@@11| |#$T1@@137|)) ($IsBox |x2#0@@5| |#$T2@@80|))) (|Set#Equal| (Reads3 |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227| $OneHeap |f#0@@47| |x0#0@@19| |x1#0@@11| |x2#0@@5|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1162|
 :no-pattern (type |x0#0@@19|)
 :no-pattern (type |x1#0@@11|)
 :no-pattern (type |x2#0@@5|)
 :no-pattern (U_2_int |x0#0@@19|)
 :no-pattern (U_2_bool |x0#0@@19|)
 :no-pattern (U_2_int |x1#0@@11|)
 :no-pattern (U_2_bool |x1#0@@11|)
 :no-pattern (U_2_int |x2#0@@5|)
 :no-pattern (U_2_bool |x2#0@@5|)
)))))
 :qid |unknown.0:0|
 :skolemid |1163|
 :pattern ( ($Is |f#0@@47| (Tclass._System.___hPartialFunc3LLOL |#$T0@@201| |#$T1@@137| |#$T2@@80| |#$R@@227|)))
)))
(assert (forall ((|#$T0@@202| T@U) (|#$T1@@138| T@U) (|#$T2@@81| T@U) (|#$R@@228| T@U) (|f#0@@48| T@U) ($h@@39 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@202|) TyType) (= (type |#$T1@@138|) TyType)) (= (type |#$T2@@81|) TyType)) (= (type |#$R@@228|) TyType)) (= (type |f#0@@48|) HandleTypeType)) (= (type $h@@39) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@48| (Tclass._System.___hPartialFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39) ($IsAlloc |f#0@@48| (Tclass._System.___hFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39)))
 :qid |unknown.0:0|
 :skolemid |1164|
 :pattern ( ($IsAlloc |f#0@@48| (Tclass._System.___hPartialFunc3LLOL |#$T0@@202| |#$T1@@138| |#$T2@@81| |#$R@@228|) $h@@39))
)))
(assert (forall ((arg0@@314 T@U) (arg1@@131 T@U) (arg2@@72 T@U) (arg3@@44 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL arg0@@314 arg1@@131 arg2@@72 arg3@@44)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL arg0@@314 arg1@@131 arg2@@72 arg3@@44))
)))
(assert (forall ((|#$T0@@203| T@U) (|#$T1@@139| T@U) (|#$T2@@82| T@U) (|#$R@@229| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@203|) TyType) (= (type |#$T1@@139|) TyType)) (= (type |#$T2@@82|) TyType)) (= (type |#$R@@229|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|)) Tagclass._System.___hTotalFunc3LLOL) (= (TagFamily (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|)) |tytagFamily$_#TotalFunc3LLOL|)))
 :qid |unknown.0:0|
 :skolemid |1165|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@203| |#$T1@@139| |#$T2@@82| |#$R@@229|))
)))
(assert (forall ((arg0@@315 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_0 arg0@@315)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_0|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_0 arg0@@315))
)))
(assert (forall ((|#$T0@@204| T@U) (|#$T1@@140| T@U) (|#$T2@@83| T@U) (|#$R@@230| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@204|) TyType) (= (type |#$T1@@140|) TyType)) (= (type |#$T2@@83|) TyType)) (= (type |#$R@@230|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_0 (Tclass._System.___hTotalFunc3LLOL |#$T0@@204| |#$T1@@140| |#$T2@@83| |#$R@@230|)) |#$T0@@204|))
 :qid |unknown.0:0|
 :skolemid |1166|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@204| |#$T1@@140| |#$T2@@83| |#$R@@230|))
)))
(assert (forall ((arg0@@316 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_1 arg0@@316)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_1|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_1 arg0@@316))
)))
(assert (forall ((|#$T0@@205| T@U) (|#$T1@@141| T@U) (|#$T2@@84| T@U) (|#$R@@231| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@205|) TyType) (= (type |#$T1@@141|) TyType)) (= (type |#$T2@@84|) TyType)) (= (type |#$R@@231|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_1 (Tclass._System.___hTotalFunc3LLOL |#$T0@@205| |#$T1@@141| |#$T2@@84| |#$R@@231|)) |#$T1@@141|))
 :qid |unknown.0:0|
 :skolemid |1167|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@205| |#$T1@@141| |#$T2@@84| |#$R@@231|))
)))
(assert (forall ((arg0@@317 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_2 arg0@@317)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_2|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_2 arg0@@317))
)))
(assert (forall ((|#$T0@@206| T@U) (|#$T1@@142| T@U) (|#$T2@@85| T@U) (|#$R@@232| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@206|) TyType) (= (type |#$T1@@142|) TyType)) (= (type |#$T2@@85|) TyType)) (= (type |#$R@@232|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_2 (Tclass._System.___hTotalFunc3LLOL |#$T0@@206| |#$T1@@142| |#$T2@@85| |#$R@@232|)) |#$T2@@85|))
 :qid |unknown.0:0|
 :skolemid |1168|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@206| |#$T1@@142| |#$T2@@85| |#$R@@232|))
)))
(assert (forall ((arg0@@318 T@U) ) (! (= (type (Tclass._System.___hTotalFunc3LLOL_3 arg0@@318)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc3LLOL_3|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL_3 arg0@@318))
)))
(assert (forall ((|#$T0@@207| T@U) (|#$T1@@143| T@U) (|#$T2@@86| T@U) (|#$R@@233| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@207|) TyType) (= (type |#$T1@@143|) TyType)) (= (type |#$T2@@86|) TyType)) (= (type |#$R@@233|) TyType)) (= (Tclass._System.___hTotalFunc3LLOL_3 (Tclass._System.___hTotalFunc3LLOL |#$T0@@207| |#$T1@@143| |#$T2@@86| |#$R@@233|)) |#$R@@233|))
 :qid |unknown.0:0|
 :skolemid |1169|
 :pattern ( (Tclass._System.___hTotalFunc3LLOL |#$T0@@207| |#$T1@@143| |#$T2@@86| |#$R@@233|))
)))
(assert (forall ((|#$T0@@208| T@U) (|#$T1@@144| T@U) (|#$T2@@87| T@U) (|#$R@@234| T@U) (bx@@93 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@208|) TyType) (= (type |#$T1@@144|) TyType)) (= (type |#$T2@@87|) TyType)) (= (type |#$R@@234|) TyType)) (= (type bx@@93) BoxType)) ($IsBox bx@@93 (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|))) (and (= ($Box ($Unbox HandleTypeType bx@@93)) bx@@93) ($Is ($Unbox HandleTypeType bx@@93) (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|))))
 :qid |unknown.0:0|
 :skolemid |1170|
 :pattern ( ($IsBox bx@@93 (Tclass._System.___hTotalFunc3LLOL |#$T0@@208| |#$T1@@144| |#$T2@@87| |#$R@@234|)))
)))
(assert (forall ((|#$T0@@209| T@U) (|#$T1@@145| T@U) (|#$T2@@88| T@U) (|#$R@@235| T@U) (|f#0@@49| T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@209|) TyType) (= (type |#$T1@@145|) TyType)) (= (type |#$T2@@88|) TyType)) (= (type |#$R@@235|) TyType)) (= (type |f#0@@49|) HandleTypeType)) (= ($Is |f#0@@49| (Tclass._System.___hTotalFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|))  (and ($Is |f#0@@49| (Tclass._System.___hPartialFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|)) (forall ((|x0#0@@20| T@U) (|x1#0@@12| T@U) (|x2#0@@6| T@U) ) (!  (=> (and (and (and (= (type |x0#0@@20|) BoxType) (= (type |x1#0@@12|) BoxType)) (= (type |x2#0@@6|) BoxType)) (and (and ($IsBox |x0#0@@20| |#$T0@@209|) ($IsBox |x1#0@@12| |#$T1@@145|)) ($IsBox |x2#0@@6| |#$T2@@88|))) (Requires3 |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235| $OneHeap |f#0@@49| |x0#0@@20| |x1#0@@12| |x2#0@@6|))
 :qid |unknown.0:0|
 :skolemid |1171|
 :no-pattern (type |x0#0@@20|)
 :no-pattern (type |x1#0@@12|)
 :no-pattern (type |x2#0@@6|)
 :no-pattern (U_2_int |x0#0@@20|)
 :no-pattern (U_2_bool |x0#0@@20|)
 :no-pattern (U_2_int |x1#0@@12|)
 :no-pattern (U_2_bool |x1#0@@12|)
 :no-pattern (U_2_int |x2#0@@6|)
 :no-pattern (U_2_bool |x2#0@@6|)
)))))
 :qid |unknown.0:0|
 :skolemid |1172|
 :pattern ( ($Is |f#0@@49| (Tclass._System.___hTotalFunc3LLOL |#$T0@@209| |#$T1@@145| |#$T2@@88| |#$R@@235|)))
)))
(assert (forall ((|#$T0@@210| T@U) (|#$T1@@146| T@U) (|#$T2@@89| T@U) (|#$R@@236| T@U) (|f#0@@50| T@U) ($h@@40 T@U) ) (!  (=> (and (and (and (and (and (= (type |#$T0@@210|) TyType) (= (type |#$T1@@146|) TyType)) (= (type |#$T2@@89|) TyType)) (= (type |#$R@@236|) TyType)) (= (type |f#0@@50|) HandleTypeType)) (= (type $h@@40) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@50| (Tclass._System.___hTotalFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40) ($IsAlloc |f#0@@50| (Tclass._System.___hPartialFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40)))
 :qid |unknown.0:0|
 :skolemid |1173|
 :pattern ( ($IsAlloc |f#0@@50| (Tclass._System.___hTotalFunc3LLOL |#$T0@@210| |#$T1@@146| |#$T2@@89| |#$R@@236|) $h@@40))
)))
(assert (forall ((arg0@@319 T@U) (arg1@@132 T@U) (arg2@@73 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO|
 :pattern ( (Tclass._System.___hFunc2SSO arg0@@319 arg1@@132 arg2@@73))
)))
(assert (forall ((|#$T0@@211| T@U) (|#$T1@@147| T@U) (|#$R@@237| T@U) ) (!  (=> (and (and (= (type |#$T0@@211|) TyType) (= (type |#$T1@@147|) TyType)) (= (type |#$R@@237|) TyType)) (and (= (Tag (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|)) Tagclass._System.___hFunc2SSO) (= (TagFamily (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|)) |tytagFamily$_#Func2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1174|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@211| |#$T1@@147| |#$R@@237|))
)))
(assert (forall ((arg0@@320 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_0 arg0@@320)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_0|
 :pattern ( (Tclass._System.___hFunc2SSO_0 arg0@@320))
)))
(assert (forall ((|#$T0@@212| T@U) (|#$T1@@148| T@U) (|#$R@@238| T@U) ) (!  (=> (and (and (= (type |#$T0@@212|) TyType) (= (type |#$T1@@148|) TyType)) (= (type |#$R@@238|) TyType)) (= (Tclass._System.___hFunc2SSO_0 (Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|)) |#$T0@@212|))
 :qid |unknown.0:0|
 :skolemid |1175|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@212| |#$T1@@148| |#$R@@238|))
)))
(assert (forall ((arg0@@321 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_1 arg0@@321)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_1|
 :pattern ( (Tclass._System.___hFunc2SSO_1 arg0@@321))
)))
(assert (forall ((|#$T0@@213| T@U) (|#$T1@@149| T@U) (|#$R@@239| T@U) ) (!  (=> (and (and (= (type |#$T0@@213|) TyType) (= (type |#$T1@@149|) TyType)) (= (type |#$R@@239|) TyType)) (= (Tclass._System.___hFunc2SSO_1 (Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|)) |#$T1@@149|))
 :qid |unknown.0:0|
 :skolemid |1176|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@213| |#$T1@@149| |#$R@@239|))
)))
(assert (forall ((arg0@@322 T@U) ) (! (= (type (Tclass._System.___hFunc2SSO_2 arg0@@322)) TyType)
 :qid |funType:Tclass._System.___hFunc2SSO_2|
 :pattern ( (Tclass._System.___hFunc2SSO_2 arg0@@322))
)))
(assert (forall ((|#$T0@@214| T@U) (|#$T1@@150| T@U) (|#$R@@240| T@U) ) (!  (=> (and (and (= (type |#$T0@@214|) TyType) (= (type |#$T1@@150|) TyType)) (= (type |#$R@@240|) TyType)) (= (Tclass._System.___hFunc2SSO_2 (Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|)) |#$R@@240|))
 :qid |unknown.0:0|
 :skolemid |1177|
 :pattern ( (Tclass._System.___hFunc2SSO |#$T0@@214| |#$T1@@150| |#$R@@240|))
)))
(assert (forall ((|#$T0@@215| T@U) (|#$T1@@151| T@U) (|#$R@@241| T@U) (bx@@94 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@215|) TyType) (= (type |#$T1@@151|) TyType)) (= (type |#$R@@241|) TyType)) (= (type bx@@94) BoxType)) ($IsBox bx@@94 (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|))) (and (= ($Box ($Unbox HandleTypeType bx@@94)) bx@@94) ($Is ($Unbox HandleTypeType bx@@94) (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|))))
 :qid |unknown.0:0|
 :skolemid |1178|
 :pattern ( ($IsBox bx@@94 (Tclass._System.___hFunc2SSO |#$T0@@215| |#$T1@@151| |#$R@@241|)))
)))
(assert (forall ((arg0@@323 T@U) (arg1@@133 T@U) (arg2@@74 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO|
 :pattern ( (Tclass._System.___hPartialFunc2SSO arg0@@323 arg1@@133 arg2@@74))
)))
(assert (forall ((|#$T0@@216| T@U) (|#$T1@@152| T@U) (|#$R@@242| T@U) ) (!  (=> (and (and (= (type |#$T0@@216|) TyType) (= (type |#$T1@@152|) TyType)) (= (type |#$R@@242|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|)) Tagclass._System.___hPartialFunc2SSO) (= (TagFamily (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|)) |tytagFamily$_#PartialFunc2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1179|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@216| |#$T1@@152| |#$R@@242|))
)))
(assert (forall ((arg0@@324 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_0 arg0@@324)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_0|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_0 arg0@@324))
)))
(assert (forall ((|#$T0@@217| T@U) (|#$T1@@153| T@U) (|#$R@@243| T@U) ) (!  (=> (and (and (= (type |#$T0@@217|) TyType) (= (type |#$T1@@153|) TyType)) (= (type |#$R@@243|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_0 (Tclass._System.___hPartialFunc2SSO |#$T0@@217| |#$T1@@153| |#$R@@243|)) |#$T0@@217|))
 :qid |unknown.0:0|
 :skolemid |1180|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@217| |#$T1@@153| |#$R@@243|))
)))
(assert (forall ((arg0@@325 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_1 arg0@@325)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_1|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_1 arg0@@325))
)))
(assert (forall ((|#$T0@@218| T@U) (|#$T1@@154| T@U) (|#$R@@244| T@U) ) (!  (=> (and (and (= (type |#$T0@@218|) TyType) (= (type |#$T1@@154|) TyType)) (= (type |#$R@@244|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_1 (Tclass._System.___hPartialFunc2SSO |#$T0@@218| |#$T1@@154| |#$R@@244|)) |#$T1@@154|))
 :qid |unknown.0:0|
 :skolemid |1181|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@218| |#$T1@@154| |#$R@@244|))
)))
(assert (forall ((arg0@@326 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2SSO_2 arg0@@326)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2SSO_2|
 :pattern ( (Tclass._System.___hPartialFunc2SSO_2 arg0@@326))
)))
(assert (forall ((|#$T0@@219| T@U) (|#$T1@@155| T@U) (|#$R@@245| T@U) ) (!  (=> (and (and (= (type |#$T0@@219|) TyType) (= (type |#$T1@@155|) TyType)) (= (type |#$R@@245|) TyType)) (= (Tclass._System.___hPartialFunc2SSO_2 (Tclass._System.___hPartialFunc2SSO |#$T0@@219| |#$T1@@155| |#$R@@245|)) |#$R@@245|))
 :qid |unknown.0:0|
 :skolemid |1182|
 :pattern ( (Tclass._System.___hPartialFunc2SSO |#$T0@@219| |#$T1@@155| |#$R@@245|))
)))
(assert (forall ((|#$T0@@220| T@U) (|#$T1@@156| T@U) (|#$R@@246| T@U) (bx@@95 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@220|) TyType) (= (type |#$T1@@156|) TyType)) (= (type |#$R@@246|) TyType)) (= (type bx@@95) BoxType)) ($IsBox bx@@95 (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|))) (and (= ($Box ($Unbox HandleTypeType bx@@95)) bx@@95) ($Is ($Unbox HandleTypeType bx@@95) (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|))))
 :qid |unknown.0:0|
 :skolemid |1183|
 :pattern ( ($IsBox bx@@95 (Tclass._System.___hPartialFunc2SSO |#$T0@@220| |#$T1@@156| |#$R@@246|)))
)))
(assert (forall ((|#$T0@@221| T@U) (|#$T1@@157| T@U) (|#$R@@247| T@U) (|f#0@@51| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@221|) TyType) (= (type |#$T1@@157|) TyType)) (= (type |#$R@@247|) TyType)) (= (type |f#0@@51|) HandleTypeType)) (= ($Is |f#0@@51| (Tclass._System.___hPartialFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|))  (and ($Is |f#0@@51| (Tclass._System.___hFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|)) (forall ((|x0#0@@21| T@U) (|x1#0@@13| T@U) ) (!  (=> (and (and (= (type |x0#0@@21|) BoxType) (= (type |x1#0@@13|) BoxType)) (and ($IsBox |x0#0@@21| |#$T0@@221|) ($IsBox |x1#0@@13| |#$T1@@157|))) (|Set#Equal| (Reads2 |#$T0@@221| |#$T1@@157| |#$R@@247| $OneHeap |f#0@@51| |x0#0@@21| |x1#0@@13|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1184|
 :no-pattern (type |x0#0@@21|)
 :no-pattern (type |x1#0@@13|)
 :no-pattern (U_2_int |x0#0@@21|)
 :no-pattern (U_2_bool |x0#0@@21|)
 :no-pattern (U_2_int |x1#0@@13|)
 :no-pattern (U_2_bool |x1#0@@13|)
)))))
 :qid |unknown.0:0|
 :skolemid |1185|
 :pattern ( ($Is |f#0@@51| (Tclass._System.___hPartialFunc2SSO |#$T0@@221| |#$T1@@157| |#$R@@247|)))
)))
(assert (forall ((|#$T0@@222| T@U) (|#$T1@@158| T@U) (|#$R@@248| T@U) (|f#0@@52| T@U) ($h@@41 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@222|) TyType) (= (type |#$T1@@158|) TyType)) (= (type |#$R@@248|) TyType)) (= (type |f#0@@52|) HandleTypeType)) (= (type $h@@41) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@52| (Tclass._System.___hPartialFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41) ($IsAlloc |f#0@@52| (Tclass._System.___hFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41)))
 :qid |unknown.0:0|
 :skolemid |1186|
 :pattern ( ($IsAlloc |f#0@@52| (Tclass._System.___hPartialFunc2SSO |#$T0@@222| |#$T1@@158| |#$R@@248|) $h@@41))
)))
(assert (forall ((arg0@@327 T@U) (arg1@@134 T@U) (arg2@@75 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO|
 :pattern ( (Tclass._System.___hTotalFunc2SSO arg0@@327 arg1@@134 arg2@@75))
)))
(assert (forall ((|#$T0@@223| T@U) (|#$T1@@159| T@U) (|#$R@@249| T@U) ) (!  (=> (and (and (= (type |#$T0@@223|) TyType) (= (type |#$T1@@159|) TyType)) (= (type |#$R@@249|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|)) Tagclass._System.___hTotalFunc2SSO) (= (TagFamily (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|)) |tytagFamily$_#TotalFunc2SSO|)))
 :qid |unknown.0:0|
 :skolemid |1187|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@223| |#$T1@@159| |#$R@@249|))
)))
(assert (forall ((arg0@@328 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_0 arg0@@328)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_0|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_0 arg0@@328))
)))
(assert (forall ((|#$T0@@224| T@U) (|#$T1@@160| T@U) (|#$R@@250| T@U) ) (!  (=> (and (and (= (type |#$T0@@224|) TyType) (= (type |#$T1@@160|) TyType)) (= (type |#$R@@250|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_0 (Tclass._System.___hTotalFunc2SSO |#$T0@@224| |#$T1@@160| |#$R@@250|)) |#$T0@@224|))
 :qid |unknown.0:0|
 :skolemid |1188|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@224| |#$T1@@160| |#$R@@250|))
)))
(assert (forall ((arg0@@329 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_1 arg0@@329)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_1|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_1 arg0@@329))
)))
(assert (forall ((|#$T0@@225| T@U) (|#$T1@@161| T@U) (|#$R@@251| T@U) ) (!  (=> (and (and (= (type |#$T0@@225|) TyType) (= (type |#$T1@@161|) TyType)) (= (type |#$R@@251|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_1 (Tclass._System.___hTotalFunc2SSO |#$T0@@225| |#$T1@@161| |#$R@@251|)) |#$T1@@161|))
 :qid |unknown.0:0|
 :skolemid |1189|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@225| |#$T1@@161| |#$R@@251|))
)))
(assert (forall ((arg0@@330 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2SSO_2 arg0@@330)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2SSO_2|
 :pattern ( (Tclass._System.___hTotalFunc2SSO_2 arg0@@330))
)))
(assert (forall ((|#$T0@@226| T@U) (|#$T1@@162| T@U) (|#$R@@252| T@U) ) (!  (=> (and (and (= (type |#$T0@@226|) TyType) (= (type |#$T1@@162|) TyType)) (= (type |#$R@@252|) TyType)) (= (Tclass._System.___hTotalFunc2SSO_2 (Tclass._System.___hTotalFunc2SSO |#$T0@@226| |#$T1@@162| |#$R@@252|)) |#$R@@252|))
 :qid |unknown.0:0|
 :skolemid |1190|
 :pattern ( (Tclass._System.___hTotalFunc2SSO |#$T0@@226| |#$T1@@162| |#$R@@252|))
)))
(assert (forall ((|#$T0@@227| T@U) (|#$T1@@163| T@U) (|#$R@@253| T@U) (bx@@96 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@227|) TyType) (= (type |#$T1@@163|) TyType)) (= (type |#$R@@253|) TyType)) (= (type bx@@96) BoxType)) ($IsBox bx@@96 (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|))) (and (= ($Box ($Unbox HandleTypeType bx@@96)) bx@@96) ($Is ($Unbox HandleTypeType bx@@96) (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|))))
 :qid |unknown.0:0|
 :skolemid |1191|
 :pattern ( ($IsBox bx@@96 (Tclass._System.___hTotalFunc2SSO |#$T0@@227| |#$T1@@163| |#$R@@253|)))
)))
(assert (forall ((|#$T0@@228| T@U) (|#$T1@@164| T@U) (|#$R@@254| T@U) (|f#0@@53| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@228|) TyType) (= (type |#$T1@@164|) TyType)) (= (type |#$R@@254|) TyType)) (= (type |f#0@@53|) HandleTypeType)) (= ($Is |f#0@@53| (Tclass._System.___hTotalFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|))  (and ($Is |f#0@@53| (Tclass._System.___hPartialFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|)) (forall ((|x0#0@@22| T@U) (|x1#0@@14| T@U) ) (!  (=> (and (and (= (type |x0#0@@22|) BoxType) (= (type |x1#0@@14|) BoxType)) (and ($IsBox |x0#0@@22| |#$T0@@228|) ($IsBox |x1#0@@14| |#$T1@@164|))) (Requires2 |#$T0@@228| |#$T1@@164| |#$R@@254| $OneHeap |f#0@@53| |x0#0@@22| |x1#0@@14|))
 :qid |unknown.0:0|
 :skolemid |1192|
 :no-pattern (type |x0#0@@22|)
 :no-pattern (type |x1#0@@14|)
 :no-pattern (U_2_int |x0#0@@22|)
 :no-pattern (U_2_bool |x0#0@@22|)
 :no-pattern (U_2_int |x1#0@@14|)
 :no-pattern (U_2_bool |x1#0@@14|)
)))))
 :qid |unknown.0:0|
 :skolemid |1193|
 :pattern ( ($Is |f#0@@53| (Tclass._System.___hTotalFunc2SSO |#$T0@@228| |#$T1@@164| |#$R@@254|)))
)))
(assert (forall ((|#$T0@@229| T@U) (|#$T1@@165| T@U) (|#$R@@255| T@U) (|f#0@@54| T@U) ($h@@42 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@229|) TyType) (= (type |#$T1@@165|) TyType)) (= (type |#$R@@255|) TyType)) (= (type |f#0@@54|) HandleTypeType)) (= (type $h@@42) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@54| (Tclass._System.___hTotalFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42) ($IsAlloc |f#0@@54| (Tclass._System.___hPartialFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42)))
 :qid |unknown.0:0|
 :skolemid |1194|
 :pattern ( ($IsAlloc |f#0@@54| (Tclass._System.___hTotalFunc2SSO |#$T0@@229| |#$T1@@165| |#$R@@255|) $h@@42))
)))
(assert (forall ((arg0@@331 T@U) (arg1@@135 T@U) (arg2@@76 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO|
 :pattern ( (Tclass._System.___hFunc2LLO arg0@@331 arg1@@135 arg2@@76))
)))
(assert (forall ((|#$T0@@230| T@U) (|#$T1@@166| T@U) (|#$R@@256| T@U) ) (!  (=> (and (and (= (type |#$T0@@230|) TyType) (= (type |#$T1@@166|) TyType)) (= (type |#$R@@256|) TyType)) (and (= (Tag (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|)) Tagclass._System.___hFunc2LLO) (= (TagFamily (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|)) |tytagFamily$_#Func2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1195|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@230| |#$T1@@166| |#$R@@256|))
)))
(assert (forall ((arg0@@332 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_0 arg0@@332)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_0|
 :pattern ( (Tclass._System.___hFunc2LLO_0 arg0@@332))
)))
(assert (forall ((|#$T0@@231| T@U) (|#$T1@@167| T@U) (|#$R@@257| T@U) ) (!  (=> (and (and (= (type |#$T0@@231|) TyType) (= (type |#$T1@@167|) TyType)) (= (type |#$R@@257|) TyType)) (= (Tclass._System.___hFunc2LLO_0 (Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|)) |#$T0@@231|))
 :qid |unknown.0:0|
 :skolemid |1196|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@231| |#$T1@@167| |#$R@@257|))
)))
(assert (forall ((arg0@@333 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_1 arg0@@333)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_1|
 :pattern ( (Tclass._System.___hFunc2LLO_1 arg0@@333))
)))
(assert (forall ((|#$T0@@232| T@U) (|#$T1@@168| T@U) (|#$R@@258| T@U) ) (!  (=> (and (and (= (type |#$T0@@232|) TyType) (= (type |#$T1@@168|) TyType)) (= (type |#$R@@258|) TyType)) (= (Tclass._System.___hFunc2LLO_1 (Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|)) |#$T1@@168|))
 :qid |unknown.0:0|
 :skolemid |1197|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@232| |#$T1@@168| |#$R@@258|))
)))
(assert (forall ((arg0@@334 T@U) ) (! (= (type (Tclass._System.___hFunc2LLO_2 arg0@@334)) TyType)
 :qid |funType:Tclass._System.___hFunc2LLO_2|
 :pattern ( (Tclass._System.___hFunc2LLO_2 arg0@@334))
)))
(assert (forall ((|#$T0@@233| T@U) (|#$T1@@169| T@U) (|#$R@@259| T@U) ) (!  (=> (and (and (= (type |#$T0@@233|) TyType) (= (type |#$T1@@169|) TyType)) (= (type |#$R@@259|) TyType)) (= (Tclass._System.___hFunc2LLO_2 (Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|)) |#$R@@259|))
 :qid |unknown.0:0|
 :skolemid |1198|
 :pattern ( (Tclass._System.___hFunc2LLO |#$T0@@233| |#$T1@@169| |#$R@@259|))
)))
(assert (forall ((|#$T0@@234| T@U) (|#$T1@@170| T@U) (|#$R@@260| T@U) (bx@@97 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@234|) TyType) (= (type |#$T1@@170|) TyType)) (= (type |#$R@@260|) TyType)) (= (type bx@@97) BoxType)) ($IsBox bx@@97 (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|))) (and (= ($Box ($Unbox HandleTypeType bx@@97)) bx@@97) ($Is ($Unbox HandleTypeType bx@@97) (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|))))
 :qid |unknown.0:0|
 :skolemid |1199|
 :pattern ( ($IsBox bx@@97 (Tclass._System.___hFunc2LLO |#$T0@@234| |#$T1@@170| |#$R@@260|)))
)))
(assert (forall ((arg0@@335 T@U) (arg1@@136 T@U) (arg2@@77 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO|
 :pattern ( (Tclass._System.___hPartialFunc2LLO arg0@@335 arg1@@136 arg2@@77))
)))
(assert (forall ((|#$T0@@235| T@U) (|#$T1@@171| T@U) (|#$R@@261| T@U) ) (!  (=> (and (and (= (type |#$T0@@235|) TyType) (= (type |#$T1@@171|) TyType)) (= (type |#$R@@261|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|)) Tagclass._System.___hPartialFunc2LLO) (= (TagFamily (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|)) |tytagFamily$_#PartialFunc2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1200|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@235| |#$T1@@171| |#$R@@261|))
)))
(assert (forall ((arg0@@336 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_0 arg0@@336)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_0|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_0 arg0@@336))
)))
(assert (forall ((|#$T0@@236| T@U) (|#$T1@@172| T@U) (|#$R@@262| T@U) ) (!  (=> (and (and (= (type |#$T0@@236|) TyType) (= (type |#$T1@@172|) TyType)) (= (type |#$R@@262|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_0 (Tclass._System.___hPartialFunc2LLO |#$T0@@236| |#$T1@@172| |#$R@@262|)) |#$T0@@236|))
 :qid |unknown.0:0|
 :skolemid |1201|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@236| |#$T1@@172| |#$R@@262|))
)))
(assert (forall ((arg0@@337 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_1 arg0@@337)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_1|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_1 arg0@@337))
)))
(assert (forall ((|#$T0@@237| T@U) (|#$T1@@173| T@U) (|#$R@@263| T@U) ) (!  (=> (and (and (= (type |#$T0@@237|) TyType) (= (type |#$T1@@173|) TyType)) (= (type |#$R@@263|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_1 (Tclass._System.___hPartialFunc2LLO |#$T0@@237| |#$T1@@173| |#$R@@263|)) |#$T1@@173|))
 :qid |unknown.0:0|
 :skolemid |1202|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@237| |#$T1@@173| |#$R@@263|))
)))
(assert (forall ((arg0@@338 T@U) ) (! (= (type (Tclass._System.___hPartialFunc2LLO_2 arg0@@338)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc2LLO_2|
 :pattern ( (Tclass._System.___hPartialFunc2LLO_2 arg0@@338))
)))
(assert (forall ((|#$T0@@238| T@U) (|#$T1@@174| T@U) (|#$R@@264| T@U) ) (!  (=> (and (and (= (type |#$T0@@238|) TyType) (= (type |#$T1@@174|) TyType)) (= (type |#$R@@264|) TyType)) (= (Tclass._System.___hPartialFunc2LLO_2 (Tclass._System.___hPartialFunc2LLO |#$T0@@238| |#$T1@@174| |#$R@@264|)) |#$R@@264|))
 :qid |unknown.0:0|
 :skolemid |1203|
 :pattern ( (Tclass._System.___hPartialFunc2LLO |#$T0@@238| |#$T1@@174| |#$R@@264|))
)))
(assert (forall ((|#$T0@@239| T@U) (|#$T1@@175| T@U) (|#$R@@265| T@U) (bx@@98 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@239|) TyType) (= (type |#$T1@@175|) TyType)) (= (type |#$R@@265|) TyType)) (= (type bx@@98) BoxType)) ($IsBox bx@@98 (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|))) (and (= ($Box ($Unbox HandleTypeType bx@@98)) bx@@98) ($Is ($Unbox HandleTypeType bx@@98) (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|))))
 :qid |unknown.0:0|
 :skolemid |1204|
 :pattern ( ($IsBox bx@@98 (Tclass._System.___hPartialFunc2LLO |#$T0@@239| |#$T1@@175| |#$R@@265|)))
)))
(assert (forall ((|#$T0@@240| T@U) (|#$T1@@176| T@U) (|#$R@@266| T@U) (|f#0@@55| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@240|) TyType) (= (type |#$T1@@176|) TyType)) (= (type |#$R@@266|) TyType)) (= (type |f#0@@55|) HandleTypeType)) (= ($Is |f#0@@55| (Tclass._System.___hPartialFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|))  (and ($Is |f#0@@55| (Tclass._System.___hFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|)) (forall ((|x0#0@@23| T@U) (|x1#0@@15| T@U) ) (!  (=> (and (and (= (type |x0#0@@23|) BoxType) (= (type |x1#0@@15|) BoxType)) (and ($IsBox |x0#0@@23| |#$T0@@240|) ($IsBox |x1#0@@15| |#$T1@@176|))) (|Set#Equal| (Reads2 |#$T0@@240| |#$T1@@176| |#$R@@266| $OneHeap |f#0@@55| |x0#0@@23| |x1#0@@15|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1205|
 :no-pattern (type |x0#0@@23|)
 :no-pattern (type |x1#0@@15|)
 :no-pattern (U_2_int |x0#0@@23|)
 :no-pattern (U_2_bool |x0#0@@23|)
 :no-pattern (U_2_int |x1#0@@15|)
 :no-pattern (U_2_bool |x1#0@@15|)
)))))
 :qid |unknown.0:0|
 :skolemid |1206|
 :pattern ( ($Is |f#0@@55| (Tclass._System.___hPartialFunc2LLO |#$T0@@240| |#$T1@@176| |#$R@@266|)))
)))
(assert (forall ((|#$T0@@241| T@U) (|#$T1@@177| T@U) (|#$R@@267| T@U) (|f#0@@56| T@U) ($h@@43 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@241|) TyType) (= (type |#$T1@@177|) TyType)) (= (type |#$R@@267|) TyType)) (= (type |f#0@@56|) HandleTypeType)) (= (type $h@@43) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@56| (Tclass._System.___hPartialFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43) ($IsAlloc |f#0@@56| (Tclass._System.___hFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43)))
 :qid |unknown.0:0|
 :skolemid |1207|
 :pattern ( ($IsAlloc |f#0@@56| (Tclass._System.___hPartialFunc2LLO |#$T0@@241| |#$T1@@177| |#$R@@267|) $h@@43))
)))
(assert (forall ((arg0@@339 T@U) (arg1@@137 T@U) (arg2@@78 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO|
 :pattern ( (Tclass._System.___hTotalFunc2LLO arg0@@339 arg1@@137 arg2@@78))
)))
(assert (forall ((|#$T0@@242| T@U) (|#$T1@@178| T@U) (|#$R@@268| T@U) ) (!  (=> (and (and (= (type |#$T0@@242|) TyType) (= (type |#$T1@@178|) TyType)) (= (type |#$R@@268|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|)) Tagclass._System.___hTotalFunc2LLO) (= (TagFamily (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|)) |tytagFamily$_#TotalFunc2LLO|)))
 :qid |unknown.0:0|
 :skolemid |1208|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@242| |#$T1@@178| |#$R@@268|))
)))
(assert (forall ((arg0@@340 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_0 arg0@@340)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_0|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_0 arg0@@340))
)))
(assert (forall ((|#$T0@@243| T@U) (|#$T1@@179| T@U) (|#$R@@269| T@U) ) (!  (=> (and (and (= (type |#$T0@@243|) TyType) (= (type |#$T1@@179|) TyType)) (= (type |#$R@@269|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_0 (Tclass._System.___hTotalFunc2LLO |#$T0@@243| |#$T1@@179| |#$R@@269|)) |#$T0@@243|))
 :qid |unknown.0:0|
 :skolemid |1209|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@243| |#$T1@@179| |#$R@@269|))
)))
(assert (forall ((arg0@@341 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_1 arg0@@341)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_1|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_1 arg0@@341))
)))
(assert (forall ((|#$T0@@244| T@U) (|#$T1@@180| T@U) (|#$R@@270| T@U) ) (!  (=> (and (and (= (type |#$T0@@244|) TyType) (= (type |#$T1@@180|) TyType)) (= (type |#$R@@270|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_1 (Tclass._System.___hTotalFunc2LLO |#$T0@@244| |#$T1@@180| |#$R@@270|)) |#$T1@@180|))
 :qid |unknown.0:0|
 :skolemid |1210|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@244| |#$T1@@180| |#$R@@270|))
)))
(assert (forall ((arg0@@342 T@U) ) (! (= (type (Tclass._System.___hTotalFunc2LLO_2 arg0@@342)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc2LLO_2|
 :pattern ( (Tclass._System.___hTotalFunc2LLO_2 arg0@@342))
)))
(assert (forall ((|#$T0@@245| T@U) (|#$T1@@181| T@U) (|#$R@@271| T@U) ) (!  (=> (and (and (= (type |#$T0@@245|) TyType) (= (type |#$T1@@181|) TyType)) (= (type |#$R@@271|) TyType)) (= (Tclass._System.___hTotalFunc2LLO_2 (Tclass._System.___hTotalFunc2LLO |#$T0@@245| |#$T1@@181| |#$R@@271|)) |#$R@@271|))
 :qid |unknown.0:0|
 :skolemid |1211|
 :pattern ( (Tclass._System.___hTotalFunc2LLO |#$T0@@245| |#$T1@@181| |#$R@@271|))
)))
(assert (forall ((|#$T0@@246| T@U) (|#$T1@@182| T@U) (|#$R@@272| T@U) (bx@@99 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@246|) TyType) (= (type |#$T1@@182|) TyType)) (= (type |#$R@@272|) TyType)) (= (type bx@@99) BoxType)) ($IsBox bx@@99 (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|))) (and (= ($Box ($Unbox HandleTypeType bx@@99)) bx@@99) ($Is ($Unbox HandleTypeType bx@@99) (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|))))
 :qid |unknown.0:0|
 :skolemid |1212|
 :pattern ( ($IsBox bx@@99 (Tclass._System.___hTotalFunc2LLO |#$T0@@246| |#$T1@@182| |#$R@@272|)))
)))
(assert (forall ((|#$T0@@247| T@U) (|#$T1@@183| T@U) (|#$R@@273| T@U) (|f#0@@57| T@U) ) (!  (=> (and (and (and (= (type |#$T0@@247|) TyType) (= (type |#$T1@@183|) TyType)) (= (type |#$R@@273|) TyType)) (= (type |f#0@@57|) HandleTypeType)) (= ($Is |f#0@@57| (Tclass._System.___hTotalFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|))  (and ($Is |f#0@@57| (Tclass._System.___hPartialFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|)) (forall ((|x0#0@@24| T@U) (|x1#0@@16| T@U) ) (!  (=> (and (and (= (type |x0#0@@24|) BoxType) (= (type |x1#0@@16|) BoxType)) (and ($IsBox |x0#0@@24| |#$T0@@247|) ($IsBox |x1#0@@16| |#$T1@@183|))) (Requires2 |#$T0@@247| |#$T1@@183| |#$R@@273| $OneHeap |f#0@@57| |x0#0@@24| |x1#0@@16|))
 :qid |unknown.0:0|
 :skolemid |1213|
 :no-pattern (type |x0#0@@24|)
 :no-pattern (type |x1#0@@16|)
 :no-pattern (U_2_int |x0#0@@24|)
 :no-pattern (U_2_bool |x0#0@@24|)
 :no-pattern (U_2_int |x1#0@@16|)
 :no-pattern (U_2_bool |x1#0@@16|)
)))))
 :qid |unknown.0:0|
 :skolemid |1214|
 :pattern ( ($Is |f#0@@57| (Tclass._System.___hTotalFunc2LLO |#$T0@@247| |#$T1@@183| |#$R@@273|)))
)))
(assert (forall ((|#$T0@@248| T@U) (|#$T1@@184| T@U) (|#$R@@274| T@U) (|f#0@@58| T@U) ($h@@44 T@U) ) (!  (=> (and (and (and (and (= (type |#$T0@@248|) TyType) (= (type |#$T1@@184|) TyType)) (= (type |#$R@@274|) TyType)) (= (type |f#0@@58|) HandleTypeType)) (= (type $h@@44) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@58| (Tclass._System.___hTotalFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44) ($IsAlloc |f#0@@58| (Tclass._System.___hPartialFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44)))
 :qid |unknown.0:0|
 :skolemid |1215|
 :pattern ( ($IsAlloc |f#0@@58| (Tclass._System.___hTotalFunc2LLO |#$T0@@248| |#$T1@@184| |#$R@@274|) $h@@44))
)))
(assert (forall ((arg0@@343 T@U) (arg1@@138 T@U) ) (! (= (type (Tclass._System.___hFunc1SS arg0@@343 arg1@@138)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS|
 :pattern ( (Tclass._System.___hFunc1SS arg0@@343 arg1@@138))
)))
(assert (forall ((|#$T0@@249| T@U) (|#$R@@275| T@U) ) (!  (=> (and (= (type |#$T0@@249|) TyType) (= (type |#$R@@275|) TyType)) (and (= (Tag (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|)) Tagclass._System.___hFunc1SS) (= (TagFamily (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|)) |tytagFamily$_#Func1SS|)))
 :qid |unknown.0:0|
 :skolemid |1216|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@249| |#$R@@275|))
)))
(assert (forall ((arg0@@344 T@U) ) (! (= (type (Tclass._System.___hFunc1SS_0 arg0@@344)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS_0|
 :pattern ( (Tclass._System.___hFunc1SS_0 arg0@@344))
)))
(assert (forall ((|#$T0@@250| T@U) (|#$R@@276| T@U) ) (!  (=> (and (= (type |#$T0@@250|) TyType) (= (type |#$R@@276|) TyType)) (= (Tclass._System.___hFunc1SS_0 (Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|)) |#$T0@@250|))
 :qid |unknown.0:0|
 :skolemid |1217|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@250| |#$R@@276|))
)))
(assert (forall ((arg0@@345 T@U) ) (! (= (type (Tclass._System.___hFunc1SS_1 arg0@@345)) TyType)
 :qid |funType:Tclass._System.___hFunc1SS_1|
 :pattern ( (Tclass._System.___hFunc1SS_1 arg0@@345))
)))
(assert (forall ((|#$T0@@251| T@U) (|#$R@@277| T@U) ) (!  (=> (and (= (type |#$T0@@251|) TyType) (= (type |#$R@@277|) TyType)) (= (Tclass._System.___hFunc1SS_1 (Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|)) |#$R@@277|))
 :qid |unknown.0:0|
 :skolemid |1218|
 :pattern ( (Tclass._System.___hFunc1SS |#$T0@@251| |#$R@@277|))
)))
(assert (forall ((|#$T0@@252| T@U) (|#$R@@278| T@U) (bx@@100 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@252|) TyType) (= (type |#$R@@278|) TyType)) (= (type bx@@100) BoxType)) ($IsBox bx@@100 (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|))) (and (= ($Box ($Unbox HandleTypeType bx@@100)) bx@@100) ($Is ($Unbox HandleTypeType bx@@100) (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|))))
 :qid |unknown.0:0|
 :skolemid |1219|
 :pattern ( ($IsBox bx@@100 (Tclass._System.___hFunc1SS |#$T0@@252| |#$R@@278|)))
)))
(assert (forall ((arg0@@346 T@U) (arg1@@139 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS|
 :pattern ( (Tclass._System.___hPartialFunc1SS arg0@@346 arg1@@139))
)))
(assert (forall ((|#$T0@@253| T@U) (|#$R@@279| T@U) ) (!  (=> (and (= (type |#$T0@@253|) TyType) (= (type |#$R@@279|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|)) Tagclass._System.___hPartialFunc1SS) (= (TagFamily (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|)) |tytagFamily$_#PartialFunc1SS|)))
 :qid |unknown.0:0|
 :skolemid |1220|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@253| |#$R@@279|))
)))
(assert (forall ((arg0@@347 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS_0 arg0@@347)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS_0|
 :pattern ( (Tclass._System.___hPartialFunc1SS_0 arg0@@347))
)))
(assert (forall ((|#$T0@@254| T@U) (|#$R@@280| T@U) ) (!  (=> (and (= (type |#$T0@@254|) TyType) (= (type |#$R@@280|) TyType)) (= (Tclass._System.___hPartialFunc1SS_0 (Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|)) |#$T0@@254|))
 :qid |unknown.0:0|
 :skolemid |1221|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@254| |#$R@@280|))
)))
(assert (forall ((arg0@@348 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1SS_1 arg0@@348)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1SS_1|
 :pattern ( (Tclass._System.___hPartialFunc1SS_1 arg0@@348))
)))
(assert (forall ((|#$T0@@255| T@U) (|#$R@@281| T@U) ) (!  (=> (and (= (type |#$T0@@255|) TyType) (= (type |#$R@@281|) TyType)) (= (Tclass._System.___hPartialFunc1SS_1 (Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|)) |#$R@@281|))
 :qid |unknown.0:0|
 :skolemid |1222|
 :pattern ( (Tclass._System.___hPartialFunc1SS |#$T0@@255| |#$R@@281|))
)))
(assert (forall ((|#$T0@@256| T@U) (|#$R@@282| T@U) (bx@@101 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@256|) TyType) (= (type |#$R@@282|) TyType)) (= (type bx@@101) BoxType)) ($IsBox bx@@101 (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|))) (and (= ($Box ($Unbox HandleTypeType bx@@101)) bx@@101) ($Is ($Unbox HandleTypeType bx@@101) (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|))))
 :qid |unknown.0:0|
 :skolemid |1223|
 :pattern ( ($IsBox bx@@101 (Tclass._System.___hPartialFunc1SS |#$T0@@256| |#$R@@282|)))
)))
(assert (forall ((|#$T0@@257| T@U) (|#$R@@283| T@U) (|f#0@@59| T@U) ) (!  (=> (and (and (= (type |#$T0@@257|) TyType) (= (type |#$R@@283|) TyType)) (= (type |f#0@@59|) HandleTypeType)) (= ($Is |f#0@@59| (Tclass._System.___hPartialFunc1SS |#$T0@@257| |#$R@@283|))  (and ($Is |f#0@@59| (Tclass._System.___hFunc1SS |#$T0@@257| |#$R@@283|)) (forall ((|x0#0@@25| T@U) ) (!  (=> (and (= (type |x0#0@@25|) BoxType) ($IsBox |x0#0@@25| |#$T0@@257|)) (|Set#Equal| (Reads1 |#$T0@@257| |#$R@@283| $OneHeap |f#0@@59| |x0#0@@25|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1224|
 :no-pattern (type |x0#0@@25|)
 :no-pattern (U_2_int |x0#0@@25|)
 :no-pattern (U_2_bool |x0#0@@25|)
)))))
 :qid |unknown.0:0|
 :skolemid |1225|
 :pattern ( ($Is |f#0@@59| (Tclass._System.___hPartialFunc1SS |#$T0@@257| |#$R@@283|)))
)))
(assert (forall ((|#$T0@@258| T@U) (|#$R@@284| T@U) (|f#0@@60| T@U) ($h@@45 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@258|) TyType) (= (type |#$R@@284|) TyType)) (= (type |f#0@@60|) HandleTypeType)) (= (type $h@@45) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@60| (Tclass._System.___hPartialFunc1SS |#$T0@@258| |#$R@@284|) $h@@45) ($IsAlloc |f#0@@60| (Tclass._System.___hFunc1SS |#$T0@@258| |#$R@@284|) $h@@45)))
 :qid |unknown.0:0|
 :skolemid |1226|
 :pattern ( ($IsAlloc |f#0@@60| (Tclass._System.___hPartialFunc1SS |#$T0@@258| |#$R@@284|) $h@@45))
)))
(assert (forall ((arg0@@349 T@U) (arg1@@140 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS|
 :pattern ( (Tclass._System.___hTotalFunc1SS arg0@@349 arg1@@140))
)))
(assert (forall ((|#$T0@@259| T@U) (|#$R@@285| T@U) ) (!  (=> (and (= (type |#$T0@@259|) TyType) (= (type |#$R@@285|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|)) Tagclass._System.___hTotalFunc1SS) (= (TagFamily (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|)) |tytagFamily$_#TotalFunc1SS|)))
 :qid |unknown.0:0|
 :skolemid |1227|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@259| |#$R@@285|))
)))
(assert (forall ((arg0@@350 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS_0 arg0@@350)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS_0|
 :pattern ( (Tclass._System.___hTotalFunc1SS_0 arg0@@350))
)))
(assert (forall ((|#$T0@@260| T@U) (|#$R@@286| T@U) ) (!  (=> (and (= (type |#$T0@@260|) TyType) (= (type |#$R@@286|) TyType)) (= (Tclass._System.___hTotalFunc1SS_0 (Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|)) |#$T0@@260|))
 :qid |unknown.0:0|
 :skolemid |1228|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@260| |#$R@@286|))
)))
(assert (forall ((arg0@@351 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1SS_1 arg0@@351)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1SS_1|
 :pattern ( (Tclass._System.___hTotalFunc1SS_1 arg0@@351))
)))
(assert (forall ((|#$T0@@261| T@U) (|#$R@@287| T@U) ) (!  (=> (and (= (type |#$T0@@261|) TyType) (= (type |#$R@@287|) TyType)) (= (Tclass._System.___hTotalFunc1SS_1 (Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|)) |#$R@@287|))
 :qid |unknown.0:0|
 :skolemid |1229|
 :pattern ( (Tclass._System.___hTotalFunc1SS |#$T0@@261| |#$R@@287|))
)))
(assert (forall ((|#$T0@@262| T@U) (|#$R@@288| T@U) (bx@@102 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@262|) TyType) (= (type |#$R@@288|) TyType)) (= (type bx@@102) BoxType)) ($IsBox bx@@102 (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|))) (and (= ($Box ($Unbox HandleTypeType bx@@102)) bx@@102) ($Is ($Unbox HandleTypeType bx@@102) (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|))))
 :qid |unknown.0:0|
 :skolemid |1230|
 :pattern ( ($IsBox bx@@102 (Tclass._System.___hTotalFunc1SS |#$T0@@262| |#$R@@288|)))
)))
(assert (forall ((|#$T0@@263| T@U) (|#$R@@289| T@U) (|f#0@@61| T@U) ) (!  (=> (and (and (= (type |#$T0@@263|) TyType) (= (type |#$R@@289|) TyType)) (= (type |f#0@@61|) HandleTypeType)) (= ($Is |f#0@@61| (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|))  (and ($Is |f#0@@61| (Tclass._System.___hPartialFunc1SS |#$T0@@263| |#$R@@289|)) (forall ((|x0#0@@26| T@U) ) (!  (=> (and (= (type |x0#0@@26|) BoxType) ($IsBox |x0#0@@26| |#$T0@@263|)) (Requires1 |#$T0@@263| |#$R@@289| $OneHeap |f#0@@61| |x0#0@@26|))
 :qid |unknown.0:0|
 :skolemid |1231|
 :no-pattern (type |x0#0@@26|)
 :no-pattern (U_2_int |x0#0@@26|)
 :no-pattern (U_2_bool |x0#0@@26|)
)))))
 :qid |unknown.0:0|
 :skolemid |1232|
 :pattern ( ($Is |f#0@@61| (Tclass._System.___hTotalFunc1SS |#$T0@@263| |#$R@@289|)))
)))
(assert (forall ((|#$T0@@264| T@U) (|#$R@@290| T@U) (|f#0@@62| T@U) ($h@@46 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@264|) TyType) (= (type |#$R@@290|) TyType)) (= (type |f#0@@62|) HandleTypeType)) (= (type $h@@46) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@62| (Tclass._System.___hTotalFunc1SS |#$T0@@264| |#$R@@290|) $h@@46) ($IsAlloc |f#0@@62| (Tclass._System.___hPartialFunc1SS |#$T0@@264| |#$R@@290|) $h@@46)))
 :qid |unknown.0:0|
 :skolemid |1233|
 :pattern ( ($IsAlloc |f#0@@62| (Tclass._System.___hTotalFunc1SS |#$T0@@264| |#$R@@290|) $h@@46))
)))
(assert (forall ((arg0@@352 T@U) (arg1@@141 T@U) ) (! (= (type (Tclass._System.___hFunc1LL arg0@@352 arg1@@141)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL|
 :pattern ( (Tclass._System.___hFunc1LL arg0@@352 arg1@@141))
)))
(assert (forall ((|#$T0@@265| T@U) (|#$R@@291| T@U) ) (!  (=> (and (= (type |#$T0@@265|) TyType) (= (type |#$R@@291|) TyType)) (and (= (Tag (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|)) Tagclass._System.___hFunc1LL) (= (TagFamily (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|)) |tytagFamily$_#Func1LL|)))
 :qid |unknown.0:0|
 :skolemid |1234|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@265| |#$R@@291|))
)))
(assert (forall ((arg0@@353 T@U) ) (! (= (type (Tclass._System.___hFunc1LL_0 arg0@@353)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL_0|
 :pattern ( (Tclass._System.___hFunc1LL_0 arg0@@353))
)))
(assert (forall ((|#$T0@@266| T@U) (|#$R@@292| T@U) ) (!  (=> (and (= (type |#$T0@@266|) TyType) (= (type |#$R@@292|) TyType)) (= (Tclass._System.___hFunc1LL_0 (Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|)) |#$T0@@266|))
 :qid |unknown.0:0|
 :skolemid |1235|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@266| |#$R@@292|))
)))
(assert (forall ((arg0@@354 T@U) ) (! (= (type (Tclass._System.___hFunc1LL_1 arg0@@354)) TyType)
 :qid |funType:Tclass._System.___hFunc1LL_1|
 :pattern ( (Tclass._System.___hFunc1LL_1 arg0@@354))
)))
(assert (forall ((|#$T0@@267| T@U) (|#$R@@293| T@U) ) (!  (=> (and (= (type |#$T0@@267|) TyType) (= (type |#$R@@293|) TyType)) (= (Tclass._System.___hFunc1LL_1 (Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|)) |#$R@@293|))
 :qid |unknown.0:0|
 :skolemid |1236|
 :pattern ( (Tclass._System.___hFunc1LL |#$T0@@267| |#$R@@293|))
)))
(assert (forall ((|#$T0@@268| T@U) (|#$R@@294| T@U) (bx@@103 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@268|) TyType) (= (type |#$R@@294|) TyType)) (= (type bx@@103) BoxType)) ($IsBox bx@@103 (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|))) (and (= ($Box ($Unbox HandleTypeType bx@@103)) bx@@103) ($Is ($Unbox HandleTypeType bx@@103) (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|))))
 :qid |unknown.0:0|
 :skolemid |1237|
 :pattern ( ($IsBox bx@@103 (Tclass._System.___hFunc1LL |#$T0@@268| |#$R@@294|)))
)))
(assert (forall ((arg0@@355 T@U) (arg1@@142 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL|
 :pattern ( (Tclass._System.___hPartialFunc1LL arg0@@355 arg1@@142))
)))
(assert (forall ((|#$T0@@269| T@U) (|#$R@@295| T@U) ) (!  (=> (and (= (type |#$T0@@269|) TyType) (= (type |#$R@@295|) TyType)) (and (= (Tag (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|)) Tagclass._System.___hPartialFunc1LL) (= (TagFamily (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|)) |tytagFamily$_#PartialFunc1LL|)))
 :qid |unknown.0:0|
 :skolemid |1238|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@269| |#$R@@295|))
)))
(assert (forall ((arg0@@356 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL_0 arg0@@356)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL_0|
 :pattern ( (Tclass._System.___hPartialFunc1LL_0 arg0@@356))
)))
(assert (forall ((|#$T0@@270| T@U) (|#$R@@296| T@U) ) (!  (=> (and (= (type |#$T0@@270|) TyType) (= (type |#$R@@296|) TyType)) (= (Tclass._System.___hPartialFunc1LL_0 (Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|)) |#$T0@@270|))
 :qid |unknown.0:0|
 :skolemid |1239|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@270| |#$R@@296|))
)))
(assert (forall ((arg0@@357 T@U) ) (! (= (type (Tclass._System.___hPartialFunc1LL_1 arg0@@357)) TyType)
 :qid |funType:Tclass._System.___hPartialFunc1LL_1|
 :pattern ( (Tclass._System.___hPartialFunc1LL_1 arg0@@357))
)))
(assert (forall ((|#$T0@@271| T@U) (|#$R@@297| T@U) ) (!  (=> (and (= (type |#$T0@@271|) TyType) (= (type |#$R@@297|) TyType)) (= (Tclass._System.___hPartialFunc1LL_1 (Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|)) |#$R@@297|))
 :qid |unknown.0:0|
 :skolemid |1240|
 :pattern ( (Tclass._System.___hPartialFunc1LL |#$T0@@271| |#$R@@297|))
)))
(assert (forall ((|#$T0@@272| T@U) (|#$R@@298| T@U) (bx@@104 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@272|) TyType) (= (type |#$R@@298|) TyType)) (= (type bx@@104) BoxType)) ($IsBox bx@@104 (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|))) (and (= ($Box ($Unbox HandleTypeType bx@@104)) bx@@104) ($Is ($Unbox HandleTypeType bx@@104) (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|))))
 :qid |unknown.0:0|
 :skolemid |1241|
 :pattern ( ($IsBox bx@@104 (Tclass._System.___hPartialFunc1LL |#$T0@@272| |#$R@@298|)))
)))
(assert (forall ((|#$T0@@273| T@U) (|#$R@@299| T@U) (|f#0@@63| T@U) ) (!  (=> (and (and (= (type |#$T0@@273|) TyType) (= (type |#$R@@299|) TyType)) (= (type |f#0@@63|) HandleTypeType)) (= ($Is |f#0@@63| (Tclass._System.___hPartialFunc1LL |#$T0@@273| |#$R@@299|))  (and ($Is |f#0@@63| (Tclass._System.___hFunc1LL |#$T0@@273| |#$R@@299|)) (forall ((|x0#0@@27| T@U) ) (!  (=> (and (= (type |x0#0@@27|) BoxType) ($IsBox |x0#0@@27| |#$T0@@273|)) (|Set#Equal| (Reads1 |#$T0@@273| |#$R@@299| $OneHeap |f#0@@63| |x0#0@@27|) (|Set#Empty| BoxType)))
 :qid |unknown.0:0|
 :skolemid |1242|
 :no-pattern (type |x0#0@@27|)
 :no-pattern (U_2_int |x0#0@@27|)
 :no-pattern (U_2_bool |x0#0@@27|)
)))))
 :qid |unknown.0:0|
 :skolemid |1243|
 :pattern ( ($Is |f#0@@63| (Tclass._System.___hPartialFunc1LL |#$T0@@273| |#$R@@299|)))
)))
(assert (forall ((|#$T0@@274| T@U) (|#$R@@300| T@U) (|f#0@@64| T@U) ($h@@47 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@274|) TyType) (= (type |#$R@@300|) TyType)) (= (type |f#0@@64|) HandleTypeType)) (= (type $h@@47) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@64| (Tclass._System.___hPartialFunc1LL |#$T0@@274| |#$R@@300|) $h@@47) ($IsAlloc |f#0@@64| (Tclass._System.___hFunc1LL |#$T0@@274| |#$R@@300|) $h@@47)))
 :qid |unknown.0:0|
 :skolemid |1244|
 :pattern ( ($IsAlloc |f#0@@64| (Tclass._System.___hPartialFunc1LL |#$T0@@274| |#$R@@300|) $h@@47))
)))
(assert (forall ((arg0@@358 T@U) (arg1@@143 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL|
 :pattern ( (Tclass._System.___hTotalFunc1LL arg0@@358 arg1@@143))
)))
(assert (forall ((|#$T0@@275| T@U) (|#$R@@301| T@U) ) (!  (=> (and (= (type |#$T0@@275|) TyType) (= (type |#$R@@301|) TyType)) (and (= (Tag (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|)) Tagclass._System.___hTotalFunc1LL) (= (TagFamily (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|)) |tytagFamily$_#TotalFunc1LL|)))
 :qid |unknown.0:0|
 :skolemid |1245|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@275| |#$R@@301|))
)))
(assert (forall ((arg0@@359 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL_0 arg0@@359)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL_0|
 :pattern ( (Tclass._System.___hTotalFunc1LL_0 arg0@@359))
)))
(assert (forall ((|#$T0@@276| T@U) (|#$R@@302| T@U) ) (!  (=> (and (= (type |#$T0@@276|) TyType) (= (type |#$R@@302|) TyType)) (= (Tclass._System.___hTotalFunc1LL_0 (Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|)) |#$T0@@276|))
 :qid |unknown.0:0|
 :skolemid |1246|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@276| |#$R@@302|))
)))
(assert (forall ((arg0@@360 T@U) ) (! (= (type (Tclass._System.___hTotalFunc1LL_1 arg0@@360)) TyType)
 :qid |funType:Tclass._System.___hTotalFunc1LL_1|
 :pattern ( (Tclass._System.___hTotalFunc1LL_1 arg0@@360))
)))
(assert (forall ((|#$T0@@277| T@U) (|#$R@@303| T@U) ) (!  (=> (and (= (type |#$T0@@277|) TyType) (= (type |#$R@@303|) TyType)) (= (Tclass._System.___hTotalFunc1LL_1 (Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|)) |#$R@@303|))
 :qid |unknown.0:0|
 :skolemid |1247|
 :pattern ( (Tclass._System.___hTotalFunc1LL |#$T0@@277| |#$R@@303|))
)))
(assert (forall ((|#$T0@@278| T@U) (|#$R@@304| T@U) (bx@@105 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@278|) TyType) (= (type |#$R@@304|) TyType)) (= (type bx@@105) BoxType)) ($IsBox bx@@105 (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|))) (and (= ($Box ($Unbox HandleTypeType bx@@105)) bx@@105) ($Is ($Unbox HandleTypeType bx@@105) (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|))))
 :qid |unknown.0:0|
 :skolemid |1248|
 :pattern ( ($IsBox bx@@105 (Tclass._System.___hTotalFunc1LL |#$T0@@278| |#$R@@304|)))
)))
(assert (forall ((|#$T0@@279| T@U) (|#$R@@305| T@U) (|f#0@@65| T@U) ) (!  (=> (and (and (= (type |#$T0@@279|) TyType) (= (type |#$R@@305|) TyType)) (= (type |f#0@@65|) HandleTypeType)) (= ($Is |f#0@@65| (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|))  (and ($Is |f#0@@65| (Tclass._System.___hPartialFunc1LL |#$T0@@279| |#$R@@305|)) (forall ((|x0#0@@28| T@U) ) (!  (=> (and (= (type |x0#0@@28|) BoxType) ($IsBox |x0#0@@28| |#$T0@@279|)) (Requires1 |#$T0@@279| |#$R@@305| $OneHeap |f#0@@65| |x0#0@@28|))
 :qid |unknown.0:0|
 :skolemid |1249|
 :no-pattern (type |x0#0@@28|)
 :no-pattern (U_2_int |x0#0@@28|)
 :no-pattern (U_2_bool |x0#0@@28|)
)))))
 :qid |unknown.0:0|
 :skolemid |1250|
 :pattern ( ($Is |f#0@@65| (Tclass._System.___hTotalFunc1LL |#$T0@@279| |#$R@@305|)))
)))
(assert (forall ((|#$T0@@280| T@U) (|#$R@@306| T@U) (|f#0@@66| T@U) ($h@@48 T@U) ) (!  (=> (and (and (and (= (type |#$T0@@280|) TyType) (= (type |#$R@@306|) TyType)) (= (type |f#0@@66|) HandleTypeType)) (= (type $h@@48) (MapType0Type refType MapType1Type))) (= ($IsAlloc |f#0@@66| (Tclass._System.___hTotalFunc1LL |#$T0@@280| |#$R@@306|) $h@@48) ($IsAlloc |f#0@@66| (Tclass._System.___hPartialFunc1LL |#$T0@@280| |#$R@@306|) $h@@48)))
 :qid |unknown.0:0|
 :skolemid |1251|
 :pattern ( ($IsAlloc |f#0@@66| (Tclass._System.___hTotalFunc1LL |#$T0@@280| |#$R@@306|) $h@@48))
)))
(assert (forall ((arg0@@361 Int) (arg1@@144 T@U) (arg2@@79 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.QueryLabel| arg0@@361 arg1@@144 arg2@@79)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.QueryLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| arg0@@361 arg1@@144 arg2@@79))
)))
(assert (forall ((|a#23#0#0| Int) (|a#23#1#0| T@U) (|a#23#2#0| T@U) ) (!  (=> (and (= (type |a#23#1#0|) (SeqType BoxType)) (= (type |a#23#2#0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.QueryLabel| |a#23#0#0| |a#23#1#0| |a#23#2#0|)) |##PivotBetree.TransitionLabel.QueryLabel|))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1252|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#23#0#0| |a#23#1#0| |a#23#2#0|))
)))
(assert (forall ((d@@16 T@U) ) (!  (=> (= (type d@@16) DatatypeTypeType) (= (PivotBetree.TransitionLabel.QueryLabel_q d@@16) (= (DatatypeCtorId d@@16) |##PivotBetree.TransitionLabel.QueryLabel|)))
 :qid |unknown.0:0|
 :skolemid |1253|
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@16))
)))
(assert (forall ((d@@17 T@U) ) (!  (=> (and (= (type d@@17) DatatypeTypeType) (PivotBetree.TransitionLabel.QueryLabel_q d@@17)) (exists ((|a#24#0#0| Int) (|a#24#1#0| T@U) (|a#24#2#0| T@U) ) (!  (and (and (= (type |a#24#1#0|) (SeqType BoxType)) (= (type |a#24#2#0|) (SeqType BoxType))) (= d@@17 (|#PivotBetree.TransitionLabel.QueryLabel| |a#24#0#0| |a#24#1#0| |a#24#2#0|)))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1254|
 :no-pattern (type |a#24#1#0|)
 :no-pattern (type |a#24#2#0|)
 :no-pattern (U_2_int |a#24#1#0|)
 :no-pattern (U_2_bool |a#24#1#0|)
 :no-pattern (U_2_int |a#24#2#0|)
 :no-pattern (U_2_bool |a#24#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1255|
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@17))
)))
(assert (= (type Tclass.KeyType.Key) TyType))
(assert (= (Tag Tclass.KeyType.Key) Tagclass.KeyType.Key))
(assert (= (TagFamily Tclass.KeyType.Key) tytagFamily$Key))
(assert (forall ((bx@@106 T@U) ) (!  (=> (and (= (type bx@@106) BoxType) ($IsBox bx@@106 Tclass.KeyType.Key)) (and (= ($Box ($Unbox (SeqType BoxType) bx@@106)) bx@@106) ($Is ($Unbox (SeqType BoxType) bx@@106) Tclass.KeyType.Key)))
 :qid |unknown.0:0|
 :skolemid |1256|
 :pattern ( ($IsBox bx@@106 Tclass.KeyType.Key))
)))
(assert (= (type Tclass.ValueType.Value) TyType))
(assert (= (Tag Tclass.ValueType.Value) Tagclass.ValueType.Value))
(assert (= (TagFamily Tclass.ValueType.Value) tytagFamily$Value))
(assert (forall ((bx@@107 T@U) ) (!  (=> (and (= (type bx@@107) BoxType) ($IsBox bx@@107 Tclass.ValueType.Value)) (and (= ($Box ($Unbox (SeqType BoxType) bx@@107)) bx@@107) ($Is ($Unbox (SeqType BoxType) bx@@107) Tclass.ValueType.Value)))
 :qid |unknown.0:0|
 :skolemid |1257|
 :pattern ( ($IsBox bx@@107 Tclass.ValueType.Value))
)))
(assert (= (type Tclass.PivotBetree.TransitionLabel) TyType))
(assert (= (Tag Tclass.PivotBetree.TransitionLabel) Tagclass.PivotBetree.TransitionLabel))
(assert (= (TagFamily Tclass.PivotBetree.TransitionLabel) tytagFamily$TransitionLabel))
(assert (forall ((bx@@108 T@U) ) (!  (=> (and (= (type bx@@108) BoxType) ($IsBox bx@@108 Tclass.PivotBetree.TransitionLabel)) (and (= ($Box ($Unbox DatatypeTypeType bx@@108)) bx@@108) ($Is ($Unbox DatatypeTypeType bx@@108) Tclass.PivotBetree.TransitionLabel)))
 :qid |unknown.0:0|
 :skolemid |1258|
 :pattern ( ($IsBox bx@@108 Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#25#0#0| Int) (|a#25#1#0| T@U) (|a#25#2#0| T@U) ) (!  (=> (and (= (type |a#25#1#0|) (SeqType BoxType)) (= (type |a#25#2#0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.TransitionLabel.QueryLabel| |a#25#0#0| |a#25#1#0| |a#25#2#0|) Tclass.PivotBetree.TransitionLabel)  (and (and ($Is (int_2_U |a#25#0#0|) Tclass._System.nat) ($Is |a#25#1#0| Tclass.KeyType.Key)) ($Is |a#25#2#0| Tclass.ValueType.Value))))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1259|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.QueryLabel| |a#25#0#0| |a#25#1#0| |a#25#2#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#26#0#0| Int) (|a#26#1#0| T@U) (|a#26#2#0| T@U) ($h@@49 T@U) ) (!  (=> (and (and (and (= (type |a#26#1#0|) (SeqType BoxType)) (= (type |a#26#2#0|) (SeqType BoxType))) (= (type $h@@49) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@49)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.QueryLabel| |a#26#0#0| |a#26#1#0| |a#26#2#0|) Tclass.PivotBetree.TransitionLabel $h@@49)  (and (and ($IsAlloc (int_2_U |a#26#0#0|) Tclass._System.nat $h@@49) ($IsAlloc |a#26#1#0| Tclass.KeyType.Key $h@@49)) ($IsAlloc |a#26#2#0| Tclass.ValueType.Value $h@@49))))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1260|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.QueryLabel| |a#26#0#0| |a#26#1#0| |a#26#2#0|) Tclass.PivotBetree.TransitionLabel $h@@49))
)))
(assert (forall ((d@@18 T@U) ($h@@50 T@U) ) (!  (=> (and (and (= (type d@@18) DatatypeTypeType) (= (type $h@@50) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@50) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@18) ($IsAlloc d@@18 Tclass.PivotBetree.TransitionLabel $h@@50)))) ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@18)) Tclass._System.nat $h@@50))
 :qid |unknown.0:0|
 :skolemid |1261|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@18)) Tclass._System.nat $h@@50))
)))
(assert (forall ((arg0@@362 T@U) ) (! (= (type (PivotBetree.TransitionLabel.key arg0@@362)) (SeqType BoxType))
 :qid |funType:PivotBetree.TransitionLabel.key|
 :pattern ( (PivotBetree.TransitionLabel.key arg0@@362))
)))
(assert (forall ((d@@19 T@U) ($h@@51 T@U) ) (!  (=> (and (and (= (type d@@19) DatatypeTypeType) (= (type $h@@51) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@51) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@19) ($IsAlloc d@@19 Tclass.PivotBetree.TransitionLabel $h@@51)))) ($IsAlloc (PivotBetree.TransitionLabel.key d@@19) Tclass.KeyType.Key $h@@51))
 :qid |unknown.0:0|
 :skolemid |1262|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.key d@@19) Tclass.KeyType.Key $h@@51))
)))
(assert (forall ((arg0@@363 T@U) ) (! (= (type (PivotBetree.TransitionLabel.value arg0@@363)) (SeqType BoxType))
 :qid |funType:PivotBetree.TransitionLabel.value|
 :pattern ( (PivotBetree.TransitionLabel.value arg0@@363))
)))
(assert (forall ((d@@20 T@U) ($h@@52 T@U) ) (!  (=> (and (and (= (type d@@20) DatatypeTypeType) (= (type $h@@52) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@52) (and (PivotBetree.TransitionLabel.QueryLabel_q d@@20) ($IsAlloc d@@20 Tclass.PivotBetree.TransitionLabel $h@@52)))) ($IsAlloc (PivotBetree.TransitionLabel.value d@@20) Tclass.ValueType.Value $h@@52))
 :qid |unknown.0:0|
 :skolemid |1263|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.value d@@20) Tclass.ValueType.Value $h@@52))
)))
(assert (forall ((|a#27#0#0| Int) (|a#27#1#0| T@U) (|a#27#2#0| T@U) ) (!  (=> (and (= (type |a#27#1#0|) (SeqType BoxType)) (= (type |a#27#2#0|) (SeqType BoxType))) (= (|#PivotBetree.TransitionLabel.QueryLabel| (LitInt |a#27#0#0|) (Lit |a#27#1#0|) (Lit |a#27#2#0|)) (Lit (|#PivotBetree.TransitionLabel.QueryLabel| |a#27#0#0| |a#27#1#0| |a#27#2#0|))))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1264|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| (LitInt |a#27#0#0|) (Lit |a#27#1#0|) (Lit |a#27#2#0|)))
)))
(assert (forall ((|a#28#0#0| Int) (|a#28#1#0| T@U) (|a#28#2#0| T@U) ) (!  (=> (and (= (type |a#28#1#0|) (SeqType BoxType)) (= (type |a#28#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.endLsn (|#PivotBetree.TransitionLabel.QueryLabel| |a#28#0#0| |a#28#1#0| |a#28#2#0|)) |a#28#0#0|))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1265|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#28#0#0| |a#28#1#0| |a#28#2#0|))
)))
(assert (forall ((|a#29#0#0| Int) (|a#29#1#0| T@U) (|a#29#2#0| T@U) ) (!  (=> (and (= (type |a#29#1#0|) (SeqType BoxType)) (= (type |a#29#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.key (|#PivotBetree.TransitionLabel.QueryLabel| |a#29#0#0| |a#29#1#0| |a#29#2#0|)) |a#29#1#0|))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1266|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#29#0#0| |a#29#1#0| |a#29#2#0|))
)))
(assert (forall ((|a#30#0#0| Int) (|a#30#1#0| T@U) (|a#30#2#0| T@U) ) (!  (=> (and (= (type |a#30#1#0|) (SeqType BoxType)) (= (type |a#30#2#0|) (SeqType BoxType))) (= (PivotBetree.TransitionLabel.value (|#PivotBetree.TransitionLabel.QueryLabel| |a#30#0#0| |a#30#1#0| |a#30#2#0|)) |a#30#2#0|))
 :qid |PivotBetreebrokenidfy.30:16|
 :skolemid |1267|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryLabel| |a#30#0#0| |a#30#1#0| |a#30#2#0|))
)))
(assert (forall ((arg0@@364 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.PutLabel| arg0@@364)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.PutLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| arg0@@364))
)))
(assert (forall ((|a#31#0#0| T@U) ) (!  (=> (= (type |a#31#0#0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.PutLabel| |a#31#0#0|)) |##PivotBetree.TransitionLabel.PutLabel|))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1268|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#31#0#0|))
)))
(assert (forall ((d@@21 T@U) ) (!  (=> (= (type d@@21) DatatypeTypeType) (= (PivotBetree.TransitionLabel.PutLabel_q d@@21) (= (DatatypeCtorId d@@21) |##PivotBetree.TransitionLabel.PutLabel|)))
 :qid |unknown.0:0|
 :skolemid |1269|
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@21))
)))
(assert (forall ((d@@22 T@U) ) (!  (=> (and (= (type d@@22) DatatypeTypeType) (PivotBetree.TransitionLabel.PutLabel_q d@@22)) (exists ((|a#32#0#0| T@U) ) (!  (and (= (type |a#32#0#0|) DatatypeTypeType) (= d@@22 (|#PivotBetree.TransitionLabel.PutLabel| |a#32#0#0|)))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1270|
 :no-pattern (type |a#32#0#0|)
 :no-pattern (U_2_int |a#32#0#0|)
 :no-pattern (U_2_bool |a#32#0#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1271|
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@22))
)))
(assert (= (type Tclass.MsgHistoryMod.MsgHistory) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.MsgHistory) Tagclass.MsgHistoryMod.MsgHistory))
(assert (= (TagFamily Tclass.MsgHistoryMod.MsgHistory) tytagFamily$MsgHistory))
(assert (forall ((bx@@109 T@U) ) (!  (=> (and (= (type bx@@109) BoxType) ($IsBox bx@@109 Tclass.MsgHistoryMod.MsgHistory)) (and (= ($Box ($Unbox DatatypeTypeType bx@@109)) bx@@109) ($Is ($Unbox DatatypeTypeType bx@@109) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |unknown.0:0|
 :skolemid |1272|
 :pattern ( ($IsBox bx@@109 Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (forall ((|a#33#0#0| T@U) ) (!  (=> (= (type |a#33#0#0|) DatatypeTypeType) (= ($Is (|#PivotBetree.TransitionLabel.PutLabel| |a#33#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is |a#33#0#0| Tclass.MsgHistoryMod.MsgHistory)))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1273|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.PutLabel| |a#33#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#34#0#0| T@U) ($h@@53 T@U) ) (!  (=> (and (and (= (type |a#34#0#0|) DatatypeTypeType) (= (type $h@@53) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@53)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.PutLabel| |a#34#0#0|) Tclass.PivotBetree.TransitionLabel $h@@53) ($IsAlloc |a#34#0#0| Tclass.MsgHistoryMod.MsgHistory $h@@53)))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1274|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.PutLabel| |a#34#0#0|) Tclass.PivotBetree.TransitionLabel $h@@53))
)))
(assert (forall ((arg0@@365 T@U) ) (! (= (type (PivotBetree.TransitionLabel.puts arg0@@365)) DatatypeTypeType)
 :qid |funType:PivotBetree.TransitionLabel.puts|
 :pattern ( (PivotBetree.TransitionLabel.puts arg0@@365))
)))
(assert (forall ((d@@23 T@U) ($h@@54 T@U) ) (!  (=> (and (and (= (type d@@23) DatatypeTypeType) (= (type $h@@54) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@54) (and (PivotBetree.TransitionLabel.PutLabel_q d@@23) ($IsAlloc d@@23 Tclass.PivotBetree.TransitionLabel $h@@54)))) ($IsAlloc (PivotBetree.TransitionLabel.puts d@@23) Tclass.MsgHistoryMod.MsgHistory $h@@54))
 :qid |unknown.0:0|
 :skolemid |1275|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.puts d@@23) Tclass.MsgHistoryMod.MsgHistory $h@@54))
)))
(assert (forall ((|a#35#0#0| T@U) ) (!  (=> (= (type |a#35#0#0|) DatatypeTypeType) (= (|#PivotBetree.TransitionLabel.PutLabel| (Lit |a#35#0#0|)) (Lit (|#PivotBetree.TransitionLabel.PutLabel| |a#35#0#0|))))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1276|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| (Lit |a#35#0#0|)))
)))
(assert (forall ((|a#36#0#0| T@U) ) (!  (=> (= (type |a#36#0#0|) DatatypeTypeType) (= (PivotBetree.TransitionLabel.puts (|#PivotBetree.TransitionLabel.PutLabel| |a#36#0#0|)) |a#36#0#0|))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1277|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#36#0#0|))
)))
(assert (forall ((|a#37#0#0| T@U) ) (!  (=> (= (type |a#37#0#0|) DatatypeTypeType) (< (DtRank |a#37#0#0|) (DtRank (|#PivotBetree.TransitionLabel.PutLabel| |a#37#0#0|))))
 :qid |PivotBetreebrokenidfy.31:14|
 :skolemid |1278|
 :pattern ( (|#PivotBetree.TransitionLabel.PutLabel| |a#37#0#0|))
)))
(assert (forall ((arg0@@366 Int) ) (! (= (type (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| arg0@@366)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.QueryEndLsnLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| arg0@@366))
)))
(assert (forall ((|a#38#0#0| Int) ) (! (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#38#0#0|)) |##PivotBetree.TransitionLabel.QueryEndLsnLabel|)
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1279|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#38#0#0|))
)))
(assert (forall ((d@@24 T@U) ) (!  (=> (= (type d@@24) DatatypeTypeType) (= (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@24) (= (DatatypeCtorId d@@24) |##PivotBetree.TransitionLabel.QueryEndLsnLabel|)))
 :qid |unknown.0:0|
 :skolemid |1280|
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@24))
)))
(assert (forall ((d@@25 T@U) ) (!  (=> (and (= (type d@@25) DatatypeTypeType) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@25)) (exists ((|a#39#0#0| Int) ) (! (= d@@25 (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#39#0#0|))
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1281|
)))
 :qid |unknown.0:0|
 :skolemid |1282|
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@25))
)))
(assert (forall ((|a#40#0#0| Int) ) (! (= ($Is (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#40#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is (int_2_U |a#40#0#0|) Tclass._System.nat))
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1283|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#40#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#41#0#0| Int) ($h@@55 T@U) ) (!  (=> (and (= (type $h@@55) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@55)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#41#0#0|) Tclass.PivotBetree.TransitionLabel $h@@55) ($IsAlloc (int_2_U |a#41#0#0|) Tclass._System.nat $h@@55)))
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1284|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#41#0#0|) Tclass.PivotBetree.TransitionLabel $h@@55))
)))
(assert (forall ((d@@26 T@U) ($h@@56 T@U) ) (!  (=> (and (and (= (type d@@26) DatatypeTypeType) (= (type $h@@56) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@56) (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@26) ($IsAlloc d@@26 Tclass.PivotBetree.TransitionLabel $h@@56)))) ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@26)) Tclass._System.nat $h@@56))
 :qid |unknown.0:0|
 :skolemid |1285|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.TransitionLabel.endLsn d@@26)) Tclass._System.nat $h@@56))
)))
(assert (forall ((|a#42#0#0| Int) ) (! (= (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#42#0#0|)) (Lit (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#42#0#0|)))
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1286|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| (LitInt |a#42#0#0|)))
)))
(assert (forall ((|a#43#0#0| Int) ) (! (= (PivotBetree.TransitionLabel.endLsn (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#43#0#0|)) |a#43#0#0|)
 :qid |PivotBetreebrokenidfy.32:22|
 :skolemid |1287|
 :pattern ( (|#PivotBetree.TransitionLabel.QueryEndLsnLabel| |a#43#0#0|))
)))
(assert (forall ((arg0@@367 T@U) ) (! (= (type (|#PivotBetree.TransitionLabel.FreezeAsLabel| arg0@@367)) DatatypeTypeType)
 :qid |funType:#PivotBetree.TransitionLabel.FreezeAsLabel|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| arg0@@367))
)))
(assert (forall ((|a#44#0#0| T@U) ) (!  (=> (= (type |a#44#0#0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#44#0#0|)) |##PivotBetree.TransitionLabel.FreezeAsLabel|))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1288|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#44#0#0|))
)))
(assert (forall ((d@@27 T@U) ) (!  (=> (= (type d@@27) DatatypeTypeType) (= (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@27) (= (DatatypeCtorId d@@27) |##PivotBetree.TransitionLabel.FreezeAsLabel|)))
 :qid |unknown.0:0|
 :skolemid |1289|
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@27))
)))
(assert (forall ((d@@28 T@U) ) (!  (=> (and (= (type d@@28) DatatypeTypeType) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@28)) (exists ((|a#45#0#0| T@U) ) (!  (and (= (type |a#45#0#0|) DatatypeTypeType) (= d@@28 (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#45#0#0|)))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1290|
 :no-pattern (type |a#45#0#0|)
 :no-pattern (U_2_int |a#45#0#0|)
 :no-pattern (U_2_bool |a#45#0#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1291|
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@28))
)))
(assert (= (type Tclass.PivotBetree.BetreeNode) TyType))
(assert (= (Tag Tclass.PivotBetree.BetreeNode) Tagclass.PivotBetree.BetreeNode))
(assert (= (TagFamily Tclass.PivotBetree.BetreeNode) tytagFamily$BetreeNode))
(assert (forall ((bx@@110 T@U) ) (!  (=> (and (= (type bx@@110) BoxType) ($IsBox bx@@110 Tclass.PivotBetree.BetreeNode)) (and (= ($Box ($Unbox DatatypeTypeType bx@@110)) bx@@110) ($Is ($Unbox DatatypeTypeType bx@@110) Tclass.PivotBetree.BetreeNode)))
 :qid |unknown.0:0|
 :skolemid |1292|
 :pattern ( ($IsBox bx@@110 Tclass.PivotBetree.BetreeNode))
)))
(assert (forall ((arg0@@368 T@U) ) (! (= (type (Tclass.StampedMod.Stamped arg0@@368)) TyType)
 :qid |funType:Tclass.StampedMod.Stamped|
 :pattern ( (Tclass.StampedMod.Stamped arg0@@368))
)))
(assert (forall ((StampedMod.Stamped$T T@U) ) (!  (=> (= (type StampedMod.Stamped$T) TyType) (and (= (Tag (Tclass.StampedMod.Stamped StampedMod.Stamped$T)) Tagclass.StampedMod.Stamped) (= (TagFamily (Tclass.StampedMod.Stamped StampedMod.Stamped$T)) tytagFamily$Stamped)))
 :qid |unknown.0:0|
 :skolemid |1293|
 :pattern ( (Tclass.StampedMod.Stamped StampedMod.Stamped$T))
)))
(assert (forall ((arg0@@369 T@U) ) (! (= (type (Tclass.StampedMod.Stamped_0 arg0@@369)) TyType)
 :qid |funType:Tclass.StampedMod.Stamped_0|
 :pattern ( (Tclass.StampedMod.Stamped_0 arg0@@369))
)))
(assert (forall ((StampedMod.Stamped$T@@0 T@U) ) (!  (=> (= (type StampedMod.Stamped$T@@0) TyType) (= (Tclass.StampedMod.Stamped_0 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0)) StampedMod.Stamped$T@@0))
 :qid |unknown.0:0|
 :skolemid |1294|
 :pattern ( (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@0))
)))
(assert (forall ((StampedMod.Stamped$T@@1 T@U) (bx@@111 T@U) ) (!  (=> (and (and (= (type StampedMod.Stamped$T@@1) TyType) (= (type bx@@111) BoxType)) ($IsBox bx@@111 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1))) (and (= ($Box ($Unbox DatatypeTypeType bx@@111)) bx@@111) ($Is ($Unbox DatatypeTypeType bx@@111) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1))))
 :qid |unknown.0:0|
 :skolemid |1295|
 :pattern ( ($IsBox bx@@111 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@1)))
)))
(assert (forall ((|a#46#0#0| T@U) ) (!  (=> (= (type |a#46#0#0|) DatatypeTypeType) (= ($Is (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#46#0#0|) Tclass.PivotBetree.TransitionLabel) ($Is |a#46#0#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1296|
 :pattern ( ($Is (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#46#0#0|) Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((|a#47#0#0| T@U) ($h@@57 T@U) ) (!  (=> (and (and (= (type |a#47#0#0|) DatatypeTypeType) (= (type $h@@57) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@57)) (= ($IsAlloc (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#47#0#0|) Tclass.PivotBetree.TransitionLabel $h@@57) ($IsAlloc |a#47#0#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@57)))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1297|
 :pattern ( ($IsAlloc (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#47#0#0|) Tclass.PivotBetree.TransitionLabel $h@@57))
)))
(assert (forall ((arg0@@370 T@U) ) (! (= (type (PivotBetree.TransitionLabel.stampedBetree arg0@@370)) DatatypeTypeType)
 :qid |funType:PivotBetree.TransitionLabel.stampedBetree|
 :pattern ( (PivotBetree.TransitionLabel.stampedBetree arg0@@370))
)))
(assert (forall ((d@@29 T@U) ($h@@58 T@U) ) (!  (=> (and (and (= (type d@@29) DatatypeTypeType) (= (type $h@@58) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@58) (and (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@29) ($IsAlloc d@@29 Tclass.PivotBetree.TransitionLabel $h@@58)))) ($IsAlloc (PivotBetree.TransitionLabel.stampedBetree d@@29) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@58))
 :qid |unknown.0:0|
 :skolemid |1298|
 :pattern ( ($IsAlloc (PivotBetree.TransitionLabel.stampedBetree d@@29) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode) $h@@58))
)))
(assert (forall ((|a#48#0#0| T@U) ) (!  (=> (= (type |a#48#0#0|) DatatypeTypeType) (= (|#PivotBetree.TransitionLabel.FreezeAsLabel| (Lit |a#48#0#0|)) (Lit (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#48#0#0|))))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1299|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| (Lit |a#48#0#0|)))
)))
(assert (forall ((|a#49#0#0| T@U) ) (!  (=> (= (type |a#49#0#0|) DatatypeTypeType) (= (PivotBetree.TransitionLabel.stampedBetree (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#49#0#0|)) |a#49#0#0|))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1300|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#49#0#0|))
)))
(assert (forall ((|a#50#0#0| T@U) ) (!  (=> (= (type |a#50#0#0|) DatatypeTypeType) (< (DtRank |a#50#0#0|) (DtRank (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#50#0#0|))))
 :qid |PivotBetreebrokenidfy.33:19|
 :skolemid |1301|
 :pattern ( (|#PivotBetree.TransitionLabel.FreezeAsLabel| |a#50#0#0|))
)))
(assert (= (type |#PivotBetree.TransitionLabel.InternalLabel|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.TransitionLabel.InternalLabel|) |##PivotBetree.TransitionLabel.InternalLabel|))
(assert (forall ((d@@30 T@U) ) (!  (=> (= (type d@@30) DatatypeTypeType) (= (PivotBetree.TransitionLabel.InternalLabel_q d@@30) (= (DatatypeCtorId d@@30) |##PivotBetree.TransitionLabel.InternalLabel|)))
 :qid |unknown.0:0|
 :skolemid |1302|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@30))
)))
(assert (forall ((d@@31 T@U) ) (!  (=> (and (= (type d@@31) DatatypeTypeType) (PivotBetree.TransitionLabel.InternalLabel_q d@@31)) (= d@@31 |#PivotBetree.TransitionLabel.InternalLabel|))
 :qid |unknown.0:0|
 :skolemid |1303|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@31))
)))
(assert ($Is |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel))
(assert (forall (($h@@59 T@U) ) (!  (=> (and (= (type $h@@59) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@59)) ($IsAlloc |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel $h@@59))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |1304|
 :pattern ( ($IsAlloc |#PivotBetree.TransitionLabel.InternalLabel| Tclass.PivotBetree.TransitionLabel $h@@59))
)))
(assert (= |#PivotBetree.TransitionLabel.InternalLabel| (Lit |#PivotBetree.TransitionLabel.InternalLabel|)))
(assert (forall ((d@@32 T@U) ) (!  (=> (and (= (type d@@32) DatatypeTypeType) (|$IsA#PivotBetree.TransitionLabel| d@@32)) (or (or (or (or (PivotBetree.TransitionLabel.QueryLabel_q d@@32) (PivotBetree.TransitionLabel.PutLabel_q d@@32)) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@32)) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@32)) (PivotBetree.TransitionLabel.InternalLabel_q d@@32)))
 :qid |unknown.0:0|
 :skolemid |1305|
 :pattern ( (|$IsA#PivotBetree.TransitionLabel| d@@32))
)))
(assert (forall ((d@@33 T@U) ) (!  (=> (and (= (type d@@33) DatatypeTypeType) ($Is d@@33 Tclass.PivotBetree.TransitionLabel)) (or (or (or (or (PivotBetree.TransitionLabel.QueryLabel_q d@@33) (PivotBetree.TransitionLabel.PutLabel_q d@@33)) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@33)) (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@33)) (PivotBetree.TransitionLabel.InternalLabel_q d@@33)))
 :qid |unknown.0:0|
 :skolemid |1306|
 :pattern ( (PivotBetree.TransitionLabel.InternalLabel_q d@@33) ($Is d@@33 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.FreezeAsLabel_q d@@33) ($Is d@@33 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.QueryEndLsnLabel_q d@@33) ($Is d@@33 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.PutLabel_q d@@33) ($Is d@@33 Tclass.PivotBetree.TransitionLabel))
 :pattern ( (PivotBetree.TransitionLabel.QueryLabel_q d@@33) ($Is d@@33 Tclass.PivotBetree.TransitionLabel))
)))
(assert (forall ((a@@118 T@U) (b@@67 T@U) ) (!  (=> (and (and (= (type a@@118) DatatypeTypeType) (= (type b@@67) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.QueryLabel_q a@@118) (PivotBetree.TransitionLabel.QueryLabel_q b@@67))) (= (|PivotBetree.TransitionLabel#Equal| a@@118 b@@67)  (and (and (= (PivotBetree.TransitionLabel.endLsn a@@118) (PivotBetree.TransitionLabel.endLsn b@@67)) (|Seq#Equal| (PivotBetree.TransitionLabel.key a@@118) (PivotBetree.TransitionLabel.key b@@67))) (|Seq#Equal| (PivotBetree.TransitionLabel.value a@@118) (PivotBetree.TransitionLabel.value b@@67)))))
 :qid |unknown.0:0|
 :skolemid |1307|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@118 b@@67) (PivotBetree.TransitionLabel.QueryLabel_q a@@118))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@118 b@@67) (PivotBetree.TransitionLabel.QueryLabel_q b@@67))
)))
(assert (forall ((a@@119 T@U) (b@@68 T@U) ) (!  (=> (and (and (= (type a@@119) DatatypeTypeType) (= (type b@@68) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.PutLabel_q a@@119) (PivotBetree.TransitionLabel.PutLabel_q b@@68))) (= (|PivotBetree.TransitionLabel#Equal| a@@119 b@@68) (|MsgHistoryMod.MsgHistory#Equal| (PivotBetree.TransitionLabel.puts a@@119) (PivotBetree.TransitionLabel.puts b@@68))))
 :qid |unknown.0:0|
 :skolemid |1308|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@119 b@@68) (PivotBetree.TransitionLabel.PutLabel_q a@@119))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@119 b@@68) (PivotBetree.TransitionLabel.PutLabel_q b@@68))
)))
(assert (forall ((a@@120 T@U) (b@@69 T@U) ) (!  (=> (and (and (= (type a@@120) DatatypeTypeType) (= (type b@@69) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q a@@120) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q b@@69))) (= (|PivotBetree.TransitionLabel#Equal| a@@120 b@@69) (= (PivotBetree.TransitionLabel.endLsn a@@120) (PivotBetree.TransitionLabel.endLsn b@@69))))
 :qid |unknown.0:0|
 :skolemid |1309|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@120 b@@69) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q a@@120))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@120 b@@69) (PivotBetree.TransitionLabel.QueryEndLsnLabel_q b@@69))
)))
(assert (forall ((a@@121 T@U) (b@@70 T@U) ) (!  (=> (and (and (= (type a@@121) DatatypeTypeType) (= (type b@@70) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.FreezeAsLabel_q a@@121) (PivotBetree.TransitionLabel.FreezeAsLabel_q b@@70))) (= (|PivotBetree.TransitionLabel#Equal| a@@121 b@@70) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree a@@121) (PivotBetree.TransitionLabel.stampedBetree b@@70))))
 :qid |unknown.0:0|
 :skolemid |1310|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@121 b@@70) (PivotBetree.TransitionLabel.FreezeAsLabel_q a@@121))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@121 b@@70) (PivotBetree.TransitionLabel.FreezeAsLabel_q b@@70))
)))
(assert (forall ((a@@122 T@U) (b@@71 T@U) ) (!  (=> (and (and (= (type a@@122) DatatypeTypeType) (= (type b@@71) DatatypeTypeType)) (and (PivotBetree.TransitionLabel.InternalLabel_q a@@122) (PivotBetree.TransitionLabel.InternalLabel_q b@@71))) (= (|PivotBetree.TransitionLabel#Equal| a@@122 b@@71) true))
 :qid |unknown.0:0|
 :skolemid |1311|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@122 b@@71) (PivotBetree.TransitionLabel.InternalLabel_q a@@122))
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@122 b@@71) (PivotBetree.TransitionLabel.InternalLabel_q b@@71))
)))
(assert (forall ((a@@123 T@U) (b@@72 T@U) ) (!  (=> (and (= (type a@@123) DatatypeTypeType) (= (type b@@72) DatatypeTypeType)) (= (|PivotBetree.TransitionLabel#Equal| a@@123 b@@72) (= a@@123 b@@72)))
 :qid |unknown.0:0|
 :skolemid |1312|
 :pattern ( (|PivotBetree.TransitionLabel#Equal| a@@123 b@@72))
)))
(assert (= (type |#PivotBetree.BetreeNode.Nil|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.BetreeNode.Nil|) |##PivotBetree.BetreeNode.Nil|))
(assert (forall ((d@@34 T@U) ) (!  (=> (= (type d@@34) DatatypeTypeType) (= (PivotBetree.BetreeNode.Nil_q d@@34) (= (DatatypeCtorId d@@34) |##PivotBetree.BetreeNode.Nil|)))
 :qid |unknown.0:0|
 :skolemid |1313|
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@34))
)))
(assert (forall ((d@@35 T@U) ) (!  (=> (and (= (type d@@35) DatatypeTypeType) (PivotBetree.BetreeNode.Nil_q d@@35)) (= d@@35 |#PivotBetree.BetreeNode.Nil|))
 :qid |unknown.0:0|
 :skolemid |1314|
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@35))
)))
(assert ($Is |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode))
(assert (forall (($h@@60 T@U) ) (!  (=> (and (= (type $h@@60) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@60)) ($IsAlloc |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode $h@@60))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |1315|
 :pattern ( ($IsAlloc |#PivotBetree.BetreeNode.Nil| Tclass.PivotBetree.BetreeNode $h@@60))
)))
(assert (= |#PivotBetree.BetreeNode.Nil| (Lit |#PivotBetree.BetreeNode.Nil|)))
(assert (forall ((arg0@@371 T@U) (arg1@@145 T@U) (arg2@@80 T@U) ) (! (= (type (|#PivotBetree.BetreeNode.BetreeNode| arg0@@371 arg1@@145 arg2@@80)) DatatypeTypeType)
 :qid |funType:#PivotBetree.BetreeNode.BetreeNode|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| arg0@@371 arg1@@145 arg2@@80))
)))
(assert (forall ((|a#61#0#0| T@U) (|a#61#1#0| T@U) (|a#61#2#0| T@U) ) (!  (=> (and (and (= (type |a#61#0#0|) DatatypeTypeType) (= (type |a#61#1#0|) (SeqType BoxType))) (= (type |a#61#2#0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.BetreeNode.BetreeNode| |a#61#0#0| |a#61#1#0| |a#61#2#0|)) |##PivotBetree.BetreeNode.BetreeNode|))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1316|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#61#0#0| |a#61#1#0| |a#61#2#0|))
)))
(assert (forall ((d@@36 T@U) ) (!  (=> (= (type d@@36) DatatypeTypeType) (= (PivotBetree.BetreeNode.BetreeNode_q d@@36) (= (DatatypeCtorId d@@36) |##PivotBetree.BetreeNode.BetreeNode|)))
 :qid |unknown.0:0|
 :skolemid |1317|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@36))
)))
(assert (forall ((d@@37 T@U) ) (!  (=> (and (= (type d@@37) DatatypeTypeType) (PivotBetree.BetreeNode.BetreeNode_q d@@37)) (exists ((|a#62#0#0| T@U) (|a#62#1#0| T@U) (|a#62#2#0| T@U) ) (!  (and (and (and (= (type |a#62#0#0|) DatatypeTypeType) (= (type |a#62#1#0|) (SeqType BoxType))) (= (type |a#62#2#0|) (SeqType BoxType))) (= d@@37 (|#PivotBetree.BetreeNode.BetreeNode| |a#62#0#0| |a#62#1#0| |a#62#2#0|)))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1318|
 :no-pattern (type |a#62#0#0|)
 :no-pattern (type |a#62#1#0|)
 :no-pattern (type |a#62#2#0|)
 :no-pattern (U_2_int |a#62#0#0|)
 :no-pattern (U_2_bool |a#62#0#0|)
 :no-pattern (U_2_int |a#62#1#0|)
 :no-pattern (U_2_bool |a#62#1#0|)
 :no-pattern (U_2_int |a#62#2#0|)
 :no-pattern (U_2_bool |a#62#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1319|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@37))
)))
(assert (= (type Tclass.Buffers.BufferStack) TyType))
(assert (= (Tag Tclass.Buffers.BufferStack) Tagclass.Buffers.BufferStack))
(assert (= (TagFamily Tclass.Buffers.BufferStack) tytagFamily$BufferStack))
(assert (forall ((bx@@112 T@U) ) (!  (=> (and (= (type bx@@112) BoxType) ($IsBox bx@@112 Tclass.Buffers.BufferStack)) (and (= ($Box ($Unbox DatatypeTypeType bx@@112)) bx@@112) ($Is ($Unbox DatatypeTypeType bx@@112) Tclass.Buffers.BufferStack)))
 :qid |unknown.0:0|
 :skolemid |1320|
 :pattern ( ($IsBox bx@@112 Tclass.Buffers.BufferStack))
)))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order.Element) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order.Element) Tagclass.Upperbounded__Lexicographic__Byte__Order.Element))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order.Element) tytagFamily$Element))
(assert (forall ((bx@@113 T@U) ) (!  (=> (and (= (type bx@@113) BoxType) ($IsBox bx@@113 Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (= ($Box ($Unbox DatatypeTypeType bx@@113)) bx@@113) ($Is ($Unbox DatatypeTypeType bx@@113) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |unknown.0:0|
 :skolemid |1321|
 :pattern ( ($IsBox bx@@113 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (forall ((|a#63#0#0| T@U) (|a#63#1#0| T@U) (|a#63#2#0| T@U) ) (!  (=> (and (and (= (type |a#63#0#0|) DatatypeTypeType) (= (type |a#63#1#0|) (SeqType BoxType))) (= (type |a#63#2#0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.BetreeNode.BetreeNode| |a#63#0#0| |a#63#1#0| |a#63#2#0|) Tclass.PivotBetree.BetreeNode)  (and (and ($Is |a#63#0#0| Tclass.Buffers.BufferStack) ($Is |a#63#1#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |a#63#2#0| (TSeq Tclass.PivotBetree.BetreeNode)))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1322|
 :pattern ( ($Is (|#PivotBetree.BetreeNode.BetreeNode| |a#63#0#0| |a#63#1#0| |a#63#2#0|) Tclass.PivotBetree.BetreeNode))
)))
(assert (forall ((|a#64#0#0| T@U) (|a#64#1#0| T@U) (|a#64#2#0| T@U) ($h@@61 T@U) ) (!  (=> (and (and (and (and (= (type |a#64#0#0|) DatatypeTypeType) (= (type |a#64#1#0|) (SeqType BoxType))) (= (type |a#64#2#0|) (SeqType BoxType))) (= (type $h@@61) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@61)) (= ($IsAlloc (|#PivotBetree.BetreeNode.BetreeNode| |a#64#0#0| |a#64#1#0| |a#64#2#0|) Tclass.PivotBetree.BetreeNode $h@@61)  (and (and ($IsAlloc |a#64#0#0| Tclass.Buffers.BufferStack $h@@61) ($IsAlloc |a#64#1#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@61)) ($IsAlloc |a#64#2#0| (TSeq Tclass.PivotBetree.BetreeNode) $h@@61))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1323|
 :pattern ( ($IsAlloc (|#PivotBetree.BetreeNode.BetreeNode| |a#64#0#0| |a#64#1#0| |a#64#2#0|) Tclass.PivotBetree.BetreeNode $h@@61))
)))
(assert (forall ((arg0@@372 T@U) ) (! (= (type (PivotBetree.BetreeNode.buffers arg0@@372)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.buffers|
 :pattern ( (PivotBetree.BetreeNode.buffers arg0@@372))
)))
(assert (forall ((d@@38 T@U) ($h@@62 T@U) ) (!  (=> (and (and (= (type d@@38) DatatypeTypeType) (= (type $h@@62) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@62) (and (PivotBetree.BetreeNode.BetreeNode_q d@@38) ($IsAlloc d@@38 Tclass.PivotBetree.BetreeNode $h@@62)))) ($IsAlloc (PivotBetree.BetreeNode.buffers d@@38) Tclass.Buffers.BufferStack $h@@62))
 :qid |unknown.0:0|
 :skolemid |1324|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.buffers d@@38) Tclass.Buffers.BufferStack $h@@62))
)))
(assert (forall ((arg0@@373 T@U) ) (! (= (type (PivotBetree.BetreeNode.pivotTable arg0@@373)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.pivotTable|
 :pattern ( (PivotBetree.BetreeNode.pivotTable arg0@@373))
)))
(assert (forall ((d@@39 T@U) ($h@@63 T@U) ) (!  (=> (and (and (= (type d@@39) DatatypeTypeType) (= (type $h@@63) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@63) (and (PivotBetree.BetreeNode.BetreeNode_q d@@39) ($IsAlloc d@@39 Tclass.PivotBetree.BetreeNode $h@@63)))) ($IsAlloc (PivotBetree.BetreeNode.pivotTable d@@39) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@63))
 :qid |unknown.0:0|
 :skolemid |1325|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.pivotTable d@@39) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $h@@63))
)))
(assert (forall ((arg0@@374 T@U) ) (! (= (type (PivotBetree.BetreeNode.children arg0@@374)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.children|
 :pattern ( (PivotBetree.BetreeNode.children arg0@@374))
)))
(assert (forall ((d@@40 T@U) ($h@@64 T@U) ) (!  (=> (and (and (= (type d@@40) DatatypeTypeType) (= (type $h@@64) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@64) (and (PivotBetree.BetreeNode.BetreeNode_q d@@40) ($IsAlloc d@@40 Tclass.PivotBetree.BetreeNode $h@@64)))) ($IsAlloc (PivotBetree.BetreeNode.children d@@40) (TSeq Tclass.PivotBetree.BetreeNode) $h@@64))
 :qid |unknown.0:0|
 :skolemid |1326|
 :pattern ( ($IsAlloc (PivotBetree.BetreeNode.children d@@40) (TSeq Tclass.PivotBetree.BetreeNode) $h@@64))
)))
(assert (forall ((|a#65#0#0| T@U) (|a#65#1#0| T@U) (|a#65#2#0| T@U) ) (!  (=> (and (and (= (type |a#65#0#0|) DatatypeTypeType) (= (type |a#65#1#0|) (SeqType BoxType))) (= (type |a#65#2#0|) (SeqType BoxType))) (= (|#PivotBetree.BetreeNode.BetreeNode| (Lit |a#65#0#0|) (Lit |a#65#1#0|) (Lit |a#65#2#0|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| |a#65#0#0| |a#65#1#0| |a#65#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1327|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| (Lit |a#65#0#0|) (Lit |a#65#1#0|) (Lit |a#65#2#0|)))
)))
(assert (forall ((|a#66#0#0| T@U) (|a#66#1#0| T@U) (|a#66#2#0| T@U) ) (!  (=> (and (and (= (type |a#66#0#0|) DatatypeTypeType) (= (type |a#66#1#0|) (SeqType BoxType))) (= (type |a#66#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.buffers (|#PivotBetree.BetreeNode.BetreeNode| |a#66#0#0| |a#66#1#0| |a#66#2#0|)) |a#66#0#0|))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1328|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#66#0#0| |a#66#1#0| |a#66#2#0|))
)))
(assert (forall ((|a#67#0#0| T@U) (|a#67#1#0| T@U) (|a#67#2#0| T@U) ) (!  (=> (and (and (= (type |a#67#0#0|) DatatypeTypeType) (= (type |a#67#1#0|) (SeqType BoxType))) (= (type |a#67#2#0|) (SeqType BoxType))) (< (DtRank |a#67#0#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#67#0#0| |a#67#1#0| |a#67#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1329|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#67#0#0| |a#67#1#0| |a#67#2#0|))
)))
(assert (forall ((|a#68#0#0| T@U) (|a#68#1#0| T@U) (|a#68#2#0| T@U) ) (!  (=> (and (and (= (type |a#68#0#0|) DatatypeTypeType) (= (type |a#68#1#0|) (SeqType BoxType))) (= (type |a#68#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.pivotTable (|#PivotBetree.BetreeNode.BetreeNode| |a#68#0#0| |a#68#1#0| |a#68#2#0|)) |a#68#1#0|))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1330|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#68#0#0| |a#68#1#0| |a#68#2#0|))
)))
(assert (forall ((|a#69#0#0| T@U) (|a#69#1#0| T@U) (|a#69#2#0| T@U) (i@@25 Int) ) (!  (=> (and (and (and (= (type |a#69#0#0|) DatatypeTypeType) (= (type |a#69#1#0|) (SeqType BoxType))) (= (type |a#69#2#0|) (SeqType BoxType))) (and (<= 0 i@@25) (< i@@25 (|Seq#Length| |a#69#1#0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#69#1#0| i@@25))) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#69#0#0| |a#69#1#0| |a#69#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1331|
 :pattern ( (|Seq#Index| |a#69#1#0| i@@25) (|#PivotBetree.BetreeNode.BetreeNode| |a#69#0#0| |a#69#1#0| |a#69#2#0|))
)))
(assert (forall ((|a#70#0#0| T@U) (|a#70#1#0| T@U) (|a#70#2#0| T@U) ) (!  (=> (and (and (= (type |a#70#0#0|) DatatypeTypeType) (= (type |a#70#1#0|) (SeqType BoxType))) (= (type |a#70#2#0|) (SeqType BoxType))) (< (|Seq#Rank| |a#70#1#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#70#0#0| |a#70#1#0| |a#70#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1332|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#70#0#0| |a#70#1#0| |a#70#2#0|))
)))
(assert (forall ((|a#71#0#0| T@U) (|a#71#1#0| T@U) (|a#71#2#0| T@U) ) (!  (=> (and (and (= (type |a#71#0#0|) DatatypeTypeType) (= (type |a#71#1#0|) (SeqType BoxType))) (= (type |a#71#2#0|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.children (|#PivotBetree.BetreeNode.BetreeNode| |a#71#0#0| |a#71#1#0| |a#71#2#0|)) |a#71#2#0|))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1333|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#71#0#0| |a#71#1#0| |a#71#2#0|))
)))
(assert (forall ((|a#72#0#0| T@U) (|a#72#1#0| T@U) (|a#72#2#0| T@U) (i@@26 Int) ) (!  (=> (and (and (and (= (type |a#72#0#0|) DatatypeTypeType) (= (type |a#72#1#0|) (SeqType BoxType))) (= (type |a#72#2#0|) (SeqType BoxType))) (and (<= 0 i@@26) (< i@@26 (|Seq#Length| |a#72#2#0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#72#2#0| i@@26))) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#72#0#0| |a#72#1#0| |a#72#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1334|
 :pattern ( (|Seq#Index| |a#72#2#0| i@@26) (|#PivotBetree.BetreeNode.BetreeNode| |a#72#0#0| |a#72#1#0| |a#72#2#0|))
)))
(assert (forall ((|a#73#0#0| T@U) (|a#73#1#0| T@U) (|a#73#2#0| T@U) ) (!  (=> (and (and (= (type |a#73#0#0|) DatatypeTypeType) (= (type |a#73#1#0|) (SeqType BoxType))) (= (type |a#73#2#0|) (SeqType BoxType))) (< (|Seq#Rank| |a#73#2#0|) (DtRank (|#PivotBetree.BetreeNode.BetreeNode| |a#73#0#0| |a#73#1#0| |a#73#2#0|))))
 :qid |PivotBetreebrokenidfy.44:5|
 :skolemid |1335|
 :pattern ( (|#PivotBetree.BetreeNode.BetreeNode| |a#73#0#0| |a#73#1#0| |a#73#2#0|))
)))
(assert (forall ((d@@41 T@U) ) (!  (=> (and (= (type d@@41) DatatypeTypeType) (|$IsA#PivotBetree.BetreeNode| d@@41)) (or (PivotBetree.BetreeNode.Nil_q d@@41) (PivotBetree.BetreeNode.BetreeNode_q d@@41)))
 :qid |unknown.0:0|
 :skolemid |1336|
 :pattern ( (|$IsA#PivotBetree.BetreeNode| d@@41))
)))
(assert (forall ((d@@42 T@U) ) (!  (=> (and (= (type d@@42) DatatypeTypeType) ($Is d@@42 Tclass.PivotBetree.BetreeNode)) (or (PivotBetree.BetreeNode.Nil_q d@@42) (PivotBetree.BetreeNode.BetreeNode_q d@@42)))
 :qid |unknown.0:0|
 :skolemid |1337|
 :pattern ( (PivotBetree.BetreeNode.BetreeNode_q d@@42) ($Is d@@42 Tclass.PivotBetree.BetreeNode))
 :pattern ( (PivotBetree.BetreeNode.Nil_q d@@42) ($Is d@@42 Tclass.PivotBetree.BetreeNode))
)))
(assert (forall ((a@@124 T@U) (b@@73 T@U) ) (!  (=> (and (and (= (type a@@124) DatatypeTypeType) (= (type b@@73) DatatypeTypeType)) (and (PivotBetree.BetreeNode.Nil_q a@@124) (PivotBetree.BetreeNode.Nil_q b@@73))) (= (|PivotBetree.BetreeNode#Equal| a@@124 b@@73) true))
 :qid |unknown.0:0|
 :skolemid |1338|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@124 b@@73) (PivotBetree.BetreeNode.Nil_q a@@124))
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@124 b@@73) (PivotBetree.BetreeNode.Nil_q b@@73))
)))
(assert (forall ((a@@125 T@U) (b@@74 T@U) ) (!  (=> (and (and (= (type a@@125) DatatypeTypeType) (= (type b@@74) DatatypeTypeType)) (and (PivotBetree.BetreeNode.BetreeNode_q a@@125) (PivotBetree.BetreeNode.BetreeNode_q b@@74))) (= (|PivotBetree.BetreeNode#Equal| a@@125 b@@74)  (and (and (|Buffers.BufferStack#Equal| (PivotBetree.BetreeNode.buffers a@@125) (PivotBetree.BetreeNode.buffers b@@74)) (|Seq#Equal| (PivotBetree.BetreeNode.pivotTable a@@125) (PivotBetree.BetreeNode.pivotTable b@@74))) (|Seq#Equal| (PivotBetree.BetreeNode.children a@@125) (PivotBetree.BetreeNode.children b@@74)))))
 :qid |unknown.0:0|
 :skolemid |1339|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@125 b@@74) (PivotBetree.BetreeNode.BetreeNode_q a@@125))
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@125 b@@74) (PivotBetree.BetreeNode.BetreeNode_q b@@74))
)))
(assert (forall ((a@@126 T@U) (b@@75 T@U) ) (!  (=> (and (= (type a@@126) DatatypeTypeType) (= (type b@@75) DatatypeTypeType)) (= (|PivotBetree.BetreeNode#Equal| a@@126 b@@75) (= a@@126 b@@75)))
 :qid |unknown.0:0|
 :skolemid |1340|
 :pattern ( (|PivotBetree.BetreeNode#Equal| a@@126 b@@75))
)))
(assert  (=> (<= 14 $FunctionContextHeight) (forall ((this T@U) ) (!  (=> (and (= (type this) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| this) (and (not (= 14 $FunctionContextHeight)) ($Is this Tclass.PivotBetree.BetreeNode)))) true)
 :qid |PivotBetreebrokenidfy.48:15|
 :skolemid |1341|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure this))
))))
(assert (forall ((this@@0 T@U) ) (!  (=> (and (= (type this@@0) DatatypeTypeType) ($Is this@@0 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.LocalStructure#requires| this@@0) true))
 :qid |PivotBetreebrokenidfy.48:15|
 :skolemid |1342|
 :pattern ( (|PivotBetree.BetreeNode.LocalStructure#requires| this@@0))
)))
(assert  (=> (<= 14 $FunctionContextHeight) (forall ((this@@1 T@U) ) (!  (=> (and (= (type this@@1) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| this@@1) (and (not (= 14 $FunctionContextHeight)) ($Is this@@1 Tclass.PivotBetree.BetreeNode)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@1) (and (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable this@@1)) (=> (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable this@@1)) (|BoundedPivotsLib.__default.NumBuckets#canCall| (PivotBetree.BetreeNode.pivotTable this@@1)))))) (= (PivotBetree.BetreeNode.LocalStructure this@@1)  (and true (=> (PivotBetree.BetreeNode.BetreeNode_q this@@1) (and (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable this@@1)) (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@1)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable this@@1)))))))))
 :qid |PivotBetreebrokenidfy.48:15|
 :skolemid |1343|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure this@@1))
))))
(assert  (=> (<= 14 $FunctionContextHeight) (forall ((this@@2 T@U) ) (!  (=> (and (= (type this@@2) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LocalStructure#canCall| (Lit this@@2)) (and (not (= 14 $FunctionContextHeight)) ($Is this@@2 Tclass.PivotBetree.BetreeNode)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@2))))) (and (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@2)))) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@2))))))) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@2)))))))) (= (PivotBetree.BetreeNode.LocalStructure (Lit this@@2))  (and true (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@2)) (and (BoundedPivotsLib.__default.WFPivots (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@2)))) (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@2)))) (LitInt (BoundedPivotsLib.__default.NumBuckets (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@2))))))))))))
 :qid |PivotBetreebrokenidfy.48:15|
 :weight 3
 :skolemid |1344|
 :pattern ( (PivotBetree.BetreeNode.LocalStructure (Lit this@@2)))
))))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((this@@3 T@U) (|childIdx#0| Int) ) (!  (=> (and (= (type this@@3) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@3 |childIdx#0|) (and (not (= 13 $FunctionContextHeight)) (and ($Is this@@3 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0|))))) true)
 :qid |PivotBetreebrokenidfy.56:15|
 :skolemid |1347|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@3 |childIdx#0|))
))))
(assert (forall ((this@@4 T@U) (|childIdx#0@@0| Int) ) (!  (=> (= (type this@@4) DatatypeTypeType) (=> (and ($Is this@@4 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@0|)) (= (|PivotBetree.BetreeNode.ValidChildIndex#requires| this@@4 |childIdx#0@@0|) true)))
 :qid |PivotBetreebrokenidfy.56:15|
 :skolemid |1348|
 :pattern ( (|PivotBetree.BetreeNode.ValidChildIndex#requires| this@@4 |childIdx#0@@0|))
)))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((this@@5 T@U) (|childIdx#0@@1| Int) ) (!  (=> (and (= (type this@@5) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@5 |childIdx#0@@1|) (and (not (= 13 $FunctionContextHeight)) (and ($Is this@@5 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@1|))))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@5) (|BoundedPivotsLib.__default.NumBuckets#canCall| (PivotBetree.BetreeNode.pivotTable this@@5))) (= (PivotBetree.BetreeNode.ValidChildIndex this@@5 |childIdx#0@@1|)  (and (PivotBetree.BetreeNode.BetreeNode_q this@@5) (INTERNAL_lt_boogie |childIdx#0@@1| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable this@@5)))))))
 :qid |PivotBetreebrokenidfy.56:15|
 :skolemid |1349|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@5 |childIdx#0@@1|))
))))
(assert  (=> (<= 13 $FunctionContextHeight) (forall ((this@@6 T@U) (|childIdx#0@@2| Int) ) (!  (=> (and (= (type this@@6) DatatypeTypeType) (or (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@6) (LitInt |childIdx#0@@2|)) (and (not (= 13 $FunctionContextHeight)) (and ($Is this@@6 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@2|))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@6))))) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@6))))) (= (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@6) (LitInt |childIdx#0@@2|)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@6)) (INTERNAL_lt_boogie |childIdx#0@@2| (BoundedPivotsLib.__default.NumBuckets (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@6))))))))))))
 :qid |PivotBetreebrokenidfy.56:15|
 :weight 3
 :skolemid |1350|
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@6) (LitInt |childIdx#0@@2|)))
))))
(assert  (=> (<= 18 $FunctionContextHeight) (forall ((this@@7 T@U) ) (!  (=> (and (= (type this@@7) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@7) (and (not (= 18 $FunctionContextHeight)) (and ($Is this@@7 Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.LocalStructure this@@7))))) true)
 :qid |PivotBetreebrokenidfy.62:15|
 :skolemid |1352|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren this@@7))
))))
(assert (forall ((this@@8 T@U) ) (!  (=> (and (= (type this@@8) DatatypeTypeType) ($Is this@@8 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.LinkedChildren#requires| this@@8) (PivotBetree.BetreeNode.LocalStructure this@@8)))
 :qid |PivotBetreebrokenidfy.62:15|
 :skolemid |1353|
 :pattern ( (|PivotBetree.BetreeNode.LinkedChildren#requires| this@@8))
)))
(assert  (and (forall ((arg0@@375 T@U) (arg1@@146 Int) ) (! (= (type (PivotBetree.BetreeNode.DomainRoutedToChild arg0@@375 arg1@@146)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.DomainRoutedToChild|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild arg0@@375 arg1@@146))
)) (forall ((arg0@@376 T@U) ) (! (= (type (PivotBetree.BetreeNode.MyDomain arg0@@376)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.MyDomain|
 :pattern ( (PivotBetree.BetreeNode.MyDomain arg0@@376))
))))
(assert  (=> (<= 18 $FunctionContextHeight) (forall ((this@@9 T@U) ) (!  (=> (and (= (type this@@9) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@9) (and (not (= 18 $FunctionContextHeight)) (and ($Is this@@9 Tclass.PivotBetree.BetreeNode) (PivotBetree.BetreeNode.LocalStructure this@@9))))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@9) (forall ((|i#0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0|) (and (and (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@9 |i#0|) (=> (PivotBetree.BetreeNode.ValidChildIndex this@@9 |i#0|) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|))) (|PivotBetree.BetreeNode.LocalStructure#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|)))))) (=> (and (and (PivotBetree.BetreeNode.ValidChildIndex this@@9 |i#0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|)))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.DomainRoutedToChild this@@9 |i#0|))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@9 |i#0|))))))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |1355|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@9 |i#0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@9 |i#0|))
))) (= (PivotBetree.BetreeNode.LinkedChildren this@@9)  (=> (PivotBetree.BetreeNode.BetreeNode_q this@@9) (forall ((|i#0@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@0|) (and (and (PivotBetree.BetreeNode.ValidChildIndex this@@9 |i#0@@0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0@@0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0@@0|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0@@0|))) (PivotBetree.BetreeNode.DomainRoutedToChild this@@9 |i#0@@0|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |1354|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@9 |i#0@@0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@9) |i#0@@0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@9 |i#0@@0|))
))))))
 :qid |PivotBetreebrokenidfy.62:15|
 :skolemid |1356|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren this@@9))
))))
(assert  (=> (<= 18 $FunctionContextHeight) (forall ((this@@10 T@U) ) (!  (=> (and (= (type this@@10) DatatypeTypeType) (or (|PivotBetree.BetreeNode.LinkedChildren#canCall| (Lit this@@10)) (and (not (= 18 $FunctionContextHeight)) (and ($Is this@@10 Tclass.PivotBetree.BetreeNode) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@10))))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@10))))) (forall ((|i#1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1|) (and (and (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@10) |i#1|) (=> (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@10) |i#1|) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|))) (|PivotBetree.BetreeNode.LocalStructure#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|)))))) (=> (and (and (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@10) |i#1|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|)))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@10) |i#1|))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1|))) (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@10) |i#1|))))))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |1358|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@10 |i#1|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@10) |i#1|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@10 |i#1|))
))) (= (PivotBetree.BetreeNode.LinkedChildren (Lit this@@10))  (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@10)) (forall ((|i#1@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@0|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@10) |i#1@@0|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1@@0|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1@@0|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@10))) |i#1@@0|))) (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@10) |i#1@@0|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |1357|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@10 |i#1@@0|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@10) |i#1@@0|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex this@@10 |i#1@@0|))
))))))
 :qid |PivotBetreebrokenidfy.62:15|
 :weight 3
 :skolemid |1359|
 :pattern ( (PivotBetree.BetreeNode.LinkedChildren (Lit this@@10)))
))))
(assert (forall (($ly T@U) (this@@11 T@U) ) (!  (=> (and (= (type $ly) LayerTypeType) (= (type this@@11) DatatypeTypeType)) (= (PivotBetree.BetreeNode.WF ($LS $ly) this@@11) (PivotBetree.BetreeNode.WF $ly this@@11)))
 :qid |PivotBetreebrokenidfy.73:15|
 :skolemid |1375|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly) this@@11))
)))
(assert  (and (forall ((arg0@@377 T@U) ) (! (= (type (AsFuelBottom arg0@@377)) LayerTypeType)
 :qid |funType:AsFuelBottom|
 :pattern ( (AsFuelBottom arg0@@377))
)) (= (type $LZ) LayerTypeType)))
(assert (forall (($ly@@0 T@U) (this@@12 T@U) ) (!  (=> (and (= (type $ly@@0) LayerTypeType) (= (type this@@12) DatatypeTypeType)) (= (PivotBetree.BetreeNode.WF $ly@@0 this@@12) (PivotBetree.BetreeNode.WF $LZ this@@12)))
 :qid |PivotBetreebrokenidfy.73:15|
 :skolemid |1376|
 :pattern ( (PivotBetree.BetreeNode.WF (AsFuelBottom $ly@@0) this@@12))
)))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@1 T@U) (this@@13 T@U) ) (!  (=> (and (and (= (type $ly@@1) LayerTypeType) (= (type this@@13) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| this@@13) (and (not (= 19 $FunctionContextHeight)) ($Is this@@13 Tclass.PivotBetree.BetreeNode)))) true)
 :qid |PivotBetreebrokenidfy.73:15|
 :skolemid |1377|
 :pattern ( (PivotBetree.BetreeNode.WF $ly@@1 this@@13))
))))
(assert (forall (($ly@@2 T@U) (this@@14 T@U) ) (!  (=> (and (and (= (type $ly@@2) LayerTypeType) (= (type this@@14) DatatypeTypeType)) ($Is this@@14 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.WF#requires| $ly@@2 this@@14) true))
 :qid |PivotBetreebrokenidfy.73:15|
 :skolemid |1378|
 :pattern ( (|PivotBetree.BetreeNode.WF#requires| $ly@@2 this@@14))
)))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@3 T@U) (this@@15 T@U) ) (!  (=> (and (and (= (type $ly@@3) LayerTypeType) (= (type this@@15) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| this@@15) (and (not (= 19 $FunctionContextHeight)) ($Is this@@15 Tclass.PivotBetree.BetreeNode)))) (and (and (|PivotBetree.BetreeNode.LocalStructure#canCall| this@@15) (=> (PivotBetree.BetreeNode.LocalStructure this@@15) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@15) (and (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children this@@15)) (=> (PivotBetree.__default.WFChildren $ly@@3 (PivotBetree.BetreeNode.children this@@15)) (|PivotBetree.BetreeNode.LinkedChildren#canCall| this@@15)))))) (= (PivotBetree.BetreeNode.WF ($LS $ly@@3) this@@15)  (and (PivotBetree.BetreeNode.LocalStructure this@@15) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@15) (and (PivotBetree.__default.WFChildren $ly@@3 (PivotBetree.BetreeNode.children this@@15)) (PivotBetree.BetreeNode.LinkedChildren this@@15)))))))
 :qid |PivotBetreebrokenidfy.73:15|
 :skolemid |1379|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly@@3) this@@15))
))))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@4 T@U) (this@@16 T@U) ) (!  (=> (and (and (= (type $ly@@4) LayerTypeType) (= (type this@@16) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@16)) (and (not (= 19 $FunctionContextHeight)) ($Is this@@16 Tclass.PivotBetree.BetreeNode)))) (and (and (|PivotBetree.BetreeNode.LocalStructure#canCall| (Lit this@@16)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@16))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@16))))) (and (|PivotBetree.__default.WFChildren#canCall| (Lit (PivotBetree.BetreeNode.children (Lit this@@16)))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.__default.WFChildren ($LS $ly@@4) (Lit (PivotBetree.BetreeNode.children (Lit this@@16))))))) (|PivotBetree.BetreeNode.LinkedChildren#canCall| (Lit this@@16))))))) (= (PivotBetree.BetreeNode.WF ($LS $ly@@4) (Lit this@@16)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.LocalStructure (Lit this@@16)) (=> (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@16)) (and (PivotBetree.__default.WFChildren ($LS $ly@@4) (Lit (PivotBetree.BetreeNode.children (Lit this@@16)))) (PivotBetree.BetreeNode.LinkedChildren (Lit this@@16)))))))))))
 :qid |PivotBetreebrokenidfy.73:15|
 :weight 3
 :skolemid |1380|
 :pattern ( (PivotBetree.BetreeNode.WF ($LS $ly@@4) (Lit this@@16)))
))))
(assert (forall ((arg0@@378 T@U) (arg1@@147 T@U) ) (! (= (type (PivotBetree.BetreeNode.PushBufferStack arg0@@378 arg1@@147)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.PushBufferStack|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack arg0@@378 arg1@@147))
)))
(assert  (=> (<= 20 $FunctionContextHeight) (forall ((this@@17 T@U) (|bufferStack#0| T@U) ) (!  (=> (and (and (= (type this@@17) DatatypeTypeType) (= (type |bufferStack#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| this@@17 |bufferStack#0|) (and (not (= 20 $FunctionContextHeight)) (and (and ($Is this@@17 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@17) (PivotBetree.BetreeNode.BetreeNode_q this@@17)))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.PushBufferStack this@@17 |bufferStack#0|)) ($Is (PivotBetree.BetreeNode.PushBufferStack this@@17 |bufferStack#0|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.81:14|
 :skolemid |1388|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack this@@17 |bufferStack#0|))
))))
(assert (forall ((this@@18 T@U) (|bufferStack#0@@0| T@U) ) (!  (=> (and (and (= (type this@@18) DatatypeTypeType) (= (type |bufferStack#0@@0|) DatatypeTypeType)) (and ($Is this@@18 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@0| Tclass.Buffers.BufferStack))) (= (|PivotBetree.BetreeNode.PushBufferStack#requires| this@@18 |bufferStack#0@@0|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@18) (PivotBetree.BetreeNode.BetreeNode_q this@@18))))
 :qid |PivotBetreebrokenidfy.81:14|
 :skolemid |1389|
 :pattern ( (|PivotBetree.BetreeNode.PushBufferStack#requires| this@@18 |bufferStack#0@@0|))
)))
(assert (forall ((arg0@@379 T@U) (arg1@@148 T@U) ) (! (= (type (Buffers.BufferStack.PushBufferStack arg0@@379 arg1@@148)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.PushBufferStack|
 :pattern ( (Buffers.BufferStack.PushBufferStack arg0@@379 arg1@@148))
)))
(assert  (=> (<= 20 $FunctionContextHeight) (forall ((this@@19 T@U) (|bufferStack#0@@1| T@U) ) (!  (=> (and (and (= (type this@@19) DatatypeTypeType) (= (type |bufferStack#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| this@@19 |bufferStack#0@@1|) (and (not (= 20 $FunctionContextHeight)) (and (and ($Is this@@19 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@1| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@19) (PivotBetree.BetreeNode.BetreeNode_q this@@19)))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (PivotBetree.BetreeNode.buffers this@@19) |bufferStack#0@@1|) (= (PivotBetree.BetreeNode.PushBufferStack this@@19 |bufferStack#0@@1|) (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.PushBufferStack (PivotBetree.BetreeNode.buffers this@@19) |bufferStack#0@@1|) (PivotBetree.BetreeNode.pivotTable this@@19) (PivotBetree.BetreeNode.children this@@19)))))
 :qid |PivotBetreebrokenidfy.81:14|
 :skolemid |1390|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack this@@19 |bufferStack#0@@1|))
))))
(assert  (=> (<= 20 $FunctionContextHeight) (forall ((this@@20 T@U) (|bufferStack#0@@2| T@U) ) (!  (=> (and (and (= (type this@@20) DatatypeTypeType) (= (type |bufferStack#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.PushBufferStack#canCall| (Lit this@@20) (Lit |bufferStack#0@@2|)) (and (not (= 20 $FunctionContextHeight)) (and (and ($Is this@@20 Tclass.PivotBetree.BetreeNode) ($Is |bufferStack#0@@2| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@20))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@20)))))))))) (and (|Buffers.BufferStack.PushBufferStack#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@20))) (Lit |bufferStack#0@@2|)) (= (PivotBetree.BetreeNode.PushBufferStack (Lit this@@20) (Lit |bufferStack#0@@2|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.PushBufferStack (Lit (PivotBetree.BetreeNode.buffers (Lit this@@20))) (Lit |bufferStack#0@@2|))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@20))) (Lit (PivotBetree.BetreeNode.children (Lit this@@20))))))))
 :qid |PivotBetreebrokenidfy.81:14|
 :weight 3
 :skolemid |1391|
 :pattern ( (PivotBetree.BetreeNode.PushBufferStack (Lit this@@20) (Lit |bufferStack#0@@2|)))
))))
(assert  (=> (<= 22 $FunctionContextHeight) (forall ((this@@21 T@U) ) (!  (=> (and (= (type this@@21) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| this@@21) (and (not (= 22 $FunctionContextHeight)) ($Is this@@21 Tclass.PivotBetree.BetreeNode)))) true)
 :qid |PivotBetreebrokenidfy.89:15|
 :skolemid |1400|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf this@@21))
))))
(assert (forall ((this@@22 T@U) ) (!  (=> (and (= (type this@@22) DatatypeTypeType) ($Is this@@22 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.IsLeaf#requires| this@@22) true))
 :qid |PivotBetreebrokenidfy.89:15|
 :skolemid |1401|
 :pattern ( (|PivotBetree.BetreeNode.IsLeaf#requires| this@@22))
)))
(assert  (=> (<= 22 $FunctionContextHeight) (forall ((this@@23 T@U) ) (!  (=> (and (= (type this@@23) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| this@@23) (and (not (= 22 $FunctionContextHeight)) ($Is this@@23 Tclass.PivotBetree.BetreeNode)))) (and (=> (PivotBetree.BetreeNode.BetreeNode_q this@@23) (=> (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@23)) (LitInt 1)) (|$IsA#PivotBetree.BetreeNode| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@23) (LitInt 0)))))) (= (PivotBetree.BetreeNode.IsLeaf this@@23)  (and (and (PivotBetree.BetreeNode.BetreeNode_q this@@23) (= (|Seq#Length| (PivotBetree.BetreeNode.children this@@23)) (LitInt 1))) (|PivotBetree.BetreeNode#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@23) (LitInt 0))) |#PivotBetree.BetreeNode.Nil|)))))
 :qid |PivotBetreebrokenidfy.89:15|
 :skolemid |1402|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf this@@23))
))))
(assert  (=> (<= 22 $FunctionContextHeight) (forall ((this@@24 T@U) ) (!  (=> (and (= (type this@@24) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsLeaf#canCall| (Lit this@@24)) (and (not (= 22 $FunctionContextHeight)) ($Is this@@24 Tclass.PivotBetree.BetreeNode)))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@24))))) (=> (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@24)))) (LitInt 1)) (|$IsA#PivotBetree.BetreeNode| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@24))) (LitInt 0)))))) (= (PivotBetree.BetreeNode.IsLeaf (Lit this@@24))  (and (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@24)) (= (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@24)))) (LitInt 1))) (|PivotBetree.BetreeNode#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@24))) (LitInt 0))) |#PivotBetree.BetreeNode.Nil|)))))
 :qid |PivotBetreebrokenidfy.89:15|
 :weight 3
 :skolemid |1403|
 :pattern ( (PivotBetree.BetreeNode.IsLeaf (Lit this@@24)))
))))
(assert  (=> (<= 24 $FunctionContextHeight) (forall ((this@@25 T@U) ) (!  (=> (and (= (type this@@25) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| this@@25) (and (not (= 24 $FunctionContextHeight)) ($Is this@@25 Tclass.PivotBetree.BetreeNode)))) true)
 :qid |PivotBetreebrokenidfy.96:15|
 :skolemid |1404|
 :pattern ( (PivotBetree.BetreeNode.IsIndex this@@25))
))))
(assert (forall ((this@@26 T@U) ) (!  (=> (and (= (type this@@26) DatatypeTypeType) ($Is this@@26 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.IsIndex#requires| this@@26) true))
 :qid |PivotBetreebrokenidfy.96:15|
 :skolemid |1405|
 :pattern ( (|PivotBetree.BetreeNode.IsIndex#requires| this@@26))
)))
(assert  (=> (<= 24 $FunctionContextHeight) (forall ((this@@27 T@U) ) (!  (=> (and (= (type this@@27) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| this@@27) (and (not (= 24 $FunctionContextHeight)) ($Is this@@27 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.IsIndex this@@27)  (and (PivotBetree.BetreeNode.BetreeNode_q this@@27) (forall ((|i#0@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@1|) (INTERNAL_lt_boogie |i#0@@1| (|Seq#Length| (PivotBetree.BetreeNode.children this@@27)))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@27) |i#0@@1|))))
 :qid |PivotBetreebrokenidfy.99:18|
 :skolemid |1406|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@27) |i#0@@1|)))
)))))
 :qid |PivotBetreebrokenidfy.96:15|
 :skolemid |1407|
 :pattern ( (PivotBetree.BetreeNode.IsIndex this@@27))
))))
(assert  (=> (<= 24 $FunctionContextHeight) (forall ((this@@28 T@U) ) (!  (=> (and (= (type this@@28) DatatypeTypeType) (or (|PivotBetree.BetreeNode.IsIndex#canCall| (Lit this@@28)) (and (not (= 24 $FunctionContextHeight)) ($Is this@@28 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.IsIndex (Lit this@@28))  (and (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@28)) (forall ((|i#1@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@1|) (INTERNAL_lt_boogie |i#1@@1| (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit this@@28)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@28))) |i#1@@1|))))
 :qid |PivotBetreebrokenidfy.99:18|
 :skolemid |1408|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@28) |i#1@@1|)))
)))))
 :qid |PivotBetreebrokenidfy.96:15|
 :weight 3
 :skolemid |1409|
 :pattern ( (PivotBetree.BetreeNode.IsIndex (Lit this@@28)))
))))
(assert  (and (and (forall ((arg0@@380 T@U) (arg1@@149 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitLeaf arg0@@380 arg1@@149)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitLeaf|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf arg0@@380 arg1@@149))
)) (forall ((arg0@@381 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.Element.e arg0@@381)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.Element.e|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.e arg0@@381))
))) (forall ((arg0@@382 T@U) ) (! (= (type (DomainMod.Domain.start arg0@@382)) DatatypeTypeType)
 :qid |funType:DomainMod.Domain.start|
 :pattern ( (DomainMod.Domain.start arg0@@382))
))))
(assert  (=> (<= 23 $FunctionContextHeight) (forall ((this@@29 T@U) (|splitKey#0| T@U) ) (!  (=> (and (and (= (type this@@29) DatatypeTypeType) (= (type |splitKey#0|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| this@@29 |splitKey#0|) (and (not (= 23 $FunctionContextHeight)) (and (and ($Is this@@29 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0| Tclass.KeyType.Key)) (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@29) (PivotBetree.BetreeNode.IsLeaf this@@29)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@29) |splitKey#0|)) (not (|Seq#Equal| |splitKey#0| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@29)))))))))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._0 (PivotBetree.BetreeNode.SplitLeaf this@@29 |splitKey#0|)))) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._1 (PivotBetree.BetreeNode.SplitLeaf this@@29 |splitKey#0|))))) ($Is (PivotBetree.BetreeNode.SplitLeaf this@@29 |splitKey#0|) (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreebrokenidfy.103:14|
 :skolemid |1411|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf this@@29 |splitKey#0|))
))))
(assert (forall ((this@@30 T@U) (|splitKey#0@@0| T@U) ) (!  (=> (and (and (= (type this@@30) DatatypeTypeType) (= (type |splitKey#0@@0|) (SeqType BoxType))) (and ($Is this@@30 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@0| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.SplitLeaf#requires| this@@30 |splitKey#0@@0|)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@30) (PivotBetree.BetreeNode.IsLeaf this@@30)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@30) |splitKey#0@@0|)) (not (|Seq#Equal| |splitKey#0@@0| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@30))))))))
 :qid |PivotBetreebrokenidfy.103:14|
 :skolemid |1412|
 :pattern ( (|PivotBetree.BetreeNode.SplitLeaf#requires| this@@30 |splitKey#0@@0|))
)))
(assert  (and (and (and (and (forall ((arg0@@383 T@U) (arg1@@150 T@U) ) (! (= (type (|#DomainMod.Domain.Domain| arg0@@383 arg1@@150)) DatatypeTypeType)
 :qid |funType:#DomainMod.Domain.Domain|
 :pattern ( (|#DomainMod.Domain.Domain| arg0@@383 arg1@@150))
)) (forall ((arg0@@384 T@U) ) (! (= (type (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| arg0@@384)) DatatypeTypeType)
 :qid |funType:#Upperbounded_Lexicographic_Byte_Order.Element.Element|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| arg0@@384))
))) (forall ((arg0@@385 T@U) ) (! (= (type (DomainMod.Domain.end arg0@@385)) DatatypeTypeType)
 :qid |funType:DomainMod.Domain.end|
 :pattern ( (DomainMod.Domain.end arg0@@385))
))) (forall ((arg0@@386 T@U) ) (! (= (type (DomainMod.Domain.KeySet arg0@@386)) (MapType0Type BoxType boolType))
 :qid |funType:DomainMod.Domain.KeySet|
 :pattern ( (DomainMod.Domain.KeySet arg0@@386))
))) (forall ((arg0@@387 T@U) (arg1@@151 T@U) ) (! (= (type (Buffers.BufferStack.ApplyFilter arg0@@387 arg1@@151)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.ApplyFilter|
 :pattern ( (Buffers.BufferStack.ApplyFilter arg0@@387 arg1@@151))
))))
(assert  (=> (<= 23 $FunctionContextHeight) (forall ((this@@31 T@U) (|splitKey#0@@1| T@U) ) (!  (=> (and (and (= (type this@@31) DatatypeTypeType) (= (type |splitKey#0@@1|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| this@@31 |splitKey#0@@1|) (and (not (= 23 $FunctionContextHeight)) (and (and ($Is this@@31 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@1| Tclass.KeyType.Key)) (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@31) (PivotBetree.BetreeNode.IsLeaf this@@31)) (DomainMod.Domain.Contains (PivotBetree.BetreeNode.MyDomain this@@31) |splitKey#0@@1|)) (not (|Seq#Equal| |splitKey#0@@1| (Upperbounded__Lexicographic__Byte__Order.Element.e (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@31)))))))))) (and (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@31) (let ((|leftFilter#0| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@31)) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@31) (let ((|rightFilter#0| (|#DomainMod.Domain.Domain| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|) (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@31)))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#0|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@31) (DomainMod.Domain.KeySet |leftFilter#0|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#0|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@31) (DomainMod.Domain.KeySet |rightFilter#0|)))))))) (= (PivotBetree.BetreeNode.SplitLeaf this@@31 |splitKey#0@@1|) (let ((|leftFilter#0@@0| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@31)) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))))
(let ((|rightFilter#0@@0| (|#DomainMod.Domain.Domain| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|) (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@31)))))
(let ((|newLeft#0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@31) (DomainMod.Domain.KeySet |leftFilter#0@@0|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@31) (LitInt 0))) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(let ((|newRight#0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@31) (DomainMod.Domain.KeySet |rightFilter#0@@0|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |splitKey#0@@1|))) (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@31) (LitInt 1))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#0|) ($Box |newRight#0|)))))))))
 :qid |PivotBetreebrokenidfy.103:14|
 :skolemid |1413|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf this@@31 |splitKey#0@@1|))
))))
(assert  (=> (<= 23 $FunctionContextHeight) (forall ((this@@32 T@U) (|splitKey#0@@2| T@U) ) (!  (=> (and (and (= (type this@@32) DatatypeTypeType) (= (type |splitKey#0@@2|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.SplitLeaf#canCall| (Lit this@@32) (Lit |splitKey#0@@2|)) (and (not (= 23 $FunctionContextHeight)) (and (and ($Is this@@32 Tclass.PivotBetree.BetreeNode) ($Is |splitKey#0@@2| Tclass.KeyType.Key)) (and (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@32))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.IsLeaf (Lit this@@32)))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Contains (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32))) (Lit |splitKey#0@@2|)))))) (not (|Seq#Equal| |splitKey#0@@2| (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32))))))))))))) (and (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@32)) (let ((|leftFilter#1| (Lit (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32))))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|)))))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@32)) (let ((|rightFilter#1| (Lit (|#DomainMod.Domain.Domain| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))) (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32)))))))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@32))) (DomainMod.Domain.KeySet |leftFilter#1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@32))) (DomainMod.Domain.KeySet |rightFilter#1|)))))))) (= (PivotBetree.BetreeNode.SplitLeaf (Lit this@@32) (Lit |splitKey#0@@2|)) (let ((|leftFilter#1@@0| (Lit (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32))))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|)))))))
(let ((|rightFilter#1@@0| (Lit (|#DomainMod.Domain.Domain| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))) (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@32)))))))))
(let ((|newLeft#1| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@32))) (Lit (DomainMod.Domain.KeySet |leftFilter#1@@0|)))) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@32))) (LitInt 0))) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(let ((|newRight#1| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@32))) (Lit (DomainMod.Domain.KeySet |rightFilter#1@@0|)))) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |splitKey#0@@2|))))) (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@32))) (LitInt 1))) (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#1|) ($Box |newRight#1|)))))))))
 :qid |PivotBetreebrokenidfy.103:14|
 :weight 3
 :skolemid |1414|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf (Lit this@@32) (Lit |splitKey#0@@2|)))
))))
(assert (= (type Tclass.DomainMod.Domain) TyType))
(assert (= (Tag Tclass.DomainMod.Domain) Tagclass.DomainMod.Domain))
(assert (= (TagFamily Tclass.DomainMod.Domain) tytagFamily$Domain))
(assert (forall ((bx@@114 T@U) ) (!  (=> (and (= (type bx@@114) BoxType) ($IsBox bx@@114 Tclass.DomainMod.Domain)) (and (= ($Box ($Unbox DatatypeTypeType bx@@114)) bx@@114) ($Is ($Unbox DatatypeTypeType bx@@114) Tclass.DomainMod.Domain)))
 :qid |unknown.0:0|
 :skolemid |1434|
 :pattern ( ($IsBox bx@@114 Tclass.DomainMod.Domain))
)))
(assert (forall ((arg0@@388 T@U) (arg1@@152 Int) ) (! (= (type (PivotBetree.BetreeNode.SplitIndex arg0@@388 arg1@@152)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitIndex|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex arg0@@388 arg1@@152))
)))
(assert  (=> (<= 25 $FunctionContextHeight) (forall ((this@@33 T@U) (|pivotIdx#0| Int) ) (!  (=> (and (= (type this@@33) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| this@@33 |pivotIdx#0|) (and (not (= 25 $FunctionContextHeight)) (and (and ($Is this@@33 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@33) (PivotBetree.BetreeNode.IsIndex this@@33)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0|) (INTERNAL_lt_boogie |pivotIdx#0| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@33)) 1)))))))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._0 (PivotBetree.BetreeNode.SplitIndex this@@33 |pivotIdx#0|)))) (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (_System.Tuple2._1 (PivotBetree.BetreeNode.SplitIndex this@@33 |pivotIdx#0|))))) ($Is (PivotBetree.BetreeNode.SplitIndex this@@33 |pivotIdx#0|) (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreebrokenidfy.121:14|
 :skolemid |1467|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex this@@33 |pivotIdx#0|))
))))
(assert (forall ((this@@34 T@U) (|pivotIdx#0@@0| Int) ) (!  (=> (= (type this@@34) DatatypeTypeType) (=> (and ($Is this@@34 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@0|)) (= (|PivotBetree.BetreeNode.SplitIndex#requires| this@@34 |pivotIdx#0@@0|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@34) (PivotBetree.BetreeNode.IsIndex this@@34)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@0|) (INTERNAL_lt_boogie |pivotIdx#0@@0| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@34)) 1)))))))
 :qid |PivotBetreebrokenidfy.121:14|
 :skolemid |1468|
 :pattern ( (|PivotBetree.BetreeNode.SplitIndex#requires| this@@34 |pivotIdx#0@@0|))
)))
(assert  (=> (<= 25 $FunctionContextHeight) (forall ((this@@35 T@U) (|pivotIdx#0@@1| Int) ) (!  (=> (and (= (type this@@35) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| this@@35 |pivotIdx#0@@1|) (and (not (= 25 $FunctionContextHeight)) (and (and ($Is this@@35 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@1|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@35) (PivotBetree.BetreeNode.IsIndex this@@35)) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@1|) (INTERNAL_lt_boogie |pivotIdx#0@@1| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable this@@35)) 1)))))))) (and (let ((|splitElt#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@35) |pivotIdx#0@@1|))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@35) (let ((|leftFilter#0@@1| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@35)) |splitElt#0|)))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| this@@35) (let ((|rightFilter#0@@1| (|#DomainMod.Domain.Domain| |splitElt#0| (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@35)))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#0@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@35) (DomainMod.Domain.KeySet |leftFilter#0@@1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#0@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@35) (DomainMod.Domain.KeySet |rightFilter#0@@1|))))))))) (= (PivotBetree.BetreeNode.SplitIndex this@@35 |pivotIdx#0@@1|) (let ((|splitElt#0@@0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@35) |pivotIdx#0@@1|))))
(let ((|leftFilter#0@@2| (|#DomainMod.Domain.Domain| (DomainMod.Domain.start (PivotBetree.BetreeNode.MyDomain this@@35)) |splitElt#0@@0|)))
(let ((|rightFilter#0@@2| (|#DomainMod.Domain.Domain| |splitElt#0@@0| (DomainMod.Domain.end (PivotBetree.BetreeNode.MyDomain this@@35)))))
(let ((|newLeft#0@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@35) (DomainMod.Domain.KeySet |leftFilter#0@@2|)) (|Seq#Take| (PivotBetree.BetreeNode.pivotTable this@@35) (INTERNAL_add_boogie |pivotIdx#0@@1| 1)) (|Seq#Take| (PivotBetree.BetreeNode.children this@@35) |pivotIdx#0@@1|))))
(let ((|newRight#0@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@35) (DomainMod.Domain.KeySet |rightFilter#0@@2|)) (|Seq#Drop| (PivotBetree.BetreeNode.pivotTable this@@35) |pivotIdx#0@@1|) (|Seq#Drop| (PivotBetree.BetreeNode.children this@@35) |pivotIdx#0@@1|))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#0@@0|) ($Box |newRight#0@@0|))))))))))
 :qid |PivotBetreebrokenidfy.121:14|
 :skolemid |1469|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex this@@35 |pivotIdx#0@@1|))
))))
(assert  (=> (<= 25 $FunctionContextHeight) (forall ((this@@36 T@U) (|pivotIdx#0@@2| Int) ) (!  (=> (and (= (type this@@36) DatatypeTypeType) (or (|PivotBetree.BetreeNode.SplitIndex#canCall| (Lit this@@36) (LitInt |pivotIdx#0@@2|)) (and (not (= 25 $FunctionContextHeight)) (and (and ($Is this@@36 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |pivotIdx#0@@2|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@36))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.IsIndex (Lit this@@36)))))) (and (INTERNAL_lt_boogie 0 |pivotIdx#0@@2|) (INTERNAL_lt_boogie |pivotIdx#0@@2| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@36)))) 1)))))))) (and (let ((|splitElt#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@36))) (LitInt |pivotIdx#0@@2|)))))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@36)) (let ((|leftFilter#1@@1| (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@36))))) |splitElt#1|)))
 (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@36)) (let ((|rightFilter#1@@1| (|#DomainMod.Domain.Domain| |splitElt#1| (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@36))))))))
 (and (and (|DomainMod.Domain.KeySet#canCall| |leftFilter#1@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@36))) (DomainMod.Domain.KeySet |leftFilter#1@@1|))) (and (|DomainMod.Domain.KeySet#canCall| |rightFilter#1@@1|) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@36))) (DomainMod.Domain.KeySet |rightFilter#1@@1|))))))))) (= (PivotBetree.BetreeNode.SplitIndex (Lit this@@36) (LitInt |pivotIdx#0@@2|)) (let ((|splitElt#1@@0| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@36))) (LitInt |pivotIdx#0@@2|)))))
(let ((|leftFilter#1@@2| (|#DomainMod.Domain.Domain| (Lit (DomainMod.Domain.start (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@36))))) |splitElt#1@@0|)))
(let ((|rightFilter#1@@2| (|#DomainMod.Domain.Domain| |splitElt#1@@0| (Lit (DomainMod.Domain.end (Lit (PivotBetree.BetreeNode.MyDomain (Lit this@@36))))))))
(let ((|newLeft#1@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@36))) (DomainMod.Domain.KeySet |leftFilter#1@@2|)) (Lit (|Seq#Take| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@36))) (LitInt (INTERNAL_add_boogie |pivotIdx#0@@2| 1)))) (Lit (|Seq#Take| (Lit (PivotBetree.BetreeNode.children (Lit this@@36))) (LitInt |pivotIdx#0@@2|))))))
(let ((|newRight#1@@0| (|#PivotBetree.BetreeNode.BetreeNode| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@36))) (DomainMod.Domain.KeySet |rightFilter#1@@2|)) (Lit (|Seq#Drop| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@36))) (LitInt |pivotIdx#0@@2|))) (Lit (|Seq#Drop| (Lit (PivotBetree.BetreeNode.children (Lit this@@36))) (LitInt |pivotIdx#0@@2|))))))
(|#_System._tuple#2._#Make2| ($Box |newLeft#1@@0|) ($Box |newRight#1@@0|))))))))))
 :qid |PivotBetreebrokenidfy.121:14|
 :weight 3
 :skolemid |1470|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex (Lit this@@36) (LitInt |pivotIdx#0@@2|)))
))))
(assert (= (type Tclass.SplitRequestMod.SplitRequest) TyType))
(assert (= (Tag Tclass.SplitRequestMod.SplitRequest) Tagclass.SplitRequestMod.SplitRequest))
(assert (= (TagFamily Tclass.SplitRequestMod.SplitRequest) tytagFamily$SplitRequest))
(assert (forall ((bx@@115 T@U) ) (!  (=> (and (= (type bx@@115) BoxType) ($IsBox bx@@115 Tclass.SplitRequestMod.SplitRequest)) (and (= ($Box ($Unbox DatatypeTypeType bx@@115)) bx@@115) ($Is ($Unbox DatatypeTypeType bx@@115) Tclass.SplitRequestMod.SplitRequest)))
 :qid |unknown.0:0|
 :skolemid |1514|
 :pattern ( ($IsBox bx@@115 Tclass.SplitRequestMod.SplitRequest))
)))
(assert  (=> (<= 27 $FunctionContextHeight) (forall ((this@@37 T@U) (|request#0| T@U) ) (!  (=> (and (and (= (type this@@37) DatatypeTypeType) (= (type |request#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| this@@37 |request#0|) (and (not (= 27 $FunctionContextHeight)) (and ($Is this@@37 Tclass.PivotBetree.BetreeNode) ($Is |request#0| Tclass.SplitRequestMod.SplitRequest))))) true)
 :qid |PivotBetreebrokenidfy.141:15|
 :skolemid |1515|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent this@@37 |request#0|))
))))
(assert (forall (($Heap T@U) (this@@38 T@U) (|request#0@@0| T@U) ) (!  (=> (and (and (and (= (type $Heap) (MapType0Type refType MapType1Type)) (= (type this@@38) DatatypeTypeType)) (= (type |request#0@@0|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap) (and ($Is this@@38 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@38 Tclass.PivotBetree.BetreeNode $Heap))) ($Is |request#0@@0| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.CanSplitParent#requires| this@@38 |request#0@@0|) true))
 :qid |PivotBetreebrokenidfy.141:15|
 :skolemid |1516|
 :pattern ( (|PivotBetree.BetreeNode.CanSplitParent#requires| this@@38 |request#0@@0|) ($IsGoodHeap $Heap))
)))
(assert (forall ((arg0@@389 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitLeaf#Handle| arg0@@389)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitLeaf#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitLeaf#Handle| arg0@@389))
)))
(assert (forall (($self T@U) ($heap T@U) (|$fh$0x#0| T@U) ) (!  (=> (and (and (= (type $self) DatatypeTypeType) (= (type $heap) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0|) BoxType)) (= (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self) |$fh$0x#0|) ($Box (PivotBetree.BetreeNode.SplitLeaf $self ($Unbox (SeqType BoxType) |$fh$0x#0|)))))
 :qid |unknown.0:0|
 :skolemid |1517|
 :pattern ( (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self) |$fh$0x#0|))
)))
(assert (forall (($self@@0 T@U) ($heap@@0 T@U) (|$fh$0x#0@@0| T@U) ) (!  (=> (and (and (= (type $self@@0) DatatypeTypeType) (= (type $heap@@0) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@0|) BoxType)) (= (Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@0 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@0) |$fh$0x#0@@0|) (|PivotBetree.BetreeNode.SplitLeaf#requires| $self@@0 ($Unbox (SeqType BoxType) |$fh$0x#0@@0|))))
 :qid |unknown.0:0|
 :skolemid |1518|
 :pattern ( (Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@0 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@0) |$fh$0x#0@@0|))
)))
(assert (forall (($bx T@U) ($self@@1 T@U) ($heap@@1 T@U) (|$fh$0x#0@@1| T@U) ) (!  (=> (and (and (and (= (type $bx) BoxType) (= (type $self@@1) DatatypeTypeType)) (= (type $heap@@1) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@1 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@1) |$fh$0x#0@@1|) $bx)) false))
 :qid |unknown.0:0|
 :skolemid |1519|
 :pattern ( (MapType0Select (Reads1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@1 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@1) |$fh$0x#0@@1|) $bx))
)))
(assert (forall (($self@@2 T@U) ($heap@@2 T@U) (|$fh$0x#0@@2| T@U) ) (!  (=> (and (and (= (type $self@@2) DatatypeTypeType) (= (type $heap@@2) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@2|) (SeqType BoxType))) (= (PivotBetree.BetreeNode.SplitLeaf $self@@2 |$fh$0x#0@@2|) ($Unbox DatatypeTypeType (Apply1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@2 (|PivotBetree.BetreeNode.SplitLeaf#Handle| $self@@2) ($Box |$fh$0x#0@@2|)))))
 :qid |unknown.0:0|
 :skolemid |1520|
 :pattern ( (PivotBetree.BetreeNode.SplitLeaf $self@@2 |$fh$0x#0@@2|) ($IsGoodHeap $heap@@2))
)))
(assert (forall ((arg0@@390 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitIndex#Handle| arg0@@390)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitIndex#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitIndex#Handle| arg0@@390))
)))
(assert (forall (($self@@3 T@U) ($heap@@3 T@U) (|$fh$0x#0@@3| T@U) ) (!  (=> (and (and (= (type $self@@3) DatatypeTypeType) (= (type $heap@@3) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@3|) BoxType)) (= (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@3 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@3) |$fh$0x#0@@3|) ($Box (PivotBetree.BetreeNode.SplitIndex $self@@3 (U_2_int ($Unbox intType |$fh$0x#0@@3|))))))
 :qid |unknown.0:0|
 :skolemid |1521|
 :pattern ( (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@3 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@3) |$fh$0x#0@@3|))
)))
(assert (forall (($self@@4 T@U) ($heap@@4 T@U) (|$fh$0x#0@@4| T@U) ) (!  (=> (and (and (= (type $self@@4) DatatypeTypeType) (= (type $heap@@4) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@4|) BoxType)) (= (Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@4 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@4) |$fh$0x#0@@4|) (|PivotBetree.BetreeNode.SplitIndex#requires| $self@@4 (U_2_int ($Unbox intType |$fh$0x#0@@4|)))))
 :qid |unknown.0:0|
 :skolemid |1522|
 :pattern ( (Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@4 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@4) |$fh$0x#0@@4|))
)))
(assert (forall (($bx@@0 T@U) ($self@@5 T@U) ($heap@@5 T@U) (|$fh$0x#0@@5| T@U) ) (!  (=> (and (and (and (= (type $bx@@0) BoxType) (= (type $self@@5) DatatypeTypeType)) (= (type $heap@@5) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@5 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@5) |$fh$0x#0@@5|) $bx@@0)) false))
 :qid |unknown.0:0|
 :skolemid |1523|
 :pattern ( (MapType0Select (Reads1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@5 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@5) |$fh$0x#0@@5|) $bx@@0))
)))
(assert (forall (($self@@6 T@U) ($heap@@6 T@U) (|$fh$0x#0@@6| Int) ) (!  (=> (and (= (type $self@@6) DatatypeTypeType) (= (type $heap@@6) (MapType0Type refType MapType1Type))) (= (PivotBetree.BetreeNode.SplitIndex $self@@6 |$fh$0x#0@@6|) ($Unbox DatatypeTypeType (Apply1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $heap@@6 (|PivotBetree.BetreeNode.SplitIndex#Handle| $self@@6) ($Box (int_2_U |$fh$0x#0@@6|))))))
 :qid |unknown.0:0|
 :skolemid |1524|
 :pattern ( (PivotBetree.BetreeNode.SplitIndex $self@@6 |$fh$0x#0@@6|) ($IsGoodHeap $heap@@6))
)))
(assert (forall ((arg0@@391 T@U) ) (! (= (type (SplitRequestMod.SplitRequest.splitKey arg0@@391)) (SeqType BoxType))
 :qid |funType:SplitRequestMod.SplitRequest.splitKey|
 :pattern ( (SplitRequestMod.SplitRequest.splitKey arg0@@391))
)))
(assert  (=> (<= 27 $FunctionContextHeight) (forall (($Heap@@0 T@U) (this@@39 T@U) (|request#0@@1| T@U) ) (!  (=> (and (and (and (= (type $Heap@@0) (MapType0Type refType MapType1Type)) (= (type this@@39) DatatypeTypeType)) (= (type |request#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| this@@39 |request#0@@1|) (and (not (= 27 $FunctionContextHeight)) (and (and ($IsGoodHeap $Heap@@0) (and ($Is this@@39 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@39 Tclass.PivotBetree.BetreeNode $Heap@@0))) ($Is |request#0@@1| Tclass.SplitRequestMod.SplitRequest))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@39) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@39) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@39) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@1|)) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@39 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|))) (=> (PivotBetree.BetreeNode.ValidChildIndex this@@39 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|)) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@1|)) (=> (U_2_bool (Lit (bool_2_U true))) (and (=> (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) true) (=> (not (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|)) true))))))))) (= (PivotBetree.BetreeNode.CanSplitParent this@@39 |request#0@@1|)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@39) (PivotBetree.BetreeNode.BetreeNode_q this@@39)) (PivotBetree.BetreeNode.ValidChildIndex this@@39 (SplitRequestMod.SplitRequest.childIdx |request#0@@1|))) (let ((|child#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@39) (SplitRequestMod.SplitRequest.childIdx |request#0@@1|)))))
 (and true (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@1|) (let ((|splitKey#0@@3| (SplitRequestMod.SplitRequest.splitKey |request#0@@1|)))
(Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@0 (|PivotBetree.BetreeNode.SplitLeaf#Handle| |child#0|) ($Box |splitKey#0@@3|))) (let ((|childPivotIdx#0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@1|)))
(Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@0 (|PivotBetree.BetreeNode.SplitIndex#Handle| |child#0|) ($Box (int_2_U |childPivotIdx#0|)))))))))))
 :qid |PivotBetreebrokenidfy.141:15|
 :skolemid |1525|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent this@@39 |request#0@@1|) ($IsGoodHeap $Heap@@0))
))))
(assert  (=> (<= 27 $FunctionContextHeight) (forall (($Heap@@1 T@U) (this@@40 T@U) (|request#0@@2| T@U) ) (!  (=> (and (and (and (= (type $Heap@@1) (MapType0Type refType MapType1Type)) (= (type this@@40) DatatypeTypeType)) (= (type |request#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.CanSplitParent#canCall| (Lit this@@40) (Lit |request#0@@2|)) (and (not (= 27 $FunctionContextHeight)) (and (and ($IsGoodHeap $Heap@@1) (and ($Is this@@40 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@40 Tclass.PivotBetree.BetreeNode $Heap@@1))) ($Is |request#0@@2| Tclass.SplitRequestMod.SplitRequest))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@40)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@40))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@40))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@2|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@40) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@40) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@2|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (=> (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|))))) true) (=> (not (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)))))) true))))))))) (= (PivotBetree.BetreeNode.CanSplitParent (Lit this@@40) (Lit |request#0@@2|))  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@40)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@40))) (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@40) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|))))) (let ((|child#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@40))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@2|)))))))
 (and true (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@2|)) (let ((|splitKey#2| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@2|)))))
(Requires1 Tclass.KeyType.Key (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@1 (|PivotBetree.BetreeNode.SplitLeaf#Handle| |child#1|) ($Box |splitKey#2|))) (let ((|childPivotIdx#2| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@2|)))))
(Requires1 Tclass._System.nat (Tclass._System.Tuple2 Tclass.PivotBetree.BetreeNode Tclass.PivotBetree.BetreeNode) $Heap@@1 (|PivotBetree.BetreeNode.SplitIndex#Handle| |child#1|) ($Box (int_2_U |childPivotIdx#2|)))))))))))
 :qid |PivotBetreebrokenidfy.141:15|
 :weight 3
 :skolemid |1526|
 :pattern ( (PivotBetree.BetreeNode.CanSplitParent (Lit this@@40) (Lit |request#0@@2|)) ($IsGoodHeap $Heap@@1))
))))
(assert (= (type Tclass.NativeTypes.byte) TyType))
(assert (= (Tag Tclass.NativeTypes.byte) Tagclass.NativeTypes.byte))
(assert (= (TagFamily Tclass.NativeTypes.byte) tytagFamily$byte))
(assert (forall ((bx@@116 T@U) ) (!  (=> (and (= (type bx@@116) BoxType) ($IsBox bx@@116 Tclass.NativeTypes.byte)) (and (= ($Box ($Unbox intType bx@@116)) bx@@116) ($Is ($Unbox intType bx@@116) Tclass.NativeTypes.byte)))
 :qid |unknown.0:0|
 :skolemid |1530|
 :pattern ( ($IsBox bx@@116 Tclass.NativeTypes.byte))
)))
(assert (forall ((arg0@@392 T@U) (arg1@@153 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitKey arg0@@392 arg1@@153)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.SplitKey|
 :pattern ( (PivotBetree.BetreeNode.SplitKey arg0@@392 arg1@@153))
)))
(assert  (=> (<= 28 $FunctionContextHeight) (forall ((this@@41 T@U) (|request#0@@3| T@U) ) (!  (=> (and (and (= (type this@@41) DatatypeTypeType) (= (type |request#0@@3|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| this@@41 |request#0@@3|) (and (not (= 28 $FunctionContextHeight)) (and (and ($Is this@@41 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@3| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@41) (PivotBetree.BetreeNode.CanSplitParent this@@41 |request#0@@3|)))))) (and (BoundedPivotsLib.__default.PivotInsertable (PivotBetree.BetreeNode.pivotTable this@@41) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@3|) 1) (PivotBetree.BetreeNode.SplitKey this@@41 |request#0@@3|)) ($Is (PivotBetree.BetreeNode.SplitKey this@@41 |request#0@@3|) Tclass.KeyType.Key)))
 :qid |PivotBetreebrokenidfy.153:14|
 :skolemid |1532|
 :pattern ( (PivotBetree.BetreeNode.SplitKey this@@41 |request#0@@3|))
))))
(assert (forall ((this@@42 T@U) (|request#0@@4| T@U) ) (!  (=> (and (and (= (type this@@42) DatatypeTypeType) (= (type |request#0@@4|) DatatypeTypeType)) (and ($Is this@@42 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@4| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitKey#requires| this@@42 |request#0@@4|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@42) (PivotBetree.BetreeNode.CanSplitParent this@@42 |request#0@@4|))))
 :qid |PivotBetreebrokenidfy.153:14|
 :skolemid |1533|
 :pattern ( (|PivotBetree.BetreeNode.SplitKey#requires| this@@42 |request#0@@4|))
)))
(assert  (=> (<= 28 $FunctionContextHeight) (forall ((this@@43 T@U) (|request#0@@5| T@U) ) (!  (=> (and (and (= (type this@@43) DatatypeTypeType) (= (type |request#0@@5|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| this@@43 |request#0@@5|) (and (not (= 28 $FunctionContextHeight)) (and (and ($Is this@@43 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@5| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@43) (PivotBetree.BetreeNode.CanSplitParent this@@43 |request#0@@5|)))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@5|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@5|)) (= (PivotBetree.BetreeNode.SplitKey this@@43 |request#0@@5|) (let ((|oldChild#0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@43) (SplitRequestMod.SplitRequest.childIdx |request#0@@5|)))))
(let ((|out#0| (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@5|) (SplitRequestMod.SplitRequest.splitKey |request#0@@5|) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |oldChild#0|) (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@5|)))))))
|out#0|)))))
 :qid |PivotBetreebrokenidfy.153:14|
 :skolemid |1534|
 :pattern ( (PivotBetree.BetreeNode.SplitKey this@@43 |request#0@@5|))
))))
(assert  (=> (<= 28 $FunctionContextHeight) (forall ((this@@44 T@U) (|request#0@@6| T@U) ) (!  (=> (and (and (= (type this@@44) DatatypeTypeType) (= (type |request#0@@6|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit this@@44) (Lit |request#0@@6|)) (and (not (= 28 $FunctionContextHeight)) (and (and ($Is this@@44 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@6| Tclass.SplitRequestMod.SplitRequest)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@44))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanSplitParent (Lit this@@44) (Lit |request#0@@6|)))))))))) (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@6|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@6|))) (= (PivotBetree.BetreeNode.SplitKey (Lit this@@44) (Lit |request#0@@6|)) (let ((|oldChild#1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@44))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@6|)))))))
(let ((|out#1| (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@6|)) (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@6|)) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |oldChild#1|) (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@6|)))))))))
|out#1|)))))
 :qid |PivotBetreebrokenidfy.153:14|
 :weight 3
 :skolemid |1535|
 :pattern ( (PivotBetree.BetreeNode.SplitKey (Lit this@@44) (Lit |request#0@@6|)))
))))
(assert (forall ((arg0@@393 T@U) (arg1@@154 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitParentDefn arg0@@393 arg1@@154)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParentDefn|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn arg0@@393 arg1@@154))
)))
(assert  (=> (<= 29 $FunctionContextHeight) (forall ((this@@45 T@U) (|request#0@@7| T@U) ) (!  (=> (and (and (= (type this@@45) DatatypeTypeType) (= (type |request#0@@7|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@45 |request#0@@7|) (and (not (= 29 $FunctionContextHeight)) (and (and ($Is this@@45 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@7| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@45) (PivotBetree.BetreeNode.CanSplitParent this@@45 |request#0@@7|)))))) ($Is (PivotBetree.BetreeNode.SplitParentDefn this@@45 |request#0@@7|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreebrokenidfy.169:14|
 :skolemid |1546|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn this@@45 |request#0@@7|))
))))
(assert (forall ((this@@46 T@U) (|request#0@@8| T@U) ) (!  (=> (and (and (= (type this@@46) DatatypeTypeType) (= (type |request#0@@8|) DatatypeTypeType)) (and ($Is this@@46 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@8| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitParentDefn#requires| this@@46 |request#0@@8|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@46) (PivotBetree.BetreeNode.CanSplitParent this@@46 |request#0@@8|))))
 :qid |PivotBetreebrokenidfy.169:14|
 :skolemid |1547|
 :pattern ( (|PivotBetree.BetreeNode.SplitParentDefn#requires| this@@46 |request#0@@8|))
)))
(assert  (and (and (forall ((arg0@@394 T@U) (arg1@@155 T@U) (arg2@@81 T@U) (arg3@@45 T@U) (arg4@@28 T@U) (arg5@@15 Int) ) (! (= (type (Sequences.__default.replace1with2 arg0@@394 arg1@@155 arg2@@81 arg3@@45 arg4@@28 arg5@@15)) (SeqType BoxType))
 :qid |funType:Sequences.__default.replace1with2|
 :pattern ( (Sequences.__default.replace1with2 arg0@@394 arg1@@155 arg2@@81 arg3@@45 arg4@@28 arg5@@15))
)) (= (type StartFuel_Sequences._default.replace1with2) LayerTypeType)) (forall ((arg0@@395 T@U) (arg1@@156 Int) (arg2@@82 T@U) ) (! (= (type (BoundedPivotsLib.__default.InsertPivot arg0@@395 arg1@@156 arg2@@82)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.InsertPivot|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot arg0@@395 arg1@@156 arg2@@82))
))))
(assert  (=> (<= 29 $FunctionContextHeight) (forall ((this@@47 T@U) (|request#0@@9| T@U) ) (!  (=> (and (and (= (type this@@47) DatatypeTypeType) (= (type |request#0@@9|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@47 |request#0@@9|) (and (not (= 29 $FunctionContextHeight)) (and (and ($Is this@@47 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@9| Tclass.SplitRequestMod.SplitRequest)) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@47) (PivotBetree.BetreeNode.CanSplitParent this@@47 |request#0@@9|)))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (let ((|oldChild#0@@0| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@47) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|)))))
 (and (and (=> (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (|PivotBetree.BetreeNode.SplitLeaf#canCall| |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|))) (=> (not (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|)) (|PivotBetree.BetreeNode.SplitIndex#canCall| |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))) (let ((|newRightChild#0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newLeftChild#0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@0| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@0| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
 (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (|Sequences.__default.replace1with2#canCall| Tclass.PivotBetree.BetreeNode (PivotBetree.BetreeNode.children this@@47) ($Box |newLeftChild#0|) ($Box |newRightChild#0|) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#0@@9|)) (|PivotBetree.BetreeNode.SplitKey#canCall| this@@47 |request#0@@9|)) (|BoundedPivotsLib.__default.InsertPivot#canCall| (PivotBetree.BetreeNode.pivotTable this@@47) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@9|) 1) (PivotBetree.BetreeNode.SplitKey this@@47 |request#0@@9|))))))))) (= (PivotBetree.BetreeNode.SplitParentDefn this@@47 |request#0@@9|) (let ((|oldChild#0@@1| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@47) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|)))))
(let ((|newRightChild#0@@0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@1| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@1| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newLeftChild#0@@0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q |request#0@@9|) (PivotBetree.BetreeNode.SplitLeaf |oldChild#0@@1| (SplitRequestMod.SplitRequest.splitKey |request#0@@9|)) (PivotBetree.BetreeNode.SplitIndex |oldChild#0@@1| (SplitRequestMod.SplitRequest.childPivotIdx |request#0@@9|)))))))
(let ((|newChildren#0| (Sequences.__default.replace1with2 Tclass.PivotBetree.BetreeNode StartFuel_Sequences._default.replace1with2 (PivotBetree.BetreeNode.children this@@47) ($Box |newLeftChild#0@@0|) ($Box |newRightChild#0@@0|) (SplitRequestMod.SplitRequest.childIdx |request#0@@9|))))
(|#PivotBetree.BetreeNode.BetreeNode| (PivotBetree.BetreeNode.buffers this@@47) (BoundedPivotsLib.__default.InsertPivot (PivotBetree.BetreeNode.pivotTable this@@47) (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx |request#0@@9|) 1) (PivotBetree.BetreeNode.SplitKey this@@47 |request#0@@9|)) |newChildren#0|))))))))
 :qid |PivotBetreebrokenidfy.169:14|
 :skolemid |1548|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn this@@47 |request#0@@9|))
))))
(assert  (=> (<= 29 $FunctionContextHeight) (forall ((this@@48 T@U) (|request#0@@10| T@U) ) (!  (=> (and (and (= (type this@@48) DatatypeTypeType) (= (type |request#0@@10|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParentDefn#canCall| (Lit this@@48) (Lit |request#0@@10|)) (and (not (= 29 $FunctionContextHeight)) (and (and ($Is this@@48 Tclass.PivotBetree.BetreeNode) ($Is |request#0@@10| Tclass.SplitRequestMod.SplitRequest)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@48))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanSplitParent (Lit this@@48) (Lit |request#0@@10|)))))))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (let ((|oldChild#1@@0| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@48))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)))))))
 (and (and (=> (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|))))) (|PivotBetree.BetreeNode.SplitLeaf#canCall| |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|))))) (=> (not (U_2_bool (Lit (bool_2_U (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)))))) (|PivotBetree.BetreeNode.SplitIndex#canCall| |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))) (let ((|newRightChild#1| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newLeftChild#1| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@0| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@0| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
 (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (|Sequences.__default.replace1with2#canCall| Tclass.PivotBetree.BetreeNode (Lit (PivotBetree.BetreeNode.children (Lit this@@48))) ($Box |newLeftChild#1|) ($Box |newRightChild#1|) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|))))) (and (and (or (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (SplitRequestMod.SplitRequest.SplitIndex_q (Lit |request#0@@10|))) (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit this@@48) (Lit |request#0@@10|))) (|BoundedPivotsLib.__default.InsertPivot#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@48))) (LitInt (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)) 1)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit this@@48) (Lit |request#0@@10|))))))))))) (= (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@48) (Lit |request#0@@10|)) (let ((|oldChild#1@@1| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@48))) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)))))))
(let ((|newRightChild#1@@0| ($Unbox DatatypeTypeType (_System.Tuple2._1 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@1| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@1| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newLeftChild#1@@0| ($Unbox DatatypeTypeType (_System.Tuple2._0 (ite (SplitRequestMod.SplitRequest.SplitLeaf_q (Lit |request#0@@10|)) (PivotBetree.BetreeNode.SplitLeaf |oldChild#1@@1| (Lit (SplitRequestMod.SplitRequest.splitKey (Lit |request#0@@10|)))) (PivotBetree.BetreeNode.SplitIndex |oldChild#1@@1| (LitInt (SplitRequestMod.SplitRequest.childPivotIdx (Lit |request#0@@10|)))))))))
(let ((|newChildren#1| (Sequences.__default.replace1with2 Tclass.PivotBetree.BetreeNode StartFuel_Sequences._default.replace1with2 (Lit (PivotBetree.BetreeNode.children (Lit this@@48))) ($Box |newLeftChild#1@@0|) ($Box |newRightChild#1@@0|) (LitInt (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|))))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@48))) (Lit (BoundedPivotsLib.__default.InsertPivot (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@48))) (LitInt (INTERNAL_add_boogie (SplitRequestMod.SplitRequest.childIdx (Lit |request#0@@10|)) 1)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit this@@48) (Lit |request#0@@10|))))) |newChildren#1|))))))))
 :qid |PivotBetreebrokenidfy.169:14|
 :weight 3
 :skolemid |1549|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@48) (Lit |request#0@@10|)))
))))
(assert (forall ((arg0@@396 T@U) ) (! (= (type (|PivotBetree.BetreeNode.SplitParentDefn#Handle| arg0@@396)) HandleTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParentDefn#Handle|
 :pattern ( (|PivotBetree.BetreeNode.SplitParentDefn#Handle| arg0@@396))
)))
(assert (forall (($self@@7 T@U) ($heap@@7 T@U) (|$fh$0x#0@@7| T@U) ) (!  (=> (and (and (= (type $self@@7) DatatypeTypeType) (= (type $heap@@7) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@7|) BoxType)) (= (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@7 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@7) |$fh$0x#0@@7|) ($Box (PivotBetree.BetreeNode.SplitParentDefn $self@@7 ($Unbox DatatypeTypeType |$fh$0x#0@@7|)))))
 :qid |unknown.0:0|
 :skolemid |1691|
 :pattern ( (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@7 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@7) |$fh$0x#0@@7|))
)))
(assert (forall (($self@@8 T@U) ($heap@@8 T@U) (|$fh$0x#0@@8| T@U) ) (!  (=> (and (and (= (type $self@@8) DatatypeTypeType) (= (type $heap@@8) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@8|) BoxType)) (= (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@8 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@8) |$fh$0x#0@@8|) (|PivotBetree.BetreeNode.SplitParentDefn#requires| $self@@8 ($Unbox DatatypeTypeType |$fh$0x#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |1692|
 :pattern ( (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@8 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@8) |$fh$0x#0@@8|))
)))
(assert (forall (($bx@@1 T@U) ($self@@9 T@U) ($heap@@9 T@U) (|$fh$0x#0@@9| T@U) ) (!  (=> (and (and (and (= (type $bx@@1) BoxType) (= (type $self@@9) DatatypeTypeType)) (= (type $heap@@9) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@9|) BoxType)) (= (U_2_bool (MapType0Select (Reads1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@9 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@9) |$fh$0x#0@@9|) $bx@@1)) false))
 :qid |unknown.0:0|
 :skolemid |1693|
 :pattern ( (MapType0Select (Reads1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@9 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@9) |$fh$0x#0@@9|) $bx@@1))
)))
(assert (forall (($self@@10 T@U) ($heap@@10 T@U) (|$fh$0x#0@@10| T@U) ) (!  (=> (and (and (= (type $self@@10) DatatypeTypeType) (= (type $heap@@10) (MapType0Type refType MapType1Type))) (= (type |$fh$0x#0@@10|) DatatypeTypeType)) (= (PivotBetree.BetreeNode.SplitParentDefn $self@@10 |$fh$0x#0@@10|) ($Unbox DatatypeTypeType (Apply1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $heap@@10 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| $self@@10) ($Box |$fh$0x#0@@10|)))))
 :qid |unknown.0:0|
 :skolemid |1694|
 :pattern ( (PivotBetree.BetreeNode.SplitParentDefn $self@@10 |$fh$0x#0@@10|) ($IsGoodHeap $heap@@10))
)))
(assert (forall ((arg0@@397 T@U) (arg1@@157 T@U) ) (! (= (type (PivotBetree.BetreeNode.SplitParent arg0@@397 arg1@@157)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.SplitParent|
 :pattern ( (PivotBetree.BetreeNode.SplitParent arg0@@397 arg1@@157))
)))
(assert  (=> (<= 31 $FunctionContextHeight) (forall (($Heap@@2 T@U) (this@@49 T@U) (|request#0@@11| T@U) ) (!  (=> (and (and (and (= (type $Heap@@2) (MapType0Type refType MapType1Type)) (= (type this@@49) DatatypeTypeType)) (= (type |request#0@@11|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| this@@49 |request#0@@11|) (and (not (= 31 $FunctionContextHeight)) (and (and (and ($IsGoodHeap $Heap@@2) (and ($Is this@@49 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@49 Tclass.PivotBetree.BetreeNode $Heap@@2))) ($Is |request#0@@11| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@2 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@49) ($Box |request#0@@11|)))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.SplitParent this@@49 |request#0@@11|)) ($Is (PivotBetree.BetreeNode.SplitParent this@@49 |request#0@@11|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.206:14|
 :skolemid |1695|
 :pattern ( (PivotBetree.BetreeNode.SplitParent this@@49 |request#0@@11|) ($IsGoodHeap $Heap@@2))
))))
(assert (forall (($Heap@@3 T@U) (this@@50 T@U) (|request#0@@12| T@U) ) (!  (=> (and (and (and (= (type $Heap@@3) (MapType0Type refType MapType1Type)) (= (type this@@50) DatatypeTypeType)) (= (type |request#0@@12|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap@@3) (and ($Is this@@50 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@50 Tclass.PivotBetree.BetreeNode $Heap@@3))) ($Is |request#0@@12| Tclass.SplitRequestMod.SplitRequest))) (= (|PivotBetree.BetreeNode.SplitParent#requires| this@@50 |request#0@@12|) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@3 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@50) ($Box |request#0@@12|))))
 :qid |PivotBetreebrokenidfy.206:14|
 :skolemid |1696|
 :pattern ( (|PivotBetree.BetreeNode.SplitParent#requires| this@@50 |request#0@@12|) ($IsGoodHeap $Heap@@3))
)))
(assert  (=> (<= 31 $FunctionContextHeight) (forall (($Heap@@4 T@U) (this@@51 T@U) (|request#0@@13| T@U) ) (!  (=> (and (and (and (= (type $Heap@@4) (MapType0Type refType MapType1Type)) (= (type this@@51) DatatypeTypeType)) (= (type |request#0@@13|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| this@@51 |request#0@@13|) (and (not (= 31 $FunctionContextHeight)) (and (and (and ($IsGoodHeap $Heap@@4) (and ($Is this@@51 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@51 Tclass.PivotBetree.BetreeNode $Heap@@4))) ($Is |request#0@@13| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@4 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| this@@51) ($Box |request#0@@13|)))))) (and (|PivotBetree.BetreeNode.SplitParentDefn#canCall| this@@51 |request#0@@13|) (= (PivotBetree.BetreeNode.SplitParent this@@51 |request#0@@13|) (PivotBetree.BetreeNode.SplitParentDefn this@@51 |request#0@@13|))))
 :qid |PivotBetreebrokenidfy.206:14|
 :skolemid |1697|
 :pattern ( (PivotBetree.BetreeNode.SplitParent this@@51 |request#0@@13|) ($IsGoodHeap $Heap@@4))
))))
(assert  (=> (<= 31 $FunctionContextHeight) (forall (($Heap@@5 T@U) (this@@52 T@U) (|request#0@@14| T@U) ) (!  (=> (and (and (and (= (type $Heap@@5) (MapType0Type refType MapType1Type)) (= (type this@@52) DatatypeTypeType)) (= (type |request#0@@14|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.SplitParent#canCall| (Lit this@@52) (Lit |request#0@@14|)) (and (not (= 31 $FunctionContextHeight)) (and (and (and ($IsGoodHeap $Heap@@5) (and ($Is this@@52 Tclass.PivotBetree.BetreeNode) ($IsAlloc this@@52 Tclass.PivotBetree.BetreeNode $Heap@@5))) ($Is |request#0@@14| Tclass.SplitRequestMod.SplitRequest)) (Requires1 Tclass.SplitRequestMod.SplitRequest Tclass.PivotBetree.BetreeNode $Heap@@5 (|PivotBetree.BetreeNode.SplitParentDefn#Handle| (Lit this@@52)) ($Box (Lit |request#0@@14|))))))) (and (|PivotBetree.BetreeNode.SplitParentDefn#canCall| (Lit this@@52) (Lit |request#0@@14|)) (= (PivotBetree.BetreeNode.SplitParent (Lit this@@52) (Lit |request#0@@14|)) (Lit (PivotBetree.BetreeNode.SplitParentDefn (Lit this@@52) (Lit |request#0@@14|))))))
 :qid |PivotBetreebrokenidfy.206:14|
 :weight 3
 :skolemid |1698|
 :pattern ( (PivotBetree.BetreeNode.SplitParent (Lit this@@52) (Lit |request#0@@14|)) ($IsGoodHeap $Heap@@5))
))))
(assert (forall ((arg0@@398 T@U) (arg1@@158 T@U) ) (! (= (type (PivotBetree.BetreeNode.Promote arg0@@398 arg1@@158)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Promote|
 :pattern ( (PivotBetree.BetreeNode.Promote arg0@@398 arg1@@158))
)))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((this@@53 T@U) (|domain#0| T@U) ) (!  (=> (and (and (= (type this@@53) DatatypeTypeType) (= (type |domain#0|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| this@@53 |domain#0|) (and (not (= 33 $FunctionContextHeight)) (and (and ($Is this@@53 Tclass.PivotBetree.BetreeNode) ($Is |domain#0| Tclass.DomainMod.Domain)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@53) (DomainMod.Domain.WF |domain#0|)) (DomainMod.Domain.Domain_q |domain#0|)))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.Promote this@@53 |domain#0|)) ($Is (PivotBetree.BetreeNode.Promote this@@53 |domain#0|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.214:14|
 :skolemid |1719|
 :pattern ( (PivotBetree.BetreeNode.Promote this@@53 |domain#0|))
))))
(assert (forall ((this@@54 T@U) (|domain#0@@0| T@U) ) (!  (=> (and (and (= (type this@@54) DatatypeTypeType) (= (type |domain#0@@0|) DatatypeTypeType)) (and ($Is this@@54 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@0| Tclass.DomainMod.Domain))) (= (|PivotBetree.BetreeNode.Promote#requires| this@@54 |domain#0@@0|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@54) (DomainMod.Domain.WF |domain#0@@0|)) (DomainMod.Domain.Domain_q |domain#0@@0|))))
 :qid |PivotBetreebrokenidfy.214:14|
 :skolemid |1720|
 :pattern ( (|PivotBetree.BetreeNode.Promote#requires| this@@54 |domain#0@@0|))
)))
(assert (forall ((arg0@@399 T@U) ) (! (= (type (PivotBetree.__default.EmptyRoot arg0@@399)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.EmptyRoot|
 :pattern ( (PivotBetree.__default.EmptyRoot arg0@@399))
)))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((this@@55 T@U) (|domain#0@@1| T@U) ) (!  (=> (and (and (= (type this@@55) DatatypeTypeType) (= (type |domain#0@@1|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| this@@55 |domain#0@@1|) (and (not (= 33 $FunctionContextHeight)) (and (and ($Is this@@55 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@1| Tclass.DomainMod.Domain)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@55) (DomainMod.Domain.WF |domain#0@@1|)) (DomainMod.Domain.Domain_q |domain#0@@1|)))))) (and (=> (PivotBetree.BetreeNode.Nil_q this@@55) (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@1|)) (= (PivotBetree.BetreeNode.Promote this@@55 |domain#0@@1|) (ite (PivotBetree.BetreeNode.Nil_q this@@55) (PivotBetree.__default.EmptyRoot |domain#0@@1|) this@@55))))
 :qid |PivotBetreebrokenidfy.214:14|
 :skolemid |1721|
 :pattern ( (PivotBetree.BetreeNode.Promote this@@55 |domain#0@@1|))
))))
(assert  (=> (<= 33 $FunctionContextHeight) (forall ((this@@56 T@U) (|domain#0@@2| T@U) ) (!  (=> (and (and (= (type this@@56) DatatypeTypeType) (= (type |domain#0@@2|) DatatypeTypeType)) (or (|PivotBetree.BetreeNode.Promote#canCall| (Lit this@@56) (Lit |domain#0@@2|)) (and (not (= 33 $FunctionContextHeight)) (and (and ($Is this@@56 Tclass.PivotBetree.BetreeNode) ($Is |domain#0@@2| Tclass.DomainMod.Domain)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@56))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.WF (Lit |domain#0@@2|)))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Domain_q (Lit |domain#0@@2|)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit this@@56))))) (|PivotBetree.__default.EmptyRoot#canCall| (Lit |domain#0@@2|))) (= (PivotBetree.BetreeNode.Promote (Lit this@@56) (Lit |domain#0@@2|)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@56)) (PivotBetree.__default.EmptyRoot (Lit |domain#0@@2|)) this@@56))))
 :qid |PivotBetreebrokenidfy.214:14|
 :weight 3
 :skolemid |1722|
 :pattern ( (PivotBetree.BetreeNode.Promote (Lit this@@56) (Lit |domain#0@@2|)))
))))
(assert  (=> (<= 16 $FunctionContextHeight) (forall ((this@@57 T@U) ) (!  (=> (and (= (type this@@57) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| this@@57) (and (not (= 16 $FunctionContextHeight)) (and ($Is this@@57 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.LocalStructure this@@57) (PivotBetree.BetreeNode.BetreeNode_q this@@57)))))) ($Is (PivotBetree.BetreeNode.MyDomain this@@57) Tclass.DomainMod.Domain))
 :qid |PivotBetreebrokenidfy.223:14|
 :skolemid |1732|
 :pattern ( (PivotBetree.BetreeNode.MyDomain this@@57))
))))
(assert (forall ((this@@58 T@U) ) (!  (=> (and (= (type this@@58) DatatypeTypeType) ($Is this@@58 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.MyDomain#requires| this@@58)  (and (PivotBetree.BetreeNode.LocalStructure this@@58) (PivotBetree.BetreeNode.BetreeNode_q this@@58))))
 :qid |PivotBetreebrokenidfy.223:14|
 :skolemid |1733|
 :pattern ( (|PivotBetree.BetreeNode.MyDomain#requires| this@@58))
)))
(assert (forall ((arg0@@400 T@U) (arg1@@159 T@U) ) (! (= (type (Sequences.__default.Last arg0@@400 arg1@@159)) BoxType)
 :qid |funType:Sequences.__default.Last|
 :pattern ( (Sequences.__default.Last arg0@@400 arg1@@159))
)))
(assert  (=> (<= 16 $FunctionContextHeight) (forall ((this@@59 T@U) ) (!  (=> (and (= (type this@@59) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| this@@59) (and (not (= 16 $FunctionContextHeight)) (and ($Is this@@59 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.LocalStructure this@@59) (PivotBetree.BetreeNode.BetreeNode_q this@@59)))))) (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (PivotBetree.BetreeNode.pivotTable this@@59)) (= (PivotBetree.BetreeNode.MyDomain this@@59) (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@59) (LitInt 0))) ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (PivotBetree.BetreeNode.pivotTable this@@59)))))))
 :qid |PivotBetreebrokenidfy.223:14|
 :skolemid |1734|
 :pattern ( (PivotBetree.BetreeNode.MyDomain this@@59))
))))
(assert  (=> (<= 16 $FunctionContextHeight) (forall ((this@@60 T@U) ) (!  (=> (and (= (type this@@60) DatatypeTypeType) (or (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit this@@60)) (and (not (= 16 $FunctionContextHeight)) (and ($Is this@@60 Tclass.PivotBetree.BetreeNode) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@60))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@60)))))))))) (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@60)))) (= (PivotBetree.BetreeNode.MyDomain (Lit this@@60)) (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@60))) (LitInt 0))) (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@60))))))))))
 :qid |PivotBetreebrokenidfy.223:14|
 :weight 3
 :skolemid |1735|
 :pattern ( (PivotBetree.BetreeNode.MyDomain (Lit this@@60)))
))))
(assert  (=> (<= 17 $FunctionContextHeight) (forall ((this@@61 T@U) (|childIdx#0@@3| Int) ) (!  (=> (and (= (type this@@61) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@61 |childIdx#0@@3|) (and (not (= 17 $FunctionContextHeight)) (and (and ($Is this@@61 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@3|)) (and (and (PivotBetree.BetreeNode.LocalStructure this@@61) (PivotBetree.BetreeNode.BetreeNode_q this@@61)) (PivotBetree.BetreeNode.ValidChildIndex this@@61 |childIdx#0@@3|)))))) (and (DomainMod.Domain.WF (PivotBetree.BetreeNode.DomainRoutedToChild this@@61 |childIdx#0@@3|)) ($Is (PivotBetree.BetreeNode.DomainRoutedToChild this@@61 |childIdx#0@@3|) Tclass.DomainMod.Domain)))
 :qid |PivotBetreebrokenidfy.230:14|
 :skolemid |1738|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@61 |childIdx#0@@3|))
))))
(assert (forall ((this@@62 T@U) (|childIdx#0@@4| Int) ) (!  (=> (= (type this@@62) DatatypeTypeType) (=> (and ($Is this@@62 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@4|)) (= (|PivotBetree.BetreeNode.DomainRoutedToChild#requires| this@@62 |childIdx#0@@4|)  (and (and (PivotBetree.BetreeNode.LocalStructure this@@62) (PivotBetree.BetreeNode.BetreeNode_q this@@62)) (PivotBetree.BetreeNode.ValidChildIndex this@@62 |childIdx#0@@4|)))))
 :qid |PivotBetreebrokenidfy.230:14|
 :skolemid |1739|
 :pattern ( (|PivotBetree.BetreeNode.DomainRoutedToChild#requires| this@@62 |childIdx#0@@4|))
)))
(assert  (=> (<= 17 $FunctionContextHeight) (forall ((this@@63 T@U) (|childIdx#0@@5| Int) ) (!  (=> (and (= (type this@@63) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@63 |childIdx#0@@5|) (and (not (= 17 $FunctionContextHeight)) (and (and ($Is this@@63 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@5|)) (and (and (PivotBetree.BetreeNode.LocalStructure this@@63) (PivotBetree.BetreeNode.BetreeNode_q this@@63)) (PivotBetree.BetreeNode.ValidChildIndex this@@63 |childIdx#0@@5|)))))) (= (PivotBetree.BetreeNode.DomainRoutedToChild this@@63 |childIdx#0@@5|) (let ((|out#0@@0| (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@63) |childIdx#0@@5|)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable this@@63) (INTERNAL_add_boogie |childIdx#0@@5| 1))))))
|out#0@@0|)))
 :qid |PivotBetreebrokenidfy.230:14|
 :skolemid |1740|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild this@@63 |childIdx#0@@5|))
))))
(assert  (=> (<= 17 $FunctionContextHeight) (forall ((this@@64 T@U) (|childIdx#0@@6| Int) ) (!  (=> (and (= (type this@@64) DatatypeTypeType) (or (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@64) (LitInt |childIdx#0@@6|)) (and (not (= 17 $FunctionContextHeight)) (and (and ($Is this@@64 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@6|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.LocalStructure (Lit this@@64))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@64)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@64) (LitInt |childIdx#0@@6|)))))))))) (= (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@64) (LitInt |childIdx#0@@6|)) (let ((|out#1@@0| (|#DomainMod.Domain.Domain| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@64))) (LitInt |childIdx#0@@6|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@64))) (LitInt (INTERNAL_add_boogie |childIdx#0@@6| 1)))))))
|out#1@@0|)))
 :qid |PivotBetreebrokenidfy.230:14|
 :weight 3
 :skolemid |1741|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@64) (LitInt |childIdx#0@@6|)))
))))
(assert  (=> (<= 34 $FunctionContextHeight) (forall ((this@@65 T@U) (|childIdx#0@@7| Int) ) (!  (=> (and (= (type this@@65) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| this@@65 |childIdx#0@@7|) (and (not (= 34 $FunctionContextHeight)) (and ($Is this@@65 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@7|))))) true)
 :qid |PivotBetreebrokenidfy.242:15|
 :skolemid |1744|
 :pattern ( (PivotBetree.BetreeNode.CanFlush this@@65 |childIdx#0@@7|))
))))
(assert (forall ((this@@66 T@U) (|childIdx#0@@8| Int) ) (!  (=> (= (type this@@66) DatatypeTypeType) (=> (and ($Is this@@66 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@8|)) (= (|PivotBetree.BetreeNode.CanFlush#requires| this@@66 |childIdx#0@@8|) true)))
 :qid |PivotBetreebrokenidfy.242:15|
 :skolemid |1745|
 :pattern ( (|PivotBetree.BetreeNode.CanFlush#requires| this@@66 |childIdx#0@@8|))
)))
(assert  (=> (<= 34 $FunctionContextHeight) (forall ((this@@67 T@U) (|childIdx#0@@9| Int) ) (!  (=> (and (= (type this@@67) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| this@@67 |childIdx#0@@9|) (and (not (= 34 $FunctionContextHeight)) (and ($Is this@@67 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@9|))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@67) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@67) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@67) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| this@@67 |childIdx#0@@9|)))) (= (PivotBetree.BetreeNode.CanFlush this@@67 |childIdx#0@@9|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@67) (PivotBetree.BetreeNode.BetreeNode_q this@@67)) (PivotBetree.BetreeNode.ValidChildIndex this@@67 |childIdx#0@@9|)))))
 :qid |PivotBetreebrokenidfy.242:15|
 :skolemid |1746|
 :pattern ( (PivotBetree.BetreeNode.CanFlush this@@67 |childIdx#0@@9|))
))))
(assert  (=> (<= 34 $FunctionContextHeight) (forall ((this@@68 T@U) (|childIdx#0@@10| Int) ) (!  (=> (and (= (type this@@68) DatatypeTypeType) (or (|PivotBetree.BetreeNode.CanFlush#canCall| (Lit this@@68) (LitInt |childIdx#0@@10|)) (and (not (= 34 $FunctionContextHeight)) (and ($Is this@@68 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@10|))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@68)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@68))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@68))))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit this@@68) (LitInt |childIdx#0@@10|))))) (= (PivotBetree.BetreeNode.CanFlush (Lit this@@68) (LitInt |childIdx#0@@10|)) (U_2_bool (Lit (bool_2_U  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@68)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@68))) (PivotBetree.BetreeNode.ValidChildIndex (Lit this@@68) (LitInt |childIdx#0@@10|)))))))))
 :qid |PivotBetreebrokenidfy.242:15|
 :weight 3
 :skolemid |1747|
 :pattern ( (PivotBetree.BetreeNode.CanFlush (Lit this@@68) (LitInt |childIdx#0@@10|)))
))))
(assert (forall ((arg0@@401 T@U) (arg1@@160 Int) ) (! (= (type (PivotBetree.BetreeNode.Flush arg0@@401 arg1@@160)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Flush|
 :pattern ( (PivotBetree.BetreeNode.Flush arg0@@401 arg1@@160))
)))
(assert  (=> (<= 35 $FunctionContextHeight) (forall ((this@@69 T@U) (|childIdx#0@@11| Int) ) (!  (=> (and (= (type this@@69) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| this@@69 |childIdx#0@@11|) (and (not (= 35 $FunctionContextHeight)) (and (and ($Is this@@69 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@11|)) (PivotBetree.BetreeNode.CanFlush this@@69 |childIdx#0@@11|))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.BetreeNode.Flush this@@69 |childIdx#0@@11|)) ($Is (PivotBetree.BetreeNode.Flush this@@69 |childIdx#0@@11|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.249:14|
 :skolemid |1750|
 :pattern ( (PivotBetree.BetreeNode.Flush this@@69 |childIdx#0@@11|))
))))
(assert (forall ((this@@70 T@U) (|childIdx#0@@12| Int) ) (!  (=> (= (type this@@70) DatatypeTypeType) (=> (and ($Is this@@70 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@12|)) (= (|PivotBetree.BetreeNode.Flush#requires| this@@70 |childIdx#0@@12|) (PivotBetree.BetreeNode.CanFlush this@@70 |childIdx#0@@12|))))
 :qid |PivotBetreebrokenidfy.249:14|
 :skolemid |1751|
 :pattern ( (|PivotBetree.BetreeNode.Flush#requires| this@@70 |childIdx#0@@12|))
)))
(assert (= (type Buffers.__default.AllKeys) (MapType0Type BoxType boolType)))
(assert  (=> (<= 35 $FunctionContextHeight) (forall ((this@@71 T@U) (|childIdx#0@@13| Int) ) (!  (=> (and (= (type this@@71) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| this@@71 |childIdx#0@@13|) (and (not (= 35 $FunctionContextHeight)) (and (and ($Is this@@71 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@13|)) (PivotBetree.BetreeNode.CanFlush this@@71 |childIdx#0@@13|))))) (and (and (and |Buffers.__default.AllKeys#canCall| (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@71 |childIdx#0@@13|) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))) (let ((|keepKeys#0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))))
 (and (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@71) |keepKeys#0|) (and (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@71 |childIdx#0@@13|) (|DomainMod.Domain.KeySet#canCall| (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|))) (|Buffers.BufferStack.ApplyFilter#canCall| (PivotBetree.BetreeNode.buffers this@@71) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))) (let ((|movedBuffers#0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@71) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))))
 (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| this@@71 |childIdx#0@@13|) (|PivotBetree.BetreeNode.Promote#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@71) |childIdx#0@@13|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@71) |childIdx#0@@13|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)) |movedBuffers#0|))))))) (= (PivotBetree.BetreeNode.Flush this@@71 |childIdx#0@@13|) (let ((|keepKeys#0@@0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))))
(let ((|keptBuffers#0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@71) |keepKeys#0@@0|)))
(let ((|movedBuffers#0@@0| (Buffers.BufferStack.ApplyFilter (PivotBetree.BetreeNode.buffers this@@71) (DomainMod.Domain.KeySet (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)))))
(let ((|newChild#0| (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@71) |childIdx#0@@13|)) (PivotBetree.BetreeNode.DomainRoutedToChild this@@71 |childIdx#0@@13|)) |movedBuffers#0@@0|)))
(|#PivotBetree.BetreeNode.BetreeNode| |keptBuffers#0| (PivotBetree.BetreeNode.pivotTable this@@71) (|Seq#Update| (PivotBetree.BetreeNode.children this@@71) |childIdx#0@@13| ($Box |newChild#0|))))))))))
 :qid |PivotBetreebrokenidfy.249:14|
 :skolemid |1752|
 :pattern ( (PivotBetree.BetreeNode.Flush this@@71 |childIdx#0@@13|))
))))
(assert  (=> (<= 35 $FunctionContextHeight) (forall ((this@@72 T@U) (|childIdx#0@@14| Int) ) (!  (=> (and (= (type this@@72) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Flush#canCall| (Lit this@@72) (LitInt |childIdx#0@@14|)) (and (not (= 35 $FunctionContextHeight)) (and (and ($Is this@@72 Tclass.PivotBetree.BetreeNode) (INTERNAL_le_boogie 0 |childIdx#0@@14|)) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanFlush (Lit this@@72) (LitInt |childIdx#0@@14|))))))))) (and (and (and |Buffers.__default.AllKeys#canCall| (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@72) (LitInt |childIdx#0@@14|)) (|DomainMod.Domain.KeySet#canCall| (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))))) (let ((|keepKeys#1| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))))))
 (and (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@72))) |keepKeys#1|) (and (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@72) (LitInt |childIdx#0@@14|)) (|DomainMod.Domain.KeySet#canCall| (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|))))) (|Buffers.BufferStack.ApplyFilter#canCall| (Lit (PivotBetree.BetreeNode.buffers (Lit this@@72))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|))))))) (let ((|movedBuffers#1| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@72))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))))))))
 (and (and (|PivotBetree.BetreeNode.DomainRoutedToChild#canCall| (Lit this@@72) (LitInt |childIdx#0@@14|)) (|PivotBetree.BetreeNode.Promote#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@72))) (LitInt |childIdx#0@@14|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|))))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@72))) (LitInt |childIdx#0@@14|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))) |movedBuffers#1|))))))) (= (PivotBetree.BetreeNode.Flush (Lit this@@72) (LitInt |childIdx#0@@14|)) (let ((|keepKeys#1@@0| (|ISet#Difference| Buffers.__default.AllKeys (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))))))
(let ((|keptBuffers#1| (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@72))) |keepKeys#1@@0|)))
(let ((|movedBuffers#1@@0| (Lit (Buffers.BufferStack.ApplyFilter (Lit (PivotBetree.BetreeNode.buffers (Lit this@@72))) (Lit (DomainMod.Domain.KeySet (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))))))))
(let ((|newChild#1| (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@72))) (LitInt |childIdx#0@@14|))) (Lit (PivotBetree.BetreeNode.DomainRoutedToChild (Lit this@@72) (LitInt |childIdx#0@@14|)))) |movedBuffers#1@@0|)))
(|#PivotBetree.BetreeNode.BetreeNode| |keptBuffers#1| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@72))) (|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit this@@72))) (LitInt |childIdx#0@@14|) ($Box |newChild#1|))))))))))
 :qid |PivotBetreebrokenidfy.249:14|
 :weight 3
 :skolemid |1753|
 :pattern ( (PivotBetree.BetreeNode.Flush (Lit this@@72) (LitInt |childIdx#0@@14|)))
))))
(assert (forall ((arg0@@402 T@U) ) (! (= (type (PivotBetree.BetreeNode.Buffers arg0@@402)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Buffers|
 :pattern ( (PivotBetree.BetreeNode.Buffers arg0@@402))
)))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((this@@73 T@U) ) (!  (=> (and (= (type this@@73) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| this@@73) (and (not (= 36 $FunctionContextHeight)) ($Is this@@73 Tclass.PivotBetree.BetreeNode)))) ($Is (PivotBetree.BetreeNode.Buffers this@@73) Tclass.Buffers.BufferStack))
 :qid |PivotBetreebrokenidfy.261:14|
 :skolemid |1798|
 :pattern ( (PivotBetree.BetreeNode.Buffers this@@73))
))))
(assert (forall ((this@@74 T@U) ) (!  (=> (and (= (type this@@74) DatatypeTypeType) ($Is this@@74 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.Buffers#requires| this@@74) true))
 :qid |PivotBetreebrokenidfy.261:14|
 :skolemid |1799|
 :pattern ( (|PivotBetree.BetreeNode.Buffers#requires| this@@74))
)))
(assert (forall ((arg0@@403 T@U) ) (! (= (type (|#Buffers.BufferStack.BufferStack| arg0@@403)) DatatypeTypeType)
 :qid |funType:#Buffers.BufferStack.BufferStack|
 :pattern ( (|#Buffers.BufferStack.BufferStack| arg0@@403))
)))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((this@@75 T@U) ) (!  (=> (and (= (type this@@75) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| this@@75) (and (not (= 36 $FunctionContextHeight)) ($Is this@@75 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.Buffers this@@75) (ite (PivotBetree.BetreeNode.Nil_q this@@75) (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType))) (PivotBetree.BetreeNode.buffers this@@75))))
 :qid |PivotBetreebrokenidfy.261:14|
 :skolemid |1800|
 :pattern ( (PivotBetree.BetreeNode.Buffers this@@75))
))))
(assert  (=> (<= 36 $FunctionContextHeight) (forall ((this@@76 T@U) ) (!  (=> (and (= (type this@@76) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Buffers#canCall| (Lit this@@76)) (and (not (= 36 $FunctionContextHeight)) ($Is this@@76 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.Buffers (Lit this@@76)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@76)) (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType))) (PivotBetree.BetreeNode.buffers (Lit this@@76)))))
 :qid |PivotBetreebrokenidfy.261:14|
 :weight 3
 :skolemid |1801|
 :pattern ( (PivotBetree.BetreeNode.Buffers (Lit this@@76)))
))))
(assert (forall ((arg0@@404 T@U) ) (! (= (type (PivotBetree.BetreeNode.Children arg0@@404)) (SeqType BoxType))
 :qid |funType:PivotBetree.BetreeNode.Children|
 :pattern ( (PivotBetree.BetreeNode.Children arg0@@404))
)))
(assert  (=> (<= 37 $FunctionContextHeight) (forall ((this@@77 T@U) ) (!  (=> (and (= (type this@@77) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| this@@77) (and (not (= 37 $FunctionContextHeight)) ($Is this@@77 Tclass.PivotBetree.BetreeNode)))) ($Is (PivotBetree.BetreeNode.Children this@@77) (TSeq Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.266:14|
 :skolemid |1802|
 :pattern ( (PivotBetree.BetreeNode.Children this@@77))
))))
(assert (forall ((this@@78 T@U) ) (!  (=> (and (= (type this@@78) DatatypeTypeType) ($Is this@@78 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.Children#requires| this@@78) true))
 :qid |PivotBetreebrokenidfy.266:14|
 :skolemid |1803|
 :pattern ( (|PivotBetree.BetreeNode.Children#requires| this@@78))
)))
(assert  (=> (<= 37 $FunctionContextHeight) (forall ((this@@79 T@U) ) (!  (=> (and (= (type this@@79) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| this@@79) (and (not (= 37 $FunctionContextHeight)) ($Is this@@79 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.Children this@@79) (ite (PivotBetree.BetreeNode.Nil_q this@@79) (|Seq#Empty| BoxType) (PivotBetree.BetreeNode.children this@@79))))
 :qid |PivotBetreebrokenidfy.266:14|
 :skolemid |1804|
 :pattern ( (PivotBetree.BetreeNode.Children this@@79))
))))
(assert  (=> (<= 37 $FunctionContextHeight) (forall ((this@@80 T@U) ) (!  (=> (and (= (type this@@80) DatatypeTypeType) (or (|PivotBetree.BetreeNode.Children#canCall| (Lit this@@80)) (and (not (= 37 $FunctionContextHeight)) ($Is this@@80 Tclass.PivotBetree.BetreeNode)))) (= (PivotBetree.BetreeNode.Children (Lit this@@80)) (ite (PivotBetree.BetreeNode.Nil_q (Lit this@@80)) (|Seq#Empty| BoxType) (PivotBetree.BetreeNode.children (Lit this@@80)))))
 :qid |PivotBetreebrokenidfy.266:14|
 :weight 3
 :skolemid |1805|
 :pattern ( (PivotBetree.BetreeNode.Children (Lit this@@80)))
))))
(assert  (=> (<= 38 $FunctionContextHeight) (forall ((this@@81 T@U) (|key#0| T@U) ) (!  (=> (and (and (= (type this@@81) DatatypeTypeType) (= (type |key#0|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@81 |key#0|) (and (not (= 38 $FunctionContextHeight)) (and ($Is this@@81 Tclass.PivotBetree.BetreeNode) ($Is |key#0| Tclass.KeyType.Key))))) true)
 :qid |PivotBetreebrokenidfy.271:15|
 :skolemid |1806|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@81 |key#0|))
))))
(assert (forall ((this@@82 T@U) (|key#0@@0| T@U) ) (!  (=> (and (and (= (type this@@82) DatatypeTypeType) (= (type |key#0@@0|) (SeqType BoxType))) (and ($Is this@@82 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@0| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.KeyInDomain#requires| this@@82 |key#0@@0|) true))
 :qid |PivotBetreebrokenidfy.271:15|
 :skolemid |1807|
 :pattern ( (|PivotBetree.BetreeNode.KeyInDomain#requires| this@@82 |key#0@@0|))
)))
(assert  (=> (<= 38 $FunctionContextHeight) (forall ((this@@83 T@U) (|key#0@@1| T@U) ) (!  (=> (and (and (= (type this@@83) DatatypeTypeType) (= (type |key#0@@1|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@83 |key#0@@1|) (and (not (= 38 $FunctionContextHeight)) (and ($Is this@@83 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@1| Tclass.KeyType.Key))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| this@@83) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) this@@83) (=> (PivotBetree.BetreeNode.BetreeNode_q this@@83) (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable this@@83) |key#0@@1|)))) (= (PivotBetree.BetreeNode.KeyInDomain this@@83 |key#0@@1|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@83) (PivotBetree.BetreeNode.BetreeNode_q this@@83)) (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable this@@83) |key#0@@1|)))))
 :qid |PivotBetreebrokenidfy.271:15|
 :skolemid |1808|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@83 |key#0@@1|))
))))
(assert  (=> (<= 38 $FunctionContextHeight) (forall ((this@@84 T@U) (|key#0@@2| T@U) ) (!  (=> (and (and (= (type this@@84) DatatypeTypeType) (= (type |key#0@@2|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit this@@84) (Lit |key#0@@2|)) (and (not (= 38 $FunctionContextHeight)) (and ($Is this@@84 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@2| Tclass.KeyType.Key))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit this@@84)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@84))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@84))))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@84))) (Lit |key#0@@2|))))) (= (PivotBetree.BetreeNode.KeyInDomain (Lit this@@84) (Lit |key#0@@2|)) (U_2_bool (Lit (bool_2_U  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@84)) (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@84))) (BoundedPivotsLib.__default.BoundedKey (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@84))) (Lit |key#0@@2|)))))))))
 :qid |PivotBetreebrokenidfy.271:15|
 :weight 3
 :skolemid |1809|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain (Lit this@@84) (Lit |key#0@@2|)))
))))
(assert (forall ((arg0@@405 T@U) ) (! (= (type (PivotBetree.BetreeNode.KeySet arg0@@405)) (MapType0Type BoxType boolType))
 :qid |funType:PivotBetree.BetreeNode.KeySet|
 :pattern ( (PivotBetree.BetreeNode.KeySet arg0@@405))
)))
(assert  (=> (<= 39 $FunctionContextHeight) (forall ((this@@85 T@U) ) (!  (=> (and (= (type this@@85) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| this@@85) (and (not (= 39 $FunctionContextHeight)) (and ($Is this@@85 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@85) (PivotBetree.BetreeNode.BetreeNode_q this@@85)))))) ($Is (PivotBetree.BetreeNode.KeySet this@@85) (TISet Tclass.KeyType.Key)))
 :qid |PivotBetreebrokenidfy.279:14|
 :skolemid |1816|
 :pattern ( (PivotBetree.BetreeNode.KeySet this@@85))
))))
(assert (forall ((this@@86 T@U) ) (!  (=> (and (= (type this@@86) DatatypeTypeType) ($Is this@@86 Tclass.PivotBetree.BetreeNode)) (= (|PivotBetree.BetreeNode.KeySet#requires| this@@86)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@86) (PivotBetree.BetreeNode.BetreeNode_q this@@86))))
 :qid |PivotBetreebrokenidfy.279:14|
 :skolemid |1817|
 :pattern ( (|PivotBetree.BetreeNode.KeySet#requires| this@@86))
)))
(assert (forall ((arg0@@406 T@U) (arg1@@161 T@U) ) (! (= (type (|lambda#44| arg0@@406 arg1@@161)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#44|
 :pattern ( (|lambda#44| arg0@@406 arg1@@161))
)))
(assert  (=> (<= 39 $FunctionContextHeight) (forall ((this@@87 T@U) ) (!  (=> (and (= (type this@@87) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| this@@87) (and (not (= 39 $FunctionContextHeight)) (and ($Is this@@87 Tclass.PivotBetree.BetreeNode) (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@87) (PivotBetree.BetreeNode.BetreeNode_q this@@87)))))) (and (forall ((|key#0@@3| T@U) ) (!  (=> (and (= (type |key#0@@3|) (SeqType BoxType)) ($Is |key#0@@3| Tclass.KeyType.Key)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| this@@87 |key#0@@3|))
 :qid |PivotBetreebrokenidfy.283:12|
 :skolemid |1818|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@87 |key#0@@3|))
)) (= (PivotBetree.BetreeNode.KeySet this@@87) (|lambda#44| Tclass.KeyType.Key this@@87))))
 :qid |PivotBetreebrokenidfy.279:14|
 :skolemid |1819|
 :pattern ( (PivotBetree.BetreeNode.KeySet this@@87))
))))
(assert  (=> (<= 39 $FunctionContextHeight) (forall ((this@@88 T@U) ) (!  (=> (and (= (type this@@88) DatatypeTypeType) (or (|PivotBetree.BetreeNode.KeySet#canCall| (Lit this@@88)) (and (not (= 39 $FunctionContextHeight)) (and ($Is this@@88 Tclass.PivotBetree.BetreeNode) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@88))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@88)))))))))) (and (forall ((|key#1| T@U) ) (!  (=> (and (= (type |key#1|) (SeqType BoxType)) ($Is |key#1| Tclass.KeyType.Key)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit this@@88) |key#1|))
 :qid |PivotBetreebrokenidfy.283:12|
 :skolemid |1820|
 :pattern ( (PivotBetree.BetreeNode.KeyInDomain this@@88 |key#1|))
)) (= (PivotBetree.BetreeNode.KeySet (Lit this@@88)) (|lambda#44| Tclass.KeyType.Key (Lit this@@88)))))
 :qid |PivotBetreebrokenidfy.279:14|
 :weight 3
 :skolemid |1821|
 :pattern ( (PivotBetree.BetreeNode.KeySet (Lit this@@88)))
))))
(assert (forall ((arg0@@407 T@U) (arg1@@162 T@U) ) (! (= (type (PivotBetree.BetreeNode.Child arg0@@407 arg1@@162)) DatatypeTypeType)
 :qid |funType:PivotBetree.BetreeNode.Child|
 :pattern ( (PivotBetree.BetreeNode.Child arg0@@407 arg1@@162))
)))
(assert  (=> (<= 40 $FunctionContextHeight) (forall ((this@@89 T@U) (|key#0@@4| T@U) ) (!  (=> (and (and (= (type this@@89) DatatypeTypeType) (= (type |key#0@@4|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| this@@89 |key#0@@4|) (and (not (= 40 $FunctionContextHeight)) (and (and ($Is this@@89 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@4| Tclass.KeyType.Key)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@89) (PivotBetree.BetreeNode.BetreeNode_q this@@89)) (PivotBetree.BetreeNode.KeyInDomain this@@89 |key#0@@4|)))))) ($Is (PivotBetree.BetreeNode.Child this@@89 |key#0@@4|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreebrokenidfy.286:14|
 :skolemid |1825|
 :pattern ( (PivotBetree.BetreeNode.Child this@@89 |key#0@@4|))
))))
(assert (forall ((this@@90 T@U) (|key#0@@5| T@U) ) (!  (=> (and (and (= (type this@@90) DatatypeTypeType) (= (type |key#0@@5|) (SeqType BoxType))) (and ($Is this@@90 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@5| Tclass.KeyType.Key))) (= (|PivotBetree.BetreeNode.Child#requires| this@@90 |key#0@@5|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@90) (PivotBetree.BetreeNode.BetreeNode_q this@@90)) (PivotBetree.BetreeNode.KeyInDomain this@@90 |key#0@@5|))))
 :qid |PivotBetreebrokenidfy.286:14|
 :skolemid |1826|
 :pattern ( (|PivotBetree.BetreeNode.Child#requires| this@@90 |key#0@@5|))
)))
(assert  (=> (<= 40 $FunctionContextHeight) (forall ((this@@91 T@U) (|key#0@@6| T@U) ) (!  (=> (and (and (= (type this@@91) DatatypeTypeType) (= (type |key#0@@6|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| this@@91 |key#0@@6|) (and (not (= 40 $FunctionContextHeight)) (and (and ($Is this@@91 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@6| Tclass.KeyType.Key)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) this@@91) (PivotBetree.BetreeNode.BetreeNode_q this@@91)) (PivotBetree.BetreeNode.KeyInDomain this@@91 |key#0@@6|)))))) (and (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable this@@91) |key#0@@6|) (= (PivotBetree.BetreeNode.Child this@@91 |key#0@@6|) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children this@@91) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable this@@91) |key#0@@6|))))))
 :qid |PivotBetreebrokenidfy.286:14|
 :skolemid |1827|
 :pattern ( (PivotBetree.BetreeNode.Child this@@91 |key#0@@6|))
))))
(assert  (=> (<= 40 $FunctionContextHeight) (forall ((this@@92 T@U) (|key#0@@7| T@U) ) (!  (=> (and (and (= (type this@@92) DatatypeTypeType) (= (type |key#0@@7|) (SeqType BoxType))) (or (|PivotBetree.BetreeNode.Child#canCall| (Lit this@@92) (Lit |key#0@@7|)) (and (not (= 40 $FunctionContextHeight)) (and (and ($Is this@@92 Tclass.PivotBetree.BetreeNode) ($Is |key#0@@7| Tclass.KeyType.Key)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit this@@92))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit this@@92)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit this@@92) (Lit |key#0@@7|)))))))))) (and (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@92))) (Lit |key#0@@7|)) (= (PivotBetree.BetreeNode.Child (Lit this@@92) (Lit |key#0@@7|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit this@@92))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit this@@92))) (Lit |key#0@@7|))))))))
 :qid |PivotBetreebrokenidfy.286:14|
 :weight 3
 :skolemid |1828|
 :pattern ( (PivotBetree.BetreeNode.Child (Lit this@@92) (Lit |key#0@@7|)))
))))
(assert (forall ((arg0@@408 T@U) (arg1@@163 T@U) ) (! (= (type (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| arg0@@408 arg1@@163)) DatatypeTypeType)
 :qid |funType:#PivotBetree.QueryReceiptLine.QueryReceiptLine|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| arg0@@408 arg1@@163))
)))
(assert (forall ((|a#0#0#0@@0| T@U) (|a#0#1#0@@0| T@U) ) (!  (=> (and (= (type |a#0#0#0@@0|) DatatypeTypeType) (= (type |a#0#1#0@@0|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@0| |a#0#1#0@@0|)) |##PivotBetree.QueryReceiptLine.QueryReceiptLine|))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1839|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#0#0#0@@0| |a#0#1#0@@0|))
)))
(assert (forall ((d@@43 T@U) ) (!  (=> (= (type d@@43) DatatypeTypeType) (= (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@43) (= (DatatypeCtorId d@@43) |##PivotBetree.QueryReceiptLine.QueryReceiptLine|)))
 :qid |unknown.0:0|
 :skolemid |1840|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@43))
)))
(assert (forall ((d@@44 T@U) ) (!  (=> (and (= (type d@@44) DatatypeTypeType) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@44)) (exists ((|a#1#0#0@@0| T@U) (|a#1#1#0@@0| T@U) ) (!  (and (and (= (type |a#1#0#0@@0|) DatatypeTypeType) (= (type |a#1#1#0@@0|) DatatypeTypeType)) (= d@@44 (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#1#0#0@@0| |a#1#1#0@@0|)))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1841|
 :no-pattern (type |a#1#0#0@@0|)
 :no-pattern (type |a#1#1#0@@0|)
 :no-pattern (U_2_int |a#1#0#0@@0|)
 :no-pattern (U_2_bool |a#1#0#0@@0|)
 :no-pattern (U_2_int |a#1#1#0@@0|)
 :no-pattern (U_2_bool |a#1#1#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |1842|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@44))
)))
(assert (= (type Tclass.ValueMessage.Message) TyType))
(assert (= (Tag Tclass.ValueMessage.Message) Tagclass.ValueMessage.Message))
(assert (= (TagFamily Tclass.ValueMessage.Message) tytagFamily$Message))
(assert (forall ((bx@@117 T@U) ) (!  (=> (and (= (type bx@@117) BoxType) ($IsBox bx@@117 Tclass.ValueMessage.Message)) (and (= ($Box ($Unbox DatatypeTypeType bx@@117)) bx@@117) ($Is ($Unbox DatatypeTypeType bx@@117) Tclass.ValueMessage.Message)))
 :qid |unknown.0:0|
 :skolemid |1843|
 :pattern ( ($IsBox bx@@117 Tclass.ValueMessage.Message))
)))
(assert (= (type Tclass.PivotBetree.QueryReceiptLine) TyType))
(assert (= (Tag Tclass.PivotBetree.QueryReceiptLine) Tagclass.PivotBetree.QueryReceiptLine))
(assert (= (TagFamily Tclass.PivotBetree.QueryReceiptLine) tytagFamily$QueryReceiptLine))
(assert (forall ((bx@@118 T@U) ) (!  (=> (and (= (type bx@@118) BoxType) ($IsBox bx@@118 Tclass.PivotBetree.QueryReceiptLine)) (and (= ($Box ($Unbox DatatypeTypeType bx@@118)) bx@@118) ($Is ($Unbox DatatypeTypeType bx@@118) Tclass.PivotBetree.QueryReceiptLine)))
 :qid |unknown.0:0|
 :skolemid |1844|
 :pattern ( ($IsBox bx@@118 Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (forall ((|a#2#0#0@@0| T@U) (|a#2#1#0@@0| T@U) ) (!  (=> (and (= (type |a#2#0#0@@0|) DatatypeTypeType) (= (type |a#2#1#0@@0|) DatatypeTypeType)) (= ($Is (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@0| |a#2#1#0@@0|) Tclass.PivotBetree.QueryReceiptLine)  (and ($Is |a#2#0#0@@0| Tclass.PivotBetree.BetreeNode) ($Is |a#2#1#0@@0| Tclass.ValueMessage.Message))))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1845|
 :pattern ( ($Is (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#2#0#0@@0| |a#2#1#0@@0|) Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (forall ((|a#3#0#0@@0| T@U) (|a#3#1#0@@0| T@U) ($h@@65 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@0|) DatatypeTypeType) (= (type |a#3#1#0@@0|) DatatypeTypeType)) (= (type $h@@65) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@65)) (= ($IsAlloc (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@0| |a#3#1#0@@0|) Tclass.PivotBetree.QueryReceiptLine $h@@65)  (and ($IsAlloc |a#3#0#0@@0| Tclass.PivotBetree.BetreeNode $h@@65) ($IsAlloc |a#3#1#0@@0| Tclass.ValueMessage.Message $h@@65))))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1846|
 :pattern ( ($IsAlloc (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#3#0#0@@0| |a#3#1#0@@0|) Tclass.PivotBetree.QueryReceiptLine $h@@65))
)))
(assert (forall ((arg0@@409 T@U) ) (! (= (type (PivotBetree.QueryReceiptLine.node arg0@@409)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceiptLine.node|
 :pattern ( (PivotBetree.QueryReceiptLine.node arg0@@409))
)))
(assert (forall ((d@@45 T@U) ($h@@66 T@U) ) (!  (=> (and (and (= (type d@@45) DatatypeTypeType) (= (type $h@@66) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@66) (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@45) ($IsAlloc d@@45 Tclass.PivotBetree.QueryReceiptLine $h@@66)))) ($IsAlloc (PivotBetree.QueryReceiptLine.node d@@45) Tclass.PivotBetree.BetreeNode $h@@66))
 :qid |unknown.0:0|
 :skolemid |1847|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceiptLine.node d@@45) Tclass.PivotBetree.BetreeNode $h@@66))
)))
(assert (forall ((arg0@@410 T@U) ) (! (= (type (PivotBetree.QueryReceiptLine.result arg0@@410)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceiptLine.result|
 :pattern ( (PivotBetree.QueryReceiptLine.result arg0@@410))
)))
(assert (forall ((d@@46 T@U) ($h@@67 T@U) ) (!  (=> (and (and (= (type d@@46) DatatypeTypeType) (= (type $h@@67) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@67) (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@46) ($IsAlloc d@@46 Tclass.PivotBetree.QueryReceiptLine $h@@67)))) ($IsAlloc (PivotBetree.QueryReceiptLine.result d@@46) Tclass.ValueMessage.Message $h@@67))
 :qid |unknown.0:0|
 :skolemid |1848|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceiptLine.result d@@46) Tclass.ValueMessage.Message $h@@67))
)))
(assert (forall ((|a#4#0#0@@0| T@U) (|a#4#1#0@@0| T@U) ) (!  (=> (and (= (type |a#4#0#0@@0|) DatatypeTypeType) (= (type |a#4#1#0@@0|) DatatypeTypeType)) (= (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@0|) (Lit |a#4#1#0@@0|)) (Lit (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#4#0#0@@0| |a#4#1#0@@0|))))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1849|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| (Lit |a#4#0#0@@0|) (Lit |a#4#1#0@@0|)))
)))
(assert (forall ((|a#5#0#0@@0| T@U) (|a#5#1#0@@0| T@U) ) (!  (=> (and (= (type |a#5#0#0@@0|) DatatypeTypeType) (= (type |a#5#1#0@@0|) DatatypeTypeType)) (= (PivotBetree.QueryReceiptLine.node (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@0| |a#5#1#0@@0|)) |a#5#0#0@@0|))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1850|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#5#0#0@@0| |a#5#1#0@@0|))
)))
(assert (forall ((|a#6#0#0@@0| T@U) (|a#6#1#0@@0| T@U) ) (!  (=> (and (= (type |a#6#0#0@@0|) DatatypeTypeType) (= (type |a#6#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@0|) (DtRank (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@0| |a#6#1#0@@0|))))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1851|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#6#0#0@@0| |a#6#1#0@@0|))
)))
(assert (forall ((|a#7#0#0@@0| T@U) (|a#7#1#0@@0| T@U) ) (!  (=> (and (= (type |a#7#0#0@@0|) DatatypeTypeType) (= (type |a#7#1#0@@0|) DatatypeTypeType)) (= (PivotBetree.QueryReceiptLine.result (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@0| |a#7#1#0@@0|)) |a#7#1#0@@0|))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1852|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#7#0#0@@0| |a#7#1#0@@0|))
)))
(assert (forall ((|a#8#0#0@@0| T@U) (|a#8#1#0@@0| T@U) ) (!  (=> (and (= (type |a#8#0#0@@0|) DatatypeTypeType) (= (type |a#8#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@0|) (DtRank (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@0| |a#8#1#0@@0|))))
 :qid |PivotBetreebrokenidfy.310:5|
 :skolemid |1853|
 :pattern ( (|#PivotBetree.QueryReceiptLine.QueryReceiptLine| |a#8#0#0@@0| |a#8#1#0@@0|))
)))
(assert (forall ((d@@47 T@U) ) (!  (=> (and (= (type d@@47) DatatypeTypeType) (|$IsA#PivotBetree.QueryReceiptLine| d@@47)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@47))
 :qid |unknown.0:0|
 :skolemid |1854|
 :pattern ( (|$IsA#PivotBetree.QueryReceiptLine| d@@47))
)))
(assert (forall ((d@@48 T@U) ) (!  (=> (and (= (type d@@48) DatatypeTypeType) ($Is d@@48 Tclass.PivotBetree.QueryReceiptLine)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@48))
 :qid |unknown.0:0|
 :skolemid |1855|
 :pattern ( (PivotBetree.QueryReceiptLine.QueryReceiptLine_q d@@48) ($Is d@@48 Tclass.PivotBetree.QueryReceiptLine))
)))
(assert (forall ((a@@127 T@U) (b@@76 T@U) ) (!  (=> (and (and (= (type a@@127) DatatypeTypeType) (= (type b@@76) DatatypeTypeType)) true) (= (|PivotBetree.QueryReceiptLine#Equal| a@@127 b@@76)  (and (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node a@@127) (PivotBetree.QueryReceiptLine.node b@@76)) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result a@@127) (PivotBetree.QueryReceiptLine.result b@@76)))))
 :qid |unknown.0:0|
 :skolemid |1856|
 :pattern ( (|PivotBetree.QueryReceiptLine#Equal| a@@127 b@@76))
)))
(assert (forall ((a@@128 T@U) (b@@77 T@U) ) (!  (=> (and (= (type a@@128) DatatypeTypeType) (= (type b@@77) DatatypeTypeType)) (= (|PivotBetree.QueryReceiptLine#Equal| a@@128 b@@77) (= a@@128 b@@77)))
 :qid |unknown.0:0|
 :skolemid |1857|
 :pattern ( (|PivotBetree.QueryReceiptLine#Equal| a@@128 b@@77))
)))
(assert  (=> (<= 44 $FunctionContextHeight) (forall ((this@@93 T@U) ) (!  (=> (and (= (type this@@93) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| this@@93) (and (not (= 44 $FunctionContextHeight)) ($Is this@@93 Tclass.PivotBetree.QueryReceiptLine)))) true)
 :qid |PivotBetreebrokenidfy.313:15|
 :skolemid |1858|
 :pattern ( (PivotBetree.QueryReceiptLine.WF this@@93))
))))
(assert (forall ((this@@94 T@U) ) (!  (=> (and (= (type this@@94) DatatypeTypeType) ($Is this@@94 Tclass.PivotBetree.QueryReceiptLine)) (= (|PivotBetree.QueryReceiptLine.WF#requires| this@@94) true))
 :qid |PivotBetreebrokenidfy.313:15|
 :skolemid |1859|
 :pattern ( (|PivotBetree.QueryReceiptLine.WF#requires| this@@94))
)))
(assert  (=> (<= 44 $FunctionContextHeight) (forall ((this@@95 T@U) ) (!  (=> (and (= (type this@@95) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| this@@95) (and (not (= 44 $FunctionContextHeight)) ($Is this@@95 Tclass.PivotBetree.QueryReceiptLine)))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q this@@95) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.QueryReceiptLine.node this@@95))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.QueryReceiptLine.node this@@95)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q this@@95))) (= (PivotBetree.QueryReceiptLine.WF this@@95)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.QueryReceiptLine.node this@@95)) (ValueMessage.Message.Define_q (PivotBetree.QueryReceiptLine.result this@@95))))))
 :qid |PivotBetreebrokenidfy.313:15|
 :skolemid |1860|
 :pattern ( (PivotBetree.QueryReceiptLine.WF this@@95))
))))
(assert  (=> (<= 44 $FunctionContextHeight) (forall ((this@@96 T@U) ) (!  (=> (and (= (type this@@96) DatatypeTypeType) (or (|PivotBetree.QueryReceiptLine.WF#canCall| (Lit this@@96)) (and (not (= 44 $FunctionContextHeight)) ($Is this@@96 Tclass.PivotBetree.QueryReceiptLine)))) (and (and (and (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@96)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@96))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@96))))))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit this@@96)))) (= (PivotBetree.QueryReceiptLine.WF (Lit this@@96)) (U_2_bool (Lit (bool_2_U  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.QueryReceiptLine.node (Lit this@@96)))) (ValueMessage.Message.Define_q (Lit (PivotBetree.QueryReceiptLine.result (Lit this@@96)))))))))))
 :qid |PivotBetreebrokenidfy.313:15|
 :weight 3
 :skolemid |1861|
 :pattern ( (PivotBetree.QueryReceiptLine.WF (Lit this@@96)))
))))
(assert (forall ((arg0@@411 T@U) (arg1@@164 T@U) (arg2@@83 T@U) ) (! (= (type (|#PivotBetree.QueryReceipt.QueryReceipt| arg0@@411 arg1@@164 arg2@@83)) DatatypeTypeType)
 :qid |funType:#PivotBetree.QueryReceipt.QueryReceipt|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| arg0@@411 arg1@@164 arg2@@83))
)))
(assert (forall ((|a#0#0#0@@1| T@U) (|a#0#1#0@@1| T@U) (|a#0#2#0| T@U) ) (!  (=> (and (and (= (type |a#0#0#0@@1|) (SeqType BoxType)) (= (type |a#0#1#0@@1|) DatatypeTypeType)) (= (type |a#0#2#0|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@1| |a#0#1#0@@1| |a#0#2#0|)) |##PivotBetree.QueryReceipt.QueryReceipt|))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1863|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#0#0#0@@1| |a#0#1#0@@1| |a#0#2#0|))
)))
(assert (forall ((d@@49 T@U) ) (!  (=> (= (type d@@49) DatatypeTypeType) (= (PivotBetree.QueryReceipt.QueryReceipt_q d@@49) (= (DatatypeCtorId d@@49) |##PivotBetree.QueryReceipt.QueryReceipt|)))
 :qid |unknown.0:0|
 :skolemid |1864|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@49))
)))
(assert (forall ((d@@50 T@U) ) (!  (=> (and (= (type d@@50) DatatypeTypeType) (PivotBetree.QueryReceipt.QueryReceipt_q d@@50)) (exists ((|a#1#0#0@@1| T@U) (|a#1#1#0@@1| T@U) (|a#1#2#0| T@U) ) (!  (and (and (and (= (type |a#1#0#0@@1|) (SeqType BoxType)) (= (type |a#1#1#0@@1|) DatatypeTypeType)) (= (type |a#1#2#0|) (SeqType BoxType))) (= d@@50 (|#PivotBetree.QueryReceipt.QueryReceipt| |a#1#0#0@@1| |a#1#1#0@@1| |a#1#2#0|)))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1865|
 :no-pattern (type |a#1#0#0@@1|)
 :no-pattern (type |a#1#1#0@@1|)
 :no-pattern (type |a#1#2#0|)
 :no-pattern (U_2_int |a#1#0#0@@1|)
 :no-pattern (U_2_bool |a#1#0#0@@1|)
 :no-pattern (U_2_int |a#1#1#0@@1|)
 :no-pattern (U_2_bool |a#1#1#0@@1|)
 :no-pattern (U_2_int |a#1#2#0|)
 :no-pattern (U_2_bool |a#1#2#0|)
)))
 :qid |unknown.0:0|
 :skolemid |1866|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@50))
)))
(assert (= (type Tclass.PivotBetree.QueryReceipt) TyType))
(assert (= (Tag Tclass.PivotBetree.QueryReceipt) Tagclass.PivotBetree.QueryReceipt))
(assert (= (TagFamily Tclass.PivotBetree.QueryReceipt) tytagFamily$QueryReceipt))
(assert (forall ((bx@@119 T@U) ) (!  (=> (and (= (type bx@@119) BoxType) ($IsBox bx@@119 Tclass.PivotBetree.QueryReceipt)) (and (= ($Box ($Unbox DatatypeTypeType bx@@119)) bx@@119) ($Is ($Unbox DatatypeTypeType bx@@119) Tclass.PivotBetree.QueryReceipt)))
 :qid |unknown.0:0|
 :skolemid |1867|
 :pattern ( ($IsBox bx@@119 Tclass.PivotBetree.QueryReceipt))
)))
(assert (forall ((|a#2#0#0@@1| T@U) (|a#2#1#0@@1| T@U) (|a#2#2#0| T@U) ) (!  (=> (and (and (= (type |a#2#0#0@@1|) (SeqType BoxType)) (= (type |a#2#1#0@@1|) DatatypeTypeType)) (= (type |a#2#2#0|) (SeqType BoxType))) (= ($Is (|#PivotBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@1| |a#2#1#0@@1| |a#2#2#0|) Tclass.PivotBetree.QueryReceipt)  (and (and ($Is |a#2#0#0@@1| Tclass.KeyType.Key) ($Is |a#2#1#0@@1| Tclass.PivotBetree.BetreeNode)) ($Is |a#2#2#0| (TSeq Tclass.PivotBetree.QueryReceiptLine)))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1868|
 :pattern ( ($Is (|#PivotBetree.QueryReceipt.QueryReceipt| |a#2#0#0@@1| |a#2#1#0@@1| |a#2#2#0|) Tclass.PivotBetree.QueryReceipt))
)))
(assert (forall ((|a#3#0#0@@1| T@U) (|a#3#1#0@@1| T@U) (|a#3#2#0| T@U) ($h@@68 T@U) ) (!  (=> (and (and (and (and (= (type |a#3#0#0@@1|) (SeqType BoxType)) (= (type |a#3#1#0@@1|) DatatypeTypeType)) (= (type |a#3#2#0|) (SeqType BoxType))) (= (type $h@@68) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@68)) (= ($IsAlloc (|#PivotBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@1| |a#3#1#0@@1| |a#3#2#0|) Tclass.PivotBetree.QueryReceipt $h@@68)  (and (and ($IsAlloc |a#3#0#0@@1| Tclass.KeyType.Key $h@@68) ($IsAlloc |a#3#1#0@@1| Tclass.PivotBetree.BetreeNode $h@@68)) ($IsAlloc |a#3#2#0| (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@68))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1869|
 :pattern ( ($IsAlloc (|#PivotBetree.QueryReceipt.QueryReceipt| |a#3#0#0@@1| |a#3#1#0@@1| |a#3#2#0|) Tclass.PivotBetree.QueryReceipt $h@@68))
)))
(assert (forall ((arg0@@412 T@U) ) (! (= (type (PivotBetree.QueryReceipt.key arg0@@412)) (SeqType BoxType))
 :qid |funType:PivotBetree.QueryReceipt.key|
 :pattern ( (PivotBetree.QueryReceipt.key arg0@@412))
)))
(assert (forall ((d@@51 T@U) ($h@@69 T@U) ) (!  (=> (and (and (= (type d@@51) DatatypeTypeType) (= (type $h@@69) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@69) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@51) ($IsAlloc d@@51 Tclass.PivotBetree.QueryReceipt $h@@69)))) ($IsAlloc (PivotBetree.QueryReceipt.key d@@51) Tclass.KeyType.Key $h@@69))
 :qid |unknown.0:0|
 :skolemid |1870|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.key d@@51) Tclass.KeyType.Key $h@@69))
)))
(assert (forall ((arg0@@413 T@U) ) (! (= (type (PivotBetree.QueryReceipt.root arg0@@413)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.root|
 :pattern ( (PivotBetree.QueryReceipt.root arg0@@413))
)))
(assert (forall ((d@@52 T@U) ($h@@70 T@U) ) (!  (=> (and (and (= (type d@@52) DatatypeTypeType) (= (type $h@@70) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@70) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@52) ($IsAlloc d@@52 Tclass.PivotBetree.QueryReceipt $h@@70)))) ($IsAlloc (PivotBetree.QueryReceipt.root d@@52) Tclass.PivotBetree.BetreeNode $h@@70))
 :qid |unknown.0:0|
 :skolemid |1871|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.root d@@52) Tclass.PivotBetree.BetreeNode $h@@70))
)))
(assert (forall ((arg0@@414 T@U) ) (! (= (type (PivotBetree.QueryReceipt.lines arg0@@414)) (SeqType BoxType))
 :qid |funType:PivotBetree.QueryReceipt.lines|
 :pattern ( (PivotBetree.QueryReceipt.lines arg0@@414))
)))
(assert (forall ((d@@53 T@U) ($h@@71 T@U) ) (!  (=> (and (and (= (type d@@53) DatatypeTypeType) (= (type $h@@71) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@71) (and (PivotBetree.QueryReceipt.QueryReceipt_q d@@53) ($IsAlloc d@@53 Tclass.PivotBetree.QueryReceipt $h@@71)))) ($IsAlloc (PivotBetree.QueryReceipt.lines d@@53) (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@71))
 :qid |unknown.0:0|
 :skolemid |1872|
 :pattern ( ($IsAlloc (PivotBetree.QueryReceipt.lines d@@53) (TSeq Tclass.PivotBetree.QueryReceiptLine) $h@@71))
)))
(assert (forall ((|a#4#0#0@@1| T@U) (|a#4#1#0@@1| T@U) (|a#4#2#0| T@U) ) (!  (=> (and (and (= (type |a#4#0#0@@1|) (SeqType BoxType)) (= (type |a#4#1#0@@1|) DatatypeTypeType)) (= (type |a#4#2#0|) (SeqType BoxType))) (= (|#PivotBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@1|) (Lit |a#4#1#0@@1|) (Lit |a#4#2#0|)) (Lit (|#PivotBetree.QueryReceipt.QueryReceipt| |a#4#0#0@@1| |a#4#1#0@@1| |a#4#2#0|))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1873|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| (Lit |a#4#0#0@@1|) (Lit |a#4#1#0@@1|) (Lit |a#4#2#0|)))
)))
(assert (forall ((|a#5#0#0@@1| T@U) (|a#5#1#0@@1| T@U) (|a#5#2#0| T@U) ) (!  (=> (and (and (= (type |a#5#0#0@@1|) (SeqType BoxType)) (= (type |a#5#1#0@@1|) DatatypeTypeType)) (= (type |a#5#2#0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.key (|#PivotBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@1| |a#5#1#0@@1| |a#5#2#0|)) |a#5#0#0@@1|))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1874|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#5#0#0@@1| |a#5#1#0@@1| |a#5#2#0|))
)))
(assert (forall ((|a#6#0#0@@1| T@U) (|a#6#1#0@@1| T@U) (|a#6#2#0| T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@1|) (SeqType BoxType)) (= (type |a#6#1#0@@1|) DatatypeTypeType)) (= (type |a#6#2#0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.root (|#PivotBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@1| |a#6#1#0@@1| |a#6#2#0|)) |a#6#1#0@@1|))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1875|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#6#0#0@@1| |a#6#1#0@@1| |a#6#2#0|))
)))
(assert (forall ((|a#7#0#0@@1| T@U) (|a#7#1#0@@1| T@U) (|a#7#2#0| T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@1|) (SeqType BoxType)) (= (type |a#7#1#0@@1|) DatatypeTypeType)) (= (type |a#7#2#0|) (SeqType BoxType))) (< (DtRank |a#7#1#0@@1|) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@1| |a#7#1#0@@1| |a#7#2#0|))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1876|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#7#0#0@@1| |a#7#1#0@@1| |a#7#2#0|))
)))
(assert (forall ((|a#8#0#0@@1| T@U) (|a#8#1#0@@1| T@U) (|a#8#2#0| T@U) ) (!  (=> (and (and (= (type |a#8#0#0@@1|) (SeqType BoxType)) (= (type |a#8#1#0@@1|) DatatypeTypeType)) (= (type |a#8#2#0|) (SeqType BoxType))) (= (PivotBetree.QueryReceipt.lines (|#PivotBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@1| |a#8#1#0@@1| |a#8#2#0|)) |a#8#2#0|))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1877|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#8#0#0@@1| |a#8#1#0@@1| |a#8#2#0|))
)))
(assert (forall ((|a#9#0#0| T@U) (|a#9#1#0| T@U) (|a#9#2#0| T@U) (i@@27 Int) ) (!  (=> (and (and (and (= (type |a#9#0#0|) (SeqType BoxType)) (= (type |a#9#1#0|) DatatypeTypeType)) (= (type |a#9#2#0|) (SeqType BoxType))) (and (<= 0 i@@27) (< i@@27 (|Seq#Length| |a#9#2#0|)))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#9#2#0| i@@27))) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#9#0#0| |a#9#1#0| |a#9#2#0|))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1878|
 :pattern ( (|Seq#Index| |a#9#2#0| i@@27) (|#PivotBetree.QueryReceipt.QueryReceipt| |a#9#0#0| |a#9#1#0| |a#9#2#0|))
)))
(assert (forall ((|a#10#0#0| T@U) (|a#10#1#0| T@U) (|a#10#2#0| T@U) ) (!  (=> (and (and (= (type |a#10#0#0|) (SeqType BoxType)) (= (type |a#10#1#0|) DatatypeTypeType)) (= (type |a#10#2#0|) (SeqType BoxType))) (< (|Seq#Rank| |a#10#2#0|) (DtRank (|#PivotBetree.QueryReceipt.QueryReceipt| |a#10#0#0| |a#10#1#0| |a#10#2#0|))))
 :qid |PivotBetreebrokenidfy.321:5|
 :skolemid |1879|
 :pattern ( (|#PivotBetree.QueryReceipt.QueryReceipt| |a#10#0#0| |a#10#1#0| |a#10#2#0|))
)))
(assert (forall ((d@@54 T@U) ) (!  (=> (and (= (type d@@54) DatatypeTypeType) (|$IsA#PivotBetree.QueryReceipt| d@@54)) (PivotBetree.QueryReceipt.QueryReceipt_q d@@54))
 :qid |unknown.0:0|
 :skolemid |1880|
 :pattern ( (|$IsA#PivotBetree.QueryReceipt| d@@54))
)))
(assert (forall ((d@@55 T@U) ) (!  (=> (and (= (type d@@55) DatatypeTypeType) ($Is d@@55 Tclass.PivotBetree.QueryReceipt)) (PivotBetree.QueryReceipt.QueryReceipt_q d@@55))
 :qid |unknown.0:0|
 :skolemid |1881|
 :pattern ( (PivotBetree.QueryReceipt.QueryReceipt_q d@@55) ($Is d@@55 Tclass.PivotBetree.QueryReceipt))
)))
(assert (forall ((a@@129 T@U) (b@@78 T@U) ) (!  (=> (and (and (= (type a@@129) DatatypeTypeType) (= (type b@@78) DatatypeTypeType)) true) (= (|PivotBetree.QueryReceipt#Equal| a@@129 b@@78)  (and (and (|Seq#Equal| (PivotBetree.QueryReceipt.key a@@129) (PivotBetree.QueryReceipt.key b@@78)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root a@@129) (PivotBetree.QueryReceipt.root b@@78))) (|Seq#Equal| (PivotBetree.QueryReceipt.lines a@@129) (PivotBetree.QueryReceipt.lines b@@78)))))
 :qid |unknown.0:0|
 :skolemid |1882|
 :pattern ( (|PivotBetree.QueryReceipt#Equal| a@@129 b@@78))
)))
(assert (forall ((a@@130 T@U) (b@@79 T@U) ) (!  (=> (and (= (type a@@130) DatatypeTypeType) (= (type b@@79) DatatypeTypeType)) (= (|PivotBetree.QueryReceipt#Equal| a@@130 b@@79) (= a@@130 b@@79)))
 :qid |unknown.0:0|
 :skolemid |1883|
 :pattern ( (|PivotBetree.QueryReceipt#Equal| a@@130 b@@79))
)))
(assert  (=> (<= 46 $FunctionContextHeight) (forall ((this@@97 T@U) ) (!  (=> (and (= (type this@@97) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| this@@97) (and (not (= 46 $FunctionContextHeight)) ($Is this@@97 Tclass.PivotBetree.QueryReceipt)))) true)
 :qid |PivotBetreebrokenidfy.325:15|
 :skolemid |1884|
 :pattern ( (PivotBetree.QueryReceipt.Structure this@@97))
))))
(assert (forall ((this@@98 T@U) ) (!  (=> (and (= (type this@@98) DatatypeTypeType) ($Is this@@98 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Structure#requires| this@@98) true))
 :qid |PivotBetreebrokenidfy.325:15|
 :skolemid |1885|
 :pattern ( (|PivotBetree.QueryReceipt.Structure#requires| this@@98))
)))
(assert  (and (forall ((arg0@@415 T@U) ) (! (= (type (|#ValueMessage.Message.Define| arg0@@415)) DatatypeTypeType)
 :qid |funType:#ValueMessage.Message.Define|
 :pattern ( (|#ValueMessage.Message.Define| arg0@@415))
)) (= (type ValueMessage.__default.DefaultValue) (SeqType BoxType))))
(assert  (=> (<= 46 $FunctionContextHeight) (forall ((this@@99 T@U) ) (!  (=> (and (= (type this@@99) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| this@@99) (and (not (= 46 $FunctionContextHeight)) ($Is this@@99 Tclass.PivotBetree.QueryReceipt)))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@99) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) (LitInt 0))))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.root this@@99))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@99) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) (LitInt 0))))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@99))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) (LitInt 0)))) (PivotBetree.QueryReceipt.root this@@99)) (and (forall ((|i#0@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@2|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@99) (=> (INTERNAL_lt_boogie |i#0@@2| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@99) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@2|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@99)))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1887|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@2|)))
)) (=> (forall ((|i#0@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@3|) (INTERNAL_lt_boogie |i#0@@3| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99)))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@3|)))) (INTERNAL_lt_boogie |i#0@@3| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99)) 1))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1888|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@3|)))
)) (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@99))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@99) (|Sequences.__default.Last#canCall| Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@99))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@99))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PivotBetree.QueryReceipt.Structure this@@99)  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) (LitInt 0)))) (PivotBetree.QueryReceipt.root this@@99))) (forall ((|i#0@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@4|) (INTERNAL_lt_boogie |i#0@@4| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99)))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@4|)))) (INTERNAL_lt_boogie |i#0@@4| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@99)) 1))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1886|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@99) |i#0@@4|)))
))) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (PivotBetree.QueryReceipt.lines this@@99)))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PivotBetreebrokenidfy.325:15|
 :skolemid |1889|
 :pattern ( (PivotBetree.QueryReceipt.Structure this@@99))
))))
(assert  (=> (<= 46 $FunctionContextHeight) (forall ((this@@100 T@U) ) (!  (=> (and (= (type this@@100) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Structure#canCall| (Lit this@@100)) (and (not (= 46 $FunctionContextHeight)) ($Is this@@100 Tclass.PivotBetree.QueryReceipt)))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)) (=> (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) (LitInt 0))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.root (Lit this@@100))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) (LitInt 0))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) (LitInt 0)))) (PivotBetree.QueryReceipt.root (Lit this@@100))) (and (forall ((|i#1@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@2|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)) (=> (INTERNAL_lt_boogie |i#1@@2| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) |i#1@@2|)))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100))))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1891|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@100) |i#1@@2|)))
)) (=> (forall ((|i#1@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@3|) (INTERNAL_lt_boogie |i#1@@3| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100)))))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) |i#1@@3|)))) (INTERNAL_lt_boogie |i#1@@3| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100)))) 1))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1892|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@100) |i#1@@3|)))
)) (and (|$IsA#ValueMessage.Message| (Lit (PivotBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))))))) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@100)) (|Sequences.__default.Last#canCall| Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100)))))))) |ValueMessage.__default.DefaultValue#canCall|)))))))) (= (PivotBetree.QueryReceipt.Structure (Lit this@@100))  (and (and (and (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) (LitInt 0)))) (PivotBetree.QueryReceipt.root (Lit this@@100)))) (forall ((|i#1@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@4|) (INTERNAL_lt_boogie |i#1@@4| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100)))))) (= (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))) |i#1@@4|)))) (INTERNAL_lt_boogie |i#1@@4| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100)))) 1))))
 :qid |PivotBetreebrokenidfy.329:18|
 :skolemid |1890|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@100) |i#1@@4|)))
))) (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.PivotBetree.QueryReceiptLine (Lit (PivotBetree.QueryReceipt.lines (Lit this@@100))))))) (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue)))))))
 :qid |PivotBetreebrokenidfy.325:15|
 :weight 3
 :skolemid |1893|
 :pattern ( (PivotBetree.QueryReceipt.Structure (Lit this@@100)))
))))
(assert  (=> (<= 45 $FunctionContextHeight) (forall ((this@@101 T@U) ) (!  (=> (and (= (type this@@101) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@101) (and (not (= 45 $FunctionContextHeight)) ($Is this@@101 Tclass.PivotBetree.QueryReceipt)))) true)
 :qid |PivotBetreebrokenidfy.333:15|
 :skolemid |1900|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF this@@101))
))))
(assert (forall ((this@@102 T@U) ) (!  (=> (and (= (type this@@102) DatatypeTypeType) ($Is this@@102 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.AllLinesWF#requires| this@@102) true))
 :qid |PivotBetreebrokenidfy.333:15|
 :skolemid |1901|
 :pattern ( (|PivotBetree.QueryReceipt.AllLinesWF#requires| this@@102))
)))
(assert  (=> (<= 45 $FunctionContextHeight) (forall ((this@@103 T@U) ) (!  (=> (and (= (type this@@103) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@103) (and (not (= 45 $FunctionContextHeight)) ($Is this@@103 Tclass.PivotBetree.QueryReceipt)))) (and (and (forall ((|i#0@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@5|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@103) (=> (INTERNAL_lt_boogie |i#0@@5| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@103))) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@103) (|PivotBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@5|)))))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1904|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@5|)))
)) (=> (forall ((|i#0@@6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@6|) (INTERNAL_lt_boogie |i#0@@6| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@103)))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@6|))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1906|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@6|)))
)) (forall ((|i#1@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@5|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@103) (=> (INTERNAL_lt_boogie |i#1@@5| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@103)) 1)) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@103) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#1@@5|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@103)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#1@@5|))) (PivotBetree.QueryReceipt.key this@@103))))))
 :qid |PivotBetreebrokenidfy.336:18|
 :skolemid |1905|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#1@@5|)))
)))) (= (PivotBetree.QueryReceipt.AllLinesWF this@@103)  (and (forall ((|i#0@@7| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@7|) (INTERNAL_lt_boogie |i#0@@7| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@103)))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@7|))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1902|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#0@@7|)))
)) (forall ((|i#1@@6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@6|) (INTERNAL_lt_boogie |i#1@@6| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@103)) 1))) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#1@@6|))) (PivotBetree.QueryReceipt.key this@@103)))
 :qid |PivotBetreebrokenidfy.336:18|
 :skolemid |1903|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@103) |i#1@@6|)))
))))))
 :qid |PivotBetreebrokenidfy.333:15|
 :skolemid |1907|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF this@@103))
))))
(assert  (=> (<= 45 $FunctionContextHeight) (forall ((this@@104 T@U) ) (!  (=> (and (= (type this@@104) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@104)) (and (not (= 45 $FunctionContextHeight)) ($Is this@@104 Tclass.PivotBetree.QueryReceipt)))) (and (and (forall ((|i#2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#2|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@104)) (=> (INTERNAL_lt_boogie |i#2| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))))) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@104)) (|PivotBetree.QueryReceiptLine.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#2|)))))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1910|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@104) |i#2|)))
)) (=> (forall ((|i#2@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@0|) (INTERNAL_lt_boogie |i#2@@0| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104)))))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#2@@0|))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1912|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@104) |i#2@@0|)))
)) (forall ((|i#3| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@104)) (=> (INTERNAL_lt_boogie |i#3| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104)))) 1)) (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@104)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#3|)))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@104))) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#3|))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@104))))))))
 :qid |PivotBetreebrokenidfy.336:18|
 :skolemid |1911|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@104) |i#3|)))
)))) (= (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@104))  (and (forall ((|i#2@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@1|) (INTERNAL_lt_boogie |i#2@@1| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104)))))) (PivotBetree.QueryReceiptLine.WF ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#2@@1|))))
 :qid |PivotBetreebrokenidfy.335:18|
 :skolemid |1908|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@104) |i#2@@1|)))
)) (forall ((|i#3@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@0|) (INTERNAL_lt_boogie |i#3@@0| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104)))) 1))) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@104))) |i#3@@0|))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@104)))))
 :qid |PivotBetreebrokenidfy.336:18|
 :skolemid |1909|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@104) |i#3@@0|)))
))))))
 :qid |PivotBetreebrokenidfy.333:15|
 :weight 3
 :skolemid |1913|
 :pattern ( (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@104)))
))))
(assert (forall ((arg0@@416 T@U) (arg1@@165 Int) ) (! (= (type (PivotBetree.QueryReceipt.ChildAt arg0@@416 arg1@@165)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.ChildAt|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt arg0@@416 arg1@@165))
)))
(assert  (=> (<= 47 $FunctionContextHeight) (forall ((this@@105 T@U) (|i#0@@8| Int) ) (!  (=> (and (= (type this@@105) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@105 |i#0@@8|) (and (not (= 47 $FunctionContextHeight)) (and (and ($Is this@@105 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@8|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@105) (PivotBetree.QueryReceipt.Structure this@@105)) (INTERNAL_lt_boogie |i#0@@8| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@105)) 1))))))) ($Is (PivotBetree.QueryReceipt.ChildAt this@@105 |i#0@@8|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreebrokenidfy.339:14|
 :skolemid |1922|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt this@@105 |i#0@@8|))
))))
(assert (forall ((this@@106 T@U) (|i#0@@9| Int) ) (!  (=> (= (type this@@106) DatatypeTypeType) (=> (and ($Is this@@106 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@9|)) (= (|PivotBetree.QueryReceipt.ChildAt#requires| this@@106 |i#0@@9|)  (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@106) (PivotBetree.QueryReceipt.Structure this@@106)) (INTERNAL_lt_boogie |i#0@@9| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@106)) 1))))))
 :qid |PivotBetreebrokenidfy.339:14|
 :skolemid |1923|
 :pattern ( (|PivotBetree.QueryReceipt.ChildAt#requires| this@@106 |i#0@@9|))
)))
(assert  (=> (<= 47 $FunctionContextHeight) (forall ((this@@107 T@U) (|i#0@@10| Int) ) (!  (=> (and (= (type this@@107) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@107 |i#0@@10|) (and (not (= 47 $FunctionContextHeight)) (and (and ($Is this@@107 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@10|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@107) (PivotBetree.QueryReceipt.Structure this@@107)) (INTERNAL_lt_boogie |i#0@@10| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@107)) 1))))))) (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@107) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@107) |i#0@@10|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@107)) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@107) |i#0@@10|))) (PivotBetree.QueryReceipt.key this@@107))) (= (PivotBetree.QueryReceipt.ChildAt this@@107 |i#0@@10|) (PivotBetree.BetreeNode.Child (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@107) |i#0@@10|))) (PivotBetree.QueryReceipt.key this@@107)))))
 :qid |PivotBetreebrokenidfy.339:14|
 :skolemid |1924|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt this@@107 |i#0@@10|))
))))
(assert  (=> (<= 47 $FunctionContextHeight) (forall ((this@@108 T@U) (|i#0@@11| Int) ) (!  (=> (and (= (type this@@108) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildAt#canCall| (Lit this@@108) (LitInt |i#0@@11|)) (and (not (= 47 $FunctionContextHeight)) (and (and ($Is this@@108 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@11|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@108))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@108)))))) (INTERNAL_lt_boogie |i#0@@11| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@108)))) 1))))))) (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@108)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@108))) (LitInt |i#0@@11|))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@108))) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@108))) (LitInt |i#0@@11|)))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@108))))) (= (PivotBetree.QueryReceipt.ChildAt (Lit this@@108) (LitInt |i#0@@11|)) (PivotBetree.BetreeNode.Child (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@108))) (LitInt |i#0@@11|)))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@108)))))))
 :qid |PivotBetreebrokenidfy.339:14|
 :weight 3
 :skolemid |1925|
 :pattern ( (PivotBetree.QueryReceipt.ChildAt (Lit this@@108) (LitInt |i#0@@11|)))
))))
(assert  (=> (<= 48 $FunctionContextHeight) (forall ((this@@109 T@U) (|i#0@@12| Int) ) (!  (=> (and (= (type this@@109) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@109 |i#0@@12|) (and (not (= 48 $FunctionContextHeight)) (and (and ($Is this@@109 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@12|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@109) (PivotBetree.QueryReceipt.Structure this@@109)) (INTERNAL_lt_boogie |i#0@@12| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@109)) 1))))))) true)
 :qid |PivotBetreebrokenidfy.347:15|
 :skolemid |1941|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@109 |i#0@@12|))
))))
(assert (forall ((this@@110 T@U) (|i#0@@13| Int) ) (!  (=> (= (type this@@110) DatatypeTypeType) (=> (and ($Is this@@110 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@13|)) (= (|PivotBetree.QueryReceipt.ChildLinkedAt#requires| this@@110 |i#0@@13|)  (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@110) (PivotBetree.QueryReceipt.Structure this@@110)) (INTERNAL_lt_boogie |i#0@@13| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@110)) 1))))))
 :qid |PivotBetreebrokenidfy.347:15|
 :skolemid |1942|
 :pattern ( (|PivotBetree.QueryReceipt.ChildLinkedAt#requires| this@@110 |i#0@@13|))
)))
(assert  (=> (<= 48 $FunctionContextHeight) (forall ((this@@111 T@U) (|i#0@@14| Int) ) (!  (=> (and (= (type this@@111) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@111 |i#0@@14|) (and (not (= 48 $FunctionContextHeight)) (and (and ($Is this@@111 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@14|)) (and (and (PivotBetree.QueryReceipt.AllLinesWF this@@111) (PivotBetree.QueryReceipt.Structure this@@111)) (INTERNAL_lt_boogie |i#0@@14| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@111)) 1))))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@111) (INTERNAL_add_boogie |i#0@@14| 1))))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.ChildAt this@@111 |i#0@@14|))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@111) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@111) (INTERNAL_add_boogie |i#0@@14| 1))))) (|PivotBetree.QueryReceipt.ChildAt#canCall| this@@111 |i#0@@14|))) (= (PivotBetree.QueryReceipt.ChildLinkedAt this@@111 |i#0@@14|) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@111) (INTERNAL_add_boogie |i#0@@14| 1)))) (PivotBetree.QueryReceipt.ChildAt this@@111 |i#0@@14|)))))
 :qid |PivotBetreebrokenidfy.347:15|
 :skolemid |1943|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@111 |i#0@@14|))
))))
(assert  (=> (<= 48 $FunctionContextHeight) (forall ((this@@112 T@U) (|i#0@@15| Int) ) (!  (=> (and (= (type this@@112) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@112) (LitInt |i#0@@15|)) (and (not (= 48 $FunctionContextHeight)) (and (and ($Is this@@112 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@15|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@112))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@112)))))) (INTERNAL_lt_boogie |i#0@@15| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@112)))) 1))))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@112))) (LitInt (INTERNAL_add_boogie |i#0@@15| 1)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.ChildAt (Lit this@@112) (LitInt |i#0@@15|))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@112)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@112))) (LitInt (INTERNAL_add_boogie |i#0@@15| 1)))))) (|PivotBetree.QueryReceipt.ChildAt#canCall| (Lit this@@112) (LitInt |i#0@@15|)))) (= (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@112) (LitInt |i#0@@15|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@112))) (LitInt (INTERNAL_add_boogie |i#0@@15| 1))))) (PivotBetree.QueryReceipt.ChildAt (Lit this@@112) (LitInt |i#0@@15|))))))
 :qid |PivotBetreebrokenidfy.347:15|
 :weight 3
 :skolemid |1944|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@112) (LitInt |i#0@@15|)))
))))
(assert (forall ((arg0@@417 T@U) (arg1@@166 Int) ) (! (= (type (PivotBetree.QueryReceipt.ResultAt arg0@@417 arg1@@166)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.ResultAt|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt arg0@@417 arg1@@166))
)))
(assert  (=> (<= 49 $FunctionContextHeight) (forall ((this@@113 T@U) (|i#0@@16| Int) ) (!  (=> (and (= (type this@@113) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@113 |i#0@@16|) (and (not (= 49 $FunctionContextHeight)) (and (and ($Is this@@113 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@16|)) (INTERNAL_lt_boogie |i#0@@16| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@113))))))) ($Is (PivotBetree.QueryReceipt.ResultAt this@@113 |i#0@@16|) Tclass.ValueMessage.Message))
 :qid |PivotBetreebrokenidfy.355:14|
 :skolemid |1954|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt this@@113 |i#0@@16|))
))))
(assert (forall ((this@@114 T@U) (|i#0@@17| Int) ) (!  (=> (= (type this@@114) DatatypeTypeType) (=> (and ($Is this@@114 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@17|)) (= (|PivotBetree.QueryReceipt.ResultAt#requires| this@@114 |i#0@@17|) (INTERNAL_lt_boogie |i#0@@17| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@114))))))
 :qid |PivotBetreebrokenidfy.355:14|
 :skolemid |1955|
 :pattern ( (|PivotBetree.QueryReceipt.ResultAt#requires| this@@114 |i#0@@17|))
)))
(assert  (=> (<= 49 $FunctionContextHeight) (forall ((this@@115 T@U) (|i#0@@18| Int) ) (!  (=> (and (= (type this@@115) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@115 |i#0@@18|) (and (not (= 49 $FunctionContextHeight)) (and (and ($Is this@@115 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@18|)) (INTERNAL_lt_boogie |i#0@@18| (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@115))))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@115) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@115) |i#0@@18|)))) (= (PivotBetree.QueryReceipt.ResultAt this@@115 |i#0@@18|) (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@115) |i#0@@18|))))))
 :qid |PivotBetreebrokenidfy.355:14|
 :skolemid |1956|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt this@@115 |i#0@@18|))
))))
(assert  (=> (<= 49 $FunctionContextHeight) (forall ((this@@116 T@U) (|i#0@@19| Int) ) (!  (=> (and (= (type this@@116) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@116) (LitInt |i#0@@19|)) (and (not (= 49 $FunctionContextHeight)) (and (and ($Is this@@116 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@19|)) (INTERNAL_lt_boogie |i#0@@19| (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@116))))))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@116)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@116))) (LitInt |i#0@@19|))))) (= (PivotBetree.QueryReceipt.ResultAt (Lit this@@116) (LitInt |i#0@@19|)) (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@116))) (LitInt |i#0@@19|)))))))
 :qid |PivotBetreebrokenidfy.355:14|
 :weight 3
 :skolemid |1957|
 :pattern ( (PivotBetree.QueryReceipt.ResultAt (Lit this@@116) (LitInt |i#0@@19|)))
))))
(assert  (=> (<= 50 $FunctionContextHeight) (forall ((this@@117 T@U) (|i#0@@20| Int) ) (!  (=> (and (= (type this@@117) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@117 |i#0@@20|) (and (not (= 50 $FunctionContextHeight)) (and (and ($Is this@@117 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@20|)) (and (and (PivotBetree.QueryReceipt.Structure this@@117) (PivotBetree.QueryReceipt.AllLinesWF this@@117)) (INTERNAL_lt_boogie |i#0@@20| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@117)) 1))))))) true)
 :qid |PivotBetreebrokenidfy.361:15|
 :skolemid |1958|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@117 |i#0@@20|))
))))
(assert (forall ((this@@118 T@U) (|i#0@@21| Int) ) (!  (=> (= (type this@@118) DatatypeTypeType) (=> (and ($Is this@@118 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@21|)) (= (|PivotBetree.QueryReceipt.ResultLinkedAt#requires| this@@118 |i#0@@21|)  (and (and (PivotBetree.QueryReceipt.Structure this@@118) (PivotBetree.QueryReceipt.AllLinesWF this@@118)) (INTERNAL_lt_boogie |i#0@@21| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@118)) 1))))))
 :qid |PivotBetreebrokenidfy.361:15|
 :skolemid |1959|
 :pattern ( (|PivotBetree.QueryReceipt.ResultLinkedAt#requires| this@@118 |i#0@@21|))
)))
(assert  (and (forall ((arg0@@418 T@U) (arg1@@167 T@U) ) (! (= (type (ValueMessage.__default.Merge arg0@@418 arg1@@167)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.Merge|
 :pattern ( (ValueMessage.__default.Merge arg0@@418 arg1@@167))
)) (forall ((arg0@@419 T@U) (arg1@@168 T@U) ) (! (= (type (Buffers.BufferStack.Query arg0@@419 arg1@@168)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.Query|
 :pattern ( (Buffers.BufferStack.Query arg0@@419 arg1@@168))
))))
(assert  (=> (<= 50 $FunctionContextHeight) (forall ((this@@119 T@U) (|i#0@@22| Int) ) (!  (=> (and (= (type this@@119) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@119 |i#0@@22|) (and (not (= 50 $FunctionContextHeight)) (and (and ($Is this@@119 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@22|)) (and (and (PivotBetree.QueryReceipt.Structure this@@119) (PivotBetree.QueryReceipt.AllLinesWF this@@119)) (INTERNAL_lt_boogie |i#0@@22| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@119)) 1))))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (PivotBetree.QueryReceipt.key this@@119)) (PivotBetree.QueryReceipt.ResultAt this@@119 (INTERNAL_add_boogie |i#0@@22| 1))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@119) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (and (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@119) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (PivotBetree.QueryReceipt.QueryReceipt_q this@@119)) (|Buffers.BufferStack.Query#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (PivotBetree.QueryReceipt.key this@@119))) (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@119 (INTERNAL_add_boogie |i#0@@22| 1))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (PivotBetree.QueryReceipt.key this@@119)) (PivotBetree.QueryReceipt.ResultAt this@@119 (INTERNAL_add_boogie |i#0@@22| 1))))))) (= (PivotBetree.QueryReceipt.ResultLinkedAt this@@119 |i#0@@22|)  (and true (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.QueryReceipt.lines this@@119) |i#0@@22|)))) (PivotBetree.QueryReceipt.key this@@119)) (PivotBetree.QueryReceipt.ResultAt this@@119 (INTERNAL_add_boogie |i#0@@22| 1))))))))
 :qid |PivotBetreebrokenidfy.361:15|
 :skolemid |1960|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@119 |i#0@@22|))
))))
(assert  (=> (<= 50 $FunctionContextHeight) (forall ((this@@120 T@U) (|i#0@@23| Int) ) (!  (=> (and (= (type this@@120) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@120) (LitInt |i#0@@23|)) (and (not (= 50 $FunctionContextHeight)) (and (and ($Is this@@120 Tclass.PivotBetree.QueryReceipt) (INTERNAL_le_boogie 0 |i#0@@23|)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@120))))) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@120)))))) (INTERNAL_lt_boogie |i#0@@23| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120)))) 1))))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#ValueMessage.Message| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@120)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@120) (LitInt (INTERNAL_add_boogie |i#0@@23| 1))))))) (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@120)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (and (and (and (and (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@120)) (PivotBetree.QueryReceiptLine.QueryReceiptLine_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@120))) (|Buffers.BufferStack.Query#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@120))))) (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@120) (LitInt (INTERNAL_add_boogie |i#0@@23| 1)))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@120)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@120) (LitInt (INTERNAL_add_boogie |i#0@@23| 1))))))))) (= (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@120) (LitInt |i#0@@23|))  (and true (|ValueMessage.Message#Equal| (PivotBetree.QueryReceiptLine.result ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|)))) (ValueMessage.__default.Merge (Buffers.BufferStack.Query (PivotBetree.BetreeNode.buffers (PivotBetree.QueryReceiptLine.node ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@120))) (LitInt |i#0@@23|))))) (Lit (PivotBetree.QueryReceipt.key (Lit this@@120)))) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@120) (LitInt (INTERNAL_add_boogie |i#0@@23| 1))))))))))
 :qid |PivotBetreebrokenidfy.361:15|
 :weight 3
 :skolemid |1961|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@120) (LitInt |i#0@@23|)))
))))
(assert  (=> (<= 52 $FunctionContextHeight) (forall ((this@@121 T@U) ) (!  (=> (and (= (type this@@121) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| this@@121) (and (not (= 52 $FunctionContextHeight)) ($Is this@@121 Tclass.PivotBetree.QueryReceipt)))) true)
 :qid |PivotBetreebrokenidfy.369:15|
 :skolemid |1967|
 :pattern ( (PivotBetree.QueryReceipt.Valid this@@121))
))))
(assert (forall ((this@@122 T@U) ) (!  (=> (and (= (type this@@122) DatatypeTypeType) ($Is this@@122 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Valid#requires| this@@122) true))
 :qid |PivotBetreebrokenidfy.369:15|
 :skolemid |1968|
 :pattern ( (|PivotBetree.QueryReceipt.Valid#requires| this@@122))
)))
(assert  (=> (<= 52 $FunctionContextHeight) (forall ((this@@123 T@U) ) (!  (=> (and (= (type this@@123) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| this@@123) (and (not (= 52 $FunctionContextHeight)) ($Is this@@123 Tclass.PivotBetree.QueryReceipt)))) (and (and (|PivotBetree.QueryReceipt.Structure#canCall| this@@123) (=> (PivotBetree.QueryReceipt.Structure this@@123) (and (|PivotBetree.QueryReceipt.AllLinesWF#canCall| this@@123) (=> (PivotBetree.QueryReceipt.AllLinesWF this@@123) (and (forall ((|i#0@@24| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@24|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@123) (=> (INTERNAL_lt_boogie |i#0@@24| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@123)) 1)) (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| this@@123 |i#0@@24|))))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1971|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@123 |i#0@@24|))
)) (=> (forall ((|i#0@@25| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@25|) (INTERNAL_lt_boogie |i#0@@25| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@123)) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt this@@123 |i#0@@25|))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1973|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@123 |i#0@@25|))
)) (forall ((|i#1@@7| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@7|) (and (PivotBetree.QueryReceipt.QueryReceipt_q this@@123) (=> (INTERNAL_lt_boogie |i#1@@7| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@123)) 1)) (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| this@@123 |i#1@@7|))))
 :qid |PivotBetreebrokenidfy.374:18|
 :skolemid |1972|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@123 |i#1@@7|))
)))))))) (= (PivotBetree.QueryReceipt.Valid this@@123)  (and (and (and (PivotBetree.QueryReceipt.Structure this@@123) (PivotBetree.QueryReceipt.AllLinesWF this@@123)) (forall ((|i#0@@26| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@26|) (INTERNAL_lt_boogie |i#0@@26| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@123)) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt this@@123 |i#0@@26|))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1969|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@123 |i#0@@26|))
))) (forall ((|i#1@@8| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@8|) (INTERNAL_lt_boogie |i#1@@8| (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.QueryReceipt.lines this@@123)) 1))) (PivotBetree.QueryReceipt.ResultLinkedAt this@@123 |i#1@@8|))
 :qid |PivotBetreebrokenidfy.374:18|
 :skolemid |1970|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@123 |i#1@@8|))
))))))
 :qid |PivotBetreebrokenidfy.369:15|
 :skolemid |1974|
 :pattern ( (PivotBetree.QueryReceipt.Valid this@@123))
))))
(assert  (=> (<= 52 $FunctionContextHeight) (forall ((this@@124 T@U) ) (!  (=> (and (= (type this@@124) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Valid#canCall| (Lit this@@124)) (and (not (= 52 $FunctionContextHeight)) ($Is this@@124 Tclass.PivotBetree.QueryReceipt)))) (and (and (|PivotBetree.QueryReceipt.Structure#canCall| (Lit this@@124)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@124))))) (and (|PivotBetree.QueryReceipt.AllLinesWF#canCall| (Lit this@@124)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@124))))) (and (forall ((|i#2@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#2@@2|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@124)) (=> (INTERNAL_lt_boogie |i#2@@2| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@124)))) 1)) (|PivotBetree.QueryReceipt.ChildLinkedAt#canCall| (Lit this@@124) |i#2@@2|))))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1977|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@124 |i#2@@2|))
)) (=> (forall ((|i#2@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@3|) (INTERNAL_lt_boogie |i#2@@3| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@124)))) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@124) |i#2@@3|))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1979|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@124 |i#2@@3|))
)) (forall ((|i#3@@1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@1|) (and (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@124)) (=> (INTERNAL_lt_boogie |i#3@@1| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@124)))) 1)) (|PivotBetree.QueryReceipt.ResultLinkedAt#canCall| (Lit this@@124) |i#3@@1|))))
 :qid |PivotBetreebrokenidfy.374:18|
 :skolemid |1978|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@124 |i#3@@1|))
)))))))) (= (PivotBetree.QueryReceipt.Valid (Lit this@@124))  (and (and (and (PivotBetree.QueryReceipt.Structure (Lit this@@124)) (PivotBetree.QueryReceipt.AllLinesWF (Lit this@@124))) (forall ((|i#2@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@4|) (INTERNAL_lt_boogie |i#2@@4| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@124)))) 1))) (PivotBetree.QueryReceipt.ChildLinkedAt (Lit this@@124) |i#2@@4|))
 :qid |PivotBetreebrokenidfy.373:18|
 :skolemid |1975|
 :pattern ( (PivotBetree.QueryReceipt.ChildLinkedAt this@@124 |i#2@@4|))
))) (forall ((|i#3@@2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@2|) (INTERNAL_lt_boogie |i#3@@2| (INTERNAL_sub_boogie (|Seq#Length| (Lit (PivotBetree.QueryReceipt.lines (Lit this@@124)))) 1))) (PivotBetree.QueryReceipt.ResultLinkedAt (Lit this@@124) |i#3@@2|))
 :qid |PivotBetreebrokenidfy.374:18|
 :skolemid |1976|
 :pattern ( (PivotBetree.QueryReceipt.ResultLinkedAt this@@124 |i#3@@2|))
))))))
 :qid |PivotBetreebrokenidfy.369:15|
 :weight 3
 :skolemid |1980|
 :pattern ( (PivotBetree.QueryReceipt.Valid (Lit this@@124)))
))))
(assert (forall ((arg0@@420 T@U) ) (! (= (type (PivotBetree.QueryReceipt.Result arg0@@420)) DatatypeTypeType)
 :qid |funType:PivotBetree.QueryReceipt.Result|
 :pattern ( (PivotBetree.QueryReceipt.Result arg0@@420))
)))
(assert  (=> (<= 51 $FunctionContextHeight) (forall ((this@@125 T@U) ) (!  (=> (and (= (type this@@125) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| this@@125) (and (not (= 51 $FunctionContextHeight)) (and ($Is this@@125 Tclass.PivotBetree.QueryReceipt) (PivotBetree.QueryReceipt.Structure this@@125))))) ($Is (PivotBetree.QueryReceipt.Result this@@125) Tclass.ValueMessage.Message))
 :qid |PivotBetreebrokenidfy.377:14|
 :skolemid |2003|
 :pattern ( (PivotBetree.QueryReceipt.Result this@@125))
))))
(assert (forall ((this@@126 T@U) ) (!  (=> (and (= (type this@@126) DatatypeTypeType) ($Is this@@126 Tclass.PivotBetree.QueryReceipt)) (= (|PivotBetree.QueryReceipt.Result#requires| this@@126) (PivotBetree.QueryReceipt.Structure this@@126)))
 :qid |PivotBetreebrokenidfy.377:14|
 :skolemid |2004|
 :pattern ( (|PivotBetree.QueryReceipt.Result#requires| this@@126))
)))
(assert  (=> (<= 51 $FunctionContextHeight) (forall ((this@@127 T@U) ) (!  (=> (and (= (type this@@127) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| this@@127) (and (not (= 51 $FunctionContextHeight)) (and ($Is this@@127 Tclass.PivotBetree.QueryReceipt) (PivotBetree.QueryReceipt.Structure this@@127))))) (and (|PivotBetree.QueryReceipt.ResultAt#canCall| this@@127 (LitInt 0)) (= (PivotBetree.QueryReceipt.Result this@@127) (PivotBetree.QueryReceipt.ResultAt this@@127 (LitInt 0)))))
 :qid |PivotBetreebrokenidfy.377:14|
 :skolemid |2005|
 :pattern ( (PivotBetree.QueryReceipt.Result this@@127))
))))
(assert  (=> (<= 51 $FunctionContextHeight) (forall ((this@@128 T@U) ) (!  (=> (and (= (type this@@128) DatatypeTypeType) (or (|PivotBetree.QueryReceipt.Result#canCall| (Lit this@@128)) (and (not (= 51 $FunctionContextHeight)) (and ($Is this@@128 Tclass.PivotBetree.QueryReceipt) (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Structure (Lit this@@128))))))))) (and (|PivotBetree.QueryReceipt.ResultAt#canCall| (Lit this@@128) (LitInt 0)) (= (PivotBetree.QueryReceipt.Result (Lit this@@128)) (Lit (PivotBetree.QueryReceipt.ResultAt (Lit this@@128) (LitInt 0))))))
 :qid |PivotBetreebrokenidfy.377:14|
 :weight 3
 :skolemid |2006|
 :pattern ( (PivotBetree.QueryReceipt.Result (Lit this@@128)))
))))
(assert  (=> (<= 53 $FunctionContextHeight) (forall ((this@@129 T@U) (|root#0| T@U) (|key#0@@8| T@U) ) (!  (=> (and (and (and (= (type this@@129) DatatypeTypeType) (= (type |root#0|) DatatypeTypeType)) (= (type |key#0@@8|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| this@@129 |root#0| |key#0@@8|) (and (not (= 53 $FunctionContextHeight)) (and (and ($Is this@@129 Tclass.PivotBetree.QueryReceipt) ($Is |root#0| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@8| Tclass.KeyType.Key))))) true)
 :qid |PivotBetreebrokenidfy.383:15|
 :skolemid |2009|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor this@@129 |root#0| |key#0@@8|))
))))
(assert (forall ((this@@130 T@U) (|root#0@@0| T@U) (|key#0@@9| T@U) ) (!  (=> (and (and (and (= (type this@@130) DatatypeTypeType) (= (type |root#0@@0|) DatatypeTypeType)) (= (type |key#0@@9|) (SeqType BoxType))) (and (and ($Is this@@130 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@0| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@9| Tclass.KeyType.Key))) (= (|PivotBetree.QueryReceipt.ValidFor#requires| this@@130 |root#0@@0| |key#0@@9|) true))
 :qid |PivotBetreebrokenidfy.383:15|
 :skolemid |2010|
 :pattern ( (|PivotBetree.QueryReceipt.ValidFor#requires| this@@130 |root#0@@0| |key#0@@9|))
)))
(assert  (=> (<= 53 $FunctionContextHeight) (forall ((this@@131 T@U) (|root#0@@1| T@U) (|key#0@@10| T@U) ) (!  (=> (and (and (and (= (type this@@131) DatatypeTypeType) (= (type |root#0@@1|) DatatypeTypeType)) (= (type |key#0@@10|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| this@@131 |root#0@@1| |key#0@@10|) (and (not (= 53 $FunctionContextHeight)) (and (and ($Is this@@131 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@1| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@10| Tclass.KeyType.Key))))) (and (and (|PivotBetree.QueryReceipt.Valid#canCall| this@@131) (=> (PivotBetree.QueryReceipt.Valid this@@131) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.QueryReceipt.root this@@131)) (|$IsA#PivotBetree.BetreeNode| |root#0@@1|)) (PivotBetree.QueryReceipt.QueryReceipt_q this@@131)) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root this@@131) |root#0@@1|) (PivotBetree.QueryReceipt.QueryReceipt_q this@@131))))) (= (PivotBetree.QueryReceipt.ValidFor this@@131 |root#0@@1| |key#0@@10|)  (and (and (PivotBetree.QueryReceipt.Valid this@@131) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root this@@131) |root#0@@1|)) (|Seq#Equal| (PivotBetree.QueryReceipt.key this@@131) |key#0@@10|)))))
 :qid |PivotBetreebrokenidfy.383:15|
 :skolemid |2011|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor this@@131 |root#0@@1| |key#0@@10|))
))))
(assert  (=> (<= 53 $FunctionContextHeight) (forall ((this@@132 T@U) (|root#0@@2| T@U) (|key#0@@11| T@U) ) (!  (=> (and (and (and (= (type this@@132) DatatypeTypeType) (= (type |root#0@@2|) DatatypeTypeType)) (= (type |key#0@@11|) (SeqType BoxType))) (or (|PivotBetree.QueryReceipt.ValidFor#canCall| (Lit this@@132) (Lit |root#0@@2|) (Lit |key#0@@11|)) (and (not (= 53 $FunctionContextHeight)) (and (and ($Is this@@132 Tclass.PivotBetree.QueryReceipt) ($Is |root#0@@2| Tclass.PivotBetree.BetreeNode)) ($Is |key#0@@11| Tclass.KeyType.Key))))) (and (and (|PivotBetree.QueryReceipt.Valid#canCall| (Lit this@@132)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.Valid (Lit this@@132))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.QueryReceipt.root (Lit this@@132)))) (|$IsA#PivotBetree.BetreeNode| (Lit |root#0@@2|))) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@132))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root (Lit this@@132)) |root#0@@2|) (PivotBetree.QueryReceipt.QueryReceipt_q (Lit this@@132)))))) (= (PivotBetree.QueryReceipt.ValidFor (Lit this@@132) (Lit |root#0@@2|) (Lit |key#0@@11|))  (and (and (PivotBetree.QueryReceipt.Valid (Lit this@@132)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.QueryReceipt.root (Lit this@@132)) |root#0@@2|)) (|Seq#Equal| (PivotBetree.QueryReceipt.key (Lit this@@132)) |key#0@@11|)))))
 :qid |PivotBetreebrokenidfy.383:15|
 :weight 3
 :skolemid |2012|
 :pattern ( (PivotBetree.QueryReceipt.ValidFor (Lit this@@132) (Lit |root#0@@2|) (Lit |key#0@@11|)))
))))
(assert (forall ((arg0@@421 T@U) (arg1@@169 T@U) ) (! (= (type (|#PivotBetree.Variables.Variables| arg0@@421 arg1@@169)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Variables.Variables|
 :pattern ( (|#PivotBetree.Variables.Variables| arg0@@421 arg1@@169))
)))
(assert (forall ((|a#0#0#0@@2| T@U) (|a#0#1#0@@2| T@U) ) (!  (=> (and (= (type |a#0#0#0@@2|) DatatypeTypeType) (= (type |a#0#1#0@@2|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Variables.Variables| |a#0#0#0@@2| |a#0#1#0@@2|)) |##PivotBetree.Variables.Variables|))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2014|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#0#0#0@@2| |a#0#1#0@@2|))
)))
(assert (forall ((d@@56 T@U) ) (!  (=> (= (type d@@56) DatatypeTypeType) (= (PivotBetree.Variables.Variables_q d@@56) (= (DatatypeCtorId d@@56) |##PivotBetree.Variables.Variables|)))
 :qid |unknown.0:0|
 :skolemid |2015|
 :pattern ( (PivotBetree.Variables.Variables_q d@@56))
)))
(assert (forall ((d@@57 T@U) ) (!  (=> (and (= (type d@@57) DatatypeTypeType) (PivotBetree.Variables.Variables_q d@@57)) (exists ((|a#1#0#0@@2| T@U) (|a#1#1#0@@2| T@U) ) (!  (and (and (= (type |a#1#0#0@@2|) DatatypeTypeType) (= (type |a#1#1#0@@2|) DatatypeTypeType)) (= d@@57 (|#PivotBetree.Variables.Variables| |a#1#0#0@@2| |a#1#1#0@@2|)))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2016|
 :no-pattern (type |a#1#0#0@@2|)
 :no-pattern (type |a#1#1#0@@2|)
 :no-pattern (U_2_int |a#1#0#0@@2|)
 :no-pattern (U_2_bool |a#1#0#0@@2|)
 :no-pattern (U_2_int |a#1#1#0@@2|)
 :no-pattern (U_2_bool |a#1#1#0@@2|)
)))
 :qid |unknown.0:0|
 :skolemid |2017|
 :pattern ( (PivotBetree.Variables.Variables_q d@@57))
)))
(assert (= (type Tclass.MemtableMod.Memtable) TyType))
(assert (= (Tag Tclass.MemtableMod.Memtable) Tagclass.MemtableMod.Memtable))
(assert (= (TagFamily Tclass.MemtableMod.Memtable) tytagFamily$Memtable))
(assert (forall ((bx@@120 T@U) ) (!  (=> (and (= (type bx@@120) BoxType) ($IsBox bx@@120 Tclass.MemtableMod.Memtable)) (and (= ($Box ($Unbox DatatypeTypeType bx@@120)) bx@@120) ($Is ($Unbox DatatypeTypeType bx@@120) Tclass.MemtableMod.Memtable)))
 :qid |unknown.0:0|
 :skolemid |2018|
 :pattern ( ($IsBox bx@@120 Tclass.MemtableMod.Memtable))
)))
(assert (= (type Tclass.PivotBetree.Variables) TyType))
(assert (= (Tag Tclass.PivotBetree.Variables) Tagclass.PivotBetree.Variables))
(assert (= (TagFamily Tclass.PivotBetree.Variables) tytagFamily$Variables))
(assert (forall ((bx@@121 T@U) ) (!  (=> (and (= (type bx@@121) BoxType) ($IsBox bx@@121 Tclass.PivotBetree.Variables)) (and (= ($Box ($Unbox DatatypeTypeType bx@@121)) bx@@121) ($Is ($Unbox DatatypeTypeType bx@@121) Tclass.PivotBetree.Variables)))
 :qid |unknown.0:0|
 :skolemid |2019|
 :pattern ( ($IsBox bx@@121 Tclass.PivotBetree.Variables))
)))
(assert (forall ((|a#2#0#0@@2| T@U) (|a#2#1#0@@2| T@U) ) (!  (=> (and (= (type |a#2#0#0@@2|) DatatypeTypeType) (= (type |a#2#1#0@@2|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Variables.Variables| |a#2#0#0@@2| |a#2#1#0@@2|) Tclass.PivotBetree.Variables)  (and ($Is |a#2#0#0@@2| Tclass.MemtableMod.Memtable) ($Is |a#2#1#0@@2| Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2020|
 :pattern ( ($Is (|#PivotBetree.Variables.Variables| |a#2#0#0@@2| |a#2#1#0@@2|) Tclass.PivotBetree.Variables))
)))
(assert (forall ((|a#3#0#0@@2| T@U) (|a#3#1#0@@2| T@U) ($h@@72 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@2|) DatatypeTypeType) (= (type |a#3#1#0@@2|) DatatypeTypeType)) (= (type $h@@72) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@72)) (= ($IsAlloc (|#PivotBetree.Variables.Variables| |a#3#0#0@@2| |a#3#1#0@@2|) Tclass.PivotBetree.Variables $h@@72)  (and ($IsAlloc |a#3#0#0@@2| Tclass.MemtableMod.Memtable $h@@72) ($IsAlloc |a#3#1#0@@2| Tclass.PivotBetree.BetreeNode $h@@72))))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2021|
 :pattern ( ($IsAlloc (|#PivotBetree.Variables.Variables| |a#3#0#0@@2| |a#3#1#0@@2|) Tclass.PivotBetree.Variables $h@@72))
)))
(assert (forall ((arg0@@422 T@U) ) (! (= (type (PivotBetree.Variables.memtable arg0@@422)) DatatypeTypeType)
 :qid |funType:PivotBetree.Variables.memtable|
 :pattern ( (PivotBetree.Variables.memtable arg0@@422))
)))
(assert (forall ((d@@58 T@U) ($h@@73 T@U) ) (!  (=> (and (and (= (type d@@58) DatatypeTypeType) (= (type $h@@73) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@73) (and (PivotBetree.Variables.Variables_q d@@58) ($IsAlloc d@@58 Tclass.PivotBetree.Variables $h@@73)))) ($IsAlloc (PivotBetree.Variables.memtable d@@58) Tclass.MemtableMod.Memtable $h@@73))
 :qid |unknown.0:0|
 :skolemid |2022|
 :pattern ( ($IsAlloc (PivotBetree.Variables.memtable d@@58) Tclass.MemtableMod.Memtable $h@@73))
)))
(assert (forall ((arg0@@423 T@U) ) (! (= (type (PivotBetree.Variables.root arg0@@423)) DatatypeTypeType)
 :qid |funType:PivotBetree.Variables.root|
 :pattern ( (PivotBetree.Variables.root arg0@@423))
)))
(assert (forall ((d@@59 T@U) ($h@@74 T@U) ) (!  (=> (and (and (= (type d@@59) DatatypeTypeType) (= (type $h@@74) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@74) (and (PivotBetree.Variables.Variables_q d@@59) ($IsAlloc d@@59 Tclass.PivotBetree.Variables $h@@74)))) ($IsAlloc (PivotBetree.Variables.root d@@59) Tclass.PivotBetree.BetreeNode $h@@74))
 :qid |unknown.0:0|
 :skolemid |2023|
 :pattern ( ($IsAlloc (PivotBetree.Variables.root d@@59) Tclass.PivotBetree.BetreeNode $h@@74))
)))
(assert (forall ((|a#4#0#0@@2| T@U) (|a#4#1#0@@2| T@U) ) (!  (=> (and (= (type |a#4#0#0@@2|) DatatypeTypeType) (= (type |a#4#1#0@@2|) DatatypeTypeType)) (= (|#PivotBetree.Variables.Variables| (Lit |a#4#0#0@@2|) (Lit |a#4#1#0@@2|)) (Lit (|#PivotBetree.Variables.Variables| |a#4#0#0@@2| |a#4#1#0@@2|))))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2024|
 :pattern ( (|#PivotBetree.Variables.Variables| (Lit |a#4#0#0@@2|) (Lit |a#4#1#0@@2|)))
)))
(assert (forall ((|a#5#0#0@@2| T@U) (|a#5#1#0@@2| T@U) ) (!  (=> (and (= (type |a#5#0#0@@2|) DatatypeTypeType) (= (type |a#5#1#0@@2|) DatatypeTypeType)) (= (PivotBetree.Variables.memtable (|#PivotBetree.Variables.Variables| |a#5#0#0@@2| |a#5#1#0@@2|)) |a#5#0#0@@2|))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2025|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#5#0#0@@2| |a#5#1#0@@2|))
)))
(assert (forall ((|a#6#0#0@@2| T@U) (|a#6#1#0@@2| T@U) ) (!  (=> (and (= (type |a#6#0#0@@2|) DatatypeTypeType) (= (type |a#6#1#0@@2|) DatatypeTypeType)) (< (DtRank |a#6#0#0@@2|) (DtRank (|#PivotBetree.Variables.Variables| |a#6#0#0@@2| |a#6#1#0@@2|))))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2026|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#6#0#0@@2| |a#6#1#0@@2|))
)))
(assert (forall ((|a#7#0#0@@2| T@U) (|a#7#1#0@@2| T@U) ) (!  (=> (and (= (type |a#7#0#0@@2|) DatatypeTypeType) (= (type |a#7#1#0@@2|) DatatypeTypeType)) (= (PivotBetree.Variables.root (|#PivotBetree.Variables.Variables| |a#7#0#0@@2| |a#7#1#0@@2|)) |a#7#1#0@@2|))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2027|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#7#0#0@@2| |a#7#1#0@@2|))
)))
(assert (forall ((|a#8#0#0@@2| T@U) (|a#8#1#0@@2| T@U) ) (!  (=> (and (= (type |a#8#0#0@@2|) DatatypeTypeType) (= (type |a#8#1#0@@2|) DatatypeTypeType)) (< (DtRank |a#8#1#0@@2|) (DtRank (|#PivotBetree.Variables.Variables| |a#8#0#0@@2| |a#8#1#0@@2|))))
 :qid |PivotBetreebrokenidfy.407:5|
 :skolemid |2028|
 :pattern ( (|#PivotBetree.Variables.Variables| |a#8#0#0@@2| |a#8#1#0@@2|))
)))
(assert (forall ((d@@60 T@U) ) (!  (=> (and (= (type d@@60) DatatypeTypeType) (|$IsA#PivotBetree.Variables| d@@60)) (PivotBetree.Variables.Variables_q d@@60))
 :qid |unknown.0:0|
 :skolemid |2029|
 :pattern ( (|$IsA#PivotBetree.Variables| d@@60))
)))
(assert (forall ((d@@61 T@U) ) (!  (=> (and (= (type d@@61) DatatypeTypeType) ($Is d@@61 Tclass.PivotBetree.Variables)) (PivotBetree.Variables.Variables_q d@@61))
 :qid |unknown.0:0|
 :skolemid |2030|
 :pattern ( (PivotBetree.Variables.Variables_q d@@61) ($Is d@@61 Tclass.PivotBetree.Variables))
)))
(assert (forall ((a@@131 T@U) (b@@80 T@U) ) (!  (=> (and (and (= (type a@@131) DatatypeTypeType) (= (type b@@80) DatatypeTypeType)) true) (= (|PivotBetree.Variables#Equal| a@@131 b@@80)  (and (|MemtableMod.Memtable#Equal| (PivotBetree.Variables.memtable a@@131) (PivotBetree.Variables.memtable b@@80)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Variables.root a@@131) (PivotBetree.Variables.root b@@80)))))
 :qid |unknown.0:0|
 :skolemid |2031|
 :pattern ( (|PivotBetree.Variables#Equal| a@@131 b@@80))
)))
(assert (forall ((a@@132 T@U) (b@@81 T@U) ) (!  (=> (and (= (type a@@132) DatatypeTypeType) (= (type b@@81) DatatypeTypeType)) (= (|PivotBetree.Variables#Equal| a@@132 b@@81) (= a@@132 b@@81)))
 :qid |unknown.0:0|
 :skolemid |2032|
 :pattern ( (|PivotBetree.Variables#Equal| a@@132 b@@81))
)))
(assert  (=> (<= 71 $FunctionContextHeight) (forall ((this@@133 T@U) ) (!  (=> (and (= (type this@@133) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| this@@133) (and (not (= 71 $FunctionContextHeight)) ($Is this@@133 Tclass.PivotBetree.Variables)))) true)
 :qid |PivotBetreebrokenidfy.410:15|
 :skolemid |2033|
 :pattern ( (PivotBetree.Variables.WF this@@133))
))))
(assert (forall ((this@@134 T@U) ) (!  (=> (and (= (type this@@134) DatatypeTypeType) ($Is this@@134 Tclass.PivotBetree.Variables)) (= (|PivotBetree.Variables.WF#requires| this@@134) true))
 :qid |PivotBetreebrokenidfy.410:15|
 :skolemid |2034|
 :pattern ( (|PivotBetree.Variables.WF#requires| this@@134))
)))
(assert  (=> (<= 71 $FunctionContextHeight) (forall ((this@@135 T@U) ) (!  (=> (and (= (type this@@135) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| this@@135) (and (not (= 71 $FunctionContextHeight)) ($Is this@@135 Tclass.PivotBetree.Variables)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PivotBetree.Variables.Variables_q this@@135) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Variables.root this@@135)))) (= (PivotBetree.Variables.WF this@@135)  (and true (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Variables.root this@@135))))))
 :qid |PivotBetreebrokenidfy.410:15|
 :skolemid |2035|
 :pattern ( (PivotBetree.Variables.WF this@@135))
))))
(assert  (=> (<= 71 $FunctionContextHeight) (forall ((this@@136 T@U) ) (!  (=> (and (= (type this@@136) DatatypeTypeType) (or (|PivotBetree.Variables.WF#canCall| (Lit this@@136)) (and (not (= 71 $FunctionContextHeight)) ($Is this@@136 Tclass.PivotBetree.Variables)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (PivotBetree.Variables.Variables_q (Lit this@@136)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.Variables.root (Lit this@@136)))))) (= (PivotBetree.Variables.WF (Lit this@@136)) (U_2_bool (Lit (bool_2_U  (and true (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Variables.root (Lit this@@136)))))))))))
 :qid |PivotBetreebrokenidfy.410:15|
 :weight 3
 :skolemid |2036|
 :pattern ( (PivotBetree.Variables.WF (Lit this@@136)))
))))
(assert (forall ((arg0@@424 T@U) (arg1@@170 T@U) (arg2@@84 Int) ) (! (= (type (|#PivotBetree.Path.Path| arg0@@424 arg1@@170 arg2@@84)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Path.Path|
 :pattern ( (|#PivotBetree.Path.Path| arg0@@424 arg1@@170 arg2@@84))
)))
(assert (forall ((|a#0#0#0@@3| T@U) (|a#0#1#0@@3| T@U) (|a#0#2#0@@0| Int) ) (!  (=> (and (= (type |a#0#0#0@@3|) DatatypeTypeType) (= (type |a#0#1#0@@3|) (SeqType BoxType))) (= (DatatypeCtorId (|#PivotBetree.Path.Path| |a#0#0#0@@3| |a#0#1#0@@3| |a#0#2#0@@0|)) |##PivotBetree.Path.Path|))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2038|
 :pattern ( (|#PivotBetree.Path.Path| |a#0#0#0@@3| |a#0#1#0@@3| |a#0#2#0@@0|))
)))
(assert (forall ((d@@62 T@U) ) (!  (=> (= (type d@@62) DatatypeTypeType) (= (PivotBetree.Path.Path_q d@@62) (= (DatatypeCtorId d@@62) |##PivotBetree.Path.Path|)))
 :qid |unknown.0:0|
 :skolemid |2039|
 :pattern ( (PivotBetree.Path.Path_q d@@62))
)))
(assert (forall ((d@@63 T@U) ) (!  (=> (and (= (type d@@63) DatatypeTypeType) (PivotBetree.Path.Path_q d@@63)) (exists ((|a#1#0#0@@3| T@U) (|a#1#1#0@@3| T@U) (|a#1#2#0@@0| Int) ) (!  (and (and (= (type |a#1#0#0@@3|) DatatypeTypeType) (= (type |a#1#1#0@@3|) (SeqType BoxType))) (= d@@63 (|#PivotBetree.Path.Path| |a#1#0#0@@3| |a#1#1#0@@3| |a#1#2#0@@0|)))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2040|
 :no-pattern (type |a#1#0#0@@3|)
 :no-pattern (type |a#1#1#0@@3|)
 :no-pattern (U_2_int |a#1#0#0@@3|)
 :no-pattern (U_2_bool |a#1#0#0@@3|)
 :no-pattern (U_2_int |a#1#1#0@@3|)
 :no-pattern (U_2_bool |a#1#1#0@@3|)
)))
 :qid |unknown.0:0|
 :skolemid |2041|
 :pattern ( (PivotBetree.Path.Path_q d@@63))
)))
(assert (= (type Tclass.PivotBetree.Path) TyType))
(assert (= (Tag Tclass.PivotBetree.Path) Tagclass.PivotBetree.Path))
(assert (= (TagFamily Tclass.PivotBetree.Path) tytagFamily$Path))
(assert (forall ((bx@@122 T@U) ) (!  (=> (and (= (type bx@@122) BoxType) ($IsBox bx@@122 Tclass.PivotBetree.Path)) (and (= ($Box ($Unbox DatatypeTypeType bx@@122)) bx@@122) ($Is ($Unbox DatatypeTypeType bx@@122) Tclass.PivotBetree.Path)))
 :qid |unknown.0:0|
 :skolemid |2042|
 :pattern ( ($IsBox bx@@122 Tclass.PivotBetree.Path))
)))
(assert (forall ((|a#2#0#0@@3| T@U) (|a#2#1#0@@3| T@U) (|a#2#2#0@@0| Int) ) (!  (=> (and (= (type |a#2#0#0@@3|) DatatypeTypeType) (= (type |a#2#1#0@@3|) (SeqType BoxType))) (= ($Is (|#PivotBetree.Path.Path| |a#2#0#0@@3| |a#2#1#0@@3| |a#2#2#0@@0|) Tclass.PivotBetree.Path)  (and (and ($Is |a#2#0#0@@3| Tclass.PivotBetree.BetreeNode) ($Is |a#2#1#0@@3| Tclass.KeyType.Key)) ($Is (int_2_U |a#2#2#0@@0|) Tclass._System.nat))))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2043|
 :pattern ( ($Is (|#PivotBetree.Path.Path| |a#2#0#0@@3| |a#2#1#0@@3| |a#2#2#0@@0|) Tclass.PivotBetree.Path))
)))
(assert (forall ((|a#3#0#0@@3| T@U) (|a#3#1#0@@3| T@U) (|a#3#2#0@@0| Int) ($h@@75 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@3|) DatatypeTypeType) (= (type |a#3#1#0@@3|) (SeqType BoxType))) (= (type $h@@75) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@75)) (= ($IsAlloc (|#PivotBetree.Path.Path| |a#3#0#0@@3| |a#3#1#0@@3| |a#3#2#0@@0|) Tclass.PivotBetree.Path $h@@75)  (and (and ($IsAlloc |a#3#0#0@@3| Tclass.PivotBetree.BetreeNode $h@@75) ($IsAlloc |a#3#1#0@@3| Tclass.KeyType.Key $h@@75)) ($IsAlloc (int_2_U |a#3#2#0@@0|) Tclass._System.nat $h@@75))))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2044|
 :pattern ( ($IsAlloc (|#PivotBetree.Path.Path| |a#3#0#0@@3| |a#3#1#0@@3| |a#3#2#0@@0|) Tclass.PivotBetree.Path $h@@75))
)))
(assert (forall ((arg0@@425 T@U) ) (! (= (type (PivotBetree.Path.node arg0@@425)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.node|
 :pattern ( (PivotBetree.Path.node arg0@@425))
)))
(assert (forall ((d@@64 T@U) ($h@@76 T@U) ) (!  (=> (and (and (= (type d@@64) DatatypeTypeType) (= (type $h@@76) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@76) (and (PivotBetree.Path.Path_q d@@64) ($IsAlloc d@@64 Tclass.PivotBetree.Path $h@@76)))) ($IsAlloc (PivotBetree.Path.node d@@64) Tclass.PivotBetree.BetreeNode $h@@76))
 :qid |unknown.0:0|
 :skolemid |2045|
 :pattern ( ($IsAlloc (PivotBetree.Path.node d@@64) Tclass.PivotBetree.BetreeNode $h@@76))
)))
(assert (forall ((arg0@@426 T@U) ) (! (= (type (PivotBetree.Path.key arg0@@426)) (SeqType BoxType))
 :qid |funType:PivotBetree.Path.key|
 :pattern ( (PivotBetree.Path.key arg0@@426))
)))
(assert (forall ((d@@65 T@U) ($h@@77 T@U) ) (!  (=> (and (and (= (type d@@65) DatatypeTypeType) (= (type $h@@77) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@77) (and (PivotBetree.Path.Path_q d@@65) ($IsAlloc d@@65 Tclass.PivotBetree.Path $h@@77)))) ($IsAlloc (PivotBetree.Path.key d@@65) Tclass.KeyType.Key $h@@77))
 :qid |unknown.0:0|
 :skolemid |2046|
 :pattern ( ($IsAlloc (PivotBetree.Path.key d@@65) Tclass.KeyType.Key $h@@77))
)))
(assert (forall ((d@@66 T@U) ($h@@78 T@U) ) (!  (=> (and (and (= (type d@@66) DatatypeTypeType) (= (type $h@@78) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@78) (and (PivotBetree.Path.Path_q d@@66) ($IsAlloc d@@66 Tclass.PivotBetree.Path $h@@78)))) ($IsAlloc (int_2_U (PivotBetree.Path.depth d@@66)) Tclass._System.nat $h@@78))
 :qid |unknown.0:0|
 :skolemid |2047|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.Path.depth d@@66)) Tclass._System.nat $h@@78))
)))
(assert (forall ((|a#4#0#0@@3| T@U) (|a#4#1#0@@3| T@U) (|a#4#2#0@@0| Int) ) (!  (=> (and (= (type |a#4#0#0@@3|) DatatypeTypeType) (= (type |a#4#1#0@@3|) (SeqType BoxType))) (= (|#PivotBetree.Path.Path| (Lit |a#4#0#0@@3|) (Lit |a#4#1#0@@3|) (LitInt |a#4#2#0@@0|)) (Lit (|#PivotBetree.Path.Path| |a#4#0#0@@3| |a#4#1#0@@3| |a#4#2#0@@0|))))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2048|
 :pattern ( (|#PivotBetree.Path.Path| (Lit |a#4#0#0@@3|) (Lit |a#4#1#0@@3|) (LitInt |a#4#2#0@@0|)))
)))
(assert (forall ((|a#5#0#0@@3| T@U) (|a#5#1#0@@3| T@U) (|a#5#2#0@@0| Int) ) (!  (=> (and (= (type |a#5#0#0@@3|) DatatypeTypeType) (= (type |a#5#1#0@@3|) (SeqType BoxType))) (= (PivotBetree.Path.node (|#PivotBetree.Path.Path| |a#5#0#0@@3| |a#5#1#0@@3| |a#5#2#0@@0|)) |a#5#0#0@@3|))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2049|
 :pattern ( (|#PivotBetree.Path.Path| |a#5#0#0@@3| |a#5#1#0@@3| |a#5#2#0@@0|))
)))
(assert (forall ((|a#6#0#0@@3| T@U) (|a#6#1#0@@3| T@U) (|a#6#2#0@@0| Int) ) (!  (=> (and (= (type |a#6#0#0@@3|) DatatypeTypeType) (= (type |a#6#1#0@@3|) (SeqType BoxType))) (< (DtRank |a#6#0#0@@3|) (DtRank (|#PivotBetree.Path.Path| |a#6#0#0@@3| |a#6#1#0@@3| |a#6#2#0@@0|))))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2050|
 :pattern ( (|#PivotBetree.Path.Path| |a#6#0#0@@3| |a#6#1#0@@3| |a#6#2#0@@0|))
)))
(assert (forall ((|a#7#0#0@@3| T@U) (|a#7#1#0@@3| T@U) (|a#7#2#0@@0| Int) ) (!  (=> (and (= (type |a#7#0#0@@3|) DatatypeTypeType) (= (type |a#7#1#0@@3|) (SeqType BoxType))) (= (PivotBetree.Path.key (|#PivotBetree.Path.Path| |a#7#0#0@@3| |a#7#1#0@@3| |a#7#2#0@@0|)) |a#7#1#0@@3|))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2051|
 :pattern ( (|#PivotBetree.Path.Path| |a#7#0#0@@3| |a#7#1#0@@3| |a#7#2#0@@0|))
)))
(assert (forall ((|a#8#0#0@@3| T@U) (|a#8#1#0@@3| T@U) (|a#8#2#0@@0| Int) ) (!  (=> (and (= (type |a#8#0#0@@3|) DatatypeTypeType) (= (type |a#8#1#0@@3|) (SeqType BoxType))) (= (PivotBetree.Path.depth (|#PivotBetree.Path.Path| |a#8#0#0@@3| |a#8#1#0@@3| |a#8#2#0@@0|)) |a#8#2#0@@0|))
 :qid |PivotBetreebrokenidfy.462:24|
 :skolemid |2052|
 :pattern ( (|#PivotBetree.Path.Path| |a#8#0#0@@3| |a#8#1#0@@3| |a#8#2#0@@0|))
)))
(assert (forall ((d@@67 T@U) ) (!  (=> (and (= (type d@@67) DatatypeTypeType) (|$IsA#PivotBetree.Path| d@@67)) (PivotBetree.Path.Path_q d@@67))
 :qid |unknown.0:0|
 :skolemid |2053|
 :pattern ( (|$IsA#PivotBetree.Path| d@@67))
)))
(assert (forall ((d@@68 T@U) ) (!  (=> (and (= (type d@@68) DatatypeTypeType) ($Is d@@68 Tclass.PivotBetree.Path)) (PivotBetree.Path.Path_q d@@68))
 :qid |unknown.0:0|
 :skolemid |2054|
 :pattern ( (PivotBetree.Path.Path_q d@@68) ($Is d@@68 Tclass.PivotBetree.Path))
)))
(assert (forall ((a@@133 T@U) (b@@82 T@U) ) (!  (=> (and (and (= (type a@@133) DatatypeTypeType) (= (type b@@82) DatatypeTypeType)) true) (= (|PivotBetree.Path#Equal| a@@133 b@@82)  (and (and (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node a@@133) (PivotBetree.Path.node b@@82)) (|Seq#Equal| (PivotBetree.Path.key a@@133) (PivotBetree.Path.key b@@82))) (= (PivotBetree.Path.depth a@@133) (PivotBetree.Path.depth b@@82)))))
 :qid |unknown.0:0|
 :skolemid |2055|
 :pattern ( (|PivotBetree.Path#Equal| a@@133 b@@82))
)))
(assert (forall ((a@@134 T@U) (b@@83 T@U) ) (!  (=> (and (= (type a@@134) DatatypeTypeType) (= (type b@@83) DatatypeTypeType)) (= (|PivotBetree.Path#Equal| a@@134 b@@83) (= a@@134 b@@83)))
 :qid |unknown.0:0|
 :skolemid |2056|
 :pattern ( (|PivotBetree.Path#Equal| a@@134 b@@83))
)))
(assert (forall ((arg0@@427 T@U) ) (! (= (type (PivotBetree.Path.Subpath arg0@@427)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Subpath|
 :pattern ( (PivotBetree.Path.Subpath arg0@@427))
)))
(assert  (=> (<= 57 $FunctionContextHeight) (forall ((this@@137 T@U) ) (!  (=> (and (= (type this@@137) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| this@@137) (and (not (= 57 $FunctionContextHeight)) (and ($Is this@@137 Tclass.PivotBetree.Path) (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@137)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@137) (PivotBetree.Path.key this@@137))))))) ($Is (PivotBetree.Path.Subpath this@@137) Tclass.PivotBetree.Path))
 :qid |PivotBetreebrokenidfy.464:14|
 :skolemid |2057|
 :pattern ( (PivotBetree.Path.Subpath this@@137))
))))
(assert (forall ((this@@138 T@U) ) (!  (=> (and (= (type this@@138) DatatypeTypeType) ($Is this@@138 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Subpath#requires| this@@138)  (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@138)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@138) (PivotBetree.Path.key this@@138)))))
 :qid |PivotBetreebrokenidfy.464:14|
 :skolemid |2058|
 :pattern ( (|PivotBetree.Path.Subpath#requires| this@@138))
)))
(assert  (=> (<= 57 $FunctionContextHeight) (forall ((this@@139 T@U) ) (!  (=> (and (= (type this@@139) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| this@@139) (and (not (= 57 $FunctionContextHeight)) (and ($Is this@@139 Tclass.PivotBetree.Path) (and (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@139)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@139) (PivotBetree.Path.key this@@139))))))) (and (and (and (and (and (PivotBetree.Path.Path_q this@@139) (PivotBetree.Path.Path_q this@@139)) (|PivotBetree.BetreeNode.Child#canCall| (PivotBetree.Path.node this@@139) (PivotBetree.Path.key this@@139))) (PivotBetree.Path.Path_q this@@139)) (PivotBetree.Path.Path_q this@@139)) (= (PivotBetree.Path.Subpath this@@139) (|#PivotBetree.Path.Path| (PivotBetree.BetreeNode.Child (PivotBetree.Path.node this@@139) (PivotBetree.Path.key this@@139)) (PivotBetree.Path.key this@@139) (INTERNAL_sub_boogie (PivotBetree.Path.depth this@@139) 1)))))
 :qid |PivotBetreebrokenidfy.464:14|
 :skolemid |2059|
 :pattern ( (PivotBetree.Path.Subpath this@@139))
))))
(assert  (=> (<= 57 $FunctionContextHeight) (forall ((this@@140 T@U) ) (!  (=> (and (= (type this@@140) DatatypeTypeType) (or (|PivotBetree.Path.Subpath#canCall| (Lit this@@140)) (and (not (= 57 $FunctionContextHeight)) (and ($Is this@@140 Tclass.PivotBetree.Path) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@140)))))) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@140))) (Lit (PivotBetree.Path.key (Lit this@@140)))))))))))) (and (and (and (and (and (PivotBetree.Path.Path_q (Lit this@@140)) (PivotBetree.Path.Path_q (Lit this@@140))) (|PivotBetree.BetreeNode.Child#canCall| (Lit (PivotBetree.Path.node (Lit this@@140))) (Lit (PivotBetree.Path.key (Lit this@@140))))) (PivotBetree.Path.Path_q (Lit this@@140))) (PivotBetree.Path.Path_q (Lit this@@140))) (= (PivotBetree.Path.Subpath (Lit this@@140)) (Lit (|#PivotBetree.Path.Path| (Lit (PivotBetree.BetreeNode.Child (Lit (PivotBetree.Path.node (Lit this@@140))) (Lit (PivotBetree.Path.key (Lit this@@140))))) (Lit (PivotBetree.Path.key (Lit this@@140))) (LitInt (INTERNAL_sub_boogie (PivotBetree.Path.depth (Lit this@@140)) 1)))))))
 :qid |PivotBetreebrokenidfy.464:14|
 :weight 3
 :skolemid |2060|
 :pattern ( (PivotBetree.Path.Subpath (Lit this@@140)))
))))
(assert (forall (($ly@@5 T@U) (this@@141 T@U) ) (!  (=> (and (= (type $ly@@5) LayerTypeType) (= (type this@@141) DatatypeTypeType)) (= (PivotBetree.Path.Valid ($LS $ly@@5) this@@141) (PivotBetree.Path.Valid $ly@@5 this@@141)))
 :qid |PivotBetreebrokenidfy.471:15|
 :skolemid |2075|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@5) this@@141))
)))
(assert (forall (($ly@@6 T@U) (this@@142 T@U) ) (!  (=> (and (= (type $ly@@6) LayerTypeType) (= (type this@@142) DatatypeTypeType)) (= (PivotBetree.Path.Valid $ly@@6 this@@142) (PivotBetree.Path.Valid $LZ this@@142)))
 :qid |PivotBetreebrokenidfy.471:15|
 :skolemid |2076|
 :pattern ( (PivotBetree.Path.Valid (AsFuelBottom $ly@@6) this@@142))
)))
(assert  (=> (<= 58 $FunctionContextHeight) (forall (($ly@@7 T@U) (this@@143 T@U) ) (!  (=> (and (and (= (type $ly@@7) LayerTypeType) (= (type this@@143) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| this@@143) (and (not (= 58 $FunctionContextHeight)) ($Is this@@143 Tclass.PivotBetree.Path)))) true)
 :qid |PivotBetreebrokenidfy.471:15|
 :skolemid |2077|
 :pattern ( (PivotBetree.Path.Valid $ly@@7 this@@143))
))))
(assert (forall (($ly@@8 T@U) (this@@144 T@U) ) (!  (=> (and (and (= (type $ly@@8) LayerTypeType) (= (type this@@144) DatatypeTypeType)) ($Is this@@144 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Valid#requires| $ly@@8 this@@144) true))
 :qid |PivotBetreebrokenidfy.471:15|
 :skolemid |2078|
 :pattern ( (|PivotBetree.Path.Valid#requires| $ly@@8 this@@144))
)))
(assert  (=> (<= 58 $FunctionContextHeight) (forall (($ly@@9 T@U) (this@@145 T@U) ) (!  (=> (and (and (= (type $ly@@9) LayerTypeType) (= (type this@@145) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| this@@145) (and (not (= 58 $FunctionContextHeight)) ($Is this@@145 Tclass.PivotBetree.Path)))) (and (and (and (PivotBetree.Path.Path_q this@@145) (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@145))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@145)) (and (and (and (PivotBetree.Path.Path_q this@@145) (PivotBetree.Path.Path_q this@@145)) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@145) (PivotBetree.Path.key this@@145))) (=> (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@145) (PivotBetree.Path.key this@@145)) (and (and (PivotBetree.Path.Path_q this@@145) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@145)) (and (PivotBetree.Path.Path_q this@@145) (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@145))))) (=> (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@145)) (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@145))) (and (PivotBetree.Path.Path_q this@@145) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@145)) (and (|PivotBetree.Path.Subpath#canCall| this@@145) (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@145))))))))))) (= (PivotBetree.Path.Valid ($LS $ly@@9) this@@145)  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@145)) (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@145) (PivotBetree.Path.key this@@145))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@145)) (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@145)))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@145)) (PivotBetree.Path.Valid $ly@@9 (PivotBetree.Path.Subpath this@@145)))))))
 :qid |PivotBetreebrokenidfy.471:15|
 :skolemid |2079|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@9) this@@145))
))))
(assert  (=> (<= 58 $FunctionContextHeight) (forall (($ly@@10 T@U) (this@@146 T@U) ) (!  (=> (and (and (= (type $ly@@10) LayerTypeType) (= (type this@@146) DatatypeTypeType)) (or (|PivotBetree.Path.Valid#canCall| (Lit this@@146)) (and (not (= 58 $FunctionContextHeight)) ($Is this@@146 Tclass.PivotBetree.Path)))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@146)) (|PivotBetree.BetreeNode.WF#canCall| (Lit (PivotBetree.Path.node (Lit this@@146))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Path.node (Lit this@@146))))))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@146)) (PivotBetree.Path.Path_q (Lit this@@146))) (|PivotBetree.BetreeNode.KeyInDomain#canCall| (Lit (PivotBetree.Path.node (Lit this@@146))) (Lit (PivotBetree.Path.key (Lit this@@146))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@146))) (Lit (PivotBetree.Path.key (Lit this@@146))))))) (and (and (PivotBetree.Path.Path_q (Lit this@@146)) (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@146)))))) (and (PivotBetree.Path.Path_q (Lit this@@146)) (|PivotBetree.BetreeNode.IsIndex#canCall| (Lit (PivotBetree.Path.node (Lit this@@146))))))) (=> (U_2_bool (Lit (bool_2_U  (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@146))) (PivotBetree.BetreeNode.IsIndex (Lit (PivotBetree.Path.node (Lit this@@146)))))))) (and (PivotBetree.Path.Path_q (Lit this@@146)) (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@146)))))) (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@146)) (|PivotBetree.Path.Valid#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@146))))))))))))) (= (PivotBetree.Path.Valid ($LS $ly@@10) (Lit this@@146)) (U_2_bool (Lit (bool_2_U  (and (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit (PivotBetree.Path.node (Lit this@@146)))) (PivotBetree.BetreeNode.KeyInDomain (Lit (PivotBetree.Path.node (Lit this@@146))) (Lit (PivotBetree.Path.key (Lit this@@146))))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@146))) (PivotBetree.BetreeNode.IsIndex (Lit (PivotBetree.Path.node (Lit this@@146)))))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@146))) (PivotBetree.Path.Valid ($LS $ly@@10) (Lit (PivotBetree.Path.Subpath (Lit this@@146))))))))))))
 :qid |PivotBetreebrokenidfy.471:15|
 :weight 3
 :skolemid |2080|
 :pattern ( (PivotBetree.Path.Valid ($LS $ly@@10) (Lit this@@146)))
))))
(assert (forall ((arg0@@428 T@U) (arg1@@171 T@U) ) (! (= (type (PivotBetree.Path.Target arg0@@428 arg1@@171)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Target|
 :pattern ( (PivotBetree.Path.Target arg0@@428 arg1@@171))
)))
(assert (forall (($ly@@11 T@U) (this@@147 T@U) ) (!  (=> (and (= (type $ly@@11) LayerTypeType) (= (type this@@147) DatatypeTypeType)) (= (PivotBetree.Path.Target ($LS $ly@@11) this@@147) (PivotBetree.Path.Target $ly@@11 this@@147)))
 :qid |PivotBetreebrokenidfy.480:14|
 :skolemid |2092|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@11) this@@147))
)))
(assert (forall (($ly@@12 T@U) (this@@148 T@U) ) (!  (=> (and (= (type $ly@@12) LayerTypeType) (= (type this@@148) DatatypeTypeType)) (= (PivotBetree.Path.Target $ly@@12 this@@148) (PivotBetree.Path.Target $LZ this@@148)))
 :qid |PivotBetreebrokenidfy.480:14|
 :skolemid |2093|
 :pattern ( (PivotBetree.Path.Target (AsFuelBottom $ly@@12) this@@148))
)))
(assert  (=> (<= 59 $FunctionContextHeight) (forall (($ly@@13 T@U) (this@@149 T@U) ) (!  (=> (and (and (= (type $ly@@13) LayerTypeType) (= (type this@@149) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| this@@149) (and (not (= 59 $FunctionContextHeight)) (and ($Is this@@149 Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) this@@149))))) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.Target $ly@@13 this@@149)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target $ly@@13 this@@149))) ($Is (PivotBetree.Path.Target $ly@@13 this@@149) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.480:14|
 :skolemid |2094|
 :pattern ( (PivotBetree.Path.Target $ly@@13 this@@149))
))))
(assert (forall (($ly@@14 T@U) (this@@150 T@U) ) (!  (=> (and (and (= (type $ly@@14) LayerTypeType) (= (type this@@150) DatatypeTypeType)) ($Is this@@150 Tclass.PivotBetree.Path)) (= (|PivotBetree.Path.Target#requires| $ly@@14 this@@150) (PivotBetree.Path.Valid ($LS $LZ) this@@150)))
 :qid |PivotBetreebrokenidfy.480:14|
 :skolemid |2095|
 :pattern ( (|PivotBetree.Path.Target#requires| $ly@@14 this@@150))
)))
(assert  (=> (<= 59 $FunctionContextHeight) (forall (($ly@@15 T@U) (this@@151 T@U) ) (!  (=> (and (and (= (type $ly@@15) LayerTypeType) (= (type this@@151) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| this@@151) (and (not (= 59 $FunctionContextHeight)) (and ($Is this@@151 Tclass.PivotBetree.Path) (PivotBetree.Path.Valid ($LS $LZ) this@@151))))) (and (and (and (PivotBetree.Path.Path_q this@@151) (=> (= (LitInt 0) (PivotBetree.Path.depth this@@151)) (PivotBetree.Path.Path_q this@@151))) (=> (not (= (LitInt 0) (PivotBetree.Path.depth this@@151))) (and (|PivotBetree.Path.Subpath#canCall| this@@151) (|PivotBetree.Path.Target#canCall| (PivotBetree.Path.Subpath this@@151))))) (= (PivotBetree.Path.Target ($LS $ly@@15) this@@151) (ite (= (LitInt 0) (PivotBetree.Path.depth this@@151)) (PivotBetree.Path.node this@@151) (PivotBetree.Path.Target $ly@@15 (PivotBetree.Path.Subpath this@@151))))))
 :qid |PivotBetreebrokenidfy.480:14|
 :skolemid |2096|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@15) this@@151))
))))
(assert  (=> (<= 59 $FunctionContextHeight) (forall (($ly@@16 T@U) (this@@152 T@U) ) (!  (=> (and (and (= (type $ly@@16) LayerTypeType) (= (type this@@152) DatatypeTypeType)) (or (|PivotBetree.Path.Target#canCall| (Lit this@@152)) (and (not (= 59 $FunctionContextHeight)) (and ($Is this@@152 Tclass.PivotBetree.Path) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@152))))))))) (and (and (and (PivotBetree.Path.Path_q (Lit this@@152)) (=> (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@152)))) (PivotBetree.Path.Path_q (Lit this@@152)))) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@152))))) (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@152)) (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@152))))))) (= (PivotBetree.Path.Target ($LS $ly@@16) (Lit this@@152)) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@152)))) (PivotBetree.Path.node (Lit this@@152)) (PivotBetree.Path.Target ($LS $ly@@16) (Lit (PivotBetree.Path.Subpath (Lit this@@152))))))))
 :qid |PivotBetreebrokenidfy.480:14|
 :weight 3
 :skolemid |2097|
 :pattern ( (PivotBetree.Path.Target ($LS $ly@@16) (Lit this@@152)))
))))
(assert  (=> (<= 60 $FunctionContextHeight) (forall ((this@@153 T@U) (|otherChildren#0| T@U) ) (!  (=> (and (and (= (type this@@153) DatatypeTypeType) (= (type |otherChildren#0|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@153 |otherChildren#0|) (and (not (= 60 $FunctionContextHeight)) (and (and ($Is this@@153 Tclass.PivotBetree.Path) ($Is |otherChildren#0| (TSeq Tclass.PivotBetree.BetreeNode))) (and (PivotBetree.Path.Valid ($LS $LZ) this@@153) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@153))))))) true)
 :qid |PivotBetreebrokenidfy.491:15|
 :skolemid |2127|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains this@@153 |otherChildren#0|))
))))
(assert (forall ((this@@154 T@U) (|otherChildren#0@@0| T@U) ) (!  (=> (and (and (= (type this@@154) DatatypeTypeType) (= (type |otherChildren#0@@0|) (SeqType BoxType))) (and ($Is this@@154 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@0| (TSeq Tclass.PivotBetree.BetreeNode)))) (= (|PivotBetree.Path.ChildrenHaveMatchingDomains#requires| this@@154 |otherChildren#0@@0|)  (and (PivotBetree.Path.Valid ($LS $LZ) this@@154) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@154)))))
 :qid |PivotBetreebrokenidfy.491:15|
 :skolemid |2128|
 :pattern ( (|PivotBetree.Path.ChildrenHaveMatchingDomains#requires| this@@154 |otherChildren#0@@0|))
)))
(assert  (=> (<= 60 $FunctionContextHeight) (forall ((this@@155 T@U) (|otherChildren#0@@1| T@U) ) (!  (=> (and (and (= (type this@@155) DatatypeTypeType) (= (type |otherChildren#0@@1|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@155 |otherChildren#0@@1|) (and (not (= 60 $FunctionContextHeight)) (and (and ($Is this@@155 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@1| (TSeq Tclass.PivotBetree.BetreeNode))) (and (PivotBetree.Path.Valid ($LS $LZ) this@@155) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@155))))))) (and (and (|PivotBetree.__default.WFChildren#canCall| |otherChildren#0@@1|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) |otherChildren#0@@1|) (and (PivotBetree.Path.Path_q this@@155) (=> (= (|Seq#Length| |otherChildren#0@@1|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)))) (forall ((|i#0@@27| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@27|) (and (and (PivotBetree.Path.Path_q this@@155) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.node this@@155) |i#0@@27|)) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@155) |i#0@@27|) (and (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|))) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)) |i#0@@27|))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|))) (and (PivotBetree.Path.Path_q this@@155) (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)) |i#0@@27|))))))))))))
 :qid |PivotBetreebrokenidfy.498:18|
 :skolemid |2130|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)) |i#0@@27|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@27|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@155) |i#0@@27|))
)))))) (= (PivotBetree.Path.ChildrenHaveMatchingDomains this@@155 |otherChildren#0@@1|)  (and (and (PivotBetree.__default.WFChildren ($LS $LZ) |otherChildren#0@@1|) (= (|Seq#Length| |otherChildren#0@@1|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155))))) (forall ((|i#0@@28| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@28|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@155) |i#0@@28|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@28|))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@28|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@28|))) (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)) |i#0@@28|))))))
 :qid |PivotBetreebrokenidfy.498:18|
 :skolemid |2129|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@155)) |i#0@@28|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@1| |i#0@@28|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@155) |i#0@@28|))
))))))
 :qid |PivotBetreebrokenidfy.491:15|
 :skolemid |2131|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains this@@155 |otherChildren#0@@1|))
))))
(assert  (=> (<= 60 $FunctionContextHeight) (forall ((this@@156 T@U) (|otherChildren#0@@2| T@U) ) (!  (=> (and (and (= (type this@@156) DatatypeTypeType) (= (type |otherChildren#0@@2|) (SeqType BoxType))) (or (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| (Lit this@@156) (Lit |otherChildren#0@@2|)) (and (not (= 60 $FunctionContextHeight)) (and (and ($Is this@@156 Tclass.PivotBetree.Path) ($Is |otherChildren#0@@2| (TSeq Tclass.PivotBetree.BetreeNode))) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@156))))) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@156))))))))))) (and (and (|PivotBetree.__default.WFChildren#canCall| (Lit |otherChildren#0@@2|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.__default.WFChildren ($LS $LZ) (Lit |otherChildren#0@@2|))))) (and (PivotBetree.Path.Path_q (Lit this@@156)) (=> (= (|Seq#Length| (Lit |otherChildren#0@@2|)) (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@156))))))) (forall ((|i#1@@9| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@9|) (and (and (PivotBetree.Path.Path_q (Lit this@@156)) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (Lit (PivotBetree.Path.node (Lit this@@156))) |i#1@@9|)) (=> (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.node (Lit this@@156))) |i#1@@9|) (and (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@9|))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@9|))) (=> (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@9|))) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@9|)))) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@156))))) |i#1@@9|))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@9|))) (and (PivotBetree.Path.Path_q (Lit this@@156)) (|PivotBetree.BetreeNode.MyDomain#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@156))))) |i#1@@9|))))))))))))
 :qid |PivotBetreebrokenidfy.498:18|
 :skolemid |2133|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@156)) |i#1@@9|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@2| |i#1@@9|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@156) |i#1@@9|))
)))))) (= (PivotBetree.Path.ChildrenHaveMatchingDomains (Lit this@@156) (Lit |otherChildren#0@@2|))  (and (and (PivotBetree.__default.WFChildren ($LS $LZ) (Lit |otherChildren#0@@2|)) (= (|Seq#Length| (Lit |otherChildren#0@@2|)) (|Seq#Length| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@156)))))))) (forall ((|i#1@@10| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@10|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.node (Lit this@@156))) |i#1@@10|)) (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@10|))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@10|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit |otherChildren#0@@2|) |i#1@@10|))) (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@156))))) |i#1@@10|))))))
 :qid |PivotBetreebrokenidfy.498:18|
 :skolemid |2132|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@156)) |i#1@@10|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |otherChildren#0@@2| |i#1@@10|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@156) |i#1@@10|))
))))))
 :qid |PivotBetreebrokenidfy.491:15|
 :weight 3
 :skolemid |2134|
 :pattern ( (PivotBetree.Path.ChildrenHaveMatchingDomains (Lit this@@156) (Lit |otherChildren#0@@2|)))
))))
(assert (forall ((arg0@@429 T@U) (arg1@@172 T@U) (arg2@@85 T@U) ) (! (= (type (PivotBetree.Path.ReplacedChildren arg0@@429 arg1@@172 arg2@@85)) (SeqType BoxType))
 :qid |funType:PivotBetree.Path.ReplacedChildren|
 :pattern ( (PivotBetree.Path.ReplacedChildren arg0@@429 arg1@@172 arg2@@85))
)))
(assert (forall (($ly@@17 T@U) (this@@157 T@U) (|replacement#0| T@U) ) (!  (=> (and (and (= (type $ly@@17) LayerTypeType) (= (type this@@157) DatatypeTypeType)) (= (type |replacement#0|) DatatypeTypeType)) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@17) this@@157 |replacement#0|) (PivotBetree.Path.ReplacedChildren $ly@@17 this@@157 |replacement#0|)))
 :qid |PivotBetreebrokenidfy.505:14|
 :skolemid |2154|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@17) this@@157 |replacement#0|))
)))
(assert (forall (($ly@@18 T@U) (this@@158 T@U) (|replacement#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@18) LayerTypeType) (= (type this@@158) DatatypeTypeType)) (= (type |replacement#0@@0|) DatatypeTypeType)) (= (PivotBetree.Path.ReplacedChildren $ly@@18 this@@158 |replacement#0@@0|) (PivotBetree.Path.ReplacedChildren $LZ this@@158 |replacement#0@@0|)))
 :qid |PivotBetreebrokenidfy.505:14|
 :skolemid |2155|
 :pattern ( (PivotBetree.Path.ReplacedChildren (AsFuelBottom $ly@@18) this@@158 |replacement#0@@0|))
)))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@19 T@U) (this@@159 T@U) (|replacement#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@19) LayerTypeType) (= (type this@@159) DatatypeTypeType)) (= (type |replacement#0@@1|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| this@@159 |replacement#0@@1|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@159 Tclass.PivotBetree.Path) ($Is |replacement#0@@1| Tclass.PivotBetree.BetreeNode)) (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@159) (PivotBetree.Path.ValidReplacement this@@159 |replacement#0@@1|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@159))))))) (and (PivotBetree.Path.ChildrenHaveMatchingDomains this@@159 (PivotBetree.Path.ReplacedChildren $ly@@19 this@@159 |replacement#0@@1|)) ($Is (PivotBetree.Path.ReplacedChildren $ly@@19 this@@159 |replacement#0@@1|) (TSeq Tclass.PivotBetree.BetreeNode))))
 :qid |PivotBetreebrokenidfy.505:14|
 :skolemid |2156|
 :pattern ( (PivotBetree.Path.ReplacedChildren $ly@@19 this@@159 |replacement#0@@1|))
))))
(assert (forall (($ly@@20 T@U) (this@@160 T@U) (|replacement#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@20) LayerTypeType) (= (type this@@160) DatatypeTypeType)) (= (type |replacement#0@@2|) DatatypeTypeType)) (and ($Is this@@160 Tclass.PivotBetree.Path) ($Is |replacement#0@@2| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.ReplacedChildren#requires| $ly@@20 this@@160 |replacement#0@@2|)  (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@160) (PivotBetree.Path.ValidReplacement this@@160 |replacement#0@@2|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@160)))))
 :qid |PivotBetreebrokenidfy.505:14|
 :skolemid |2157|
 :pattern ( (|PivotBetree.Path.ReplacedChildren#requires| $ly@@20 this@@160 |replacement#0@@2|))
)))
(assert (forall ((arg0@@430 T@U) (arg1@@173 T@U) (arg2@@86 T@U) ) (! (= (type (PivotBetree.Path.Substitute arg0@@430 arg1@@173 arg2@@86)) DatatypeTypeType)
 :qid |funType:PivotBetree.Path.Substitute|
 :pattern ( (PivotBetree.Path.Substitute arg0@@430 arg1@@173 arg2@@86))
)))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@21 T@U) (this@@161 T@U) (|replacement#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@21) LayerTypeType) (= (type this@@161) DatatypeTypeType)) (= (type |replacement#0@@3|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| this@@161 |replacement#0@@3|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@161 Tclass.PivotBetree.Path) ($Is |replacement#0@@3| Tclass.PivotBetree.BetreeNode)) (and (and (PivotBetree.Path.Valid ($LS $LZ) this@@161) (PivotBetree.Path.ValidReplacement this@@161 |replacement#0@@3|)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@161))))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| this@@161) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Path.Subpath this@@161) |replacement#0@@3|)) (and (PivotBetree.Path.Path_q this@@161) (and (and (PivotBetree.Path.Path_q this@@161) (PivotBetree.Path.Path_q this@@161)) (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@161)) (PivotBetree.Path.key this@@161))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@21) this@@161 |replacement#0@@3|) (let ((|newChild#0@@0| (PivotBetree.Path.Substitute $ly@@21 (PivotBetree.Path.Subpath this@@161) |replacement#0@@3|)))
(|Seq#Update| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@161)) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@161)) (PivotBetree.Path.key this@@161)) ($Box |newChild#0@@0|))))))
 :qid |PivotBetreebrokenidfy.505:14|
 :skolemid |2158|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@21) this@@161 |replacement#0@@3|))
))))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@22 T@U) (this@@162 T@U) (|replacement#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@22) LayerTypeType) (= (type this@@162) DatatypeTypeType)) (= (type |replacement#0@@4|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@162) |replacement#0@@4|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@162 Tclass.PivotBetree.Path) ($Is |replacement#0@@4| Tclass.PivotBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@162))))) (PivotBetree.Path.ValidReplacement (Lit this@@162) |replacement#0@@4|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@162))))))))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@162)) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@162))) |replacement#0@@4|)) (and (PivotBetree.Path.Path_q (Lit this@@162)) (and (and (PivotBetree.Path.Path_q (Lit this@@162)) (PivotBetree.Path.Path_q (Lit this@@162))) (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@162))))) (Lit (PivotBetree.Path.key (Lit this@@162))))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@22) (Lit this@@162) |replacement#0@@4|) (let ((|newChild#1@@0| (PivotBetree.Path.Substitute ($LS $ly@@22) (Lit (PivotBetree.Path.Subpath (Lit this@@162))) |replacement#0@@4|)))
(|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@162))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@162))))) (Lit (PivotBetree.Path.key (Lit this@@162))))) ($Box |newChild#1@@0|))))))
 :qid |PivotBetreebrokenidfy.505:14|
 :weight 3
 :skolemid |2159|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@22) (Lit this@@162) |replacement#0@@4|))
))))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@23 T@U) (this@@163 T@U) (|replacement#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@23) LayerTypeType) (= (type this@@163) DatatypeTypeType)) (= (type |replacement#0@@5|) DatatypeTypeType)) (or (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@163) (Lit |replacement#0@@5|)) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@163 Tclass.PivotBetree.Path) ($Is |replacement#0@@5| Tclass.PivotBetree.BetreeNode)) (and (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@163))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.ValidReplacement (Lit this@@163) (Lit |replacement#0@@5|)))))) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (Lit this@@163))))))))))) (and (and (and (|PivotBetree.Path.Subpath#canCall| (Lit this@@163)) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Path.Subpath (Lit this@@163))) (Lit |replacement#0@@5|))) (and (PivotBetree.Path.Path_q (Lit this@@163)) (and (and (PivotBetree.Path.Path_q (Lit this@@163)) (PivotBetree.Path.Path_q (Lit this@@163))) (|BoundedPivotsLib.__default.Route#canCall| (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@163))))) (Lit (PivotBetree.Path.key (Lit this@@163))))))) (= (PivotBetree.Path.ReplacedChildren ($LS $ly@@23) (Lit this@@163) (Lit |replacement#0@@5|)) (let ((|newChild#2| (Lit (PivotBetree.Path.Substitute ($LS $ly@@23) (Lit (PivotBetree.Path.Subpath (Lit this@@163))) (Lit |replacement#0@@5|)))))
(|Seq#Update| (Lit (PivotBetree.BetreeNode.children (Lit (PivotBetree.Path.node (Lit this@@163))))) (LitInt (BoundedPivotsLib.__default.Route (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@163))))) (Lit (PivotBetree.Path.key (Lit this@@163))))) ($Box |newChild#2|))))))
 :qid |PivotBetreebrokenidfy.505:14|
 :weight 3
 :skolemid |2160|
 :pattern ( (PivotBetree.Path.ReplacedChildren ($LS $ly@@23) (Lit this@@163) (Lit |replacement#0@@5|)))
))))
(assert  (=> (<= 61 $FunctionContextHeight) (forall ((this@@164 T@U) (|replacement#0@@6| T@U) ) (!  (=> (and (and (= (type this@@164) DatatypeTypeType) (= (type |replacement#0@@6|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| this@@164 |replacement#0@@6|) (and (not (= 61 $FunctionContextHeight)) (and (and ($Is this@@164 Tclass.PivotBetree.Path) ($Is |replacement#0@@6| Tclass.PivotBetree.BetreeNode)) (PivotBetree.Path.Valid ($LS $LZ) this@@164))))) true)
 :qid |PivotBetreebrokenidfy.519:15|
 :skolemid |2233|
 :pattern ( (PivotBetree.Path.ValidReplacement this@@164 |replacement#0@@6|))
))))
(assert (forall ((this@@165 T@U) (|replacement#0@@7| T@U) ) (!  (=> (and (and (= (type this@@165) DatatypeTypeType) (= (type |replacement#0@@7|) DatatypeTypeType)) (and ($Is this@@165 Tclass.PivotBetree.Path) ($Is |replacement#0@@7| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.ValidReplacement#requires| this@@165 |replacement#0@@7|) (PivotBetree.Path.Valid ($LS $LZ) this@@165)))
 :qid |PivotBetreebrokenidfy.519:15|
 :skolemid |2234|
 :pattern ( (|PivotBetree.Path.ValidReplacement#requires| this@@165 |replacement#0@@7|))
)))
(assert  (=> (<= 61 $FunctionContextHeight) (forall ((this@@166 T@U) (|replacement#0@@8| T@U) ) (!  (=> (and (and (= (type this@@166) DatatypeTypeType) (= (type |replacement#0@@8|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| this@@166 |replacement#0@@8|) (and (not (= 61 $FunctionContextHeight)) (and (and ($Is this@@166 Tclass.PivotBetree.Path) ($Is |replacement#0@@8| Tclass.PivotBetree.BetreeNode)) (PivotBetree.Path.Valid ($LS $LZ) this@@166))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@8|) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@8|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@8|) (and (and (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain |replacement#0@@8|)) (|$IsA#DomainMod.Domain| (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS $LZ) this@@166)))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| |replacement#0@@8|) (and (|PivotBetree.Path.Target#canCall| this@@166) (|PivotBetree.BetreeNode.MyDomain#canCall| (PivotBetree.Path.Target ($LS $LZ) this@@166)))))))) (= (PivotBetree.Path.ValidReplacement this@@166 |replacement#0@@8|)  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@8|) (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@8|)) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |replacement#0@@8|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS $LZ) this@@166)))))))
 :qid |PivotBetreebrokenidfy.519:15|
 :skolemid |2235|
 :pattern ( (PivotBetree.Path.ValidReplacement this@@166 |replacement#0@@8|))
))))
(assert  (=> (<= 61 $FunctionContextHeight) (forall ((this@@167 T@U) (|replacement#0@@9| T@U) ) (!  (=> (and (and (= (type this@@167) DatatypeTypeType) (= (type |replacement#0@@9|) DatatypeTypeType)) (or (|PivotBetree.Path.ValidReplacement#canCall| (Lit this@@167) (Lit |replacement#0@@9|)) (and (not (= 61 $FunctionContextHeight)) (and (and ($Is this@@167 Tclass.PivotBetree.Path) ($Is |replacement#0@@9| Tclass.PivotBetree.BetreeNode)) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@167))))))))) (and (and (|PivotBetree.BetreeNode.WF#canCall| (Lit |replacement#0@@9|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@9|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |replacement#0@@9|))))) (and (and (|$IsA#DomainMod.Domain| (Lit (PivotBetree.BetreeNode.MyDomain (Lit |replacement#0@@9|)))) (|$IsA#DomainMod.Domain| (Lit (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@167))))))) (and (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit |replacement#0@@9|)) (and (|PivotBetree.Path.Target#canCall| (Lit this@@167)) (|PivotBetree.BetreeNode.MyDomain#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@167)))))))))) (= (PivotBetree.Path.ValidReplacement (Lit this@@167) (Lit |replacement#0@@9|))  (and (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |replacement#0@@9|)) (PivotBetree.BetreeNode.BetreeNode_q (Lit |replacement#0@@9|))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain (Lit |replacement#0@@9|)) (PivotBetree.BetreeNode.MyDomain (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit this@@167)))))))))
 :qid |PivotBetreebrokenidfy.519:15|
 :weight 3
 :skolemid |2236|
 :pattern ( (PivotBetree.Path.ValidReplacement (Lit this@@167) (Lit |replacement#0@@9|)))
))))
(assert (forall (($ly@@24 T@U) (this@@168 T@U) (|replacement#0@@10| T@U) ) (!  (=> (and (and (= (type $ly@@24) LayerTypeType) (= (type this@@168) DatatypeTypeType)) (= (type |replacement#0@@10|) DatatypeTypeType)) (= (PivotBetree.Path.Substitute ($LS $ly@@24) this@@168 |replacement#0@@10|) (PivotBetree.Path.Substitute $ly@@24 this@@168 |replacement#0@@10|)))
 :qid |PivotBetreebrokenidfy.527:14|
 :skolemid |2266|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@24) this@@168 |replacement#0@@10|))
)))
(assert (forall (($ly@@25 T@U) (this@@169 T@U) (|replacement#0@@11| T@U) ) (!  (=> (and (and (= (type $ly@@25) LayerTypeType) (= (type this@@169) DatatypeTypeType)) (= (type |replacement#0@@11|) DatatypeTypeType)) (= (PivotBetree.Path.Substitute $ly@@25 this@@169 |replacement#0@@11|) (PivotBetree.Path.Substitute $LZ this@@169 |replacement#0@@11|)))
 :qid |PivotBetreebrokenidfy.527:14|
 :skolemid |2267|
 :pattern ( (PivotBetree.Path.Substitute (AsFuelBottom $ly@@25) this@@169 |replacement#0@@11|))
)))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@26 T@U) (this@@170 T@U) (|replacement#0@@12| T@U) ) (!  (=> (and (and (and (= (type $ly@@26) LayerTypeType) (= (type this@@170) DatatypeTypeType)) (= (type |replacement#0@@12|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| this@@170 |replacement#0@@12|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@170 Tclass.PivotBetree.Path) ($Is |replacement#0@@12| Tclass.PivotBetree.BetreeNode)) (and (PivotBetree.Path.Valid ($LS $LZ) this@@170) (PivotBetree.Path.ValidReplacement this@@170 |replacement#0@@12|)))))) ($Is (PivotBetree.Path.Substitute $ly@@26 this@@170 |replacement#0@@12|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreebrokenidfy.527:14|
 :skolemid |2268|
 :pattern ( (PivotBetree.Path.Substitute $ly@@26 this@@170 |replacement#0@@12|))
))))
(assert (forall (($ly@@27 T@U) (this@@171 T@U) (|replacement#0@@13| T@U) ) (!  (=> (and (and (and (= (type $ly@@27) LayerTypeType) (= (type this@@171) DatatypeTypeType)) (= (type |replacement#0@@13|) DatatypeTypeType)) (and ($Is this@@171 Tclass.PivotBetree.Path) ($Is |replacement#0@@13| Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.Path.Substitute#requires| $ly@@27 this@@171 |replacement#0@@13|)  (and (PivotBetree.Path.Valid ($LS $LZ) this@@171) (PivotBetree.Path.ValidReplacement this@@171 |replacement#0@@13|))))
 :qid |PivotBetreebrokenidfy.527:14|
 :skolemid |2269|
 :pattern ( (|PivotBetree.Path.Substitute#requires| $ly@@27 this@@171 |replacement#0@@13|))
)))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@28 T@U) (this@@172 T@U) (|replacement#0@@14| T@U) ) (!  (=> (and (and (and (= (type $ly@@28) LayerTypeType) (= (type this@@172) DatatypeTypeType)) (= (type |replacement#0@@14|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| this@@172 |replacement#0@@14|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@172 Tclass.PivotBetree.Path) ($Is |replacement#0@@14| Tclass.PivotBetree.BetreeNode)) (and (PivotBetree.Path.Valid ($LS $LZ) this@@172) (PivotBetree.Path.ValidReplacement this@@172 |replacement#0@@14|)))))) (and (and (PivotBetree.Path.Path_q this@@172) (=> (not (= (LitInt 0) (PivotBetree.Path.depth this@@172))) (and (and (PivotBetree.Path.Path_q this@@172) (PivotBetree.Path.Path_q this@@172)) (|PivotBetree.Path.ReplacedChildren#canCall| this@@172 |replacement#0@@14|)))) (= (PivotBetree.Path.Substitute ($LS $ly@@28) this@@172 |replacement#0@@14|) (ite (= (LitInt 0) (PivotBetree.Path.depth this@@172)) |replacement#0@@14| (|#PivotBetree.BetreeNode.BetreeNode| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.node this@@172)) (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@172)) (PivotBetree.Path.ReplacedChildren $ly@@28 this@@172 |replacement#0@@14|))))))
 :qid |PivotBetreebrokenidfy.527:14|
 :skolemid |2270|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@28) this@@172 |replacement#0@@14|))
))))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@29 T@U) (this@@173 T@U) (|replacement#0@@15| T@U) ) (!  (=> (and (and (and (= (type $ly@@29) LayerTypeType) (= (type this@@173) DatatypeTypeType)) (= (type |replacement#0@@15|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| (Lit this@@173) |replacement#0@@15|) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@173 Tclass.PivotBetree.Path) ($Is |replacement#0@@15| Tclass.PivotBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@173))))) (PivotBetree.Path.ValidReplacement (Lit this@@173) |replacement#0@@15|)))))) (and (and (PivotBetree.Path.Path_q (Lit this@@173)) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@173))))) (and (and (PivotBetree.Path.Path_q (Lit this@@173)) (PivotBetree.Path.Path_q (Lit this@@173))) (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@173) |replacement#0@@15|)))) (= (PivotBetree.Path.Substitute ($LS $ly@@29) (Lit this@@173) |replacement#0@@15|) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@173)))) |replacement#0@@15| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.node (Lit this@@173))))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@173))))) (PivotBetree.Path.ReplacedChildren ($LS $ly@@29) (Lit this@@173) |replacement#0@@15|))))))
 :qid |PivotBetreebrokenidfy.527:14|
 :weight 3
 :skolemid |2271|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@29) (Lit this@@173) |replacement#0@@15|))
))))
(assert  (=> (<= 62 $FunctionContextHeight) (forall (($ly@@30 T@U) (this@@174 T@U) (|replacement#0@@16| T@U) ) (!  (=> (and (and (and (= (type $ly@@30) LayerTypeType) (= (type this@@174) DatatypeTypeType)) (= (type |replacement#0@@16|) DatatypeTypeType)) (or (|PivotBetree.Path.Substitute#canCall| (Lit this@@174) (Lit |replacement#0@@16|)) (and (not (= 62 $FunctionContextHeight)) (and (and ($Is this@@174 Tclass.PivotBetree.Path) ($Is |replacement#0@@16| Tclass.PivotBetree.BetreeNode)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit this@@174))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Path.ValidReplacement (Lit this@@174) (Lit |replacement#0@@16|)))))))))) (and (and (PivotBetree.Path.Path_q (Lit this@@174)) (=> (not (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@174))))) (and (and (PivotBetree.Path.Path_q (Lit this@@174)) (PivotBetree.Path.Path_q (Lit this@@174))) (|PivotBetree.Path.ReplacedChildren#canCall| (Lit this@@174) (Lit |replacement#0@@16|))))) (= (PivotBetree.Path.Substitute ($LS $ly@@30) (Lit this@@174) (Lit |replacement#0@@16|)) (ite (= (LitInt 0) (LitInt (PivotBetree.Path.depth (Lit this@@174)))) |replacement#0@@16| (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.node (Lit this@@174))))) (Lit (PivotBetree.BetreeNode.pivotTable (Lit (PivotBetree.Path.node (Lit this@@174))))) (Lit (PivotBetree.Path.ReplacedChildren ($LS $ly@@30) (Lit this@@174) (Lit |replacement#0@@16|))))))))
 :qid |PivotBetreebrokenidfy.527:14|
 :weight 3
 :skolemid |2272|
 :pattern ( (PivotBetree.Path.Substitute ($LS $ly@@30) (Lit this@@174) (Lit |replacement#0@@16|)))
))))
(assert (forall ((arg0@@431 T@U) ) (! (= (type (|#PivotBetree.Step.QueryStep| arg0@@431)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.QueryStep|
 :pattern ( (|#PivotBetree.Step.QueryStep| arg0@@431))
)))
(assert (forall ((|a#0#0#0@@4| T@U) ) (!  (=> (= (type |a#0#0#0@@4|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.Step.QueryStep| |a#0#0#0@@4|)) |##PivotBetree.Step.QueryStep|))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2310|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#0#0#0@@4|))
)))
(assert (forall ((d@@69 T@U) ) (!  (=> (= (type d@@69) DatatypeTypeType) (= (PivotBetree.Step.QueryStep_q d@@69) (= (DatatypeCtorId d@@69) |##PivotBetree.Step.QueryStep|)))
 :qid |unknown.0:0|
 :skolemid |2311|
 :pattern ( (PivotBetree.Step.QueryStep_q d@@69))
)))
(assert (forall ((d@@70 T@U) ) (!  (=> (and (= (type d@@70) DatatypeTypeType) (PivotBetree.Step.QueryStep_q d@@70)) (exists ((|a#1#0#0@@4| T@U) ) (!  (and (= (type |a#1#0#0@@4|) DatatypeTypeType) (= d@@70 (|#PivotBetree.Step.QueryStep| |a#1#0#0@@4|)))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2312|
 :no-pattern (type |a#1#0#0@@4|)
 :no-pattern (U_2_int |a#1#0#0@@4|)
 :no-pattern (U_2_bool |a#1#0#0@@4|)
)))
 :qid |unknown.0:0|
 :skolemid |2313|
 :pattern ( (PivotBetree.Step.QueryStep_q d@@70))
)))
(assert (= (type Tclass.PivotBetree.Step) TyType))
(assert (= (Tag Tclass.PivotBetree.Step) Tagclass.PivotBetree.Step))
(assert (= (TagFamily Tclass.PivotBetree.Step) tytagFamily$Step))
(assert (forall ((bx@@123 T@U) ) (!  (=> (and (= (type bx@@123) BoxType) ($IsBox bx@@123 Tclass.PivotBetree.Step)) (and (= ($Box ($Unbox DatatypeTypeType bx@@123)) bx@@123) ($Is ($Unbox DatatypeTypeType bx@@123) Tclass.PivotBetree.Step)))
 :qid |unknown.0:0|
 :skolemid |2314|
 :pattern ( ($IsBox bx@@123 Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#2#0#0@@4| T@U) ) (!  (=> (= (type |a#2#0#0@@4|) DatatypeTypeType) (= ($Is (|#PivotBetree.Step.QueryStep| |a#2#0#0@@4|) Tclass.PivotBetree.Step) ($Is |a#2#0#0@@4| Tclass.PivotBetree.QueryReceipt)))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2315|
 :pattern ( ($Is (|#PivotBetree.Step.QueryStep| |a#2#0#0@@4|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#3#0#0@@4| T@U) ($h@@79 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@4|) DatatypeTypeType) (= (type $h@@79) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@79)) (= ($IsAlloc (|#PivotBetree.Step.QueryStep| |a#3#0#0@@4|) Tclass.PivotBetree.Step $h@@79) ($IsAlloc |a#3#0#0@@4| Tclass.PivotBetree.QueryReceipt $h@@79)))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2316|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.QueryStep| |a#3#0#0@@4|) Tclass.PivotBetree.Step $h@@79))
)))
(assert (forall ((arg0@@432 T@U) ) (! (= (type (PivotBetree.Step.receipt arg0@@432)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.receipt|
 :pattern ( (PivotBetree.Step.receipt arg0@@432))
)))
(assert (forall ((d@@71 T@U) ($h@@80 T@U) ) (!  (=> (and (and (= (type d@@71) DatatypeTypeType) (= (type $h@@80) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@80) (and (PivotBetree.Step.QueryStep_q d@@71) ($IsAlloc d@@71 Tclass.PivotBetree.Step $h@@80)))) ($IsAlloc (PivotBetree.Step.receipt d@@71) Tclass.PivotBetree.QueryReceipt $h@@80))
 :qid |unknown.0:0|
 :skolemid |2317|
 :pattern ( ($IsAlloc (PivotBetree.Step.receipt d@@71) Tclass.PivotBetree.QueryReceipt $h@@80))
)))
(assert (forall ((|a#4#0#0@@4| T@U) ) (!  (=> (= (type |a#4#0#0@@4|) DatatypeTypeType) (= (|#PivotBetree.Step.QueryStep| (Lit |a#4#0#0@@4|)) (Lit (|#PivotBetree.Step.QueryStep| |a#4#0#0@@4|))))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2318|
 :pattern ( (|#PivotBetree.Step.QueryStep| (Lit |a#4#0#0@@4|)))
)))
(assert (forall ((|a#5#0#0@@4| T@U) ) (!  (=> (= (type |a#5#0#0@@4|) DatatypeTypeType) (= (PivotBetree.Step.receipt (|#PivotBetree.Step.QueryStep| |a#5#0#0@@4|)) |a#5#0#0@@4|))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2319|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#5#0#0@@4|))
)))
(assert (forall ((|a#6#0#0@@4| T@U) ) (!  (=> (= (type |a#6#0#0@@4|) DatatypeTypeType) (< (DtRank |a#6#0#0@@4|) (DtRank (|#PivotBetree.Step.QueryStep| |a#6#0#0@@4|))))
 :qid |PivotBetreebrokenidfy.604:17|
 :skolemid |2320|
 :pattern ( (|#PivotBetree.Step.QueryStep| |a#6#0#0@@4|))
)))
(assert (= (type |#PivotBetree.Step.PutStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.PutStep|) |##PivotBetree.Step.PutStep|))
(assert (forall ((d@@72 T@U) ) (!  (=> (= (type d@@72) DatatypeTypeType) (= (PivotBetree.Step.PutStep_q d@@72) (= (DatatypeCtorId d@@72) |##PivotBetree.Step.PutStep|)))
 :qid |unknown.0:0|
 :skolemid |2321|
 :pattern ( (PivotBetree.Step.PutStep_q d@@72))
)))
(assert (forall ((d@@73 T@U) ) (!  (=> (and (= (type d@@73) DatatypeTypeType) (PivotBetree.Step.PutStep_q d@@73)) (= d@@73 |#PivotBetree.Step.PutStep|))
 :qid |unknown.0:0|
 :skolemid |2322|
 :pattern ( (PivotBetree.Step.PutStep_q d@@73))
)))
(assert ($Is |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@81 T@U) ) (!  (=> (and (= (type $h@@81) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@81)) ($IsAlloc |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step $h@@81))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2323|
 :pattern ( ($IsAlloc |#PivotBetree.Step.PutStep| Tclass.PivotBetree.Step $h@@81))
)))
(assert (= |#PivotBetree.Step.PutStep| (Lit |#PivotBetree.Step.PutStep|)))
(assert (= (type |#PivotBetree.Step.QueryEndLsnStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.QueryEndLsnStep|) |##PivotBetree.Step.QueryEndLsnStep|))
(assert (forall ((d@@74 T@U) ) (!  (=> (= (type d@@74) DatatypeTypeType) (= (PivotBetree.Step.QueryEndLsnStep_q d@@74) (= (DatatypeCtorId d@@74) |##PivotBetree.Step.QueryEndLsnStep|)))
 :qid |unknown.0:0|
 :skolemid |2324|
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@74))
)))
(assert (forall ((d@@75 T@U) ) (!  (=> (and (= (type d@@75) DatatypeTypeType) (PivotBetree.Step.QueryEndLsnStep_q d@@75)) (= d@@75 |#PivotBetree.Step.QueryEndLsnStep|))
 :qid |unknown.0:0|
 :skolemid |2325|
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@75))
)))
(assert ($Is |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@82 T@U) ) (!  (=> (and (= (type $h@@82) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@82)) ($IsAlloc |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step $h@@82))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2326|
 :pattern ( ($IsAlloc |#PivotBetree.Step.QueryEndLsnStep| Tclass.PivotBetree.Step $h@@82))
)))
(assert (= |#PivotBetree.Step.QueryEndLsnStep| (Lit |#PivotBetree.Step.QueryEndLsnStep|)))
(assert (= (type |#PivotBetree.Step.FreezeAsStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.FreezeAsStep|) |##PivotBetree.Step.FreezeAsStep|))
(assert (forall ((d@@76 T@U) ) (!  (=> (= (type d@@76) DatatypeTypeType) (= (PivotBetree.Step.FreezeAsStep_q d@@76) (= (DatatypeCtorId d@@76) |##PivotBetree.Step.FreezeAsStep|)))
 :qid |unknown.0:0|
 :skolemid |2327|
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@76))
)))
(assert (forall ((d@@77 T@U) ) (!  (=> (and (= (type d@@77) DatatypeTypeType) (PivotBetree.Step.FreezeAsStep_q d@@77)) (= d@@77 |#PivotBetree.Step.FreezeAsStep|))
 :qid |unknown.0:0|
 :skolemid |2328|
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@77))
)))
(assert ($Is |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@83 T@U) ) (!  (=> (and (= (type $h@@83) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@83)) ($IsAlloc |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step $h@@83))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2329|
 :pattern ( ($IsAlloc |#PivotBetree.Step.FreezeAsStep| Tclass.PivotBetree.Step $h@@83))
)))
(assert (= |#PivotBetree.Step.FreezeAsStep| (Lit |#PivotBetree.Step.FreezeAsStep|)))
(assert (= (type |#PivotBetree.Step.InternalGrowStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalGrowStep|) |##PivotBetree.Step.InternalGrowStep|))
(assert (forall ((d@@78 T@U) ) (!  (=> (= (type d@@78) DatatypeTypeType) (= (PivotBetree.Step.InternalGrowStep_q d@@78) (= (DatatypeCtorId d@@78) |##PivotBetree.Step.InternalGrowStep|)))
 :qid |unknown.0:0|
 :skolemid |2330|
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@78))
)))
(assert (forall ((d@@79 T@U) ) (!  (=> (and (= (type d@@79) DatatypeTypeType) (PivotBetree.Step.InternalGrowStep_q d@@79)) (= d@@79 |#PivotBetree.Step.InternalGrowStep|))
 :qid |unknown.0:0|
 :skolemid |2331|
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@79))
)))
(assert ($Is |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@84 T@U) ) (!  (=> (and (= (type $h@@84) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@84)) ($IsAlloc |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step $h@@84))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2332|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalGrowStep| Tclass.PivotBetree.Step $h@@84))
)))
(assert (= |#PivotBetree.Step.InternalGrowStep| (Lit |#PivotBetree.Step.InternalGrowStep|)))
(assert (forall ((arg0@@433 T@U) (arg1@@174 T@U) ) (! (= (type (|#PivotBetree.Step.InternalSplitStep| arg0@@433 arg1@@174)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalSplitStep|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| arg0@@433 arg1@@174))
)))
(assert (forall ((|a#27#0#0@@0| T@U) (|a#27#1#0@@0| T@U) ) (!  (=> (and (= (type |a#27#0#0@@0|) DatatypeTypeType) (= (type |a#27#1#0@@0|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Step.InternalSplitStep| |a#27#0#0@@0| |a#27#1#0@@0|)) |##PivotBetree.Step.InternalSplitStep|))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2333|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#27#0#0@@0| |a#27#1#0@@0|))
)))
(assert (forall ((d@@80 T@U) ) (!  (=> (= (type d@@80) DatatypeTypeType) (= (PivotBetree.Step.InternalSplitStep_q d@@80) (= (DatatypeCtorId d@@80) |##PivotBetree.Step.InternalSplitStep|)))
 :qid |unknown.0:0|
 :skolemid |2334|
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@80))
)))
(assert (forall ((d@@81 T@U) ) (!  (=> (and (= (type d@@81) DatatypeTypeType) (PivotBetree.Step.InternalSplitStep_q d@@81)) (exists ((|a#28#0#0@@0| T@U) (|a#28#1#0@@0| T@U) ) (!  (and (and (= (type |a#28#0#0@@0|) DatatypeTypeType) (= (type |a#28#1#0@@0|) DatatypeTypeType)) (= d@@81 (|#PivotBetree.Step.InternalSplitStep| |a#28#0#0@@0| |a#28#1#0@@0|)))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2335|
 :no-pattern (type |a#28#0#0@@0|)
 :no-pattern (type |a#28#1#0@@0|)
 :no-pattern (U_2_int |a#28#0#0@@0|)
 :no-pattern (U_2_bool |a#28#0#0@@0|)
 :no-pattern (U_2_int |a#28#1#0@@0|)
 :no-pattern (U_2_bool |a#28#1#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |2336|
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@81))
)))
(assert (forall ((|a#29#0#0@@0| T@U) (|a#29#1#0@@0| T@U) ) (!  (=> (and (= (type |a#29#0#0@@0|) DatatypeTypeType) (= (type |a#29#1#0@@0|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Step.InternalSplitStep| |a#29#0#0@@0| |a#29#1#0@@0|) Tclass.PivotBetree.Step)  (and ($Is |a#29#0#0@@0| Tclass.PivotBetree.Path) ($Is |a#29#1#0@@0| Tclass.SplitRequestMod.SplitRequest))))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2337|
 :pattern ( ($Is (|#PivotBetree.Step.InternalSplitStep| |a#29#0#0@@0| |a#29#1#0@@0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#30#0#0@@0| T@U) (|a#30#1#0@@0| T@U) ($h@@85 T@U) ) (!  (=> (and (and (and (= (type |a#30#0#0@@0|) DatatypeTypeType) (= (type |a#30#1#0@@0|) DatatypeTypeType)) (= (type $h@@85) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@85)) (= ($IsAlloc (|#PivotBetree.Step.InternalSplitStep| |a#30#0#0@@0| |a#30#1#0@@0|) Tclass.PivotBetree.Step $h@@85)  (and ($IsAlloc |a#30#0#0@@0| Tclass.PivotBetree.Path $h@@85) ($IsAlloc |a#30#1#0@@0| Tclass.SplitRequestMod.SplitRequest $h@@85))))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2338|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalSplitStep| |a#30#0#0@@0| |a#30#1#0@@0|) Tclass.PivotBetree.Step $h@@85))
)))
(assert (forall ((arg0@@434 T@U) ) (! (= (type (PivotBetree.Step.path arg0@@434)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.path|
 :pattern ( (PivotBetree.Step.path arg0@@434))
)))
(assert (forall ((d@@82 T@U) ($h@@86 T@U) ) (!  (=> (and (and (= (type d@@82) DatatypeTypeType) (= (type $h@@86) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@86) (and (PivotBetree.Step.InternalSplitStep_q d@@82) ($IsAlloc d@@82 Tclass.PivotBetree.Step $h@@86)))) ($IsAlloc (PivotBetree.Step.path d@@82) Tclass.PivotBetree.Path $h@@86))
 :qid |unknown.0:0|
 :skolemid |2339|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@82) Tclass.PivotBetree.Path $h@@86))
)))
(assert (forall ((arg0@@435 T@U) ) (! (= (type (PivotBetree.Step.request arg0@@435)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.request|
 :pattern ( (PivotBetree.Step.request arg0@@435))
)))
(assert (forall ((d@@83 T@U) ($h@@87 T@U) ) (!  (=> (and (and (= (type d@@83) DatatypeTypeType) (= (type $h@@87) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@87) (and (PivotBetree.Step.InternalSplitStep_q d@@83) ($IsAlloc d@@83 Tclass.PivotBetree.Step $h@@87)))) ($IsAlloc (PivotBetree.Step.request d@@83) Tclass.SplitRequestMod.SplitRequest $h@@87))
 :qid |unknown.0:0|
 :skolemid |2340|
 :pattern ( ($IsAlloc (PivotBetree.Step.request d@@83) Tclass.SplitRequestMod.SplitRequest $h@@87))
)))
(assert (forall ((|a#31#0#0@@0| T@U) (|a#31#1#0| T@U) ) (!  (=> (and (= (type |a#31#0#0@@0|) DatatypeTypeType) (= (type |a#31#1#0|) DatatypeTypeType)) (= (|#PivotBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@0|) (Lit |a#31#1#0|)) (Lit (|#PivotBetree.Step.InternalSplitStep| |a#31#0#0@@0| |a#31#1#0|))))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2341|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| (Lit |a#31#0#0@@0|) (Lit |a#31#1#0|)))
)))
(assert (forall ((|a#32#0#0@@0| T@U) (|a#32#1#0| T@U) ) (!  (=> (and (= (type |a#32#0#0@@0|) DatatypeTypeType) (= (type |a#32#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalSplitStep| |a#32#0#0@@0| |a#32#1#0|)) |a#32#0#0@@0|))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2342|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#32#0#0@@0| |a#32#1#0|))
)))
(assert (forall ((|a#33#0#0@@0| T@U) (|a#33#1#0| T@U) ) (!  (=> (and (= (type |a#33#0#0@@0|) DatatypeTypeType) (= (type |a#33#1#0|) DatatypeTypeType)) (< (DtRank |a#33#0#0@@0|) (DtRank (|#PivotBetree.Step.InternalSplitStep| |a#33#0#0@@0| |a#33#1#0|))))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2343|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#33#0#0@@0| |a#33#1#0|))
)))
(assert (forall ((|a#34#0#0@@0| T@U) (|a#34#1#0| T@U) ) (!  (=> (and (= (type |a#34#0#0@@0|) DatatypeTypeType) (= (type |a#34#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.request (|#PivotBetree.Step.InternalSplitStep| |a#34#0#0@@0| |a#34#1#0|)) |a#34#1#0|))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2344|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#34#0#0@@0| |a#34#1#0|))
)))
(assert (forall ((|a#35#0#0@@0| T@U) (|a#35#1#0| T@U) ) (!  (=> (and (= (type |a#35#0#0@@0|) DatatypeTypeType) (= (type |a#35#1#0|) DatatypeTypeType)) (< (DtRank |a#35#1#0|) (DtRank (|#PivotBetree.Step.InternalSplitStep| |a#35#0#0@@0| |a#35#1#0|))))
 :qid |PivotBetreebrokenidfy.609:25|
 :skolemid |2345|
 :pattern ( (|#PivotBetree.Step.InternalSplitStep| |a#35#0#0@@0| |a#35#1#0|))
)))
(assert (= (type |#PivotBetree.Step.InternalFlushMemtableStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalFlushMemtableStep|) |##PivotBetree.Step.InternalFlushMemtableStep|))
(assert (forall ((d@@84 T@U) ) (!  (=> (= (type d@@84) DatatypeTypeType) (= (PivotBetree.Step.InternalFlushMemtableStep_q d@@84) (= (DatatypeCtorId d@@84) |##PivotBetree.Step.InternalFlushMemtableStep|)))
 :qid |unknown.0:0|
 :skolemid |2346|
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@84))
)))
(assert (forall ((d@@85 T@U) ) (!  (=> (and (= (type d@@85) DatatypeTypeType) (PivotBetree.Step.InternalFlushMemtableStep_q d@@85)) (= d@@85 |#PivotBetree.Step.InternalFlushMemtableStep|))
 :qid |unknown.0:0|
 :skolemid |2347|
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@85))
)))
(assert ($Is |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@88 T@U) ) (!  (=> (and (= (type $h@@88) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@88)) ($IsAlloc |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step $h@@88))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2348|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalFlushMemtableStep| Tclass.PivotBetree.Step $h@@88))
)))
(assert (= |#PivotBetree.Step.InternalFlushMemtableStep| (Lit |#PivotBetree.Step.InternalFlushMemtableStep|)))
(assert (forall ((arg0@@436 T@U) (arg1@@175 Int) ) (! (= (type (|#PivotBetree.Step.InternalFlushStep| arg0@@436 arg1@@175)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalFlushStep|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| arg0@@436 arg1@@175))
)))
(assert (forall ((|a#41#0#0@@0| T@U) (|a#41#1#0| Int) ) (!  (=> (= (type |a#41#0#0@@0|) DatatypeTypeType) (= (DatatypeCtorId (|#PivotBetree.Step.InternalFlushStep| |a#41#0#0@@0| |a#41#1#0|)) |##PivotBetree.Step.InternalFlushStep|))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2349|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#41#0#0@@0| |a#41#1#0|))
)))
(assert (forall ((d@@86 T@U) ) (!  (=> (= (type d@@86) DatatypeTypeType) (= (PivotBetree.Step.InternalFlushStep_q d@@86) (= (DatatypeCtorId d@@86) |##PivotBetree.Step.InternalFlushStep|)))
 :qid |unknown.0:0|
 :skolemid |2350|
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@86))
)))
(assert (forall ((d@@87 T@U) ) (!  (=> (and (= (type d@@87) DatatypeTypeType) (PivotBetree.Step.InternalFlushStep_q d@@87)) (exists ((|a#42#0#0@@0| T@U) (|a#42#1#0| Int) ) (!  (and (= (type |a#42#0#0@@0|) DatatypeTypeType) (= d@@87 (|#PivotBetree.Step.InternalFlushStep| |a#42#0#0@@0| |a#42#1#0|)))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2351|
 :no-pattern (type |a#42#0#0@@0|)
 :no-pattern (U_2_int |a#42#0#0@@0|)
 :no-pattern (U_2_bool |a#42#0#0@@0|)
)))
 :qid |unknown.0:0|
 :skolemid |2352|
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@87))
)))
(assert (forall ((|a#43#0#0@@0| T@U) (|a#43#1#0| Int) ) (!  (=> (= (type |a#43#0#0@@0|) DatatypeTypeType) (= ($Is (|#PivotBetree.Step.InternalFlushStep| |a#43#0#0@@0| |a#43#1#0|) Tclass.PivotBetree.Step)  (and ($Is |a#43#0#0@@0| Tclass.PivotBetree.Path) ($Is (int_2_U |a#43#1#0|) Tclass._System.nat))))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2353|
 :pattern ( ($Is (|#PivotBetree.Step.InternalFlushStep| |a#43#0#0@@0| |a#43#1#0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#44#0#0@@0| T@U) (|a#44#1#0| Int) ($h@@89 T@U) ) (!  (=> (and (and (= (type |a#44#0#0@@0|) DatatypeTypeType) (= (type $h@@89) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@89)) (= ($IsAlloc (|#PivotBetree.Step.InternalFlushStep| |a#44#0#0@@0| |a#44#1#0|) Tclass.PivotBetree.Step $h@@89)  (and ($IsAlloc |a#44#0#0@@0| Tclass.PivotBetree.Path $h@@89) ($IsAlloc (int_2_U |a#44#1#0|) Tclass._System.nat $h@@89))))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2354|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalFlushStep| |a#44#0#0@@0| |a#44#1#0|) Tclass.PivotBetree.Step $h@@89))
)))
(assert (forall ((d@@88 T@U) ($h@@90 T@U) ) (!  (=> (and (and (= (type d@@88) DatatypeTypeType) (= (type $h@@90) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@90) (and (PivotBetree.Step.InternalFlushStep_q d@@88) ($IsAlloc d@@88 Tclass.PivotBetree.Step $h@@90)))) ($IsAlloc (PivotBetree.Step.path d@@88) Tclass.PivotBetree.Path $h@@90))
 :qid |unknown.0:0|
 :skolemid |2355|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@88) Tclass.PivotBetree.Path $h@@90))
)))
(assert (forall ((d@@89 T@U) ($h@@91 T@U) ) (!  (=> (and (and (= (type d@@89) DatatypeTypeType) (= (type $h@@91) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@91) (and (PivotBetree.Step.InternalFlushStep_q d@@89) ($IsAlloc d@@89 Tclass.PivotBetree.Step $h@@91)))) ($IsAlloc (int_2_U (PivotBetree.Step.childIdx d@@89)) Tclass._System.nat $h@@91))
 :qid |unknown.0:0|
 :skolemid |2356|
 :pattern ( ($IsAlloc (int_2_U (PivotBetree.Step.childIdx d@@89)) Tclass._System.nat $h@@91))
)))
(assert (forall ((|a#45#0#0@@0| T@U) (|a#45#1#0| Int) ) (!  (=> (= (type |a#45#0#0@@0|) DatatypeTypeType) (= (|#PivotBetree.Step.InternalFlushStep| (Lit |a#45#0#0@@0|) (LitInt |a#45#1#0|)) (Lit (|#PivotBetree.Step.InternalFlushStep| |a#45#0#0@@0| |a#45#1#0|))))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2357|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| (Lit |a#45#0#0@@0|) (LitInt |a#45#1#0|)))
)))
(assert (forall ((|a#46#0#0@@0| T@U) (|a#46#1#0| Int) ) (!  (=> (= (type |a#46#0#0@@0|) DatatypeTypeType) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalFlushStep| |a#46#0#0@@0| |a#46#1#0|)) |a#46#0#0@@0|))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2358|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#46#0#0@@0| |a#46#1#0|))
)))
(assert (forall ((|a#47#0#0@@0| T@U) (|a#47#1#0| Int) ) (!  (=> (= (type |a#47#0#0@@0|) DatatypeTypeType) (< (DtRank |a#47#0#0@@0|) (DtRank (|#PivotBetree.Step.InternalFlushStep| |a#47#0#0@@0| |a#47#1#0|))))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2359|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#47#0#0@@0| |a#47#1#0|))
)))
(assert (forall ((|a#48#0#0@@0| T@U) (|a#48#1#0| Int) ) (!  (=> (= (type |a#48#0#0@@0|) DatatypeTypeType) (= (PivotBetree.Step.childIdx (|#PivotBetree.Step.InternalFlushStep| |a#48#0#0@@0| |a#48#1#0|)) |a#48#1#0|))
 :qid |PivotBetreebrokenidfy.611:25|
 :skolemid |2360|
 :pattern ( (|#PivotBetree.Step.InternalFlushStep| |a#48#0#0@@0| |a#48#1#0|))
)))
(assert (forall ((arg0@@437 T@U) (arg1@@176 T@U) ) (! (= (type (|#PivotBetree.Step.InternalCompactStep| arg0@@437 arg1@@176)) DatatypeTypeType)
 :qid |funType:#PivotBetree.Step.InternalCompactStep|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| arg0@@437 arg1@@176))
)))
(assert (forall ((|a#49#0#0@@0| T@U) (|a#49#1#0| T@U) ) (!  (=> (and (= (type |a#49#0#0@@0|) DatatypeTypeType) (= (type |a#49#1#0|) DatatypeTypeType)) (= (DatatypeCtorId (|#PivotBetree.Step.InternalCompactStep| |a#49#0#0@@0| |a#49#1#0|)) |##PivotBetree.Step.InternalCompactStep|))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2361|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#49#0#0@@0| |a#49#1#0|))
)))
(assert (forall ((d@@90 T@U) ) (!  (=> (= (type d@@90) DatatypeTypeType) (= (PivotBetree.Step.InternalCompactStep_q d@@90) (= (DatatypeCtorId d@@90) |##PivotBetree.Step.InternalCompactStep|)))
 :qid |unknown.0:0|
 :skolemid |2362|
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@90))
)))
(assert (forall ((d@@91 T@U) ) (!  (=> (and (= (type d@@91) DatatypeTypeType) (PivotBetree.Step.InternalCompactStep_q d@@91)) (exists ((|a#50#0#0@@0| T@U) (|a#50#1#0| T@U) ) (!  (and (and (= (type |a#50#0#0@@0|) DatatypeTypeType) (= (type |a#50#1#0|) DatatypeTypeType)) (= d@@91 (|#PivotBetree.Step.InternalCompactStep| |a#50#0#0@@0| |a#50#1#0|)))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2363|
 :no-pattern (type |a#50#0#0@@0|)
 :no-pattern (type |a#50#1#0|)
 :no-pattern (U_2_int |a#50#0#0@@0|)
 :no-pattern (U_2_bool |a#50#0#0@@0|)
 :no-pattern (U_2_int |a#50#1#0|)
 :no-pattern (U_2_bool |a#50#1#0|)
)))
 :qid |unknown.0:0|
 :skolemid |2364|
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@91))
)))
(assert (forall ((|a#51#0#0| T@U) (|a#51#1#0| T@U) ) (!  (=> (and (= (type |a#51#0#0|) DatatypeTypeType) (= (type |a#51#1#0|) DatatypeTypeType)) (= ($Is (|#PivotBetree.Step.InternalCompactStep| |a#51#0#0| |a#51#1#0|) Tclass.PivotBetree.Step)  (and ($Is |a#51#0#0| Tclass.PivotBetree.Path) ($Is |a#51#1#0| Tclass.Buffers.BufferStack))))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2365|
 :pattern ( ($Is (|#PivotBetree.Step.InternalCompactStep| |a#51#0#0| |a#51#1#0|) Tclass.PivotBetree.Step))
)))
(assert (forall ((|a#52#0#0| T@U) (|a#52#1#0| T@U) ($h@@92 T@U) ) (!  (=> (and (and (and (= (type |a#52#0#0|) DatatypeTypeType) (= (type |a#52#1#0|) DatatypeTypeType)) (= (type $h@@92) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@92)) (= ($IsAlloc (|#PivotBetree.Step.InternalCompactStep| |a#52#0#0| |a#52#1#0|) Tclass.PivotBetree.Step $h@@92)  (and ($IsAlloc |a#52#0#0| Tclass.PivotBetree.Path $h@@92) ($IsAlloc |a#52#1#0| Tclass.Buffers.BufferStack $h@@92))))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2366|
 :pattern ( ($IsAlloc (|#PivotBetree.Step.InternalCompactStep| |a#52#0#0| |a#52#1#0|) Tclass.PivotBetree.Step $h@@92))
)))
(assert (forall ((d@@92 T@U) ($h@@93 T@U) ) (!  (=> (and (and (= (type d@@92) DatatypeTypeType) (= (type $h@@93) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@93) (and (PivotBetree.Step.InternalCompactStep_q d@@92) ($IsAlloc d@@92 Tclass.PivotBetree.Step $h@@93)))) ($IsAlloc (PivotBetree.Step.path d@@92) Tclass.PivotBetree.Path $h@@93))
 :qid |unknown.0:0|
 :skolemid |2367|
 :pattern ( ($IsAlloc (PivotBetree.Step.path d@@92) Tclass.PivotBetree.Path $h@@93))
)))
(assert (forall ((arg0@@438 T@U) ) (! (= (type (PivotBetree.Step.compactedBuffers arg0@@438)) DatatypeTypeType)
 :qid |funType:PivotBetree.Step.compactedBuffers|
 :pattern ( (PivotBetree.Step.compactedBuffers arg0@@438))
)))
(assert (forall ((d@@93 T@U) ($h@@94 T@U) ) (!  (=> (and (and (= (type d@@93) DatatypeTypeType) (= (type $h@@94) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@94) (and (PivotBetree.Step.InternalCompactStep_q d@@93) ($IsAlloc d@@93 Tclass.PivotBetree.Step $h@@94)))) ($IsAlloc (PivotBetree.Step.compactedBuffers d@@93) Tclass.Buffers.BufferStack $h@@94))
 :qid |unknown.0:0|
 :skolemid |2368|
 :pattern ( ($IsAlloc (PivotBetree.Step.compactedBuffers d@@93) Tclass.Buffers.BufferStack $h@@94))
)))
(assert (forall ((|a#53#0#0| T@U) (|a#53#1#0| T@U) ) (!  (=> (and (= (type |a#53#0#0|) DatatypeTypeType) (= (type |a#53#1#0|) DatatypeTypeType)) (= (|#PivotBetree.Step.InternalCompactStep| (Lit |a#53#0#0|) (Lit |a#53#1#0|)) (Lit (|#PivotBetree.Step.InternalCompactStep| |a#53#0#0| |a#53#1#0|))))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2369|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| (Lit |a#53#0#0|) (Lit |a#53#1#0|)))
)))
(assert (forall ((|a#54#0#0| T@U) (|a#54#1#0| T@U) ) (!  (=> (and (= (type |a#54#0#0|) DatatypeTypeType) (= (type |a#54#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.path (|#PivotBetree.Step.InternalCompactStep| |a#54#0#0| |a#54#1#0|)) |a#54#0#0|))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2370|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#54#0#0| |a#54#1#0|))
)))
(assert (forall ((|a#55#0#0| T@U) (|a#55#1#0| T@U) ) (!  (=> (and (= (type |a#55#0#0|) DatatypeTypeType) (= (type |a#55#1#0|) DatatypeTypeType)) (< (DtRank |a#55#0#0|) (DtRank (|#PivotBetree.Step.InternalCompactStep| |a#55#0#0| |a#55#1#0|))))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2371|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#55#0#0| |a#55#1#0|))
)))
(assert (forall ((|a#56#0#0| T@U) (|a#56#1#0| T@U) ) (!  (=> (and (= (type |a#56#0#0|) DatatypeTypeType) (= (type |a#56#1#0|) DatatypeTypeType)) (= (PivotBetree.Step.compactedBuffers (|#PivotBetree.Step.InternalCompactStep| |a#56#0#0| |a#56#1#0|)) |a#56#1#0|))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2372|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#56#0#0| |a#56#1#0|))
)))
(assert (forall ((|a#57#0#0| T@U) (|a#57#1#0| T@U) ) (!  (=> (and (= (type |a#57#0#0|) DatatypeTypeType) (= (type |a#57#1#0|) DatatypeTypeType)) (< (DtRank |a#57#1#0|) (DtRank (|#PivotBetree.Step.InternalCompactStep| |a#57#0#0| |a#57#1#0|))))
 :qid |PivotBetreebrokenidfy.612:27|
 :skolemid |2373|
 :pattern ( (|#PivotBetree.Step.InternalCompactStep| |a#57#0#0| |a#57#1#0|))
)))
(assert (= (type |#PivotBetree.Step.InternalNoOpStep|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#PivotBetree.Step.InternalNoOpStep|) |##PivotBetree.Step.InternalNoOpStep|))
(assert (forall ((d@@94 T@U) ) (!  (=> (= (type d@@94) DatatypeTypeType) (= (PivotBetree.Step.InternalNoOpStep_q d@@94) (= (DatatypeCtorId d@@94) |##PivotBetree.Step.InternalNoOpStep|)))
 :qid |unknown.0:0|
 :skolemid |2374|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@94))
)))
(assert (forall ((d@@95 T@U) ) (!  (=> (and (= (type d@@95) DatatypeTypeType) (PivotBetree.Step.InternalNoOpStep_q d@@95)) (= d@@95 |#PivotBetree.Step.InternalNoOpStep|))
 :qid |unknown.0:0|
 :skolemid |2375|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@95))
)))
(assert ($Is |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step))
(assert (forall (($h@@95 T@U) ) (!  (=> (and (= (type $h@@95) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@95)) ($IsAlloc |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step $h@@95))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2376|
 :pattern ( ($IsAlloc |#PivotBetree.Step.InternalNoOpStep| Tclass.PivotBetree.Step $h@@95))
)))
(assert (= |#PivotBetree.Step.InternalNoOpStep| (Lit |#PivotBetree.Step.InternalNoOpStep|)))
(assert (forall ((d@@96 T@U) ) (!  (=> (and (= (type d@@96) DatatypeTypeType) (|$IsA#PivotBetree.Step| d@@96)) (or (or (or (or (or (or (or (or (or (PivotBetree.Step.QueryStep_q d@@96) (PivotBetree.Step.PutStep_q d@@96)) (PivotBetree.Step.QueryEndLsnStep_q d@@96)) (PivotBetree.Step.FreezeAsStep_q d@@96)) (PivotBetree.Step.InternalGrowStep_q d@@96)) (PivotBetree.Step.InternalSplitStep_q d@@96)) (PivotBetree.Step.InternalFlushMemtableStep_q d@@96)) (PivotBetree.Step.InternalFlushStep_q d@@96)) (PivotBetree.Step.InternalCompactStep_q d@@96)) (PivotBetree.Step.InternalNoOpStep_q d@@96)))
 :qid |unknown.0:0|
 :skolemid |2377|
 :pattern ( (|$IsA#PivotBetree.Step| d@@96))
)))
(assert (forall ((d@@97 T@U) ) (!  (=> (and (= (type d@@97) DatatypeTypeType) ($Is d@@97 Tclass.PivotBetree.Step)) (or (or (or (or (or (or (or (or (or (PivotBetree.Step.QueryStep_q d@@97) (PivotBetree.Step.PutStep_q d@@97)) (PivotBetree.Step.QueryEndLsnStep_q d@@97)) (PivotBetree.Step.FreezeAsStep_q d@@97)) (PivotBetree.Step.InternalGrowStep_q d@@97)) (PivotBetree.Step.InternalSplitStep_q d@@97)) (PivotBetree.Step.InternalFlushMemtableStep_q d@@97)) (PivotBetree.Step.InternalFlushStep_q d@@97)) (PivotBetree.Step.InternalCompactStep_q d@@97)) (PivotBetree.Step.InternalNoOpStep_q d@@97)))
 :qid |unknown.0:0|
 :skolemid |2378|
 :pattern ( (PivotBetree.Step.InternalNoOpStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalCompactStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalFlushStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalFlushMemtableStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalSplitStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.InternalGrowStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.FreezeAsStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.QueryEndLsnStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.PutStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
 :pattern ( (PivotBetree.Step.QueryStep_q d@@97) ($Is d@@97 Tclass.PivotBetree.Step))
)))
(assert (forall ((a@@135 T@U) (b@@84 T@U) ) (!  (=> (and (and (= (type a@@135) DatatypeTypeType) (= (type b@@84) DatatypeTypeType)) (and (PivotBetree.Step.QueryStep_q a@@135) (PivotBetree.Step.QueryStep_q b@@84))) (= (|PivotBetree.Step#Equal| a@@135 b@@84) (|PivotBetree.QueryReceipt#Equal| (PivotBetree.Step.receipt a@@135) (PivotBetree.Step.receipt b@@84))))
 :qid |unknown.0:0|
 :skolemid |2379|
 :pattern ( (|PivotBetree.Step#Equal| a@@135 b@@84) (PivotBetree.Step.QueryStep_q a@@135))
 :pattern ( (|PivotBetree.Step#Equal| a@@135 b@@84) (PivotBetree.Step.QueryStep_q b@@84))
)))
(assert (forall ((a@@136 T@U) (b@@85 T@U) ) (!  (=> (and (and (= (type a@@136) DatatypeTypeType) (= (type b@@85) DatatypeTypeType)) (and (PivotBetree.Step.PutStep_q a@@136) (PivotBetree.Step.PutStep_q b@@85))) (= (|PivotBetree.Step#Equal| a@@136 b@@85) true))
 :qid |unknown.0:0|
 :skolemid |2380|
 :pattern ( (|PivotBetree.Step#Equal| a@@136 b@@85) (PivotBetree.Step.PutStep_q a@@136))
 :pattern ( (|PivotBetree.Step#Equal| a@@136 b@@85) (PivotBetree.Step.PutStep_q b@@85))
)))
(assert (forall ((a@@137 T@U) (b@@86 T@U) ) (!  (=> (and (and (= (type a@@137) DatatypeTypeType) (= (type b@@86) DatatypeTypeType)) (and (PivotBetree.Step.QueryEndLsnStep_q a@@137) (PivotBetree.Step.QueryEndLsnStep_q b@@86))) (= (|PivotBetree.Step#Equal| a@@137 b@@86) true))
 :qid |unknown.0:0|
 :skolemid |2381|
 :pattern ( (|PivotBetree.Step#Equal| a@@137 b@@86) (PivotBetree.Step.QueryEndLsnStep_q a@@137))
 :pattern ( (|PivotBetree.Step#Equal| a@@137 b@@86) (PivotBetree.Step.QueryEndLsnStep_q b@@86))
)))
(assert (forall ((a@@138 T@U) (b@@87 T@U) ) (!  (=> (and (and (= (type a@@138) DatatypeTypeType) (= (type b@@87) DatatypeTypeType)) (and (PivotBetree.Step.FreezeAsStep_q a@@138) (PivotBetree.Step.FreezeAsStep_q b@@87))) (= (|PivotBetree.Step#Equal| a@@138 b@@87) true))
 :qid |unknown.0:0|
 :skolemid |2382|
 :pattern ( (|PivotBetree.Step#Equal| a@@138 b@@87) (PivotBetree.Step.FreezeAsStep_q a@@138))
 :pattern ( (|PivotBetree.Step#Equal| a@@138 b@@87) (PivotBetree.Step.FreezeAsStep_q b@@87))
)))
(assert (forall ((a@@139 T@U) (b@@88 T@U) ) (!  (=> (and (and (= (type a@@139) DatatypeTypeType) (= (type b@@88) DatatypeTypeType)) (and (PivotBetree.Step.InternalGrowStep_q a@@139) (PivotBetree.Step.InternalGrowStep_q b@@88))) (= (|PivotBetree.Step#Equal| a@@139 b@@88) true))
 :qid |unknown.0:0|
 :skolemid |2383|
 :pattern ( (|PivotBetree.Step#Equal| a@@139 b@@88) (PivotBetree.Step.InternalGrowStep_q a@@139))
 :pattern ( (|PivotBetree.Step#Equal| a@@139 b@@88) (PivotBetree.Step.InternalGrowStep_q b@@88))
)))
(assert (forall ((a@@140 T@U) (b@@89 T@U) ) (!  (=> (and (and (= (type a@@140) DatatypeTypeType) (= (type b@@89) DatatypeTypeType)) (and (PivotBetree.Step.InternalSplitStep_q a@@140) (PivotBetree.Step.InternalSplitStep_q b@@89))) (= (|PivotBetree.Step#Equal| a@@140 b@@89)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@140) (PivotBetree.Step.path b@@89)) (|SplitRequestMod.SplitRequest#Equal| (PivotBetree.Step.request a@@140) (PivotBetree.Step.request b@@89)))))
 :qid |unknown.0:0|
 :skolemid |2384|
 :pattern ( (|PivotBetree.Step#Equal| a@@140 b@@89) (PivotBetree.Step.InternalSplitStep_q a@@140))
 :pattern ( (|PivotBetree.Step#Equal| a@@140 b@@89) (PivotBetree.Step.InternalSplitStep_q b@@89))
)))
(assert (forall ((a@@141 T@U) (b@@90 T@U) ) (!  (=> (and (and (= (type a@@141) DatatypeTypeType) (= (type b@@90) DatatypeTypeType)) (and (PivotBetree.Step.InternalFlushMemtableStep_q a@@141) (PivotBetree.Step.InternalFlushMemtableStep_q b@@90))) (= (|PivotBetree.Step#Equal| a@@141 b@@90) true))
 :qid |unknown.0:0|
 :skolemid |2385|
 :pattern ( (|PivotBetree.Step#Equal| a@@141 b@@90) (PivotBetree.Step.InternalFlushMemtableStep_q a@@141))
 :pattern ( (|PivotBetree.Step#Equal| a@@141 b@@90) (PivotBetree.Step.InternalFlushMemtableStep_q b@@90))
)))
(assert (forall ((a@@142 T@U) (b@@91 T@U) ) (!  (=> (and (and (= (type a@@142) DatatypeTypeType) (= (type b@@91) DatatypeTypeType)) (and (PivotBetree.Step.InternalFlushStep_q a@@142) (PivotBetree.Step.InternalFlushStep_q b@@91))) (= (|PivotBetree.Step#Equal| a@@142 b@@91)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@142) (PivotBetree.Step.path b@@91)) (= (PivotBetree.Step.childIdx a@@142) (PivotBetree.Step.childIdx b@@91)))))
 :qid |unknown.0:0|
 :skolemid |2386|
 :pattern ( (|PivotBetree.Step#Equal| a@@142 b@@91) (PivotBetree.Step.InternalFlushStep_q a@@142))
 :pattern ( (|PivotBetree.Step#Equal| a@@142 b@@91) (PivotBetree.Step.InternalFlushStep_q b@@91))
)))
(assert (forall ((a@@143 T@U) (b@@92 T@U) ) (!  (=> (and (and (= (type a@@143) DatatypeTypeType) (= (type b@@92) DatatypeTypeType)) (and (PivotBetree.Step.InternalCompactStep_q a@@143) (PivotBetree.Step.InternalCompactStep_q b@@92))) (= (|PivotBetree.Step#Equal| a@@143 b@@92)  (and (|PivotBetree.Path#Equal| (PivotBetree.Step.path a@@143) (PivotBetree.Step.path b@@92)) (|Buffers.BufferStack#Equal| (PivotBetree.Step.compactedBuffers a@@143) (PivotBetree.Step.compactedBuffers b@@92)))))
 :qid |unknown.0:0|
 :skolemid |2387|
 :pattern ( (|PivotBetree.Step#Equal| a@@143 b@@92) (PivotBetree.Step.InternalCompactStep_q a@@143))
 :pattern ( (|PivotBetree.Step#Equal| a@@143 b@@92) (PivotBetree.Step.InternalCompactStep_q b@@92))
)))
(assert (forall ((a@@144 T@U) (b@@93 T@U) ) (!  (=> (and (and (= (type a@@144) DatatypeTypeType) (= (type b@@93) DatatypeTypeType)) (and (PivotBetree.Step.InternalNoOpStep_q a@@144) (PivotBetree.Step.InternalNoOpStep_q b@@93))) (= (|PivotBetree.Step#Equal| a@@144 b@@93) true))
 :qid |unknown.0:0|
 :skolemid |2388|
 :pattern ( (|PivotBetree.Step#Equal| a@@144 b@@93) (PivotBetree.Step.InternalNoOpStep_q a@@144))
 :pattern ( (|PivotBetree.Step#Equal| a@@144 b@@93) (PivotBetree.Step.InternalNoOpStep_q b@@93))
)))
(assert (forall ((a@@145 T@U) (b@@94 T@U) ) (!  (=> (and (= (type a@@145) DatatypeTypeType) (= (type b@@94) DatatypeTypeType)) (= (|PivotBetree.Step#Equal| a@@145 b@@94) (= a@@145 b@@94)))
 :qid |unknown.0:0|
 :skolemid |2389|
 :pattern ( (|PivotBetree.Step#Equal| a@@145 b@@94))
)))
(assert  (=> (<= 64 $FunctionContextHeight) (forall ((this@@175 T@U) ) (!  (=> (and (= (type this@@175) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| this@@175) (and (not (= 64 $FunctionContextHeight)) ($Is this@@175 Tclass.PivotBetree.Step)))) true)
 :qid |PivotBetreebrokenidfy.615:15|
 :skolemid |2390|
 :pattern ( (PivotBetree.Step.WF this@@175))
))))
(assert (forall ((this@@176 T@U) ) (!  (=> (and (= (type this@@176) DatatypeTypeType) ($Is this@@176 Tclass.PivotBetree.Step)) (= (|PivotBetree.Step.WF#requires| this@@176) true))
 :qid |PivotBetreebrokenidfy.615:15|
 :skolemid |2391|
 :pattern ( (|PivotBetree.Step.WF#requires| this@@176))
)))
(assert  (=> (<= 64 $FunctionContextHeight) (forall ((this@@177 T@U) ) (!  (=> (and (= (type this@@177) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| this@@177) (and (not (= 64 $FunctionContextHeight)) ($Is this@@177 Tclass.PivotBetree.Step)))) (and (and (=> (PivotBetree.Step.QueryStep_q this@@177) (let ((|receipt#1| (PivotBetree.Step.receipt this@@177)))
(|PivotBetree.QueryReceipt.Valid#canCall| |receipt#1|))) (=> (not (PivotBetree.Step.QueryStep_q this@@177)) (=> (not (PivotBetree.Step.PutStep_q this@@177)) (=> (not (PivotBetree.Step.QueryEndLsnStep_q this@@177)) (=> (not (PivotBetree.Step.FreezeAsStep_q this@@177)) (=> (not (PivotBetree.Step.InternalGrowStep_q this@@177)) (and (=> (PivotBetree.Step.InternalSplitStep_q this@@177) (let ((|request#1| (PivotBetree.Step.request this@@177)))
(let ((|path#3| (PivotBetree.Step.path this@@177)))
 (and (|PivotBetree.Path.Valid#canCall| |path#3|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#3|) (and (and (and (|PivotBetree.Path.Target#canCall| |path#3|) (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#1|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#1|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#3|) (SplitRequestMod.SplitRequest.childIdx |request#1|))) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#3|) (SplitRequestMod.SplitRequest.childIdx |request#1|)) (and (|PivotBetree.Path.Target#canCall| |path#3|) (|PivotBetree.BetreeNode.CanSplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#3|) |request#1|))))))))) (=> (not (PivotBetree.Step.InternalSplitStep_q this@@177)) (=> (not (PivotBetree.Step.InternalFlushMemtableStep_q this@@177)) (and (=> (PivotBetree.Step.InternalFlushStep_q this@@177) (let ((|childIdx#1| (PivotBetree.Step.childIdx this@@177)))
(let ((|path#4| (PivotBetree.Step.path this@@177)))
 (and (|PivotBetree.Path.Valid#canCall| |path#4|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#4|) (and (|PivotBetree.Path.Target#canCall| |path#4|) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#4|) |childIdx#1|))))))) (=> (not (PivotBetree.Step.InternalFlushStep_q this@@177)) (=> (PivotBetree.Step.InternalCompactStep_q this@@177) (let ((|compactedBuffers#1| (PivotBetree.Step.compactedBuffers this@@177)))
(let ((|path#5| (PivotBetree.Step.path this@@177)))
 (and (|PivotBetree.Path.Valid#canCall| |path#5|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#5|) (and (|PivotBetree.Path.Target#canCall| |path#5|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#5|)) (and (|PivotBetree.Path.Target#canCall| |path#5|) (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#5|)) |compactedBuffers#1|)))))))))))))))))))) (= (PivotBetree.Step.WF this@@177) (ite (PivotBetree.Step.QueryStep_q this@@177) (let ((|receipt#0| (PivotBetree.Step.receipt this@@177)))
(PivotBetree.QueryReceipt.Valid |receipt#0|)) (ite (PivotBetree.Step.PutStep_q this@@177) true (ite (PivotBetree.Step.QueryEndLsnStep_q this@@177) true (ite (PivotBetree.Step.FreezeAsStep_q this@@177) true (ite (PivotBetree.Step.InternalGrowStep_q this@@177) true (ite (PivotBetree.Step.InternalSplitStep_q this@@177) (let ((|request#0@@15| (PivotBetree.Step.request this@@177)))
(let ((|path#0| (PivotBetree.Step.path this@@177)))
 (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#0|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#0|) (SplitRequestMod.SplitRequest.childIdx |request#0@@15|))) (PivotBetree.BetreeNode.CanSplitParent (PivotBetree.Path.Target ($LS $LZ) |path#0|) |request#0@@15|)))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q this@@177) true (ite (PivotBetree.Step.InternalFlushStep_q this@@177) (let ((|childIdx#0@@15| (PivotBetree.Step.childIdx this@@177)))
(let ((|path#1| (PivotBetree.Step.path this@@177)))
 (and (PivotBetree.Path.Valid ($LS $LZ) |path#1|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#1|) |childIdx#0@@15|)))) (ite (PivotBetree.Step.InternalCompactStep_q this@@177) (let ((|compactedBuffers#0| (PivotBetree.Step.compactedBuffers this@@177)))
(let ((|path#2| (PivotBetree.Step.path this@@177)))
 (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#2|) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#2|))) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#2|)) |compactedBuffers#0|)))) true))))))))))))
 :qid |PivotBetreebrokenidfy.615:15|
 :skolemid |2392|
 :pattern ( (PivotBetree.Step.WF this@@177))
))))
(assert  (=> (<= 64 $FunctionContextHeight) (forall ((this@@178 T@U) ) (!  (=> (and (= (type this@@178) DatatypeTypeType) (or (|PivotBetree.Step.WF#canCall| (Lit this@@178)) (and (not (= 64 $FunctionContextHeight)) ($Is this@@178 Tclass.PivotBetree.Step)))) (and (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit this@@178))))) (let ((|receipt#3| (Lit (PivotBetree.Step.receipt (Lit this@@178)))))
(|PivotBetree.QueryReceipt.Valid#canCall| |receipt#3|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit this@@178)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit this@@178)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit this@@178)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit this@@178)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit this@@178)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@178))))) (let ((|request#3| (Lit (PivotBetree.Step.request (Lit this@@178)))))
(let ((|path#9| (Lit (PivotBetree.Step.path (Lit this@@178)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#9|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#9|) (and (and (and (|PivotBetree.Path.Target#canCall| |path#9|) (or (SplitRequestMod.SplitRequest.SplitLeaf_q |request#3|) (SplitRequestMod.SplitRequest.SplitIndex_q |request#3|))) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#9|) (SplitRequestMod.SplitRequest.childIdx |request#3|))) (=> (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.Target ($LS $LZ) |path#9|) (SplitRequestMod.SplitRequest.childIdx |request#3|)) (and (|PivotBetree.Path.Target#canCall| |path#9|) (|PivotBetree.BetreeNode.CanSplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#9|) |request#3|))))))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@178)))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit this@@178)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit this@@178))))) (let ((|childIdx#3| (LitInt (PivotBetree.Step.childIdx (Lit this@@178)))))
(let ((|path#10| (Lit (PivotBetree.Step.path (Lit this@@178)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#10|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#10|) (and (|PivotBetree.Path.Target#canCall| |path#10|) (|PivotBetree.BetreeNode.ValidChildIndex#canCall| (PivotBetree.Path.Target ($LS $LZ) |path#10|) |childIdx#3|))))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit this@@178)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit this@@178))))) (let ((|compactedBuffers#3| (Lit (PivotBetree.Step.compactedBuffers (Lit this@@178)))))
(let ((|path#11| (Lit (PivotBetree.Step.path (Lit this@@178)))))
 (and (|PivotBetree.Path.Valid#canCall| |path#11|) (=> (PivotBetree.Path.Valid ($LS $LZ) |path#11|) (and (|PivotBetree.Path.Target#canCall| |path#11|) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.Target ($LS $LZ) |path#11|)) (and (|PivotBetree.Path.Target#canCall| |path#11|) (|Buffers.BufferStack.Equivalent#canCall| (PivotBetree.BetreeNode.buffers (PivotBetree.Path.Target ($LS $LZ) |path#11|)) |compactedBuffers#3|)))))))))))))))))))) (= (PivotBetree.Step.WF (Lit this@@178)) (ite (PivotBetree.Step.QueryStep_q (Lit this@@178)) (U_2_bool (let ((|receipt#2| (Lit (PivotBetree.Step.receipt (Lit this@@178)))))
(Lit (bool_2_U (PivotBetree.QueryReceipt.Valid |receipt#2|))))) (ite (PivotBetree.Step.PutStep_q (Lit this@@178)) true (ite (PivotBetree.Step.QueryEndLsnStep_q (Lit this@@178)) true (ite (PivotBetree.Step.FreezeAsStep_q (Lit this@@178)) true (ite (PivotBetree.Step.InternalGrowStep_q (Lit this@@178)) true (ite (PivotBetree.Step.InternalSplitStep_q (Lit this@@178)) (U_2_bool (let ((|request#2| (Lit (PivotBetree.Step.request (Lit this@@178)))))
(let ((|path#6| (Lit (PivotBetree.Step.path (Lit this@@178)))))
(Lit (bool_2_U  (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#6|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.Target ($LS $LZ) |path#6|)) (LitInt (SplitRequestMod.SplitRequest.childIdx |request#2|)))) (PivotBetree.BetreeNode.CanSplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) |path#6|)) |request#2|))))))) (ite (PivotBetree.Step.InternalFlushMemtableStep_q (Lit this@@178)) true (ite (PivotBetree.Step.InternalFlushStep_q (Lit this@@178)) (U_2_bool (let ((|childIdx#2| (LitInt (PivotBetree.Step.childIdx (Lit this@@178)))))
(let ((|path#7| (Lit (PivotBetree.Step.path (Lit this@@178)))))
(Lit (bool_2_U  (and (PivotBetree.Path.Valid ($LS $LZ) |path#7|) (PivotBetree.BetreeNode.ValidChildIndex (Lit (PivotBetree.Path.Target ($LS $LZ) |path#7|)) |childIdx#2|))))))) (ite (PivotBetree.Step.InternalCompactStep_q (Lit this@@178)) (U_2_bool (let ((|compactedBuffers#2| (Lit (PivotBetree.Step.compactedBuffers (Lit this@@178)))))
(let ((|path#8| (Lit (PivotBetree.Step.path (Lit this@@178)))))
(Lit (bool_2_U  (and (and (PivotBetree.Path.Valid ($LS $LZ) |path#8|) (PivotBetree.BetreeNode.BetreeNode_q (Lit (PivotBetree.Path.Target ($LS $LZ) |path#8|)))) (Buffers.BufferStack.Equivalent (Lit (PivotBetree.BetreeNode.buffers (Lit (PivotBetree.Path.Target ($LS $LZ) |path#8|)))) |compactedBuffers#2|))))))) true))))))))))))
 :qid |PivotBetreebrokenidfy.615:15|
 :weight 3
 :skolemid |2393|
 :pattern ( (PivotBetree.Step.WF (Lit this@@178)))
))))
(assert (forall ((arg0@@439 T@U) ) (! (= (type (PivotBetree.Step.SplitKey arg0@@439)) (SeqType BoxType))
 :qid |funType:PivotBetree.Step.SplitKey|
 :pattern ( (PivotBetree.Step.SplitKey arg0@@439))
)))
(assert  (=> (<= 65 $FunctionContextHeight) (forall ((this@@179 T@U) ) (!  (=> (and (= (type this@@179) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| this@@179) (and (not (= 65 $FunctionContextHeight)) (and ($Is this@@179 Tclass.PivotBetree.Step) (and (PivotBetree.Step.WF this@@179) (PivotBetree.Step.InternalSplitStep_q this@@179)))))) ($Is (PivotBetree.Step.SplitKey this@@179) Tclass.KeyType.Key))
 :qid |PivotBetreebrokenidfy.634:14|
 :skolemid |2477|
 :pattern ( (PivotBetree.Step.SplitKey this@@179))
))))
(assert (forall ((this@@180 T@U) ) (!  (=> (and (= (type this@@180) DatatypeTypeType) ($Is this@@180 Tclass.PivotBetree.Step)) (= (|PivotBetree.Step.SplitKey#requires| this@@180)  (and (PivotBetree.Step.WF this@@180) (PivotBetree.Step.InternalSplitStep_q this@@180))))
 :qid |PivotBetreebrokenidfy.634:14|
 :skolemid |2478|
 :pattern ( (|PivotBetree.Step.SplitKey#requires| this@@180))
)))
(assert  (=> (<= 65 $FunctionContextHeight) (forall ((this@@181 T@U) ) (!  (=> (and (= (type this@@181) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| this@@181) (and (not (= 65 $FunctionContextHeight)) (and ($Is this@@181 Tclass.PivotBetree.Step) (and (PivotBetree.Step.WF this@@181) (PivotBetree.Step.InternalSplitStep_q this@@181)))))) (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path this@@181)) (|PivotBetree.BetreeNode.SplitKey#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path this@@181)) (PivotBetree.Step.request this@@181))) (= (PivotBetree.Step.SplitKey this@@181) (PivotBetree.BetreeNode.SplitKey (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path this@@181)) (PivotBetree.Step.request this@@181)))))
 :qid |PivotBetreebrokenidfy.634:14|
 :skolemid |2479|
 :pattern ( (PivotBetree.Step.SplitKey this@@181))
))))
(assert  (=> (<= 65 $FunctionContextHeight) (forall ((this@@182 T@U) ) (!  (=> (and (= (type this@@182) DatatypeTypeType) (or (|PivotBetree.Step.SplitKey#canCall| (Lit this@@182)) (and (not (= 65 $FunctionContextHeight)) (and ($Is this@@182 Tclass.PivotBetree.Step) (and (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit this@@182))))) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit this@@182)))))))))) (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit this@@182)))) (|PivotBetree.BetreeNode.SplitKey#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit this@@182))))) (Lit (PivotBetree.Step.request (Lit this@@182))))) (= (PivotBetree.Step.SplitKey (Lit this@@182)) (Lit (PivotBetree.BetreeNode.SplitKey (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit this@@182))))) (Lit (PivotBetree.Step.request (Lit this@@182))))))))
 :qid |PivotBetreebrokenidfy.634:14|
 :weight 3
 :skolemid |2480|
 :pattern ( (PivotBetree.Step.SplitKey (Lit this@@182)))
))))
(assert (= (type Tclass.PivotBetree.__default) TyType))
(assert (= (Tag Tclass.PivotBetree.__default) Tagclass.PivotBetree.__default))
(assert (= (TagFamily Tclass.PivotBetree.__default) tytagFamily$_default))
(assert (forall ((bx@@124 T@U) ) (!  (=> (and (= (type bx@@124) BoxType) ($IsBox bx@@124 Tclass.PivotBetree.__default)) (and (= ($Box ($Unbox refType bx@@124)) bx@@124) ($Is ($Unbox refType bx@@124) Tclass.PivotBetree.__default)))
 :qid |unknown.0:0|
 :skolemid |2516|
 :pattern ( ($IsBox bx@@124 Tclass.PivotBetree.__default))
)))
(assert (forall (($o@@9 T@U) ) (!  (=> (= (type $o@@9) refType) (= ($Is $o@@9 Tclass.PivotBetree.__default)  (or (= $o@@9 null) (= (dtype $o@@9) Tclass.PivotBetree.__default))))
 :qid |unknown.0:0|
 :skolemid |2517|
 :pattern ( ($Is $o@@9 Tclass.PivotBetree.__default))
)))
(assert (forall (($o@@10 T@U) ($h@@96 T@U) ) (!  (=> (and (= (type $o@@10) refType) (= (type $h@@96) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@10 Tclass.PivotBetree.__default $h@@96)  (or (= $o@@10 null) (U_2_bool (MapType1Select (MapType0Select $h@@96 $o@@10) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2518|
 :pattern ( ($IsAlloc $o@@10 Tclass.PivotBetree.__default $h@@96))
)))
(assert (forall (($ly@@31 T@U) (|children#0| T@U) ) (!  (=> (and (= (type $ly@@31) LayerTypeType) (= (type |children#0|) (SeqType BoxType))) (= (PivotBetree.__default.WFChildren ($LS $ly@@31) |children#0|) (PivotBetree.__default.WFChildren $ly@@31 |children#0|)))
 :qid |PivotBetreebrokenidfy.38:13|
 :skolemid |2519|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@31) |children#0|))
)))
(assert (forall (($ly@@32 T@U) (|children#0@@0| T@U) ) (!  (=> (and (= (type $ly@@32) LayerTypeType) (= (type |children#0@@0|) (SeqType BoxType))) (= (PivotBetree.__default.WFChildren $ly@@32 |children#0@@0|) (PivotBetree.__default.WFChildren $LZ |children#0@@0|)))
 :qid |PivotBetreebrokenidfy.38:13|
 :skolemid |2520|
 :pattern ( (PivotBetree.__default.WFChildren (AsFuelBottom $ly@@32) |children#0@@0|))
)))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@33 T@U) (|children#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@33) LayerTypeType) (= (type |children#0@@1|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| |children#0@@1|) (and (not (= 19 $FunctionContextHeight)) ($Is |children#0@@1| (TSeq Tclass.PivotBetree.BetreeNode))))) true)
 :qid |PivotBetreebrokenidfy.38:13|
 :skolemid |2521|
 :pattern ( (PivotBetree.__default.WFChildren $ly@@33 |children#0@@1|))
))))
(assert (forall (($ly@@34 T@U) (|children#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@34) LayerTypeType) (= (type |children#0@@2|) (SeqType BoxType))) ($Is |children#0@@2| (TSeq Tclass.PivotBetree.BetreeNode))) (= (|PivotBetree.__default.WFChildren#requires| $ly@@34 |children#0@@2|) true))
 :qid |PivotBetreebrokenidfy.38:13|
 :skolemid |2522|
 :pattern ( (|PivotBetree.__default.WFChildren#requires| $ly@@34 |children#0@@2|))
)))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@35 T@U) (|children#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@35) LayerTypeType) (= (type |children#0@@3|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| |children#0@@3|) (and (not (= 19 $FunctionContextHeight)) ($Is |children#0@@3| (TSeq Tclass.PivotBetree.BetreeNode))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@29| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@29|) (=> (INTERNAL_lt_boogie |i#0@@29| (|Seq#Length| |children#0@@3|)) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@29|)))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2524|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@29|)))
))) (= (PivotBetree.__default.WFChildren ($LS $ly@@35) |children#0@@3|)  (and true (forall ((|i#0@@30| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@30|) (INTERNAL_lt_boogie |i#0@@30| (|Seq#Length| |children#0@@3|))) (PivotBetree.BetreeNode.WF $ly@@35 ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@30|))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2523|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@3| |i#0@@30|)))
))))))
 :qid |PivotBetreebrokenidfy.38:13|
 :skolemid |2525|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@35) |children#0@@3|))
))))
(assert  (=> (<= 19 $FunctionContextHeight) (forall (($ly@@36 T@U) (|children#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@36) LayerTypeType) (= (type |children#0@@4|) (SeqType BoxType))) (or (|PivotBetree.__default.WFChildren#canCall| (Lit |children#0@@4|)) (and (not (= 19 $FunctionContextHeight)) ($Is |children#0@@4| (TSeq Tclass.PivotBetree.BetreeNode))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@11| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@11|) (=> (INTERNAL_lt_boogie |i#1@@11| (|Seq#Length| (Lit |children#0@@4|))) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |children#0@@4|) |i#1@@11|)))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2527|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@4| |i#1@@11|)))
))) (= (PivotBetree.__default.WFChildren ($LS $ly@@36) (Lit |children#0@@4|))  (and true (forall ((|i#1@@12| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@12|) (INTERNAL_lt_boogie |i#1@@12| (|Seq#Length| (Lit |children#0@@4|)))) (PivotBetree.BetreeNode.WF ($LS $ly@@36) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |children#0@@4|) |i#1@@12|))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2526|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |children#0@@4| |i#1@@12|)))
))))))
 :qid |PivotBetreebrokenidfy.38:13|
 :weight 3
 :skolemid |2528|
 :pattern ( (PivotBetree.__default.WFChildren ($LS $ly@@36) (Lit |children#0@@4|)))
))))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|domain#0@@3| T@U) ) (!  (=> (and (= (type |domain#0@@3|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@3|) (and (not (= 32 $FunctionContextHeight)) (and ($Is |domain#0@@3| Tclass.DomainMod.Domain) (and (DomainMod.Domain.WF |domain#0@@3|) (DomainMod.Domain.Domain_q |domain#0@@3|)))))) (and (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.__default.EmptyRoot |domain#0@@3|)) ($Is (PivotBetree.__default.EmptyRoot |domain#0@@3|) Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.296:22|
 :skolemid |2532|
 :pattern ( (PivotBetree.__default.EmptyRoot |domain#0@@3|))
))))
(assert (forall ((|domain#0@@4| T@U) ) (!  (=> (and (= (type |domain#0@@4|) DatatypeTypeType) ($Is |domain#0@@4| Tclass.DomainMod.Domain)) (= (|PivotBetree.__default.EmptyRoot#requires| |domain#0@@4|)  (and (DomainMod.Domain.WF |domain#0@@4|) (DomainMod.Domain.Domain_q |domain#0@@4|))))
 :qid |PivotBetreebrokenidfy.296:22|
 :skolemid |2533|
 :pattern ( (|PivotBetree.__default.EmptyRoot#requires| |domain#0@@4|))
)))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|domain#0@@5| T@U) ) (!  (=> (and (= (type |domain#0@@5|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| |domain#0@@5|) (and (not (= 32 $FunctionContextHeight)) (and ($Is |domain#0@@5| Tclass.DomainMod.Domain) (and (DomainMod.Domain.WF |domain#0@@5|) (DomainMod.Domain.Domain_q |domain#0@@5|)))))) (= (PivotBetree.__default.EmptyRoot |domain#0@@5|) (let ((|pivotTable#0| (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (DomainMod.Domain.start |domain#0@@5|))) ($Box (DomainMod.Domain.end |domain#0@@5|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) |pivotTable#0| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|))))))))
 :qid |PivotBetreebrokenidfy.296:22|
 :skolemid |2534|
 :pattern ( (PivotBetree.__default.EmptyRoot |domain#0@@5|))
))))
(assert  (=> (<= 32 $FunctionContextHeight) (forall ((|domain#0@@6| T@U) ) (!  (=> (and (= (type |domain#0@@6|) DatatypeTypeType) (or (|PivotBetree.__default.EmptyRoot#canCall| (Lit |domain#0@@6|)) (and (not (= 32 $FunctionContextHeight)) (and ($Is |domain#0@@6| Tclass.DomainMod.Domain) (and (U_2_bool (Lit (bool_2_U (DomainMod.Domain.WF (Lit |domain#0@@6|))))) (U_2_bool (Lit (bool_2_U (DomainMod.Domain.Domain_q (Lit |domain#0@@6|)))))))))) (= (PivotBetree.__default.EmptyRoot (Lit |domain#0@@6|)) (let ((|pivotTable#1| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (DomainMod.Domain.start (Lit |domain#0@@6|))))) ($Box (Lit (DomainMod.Domain.end (Lit |domain#0@@6|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Empty| BoxType)))) |pivotTable#1| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit |#PivotBetree.BetreeNode.Nil|)))))))))
 :qid |PivotBetreebrokenidfy.296:22|
 :weight 3
 :skolemid |2535|
 :pattern ( (PivotBetree.__default.EmptyRoot (Lit |domain#0@@6|)))
))))
(assert (= (type PivotBetree.__default.EmptyImage) DatatypeTypeType))
(assert  (=> (<= 66 $FunctionContextHeight) (=> (or |PivotBetree.__default.EmptyImage#canCall| (not (= 66 $FunctionContextHeight))) ($Is PivotBetree.__default.EmptyImage (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))))
(assert (= |PivotBetree.__default.EmptyImage#requires| true))
(assert (forall ((arg0@@440 T@U) (arg1@@177 Int) ) (! (= (type (|#StampedMod.Stamped.Stamped| arg0@@440 arg1@@177)) DatatypeTypeType)
 :qid |funType:#StampedMod.Stamped.Stamped|
 :pattern ( (|#StampedMod.Stamped.Stamped| arg0@@440 arg1@@177))
)))
(assert  (=> (<= 66 $FunctionContextHeight) (=> (or |PivotBetree.__default.EmptyImage#canCall| (not (= 66 $FunctionContextHeight))) (= PivotBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PivotBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert  (=> (<= 66 $FunctionContextHeight) (=> (or |PivotBetree.__default.EmptyImage#canCall| (not (= 66 $FunctionContextHeight))) (= PivotBetree.__default.EmptyImage (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit |#PivotBetree.BetreeNode.Nil|)) (LitInt 0)))))))
(assert (forall ((arg0@@441 T@U) (arg1@@178 T@U) ) (! (= (type (PivotBetree.__default.PushMemtable arg0@@441 arg1@@178)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.PushMemtable|
 :pattern ( (PivotBetree.__default.PushMemtable arg0@@441 arg1@@178))
)))
(assert  (=> (<= 67 $FunctionContextHeight) (forall ((|root#0@@3| T@U) (|memtable#0| T@U) ) (!  (=> (and (and (= (type |root#0@@3|) DatatypeTypeType) (= (type |memtable#0|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| |root#0@@3| |memtable#0|) (and (not (= 67 $FunctionContextHeight)) (and (and ($Is |root#0@@3| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0| Tclass.MemtableMod.Memtable)) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@3|))))) ($Is (PivotBetree.__default.PushMemtable |root#0@@3| |memtable#0|) (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))
 :qid |PivotBetreebrokenidfy.399:25|
 :skolemid |2543|
 :pattern ( (PivotBetree.__default.PushMemtable |root#0@@3| |memtable#0|))
))))
(assert (forall ((|root#0@@4| T@U) (|memtable#0@@0| T@U) ) (!  (=> (and (and (= (type |root#0@@4|) DatatypeTypeType) (= (type |memtable#0@@0|) DatatypeTypeType)) (and ($Is |root#0@@4| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@0| Tclass.MemtableMod.Memtable))) (= (|PivotBetree.__default.PushMemtable#requires| |root#0@@4| |memtable#0@@0|) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@4|)))
 :qid |PivotBetreebrokenidfy.399:25|
 :skolemid |2544|
 :pattern ( (|PivotBetree.__default.PushMemtable#requires| |root#0@@4| |memtable#0@@0|))
)))
(assert  (and (and (forall ((arg0@@442 T@U) ) (! (= (type (|#Buffers.Buffer.Buffer| arg0@@442)) DatatypeTypeType)
 :qid |funType:#Buffers.Buffer.Buffer|
 :pattern ( (|#Buffers.Buffer.Buffer| arg0@@442))
)) (forall ((arg0@@443 T@U) ) (! (= (type (MemtableMod.Memtable.mapp arg0@@443)) (MapType BoxType BoxType))
 :qid |funType:MemtableMod.Memtable.mapp|
 :pattern ( (MemtableMod.Memtable.mapp arg0@@443))
))) (= (type DomainMod.__default.TotalDomain) DatatypeTypeType)))
(assert  (=> (<= 67 $FunctionContextHeight) (forall ((|root#0@@5| T@U) (|memtable#0@@1| T@U) ) (!  (=> (and (and (= (type |root#0@@5|) DatatypeTypeType) (= (type |memtable#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| |root#0@@5| |memtable#0@@1|) (and (not (= 67 $FunctionContextHeight)) (and (and ($Is |root#0@@5| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@1| Tclass.MemtableMod.Memtable)) (PivotBetree.BetreeNode.WF ($LS $LZ) |root#0@@5|))))) (and (and (MemtableMod.Memtable.Memtable_q |memtable#0@@1|) (let ((|newBuffer#0| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@1|))))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.BetreeNode.Promote#canCall| |root#0@@5| (Lit DomainMod.__default.TotalDomain))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (PivotBetree.BetreeNode.Promote |root#0@@5| (Lit DomainMod.__default.TotalDomain)) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0|))))) (MemtableMod.Memtable.Memtable_q |memtable#0@@1|)))) (= (PivotBetree.__default.PushMemtable |root#0@@5| |memtable#0@@1|) (let ((|newBuffer#0@@0| (|#Buffers.Buffer.Buffer| (MemtableMod.Memtable.mapp |memtable#0@@1|))))
(|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.BetreeNode.PushBufferStack (PivotBetree.BetreeNode.Promote |root#0@@5| (Lit DomainMod.__default.TotalDomain)) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#0@@0|))))) (MemtableMod.Memtable.seqEnd |memtable#0@@1|))))))
 :qid |PivotBetreebrokenidfy.399:25|
 :skolemid |2545|
 :pattern ( (PivotBetree.__default.PushMemtable |root#0@@5| |memtable#0@@1|))
))))
(assert  (=> (<= 67 $FunctionContextHeight) (forall ((|root#0@@6| T@U) (|memtable#0@@2| T@U) ) (!  (=> (and (and (= (type |root#0@@6|) DatatypeTypeType) (= (type |memtable#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.PushMemtable#canCall| (Lit |root#0@@6|) (Lit |memtable#0@@2|)) (and (not (= 67 $FunctionContextHeight)) (and (and ($Is |root#0@@6| Tclass.PivotBetree.BetreeNode) ($Is |memtable#0@@2| Tclass.MemtableMod.Memtable)) (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit |root#0@@6|))))))))) (and (and (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@2|)) (let ((|newBuffer#1| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@2|)))))))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.BetreeNode.Promote#canCall| (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (|PivotBetree.BetreeNode.PushBufferStack#canCall| (Lit (PivotBetree.BetreeNode.Promote (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (|#Buffers.BufferStack.BufferStack| (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1|))))) (MemtableMod.Memtable.Memtable_q (Lit |memtable#0@@2|))))) (= (PivotBetree.__default.PushMemtable (Lit |root#0@@6|) (Lit |memtable#0@@2|)) (let ((|newBuffer#1@@0| (Lit (|#Buffers.Buffer.Buffer| (Lit (MemtableMod.Memtable.mapp (Lit |memtable#0@@2|)))))))
(Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.BetreeNode.PushBufferStack (Lit (PivotBetree.BetreeNode.Promote (Lit |root#0@@6|) (Lit DomainMod.__default.TotalDomain))) (Lit (|#Buffers.BufferStack.BufferStack| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box |newBuffer#1@@0|)))))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit |memtable#0@@2|)))))))))
 :qid |PivotBetreebrokenidfy.399:25|
 :weight 3
 :skolemid |2546|
 :pattern ( (PivotBetree.__default.PushMemtable (Lit |root#0@@6|) (Lit |memtable#0@@2|)))
))))
(assert (= (type Tclass.Buffers.Buffer) TyType))
(assert (= (Tag Tclass.Buffers.Buffer) Tagclass.Buffers.Buffer))
(assert (= (TagFamily Tclass.Buffers.Buffer) tytagFamily$Buffer))
(assert (forall ((bx@@125 T@U) ) (!  (=> (and (= (type bx@@125) BoxType) ($IsBox bx@@125 Tclass.Buffers.Buffer)) (and (= ($Box ($Unbox DatatypeTypeType bx@@125)) bx@@125) ($Is ($Unbox DatatypeTypeType bx@@125) Tclass.Buffers.Buffer)))
 :qid |unknown.0:0|
 :skolemid |2548|
 :pattern ( ($IsBox bx@@125 Tclass.Buffers.Buffer))
)))
(assert  (=> (<= 68 $FunctionContextHeight) (forall ((|v#0| T@U) (|v'#0| T@U) (|lbl#0| T@U) (|receipt#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |v#0|) DatatypeTypeType) (= (type |v'#0|) DatatypeTypeType)) (= (type |lbl#0|) DatatypeTypeType)) (= (type |receipt#0@@0|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| |v#0| |v'#0| |lbl#0| |receipt#0@@0|) (and (not (= 68 $FunctionContextHeight)) (and (and (and ($Is |v#0| Tclass.PivotBetree.Variables) ($Is |v'#0| Tclass.PivotBetree.Variables)) ($Is |lbl#0| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@0| Tclass.PivotBetree.QueryReceipt))))) true)
 :qid |PivotBetreebrokenidfy.415:19|
 :skolemid |2564|
 :pattern ( (PivotBetree.__default.Query |v#0| |v'#0| |lbl#0| |receipt#0@@0|))
))))
(assert (forall ((|v#0@@0| T@U) (|v'#0@@0| T@U) (|lbl#0@@0| T@U) (|receipt#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@0|) DatatypeTypeType) (= (type |v'#0@@0|) DatatypeTypeType)) (= (type |lbl#0@@0|) DatatypeTypeType)) (= (type |receipt#0@@1|) DatatypeTypeType)) (and (and (and ($Is |v#0@@0| Tclass.PivotBetree.Variables) ($Is |v'#0@@0| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@0| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@1| Tclass.PivotBetree.QueryReceipt))) (= (|PivotBetree.__default.Query#requires| |v#0@@0| |v'#0@@0| |lbl#0@@0| |receipt#0@@1|) true))
 :qid |PivotBetreebrokenidfy.415:19|
 :skolemid |2565|
 :pattern ( (|PivotBetree.__default.Query#requires| |v#0@@0| |v'#0@@0| |lbl#0@@0| |receipt#0@@1|))
)))
(assert (forall ((arg0@@444 T@U) (arg1@@179 T@U) ) (! (= (type (MemtableMod.Memtable.Query arg0@@444 arg1@@179)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Query|
 :pattern ( (MemtableMod.Memtable.Query arg0@@444 arg1@@179))
)))
(assert  (=> (<= 68 $FunctionContextHeight) (forall ((|v#0@@1| T@U) (|v'#0@@1| T@U) (|lbl#0@@1| T@U) (|receipt#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@1|) DatatypeTypeType) (= (type |v'#0@@1|) DatatypeTypeType)) (= (type |lbl#0@@1|) DatatypeTypeType)) (= (type |receipt#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| |v#0@@1| |v'#0@@1| |lbl#0@@1| |receipt#0@@2|) (and (not (= 68 $FunctionContextHeight)) (and (and (and ($Is |v#0@@1| Tclass.PivotBetree.Variables) ($Is |v'#0@@1| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@1| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@2| Tclass.PivotBetree.QueryReceipt))))) (and (=> (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@1|) (and (and (PivotBetree.Variables.Variables_q |v#0@@1|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@1|))) (=> (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@1|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@1|))) (and (and (PivotBetree.Variables.Variables_q |v#0@@1|) (|PivotBetree.QueryReceipt.ValidFor#canCall| |receipt#0@@2| (PivotBetree.Variables.root |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|))) (=> (PivotBetree.QueryReceipt.ValidFor |receipt#0@@2| (PivotBetree.Variables.root |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|)) (and (and (|$IsA#ValueMessage.Message| (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|)) (PivotBetree.QueryReceipt.Result |receipt#0@@2|))) (and (and (and (PivotBetree.Variables.Variables_q |v#0@@1|) (|MemtableMod.Memtable.Query#canCall| (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|))) (|PivotBetree.QueryReceipt.Result#canCall| |receipt#0@@2|)) (|ValueMessage.__default.Merge#canCall| (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|)) (PivotBetree.QueryReceipt.Result |receipt#0@@2|)))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PivotBetree.TransitionLabel.value |lbl#0@@1|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|)) (PivotBetree.QueryReceipt.Result |receipt#0@@2|))) (and (|$IsA#PivotBetree.Variables| |v'#0@@1|) (|$IsA#PivotBetree.Variables| |v#0@@1|))))))))) (= (PivotBetree.__default.Query |v#0@@1| |v'#0@@1| |lbl#0@@1| |receipt#0@@2|)  (and (and (and (and (PivotBetree.TransitionLabel.QueryLabel_q |lbl#0@@1|) (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@1|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@1|)))) (PivotBetree.QueryReceipt.ValidFor |receipt#0@@2| (PivotBetree.Variables.root |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (PivotBetree.TransitionLabel.value |lbl#0@@1|)) (ValueMessage.__default.Merge (MemtableMod.Memtable.Query (PivotBetree.Variables.memtable |v#0@@1|) (PivotBetree.TransitionLabel.key |lbl#0@@1|)) (PivotBetree.QueryReceipt.Result |receipt#0@@2|)))) (|PivotBetree.Variables#Equal| |v'#0@@1| |v#0@@1|)))))
 :qid |PivotBetreebrokenidfy.415:19|
 :skolemid |2566|
 :pattern ( (PivotBetree.__default.Query |v#0@@1| |v'#0@@1| |lbl#0@@1| |receipt#0@@2|))
))))
(assert  (=> (<= 68 $FunctionContextHeight) (forall ((|v#0@@2| T@U) (|v'#0@@2| T@U) (|lbl#0@@2| T@U) (|receipt#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@2|) DatatypeTypeType) (= (type |v'#0@@2|) DatatypeTypeType)) (= (type |lbl#0@@2|) DatatypeTypeType)) (= (type |receipt#0@@3|) DatatypeTypeType)) (or (|PivotBetree.__default.Query#canCall| (Lit |v#0@@2|) (Lit |v'#0@@2|) (Lit |lbl#0@@2|) (Lit |receipt#0@@3|)) (and (not (= 68 $FunctionContextHeight)) (and (and (and ($Is |v#0@@2| Tclass.PivotBetree.Variables) ($Is |v'#0@@2| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@2| Tclass.PivotBetree.TransitionLabel)) ($Is |receipt#0@@3| Tclass.PivotBetree.QueryReceipt))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@2|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@2|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))))) (=> (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@2|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|)))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@2|)) (|PivotBetree.QueryReceipt.ValidFor#canCall| (Lit |receipt#0@@3|) (Lit (PivotBetree.Variables.root (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.QueryReceipt.ValidFor (Lit |receipt#0@@3|) (Lit (PivotBetree.Variables.root (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))))) (and (and (|$IsA#ValueMessage.Message| (Lit (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@3|)))))) (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@2|)) (|MemtableMod.Memtable.Query#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (|PivotBetree.QueryReceipt.Result#canCall| (Lit |receipt#0@@3|))) (|ValueMessage.__default.Merge#canCall| (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@3|)))))) (=> (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PivotBetree.TransitionLabel.value (Lit |lbl#0@@2|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@3|))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@2|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@2|)))))))))) (= (PivotBetree.__default.Query (Lit |v#0@@2|) (Lit |v'#0@@2|) (Lit |lbl#0@@2|) (Lit |receipt#0@@3|))  (and (and (and (and (PivotBetree.TransitionLabel.QueryLabel_q (Lit |lbl#0@@2|)) (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@2|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))))))) (PivotBetree.QueryReceipt.ValidFor (Lit |receipt#0@@3|) (Lit (PivotBetree.Variables.root (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (|ValueMessage.Message#Equal| (|#ValueMessage.Message.Define| (Lit (PivotBetree.TransitionLabel.value (Lit |lbl#0@@2|)))) (ValueMessage.__default.Merge (Lit (MemtableMod.Memtable.Query (Lit (PivotBetree.Variables.memtable (Lit |v#0@@2|))) (Lit (PivotBetree.TransitionLabel.key (Lit |lbl#0@@2|))))) (Lit (PivotBetree.QueryReceipt.Result (Lit |receipt#0@@3|)))))) (|PivotBetree.Variables#Equal| |v'#0@@2| |v#0@@2|)))))
 :qid |PivotBetreebrokenidfy.415:19|
 :weight 3
 :skolemid |2567|
 :pattern ( (PivotBetree.__default.Query (Lit |v#0@@2|) (Lit |v'#0@@2|) (Lit |lbl#0@@2|) (Lit |receipt#0@@3|)))
))))
(assert  (=> (<= 69 $FunctionContextHeight) (forall ((|v#0@@3| T@U) (|v'#0@@3| T@U) (|lbl#0@@3| T@U) ) (!  (=> (and (and (and (= (type |v#0@@3|) DatatypeTypeType) (= (type |v'#0@@3|) DatatypeTypeType)) (= (type |lbl#0@@3|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| |v#0@@3| |v'#0@@3| |lbl#0@@3|) (and (not (= 69 $FunctionContextHeight)) (and (and ($Is |v#0@@3| Tclass.PivotBetree.Variables) ($Is |v'#0@@3| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@3| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.424:17|
 :skolemid |2574|
 :pattern ( (PivotBetree.__default.Put |v#0@@3| |v'#0@@3| |lbl#0@@3|))
))))
(assert (forall ((|v#0@@4| T@U) (|v'#0@@4| T@U) (|lbl#0@@4| T@U) ) (!  (=> (and (and (and (= (type |v#0@@4|) DatatypeTypeType) (= (type |v'#0@@4|) DatatypeTypeType)) (= (type |lbl#0@@4|) DatatypeTypeType)) (and (and ($Is |v#0@@4| Tclass.PivotBetree.Variables) ($Is |v'#0@@4| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@4| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.Put#requires| |v#0@@4| |v'#0@@4| |lbl#0@@4|) true))
 :qid |PivotBetreebrokenidfy.424:17|
 :skolemid |2575|
 :pattern ( (|PivotBetree.__default.Put#requires| |v#0@@4| |v'#0@@4| |lbl#0@@4|))
)))
(assert (forall ((arg0@@445 T@U) (arg1@@180 T@U) (arg2@@87 T@U) ) (! (= (type (MemtableMod.Memtable.ApplyPuts arg0@@445 arg1@@180 arg2@@87)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.ApplyPuts|
 :pattern ( (MemtableMod.Memtable.ApplyPuts arg0@@445 arg1@@180 arg2@@87))
)))
(assert  (=> (<= 69 $FunctionContextHeight) (forall ((|v#0@@5| T@U) (|v'#0@@5| T@U) (|lbl#0@@5| T@U) ) (!  (=> (and (and (and (= (type |v#0@@5|) DatatypeTypeType) (= (type |v'#0@@5|) DatatypeTypeType)) (= (type |lbl#0@@5|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| |v#0@@5| |v'#0@@5| |lbl#0@@5|) (and (not (= 69 $FunctionContextHeight)) (and (and ($Is |v#0@@5| Tclass.PivotBetree.Variables) ($Is |v'#0@@5| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@5| Tclass.PivotBetree.TransitionLabel))))) (and (=> (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@5|) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (PivotBetree.TransitionLabel.puts |lbl#0@@5|)) (=> (MsgHistoryMod.MsgHistory.WF (PivotBetree.TransitionLabel.puts |lbl#0@@5|)) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (PivotBetree.TransitionLabel.puts |lbl#0@@5|)) (and (PivotBetree.Variables.Variables_q |v#0@@5|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@5|)))) (=> (= (MsgHistoryMod.MsgHistory.seqStart (PivotBetree.TransitionLabel.puts |lbl#0@@5|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@5|))) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@5|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0| |v#0@@5|))
(let ((|dt_update#memtable#0#0| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PivotBetree.Variables.memtable |v#0@@5|) (PivotBetree.TransitionLabel.puts |lbl#0@@5|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0| (PivotBetree.Variables.root |dt_update_tmp#0#0|)))))) (let ((|dt_update_tmp#0#0@@0| |v#0@@5|))
 (and (and (PivotBetree.Variables.Variables_q |v#0@@5|) (|MemtableMod.Memtable.ApplyPuts#canCall| (PivotBetree.Variables.memtable |v#0@@5|) (PivotBetree.TransitionLabel.puts |lbl#0@@5|))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@0|))))))))) (= (PivotBetree.__default.Put |v#0@@5| |v'#0@@5| |lbl#0@@5|)  (and (and (and (PivotBetree.TransitionLabel.PutLabel_q |lbl#0@@5|) (MsgHistoryMod.MsgHistory.WF (PivotBetree.TransitionLabel.puts |lbl#0@@5|))) (= (MsgHistoryMod.MsgHistory.seqStart (PivotBetree.TransitionLabel.puts |lbl#0@@5|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@5|)))) (|PivotBetree.Variables#Equal| |v'#0@@5| (let ((|dt_update_tmp#0#0@@1| |v#0@@5|))
(let ((|dt_update#memtable#0#0@@0| (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (PivotBetree.Variables.memtable |v#0@@5|) (PivotBetree.TransitionLabel.puts |lbl#0@@5|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@0| (PivotBetree.Variables.root |dt_update_tmp#0#0@@1|)))))))))
 :qid |PivotBetreebrokenidfy.424:17|
 :skolemid |2576|
 :pattern ( (PivotBetree.__default.Put |v#0@@5| |v'#0@@5| |lbl#0@@5|))
))))
(assert  (=> (<= 69 $FunctionContextHeight) (forall ((|v#0@@6| T@U) (|v'#0@@6| T@U) (|lbl#0@@6| T@U) ) (!  (=> (and (and (and (= (type |v#0@@6|) DatatypeTypeType) (= (type |v'#0@@6|) DatatypeTypeType)) (= (type |lbl#0@@6|) DatatypeTypeType)) (or (|PivotBetree.__default.Put#canCall| (Lit |v#0@@6|) (Lit |v'#0@@6|) (Lit |lbl#0@@6|)) (and (not (= 69 $FunctionContextHeight)) (and (and ($Is |v#0@@6| Tclass.PivotBetree.Variables) ($Is |v'#0@@6| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@6| Tclass.PivotBetree.TransitionLabel))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@6|))))) (and (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|)))) (=> (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|)))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@6|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|)))))) (=> (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|)))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@6|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1| (Lit |v#0@@6|)))
(let ((|dt_update#memtable#0#1| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1| (Lit (PivotBetree.Variables.root |dt_update_tmp#0#1|)))))))) (let ((|dt_update_tmp#0#1@@0| (Lit |v#0@@6|)))
 (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@6|)) (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@0|))))))))) (= (PivotBetree.__default.Put (Lit |v#0@@6|) (Lit |v'#0@@6|) (Lit |lbl#0@@6|))  (and (and (and (PivotBetree.TransitionLabel.PutLabel_q (Lit |lbl#0@@6|)) (MsgHistoryMod.MsgHistory.WF (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|))))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|))))))) (|PivotBetree.Variables#Equal| |v'#0@@6| (let ((|dt_update_tmp#0#1@@1| (Lit |v#0@@6|)))
(let ((|dt_update#memtable#0#1@@0| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $LZ) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@6|))) (Lit (PivotBetree.TransitionLabel.puts (Lit |lbl#0@@6|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@0| (Lit (PivotBetree.Variables.root |dt_update_tmp#0#1@@1|)))))))))))
 :qid |PivotBetreebrokenidfy.424:17|
 :weight 3
 :skolemid |2577|
 :pattern ( (PivotBetree.__default.Put (Lit |v#0@@6|) (Lit |v'#0@@6|) (Lit |lbl#0@@6|)))
))))
(assert  (=> (<= 70 $FunctionContextHeight) (forall ((|v#0@@7| T@U) (|v'#0@@7| T@U) (|lbl#0@@7| T@U) ) (!  (=> (and (and (and (= (type |v#0@@7|) DatatypeTypeType) (= (type |v'#0@@7|) DatatypeTypeType)) (= (type |lbl#0@@7|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@7| |v'#0@@7| |lbl#0@@7|) (and (not (= 70 $FunctionContextHeight)) (and (and ($Is |v#0@@7| Tclass.PivotBetree.Variables) ($Is |v'#0@@7| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@7| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.434:25|
 :skolemid |2582|
 :pattern ( (PivotBetree.__default.QueryEndLsn |v#0@@7| |v'#0@@7| |lbl#0@@7|))
))))
(assert (forall ((|v#0@@8| T@U) (|v'#0@@8| T@U) (|lbl#0@@8| T@U) ) (!  (=> (and (and (and (= (type |v#0@@8|) DatatypeTypeType) (= (type |v'#0@@8|) DatatypeTypeType)) (= (type |lbl#0@@8|) DatatypeTypeType)) (and (and ($Is |v#0@@8| Tclass.PivotBetree.Variables) ($Is |v'#0@@8| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@8| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.QueryEndLsn#requires| |v#0@@8| |v'#0@@8| |lbl#0@@8|) true))
 :qid |PivotBetreebrokenidfy.434:25|
 :skolemid |2583|
 :pattern ( (|PivotBetree.__default.QueryEndLsn#requires| |v#0@@8| |v'#0@@8| |lbl#0@@8|))
)))
(assert  (=> (<= 70 $FunctionContextHeight) (forall ((|v#0@@9| T@U) (|v'#0@@9| T@U) (|lbl#0@@9| T@U) ) (!  (=> (and (and (and (= (type |v#0@@9|) DatatypeTypeType) (= (type |v'#0@@9|) DatatypeTypeType)) (= (type |lbl#0@@9|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@9| |v'#0@@9| |lbl#0@@9|) (and (not (= 70 $FunctionContextHeight)) (and (and ($Is |v#0@@9| Tclass.PivotBetree.Variables) ($Is |v'#0@@9| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@9| Tclass.PivotBetree.TransitionLabel))))) (and (=> (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@9|) (and (and (PivotBetree.Variables.Variables_q |v#0@@9|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@9|))) (=> (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@9|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@9|))) (and (|$IsA#PivotBetree.Variables| |v'#0@@9|) (|$IsA#PivotBetree.Variables| |v#0@@9|))))) (= (PivotBetree.__default.QueryEndLsn |v#0@@9| |v'#0@@9| |lbl#0@@9|)  (and (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q |lbl#0@@9|) (= (PivotBetree.TransitionLabel.endLsn |lbl#0@@9|) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@9|)))) (|PivotBetree.Variables#Equal| |v'#0@@9| |v#0@@9|)))))
 :qid |PivotBetreebrokenidfy.434:25|
 :skolemid |2584|
 :pattern ( (PivotBetree.__default.QueryEndLsn |v#0@@9| |v'#0@@9| |lbl#0@@9|))
))))
(assert  (=> (<= 70 $FunctionContextHeight) (forall ((|v#0@@10| T@U) (|v'#0@@10| T@U) (|lbl#0@@10| T@U) ) (!  (=> (and (and (and (= (type |v#0@@10|) DatatypeTypeType) (= (type |v'#0@@10|) DatatypeTypeType)) (= (type |lbl#0@@10|) DatatypeTypeType)) (or (|PivotBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@10|) (Lit |v'#0@@10|) (Lit |lbl#0@@10|)) (and (not (= 70 $FunctionContextHeight)) (and (and ($Is |v#0@@10| Tclass.PivotBetree.Variables) ($Is |v'#0@@10| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@10| Tclass.PivotBetree.TransitionLabel))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@10|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@10|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@10|))))) (=> (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@10|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@10|)))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@10|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@10|)))))) (= (PivotBetree.__default.QueryEndLsn (Lit |v#0@@10|) (Lit |v'#0@@10|) (Lit |lbl#0@@10|))  (and (and (PivotBetree.TransitionLabel.QueryEndLsnLabel_q (Lit |lbl#0@@10|)) (= (LitInt (PivotBetree.TransitionLabel.endLsn (Lit |lbl#0@@10|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@10|))))))) (|PivotBetree.Variables#Equal| |v'#0@@10| |v#0@@10|)))))
 :qid |PivotBetreebrokenidfy.434:25|
 :weight 3
 :skolemid |2585|
 :pattern ( (PivotBetree.__default.QueryEndLsn (Lit |v#0@@10|) (Lit |v'#0@@10|) (Lit |lbl#0@@10|)))
))))
(assert  (=> (<= 72 $FunctionContextHeight) (forall ((|v#0@@11| T@U) (|v'#0@@11| T@U) (|lbl#0@@11| T@U) ) (!  (=> (and (and (and (= (type |v#0@@11|) DatatypeTypeType) (= (type |v'#0@@11|) DatatypeTypeType)) (= (type |lbl#0@@11|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| |v#0@@11| |v'#0@@11| |lbl#0@@11|) (and (not (= 72 $FunctionContextHeight)) (and (and ($Is |v#0@@11| Tclass.PivotBetree.Variables) ($Is |v'#0@@11| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@11| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.441:22|
 :skolemid |2586|
 :pattern ( (PivotBetree.__default.FreezeAs |v#0@@11| |v'#0@@11| |lbl#0@@11|))
))))
(assert (forall ((|v#0@@12| T@U) (|v'#0@@12| T@U) (|lbl#0@@12| T@U) ) (!  (=> (and (and (and (= (type |v#0@@12|) DatatypeTypeType) (= (type |v'#0@@12|) DatatypeTypeType)) (= (type |lbl#0@@12|) DatatypeTypeType)) (and (and ($Is |v#0@@12| Tclass.PivotBetree.Variables) ($Is |v'#0@@12| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@12| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.FreezeAs#requires| |v#0@@12| |v'#0@@12| |lbl#0@@12|) true))
 :qid |PivotBetreebrokenidfy.441:22|
 :skolemid |2587|
 :pattern ( (|PivotBetree.__default.FreezeAs#requires| |v#0@@12| |v'#0@@12| |lbl#0@@12|))
)))
(assert  (=> (<= 72 $FunctionContextHeight) (forall ((|v#0@@13| T@U) (|v'#0@@13| T@U) (|lbl#0@@13| T@U) ) (!  (=> (and (and (and (= (type |v#0@@13|) DatatypeTypeType) (= (type |v'#0@@13|) DatatypeTypeType)) (= (type |lbl#0@@13|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| |v#0@@13| |v'#0@@13| |lbl#0@@13|) (and (not (= 72 $FunctionContextHeight)) (and (and ($Is |v#0@@13| Tclass.PivotBetree.Variables) ($Is |v'#0@@13| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@13| Tclass.PivotBetree.TransitionLabel))))) (and (=> (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@13|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@13|) (=> (PivotBetree.Variables.WF |v#0@@13|) (and (and (PivotBetree.Variables.Variables_q |v#0@@13|) (|MemtableMod.Memtable.IsEmpty#canCall| (PivotBetree.Variables.memtable |v#0@@13|))) (=> (MemtableMod.Memtable.IsEmpty (PivotBetree.Variables.memtable |v#0@@13|)) (and (and (|$IsA#StampedMod.Stamped| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@13|)) (and (PivotBetree.Variables.Variables_q |v#0@@13|) (and (PivotBetree.Variables.Variables_q |v#0@@13|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@13|))))) (=> (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@13|) (|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.Variables.root |v#0@@13|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@13|)))) (and (|$IsA#PivotBetree.Variables| |v'#0@@13|) (|$IsA#PivotBetree.Variables| |v#0@@13|))))))))) (= (PivotBetree.__default.FreezeAs |v#0@@13| |v'#0@@13| |lbl#0@@13|)  (and (and (and (and (PivotBetree.TransitionLabel.FreezeAsLabel_q |lbl#0@@13|) (PivotBetree.Variables.WF |v#0@@13|)) (MemtableMod.Memtable.IsEmpty (PivotBetree.Variables.memtable |v#0@@13|))) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree |lbl#0@@13|) (|#StampedMod.Stamped.Stamped| ($Box (PivotBetree.Variables.root |v#0@@13|)) (MemtableMod.Memtable.seqEnd (PivotBetree.Variables.memtable |v#0@@13|))))) (|PivotBetree.Variables#Equal| |v'#0@@13| |v#0@@13|)))))
 :qid |PivotBetreebrokenidfy.441:22|
 :skolemid |2588|
 :pattern ( (PivotBetree.__default.FreezeAs |v#0@@13| |v'#0@@13| |lbl#0@@13|))
))))
(assert  (=> (<= 72 $FunctionContextHeight) (forall ((|v#0@@14| T@U) (|v'#0@@14| T@U) (|lbl#0@@14| T@U) ) (!  (=> (and (and (and (= (type |v#0@@14|) DatatypeTypeType) (= (type |v'#0@@14|) DatatypeTypeType)) (= (type |lbl#0@@14|) DatatypeTypeType)) (or (|PivotBetree.__default.FreezeAs#canCall| (Lit |v#0@@14|) (Lit |v'#0@@14|) (Lit |lbl#0@@14|)) (and (not (= 72 $FunctionContextHeight)) (and (and ($Is |v#0@@14| Tclass.PivotBetree.Variables) ($Is |v'#0@@14| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@14| Tclass.PivotBetree.TransitionLabel))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@14|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@14|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@14|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@14|)) (|MemtableMod.Memtable.IsEmpty#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|))))) (=> (U_2_bool (Lit (bool_2_U (MemtableMod.Memtable.IsEmpty (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|))))))) (and (and (|$IsA#StampedMod.Stamped| (Lit (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@14|)))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@14|)) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@14|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|))))))) (=> (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@14|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@14|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|))))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@14|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@14|)))))))))) (= (PivotBetree.__default.FreezeAs (Lit |v#0@@14|) (Lit |v'#0@@14|) (Lit |lbl#0@@14|))  (and (and (and (and (PivotBetree.TransitionLabel.FreezeAsLabel_q (Lit |lbl#0@@14|)) (PivotBetree.Variables.WF (Lit |v#0@@14|))) (MemtableMod.Memtable.IsEmpty (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|))))) (|StampedMod.Stamped#Equal| (PivotBetree.TransitionLabel.stampedBetree (Lit |lbl#0@@14|)) (|#StampedMod.Stamped.Stamped| ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@14|)))) (LitInt (MemtableMod.Memtable.seqEnd (Lit (PivotBetree.Variables.memtable (Lit |v#0@@14|)))))))) (|PivotBetree.Variables#Equal| |v'#0@@14| |v#0@@14|)))))
 :qid |PivotBetreebrokenidfy.441:22|
 :weight 3
 :skolemid |2589|
 :pattern ( (PivotBetree.__default.FreezeAs (Lit |v#0@@14|) (Lit |v'#0@@14|) (Lit |lbl#0@@14|)))
))))
(assert  (=> (<= 73 $FunctionContextHeight) (forall ((|v#0@@15| T@U) (|v'#0@@15| T@U) (|lbl#0@@15| T@U) ) (!  (=> (and (and (and (= (type |v#0@@15|) DatatypeTypeType) (= (type |v'#0@@15|) DatatypeTypeType)) (= (type |lbl#0@@15|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@15| |v'#0@@15| |lbl#0@@15|) (and (not (= 73 $FunctionContextHeight)) (and (and ($Is |v#0@@15| Tclass.PivotBetree.Variables) ($Is |v'#0@@15| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@15| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.450:35|
 :skolemid |2592|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable |v#0@@15| |v'#0@@15| |lbl#0@@15|))
))))
(assert (forall ((|v#0@@16| T@U) (|v'#0@@16| T@U) (|lbl#0@@16| T@U) ) (!  (=> (and (and (and (= (type |v#0@@16|) DatatypeTypeType) (= (type |v'#0@@16|) DatatypeTypeType)) (= (type |lbl#0@@16|) DatatypeTypeType)) (and (and ($Is |v#0@@16| Tclass.PivotBetree.Variables) ($Is |v'#0@@16| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@16| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.InternalFlushMemtable#requires| |v#0@@16| |v'#0@@16| |lbl#0@@16|) true))
 :qid |PivotBetreebrokenidfy.450:35|
 :skolemid |2593|
 :pattern ( (|PivotBetree.__default.InternalFlushMemtable#requires| |v#0@@16| |v'#0@@16| |lbl#0@@16|))
)))
(assert  (and (forall ((arg0@@446 T@U) ) (! (= (type (StampedMod.Stamped.value arg0@@446)) BoxType)
 :qid |funType:StampedMod.Stamped.value|
 :pattern ( (StampedMod.Stamped.value arg0@@446))
)) (forall ((arg0@@447 T@U) ) (! (= (type (MemtableMod.Memtable.Drain arg0@@447)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Drain|
 :pattern ( (MemtableMod.Memtable.Drain arg0@@447))
))))
(assert  (=> (<= 73 $FunctionContextHeight) (forall ((|v#0@@17| T@U) (|v'#0@@17| T@U) (|lbl#0@@17| T@U) ) (!  (=> (and (and (and (= (type |v#0@@17|) DatatypeTypeType) (= (type |v'#0@@17|) DatatypeTypeType)) (= (type |lbl#0@@17|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@17| |v'#0@@17| |lbl#0@@17|) (and (not (= 73 $FunctionContextHeight)) (and (and ($Is |v#0@@17| Tclass.PivotBetree.Variables) ($Is |v'#0@@17| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@17| Tclass.PivotBetree.TransitionLabel))))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@17|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@17|) (=> (PivotBetree.Variables.WF |v#0@@17|) (and (and (PivotBetree.Variables.Variables_q |v#0@@17|) (MemtableMod.Memtable.Memtable_q (PivotBetree.Variables.memtable |v#0@@17|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (and (PivotBetree.Variables.Variables_q |v#0@@17|) (=> (PivotBetree.BetreeNode.Nil_q (PivotBetree.Variables.root |v#0@@17|)) (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))))) (=> (not (PivotBetree.BetreeNode.Nil_q (PivotBetree.Variables.root |v#0@@17|))) (PivotBetree.Variables.Variables_q |v#0@@17|))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@17|) (|$IsA#PivotBetree.Variables| (let ((|dt_update#root#0#0| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@17|) (PivotBetree.Variables.memtable |v#0@@17|))))))
(let ((|dt_update#memtable#0#0@@1| (MemtableMod.Memtable.Drain (PivotBetree.Variables.memtable |v#0@@17|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@1| |dt_update#root#0#0|))))) (and (and (and (and (PivotBetree.Variables.Variables_q |v#0@@17|) (PivotBetree.Variables.Variables_q |v#0@@17|)) (|PivotBetree.__default.PushMemtable#canCall| (PivotBetree.Variables.root |v#0@@17|) (PivotBetree.Variables.memtable |v#0@@17|))) (StampedMod.Stamped.Stamped_q (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@17|) (PivotBetree.Variables.memtable |v#0@@17|)))) (and (PivotBetree.Variables.Variables_q |v#0@@17|) (|MemtableMod.Memtable.Drain#canCall| (PivotBetree.Variables.memtable |v#0@@17|)))))))))))) (= (PivotBetree.__default.InternalFlushMemtable |v#0@@17| |v'#0@@17| |lbl#0@@17|)  (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@17|) (PivotBetree.Variables.WF |v#0@@17|)) (and true (and true (|PivotBetree.Variables#Equal| |v'#0@@17| (let ((|dt_update#root#0#0@@0| ($Unbox DatatypeTypeType (StampedMod.Stamped.value (PivotBetree.__default.PushMemtable (PivotBetree.Variables.root |v#0@@17|) (PivotBetree.Variables.memtable |v#0@@17|))))))
(let ((|dt_update#memtable#0#0@@2| (MemtableMod.Memtable.Drain (PivotBetree.Variables.memtable |v#0@@17|))))
(|#PivotBetree.Variables.Variables| |dt_update#memtable#0#0@@2| |dt_update#root#0#0@@0|))))))))))
 :qid |PivotBetreebrokenidfy.450:35|
 :skolemid |2594|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable |v#0@@17| |v'#0@@17| |lbl#0@@17|))
))))
(assert  (=> (<= 73 $FunctionContextHeight) (forall ((|v#0@@18| T@U) (|v'#0@@18| T@U) (|lbl#0@@18| T@U) ) (!  (=> (and (and (and (= (type |v#0@@18|) DatatypeTypeType) (= (type |v'#0@@18|) DatatypeTypeType)) (= (type |lbl#0@@18|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@18|) (Lit |v'#0@@18|) (Lit |lbl#0@@18|)) (and (not (= 73 $FunctionContextHeight)) (and (and ($Is |v#0@@18| Tclass.PivotBetree.Variables) ($Is |v'#0@@18| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@18| Tclass.PivotBetree.TransitionLabel))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@18|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@18|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@18|))))) (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@18|)) (MemtableMod.Memtable.Memtable_q (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|))))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@18|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit (PivotBetree.Variables.root (Lit |v#0@@18|))))))) (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.Nil_q (Lit (PivotBetree.Variables.root (Lit |v#0@@18|)))))))) (PivotBetree.Variables.Variables_q (Lit |v#0@@18|)))) (=> (U_2_bool (Lit (bool_2_U true))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@18|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update#root#0#1| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@18|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|))))))))))
(let ((|dt_update#memtable#0#1@@1| (Lit (MemtableMod.Memtable.Drain (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@1| |dt_update#root#0#1|)))))) (and (and (and (and (PivotBetree.Variables.Variables_q (Lit |v#0@@18|)) (PivotBetree.Variables.Variables_q (Lit |v#0@@18|))) (|PivotBetree.__default.PushMemtable#canCall| (Lit (PivotBetree.Variables.root (Lit |v#0@@18|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|))))) (StampedMod.Stamped.Stamped_q (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@18|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|))))))) (and (PivotBetree.Variables.Variables_q (Lit |v#0@@18|)) (|MemtableMod.Memtable.Drain#canCall| (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|)))))))))))))) (= (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@18|) (Lit |v'#0@@18|) (Lit |lbl#0@@18|))  (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@18|)) (PivotBetree.Variables.WF (Lit |v#0@@18|))) (and true (and true (|PivotBetree.Variables#Equal| |v'#0@@18| (let ((|dt_update#root#0#1@@0| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit (PivotBetree.__default.PushMemtable (Lit (PivotBetree.Variables.root (Lit |v#0@@18|))) (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|))))))))))
(let ((|dt_update#memtable#0#1@@2| (Lit (MemtableMod.Memtable.Drain (Lit (PivotBetree.Variables.memtable (Lit |v#0@@18|)))))))
(Lit (|#PivotBetree.Variables.Variables| |dt_update#memtable#0#1@@2| |dt_update#root#0#1@@0|)))))))))))
 :qid |PivotBetreebrokenidfy.450:35|
 :weight 3
 :skolemid |2595|
 :pattern ( (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@18|) (Lit |v'#0@@18|) (Lit |lbl#0@@18|)))
))))
(assert  (=> (<= 74 $FunctionContextHeight) (forall ((|v#0@@19| T@U) (|v'#0@@19| T@U) (|lbl#0@@19| T@U) (|step#0| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@19|) DatatypeTypeType) (= (type |v'#0@@19|) DatatypeTypeType)) (= (type |lbl#0@@19|) DatatypeTypeType)) (= (type |step#0|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| |v#0@@19| |v'#0@@19| |lbl#0@@19| |step#0|) (and (not (= 74 $FunctionContextHeight)) (and (and (and ($Is |v#0@@19| Tclass.PivotBetree.Variables) ($Is |v'#0@@19| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@19| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0| Tclass.PivotBetree.Step))))) true)
 :qid |PivotBetreebrokenidfy.539:26|
 :skolemid |2607|
 :pattern ( (PivotBetree.__default.InternalGrow |v#0@@19| |v'#0@@19| |lbl#0@@19| |step#0|))
))))
(assert (forall ((|v#0@@20| T@U) (|v'#0@@20| T@U) (|lbl#0@@20| T@U) (|step#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@20|) DatatypeTypeType) (= (type |v'#0@@20|) DatatypeTypeType)) (= (type |lbl#0@@20|) DatatypeTypeType)) (= (type |step#0@@0|) DatatypeTypeType)) (and (and (and ($Is |v#0@@20| Tclass.PivotBetree.Variables) ($Is |v'#0@@20| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@20| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@0| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalGrow#requires| |v#0@@20| |v'#0@@20| |lbl#0@@20| |step#0@@0|) true))
 :qid |PivotBetreebrokenidfy.539:26|
 :skolemid |2608|
 :pattern ( (|PivotBetree.__default.InternalGrow#requires| |v#0@@20| |v'#0@@20| |lbl#0@@20| |step#0@@0|))
)))
(assert  (=> (<= 74 $FunctionContextHeight) (forall ((|v#0@@21| T@U) (|v'#0@@21| T@U) (|lbl#0@@21| T@U) (|step#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@21|) DatatypeTypeType) (= (type |v'#0@@21|) DatatypeTypeType)) (= (type |lbl#0@@21|) DatatypeTypeType)) (= (type |step#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| |v#0@@21| |v'#0@@21| |lbl#0@@21| |step#0@@1|) (and (not (= 74 $FunctionContextHeight)) (and (and (and ($Is |v#0@@21| Tclass.PivotBetree.Variables) ($Is |v'#0@@21| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@21| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@1| Tclass.PivotBetree.Step))))) (and (and (|PivotBetree.Variables.WF#canCall| |v#0@@21|) (=> (PivotBetree.Variables.WF |v#0@@21|) (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@21|) (=> (PivotBetree.Step.InternalGrowStep_q |step#0@@1|) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@21|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@2| |v#0@@21|))
(let ((|dt_update#root#0#0@@1| (let ((|dt_update_tmp#1#0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#0| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (PivotBetree.Variables.root |v#0@@21|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#0|)) |dt_update#children#0#0|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@2|) |dt_update#root#0#0@@1|))))) (let ((|dt_update_tmp#0#0@@3| |v#0@@21|))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))) (PivotBetree.Variables.Variables_q |v#0@@21|)) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@3|)))))))) (= (PivotBetree.__default.InternalGrow |v#0@@21| |v'#0@@21| |lbl#0@@21| |step#0@@1|)  (and (and (and (PivotBetree.Variables.WF |v#0@@21|) (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@21|)) (PivotBetree.Step.InternalGrowStep_q |step#0@@1|)) (|PivotBetree.Variables#Equal| |v'#0@@21| (let ((|dt_update_tmp#0#0@@4| |v#0@@21|))
(let ((|dt_update#root#0#0@@2| (let ((|dt_update_tmp#1#0@@0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#0@@0| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (PivotBetree.Variables.root |v#0@@21|)))))
(|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#0@@0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#0@@0|)) |dt_update#children#0#0@@0|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@4|) |dt_update#root#0#0@@2|))))))))
 :qid |PivotBetreebrokenidfy.539:26|
 :skolemid |2609|
 :pattern ( (PivotBetree.__default.InternalGrow |v#0@@21| |v'#0@@21| |lbl#0@@21| |step#0@@1|))
))))
(assert  (=> (<= 74 $FunctionContextHeight) (forall ((|v#0@@22| T@U) (|v'#0@@22| T@U) (|lbl#0@@22| T@U) (|step#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@22|) DatatypeTypeType) (= (type |v'#0@@22|) DatatypeTypeType)) (= (type |lbl#0@@22|) DatatypeTypeType)) (= (type |step#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalGrow#canCall| (Lit |v#0@@22|) (Lit |v'#0@@22|) (Lit |lbl#0@@22|) (Lit |step#0@@2|)) (and (not (= 74 $FunctionContextHeight)) (and (and (and ($Is |v#0@@22| Tclass.PivotBetree.Variables) ($Is |v'#0@@22| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@22| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@2| Tclass.PivotBetree.Step))))) (and (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@22|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@22|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@22|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@2|))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@22|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@2| (Lit |v#0@@22|)))
(let ((|dt_update#root#0#1@@1| (let ((|dt_update_tmp#1#1| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#1| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@22|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#1|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#1|)) |dt_update#children#0#1|))))))
(|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@2|)) |dt_update#root#0#1@@1|))))) (let ((|dt_update_tmp#0#1@@3| (Lit |v#0@@22|)))
 (and (and (and |DomainMod.__default.TotalDomain#canCall| (|PivotBetree.__default.EmptyRoot#canCall| (Lit DomainMod.__default.TotalDomain))) (PivotBetree.Variables.Variables_q (Lit |v#0@@22|))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@3|)))))))) (= (PivotBetree.__default.InternalGrow (Lit |v#0@@22|) (Lit |v'#0@@22|) (Lit |lbl#0@@22|) (Lit |step#0@@2|))  (and (and (and (PivotBetree.Variables.WF (Lit |v#0@@22|)) (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@22|))) (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@2|))) (|PivotBetree.Variables#Equal| |v'#0@@22| (let ((|dt_update_tmp#0#1@@4| (Lit |v#0@@22|)))
(let ((|dt_update#root#0#1@@2| (let ((|dt_update_tmp#1#1@@0| (Lit (PivotBetree.__default.EmptyRoot (Lit DomainMod.__default.TotalDomain)))))
(let ((|dt_update#children#0#1@@0| (Lit (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (PivotBetree.Variables.root (Lit |v#0@@22|))))))))
(Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit (PivotBetree.BetreeNode.buffers |dt_update_tmp#1#1@@0|)) (Lit (PivotBetree.BetreeNode.pivotTable |dt_update_tmp#1#1@@0|)) |dt_update#children#0#1@@0|))))))
(|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@4|)) |dt_update#root#0#1@@2|))))))))
 :qid |PivotBetreebrokenidfy.539:26|
 :weight 3
 :skolemid |2610|
 :pattern ( (PivotBetree.__default.InternalGrow (Lit |v#0@@22|) (Lit |v'#0@@22|) (Lit |lbl#0@@22|) (Lit |step#0@@2|)))
))))
(assert  (=> (<= 75 $FunctionContextHeight) (forall ((|v#0@@23| T@U) (|v'#0@@23| T@U) (|lbl#0@@23| T@U) (|step#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@23|) DatatypeTypeType) (= (type |v'#0@@23|) DatatypeTypeType)) (= (type |lbl#0@@23|) DatatypeTypeType)) (= (type |step#0@@3|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| |v#0@@23| |v'#0@@23| |lbl#0@@23| |step#0@@3|) (and (not (= 75 $FunctionContextHeight)) (and (and (and ($Is |v#0@@23| Tclass.PivotBetree.Variables) ($Is |v'#0@@23| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@23| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@3| Tclass.PivotBetree.Step))))) true)
 :qid |PivotBetreebrokenidfy.547:27|
 :skolemid |2614|
 :pattern ( (PivotBetree.__default.InternalSplit |v#0@@23| |v'#0@@23| |lbl#0@@23| |step#0@@3|))
))))
(assert (forall ((|v#0@@24| T@U) (|v'#0@@24| T@U) (|lbl#0@@24| T@U) (|step#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@24|) DatatypeTypeType) (= (type |v'#0@@24|) DatatypeTypeType)) (= (type |lbl#0@@24|) DatatypeTypeType)) (= (type |step#0@@4|) DatatypeTypeType)) (and (and (and ($Is |v#0@@24| Tclass.PivotBetree.Variables) ($Is |v'#0@@24| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@24| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@4| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalSplit#requires| |v#0@@24| |v'#0@@24| |lbl#0@@24| |step#0@@4|) true))
 :qid |PivotBetreebrokenidfy.547:27|
 :skolemid |2615|
 :pattern ( (|PivotBetree.__default.InternalSplit#requires| |v#0@@24| |v'#0@@24| |lbl#0@@24| |step#0@@4|))
)))
(assert  (=> (<= 75 $FunctionContextHeight) (forall ((|v#0@@25| T@U) (|v'#0@@25| T@U) (|lbl#0@@25| T@U) (|step#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@25|) DatatypeTypeType) (= (type |v'#0@@25|) DatatypeTypeType)) (= (type |lbl#0@@25|) DatatypeTypeType)) (= (type |step#0@@5|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| |v#0@@25| |v'#0@@25| |lbl#0@@25| |step#0@@5|) (and (not (= 75 $FunctionContextHeight)) (and (and (and ($Is |v#0@@25| Tclass.PivotBetree.Variables) ($Is |v'#0@@25| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@25| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@5| Tclass.PivotBetree.Step))))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@25|) (=> (PivotBetree.Step.InternalSplitStep_q |step#0@@5|) (and (|PivotBetree.Step.WF#canCall| |step#0@@5|) (=> (PivotBetree.Step.WF |step#0@@5|) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@5|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@25|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Variables.Variables_q |v#0@@25|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Variables.root |v#0@@25|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@25|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@5| |v#0@@25|))
(let ((|dt_update#root#0#0@@3| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@5|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Step.request |step#0@@5|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@5|) |dt_update#root#0#0@@3|))))) (let ((|dt_update_tmp#0#0@@6| |v#0@@25|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@5|)) (|PivotBetree.BetreeNode.SplitParent#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Step.request |step#0@@5|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@5|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Step.request |step#0@@5|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@6|)))))))))) (= (PivotBetree.__default.InternalSplit |v#0@@25| |v'#0@@25| |lbl#0@@25| |step#0@@5|)  (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@25|) (PivotBetree.Step.InternalSplitStep_q |step#0@@5|)) (PivotBetree.Step.WF |step#0@@5|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Variables.root |v#0@@25|))) (|PivotBetree.Variables#Equal| |v'#0@@25| (let ((|dt_update_tmp#0#0@@7| |v#0@@25|))
(let ((|dt_update#root#0#0@@4| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@5|) (PivotBetree.BetreeNode.SplitParent (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@5|)) (PivotBetree.Step.request |step#0@@5|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@7|) |dt_update#root#0#0@@4|))))))))
 :qid |PivotBetreebrokenidfy.547:27|
 :skolemid |2616|
 :pattern ( (PivotBetree.__default.InternalSplit |v#0@@25| |v'#0@@25| |lbl#0@@25| |step#0@@5|))
))))
(assert  (=> (<= 75 $FunctionContextHeight) (forall ((|v#0@@26| T@U) (|v'#0@@26| T@U) (|lbl#0@@26| T@U) (|step#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@26|) DatatypeTypeType) (= (type |v'#0@@26|) DatatypeTypeType)) (= (type |lbl#0@@26|) DatatypeTypeType)) (= (type |step#0@@6|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalSplit#canCall| (Lit |v#0@@26|) (Lit |v'#0@@26|) (Lit |lbl#0@@26|) (Lit |step#0@@6|)) (and (not (= 75 $FunctionContextHeight)) (and (and (and ($Is |v#0@@26| Tclass.PivotBetree.Variables) ($Is |v'#0@@26| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@26| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@6| Tclass.PivotBetree.Step))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@26|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@6|))))) (and (|PivotBetree.Step.WF#canCall| (Lit |step#0@@6|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@6|))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@26|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@26|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))) (PivotBetree.Variables.root (Lit |v#0@@26|))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@26|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@5| (Lit |v#0@@26|)))
(let ((|dt_update#root#0#1@@3| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@6|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@5|)) |dt_update#root#0#1@@3|)))))) (let ((|dt_update_tmp#0#1@@6| (Lit |v#0@@26|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))) (|PivotBetree.BetreeNode.SplitParent#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@6|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@6|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@6|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@6|)))))))))) (= (PivotBetree.__default.InternalSplit (Lit |v#0@@26|) (Lit |v'#0@@26|) (Lit |lbl#0@@26|) (Lit |step#0@@6|))  (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@26|)) (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@6|))) (PivotBetree.Step.WF (Lit |step#0@@6|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@6|)))) (PivotBetree.Variables.root (Lit |v#0@@26|)))) (|PivotBetree.Variables#Equal| |v'#0@@26| (let ((|dt_update_tmp#0#1@@7| (Lit |v#0@@26|)))
(let ((|dt_update#root#0#1@@4| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))) (Lit (PivotBetree.BetreeNode.SplitParent (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@6|))))) (Lit (PivotBetree.Step.request (Lit |step#0@@6|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@7|)) |dt_update#root#0#1@@4|)))))))))
 :qid |PivotBetreebrokenidfy.547:27|
 :weight 3
 :skolemid |2617|
 :pattern ( (PivotBetree.__default.InternalSplit (Lit |v#0@@26|) (Lit |v'#0@@26|) (Lit |lbl#0@@26|) (Lit |step#0@@6|)))
))))
(assert  (=> (<= 76 $FunctionContextHeight) (forall ((|v#0@@27| T@U) (|v'#0@@27| T@U) (|lbl#0@@27| T@U) (|step#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@27|) DatatypeTypeType) (= (type |v'#0@@27|) DatatypeTypeType)) (= (type |lbl#0@@27|) DatatypeTypeType)) (= (type |step#0@@7|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| |v#0@@27| |v'#0@@27| |lbl#0@@27| |step#0@@7|) (and (not (= 76 $FunctionContextHeight)) (and (and (and ($Is |v#0@@27| Tclass.PivotBetree.Variables) ($Is |v'#0@@27| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@27| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@7| Tclass.PivotBetree.Step))))) true)
 :qid |PivotBetreebrokenidfy.558:27|
 :skolemid |2656|
 :pattern ( (PivotBetree.__default.InternalFlush |v#0@@27| |v'#0@@27| |lbl#0@@27| |step#0@@7|))
))))
(assert (forall ((|v#0@@28| T@U) (|v'#0@@28| T@U) (|lbl#0@@28| T@U) (|step#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@28|) DatatypeTypeType) (= (type |v'#0@@28|) DatatypeTypeType)) (= (type |lbl#0@@28|) DatatypeTypeType)) (= (type |step#0@@8|) DatatypeTypeType)) (and (and (and ($Is |v#0@@28| Tclass.PivotBetree.Variables) ($Is |v'#0@@28| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@28| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@8| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalFlush#requires| |v#0@@28| |v'#0@@28| |lbl#0@@28| |step#0@@8|) true))
 :qid |PivotBetreebrokenidfy.558:27|
 :skolemid |2657|
 :pattern ( (|PivotBetree.__default.InternalFlush#requires| |v#0@@28| |v'#0@@28| |lbl#0@@28| |step#0@@8|))
)))
(assert  (=> (<= 76 $FunctionContextHeight) (forall ((|v#0@@29| T@U) (|v'#0@@29| T@U) (|lbl#0@@29| T@U) (|step#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@29|) DatatypeTypeType) (= (type |v'#0@@29|) DatatypeTypeType)) (= (type |lbl#0@@29|) DatatypeTypeType)) (= (type |step#0@@9|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| |v#0@@29| |v'#0@@29| |lbl#0@@29| |step#0@@9|) (and (not (= 76 $FunctionContextHeight)) (and (and (and ($Is |v#0@@29| Tclass.PivotBetree.Variables) ($Is |v'#0@@29| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@29| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@9| Tclass.PivotBetree.Step))))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@29|) (=> (PivotBetree.Step.InternalFlushStep_q |step#0@@9|) (and (|PivotBetree.Path.Valid#canCall| (PivotBetree.Step.path |step#0@@9|)) (=> (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@9|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@29|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Variables.Variables_q |v#0@@29|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Variables.root |v#0@@29|)) (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@9|)) (|PivotBetree.BetreeNode.CanFlush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|))) (=> (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@29|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@8| |v#0@@29|))
(let ((|dt_update#root#0#0@@5| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@9|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@8|) |dt_update#root#0#0@@5|))))) (let ((|dt_update_tmp#0#0@@9| |v#0@@29|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@9|)) (|PivotBetree.BetreeNode.Flush#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@9|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@9|)))))))))))) (= (PivotBetree.__default.InternalFlush |v#0@@29| |v'#0@@29| |lbl#0@@29| |step#0@@9|)  (and (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@29|) (PivotBetree.Step.InternalFlushStep_q |step#0@@9|)) (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Step.path |step#0@@9|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Variables.root |v#0@@29|))) (PivotBetree.BetreeNode.CanFlush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|))) (|PivotBetree.Variables#Equal| |v'#0@@29| (let ((|dt_update_tmp#0#0@@10| |v#0@@29|))
(let ((|dt_update#root#0#0@@6| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@9|) (PivotBetree.BetreeNode.Flush (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@9|)) (PivotBetree.Step.childIdx |step#0@@9|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@10|) |dt_update#root#0#0@@6|))))))))
 :qid |PivotBetreebrokenidfy.558:27|
 :skolemid |2658|
 :pattern ( (PivotBetree.__default.InternalFlush |v#0@@29| |v'#0@@29| |lbl#0@@29| |step#0@@9|))
))))
(assert  (=> (<= 76 $FunctionContextHeight) (forall ((|v#0@@30| T@U) (|v'#0@@30| T@U) (|lbl#0@@30| T@U) (|step#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@30|) DatatypeTypeType) (= (type |v'#0@@30|) DatatypeTypeType)) (= (type |lbl#0@@30|) DatatypeTypeType)) (= (type |step#0@@10|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalFlush#canCall| (Lit |v#0@@30|) (Lit |v'#0@@30|) (Lit |lbl#0@@30|) (Lit |step#0@@10|)) (and (not (= 76 $FunctionContextHeight)) (and (and (and ($Is |v#0@@30| Tclass.PivotBetree.Variables) ($Is |v'#0@@30| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@30| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@10| Tclass.PivotBetree.Step))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@30|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@10|))))) (and (|PivotBetree.Path.Valid#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@30|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@30|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (PivotBetree.Variables.root (Lit |v#0@@30|))) (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (|PivotBetree.BetreeNode.CanFlush#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.CanFlush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|))))))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@30|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@8| (Lit |v#0@@30|)))
(let ((|dt_update#root#0#1@@5| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@8|)) |dt_update#root#0#1@@5|)))))) (let ((|dt_update_tmp#0#1@@9| (Lit |v#0@@30|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (|PivotBetree.BetreeNode.Flush#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@10|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@9|)))))))))))) (= (PivotBetree.__default.InternalFlush (Lit |v#0@@30|) (Lit |v'#0@@30|) (Lit |lbl#0@@30|) (Lit |step#0@@10|))  (and (and (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@30|)) (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@10|))) (PivotBetree.Path.Valid ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@10|)))) (PivotBetree.Variables.root (Lit |v#0@@30|)))) (PivotBetree.BetreeNode.CanFlush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|))))) (|PivotBetree.Variables#Equal| |v'#0@@30| (let ((|dt_update_tmp#0#1@@10| (Lit |v#0@@30|)))
(let ((|dt_update#root#0#1@@6| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))) (Lit (PivotBetree.BetreeNode.Flush (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@10|))))) (LitInt (PivotBetree.Step.childIdx (Lit |step#0@@10|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@10|)) |dt_update#root#0#1@@6|)))))))))
 :qid |PivotBetreebrokenidfy.558:27|
 :weight 3
 :skolemid |2659|
 :pattern ( (PivotBetree.__default.InternalFlush (Lit |v#0@@30|) (Lit |v'#0@@30|) (Lit |lbl#0@@30|) (Lit |step#0@@10|)))
))))
(assert (forall ((arg0@@448 T@U) (arg1@@181 T@U) ) (! (= (type (PivotBetree.__default.CompactedNode arg0@@448 arg1@@181)) DatatypeTypeType)
 :qid |funType:PivotBetree.__default.CompactedNode|
 :pattern ( (PivotBetree.__default.CompactedNode arg0@@448 arg1@@181))
)))
(assert  (=> (<= 77 $FunctionContextHeight) (forall ((|original#0| T@U) (|newBufs#0| T@U) ) (!  (=> (and (and (= (type |original#0|) DatatypeTypeType) (= (type |newBufs#0|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| |original#0| |newBufs#0|) (and (not (= 77 $FunctionContextHeight)) (and (and ($Is |original#0| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.BetreeNode_q |original#0|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0|) |newBufs#0|)))))) ($Is (PivotBetree.__default.CompactedNode |original#0| |newBufs#0|) Tclass.PivotBetree.BetreeNode))
 :qid |PivotBetreebrokenidfy.570:26|
 :skolemid |2723|
 :pattern ( (PivotBetree.__default.CompactedNode |original#0| |newBufs#0|))
))))
(assert (forall ((|original#0@@0| T@U) (|newBufs#0@@0| T@U) ) (!  (=> (and (and (= (type |original#0@@0|) DatatypeTypeType) (= (type |newBufs#0@@0|) DatatypeTypeType)) (and ($Is |original#0@@0| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@0| Tclass.Buffers.BufferStack))) (= (|PivotBetree.__default.CompactedNode#requires| |original#0@@0| |newBufs#0@@0|)  (and (PivotBetree.BetreeNode.BetreeNode_q |original#0@@0|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0@@0|) |newBufs#0@@0|))))
 :qid |PivotBetreebrokenidfy.570:26|
 :skolemid |2724|
 :pattern ( (|PivotBetree.__default.CompactedNode#requires| |original#0@@0| |newBufs#0@@0|))
)))
(assert  (=> (<= 77 $FunctionContextHeight) (forall ((|original#0@@1| T@U) (|newBufs#0@@1| T@U) ) (!  (=> (and (and (= (type |original#0@@1|) DatatypeTypeType) (= (type |newBufs#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| |original#0@@1| |newBufs#0@@1|) (and (not (= 77 $FunctionContextHeight)) (and (and ($Is |original#0@@1| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@1| Tclass.Buffers.BufferStack)) (and (PivotBetree.BetreeNode.BetreeNode_q |original#0@@1|) (Buffers.BufferStack.Equivalent (PivotBetree.BetreeNode.buffers |original#0@@1|) |newBufs#0@@1|)))))) (= (PivotBetree.__default.CompactedNode |original#0@@1| |newBufs#0@@1|) (|#PivotBetree.BetreeNode.BetreeNode| |newBufs#0@@1| (PivotBetree.BetreeNode.pivotTable |original#0@@1|) (PivotBetree.BetreeNode.children |original#0@@1|))))
 :qid |PivotBetreebrokenidfy.570:26|
 :skolemid |2725|
 :pattern ( (PivotBetree.__default.CompactedNode |original#0@@1| |newBufs#0@@1|))
))))
(assert  (=> (<= 77 $FunctionContextHeight) (forall ((|original#0@@2| T@U) (|newBufs#0@@2| T@U) ) (!  (=> (and (and (= (type |original#0@@2|) DatatypeTypeType) (= (type |newBufs#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.CompactedNode#canCall| (Lit |original#0@@2|) (Lit |newBufs#0@@2|)) (and (not (= 77 $FunctionContextHeight)) (and (and ($Is |original#0@@2| Tclass.PivotBetree.BetreeNode) ($Is |newBufs#0@@2| Tclass.Buffers.BufferStack)) (and (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.BetreeNode_q (Lit |original#0@@2|))))) (U_2_bool (Lit (bool_2_U (Buffers.BufferStack.Equivalent (Lit (PivotBetree.BetreeNode.buffers (Lit |original#0@@2|))) (Lit |newBufs#0@@2|)))))))))) (= (PivotBetree.__default.CompactedNode (Lit |original#0@@2|) (Lit |newBufs#0@@2|)) (Lit (|#PivotBetree.BetreeNode.BetreeNode| (Lit |newBufs#0@@2|) (Lit (PivotBetree.BetreeNode.pivotTable (Lit |original#0@@2|))) (Lit (PivotBetree.BetreeNode.children (Lit |original#0@@2|)))))))
 :qid |PivotBetreebrokenidfy.570:26|
 :weight 3
 :skolemid |2726|
 :pattern ( (PivotBetree.__default.CompactedNode (Lit |original#0@@2|) (Lit |newBufs#0@@2|)))
))))
(assert  (=> (<= 78 $FunctionContextHeight) (forall ((|v#0@@31| T@U) (|v'#0@@31| T@U) (|lbl#0@@31| T@U) (|step#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@31|) DatatypeTypeType) (= (type |v'#0@@31|) DatatypeTypeType)) (= (type |lbl#0@@31|) DatatypeTypeType)) (= (type |step#0@@11|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| |v#0@@31| |v'#0@@31| |lbl#0@@31| |step#0@@11|) (and (not (= 78 $FunctionContextHeight)) (and (and (and (and ($Is |v#0@@31| Tclass.PivotBetree.Variables) ($Is |v'#0@@31| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@31| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@11| Tclass.PivotBetree.Step)) (PivotBetree.Step.WF |step#0@@11|))))) true)
 :qid |PivotBetreebrokenidfy.577:29|
 :skolemid |2728|
 :pattern ( (PivotBetree.__default.InternalCompact |v#0@@31| |v'#0@@31| |lbl#0@@31| |step#0@@11|))
))))
(assert (forall ((|v#0@@32| T@U) (|v'#0@@32| T@U) (|lbl#0@@32| T@U) (|step#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@32|) DatatypeTypeType) (= (type |v'#0@@32|) DatatypeTypeType)) (= (type |lbl#0@@32|) DatatypeTypeType)) (= (type |step#0@@12|) DatatypeTypeType)) (and (and (and ($Is |v#0@@32| Tclass.PivotBetree.Variables) ($Is |v'#0@@32| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@32| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@12| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.InternalCompact#requires| |v#0@@32| |v'#0@@32| |lbl#0@@32| |step#0@@12|) (PivotBetree.Step.WF |step#0@@12|)))
 :qid |PivotBetreebrokenidfy.577:29|
 :skolemid |2729|
 :pattern ( (|PivotBetree.__default.InternalCompact#requires| |v#0@@32| |v'#0@@32| |lbl#0@@32| |step#0@@12|))
)))
(assert  (=> (<= 78 $FunctionContextHeight) (forall ((|v#0@@33| T@U) (|v'#0@@33| T@U) (|lbl#0@@33| T@U) (|step#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@33|) DatatypeTypeType) (= (type |v'#0@@33|) DatatypeTypeType)) (= (type |lbl#0@@33|) DatatypeTypeType)) (= (type |step#0@@13|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| |v#0@@33| |v'#0@@33| |lbl#0@@33| |step#0@@13|) (and (not (= 78 $FunctionContextHeight)) (and (and (and (and ($Is |v#0@@33| Tclass.PivotBetree.Variables) ($Is |v'#0@@33| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@33| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@13| Tclass.PivotBetree.Step)) (PivotBetree.Step.WF |step#0@@13|))))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@33|) (=> (PivotBetree.Step.InternalCompactStep_q |step#0@@13|) (and (and (and (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@13|))) (|$IsA#PivotBetree.BetreeNode| (PivotBetree.Variables.root |v#0@@33|))) (and (PivotBetree.Path.Path_q (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Variables.Variables_q |v#0@@33|))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Variables.root |v#0@@33|)) (and (and (|$IsA#PivotBetree.Variables| |v'#0@@33|) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#0@@11| |v#0@@33|))
(let ((|dt_update#root#0#0@@7| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@13|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Step.compactedBuffers |step#0@@13|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@11|) |dt_update#root#0#0@@7|))))) (let ((|dt_update_tmp#0#0@@12| |v#0@@33|))
 (and (and (and (|PivotBetree.Path.Target#canCall| (PivotBetree.Step.path |step#0@@13|)) (|PivotBetree.__default.CompactedNode#canCall| (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Step.compactedBuffers |step#0@@13|))) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Step.path |step#0@@13|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Step.compactedBuffers |step#0@@13|)))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#0@@12|)))))))) (= (PivotBetree.__default.InternalCompact |v#0@@33| |v'#0@@33| |lbl#0@@33| |step#0@@13|)  (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@33|) (PivotBetree.Step.InternalCompactStep_q |step#0@@13|)) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Variables.root |v#0@@33|))) (|PivotBetree.Variables#Equal| |v'#0@@33| (let ((|dt_update_tmp#0#0@@13| |v#0@@33|))
(let ((|dt_update#root#0#0@@8| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Step.path |step#0@@13|) (PivotBetree.__default.CompactedNode (PivotBetree.Path.Target ($LS $LZ) (PivotBetree.Step.path |step#0@@13|)) (PivotBetree.Step.compactedBuffers |step#0@@13|)))))
(|#PivotBetree.Variables.Variables| (PivotBetree.Variables.memtable |dt_update_tmp#0#0@@13|) |dt_update#root#0#0@@8|))))))))
 :qid |PivotBetreebrokenidfy.577:29|
 :skolemid |2730|
 :pattern ( (PivotBetree.__default.InternalCompact |v#0@@33| |v'#0@@33| |lbl#0@@33| |step#0@@13|))
))))
(assert  (=> (<= 78 $FunctionContextHeight) (forall ((|v#0@@34| T@U) (|v'#0@@34| T@U) (|lbl#0@@34| T@U) (|step#0@@14| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@34|) DatatypeTypeType) (= (type |v'#0@@34|) DatatypeTypeType)) (= (type |lbl#0@@34|) DatatypeTypeType)) (= (type |step#0@@14|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalCompact#canCall| (Lit |v#0@@34|) (Lit |v'#0@@34|) (Lit |lbl#0@@34|) (Lit |step#0@@14|)) (and (not (= 78 $FunctionContextHeight)) (and (and (and (and ($Is |v#0@@34| Tclass.PivotBetree.Variables) ($Is |v'#0@@34| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@34| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@14| Tclass.PivotBetree.Step)) (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@14|))))))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@34|))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@14|))))) (and (and (and (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@14|)))))) (|$IsA#PivotBetree.BetreeNode| (Lit (PivotBetree.Variables.root (Lit |v#0@@34|))))) (and (PivotBetree.Path.Path_q (Lit (PivotBetree.Step.path (Lit |step#0@@14|)))) (PivotBetree.Variables.Variables_q (Lit |v#0@@34|)))) (=> (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@14|)))) (PivotBetree.Variables.root (Lit |v#0@@34|))) (and (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@34|)) (|$IsA#PivotBetree.Variables| (let ((|dt_update_tmp#0#1@@11| (Lit |v#0@@34|)))
(let ((|dt_update#root#0#1@@7| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@14|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@11|)) |dt_update#root#0#1@@7|)))))) (let ((|dt_update_tmp#0#1@@12| (Lit |v#0@@34|)))
 (and (and (and (|PivotBetree.Path.Target#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@14|)))) (|PivotBetree.__default.CompactedNode#canCall| (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@14|))))) (|PivotBetree.Path.Substitute#canCall| (Lit (PivotBetree.Step.path (Lit |step#0@@14|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@14|))))))) (PivotBetree.Variables.Variables_q |dt_update_tmp#0#1@@12|)))))))) (= (PivotBetree.__default.InternalCompact (Lit |v#0@@34|) (Lit |v'#0@@34|) (Lit |lbl#0@@34|) (Lit |step#0@@14|))  (and (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@34|)) (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@14|))) (|PivotBetree.BetreeNode#Equal| (PivotBetree.Path.node (Lit (PivotBetree.Step.path (Lit |step#0@@14|)))) (PivotBetree.Variables.root (Lit |v#0@@34|)))) (|PivotBetree.Variables#Equal| |v'#0@@34| (let ((|dt_update_tmp#0#1@@13| (Lit |v#0@@34|)))
(let ((|dt_update#root#0#1@@8| (Lit (PivotBetree.Path.Substitute ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))) (Lit (PivotBetree.__default.CompactedNode (Lit (PivotBetree.Path.Target ($LS $LZ) (Lit (PivotBetree.Step.path (Lit |step#0@@14|))))) (Lit (PivotBetree.Step.compactedBuffers (Lit |step#0@@14|)))))))))
(Lit (|#PivotBetree.Variables.Variables| (Lit (PivotBetree.Variables.memtable |dt_update_tmp#0#1@@13|)) |dt_update#root#0#1@@8|)))))))))
 :qid |PivotBetreebrokenidfy.577:29|
 :weight 3
 :skolemid |2731|
 :pattern ( (PivotBetree.__default.InternalCompact (Lit |v#0@@34|) (Lit |v'#0@@34|) (Lit |lbl#0@@34|) (Lit |step#0@@14|)))
))))
(assert  (=> (<= 79 $FunctionContextHeight) (forall ((|v#0@@35| T@U) (|v'#0@@35| T@U) (|lbl#0@@35| T@U) ) (!  (=> (and (and (and (= (type |v#0@@35|) DatatypeTypeType) (= (type |v'#0@@35|) DatatypeTypeType)) (= (type |lbl#0@@35|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@35| |v'#0@@35| |lbl#0@@35|) (and (not (= 79 $FunctionContextHeight)) (and (and ($Is |v#0@@35| Tclass.PivotBetree.Variables) ($Is |v'#0@@35| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@35| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.588:26|
 :skolemid |2772|
 :pattern ( (PivotBetree.__default.InternalNoOp |v#0@@35| |v'#0@@35| |lbl#0@@35|))
))))
(assert (forall ((|v#0@@36| T@U) (|v'#0@@36| T@U) (|lbl#0@@36| T@U) ) (!  (=> (and (and (and (= (type |v#0@@36|) DatatypeTypeType) (= (type |v'#0@@36|) DatatypeTypeType)) (= (type |lbl#0@@36|) DatatypeTypeType)) (and (and ($Is |v#0@@36| Tclass.PivotBetree.Variables) ($Is |v'#0@@36| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@36| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.InternalNoOp#requires| |v#0@@36| |v'#0@@36| |lbl#0@@36|) true))
 :qid |PivotBetreebrokenidfy.588:26|
 :skolemid |2773|
 :pattern ( (|PivotBetree.__default.InternalNoOp#requires| |v#0@@36| |v'#0@@36| |lbl#0@@36|))
)))
(assert  (=> (<= 79 $FunctionContextHeight) (forall ((|v#0@@37| T@U) (|v'#0@@37| T@U) (|lbl#0@@37| T@U) ) (!  (=> (and (and (and (= (type |v#0@@37|) DatatypeTypeType) (= (type |v'#0@@37|) DatatypeTypeType)) (= (type |lbl#0@@37|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@37| |v'#0@@37| |lbl#0@@37|) (and (not (= 79 $FunctionContextHeight)) (and (and ($Is |v#0@@37| Tclass.PivotBetree.Variables) ($Is |v'#0@@37| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@37| Tclass.PivotBetree.TransitionLabel))))) (and (=> (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@37|) (and (|PivotBetree.Variables.WF#canCall| |v#0@@37|) (=> (PivotBetree.Variables.WF |v#0@@37|) (and (|$IsA#PivotBetree.Variables| |v'#0@@37|) (|$IsA#PivotBetree.Variables| |v#0@@37|))))) (= (PivotBetree.__default.InternalNoOp |v#0@@37| |v'#0@@37| |lbl#0@@37|)  (and (and (PivotBetree.TransitionLabel.InternalLabel_q |lbl#0@@37|) (PivotBetree.Variables.WF |v#0@@37|)) (|PivotBetree.Variables#Equal| |v'#0@@37| |v#0@@37|)))))
 :qid |PivotBetreebrokenidfy.588:26|
 :skolemid |2774|
 :pattern ( (PivotBetree.__default.InternalNoOp |v#0@@37| |v'#0@@37| |lbl#0@@37|))
))))
(assert  (=> (<= 79 $FunctionContextHeight) (forall ((|v#0@@38| T@U) (|v'#0@@38| T@U) (|lbl#0@@38| T@U) ) (!  (=> (and (and (and (= (type |v#0@@38|) DatatypeTypeType) (= (type |v'#0@@38|) DatatypeTypeType)) (= (type |lbl#0@@38|) DatatypeTypeType)) (or (|PivotBetree.__default.InternalNoOp#canCall| (Lit |v#0@@38|) (Lit |v'#0@@38|) (Lit |lbl#0@@38|)) (and (not (= 79 $FunctionContextHeight)) (and (and ($Is |v#0@@38| Tclass.PivotBetree.Variables) ($Is |v'#0@@38| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@38| Tclass.PivotBetree.TransitionLabel))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@38|))))) (and (|PivotBetree.Variables.WF#canCall| (Lit |v#0@@38|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Variables.WF (Lit |v#0@@38|))))) (and (|$IsA#PivotBetree.Variables| (Lit |v'#0@@38|)) (|$IsA#PivotBetree.Variables| (Lit |v#0@@38|)))))) (= (PivotBetree.__default.InternalNoOp (Lit |v#0@@38|) (Lit |v'#0@@38|) (Lit |lbl#0@@38|))  (and (and (PivotBetree.TransitionLabel.InternalLabel_q (Lit |lbl#0@@38|)) (PivotBetree.Variables.WF (Lit |v#0@@38|))) (|PivotBetree.Variables#Equal| |v'#0@@38| |v#0@@38|)))))
 :qid |PivotBetreebrokenidfy.588:26|
 :weight 3
 :skolemid |2775|
 :pattern ( (PivotBetree.__default.InternalNoOp (Lit |v#0@@38|) (Lit |v'#0@@38|) (Lit |lbl#0@@38|)))
))))
(assert  (=> (<= 80 $FunctionContextHeight) (forall ((|v#0@@39| T@U) (|stampedBetree#0| T@U) ) (!  (=> (and (and (= (type |v#0@@39|) DatatypeTypeType) (= (type |stampedBetree#0|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| |v#0@@39| |stampedBetree#0|) (and (not (= 80 $FunctionContextHeight)) (and ($Is |v#0@@39| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))))) true)
 :qid |PivotBetreebrokenidfy.597:18|
 :skolemid |2777|
 :pattern ( (PivotBetree.__default.Init |v#0@@39| |stampedBetree#0|))
))))
(assert (forall ((|v#0@@40| T@U) (|stampedBetree#0@@0| T@U) ) (!  (=> (and (and (= (type |v#0@@40|) DatatypeTypeType) (= (type |stampedBetree#0@@0|) DatatypeTypeType)) (and ($Is |v#0@@40| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@0| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))) (= (|PivotBetree.__default.Init#requires| |v#0@@40| |stampedBetree#0@@0|) true))
 :qid |PivotBetreebrokenidfy.597:18|
 :skolemid |2778|
 :pattern ( (|PivotBetree.__default.Init#requires| |v#0@@40| |stampedBetree#0@@0|))
)))
(assert (forall ((arg0@@449 Int) ) (! (= (type (MemtableMod.__default.EmptyMemtable arg0@@449)) DatatypeTypeType)
 :qid |funType:MemtableMod.__default.EmptyMemtable|
 :pattern ( (MemtableMod.__default.EmptyMemtable arg0@@449))
)))
(assert  (=> (<= 80 $FunctionContextHeight) (forall ((|v#0@@41| T@U) (|stampedBetree#0@@1| T@U) ) (!  (=> (and (and (= (type |v#0@@41|) DatatypeTypeType) (= (type |stampedBetree#0@@1|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| |v#0@@41| |stampedBetree#0@@1|) (and (not (= 80 $FunctionContextHeight)) (and ($Is |v#0@@41| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@1| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))))) (and (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@1|) (|PivotBetree.BetreeNode.WF#canCall| ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|)))) (=> (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|))) (and (|$IsA#PivotBetree.Variables| |v#0@@41|) (and (and (StampedMod.Stamped.Stamped_q |stampedBetree#0@@1|) (|MemtableMod.__default.EmptyMemtable#canCall| (StampedMod.Stamped.seqEnd |stampedBetree#0@@1|))) (StampedMod.Stamped.Stamped_q |stampedBetree#0@@1|))))) (= (PivotBetree.__default.Init |v#0@@41| |stampedBetree#0@@1|)  (and (PivotBetree.BetreeNode.WF ($LS $LZ) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|))) (|PivotBetree.Variables#Equal| |v#0@@41| (|#PivotBetree.Variables.Variables| (MemtableMod.__default.EmptyMemtable (StampedMod.Stamped.seqEnd |stampedBetree#0@@1|)) ($Unbox DatatypeTypeType (StampedMod.Stamped.value |stampedBetree#0@@1|))))))))
 :qid |PivotBetreebrokenidfy.597:18|
 :skolemid |2779|
 :pattern ( (PivotBetree.__default.Init |v#0@@41| |stampedBetree#0@@1|))
))))
(assert  (=> (<= 80 $FunctionContextHeight) (forall ((|v#0@@42| T@U) (|stampedBetree#0@@2| T@U) ) (!  (=> (and (and (= (type |v#0@@42|) DatatypeTypeType) (= (type |stampedBetree#0@@2|) DatatypeTypeType)) (or (|PivotBetree.__default.Init#canCall| (Lit |v#0@@42|) (Lit |stampedBetree#0@@2|)) (and (not (= 80 $FunctionContextHeight)) (and ($Is |v#0@@42| Tclass.PivotBetree.Variables) ($Is |stampedBetree#0@@2| (Tclass.StampedMod.Stamped Tclass.PivotBetree.BetreeNode)))))) (and (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@2|)) (|PivotBetree.BetreeNode.WF#canCall| (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|)))))) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|)))))))) (and (|$IsA#PivotBetree.Variables| (Lit |v#0@@42|)) (and (and (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@2|)) (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@2|))))) (StampedMod.Stamped.Stamped_q (Lit |stampedBetree#0@@2|)))))) (= (PivotBetree.__default.Init (Lit |v#0@@42|) (Lit |stampedBetree#0@@2|))  (and (PivotBetree.BetreeNode.WF ($LS $LZ) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|))))) (|PivotBetree.Variables#Equal| |v#0@@42| (|#PivotBetree.Variables.Variables| (Lit (MemtableMod.__default.EmptyMemtable (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedBetree#0@@2|))))) (Lit ($Unbox DatatypeTypeType (StampedMod.Stamped.value (Lit |stampedBetree#0@@2|))))))))))
 :qid |PivotBetreebrokenidfy.597:18|
 :weight 3
 :skolemid |2780|
 :pattern ( (PivotBetree.__default.Init (Lit |v#0@@42|) (Lit |stampedBetree#0@@2|)))
))))
(assert  (=> (<= 81 $FunctionContextHeight) (forall ((|v#0@@43| T@U) (|v'#0@@39| T@U) (|lbl#0@@39| T@U) (|step#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@43|) DatatypeTypeType) (= (type |v'#0@@39|) DatatypeTypeType)) (= (type |lbl#0@@39|) DatatypeTypeType)) (= (type |step#0@@15|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| |v#0@@43| |v'#0@@39| |lbl#0@@39| |step#0@@15|) (and (not (= 81 $FunctionContextHeight)) (and (and (and ($Is |v#0@@43| Tclass.PivotBetree.Variables) ($Is |v'#0@@39| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@39| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@15| Tclass.PivotBetree.Step))))) true)
 :qid |PivotBetreebrokenidfy.642:22|
 :skolemid |2783|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@43| |v'#0@@39| |lbl#0@@39| |step#0@@15|))
))))
(assert (forall ((|v#0@@44| T@U) (|v'#0@@40| T@U) (|lbl#0@@40| T@U) (|step#0@@16| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@44|) DatatypeTypeType) (= (type |v'#0@@40|) DatatypeTypeType)) (= (type |lbl#0@@40|) DatatypeTypeType)) (= (type |step#0@@16|) DatatypeTypeType)) (and (and (and ($Is |v#0@@44| Tclass.PivotBetree.Variables) ($Is |v'#0@@40| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@40| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@16| Tclass.PivotBetree.Step))) (= (|PivotBetree.__default.NextStep#requires| |v#0@@44| |v'#0@@40| |lbl#0@@40| |step#0@@16|) true))
 :qid |PivotBetreebrokenidfy.642:22|
 :skolemid |2784|
 :pattern ( (|PivotBetree.__default.NextStep#requires| |v#0@@44| |v'#0@@40| |lbl#0@@40| |step#0@@16|))
)))
(assert  (=> (<= 81 $FunctionContextHeight) (forall ((|v#0@@45| T@U) (|v'#0@@41| T@U) (|lbl#0@@41| T@U) (|step#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@45|) DatatypeTypeType) (= (type |v'#0@@41|) DatatypeTypeType)) (= (type |lbl#0@@41|) DatatypeTypeType)) (= (type |step#0@@17|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|) (and (not (= 81 $FunctionContextHeight)) (and (and (and ($Is |v#0@@45| Tclass.PivotBetree.Variables) ($Is |v'#0@@41| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@41| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@17| Tclass.PivotBetree.Step))))) (and (and (|PivotBetree.Step.WF#canCall| |step#0@@17|) (=> (PivotBetree.Step.WF |step#0@@17|) (and (=> (PivotBetree.Step.QueryStep_q |step#0@@17|) (let ((|receipt#1@@0| (PivotBetree.Step.receipt |step#0@@17|)))
(|PivotBetree.__default.Query#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |receipt#1@@0|))) (=> (not (PivotBetree.Step.QueryStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.PutStep_q |step#0@@17|) (|PivotBetree.__default.Put#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41|)) (=> (not (PivotBetree.Step.PutStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.QueryEndLsnStep_q |step#0@@17|) (|PivotBetree.__default.QueryEndLsn#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41|)) (=> (not (PivotBetree.Step.QueryEndLsnStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.FreezeAsStep_q |step#0@@17|) (|PivotBetree.__default.FreezeAs#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41|)) (=> (not (PivotBetree.Step.FreezeAsStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.InternalGrowStep_q |step#0@@17|) (|PivotBetree.__default.InternalGrow#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|)) (=> (not (PivotBetree.Step.InternalGrowStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.InternalSplitStep_q |step#0@@17|) (|PivotBetree.__default.InternalSplit#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|)) (=> (not (PivotBetree.Step.InternalSplitStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@17|) (|PivotBetree.__default.InternalFlushMemtable#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41|)) (=> (not (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.InternalFlushStep_q |step#0@@17|) (|PivotBetree.__default.InternalFlush#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|)) (=> (not (PivotBetree.Step.InternalFlushStep_q |step#0@@17|)) (and (=> (PivotBetree.Step.InternalCompactStep_q |step#0@@17|) (|PivotBetree.__default.InternalCompact#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|)) (=> (not (PivotBetree.Step.InternalCompactStep_q |step#0@@17|)) (|PivotBetree.__default.InternalNoOp#canCall| |v#0@@45| |v'#0@@41| |lbl#0@@41|))))))))))))))))))))) (= (PivotBetree.__default.NextStep |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|)  (and (PivotBetree.Step.WF |step#0@@17|) (ite (PivotBetree.Step.QueryStep_q |step#0@@17|) (let ((|receipt#0@@4| (PivotBetree.Step.receipt |step#0@@17|)))
(PivotBetree.__default.Query |v#0@@45| |v'#0@@41| |lbl#0@@41| |receipt#0@@4|)) (ite (PivotBetree.Step.PutStep_q |step#0@@17|) (PivotBetree.__default.Put |v#0@@45| |v'#0@@41| |lbl#0@@41|) (ite (PivotBetree.Step.QueryEndLsnStep_q |step#0@@17|) (PivotBetree.__default.QueryEndLsn |v#0@@45| |v'#0@@41| |lbl#0@@41|) (ite (PivotBetree.Step.FreezeAsStep_q |step#0@@17|) (PivotBetree.__default.FreezeAs |v#0@@45| |v'#0@@41| |lbl#0@@41|) (ite (PivotBetree.Step.InternalGrowStep_q |step#0@@17|) (PivotBetree.__default.InternalGrow |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|) (ite (PivotBetree.Step.InternalSplitStep_q |step#0@@17|) (PivotBetree.__default.InternalSplit |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|) (ite (PivotBetree.Step.InternalFlushMemtableStep_q |step#0@@17|) (PivotBetree.__default.InternalFlushMemtable |v#0@@45| |v'#0@@41| |lbl#0@@41|) (ite (PivotBetree.Step.InternalFlushStep_q |step#0@@17|) (PivotBetree.__default.InternalFlush |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|) (ite (PivotBetree.Step.InternalCompactStep_q |step#0@@17|) (PivotBetree.__default.InternalCompact |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|) (PivotBetree.__default.InternalNoOp |v#0@@45| |v'#0@@41| |lbl#0@@41|))))))))))))))
 :qid |PivotBetreebrokenidfy.642:22|
 :skolemid |2785|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@45| |v'#0@@41| |lbl#0@@41| |step#0@@17|))
))))
(assert  (=> (<= 81 $FunctionContextHeight) (forall ((|v#0@@46| T@U) (|v'#0@@42| T@U) (|lbl#0@@42| T@U) (|step#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type |v#0@@46|) DatatypeTypeType) (= (type |v'#0@@42|) DatatypeTypeType)) (= (type |lbl#0@@42|) DatatypeTypeType)) (= (type |step#0@@18|) DatatypeTypeType)) (or (|PivotBetree.__default.NextStep#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)) (and (not (= 81 $FunctionContextHeight)) (and (and (and ($Is |v#0@@46| Tclass.PivotBetree.Variables) ($Is |v'#0@@42| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@42| Tclass.PivotBetree.TransitionLabel)) ($Is |step#0@@18| Tclass.PivotBetree.Step))))) (and (and (|PivotBetree.Step.WF#canCall| (Lit |step#0@@18|)) (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.WF (Lit |step#0@@18|))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@18|))))) (let ((|receipt#3@@0| (Lit (PivotBetree.Step.receipt (Lit |step#0@@18|)))))
(|PivotBetree.__default.Query#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) |receipt#3@@0|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.Put#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.PutStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.QueryEndLsn#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.FreezeAs#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.InternalGrow#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.InternalSplit#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.InternalFlushMemtable#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.InternalFlush#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@18|)))))) (and (=> (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@18|))))) (|PivotBetree.__default.InternalCompact#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|))) (=> (not (U_2_bool (Lit (bool_2_U (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@18|)))))) (|PivotBetree.__default.InternalNoOp#canCall| (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)))))))))))))))))))))) (= (PivotBetree.__default.NextStep (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|))  (and (PivotBetree.Step.WF (Lit |step#0@@18|)) (ite (PivotBetree.Step.QueryStep_q (Lit |step#0@@18|)) (U_2_bool (let ((|receipt#2@@0| (Lit (PivotBetree.Step.receipt (Lit |step#0@@18|)))))
(Lit (bool_2_U (PivotBetree.__default.Query (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) |receipt#2@@0|))))) (ite (PivotBetree.Step.PutStep_q (Lit |step#0@@18|)) (PivotBetree.__default.Put (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)) (ite (PivotBetree.Step.QueryEndLsnStep_q (Lit |step#0@@18|)) (PivotBetree.__default.QueryEndLsn (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)) (ite (PivotBetree.Step.FreezeAsStep_q (Lit |step#0@@18|)) (PivotBetree.__default.FreezeAs (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)) (ite (PivotBetree.Step.InternalGrowStep_q (Lit |step#0@@18|)) (PivotBetree.__default.InternalGrow (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)) (ite (PivotBetree.Step.InternalSplitStep_q (Lit |step#0@@18|)) (PivotBetree.__default.InternalSplit (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)) (ite (PivotBetree.Step.InternalFlushMemtableStep_q (Lit |step#0@@18|)) (PivotBetree.__default.InternalFlushMemtable (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)) (ite (PivotBetree.Step.InternalFlushStep_q (Lit |step#0@@18|)) (PivotBetree.__default.InternalFlush (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)) (ite (PivotBetree.Step.InternalCompactStep_q (Lit |step#0@@18|)) (PivotBetree.__default.InternalCompact (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)) (PivotBetree.__default.InternalNoOp (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|)))))))))))))))
 :qid |PivotBetreebrokenidfy.642:22|
 :weight 3
 :skolemid |2786|
 :pattern ( (PivotBetree.__default.NextStep (Lit |v#0@@46|) (Lit |v'#0@@42|) (Lit |lbl#0@@42|) (Lit |step#0@@18|)))
))))
(assert  (=> (<= 82 $FunctionContextHeight) (forall ((|v#0@@47| T@U) (|v'#0@@43| T@U) (|lbl#0@@43| T@U) ) (!  (=> (and (and (and (= (type |v#0@@47|) DatatypeTypeType) (= (type |v'#0@@43|) DatatypeTypeType)) (= (type |lbl#0@@43|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| |v#0@@47| |v'#0@@43| |lbl#0@@43|) (and (not (= 82 $FunctionContextHeight)) (and (and ($Is |v#0@@47| Tclass.PivotBetree.Variables) ($Is |v'#0@@43| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@43| Tclass.PivotBetree.TransitionLabel))))) true)
 :qid |PivotBetreebrokenidfy.659:18|
 :skolemid |2798|
 :pattern ( (PivotBetree.__default.Next |v#0@@47| |v'#0@@43| |lbl#0@@43|))
))))
(assert (forall ((|v#0@@48| T@U) (|v'#0@@44| T@U) (|lbl#0@@44| T@U) ) (!  (=> (and (and (and (= (type |v#0@@48|) DatatypeTypeType) (= (type |v'#0@@44|) DatatypeTypeType)) (= (type |lbl#0@@44|) DatatypeTypeType)) (and (and ($Is |v#0@@48| Tclass.PivotBetree.Variables) ($Is |v'#0@@44| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@44| Tclass.PivotBetree.TransitionLabel))) (= (|PivotBetree.__default.Next#requires| |v#0@@48| |v'#0@@44| |lbl#0@@44|) true))
 :qid |PivotBetreebrokenidfy.659:18|
 :skolemid |2799|
 :pattern ( (|PivotBetree.__default.Next#requires| |v#0@@48| |v'#0@@44| |lbl#0@@44|))
)))
(assert  (=> (<= 82 $FunctionContextHeight) (forall ((|v#0@@49| T@U) (|v'#0@@45| T@U) (|lbl#0@@45| T@U) ) (!  (=> (and (and (and (= (type |v#0@@49|) DatatypeTypeType) (= (type |v'#0@@45|) DatatypeTypeType)) (= (type |lbl#0@@45|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| |v#0@@49| |v'#0@@45| |lbl#0@@45|) (and (not (= 82 $FunctionContextHeight)) (and (and ($Is |v#0@@49| Tclass.PivotBetree.Variables) ($Is |v'#0@@45| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@45| Tclass.PivotBetree.TransitionLabel))))) (and (forall ((|step#0@@19| T@U) ) (!  (=> (and (= (type |step#0@@19|) DatatypeTypeType) ($Is |step#0@@19| Tclass.PivotBetree.Step)) (|PivotBetree.__default.NextStep#canCall| |v#0@@49| |v'#0@@45| |lbl#0@@45| |step#0@@19|))
 :qid |PivotBetreebrokenidfy.660:12|
 :skolemid |2801|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@49| |v'#0@@45| |lbl#0@@45| |step#0@@19|))
)) (= (PivotBetree.__default.Next |v#0@@49| |v'#0@@45| |lbl#0@@45|) (exists ((|step#0@@20| T@U) ) (!  (and (= (type |step#0@@20|) DatatypeTypeType) (and ($Is |step#0@@20| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep |v#0@@49| |v'#0@@45| |lbl#0@@45| |step#0@@20|)))
 :qid |PivotBetreebrokenidfy.660:12|
 :skolemid |2800|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@49| |v'#0@@45| |lbl#0@@45| |step#0@@20|))
)))))
 :qid |PivotBetreebrokenidfy.659:18|
 :skolemid |2802|
 :pattern ( (PivotBetree.__default.Next |v#0@@49| |v'#0@@45| |lbl#0@@45|))
))))
(assert  (=> (<= 82 $FunctionContextHeight) (forall ((|v#0@@50| T@U) (|v'#0@@46| T@U) (|lbl#0@@46| T@U) ) (!  (=> (and (and (and (= (type |v#0@@50|) DatatypeTypeType) (= (type |v'#0@@46|) DatatypeTypeType)) (= (type |lbl#0@@46|) DatatypeTypeType)) (or (|PivotBetree.__default.Next#canCall| (Lit |v#0@@50|) (Lit |v'#0@@46|) (Lit |lbl#0@@46|)) (and (not (= 82 $FunctionContextHeight)) (and (and ($Is |v#0@@50| Tclass.PivotBetree.Variables) ($Is |v'#0@@46| Tclass.PivotBetree.Variables)) ($Is |lbl#0@@46| Tclass.PivotBetree.TransitionLabel))))) (and (forall ((|step#1| T@U) ) (!  (=> (and (= (type |step#1|) DatatypeTypeType) ($Is |step#1| Tclass.PivotBetree.Step)) (|PivotBetree.__default.NextStep#canCall| (Lit |v#0@@50|) (Lit |v'#0@@46|) (Lit |lbl#0@@46|) |step#1|))
 :qid |PivotBetreebrokenidfy.660:12|
 :skolemid |2804|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@50| |v'#0@@46| |lbl#0@@46| |step#1|))
)) (= (PivotBetree.__default.Next (Lit |v#0@@50|) (Lit |v'#0@@46|) (Lit |lbl#0@@46|)) (exists ((|step#1@@0| T@U) ) (!  (and (= (type |step#1@@0|) DatatypeTypeType) (and ($Is |step#1@@0| Tclass.PivotBetree.Step) (PivotBetree.__default.NextStep (Lit |v#0@@50|) (Lit |v'#0@@46|) (Lit |lbl#0@@46|) |step#1@@0|)))
 :qid |PivotBetreebrokenidfy.660:12|
 :skolemid |2803|
 :pattern ( (PivotBetree.__default.NextStep |v#0@@50| |v'#0@@46| |lbl#0@@46| |step#1@@0|))
)))))
 :qid |PivotBetreebrokenidfy.659:18|
 :weight 3
 :skolemid |2805|
 :pattern ( (PivotBetree.__default.Next (Lit |v#0@@50|) (Lit |v'#0@@46|) (Lit |lbl#0@@46|)))
))))
(assert (= (type |#Options.Option.None|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#Options.Option.None|) |##Options.Option.None|))
(assert (forall ((d@@98 T@U) ) (!  (=> (= (type d@@98) DatatypeTypeType) (= (Options.Option.None_q d@@98) (= (DatatypeCtorId d@@98) |##Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |2809|
 :pattern ( (Options.Option.None_q d@@98))
)))
(assert (forall ((d@@99 T@U) ) (!  (=> (and (= (type d@@99) DatatypeTypeType) (Options.Option.None_q d@@99)) (= d@@99 |#Options.Option.None|))
 :qid |unknown.0:0|
 :skolemid |2810|
 :pattern ( (Options.Option.None_q d@@99))
)))
(assert (forall ((arg0@@450 T@U) ) (! (= (type (Tclass.Options.Option arg0@@450)) TyType)
 :qid |funType:Tclass.Options.Option|
 :pattern ( (Tclass.Options.Option arg0@@450))
)))
(assert (forall ((Options.Option$V T@U) ) (!  (=> (= (type Options.Option$V) TyType) (and (= (Tag (Tclass.Options.Option Options.Option$V)) Tagclass.Options.Option) (= (TagFamily (Tclass.Options.Option Options.Option$V)) tytagFamily$Option)))
 :qid |unknown.0:0|
 :skolemid |2811|
 :pattern ( (Tclass.Options.Option Options.Option$V))
)))
(assert (forall ((arg0@@451 T@U) ) (! (= (type (Tclass.Options.Option_0 arg0@@451)) TyType)
 :qid |funType:Tclass.Options.Option_0|
 :pattern ( (Tclass.Options.Option_0 arg0@@451))
)))
(assert (forall ((Options.Option$V@@0 T@U) ) (!  (=> (= (type Options.Option$V@@0) TyType) (= (Tclass.Options.Option_0 (Tclass.Options.Option Options.Option$V@@0)) Options.Option$V@@0))
 :qid |unknown.0:0|
 :skolemid |2812|
 :pattern ( (Tclass.Options.Option Options.Option$V@@0))
)))
(assert (forall ((Options.Option$V@@1 T@U) (bx@@126 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@1) TyType) (= (type bx@@126) BoxType)) ($IsBox bx@@126 (Tclass.Options.Option Options.Option$V@@1))) (and (= ($Box ($Unbox DatatypeTypeType bx@@126)) bx@@126) ($Is ($Unbox DatatypeTypeType bx@@126) (Tclass.Options.Option Options.Option$V@@1))))
 :qid |unknown.0:0|
 :skolemid |2813|
 :pattern ( ($IsBox bx@@126 (Tclass.Options.Option Options.Option$V@@1)))
)))
(assert (forall ((Options.Option$V@@2 T@U) ) (!  (=> (= (type Options.Option$V@@2) TyType) ($Is |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@2)))
 :qid |unknown.0:0|
 :skolemid |2814|
 :pattern ( ($Is |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@2)))
)))
(assert (forall ((Options.Option$V@@3 T@U) ($h@@97 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@3) TyType) (= (type $h@@97) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@97)) ($IsAlloc |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@3) $h@@97))
 :qid |unknown.0:0|
 :skolemid |2815|
 :pattern ( ($IsAlloc |#Options.Option.None| (Tclass.Options.Option Options.Option$V@@3) $h@@97))
)))
(assert (= |#Options.Option.None| (Lit |#Options.Option.None|)))
(assert (forall ((arg0@@452 T@U) ) (! (= (type (|#Options.Option.Some| arg0@@452)) DatatypeTypeType)
 :qid |funType:#Options.Option.Some|
 :pattern ( (|#Options.Option.Some| arg0@@452))
)))
(assert (forall ((|a#5#0#0@@5| T@U) ) (!  (=> (= (type |a#5#0#0@@5|) BoxType) (= (DatatypeCtorId (|#Options.Option.Some| |a#5#0#0@@5|)) |##Options.Option.Some|))
 :qid |Optionsdfy.5:36|
 :skolemid |2816|
 :pattern ( (|#Options.Option.Some| |a#5#0#0@@5|))
)))
(assert (forall ((d@@100 T@U) ) (!  (=> (= (type d@@100) DatatypeTypeType) (= (Options.Option.Some_q d@@100) (= (DatatypeCtorId d@@100) |##Options.Option.Some|)))
 :qid |unknown.0:0|
 :skolemid |2817|
 :pattern ( (Options.Option.Some_q d@@100))
)))
(assert (forall ((d@@101 T@U) ) (!  (=> (and (= (type d@@101) DatatypeTypeType) (Options.Option.Some_q d@@101)) (exists ((|a#6#0#0@@5| T@U) ) (!  (and (= (type |a#6#0#0@@5|) BoxType) (= d@@101 (|#Options.Option.Some| |a#6#0#0@@5|)))
 :qid |Optionsdfy.5:36|
 :skolemid |2818|
 :no-pattern (type |a#6#0#0@@5|)
 :no-pattern (U_2_int |a#6#0#0@@5|)
 :no-pattern (U_2_bool |a#6#0#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |2819|
 :pattern ( (Options.Option.Some_q d@@101))
)))
(assert (forall ((Options.Option$V@@4 T@U) (|a#7#0#0@@4| T@U) ) (!  (=> (and (= (type Options.Option$V@@4) TyType) (= (type |a#7#0#0@@4|) BoxType)) (= ($Is (|#Options.Option.Some| |a#7#0#0@@4|) (Tclass.Options.Option Options.Option$V@@4)) ($IsBox |a#7#0#0@@4| Options.Option$V@@4)))
 :qid |unknown.0:0|
 :skolemid |2820|
 :pattern ( ($Is (|#Options.Option.Some| |a#7#0#0@@4|) (Tclass.Options.Option Options.Option$V@@4)))
)))
(assert (forall ((Options.Option$V@@5 T@U) (|a#8#0#0@@4| T@U) ($h@@98 T@U) ) (!  (=> (and (and (and (= (type Options.Option$V@@5) TyType) (= (type |a#8#0#0@@4|) BoxType)) (= (type $h@@98) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@98)) (= ($IsAlloc (|#Options.Option.Some| |a#8#0#0@@4|) (Tclass.Options.Option Options.Option$V@@5) $h@@98) ($IsAllocBox |a#8#0#0@@4| Options.Option$V@@5 $h@@98)))
 :qid |unknown.0:0|
 :skolemid |2821|
 :pattern ( ($IsAlloc (|#Options.Option.Some| |a#8#0#0@@4|) (Tclass.Options.Option Options.Option$V@@5) $h@@98))
)))
(assert (forall ((arg0@@453 T@U) ) (! (= (type (Options.Option.value arg0@@453)) BoxType)
 :qid |funType:Options.Option.value|
 :pattern ( (Options.Option.value arg0@@453))
)))
(assert (forall ((d@@102 T@U) (Options.Option$V@@6 T@U) ($h@@99 T@U) ) (!  (=> (and (and (and (= (type d@@102) DatatypeTypeType) (= (type Options.Option$V@@6) TyType)) (= (type $h@@99) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@99) (and (Options.Option.Some_q d@@102) ($IsAlloc d@@102 (Tclass.Options.Option Options.Option$V@@6) $h@@99)))) ($IsAllocBox (Options.Option.value d@@102) Options.Option$V@@6 $h@@99))
 :qid |unknown.0:0|
 :skolemid |2822|
 :pattern ( ($IsAllocBox (Options.Option.value d@@102) Options.Option$V@@6 $h@@99))
)))
(assert (forall ((|a#9#0#0@@0| T@U) ) (!  (=> (= (type |a#9#0#0@@0|) BoxType) (= (|#Options.Option.Some| (Lit |a#9#0#0@@0|)) (Lit (|#Options.Option.Some| |a#9#0#0@@0|))))
 :qid |Optionsdfy.5:36|
 :skolemid |2823|
 :pattern ( (|#Options.Option.Some| (Lit |a#9#0#0@@0|)))
)))
(assert (forall ((|a#10#0#0@@0| T@U) ) (!  (=> (= (type |a#10#0#0@@0|) BoxType) (= (Options.Option.value (|#Options.Option.Some| |a#10#0#0@@0|)) |a#10#0#0@@0|))
 :qid |Optionsdfy.5:36|
 :skolemid |2824|
 :pattern ( (|#Options.Option.Some| |a#10#0#0@@0|))
)))
(assert (forall ((|a#11#0#0| T@U) ) (!  (=> (= (type |a#11#0#0|) BoxType) (< (BoxRank |a#11#0#0|) (DtRank (|#Options.Option.Some| |a#11#0#0|))))
 :qid |Optionsdfy.5:36|
 :skolemid |2825|
 :pattern ( (|#Options.Option.Some| |a#11#0#0|))
)))
(assert (forall ((d@@103 T@U) ) (!  (=> (and (= (type d@@103) DatatypeTypeType) (|$IsA#Options.Option| d@@103)) (or (Options.Option.None_q d@@103) (Options.Option.Some_q d@@103)))
 :qid |unknown.0:0|
 :skolemid |2826|
 :pattern ( (|$IsA#Options.Option| d@@103))
)))
(assert (forall ((Options.Option$V@@7 T@U) (d@@104 T@U) ) (!  (=> (and (and (= (type Options.Option$V@@7) TyType) (= (type d@@104) DatatypeTypeType)) ($Is d@@104 (Tclass.Options.Option Options.Option$V@@7))) (or (Options.Option.None_q d@@104) (Options.Option.Some_q d@@104)))
 :qid |unknown.0:0|
 :skolemid |2827|
 :pattern ( (Options.Option.Some_q d@@104) ($Is d@@104 (Tclass.Options.Option Options.Option$V@@7)))
 :pattern ( (Options.Option.None_q d@@104) ($Is d@@104 (Tclass.Options.Option Options.Option$V@@7)))
)))
(assert (forall ((a@@146 T@U) (b@@95 T@U) ) (!  (=> (and (and (= (type a@@146) DatatypeTypeType) (= (type b@@95) DatatypeTypeType)) (and (Options.Option.None_q a@@146) (Options.Option.None_q b@@95))) (= (|Options.Option#Equal| a@@146 b@@95) true))
 :qid |unknown.0:0|
 :skolemid |2828|
 :pattern ( (|Options.Option#Equal| a@@146 b@@95) (Options.Option.None_q a@@146))
 :pattern ( (|Options.Option#Equal| a@@146 b@@95) (Options.Option.None_q b@@95))
)))
(assert (forall ((a@@147 T@U) (b@@96 T@U) ) (!  (=> (and (and (= (type a@@147) DatatypeTypeType) (= (type b@@96) DatatypeTypeType)) (and (Options.Option.Some_q a@@147) (Options.Option.Some_q b@@96))) (= (|Options.Option#Equal| a@@147 b@@96) (= (Options.Option.value a@@147) (Options.Option.value b@@96))))
 :qid |unknown.0:0|
 :skolemid |2829|
 :pattern ( (|Options.Option#Equal| a@@147 b@@96) (Options.Option.Some_q a@@147))
 :pattern ( (|Options.Option#Equal| a@@147 b@@96) (Options.Option.Some_q b@@96))
)))
(assert (forall ((a@@148 T@U) (b@@97 T@U) ) (!  (=> (and (= (type a@@148) DatatypeTypeType) (= (type b@@97) DatatypeTypeType)) (= (|Options.Option#Equal| a@@148 b@@97) (= a@@148 b@@97)))
 :qid |unknown.0:0|
 :skolemid |2830|
 :pattern ( (|Options.Option#Equal| a@@148 b@@97))
)))
(assert (= (type Tclass.Options.__default) TyType))
(assert (= (Tag Tclass.Options.__default) Tagclass.Options.__default))
(assert (= (TagFamily Tclass.Options.__default) tytagFamily$_default))
(assert (forall ((bx@@127 T@U) ) (!  (=> (and (= (type bx@@127) BoxType) ($IsBox bx@@127 Tclass.Options.__default)) (and (= ($Box ($Unbox refType bx@@127)) bx@@127) ($Is ($Unbox refType bx@@127) Tclass.Options.__default)))
 :qid |unknown.0:0|
 :skolemid |2831|
 :pattern ( ($IsBox bx@@127 Tclass.Options.__default))
)))
(assert (forall (($o@@11 T@U) ) (!  (=> (= (type $o@@11) refType) (= ($Is $o@@11 Tclass.Options.__default)  (or (= $o@@11 null) (= (dtype $o@@11) Tclass.Options.__default))))
 :qid |unknown.0:0|
 :skolemid |2832|
 :pattern ( ($Is $o@@11 Tclass.Options.__default))
)))
(assert (forall (($o@@12 T@U) ($h@@100 T@U) ) (!  (=> (and (= (type $o@@12) refType) (= (type $h@@100) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@12 Tclass.Options.__default $h@@100)  (or (= $o@@12 null) (U_2_bool (MapType1Select (MapType0Select $h@@100 $o@@12) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2833|
 :pattern ( ($IsAlloc $o@@12 Tclass.Options.__default $h@@100))
)))
(assert (forall ((arg0@@454 T@U) (arg1@@182 T@U) (arg2@@88 T@U) (arg3@@46 T@U) (arg4@@29 T@U) ) (! (= (type (Options.__default.MapOption arg0@@454 arg1@@182 arg2@@88 arg3@@46 arg4@@29)) DatatypeTypeType)
 :qid |funType:Options.__default.MapOption|
 :pattern ( (Options.__default.MapOption arg0@@454 arg1@@182 arg2@@88 arg3@@46 arg4@@29))
)))
(assert (forall ((Options._default.MapOption$V0 T@U) (Options._default.MapOption$V1 T@U) ($h0 T@U) ($h1 T@U) (|opt#0| T@U) (|f#0@@67| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Options._default.MapOption$V0) TyType) (= (type Options._default.MapOption$V1) TyType)) (= (type $h0) (MapType0Type refType MapType1Type))) (= (type $h1) (MapType0Type refType MapType1Type))) (= (type |opt#0|) DatatypeTypeType)) (= (type |f#0@@67|) HandleTypeType)) (and (and (and ($IsGoodHeap $h0) ($IsGoodHeap $h1)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |opt#0| |f#0@@67|) (and ($Is |opt#0| (Tclass.Options.Option Options._default.MapOption$V0)) ($Is |f#0@@67| (Tclass._System.___hFunc1 Options._default.MapOption$V0 Options._default.MapOption$V1))))) (and ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1)))) (forall (($o@@13 T@U) ($f T@U) ) (! (let ((alpha@@6 (FieldTypeInv0 (type $f))))
 (=> (and (and (= (type $o@@13) refType) (= (type $f) (FieldType alpha@@6))) (and (not (= $o@@13 null)) (U_2_bool (MapType0Select (ite (Options.Option.Some_q |opt#0|) (Reads1 Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |f#0@@67| (Options.Option.value |opt#0|)) (|Set#Empty| BoxType)) ($Box $o@@13))))) (= (MapType1Select (MapType0Select $h0 $o@@13) $f) (MapType1Select (MapType0Select $h1 $o@@13) $f))))
 :qid |unknown.0:0|
 :skolemid |2834|
 :no-pattern (type $o@@13)
 :no-pattern (type $f)
 :no-pattern (U_2_int $o@@13)
 :no-pattern (U_2_bool $o@@13)
 :no-pattern (U_2_int $f)
 :no-pattern (U_2_bool $f)
))) (= (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h0 |opt#0| |f#0@@67|) (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h1 |opt#0| |f#0@@67|)))
 :qid |unknown.0:0|
 :skolemid |2835|
 :pattern ( ($IsHeapAnchor $h0) ($HeapSucc $h0 $h1) (Options.__default.MapOption Options._default.MapOption$V0 Options._default.MapOption$V1 $h1 |opt#0| |f#0@@67|))
)))
(assert  (=> true (forall ((Options._default.MapOption$V0@@0 T@U) (Options._default.MapOption$V1@@0 T@U) ($Heap@@6 T@U) (|opt#0@@0| T@U) (|f#0@@68| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@0) TyType) (= (type Options._default.MapOption$V1@@0) TyType)) (= (type $Heap@@6) (MapType0Type refType MapType1Type))) (= (type |opt#0@@0|) DatatypeTypeType)) (= (type |f#0@@68|) HandleTypeType)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|) (and (and (and ($IsGoodHeap $Heap@@6) ($Is |opt#0@@0| (Tclass.Options.Option Options._default.MapOption$V0@@0))) ($Is |f#0@@68| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0))) (=> (Options.Option.Some_q |opt#0@@0|) (Requires1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |f#0@@68| (Options.Option.value |opt#0@@0|)))))) (and (and (= (Options.Option.Some_q |opt#0@@0|) (Options.Option.Some_q (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|))) (=> (Options.Option.Some_q (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|)) (= (Options.Option.value (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|)) (Apply1 Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |f#0@@68| (Options.Option.value |opt#0@@0|))))) ($Is (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|) (Tclass.Options.Option Options._default.MapOption$V1@@0))))
 :qid |unknown.0:0|
 :skolemid |2836|
 :pattern ( (Options.__default.MapOption Options._default.MapOption$V0@@0 Options._default.MapOption$V1@@0 $Heap@@6 |opt#0@@0| |f#0@@68|))
))))
(assert (forall ((Options._default.MapOption$V0@@1 T@U) (Options._default.MapOption$V1@@1 T@U) ($Heap@@7 T@U) (|opt#0@@1| T@U) (|f#0@@69| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@1) TyType) (= (type Options._default.MapOption$V1@@1) TyType)) (= (type $Heap@@7) (MapType0Type refType MapType1Type))) (= (type |opt#0@@1|) DatatypeTypeType)) (= (type |f#0@@69|) HandleTypeType)) (and (and ($IsGoodHeap $Heap@@7) ($Is |opt#0@@1| (Tclass.Options.Option Options._default.MapOption$V0@@1))) ($Is |f#0@@69| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1)))) (= (|Options.__default.MapOption#requires| Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@7 |opt#0@@1| |f#0@@69|)  (=> (Options.Option.Some_q |opt#0@@1|) (Requires1 Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@7 |f#0@@69| (Options.Option.value |opt#0@@1|)))))
 :qid |unknown.0:0|
 :skolemid |2837|
 :pattern ( (|Options.__default.MapOption#requires| Options._default.MapOption$V0@@1 Options._default.MapOption$V1@@1 $Heap@@7 |opt#0@@1| |f#0@@69|) ($IsGoodHeap $Heap@@7))
)))
(assert  (=> true (forall ((Options._default.MapOption$V0@@2 T@U) (Options._default.MapOption$V1@@2 T@U) ($Heap@@8 T@U) (|opt#0@@2| T@U) (|f#0@@70| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.MapOption$V0@@2) TyType) (= (type Options._default.MapOption$V1@@2) TyType)) (= (type $Heap@@8) (MapType0Type refType MapType1Type))) (= (type |opt#0@@2|) DatatypeTypeType)) (= (type |f#0@@70|) HandleTypeType)) (or (|Options.__default.MapOption#canCall| Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@8 |opt#0@@2| |f#0@@70|) (and (and (and ($IsGoodHeap $Heap@@8) ($Is |opt#0@@2| (Tclass.Options.Option Options._default.MapOption$V0@@2))) ($Is |f#0@@70| (Tclass._System.___hFunc1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2))) (=> (Options.Option.Some_q |opt#0@@2|) (Requires1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@8 |f#0@@70| (Options.Option.value |opt#0@@2|)))))) (= (Options.__default.MapOption Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@8 |opt#0@@2| |f#0@@70|) (ite (Options.Option.None_q |opt#0@@2|) |#Options.Option.None| (let ((|v#0@@51| (Options.Option.value |opt#0@@2|)))
(|#Options.Option.Some| (Apply1 Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@8 |f#0@@70| |v#0@@51|))))))
 :qid |unknown.0:0|
 :skolemid |2838|
 :pattern ( (Options.__default.MapOption Options._default.MapOption$V0@@2 Options._default.MapOption$V1@@2 $Heap@@8 |opt#0@@2| |f#0@@70|) ($IsGoodHeap $Heap@@8))
))))
(assert (forall ((arg0@@455 T@U) (arg1@@183 T@U) (arg2@@89 T@U) (arg3@@47 T@U) (arg4@@30 T@U) ) (! (= (type (Options.__default.FlatMapOption arg0@@455 arg1@@183 arg2@@89 arg3@@47 arg4@@30)) DatatypeTypeType)
 :qid |funType:Options.__default.FlatMapOption|
 :pattern ( (Options.__default.FlatMapOption arg0@@455 arg1@@183 arg2@@89 arg3@@47 arg4@@30))
)))
(assert (forall ((Options._default.FlatMapOption$V0 T@U) (Options._default.FlatMapOption$V1 T@U) ($h0@@0 T@U) ($h1@@0 T@U) (|opt#0@@3| T@U) (|f#0@@71| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Options._default.FlatMapOption$V0) TyType) (= (type Options._default.FlatMapOption$V1) TyType)) (= (type $h0@@0) (MapType0Type refType MapType1Type))) (= (type $h1@@0) (MapType0Type refType MapType1Type))) (= (type |opt#0@@3|) DatatypeTypeType)) (= (type |f#0@@71|) HandleTypeType)) (and (and (and ($IsGoodHeap $h0@@0) ($IsGoodHeap $h1@@0)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h0@@0 |opt#0@@3| |f#0@@71|) (and ($Is |opt#0@@3| (Tclass.Options.Option Options._default.FlatMapOption$V0)) ($Is |f#0@@71| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0 (Tclass.Options.Option Options._default.FlatMapOption$V1)))))) (and ($IsHeapAnchor $h0@@0) ($HeapSucc $h0@@0 $h1@@0)))) (forall (($o@@14 T@U) ($f@@0 T@U) ) (! (let ((alpha@@7 (FieldTypeInv0 (type $f@@0))))
 (=> (and (and (= (type $o@@14) refType) (= (type $f@@0) (FieldType alpha@@7))) (and (not (= $o@@14 null)) (U_2_bool (MapType0Select (ite (Options.Option.Some_q |opt#0@@3|) (Reads1 Options._default.FlatMapOption$V0 (Tclass.Options.Option Options._default.FlatMapOption$V1) $h0@@0 |f#0@@71| (Options.Option.value |opt#0@@3|)) (|Set#Empty| BoxType)) ($Box $o@@14))))) (= (MapType1Select (MapType0Select $h0@@0 $o@@14) $f@@0) (MapType1Select (MapType0Select $h1@@0 $o@@14) $f@@0))))
 :qid |unknown.0:0|
 :skolemid |2839|
 :no-pattern (type $o@@14)
 :no-pattern (type $f@@0)
 :no-pattern (U_2_int $o@@14)
 :no-pattern (U_2_bool $o@@14)
 :no-pattern (U_2_int $f@@0)
 :no-pattern (U_2_bool $f@@0)
))) (= (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h0@@0 |opt#0@@3| |f#0@@71|) (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h1@@0 |opt#0@@3| |f#0@@71|)))
 :qid |unknown.0:0|
 :skolemid |2840|
 :pattern ( ($IsHeapAnchor $h0@@0) ($HeapSucc $h0@@0 $h1@@0) (Options.__default.FlatMapOption Options._default.FlatMapOption$V0 Options._default.FlatMapOption$V1 $h1@@0 |opt#0@@3| |f#0@@71|))
)))
(assert  (=> true (forall ((Options._default.FlatMapOption$V0@@0 T@U) (Options._default.FlatMapOption$V1@@0 T@U) ($Heap@@9 T@U) (|opt#0@@4| T@U) (|f#0@@72| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@0) TyType) (= (type Options._default.FlatMapOption$V1@@0) TyType)) (= (type $Heap@@9) (MapType0Type refType MapType1Type))) (= (type |opt#0@@4|) DatatypeTypeType)) (= (type |f#0@@72|) HandleTypeType)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@9 |opt#0@@4| |f#0@@72|) (and (and (and ($IsGoodHeap $Heap@@9) ($Is |opt#0@@4| (Tclass.Options.Option Options._default.FlatMapOption$V0@@0))) ($Is |f#0@@72| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0)))) (=> (Options.Option.Some_q |opt#0@@4|) (Requires1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@9 |f#0@@72| (Options.Option.value |opt#0@@4|)))))) (and (and (=> (and (Options.Option.Some_q |opt#0@@4|) (Options.Option.Some_q ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@9 |f#0@@72| (Options.Option.value |opt#0@@4|))))) (Options.Option.Some_q (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@9 |opt#0@@4| |f#0@@72|))) (=> (and (Options.Option.Some_q |opt#0@@4|) (Options.Option.Some_q ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@9 |f#0@@72| (Options.Option.value |opt#0@@4|))))) (= (Options.Option.value (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@9 |opt#0@@4| |f#0@@72|)) (Options.Option.value ($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@0 (Tclass.Options.Option Options._default.FlatMapOption$V1@@0) $Heap@@9 |f#0@@72| (Options.Option.value |opt#0@@4|))))))) ($Is (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@9 |opt#0@@4| |f#0@@72|) (Tclass.Options.Option Options._default.FlatMapOption$V1@@0))))
 :qid |unknown.0:0|
 :skolemid |2841|
 :pattern ( (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@0 Options._default.FlatMapOption$V1@@0 $Heap@@9 |opt#0@@4| |f#0@@72|))
))))
(assert (forall ((Options._default.FlatMapOption$V0@@1 T@U) (Options._default.FlatMapOption$V1@@1 T@U) ($Heap@@10 T@U) (|opt#0@@5| T@U) (|f#0@@73| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@1) TyType) (= (type Options._default.FlatMapOption$V1@@1) TyType)) (= (type $Heap@@10) (MapType0Type refType MapType1Type))) (= (type |opt#0@@5|) DatatypeTypeType)) (= (type |f#0@@73|) HandleTypeType)) (and (and ($IsGoodHeap $Heap@@10) ($Is |opt#0@@5| (Tclass.Options.Option Options._default.FlatMapOption$V0@@1))) ($Is |f#0@@73| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@1 (Tclass.Options.Option Options._default.FlatMapOption$V1@@1))))) (= (|Options.__default.FlatMapOption#requires| Options._default.FlatMapOption$V0@@1 Options._default.FlatMapOption$V1@@1 $Heap@@10 |opt#0@@5| |f#0@@73|)  (=> (Options.Option.Some_q |opt#0@@5|) (Requires1 Options._default.FlatMapOption$V0@@1 (Tclass.Options.Option Options._default.FlatMapOption$V1@@1) $Heap@@10 |f#0@@73| (Options.Option.value |opt#0@@5|)))))
 :qid |unknown.0:0|
 :skolemid |2842|
 :pattern ( (|Options.__default.FlatMapOption#requires| Options._default.FlatMapOption$V0@@1 Options._default.FlatMapOption$V1@@1 $Heap@@10 |opt#0@@5| |f#0@@73|) ($IsGoodHeap $Heap@@10))
)))
(assert  (=> true (forall ((Options._default.FlatMapOption$V0@@2 T@U) (Options._default.FlatMapOption$V1@@2 T@U) ($Heap@@11 T@U) (|opt#0@@6| T@U) (|f#0@@74| T@U) ) (!  (=> (and (and (and (and (and (= (type Options._default.FlatMapOption$V0@@2) TyType) (= (type Options._default.FlatMapOption$V1@@2) TyType)) (= (type $Heap@@11) (MapType0Type refType MapType1Type))) (= (type |opt#0@@6|) DatatypeTypeType)) (= (type |f#0@@74|) HandleTypeType)) (or (|Options.__default.FlatMapOption#canCall| Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@11 |opt#0@@6| |f#0@@74|) (and (and (and ($IsGoodHeap $Heap@@11) ($Is |opt#0@@6| (Tclass.Options.Option Options._default.FlatMapOption$V0@@2))) ($Is |f#0@@74| (Tclass._System.___hFunc1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2)))) (=> (Options.Option.Some_q |opt#0@@6|) (Requires1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2) $Heap@@11 |f#0@@74| (Options.Option.value |opt#0@@6|)))))) (= (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@11 |opt#0@@6| |f#0@@74|) (ite (Options.Option.None_q |opt#0@@6|) |#Options.Option.None| (let ((|v#0@@52| (Options.Option.value |opt#0@@6|)))
($Unbox DatatypeTypeType (Apply1 Options._default.FlatMapOption$V0@@2 (Tclass.Options.Option Options._default.FlatMapOption$V1@@2) $Heap@@11 |f#0@@74| |v#0@@52|))))))
 :qid |unknown.0:0|
 :skolemid |2843|
 :pattern ( (Options.__default.FlatMapOption Options._default.FlatMapOption$V0@@2 Options._default.FlatMapOption$V1@@2 $Heap@@11 |opt#0@@6| |f#0@@74|) ($IsGoodHeap $Heap@@11))
))))
(assert (= (type Tclass.NativeTypes.sbyte) TyType))
(assert (= (Tag Tclass.NativeTypes.sbyte) Tagclass.NativeTypes.sbyte))
(assert (= (TagFamily Tclass.NativeTypes.sbyte) tytagFamily$sbyte))
(assert (forall ((bx@@128 T@U) ) (!  (=> (and (= (type bx@@128) BoxType) ($IsBox bx@@128 Tclass.NativeTypes.sbyte)) (and (= ($Box ($Unbox intType bx@@128)) bx@@128) ($Is ($Unbox intType bx@@128) Tclass.NativeTypes.sbyte)))
 :qid |unknown.0:0|
 :skolemid |2844|
 :pattern ( ($IsBox bx@@128 Tclass.NativeTypes.sbyte))
)))
(assert (forall ((|i#0@@31| T@U) ) (!  (=> (= (type |i#0@@31|) intType) (= ($Is |i#0@@31| Tclass.NativeTypes.sbyte)  (and (INTERNAL_le_boogie (- 0 128) (U_2_int |i#0@@31|)) (INTERNAL_lt_boogie (U_2_int |i#0@@31|) 128))))
 :qid |unknown.0:0|
 :skolemid |2845|
 :pattern ( ($Is |i#0@@31| Tclass.NativeTypes.sbyte))
)))
(assert (forall ((|i#0@@32| T@U) ($h@@101 T@U) ) (!  (=> (and (= (type |i#0@@32|) intType) (= (type $h@@101) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@32| Tclass.NativeTypes.sbyte $h@@101))
 :qid |unknown.0:0|
 :skolemid |2846|
 :pattern ( ($IsAlloc |i#0@@32| Tclass.NativeTypes.sbyte $h@@101))
)))
(assert (forall ((|i#0@@33| T@U) ) (!  (=> (= (type |i#0@@33|) intType) (= ($Is |i#0@@33| Tclass.NativeTypes.byte)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@33|)) (INTERNAL_lt_boogie (U_2_int |i#0@@33|) 256))))
 :qid |unknown.0:0|
 :skolemid |2847|
 :pattern ( ($Is |i#0@@33| Tclass.NativeTypes.byte))
)))
(assert (forall ((|i#0@@34| T@U) ($h@@102 T@U) ) (!  (=> (and (= (type |i#0@@34|) intType) (= (type $h@@102) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@34| Tclass.NativeTypes.byte $h@@102))
 :qid |unknown.0:0|
 :skolemid |2848|
 :pattern ( ($IsAlloc |i#0@@34| Tclass.NativeTypes.byte $h@@102))
)))
(assert (= (type Tclass.NativeTypes.int16) TyType))
(assert (= (Tag Tclass.NativeTypes.int16) Tagclass.NativeTypes.int16))
(assert (= (TagFamily Tclass.NativeTypes.int16) tytagFamily$int16))
(assert (forall ((bx@@129 T@U) ) (!  (=> (and (= (type bx@@129) BoxType) ($IsBox bx@@129 Tclass.NativeTypes.int16)) (and (= ($Box ($Unbox intType bx@@129)) bx@@129) ($Is ($Unbox intType bx@@129) Tclass.NativeTypes.int16)))
 :qid |unknown.0:0|
 :skolemid |2849|
 :pattern ( ($IsBox bx@@129 Tclass.NativeTypes.int16))
)))
(assert (forall ((|i#0@@35| T@U) ) (!  (=> (= (type |i#0@@35|) intType) (= ($Is |i#0@@35| Tclass.NativeTypes.int16)  (and (INTERNAL_le_boogie (- 0 32768) (U_2_int |i#0@@35|)) (INTERNAL_lt_boogie (U_2_int |i#0@@35|) 32768))))
 :qid |unknown.0:0|
 :skolemid |2850|
 :pattern ( ($Is |i#0@@35| Tclass.NativeTypes.int16))
)))
(assert (forall ((|i#0@@36| T@U) ($h@@103 T@U) ) (!  (=> (and (= (type |i#0@@36|) intType) (= (type $h@@103) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@36| Tclass.NativeTypes.int16 $h@@103))
 :qid |unknown.0:0|
 :skolemid |2851|
 :pattern ( ($IsAlloc |i#0@@36| Tclass.NativeTypes.int16 $h@@103))
)))
(assert (= (type Tclass.NativeTypes.uint16) TyType))
(assert (= (Tag Tclass.NativeTypes.uint16) Tagclass.NativeTypes.uint16))
(assert (= (TagFamily Tclass.NativeTypes.uint16) tytagFamily$uint16))
(assert (forall ((bx@@130 T@U) ) (!  (=> (and (= (type bx@@130) BoxType) ($IsBox bx@@130 Tclass.NativeTypes.uint16)) (and (= ($Box ($Unbox intType bx@@130)) bx@@130) ($Is ($Unbox intType bx@@130) Tclass.NativeTypes.uint16)))
 :qid |unknown.0:0|
 :skolemid |2852|
 :pattern ( ($IsBox bx@@130 Tclass.NativeTypes.uint16))
)))
(assert (forall ((|i#0@@37| T@U) ) (!  (=> (= (type |i#0@@37|) intType) (= ($Is |i#0@@37| Tclass.NativeTypes.uint16)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@37|)) (INTERNAL_lt_boogie (U_2_int |i#0@@37|) 65536))))
 :qid |unknown.0:0|
 :skolemid |2853|
 :pattern ( ($Is |i#0@@37| Tclass.NativeTypes.uint16))
)))
(assert (forall ((|i#0@@38| T@U) ($h@@104 T@U) ) (!  (=> (and (= (type |i#0@@38|) intType) (= (type $h@@104) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@38| Tclass.NativeTypes.uint16 $h@@104))
 :qid |unknown.0:0|
 :skolemid |2854|
 :pattern ( ($IsAlloc |i#0@@38| Tclass.NativeTypes.uint16 $h@@104))
)))
(assert (= (type Tclass.NativeTypes.int32) TyType))
(assert (= (Tag Tclass.NativeTypes.int32) Tagclass.NativeTypes.int32))
(assert (= (TagFamily Tclass.NativeTypes.int32) tytagFamily$int32))
(assert (forall ((bx@@131 T@U) ) (!  (=> (and (= (type bx@@131) BoxType) ($IsBox bx@@131 Tclass.NativeTypes.int32)) (and (= ($Box ($Unbox intType bx@@131)) bx@@131) ($Is ($Unbox intType bx@@131) Tclass.NativeTypes.int32)))
 :qid |unknown.0:0|
 :skolemid |2855|
 :pattern ( ($IsBox bx@@131 Tclass.NativeTypes.int32))
)))
(assert (forall ((|i#0@@39| T@U) ) (!  (=> (= (type |i#0@@39|) intType) (= ($Is |i#0@@39| Tclass.NativeTypes.int32)  (and (INTERNAL_le_boogie (- 0 2147483648) (U_2_int |i#0@@39|)) (INTERNAL_lt_boogie (U_2_int |i#0@@39|) 2147483648))))
 :qid |unknown.0:0|
 :skolemid |2856|
 :pattern ( ($Is |i#0@@39| Tclass.NativeTypes.int32))
)))
(assert (forall ((|i#0@@40| T@U) ($h@@105 T@U) ) (!  (=> (and (= (type |i#0@@40|) intType) (= (type $h@@105) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@40| Tclass.NativeTypes.int32 $h@@105))
 :qid |unknown.0:0|
 :skolemid |2857|
 :pattern ( ($IsAlloc |i#0@@40| Tclass.NativeTypes.int32 $h@@105))
)))
(assert (= (type Tclass.NativeTypes.uint32) TyType))
(assert (= (Tag Tclass.NativeTypes.uint32) Tagclass.NativeTypes.uint32))
(assert (= (TagFamily Tclass.NativeTypes.uint32) tytagFamily$uint32))
(assert (forall ((bx@@132 T@U) ) (!  (=> (and (= (type bx@@132) BoxType) ($IsBox bx@@132 Tclass.NativeTypes.uint32)) (and (= ($Box ($Unbox intType bx@@132)) bx@@132) ($Is ($Unbox intType bx@@132) Tclass.NativeTypes.uint32)))
 :qid |unknown.0:0|
 :skolemid |2858|
 :pattern ( ($IsBox bx@@132 Tclass.NativeTypes.uint32))
)))
(assert (forall ((|i#0@@41| T@U) ) (!  (=> (= (type |i#0@@41|) intType) (= ($Is |i#0@@41| Tclass.NativeTypes.uint32)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@41|)) (INTERNAL_lt_boogie (U_2_int |i#0@@41|) 4294967296))))
 :qid |unknown.0:0|
 :skolemid |2859|
 :pattern ( ($Is |i#0@@41| Tclass.NativeTypes.uint32))
)))
(assert (forall ((|i#0@@42| T@U) ($h@@106 T@U) ) (!  (=> (and (= (type |i#0@@42|) intType) (= (type $h@@106) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@42| Tclass.NativeTypes.uint32 $h@@106))
 :qid |unknown.0:0|
 :skolemid |2860|
 :pattern ( ($IsAlloc |i#0@@42| Tclass.NativeTypes.uint32 $h@@106))
)))
(assert (= (type Tclass.NativeTypes.int64) TyType))
(assert (= (Tag Tclass.NativeTypes.int64) Tagclass.NativeTypes.int64))
(assert (= (TagFamily Tclass.NativeTypes.int64) tytagFamily$int64))
(assert (forall ((bx@@133 T@U) ) (!  (=> (and (= (type bx@@133) BoxType) ($IsBox bx@@133 Tclass.NativeTypes.int64)) (and (= ($Box ($Unbox intType bx@@133)) bx@@133) ($Is ($Unbox intType bx@@133) Tclass.NativeTypes.int64)))
 :qid |unknown.0:0|
 :skolemid |2861|
 :pattern ( ($IsBox bx@@133 Tclass.NativeTypes.int64))
)))
(assert (forall ((|i#0@@43| T@U) ) (!  (=> (= (type |i#0@@43|) intType) (= ($Is |i#0@@43| Tclass.NativeTypes.int64)  (and (INTERNAL_le_boogie (- 0 9223372036854775808) (U_2_int |i#0@@43|)) (INTERNAL_lt_boogie (U_2_int |i#0@@43|) 9223372036854775808))))
 :qid |unknown.0:0|
 :skolemid |2862|
 :pattern ( ($Is |i#0@@43| Tclass.NativeTypes.int64))
)))
(assert (forall ((|i#0@@44| T@U) ($h@@107 T@U) ) (!  (=> (and (= (type |i#0@@44|) intType) (= (type $h@@107) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@44| Tclass.NativeTypes.int64 $h@@107))
 :qid |unknown.0:0|
 :skolemid |2863|
 :pattern ( ($IsAlloc |i#0@@44| Tclass.NativeTypes.int64 $h@@107))
)))
(assert (= (type Tclass.NativeTypes.uint64) TyType))
(assert (= (Tag Tclass.NativeTypes.uint64) Tagclass.NativeTypes.uint64))
(assert (= (TagFamily Tclass.NativeTypes.uint64) tytagFamily$uint64))
(assert (forall ((bx@@134 T@U) ) (!  (=> (and (= (type bx@@134) BoxType) ($IsBox bx@@134 Tclass.NativeTypes.uint64)) (and (= ($Box ($Unbox intType bx@@134)) bx@@134) ($Is ($Unbox intType bx@@134) Tclass.NativeTypes.uint64)))
 :qid |unknown.0:0|
 :skolemid |2864|
 :pattern ( ($IsBox bx@@134 Tclass.NativeTypes.uint64))
)))
(assert (forall ((|i#0@@45| T@U) ) (!  (=> (= (type |i#0@@45|) intType) (= ($Is |i#0@@45| Tclass.NativeTypes.uint64)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@45|)) (INTERNAL_lt_boogie (U_2_int |i#0@@45|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |2865|
 :pattern ( ($Is |i#0@@45| Tclass.NativeTypes.uint64))
)))
(assert (forall ((|i#0@@46| T@U) ($h@@108 T@U) ) (!  (=> (and (= (type |i#0@@46|) intType) (= (type $h@@108) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@46| Tclass.NativeTypes.uint64 $h@@108))
 :qid |unknown.0:0|
 :skolemid |2866|
 :pattern ( ($IsAlloc |i#0@@46| Tclass.NativeTypes.uint64 $h@@108))
)))
(assert (= (type Tclass.NativeTypes.nat8) TyType))
(assert (= (Tag Tclass.NativeTypes.nat8) Tagclass.NativeTypes.nat8))
(assert (= (TagFamily Tclass.NativeTypes.nat8) tytagFamily$nat8))
(assert (forall ((bx@@135 T@U) ) (!  (=> (and (= (type bx@@135) BoxType) ($IsBox bx@@135 Tclass.NativeTypes.nat8)) (and (= ($Box ($Unbox intType bx@@135)) bx@@135) ($Is ($Unbox intType bx@@135) Tclass.NativeTypes.nat8)))
 :qid |unknown.0:0|
 :skolemid |2867|
 :pattern ( ($IsBox bx@@135 Tclass.NativeTypes.nat8))
)))
(assert (forall ((|i#0@@47| T@U) ) (!  (=> (= (type |i#0@@47|) intType) (= ($Is |i#0@@47| Tclass.NativeTypes.nat8)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@47|)) (INTERNAL_lt_boogie (U_2_int |i#0@@47|) 128))))
 :qid |unknown.0:0|
 :skolemid |2868|
 :pattern ( ($Is |i#0@@47| Tclass.NativeTypes.nat8))
)))
(assert (forall ((|i#0@@48| T@U) ($h@@109 T@U) ) (!  (=> (and (= (type |i#0@@48|) intType) (= (type $h@@109) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@48| Tclass.NativeTypes.nat8 $h@@109))
 :qid |unknown.0:0|
 :skolemid |2869|
 :pattern ( ($IsAlloc |i#0@@48| Tclass.NativeTypes.nat8 $h@@109))
)))
(assert (= (type Tclass.NativeTypes.nat16) TyType))
(assert (= (Tag Tclass.NativeTypes.nat16) Tagclass.NativeTypes.nat16))
(assert (= (TagFamily Tclass.NativeTypes.nat16) tytagFamily$nat16))
(assert (forall ((bx@@136 T@U) ) (!  (=> (and (= (type bx@@136) BoxType) ($IsBox bx@@136 Tclass.NativeTypes.nat16)) (and (= ($Box ($Unbox intType bx@@136)) bx@@136) ($Is ($Unbox intType bx@@136) Tclass.NativeTypes.nat16)))
 :qid |unknown.0:0|
 :skolemid |2870|
 :pattern ( ($IsBox bx@@136 Tclass.NativeTypes.nat16))
)))
(assert (forall ((|i#0@@49| T@U) ) (!  (=> (= (type |i#0@@49|) intType) (= ($Is |i#0@@49| Tclass.NativeTypes.nat16)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@49|)) (INTERNAL_lt_boogie (U_2_int |i#0@@49|) 32768))))
 :qid |unknown.0:0|
 :skolemid |2871|
 :pattern ( ($Is |i#0@@49| Tclass.NativeTypes.nat16))
)))
(assert (forall ((|i#0@@50| T@U) ($h@@110 T@U) ) (!  (=> (and (= (type |i#0@@50|) intType) (= (type $h@@110) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@50| Tclass.NativeTypes.nat16 $h@@110))
 :qid |unknown.0:0|
 :skolemid |2872|
 :pattern ( ($IsAlloc |i#0@@50| Tclass.NativeTypes.nat16 $h@@110))
)))
(assert (= (type Tclass.NativeTypes.nat32) TyType))
(assert (= (Tag Tclass.NativeTypes.nat32) Tagclass.NativeTypes.nat32))
(assert (= (TagFamily Tclass.NativeTypes.nat32) tytagFamily$nat32))
(assert (forall ((bx@@137 T@U) ) (!  (=> (and (= (type bx@@137) BoxType) ($IsBox bx@@137 Tclass.NativeTypes.nat32)) (and (= ($Box ($Unbox intType bx@@137)) bx@@137) ($Is ($Unbox intType bx@@137) Tclass.NativeTypes.nat32)))
 :qid |unknown.0:0|
 :skolemid |2873|
 :pattern ( ($IsBox bx@@137 Tclass.NativeTypes.nat32))
)))
(assert (forall ((|i#0@@51| T@U) ) (!  (=> (= (type |i#0@@51|) intType) (= ($Is |i#0@@51| Tclass.NativeTypes.nat32)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@51|)) (INTERNAL_lt_boogie (U_2_int |i#0@@51|) 2147483648))))
 :qid |unknown.0:0|
 :skolemid |2874|
 :pattern ( ($Is |i#0@@51| Tclass.NativeTypes.nat32))
)))
(assert (forall ((|i#0@@52| T@U) ($h@@111 T@U) ) (!  (=> (and (= (type |i#0@@52|) intType) (= (type $h@@111) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@52| Tclass.NativeTypes.nat32 $h@@111))
 :qid |unknown.0:0|
 :skolemid |2875|
 :pattern ( ($IsAlloc |i#0@@52| Tclass.NativeTypes.nat32 $h@@111))
)))
(assert (= (type Tclass.NativeTypes.nat64) TyType))
(assert (= (Tag Tclass.NativeTypes.nat64) Tagclass.NativeTypes.nat64))
(assert (= (TagFamily Tclass.NativeTypes.nat64) tytagFamily$nat64))
(assert (forall ((bx@@138 T@U) ) (!  (=> (and (= (type bx@@138) BoxType) ($IsBox bx@@138 Tclass.NativeTypes.nat64)) (and (= ($Box ($Unbox intType bx@@138)) bx@@138) ($Is ($Unbox intType bx@@138) Tclass.NativeTypes.nat64)))
 :qid |unknown.0:0|
 :skolemid |2876|
 :pattern ( ($IsBox bx@@138 Tclass.NativeTypes.nat64))
)))
(assert (forall ((|i#0@@53| T@U) ) (!  (=> (= (type |i#0@@53|) intType) (= ($Is |i#0@@53| Tclass.NativeTypes.nat64)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@53|)) (INTERNAL_lt_boogie (U_2_int |i#0@@53|) 9223372036854775808))))
 :qid |unknown.0:0|
 :skolemid |2877|
 :pattern ( ($Is |i#0@@53| Tclass.NativeTypes.nat64))
)))
(assert (forall ((|i#0@@54| T@U) ($h@@112 T@U) ) (!  (=> (and (= (type |i#0@@54|) intType) (= (type $h@@112) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@54| Tclass.NativeTypes.nat64 $h@@112))
 :qid |unknown.0:0|
 :skolemid |2878|
 :pattern ( ($IsAlloc |i#0@@54| Tclass.NativeTypes.nat64 $h@@112))
)))
(assert (= (type Tclass.NativeTypes.uint128) TyType))
(assert (= (Tag Tclass.NativeTypes.uint128) Tagclass.NativeTypes.uint128))
(assert (= (TagFamily Tclass.NativeTypes.uint128) tytagFamily$uint128))
(assert (forall ((bx@@139 T@U) ) (!  (=> (and (= (type bx@@139) BoxType) ($IsBox bx@@139 Tclass.NativeTypes.uint128)) (and (= ($Box ($Unbox intType bx@@139)) bx@@139) ($Is ($Unbox intType bx@@139) Tclass.NativeTypes.uint128)))
 :qid |unknown.0:0|
 :skolemid |2879|
 :pattern ( ($IsBox bx@@139 Tclass.NativeTypes.uint128))
)))
(assert (forall ((|i#0@@55| T@U) ) (!  (=> (= (type |i#0@@55|) intType) (= ($Is |i#0@@55| Tclass.NativeTypes.uint128)  (and (INTERNAL_le_boogie 0 (U_2_int |i#0@@55|)) (INTERNAL_lt_boogie (U_2_int |i#0@@55|) 340282366920938463463374607431768211456))))
 :qid |unknown.0:0|
 :skolemid |2880|
 :pattern ( ($Is |i#0@@55| Tclass.NativeTypes.uint128))
)))
(assert (forall ((|i#0@@56| T@U) ($h@@113 T@U) ) (!  (=> (and (= (type |i#0@@56|) intType) (= (type $h@@113) (MapType0Type refType MapType1Type))) ($IsAlloc |i#0@@56| Tclass.NativeTypes.uint128 $h@@113))
 :qid |unknown.0:0|
 :skolemid |2881|
 :pattern ( ($IsAlloc |i#0@@56| Tclass.NativeTypes.uint128 $h@@113))
)))
(assert (= (type Tclass.NativeTypes.__default) TyType))
(assert (= (Tag Tclass.NativeTypes.__default) Tagclass.NativeTypes.__default))
(assert (= (TagFamily Tclass.NativeTypes.__default) tytagFamily$_default))
(assert (forall ((bx@@140 T@U) ) (!  (=> (and (= (type bx@@140) BoxType) ($IsBox bx@@140 Tclass.NativeTypes.__default)) (and (= ($Box ($Unbox refType bx@@140)) bx@@140) ($Is ($Unbox refType bx@@140) Tclass.NativeTypes.__default)))
 :qid |unknown.0:0|
 :skolemid |2882|
 :pattern ( ($IsBox bx@@140 Tclass.NativeTypes.__default))
)))
(assert (forall (($o@@15 T@U) ) (!  (=> (= (type $o@@15) refType) (= ($Is $o@@15 Tclass.NativeTypes.__default)  (or (= $o@@15 null) (= (dtype $o@@15) Tclass.NativeTypes.__default))))
 :qid |unknown.0:0|
 :skolemid |2883|
 :pattern ( ($Is $o@@15 Tclass.NativeTypes.__default))
)))
(assert (forall (($o@@16 T@U) ($h@@114 T@U) ) (!  (=> (and (= (type $o@@16) refType) (= (type $h@@114) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@114)  (or (= $o@@16 null) (U_2_bool (MapType1Select (MapType0Select $h@@114 $o@@16) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2884|
 :pattern ( ($IsAlloc $o@@16 Tclass.NativeTypes.__default $h@@114))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint64Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint64Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint64Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64Size (LitInt 8)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint32Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint32Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint32Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32Size (LitInt 4)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint16Size) (INTERNAL_lt_boogie NativeTypes.__default.Uint16Size 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint16Size#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint16Size (LitInt 2)))))
(assert  (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint64UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint64UpperBound (LitInt 18446744073709551616)))))
(assert  (=> true (=> true true)))
(assert (= |NativeTypes.__default.Uint32UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint32UpperBound (LitInt 4294967296)))))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 NativeTypes.__default.Uint8UpperBound) (INTERNAL_lt_boogie NativeTypes.__default.Uint8UpperBound 18446744073709551616)))))
(assert (= |NativeTypes.__default.Uint8UpperBound#requires| true))
(assert  (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert  (=> true (=> true (= NativeTypes.__default.Uint8UpperBound (LitInt 256)))))
(assert (forall ((|s#0| T@U) ) (!  (=> (= (type |s#0|) (SeqType BoxType)) (= ($Is |s#0| Tclass.KeyType.Key)  (and ($Is |s#0| (TSeq Tclass.NativeTypes.byte)) (INTERNAL_le_boogie (|Seq#Length| |s#0|) 1024))))
 :qid |unknown.0:0|
 :skolemid |2885|
 :pattern ( ($Is |s#0| Tclass.KeyType.Key))
)))
(assert (forall ((|s#0@@0| T@U) ($h@@115 T@U) ) (!  (=> (and (= (type |s#0@@0|) (SeqType BoxType)) (= (type $h@@115) (MapType0Type refType MapType1Type))) (= ($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@115) ($IsAlloc |s#0@@0| (TSeq Tclass.NativeTypes.byte) $h@@115)))
 :qid |unknown.0:0|
 :skolemid |2886|
 :pattern ( ($IsAlloc |s#0@@0| Tclass.KeyType.Key $h@@115))
)))
(assert (= (type Tclass.KeyType.__default) TyType))
(assert (= (Tag Tclass.KeyType.__default) Tagclass.KeyType.__default))
(assert (= (TagFamily Tclass.KeyType.__default) tytagFamily$_default))
(assert (forall ((bx@@141 T@U) ) (!  (=> (and (= (type bx@@141) BoxType) ($IsBox bx@@141 Tclass.KeyType.__default)) (and (= ($Box ($Unbox refType bx@@141)) bx@@141) ($Is ($Unbox refType bx@@141) Tclass.KeyType.__default)))
 :qid |unknown.0:0|
 :skolemid |2887|
 :pattern ( ($IsBox bx@@141 Tclass.KeyType.__default))
)))
(assert (forall (($o@@17 T@U) ) (!  (=> (= (type $o@@17) refType) (= ($Is $o@@17 Tclass.KeyType.__default)  (or (= $o@@17 null) (= (dtype $o@@17) Tclass.KeyType.__default))))
 :qid |unknown.0:0|
 :skolemid |2888|
 :pattern ( ($Is $o@@17 Tclass.KeyType.__default))
)))
(assert (forall (($o@@18 T@U) ($h@@116 T@U) ) (!  (=> (and (= (type $o@@18) refType) (= (type $h@@116) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@18 Tclass.KeyType.__default $h@@116)  (or (= $o@@18 null) (U_2_bool (MapType1Select (MapType0Select $h@@116 $o@@18) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2889|
 :pattern ( ($IsAlloc $o@@18 Tclass.KeyType.__default $h@@116))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 KeyType.__default.MaxLen) (INTERNAL_lt_boogie KeyType.__default.MaxLen 18446744073709551616)))))
(assert (= |KeyType.__default.MaxLen#requires| true))
(assert  (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert  (=> true (=> true (= KeyType.__default.MaxLen (LitInt 1024)))))
(assert (forall ((|s#0@@1| T@U) ) (!  (=> (= (type |s#0@@1|) (SeqType BoxType)) (= ($Is |s#0@@1| Tclass.ValueType.Value)  (and ($Is |s#0@@1| (TSeq Tclass.NativeTypes.byte)) (INTERNAL_le_boogie (|Seq#Length| |s#0@@1|) 1024))))
 :qid |unknown.0:0|
 :skolemid |2890|
 :pattern ( ($Is |s#0@@1| Tclass.ValueType.Value))
)))
(assert (forall ((|s#0@@2| T@U) ($h@@117 T@U) ) (!  (=> (and (= (type |s#0@@2|) (SeqType BoxType)) (= (type $h@@117) (MapType0Type refType MapType1Type))) (= ($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@117) ($IsAlloc |s#0@@2| (TSeq Tclass.NativeTypes.byte) $h@@117)))
 :qid |unknown.0:0|
 :skolemid |2891|
 :pattern ( ($IsAlloc |s#0@@2| Tclass.ValueType.Value $h@@117))
)))
(assert (= (type Tclass.ValueType.__default) TyType))
(assert (= (Tag Tclass.ValueType.__default) Tagclass.ValueType.__default))
(assert (= (TagFamily Tclass.ValueType.__default) tytagFamily$_default))
(assert (forall (($o@@19 T@U) ) (!  (=> (= (type $o@@19) refType) (= ($Is $o@@19 Tclass.ValueType.__default)  (or (= $o@@19 null) (= (dtype $o@@19) Tclass.ValueType.__default))))
 :qid |unknown.0:0|
 :skolemid |2892|
 :pattern ( ($Is $o@@19 Tclass.ValueType.__default))
)))
(assert (forall (($o@@20 T@U) ($h@@118 T@U) ) (!  (=> (and (= (type $o@@20) refType) (= (type $h@@118) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@20 Tclass.ValueType.__default $h@@118)  (or (= $o@@20 null) (U_2_bool (MapType1Select (MapType0Select $h@@118 $o@@20) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2893|
 :pattern ( ($IsAlloc $o@@20 Tclass.ValueType.__default $h@@118))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 ValueType.__default.MaxLen) (INTERNAL_lt_boogie ValueType.__default.MaxLen 18446744073709551616)))))
(assert (= |ValueType.__default.MaxLen#requires| true))
(assert  (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert  (=> true (=> true (= ValueType.__default.MaxLen (LitInt 1024)))))
(assert (= (type ValueType.__default.DefaultValue) (SeqType BoxType)))
(assert  (=> true (=> true ($Is ValueType.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueType.__default.DefaultValue#requires| true))
(assert  (=> true (=> true (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (=> true (= ValueType.__default.DefaultValue (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (forall ((|v#0@@53| T@U) ) (!  (=> (and (= (type |v#0@@53|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| |v#0@@53|) ($Is |v#0@@53| Tclass.ValueType.Value))) (INTERNAL_le_boogie 0 (ValueType.__default.Len |v#0@@53|)))
 :qid |KeyTypesdfy.20:15|
 :skolemid |2894|
 :pattern ( (ValueType.__default.Len |v#0@@53|))
))))
(assert (forall ((|v#0@@54| T@U) ) (!  (=> (and (= (type |v#0@@54|) (SeqType BoxType)) ($Is |v#0@@54| Tclass.ValueType.Value)) (= (|ValueType.__default.Len#requires| |v#0@@54|) true))
 :qid |KeyTypesdfy.20:15|
 :skolemid |2895|
 :pattern ( (|ValueType.__default.Len#requires| |v#0@@54|))
)))
(assert  (=> true (forall ((|v#0@@55| T@U) ) (!  (=> (and (= (type |v#0@@55|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| |v#0@@55|) ($Is |v#0@@55| Tclass.ValueType.Value))) (= (ValueType.__default.Len |v#0@@55|) (|Seq#Length| |v#0@@55|)))
 :qid |KeyTypesdfy.20:15|
 :skolemid |2896|
 :pattern ( (ValueType.__default.Len |v#0@@55|))
))))
(assert  (=> true (forall ((|v#0@@56| T@U) ) (!  (=> (and (= (type |v#0@@56|) (SeqType BoxType)) (or (|ValueType.__default.Len#canCall| (Lit |v#0@@56|)) ($Is |v#0@@56| Tclass.ValueType.Value))) (= (ValueType.__default.Len (Lit |v#0@@56|)) (|Seq#Length| (Lit |v#0@@56|))))
 :qid |KeyTypesdfy.20:15|
 :weight 3
 :skolemid |2897|
 :pattern ( (ValueType.__default.Len (Lit |v#0@@56|)))
))))
(assert  (=> true (forall ((|s#0@@3| T@U) ) (!  (=> (and (= (type |s#0@@3|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| |s#0@@3|) ($Is |s#0@@3| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |KeyTypesdfy.22:36|
 :skolemid |2898|
 :pattern ( (ValueType.__default.ValidMessageBytestring |s#0@@3|))
))))
(assert (forall ((|s#0@@4| T@U) ) (!  (=> (and (= (type |s#0@@4|) (SeqType BoxType)) ($Is |s#0@@4| (TSeq Tclass.NativeTypes.byte))) (= (|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|) true))
 :qid |KeyTypesdfy.22:36|
 :skolemid |2899|
 :pattern ( (|ValueType.__default.ValidMessageBytestring#requires| |s#0@@4|))
)))
(assert  (=> true (forall ((|s#0@@5| T@U) ) (!  (=> (and (= (type |s#0@@5|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| |s#0@@5|) ($Is |s#0@@5| (TSeq Tclass.NativeTypes.byte)))) (and |ValueType.__default.MaxLen#canCall| (= (ValueType.__default.ValidMessageBytestring |s#0@@5|) (INTERNAL_le_boogie (|Seq#Length| |s#0@@5|) ValueType.__default.MaxLen))))
 :qid |KeyTypesdfy.22:36|
 :skolemid |2900|
 :pattern ( (ValueType.__default.ValidMessageBytestring |s#0@@5|))
))))
(assert  (=> true (forall ((|s#0@@6| T@U) ) (!  (=> (and (= (type |s#0@@6|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestring#canCall| (Lit |s#0@@6|)) ($Is |s#0@@6| (TSeq Tclass.NativeTypes.byte)))) (and |ValueType.__default.MaxLen#canCall| (= (ValueType.__default.ValidMessageBytestring (Lit |s#0@@6|)) (INTERNAL_le_boogie (|Seq#Length| (Lit |s#0@@6|)) ValueType.__default.MaxLen))))
 :qid |KeyTypesdfy.22:36|
 :weight 3
 :skolemid |2901|
 :pattern ( (ValueType.__default.ValidMessageBytestring (Lit |s#0@@6|)))
))))
(assert  (=> true (forall ((|strs#0| T@U) ) (!  (=> (and (= (type |strs#0|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| |strs#0|) ($Is |strs#0| (TSeq (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |KeyTypesdfy.27:37|
 :skolemid |2902|
 :pattern ( (ValueType.__default.ValidMessageBytestrings |strs#0|))
))))
(assert (forall ((|strs#0@@0| T@U) ) (!  (=> (and (= (type |strs#0@@0|) (SeqType BoxType)) ($Is |strs#0@@0| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|ValueType.__default.ValidMessageBytestrings#requires| |strs#0@@0|) true))
 :qid |KeyTypesdfy.27:37|
 :skolemid |2903|
 :pattern ( (|ValueType.__default.ValidMessageBytestrings#requires| |strs#0@@0|))
)))
(assert  (=> true (forall ((|strs#0@@1| T@U) ) (!  (=> (and (= (type |strs#0@@1|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| |strs#0@@1|) ($Is |strs#0@@1| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@57| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@57|) (INTERNAL_lt_boogie |i#0@@57| (|Seq#Length| |strs#0@@1|))) (|ValueType.__default.ValidMessageBytestring#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@57|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |2905|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@57|)))
)) (= (ValueType.__default.ValidMessageBytestrings |strs#0@@1|) (forall ((|i#0@@58| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@58|) (INTERNAL_lt_boogie |i#0@@58| (|Seq#Length| |strs#0@@1|))) (ValueType.__default.ValidMessageBytestring ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@58|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |2904|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@1| |i#0@@58|)))
)))))
 :qid |KeyTypesdfy.27:37|
 :skolemid |2906|
 :pattern ( (ValueType.__default.ValidMessageBytestrings |strs#0@@1|))
))))
(assert  (=> true (forall ((|strs#0@@2| T@U) ) (!  (=> (and (= (type |strs#0@@2|) (SeqType BoxType)) (or (|ValueType.__default.ValidMessageBytestrings#canCall| (Lit |strs#0@@2|)) ($Is |strs#0@@2| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1@@13| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@13|) (INTERNAL_lt_boogie |i#1@@13| (|Seq#Length| (Lit |strs#0@@2|)))) (|ValueType.__default.ValidMessageBytestring#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |strs#0@@2|) |i#1@@13|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |2908|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@2| |i#1@@13|)))
)) (= (ValueType.__default.ValidMessageBytestrings (Lit |strs#0@@2|)) (forall ((|i#1@@14| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@14|) (INTERNAL_lt_boogie |i#1@@14| (|Seq#Length| (Lit |strs#0@@2|)))) (ValueType.__default.ValidMessageBytestring ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |strs#0@@2|) |i#1@@14|))))
 :qid |KeyTypesdfy.29:12|
 :skolemid |2907|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |strs#0@@2| |i#1@@14|)))
)))))
 :qid |KeyTypesdfy.27:37|
 :weight 3
 :skolemid |2909|
 :pattern ( (ValueType.__default.ValidMessageBytestrings (Lit |strs#0@@2|)))
))))
(assert (= (type Tclass.LinearMaybe.__default) TyType))
(assert (= (Tag Tclass.LinearMaybe.__default) Tagclass.LinearMaybe.__default))
(assert (= (TagFamily Tclass.LinearMaybe.__default) tytagFamily$_default))
(assert (forall ((bx@@142 T@U) ) (!  (=> (and (= (type bx@@142) BoxType) ($IsBox bx@@142 Tclass.LinearMaybe.__default)) (and (= ($Box ($Unbox refType bx@@142)) bx@@142) ($Is ($Unbox refType bx@@142) Tclass.LinearMaybe.__default)))
 :qid |unknown.0:0|
 :skolemid |2910|
 :pattern ( ($IsBox bx@@142 Tclass.LinearMaybe.__default))
)))
(assert (forall (($o@@21 T@U) ) (!  (=> (= (type $o@@21) refType) (= ($Is $o@@21 Tclass.LinearMaybe.__default)  (or (= $o@@21 null) (= (dtype $o@@21) Tclass.LinearMaybe.__default))))
 :qid |unknown.0:0|
 :skolemid |2911|
 :pattern ( ($Is $o@@21 Tclass.LinearMaybe.__default))
)))
(assert (forall (($o@@22 T@U) ($h@@119 T@U) ) (!  (=> (and (= (type $o@@22) refType) (= (type $h@@119) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@119)  (or (= $o@@22 null) (U_2_bool (MapType1Select (MapType0Select $h@@119 $o@@22) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2912|
 :pattern ( ($IsAlloc $o@@22 Tclass.LinearMaybe.__default $h@@119))
)))
(assert (forall ((arg0@@456 T@U) ) (! (= (type (|#$maybe| arg0@@456)) TyType)
 :qid |funType:#$maybe|
 :pattern ( (|#$maybe| arg0@@456))
)))
(assert  (=> true (forall ((LinearMaybe._default.has$A T@U) (|m#0| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.has$A) TyType) (= (type |m#0|) BoxType)) (or (|LinearMaybe.__default.has#canCall| LinearMaybe._default.has$A |m#0|) ($IsBox |m#0| (|#$maybe| LinearMaybe._default.has$A)))) true)
 :qid |unknown.0:0|
 :skolemid |2913|
 :pattern ( (LinearMaybe.__default.has LinearMaybe._default.has$A |m#0|))
))))
(assert (forall ((LinearMaybe._default.has$A@@0 T@U) (|m#0@@0| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.has$A@@0) TyType) (= (type |m#0@@0|) BoxType)) ($IsBox |m#0@@0| (|#$maybe| LinearMaybe._default.has$A@@0))) (= (|LinearMaybe.__default.has#requires| LinearMaybe._default.has$A@@0 |m#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |2914|
 :pattern ( (|LinearMaybe.__default.has#requires| LinearMaybe._default.has$A@@0 |m#0@@0|))
)))
(assert (forall ((arg0@@457 T@U) (arg1@@184 T@U) ) (! (= (type (LinearMaybe.__default.read arg0@@457 arg1@@184)) BoxType)
 :qid |funType:LinearMaybe.__default.read|
 :pattern ( (LinearMaybe.__default.read arg0@@457 arg1@@184))
)))
(assert  (=> true (forall ((LinearMaybe._default.read$A T@U) (|m#0@@1| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.read$A) TyType) (= (type |m#0@@1|) BoxType)) (or (|LinearMaybe.__default.read#canCall| LinearMaybe._default.read$A |m#0@@1|) ($IsBox |m#0@@1| (|#$maybe| LinearMaybe._default.read$A)))) ($IsBox (LinearMaybe.__default.read LinearMaybe._default.read$A |m#0@@1|) LinearMaybe._default.read$A))
 :qid |unknown.0:0|
 :skolemid |2915|
 :pattern ( (LinearMaybe.__default.read LinearMaybe._default.read$A |m#0@@1|))
))))
(assert (forall ((LinearMaybe._default.read$A@@0 T@U) (|m#0@@2| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.read$A@@0) TyType) (= (type |m#0@@2|) BoxType)) ($IsBox |m#0@@2| (|#$maybe| LinearMaybe._default.read$A@@0))) (= (|LinearMaybe.__default.read#requires| LinearMaybe._default.read$A@@0 |m#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |2916|
 :pattern ( (|LinearMaybe.__default.read#requires| LinearMaybe._default.read$A@@0 |m#0@@2|))
)))
(assert (forall ((arg0@@458 T@U) (arg1@@185 T@U) ) (! (= (type (LinearMaybe.__default.peek arg0@@458 arg1@@185)) BoxType)
 :qid |funType:LinearMaybe.__default.peek|
 :pattern ( (LinearMaybe.__default.peek arg0@@458 arg1@@185))
)))
(assert  (=> true (forall ((LinearMaybe._default.peek$A T@U) (|m#0@@3| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.peek$A) TyType) (= (type |m#0@@3|) BoxType)) (or (|LinearMaybe.__default.peek#canCall| LinearMaybe._default.peek$A |m#0@@3|) (and ($IsBox |m#0@@3| (|#$maybe| LinearMaybe._default.peek$A)) (LinearMaybe.__default.has LinearMaybe._default.peek$A |m#0@@3|)))) (and (= (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|) (LinearMaybe.__default.read LinearMaybe._default.peek$A |m#0@@3|)) ($IsBox (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|) LinearMaybe._default.peek$A)))
 :qid |unknown.0:0|
 :skolemid |2917|
 :pattern ( (LinearMaybe.__default.peek LinearMaybe._default.peek$A |m#0@@3|))
))))
(assert (forall ((LinearMaybe._default.peek$A@@0 T@U) (|m#0@@4| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.peek$A@@0) TyType) (= (type |m#0@@4|) BoxType)) ($IsBox |m#0@@4| (|#$maybe| LinearMaybe._default.peek$A@@0))) (= (|LinearMaybe.__default.peek#requires| LinearMaybe._default.peek$A@@0 |m#0@@4|) (LinearMaybe.__default.has LinearMaybe._default.peek$A@@0 |m#0@@4|)))
 :qid |unknown.0:0|
 :skolemid |2918|
 :pattern ( (|LinearMaybe.__default.peek#requires| LinearMaybe._default.peek$A@@0 |m#0@@4|))
)))
(assert (forall ((arg0@@459 T@U) (arg1@@186 T@U) ) (! (= (type (LinearMaybe.__default.unwrap arg0@@459 arg1@@186)) BoxType)
 :qid |funType:LinearMaybe.__default.unwrap|
 :pattern ( (LinearMaybe.__default.unwrap arg0@@459 arg1@@186))
)))
(assert  (=> true (forall ((LinearMaybe._default.unwrap$A T@U) (|m#0@@5| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.unwrap$A) TyType) (= (type |m#0@@5|) BoxType)) (or (|LinearMaybe.__default.unwrap#canCall| LinearMaybe._default.unwrap$A |m#0@@5|) (and ($IsBox |m#0@@5| (|#$maybe| LinearMaybe._default.unwrap$A)) (LinearMaybe.__default.has LinearMaybe._default.unwrap$A |m#0@@5|)))) (and (= (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|) (LinearMaybe.__default.read LinearMaybe._default.unwrap$A |m#0@@5|)) ($IsBox (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|) LinearMaybe._default.unwrap$A)))
 :qid |unknown.0:0|
 :skolemid |2919|
 :pattern ( (LinearMaybe.__default.unwrap LinearMaybe._default.unwrap$A |m#0@@5|))
))))
(assert (forall ((LinearMaybe._default.unwrap$A@@0 T@U) (|m#0@@6| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.unwrap$A@@0) TyType) (= (type |m#0@@6|) BoxType)) ($IsBox |m#0@@6| (|#$maybe| LinearMaybe._default.unwrap$A@@0))) (= (|LinearMaybe.__default.unwrap#requires| LinearMaybe._default.unwrap$A@@0 |m#0@@6|) (LinearMaybe.__default.has LinearMaybe._default.unwrap$A@@0 |m#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |2920|
 :pattern ( (|LinearMaybe.__default.unwrap#requires| LinearMaybe._default.unwrap$A@@0 |m#0@@6|))
)))
(assert (forall ((arg0@@460 T@U) (arg1@@187 T@U) (arg2@@90 T@U) ) (! (= (type (LinearMaybe.__default.give arg0@@460 arg1@@187 arg2@@90)) BoxType)
 :qid |funType:LinearMaybe.__default.give|
 :pattern ( (LinearMaybe.__default.give arg0@@460 arg1@@187 arg2@@90))
)))
(assert (forall ((LinearMaybe._default.give$A T@U) ($ly@@37 T@U) (|a#0@@1| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.give$A) TyType) (= (type $ly@@37) LayerTypeType)) (= (type |a#0@@1|) BoxType)) (= (LinearMaybe.__default.give LinearMaybe._default.give$A ($LS $ly@@37) |a#0@@1|) (LinearMaybe.__default.give LinearMaybe._default.give$A $ly@@37 |a#0@@1|)))
 :qid |unknown.0:0|
 :skolemid |2921|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A ($LS $ly@@37) |a#0@@1|))
)))
(assert (forall ((LinearMaybe._default.give$A@@0 T@U) ($ly@@38 T@U) (|a#0@@2| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.give$A@@0) TyType) (= (type $ly@@38) LayerTypeType)) (= (type |a#0@@2|) BoxType)) (= (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 $ly@@38 |a#0@@2|) (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 $LZ |a#0@@2|)))
 :qid |unknown.0:0|
 :skolemid |2922|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@0 (AsFuelBottom $ly@@38) |a#0@@2|))
)))
(assert  (=> true (forall ((LinearMaybe._default.give$A@@1 T@U) ($ly@@39 T@U) (|a#0@@3| T@U) ) (!  (=> (and (and (and (= (type LinearMaybe._default.give$A@@1) TyType) (= (type $ly@@39) LayerTypeType)) (= (type |a#0@@3|) BoxType)) (or (|LinearMaybe.__default.give#canCall| LinearMaybe._default.give$A@@1 |a#0@@3|) ($IsBox |a#0@@3| LinearMaybe._default.give$A@@1))) (and (and (and (LinearMaybe.__default.has LinearMaybe._default.give$A@@1 (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 |a#0@@3|)) (= (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 |a#0@@3|)) |a#0@@3|)) (forall ((|x#0@@1| T@U) ) (!  (=> (= (type |x#0@@1|) BoxType) (=> (and ($IsBox |x#0@@1| (|#$maybe| LinearMaybe._default.give$A@@1)) (and (LinearMaybe.__default.has LinearMaybe._default.give$A@@1 |x#0@@1|) (= |a#0@@3| (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 |x#0@@1|)))) (= (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 |a#0@@3|) |x#0@@1|)))
 :qid |LinearMaybesdfy.25:20|
 :skolemid |2923|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 (LinearMaybe.__default.read LinearMaybe._default.give$A@@1 |x#0@@1|)))
))) ($IsBox (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 |a#0@@3|) (|#$maybe| LinearMaybe._default.give$A@@1))))
 :qid |unknown.0:0|
 :skolemid |2924|
 :pattern ( (LinearMaybe.__default.give LinearMaybe._default.give$A@@1 $ly@@39 |a#0@@3|))
))))
(assert (forall ((LinearMaybe._default.give$A@@2 T@U) ($ly@@40 T@U) (|a#0@@4| T@U) ) (!  (=> (and (and (and (= (type LinearMaybe._default.give$A@@2) TyType) (= (type $ly@@40) LayerTypeType)) (= (type |a#0@@4|) BoxType)) ($IsBox |a#0@@4| LinearMaybe._default.give$A@@2)) (= (|LinearMaybe.__default.give#requires| LinearMaybe._default.give$A@@2 $ly@@40 |a#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |2925|
 :pattern ( (|LinearMaybe.__default.give#requires| LinearMaybe._default.give$A@@2 $ly@@40 |a#0@@4|))
)))
(assert (forall ((arg0@@461 T@U) ) (! (= (type (LinearMaybe.__default.empty arg0@@461)) BoxType)
 :qid |funType:LinearMaybe.__default.empty|
 :pattern ( (LinearMaybe.__default.empty arg0@@461))
)))
(assert  (=> true (forall ((LinearMaybe._default.empty$A T@U) ) (!  (=> (and (= (type LinearMaybe._default.empty$A) TyType) true) (and (not (LinearMaybe.__default.has LinearMaybe._default.empty$A (LinearMaybe.__default.empty LinearMaybe._default.empty$A))) ($IsBox (LinearMaybe.__default.empty LinearMaybe._default.empty$A) (|#$maybe| LinearMaybe._default.empty$A))))
 :qid |unknown.0:0|
 :skolemid |2926|
 :pattern ( (LinearMaybe.__default.empty LinearMaybe._default.empty$A))
))))
(assert (forall ((LinearMaybe._default.empty$A@@0 T@U) ) (!  (=> (= (type LinearMaybe._default.empty$A@@0) TyType) (= (|LinearMaybe.__default.empty#requires| LinearMaybe._default.empty$A@@0) true))
 :qid |unknown.0:0|
 :skolemid |2927|
 :pattern ( (|LinearMaybe.__default.empty#requires| LinearMaybe._default.empty$A@@0))
)))
(assert (forall ((arg0@@462 T@U) (arg1@@188 T@U) ) (! (= (type (LinearMaybe.__default.discard arg0@@462 arg1@@188)) DatatypeTypeType)
 :qid |funType:LinearMaybe.__default.discard|
 :pattern ( (LinearMaybe.__default.discard arg0@@462 arg1@@188))
)))
(assert  (=> true (forall ((LinearMaybe._default.discard$A T@U) (|m#0@@7| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.discard$A) TyType) (= (type |m#0@@7|) BoxType)) (or (|LinearMaybe.__default.discard#canCall| LinearMaybe._default.discard$A |m#0@@7|) (and ($IsBox |m#0@@7| (|#$maybe| LinearMaybe._default.discard$A)) (not (LinearMaybe.__default.has LinearMaybe._default.discard$A |m#0@@7|))))) ($Is (LinearMaybe.__default.discard LinearMaybe._default.discard$A |m#0@@7|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |2928|
 :pattern ( (LinearMaybe.__default.discard LinearMaybe._default.discard$A |m#0@@7|))
))))
(assert (forall ((LinearMaybe._default.discard$A@@0 T@U) (|m#0@@8| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.discard$A@@0) TyType) (= (type |m#0@@8|) BoxType)) ($IsBox |m#0@@8| (|#$maybe| LinearMaybe._default.discard$A@@0))) (= (|LinearMaybe.__default.discard#requires| LinearMaybe._default.discard$A@@0 |m#0@@8|)  (not (LinearMaybe.__default.has LinearMaybe._default.discard$A@@0 |m#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |2929|
 :pattern ( (|LinearMaybe.__default.discard#requires| LinearMaybe._default.discard$A@@0 |m#0@@8|))
)))
(assert (forall ((arg0@@463 T@U) (arg1@@189 Bool) (arg2@@91 T@U) ) (! (= (type (LinearMaybe.__default.imagine arg0@@463 arg1@@189 arg2@@91)) BoxType)
 :qid |funType:LinearMaybe.__default.imagine|
 :pattern ( (LinearMaybe.__default.imagine arg0@@463 arg1@@189 arg2@@91))
)))
(assert  (=> true (forall ((LinearMaybe._default.imagine$A T@U) (|h#0| Bool) (|a#0@@5| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.imagine$A) TyType) (= (type |a#0@@5|) BoxType)) (or (|LinearMaybe.__default.imagine#canCall| LinearMaybe._default.imagine$A |h#0| |a#0@@5|) ($IsBox |a#0@@5| LinearMaybe._default.imagine$A))) (and (and (= (LinearMaybe.__default.has LinearMaybe._default.imagine$A (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|)) |h#0|) (= (LinearMaybe.__default.read LinearMaybe._default.imagine$A (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|)) |a#0@@5|)) ($IsBox (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|) (|#$maybe| LinearMaybe._default.imagine$A))))
 :qid |unknown.0:0|
 :skolemid |2930|
 :pattern ( (LinearMaybe.__default.imagine LinearMaybe._default.imagine$A |h#0| |a#0@@5|))
))))
(assert (forall ((LinearMaybe._default.imagine$A@@0 T@U) (|h#0@@0| Bool) (|a#0@@6| T@U) ) (!  (=> (and (and (= (type LinearMaybe._default.imagine$A@@0) TyType) (= (type |a#0@@6|) BoxType)) ($IsBox |a#0@@6| LinearMaybe._default.imagine$A@@0)) (= (|LinearMaybe.__default.imagine#requires| LinearMaybe._default.imagine$A@@0 |h#0@@0| |a#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |2931|
 :pattern ( (|LinearMaybe.__default.imagine#requires| LinearMaybe._default.imagine$A@@0 |h#0@@0| |a#0@@6|))
)))
(assert (= (type Tclass.LinearExtern.__default) TyType))
(assert (= (Tag Tclass.LinearExtern.__default) Tagclass.LinearExtern.__default))
(assert (= (TagFamily Tclass.LinearExtern.__default) tytagFamily$_default))
(assert (forall ((bx@@143 T@U) ) (!  (=> (and (= (type bx@@143) BoxType) ($IsBox bx@@143 Tclass.LinearExtern.__default)) (and (= ($Box ($Unbox refType bx@@143)) bx@@143) ($Is ($Unbox refType bx@@143) Tclass.LinearExtern.__default)))
 :qid |unknown.0:0|
 :skolemid |2932|
 :pattern ( ($IsBox bx@@143 Tclass.LinearExtern.__default))
)))
(assert (forall (($o@@23 T@U) ) (!  (=> (= (type $o@@23) refType) (= ($Is $o@@23 Tclass.LinearExtern.__default)  (or (= $o@@23 null) (= (dtype $o@@23) Tclass.LinearExtern.__default))))
 :qid |unknown.0:0|
 :skolemid |2933|
 :pattern ( ($Is $o@@23 Tclass.LinearExtern.__default))
)))
(assert (forall (($o@@24 T@U) ($h@@120 T@U) ) (!  (=> (and (= (type $o@@24) refType) (= (type $h@@120) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@120)  (or (= $o@@24 null) (U_2_bool (MapType1Select (MapType0Select $h@@120 $o@@24) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2934|
 :pattern ( ($IsAlloc $o@@24 Tclass.LinearExtern.__default $h@@120))
)))
(assert (forall ((arg0@@464 T@U) (arg1@@190 T@U) (arg2@@92 Int) ) (! (= (type (LinearExtern.__default.seq_get arg0@@464 arg1@@190 arg2@@92)) BoxType)
 :qid |funType:LinearExtern.__default.seq_get|
 :pattern ( (LinearExtern.__default.seq_get arg0@@464 arg1@@190 arg2@@92))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_get$A T@U) (|s#0@@7| T@U) (|i#0@@59| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_get$A) TyType) (= (type |s#0@@7|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_get#canCall| LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@59|) (and (and ($Is |s#0@@7| (TSeq LinearSequence_s._default.seq_get$A)) (and (INTERNAL_le_boogie 0 |i#0@@59|) (INTERNAL_lt_boogie |i#0@@59| 18446744073709551616))) (INTERNAL_lt_boogie |i#0@@59| (|Seq#Length| |s#0@@7|))))) (and (= (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@59|) (|Seq#Index| |s#0@@7| |i#0@@59|)) ($IsBox (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@59|) LinearSequence_s._default.seq_get$A)))
 :qid |unknown.0:0|
 :skolemid |2935|
 :pattern ( (LinearExtern.__default.seq_get LinearSequence_s._default.seq_get$A |s#0@@7| |i#0@@59|))
))))
(assert (forall ((LinearSequence_s._default.seq_get$A@@0 T@U) (|s#0@@8| T@U) (|i#0@@60| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_get$A@@0) TyType) (= (type |s#0@@8|) (SeqType BoxType))) (and ($Is |s#0@@8| (TSeq LinearSequence_s._default.seq_get$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@60|) (INTERNAL_lt_boogie |i#0@@60| 18446744073709551616)))) (= (|LinearExtern.__default.seq_get#requires| LinearSequence_s._default.seq_get$A@@0 |s#0@@8| |i#0@@60|) (INTERNAL_lt_boogie |i#0@@60| (|Seq#Length| |s#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |2936|
 :pattern ( (|LinearExtern.__default.seq_get#requires| LinearSequence_s._default.seq_get$A@@0 |s#0@@8| |i#0@@60|))
)))
(assert (forall ((arg0@@465 T@U) (arg1@@191 T@U) (arg2@@93 Int) (arg3@@48 T@U) ) (! (= (type (LinearExtern.__default.seq_set arg0@@465 arg1@@191 arg2@@93 arg3@@48)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_set|
 :pattern ( (LinearExtern.__default.seq_set arg0@@465 arg1@@191 arg2@@93 arg3@@48))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_set$A T@U) (|s1#0| T@U) (|i#0@@61| Int) (|a#0@@7| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.seq_set$A) TyType) (= (type |s1#0|) (SeqType BoxType))) (= (type |a#0@@7|) BoxType)) (or (|LinearExtern.__default.seq_set#canCall| LinearSequence_s._default.seq_set$A |s1#0| |i#0@@61| |a#0@@7|) (and (and (and ($Is |s1#0| (TSeq LinearSequence_s._default.seq_set$A)) (and (INTERNAL_le_boogie 0 |i#0@@61|) (INTERNAL_lt_boogie |i#0@@61| 18446744073709551616))) ($IsBox |a#0@@7| LinearSequence_s._default.seq_set$A)) (INTERNAL_lt_boogie |i#0@@61| (|Seq#Length| |s1#0|))))) (and (|Seq#Equal| (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@61| |a#0@@7|) (|Seq#Update| |s1#0| |i#0@@61| |a#0@@7|)) ($Is (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@61| |a#0@@7|) (TSeq LinearSequence_s._default.seq_set$A))))
 :qid |unknown.0:0|
 :skolemid |2937|
 :pattern ( (LinearExtern.__default.seq_set LinearSequence_s._default.seq_set$A |s1#0| |i#0@@61| |a#0@@7|))
))))
(assert (forall ((LinearSequence_s._default.seq_set$A@@0 T@U) (|s1#0@@0| T@U) (|i#0@@62| Int) (|a#0@@8| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.seq_set$A@@0) TyType) (= (type |s1#0@@0|) (SeqType BoxType))) (= (type |a#0@@8|) BoxType)) (and (and ($Is |s1#0@@0| (TSeq LinearSequence_s._default.seq_set$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@62|) (INTERNAL_lt_boogie |i#0@@62| 18446744073709551616))) ($IsBox |a#0@@8| LinearSequence_s._default.seq_set$A@@0))) (= (|LinearExtern.__default.seq_set#requires| LinearSequence_s._default.seq_set$A@@0 |s1#0@@0| |i#0@@62| |a#0@@8|) (INTERNAL_lt_boogie |i#0@@62| (|Seq#Length| |s1#0@@0|))))
 :qid |unknown.0:0|
 :skolemid |2938|
 :pattern ( (|LinearExtern.__default.seq_set#requires| LinearSequence_s._default.seq_set$A@@0 |s1#0@@0| |i#0@@62| |a#0@@8|))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_length$A T@U) (|s#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_length$A) TyType) (= (type |s#0@@9|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_length#canCall| LinearSequence_s._default.seq_length$A |s#0@@9|) (and ($Is |s#0@@9| (TSeq LinearSequence_s._default.seq_length$A)) (INTERNAL_le_boogie (|Seq#Length| |s#0@@9|) 18446744073709551615)))) (and (= (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|) (|Seq#Length| |s#0@@9|)) (and (INTERNAL_le_boogie 0 (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|)) (INTERNAL_lt_boogie (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |2939|
 :pattern ( (LinearExtern.__default.seq_length LinearSequence_s._default.seq_length$A |s#0@@9|))
))))
(assert (forall ((LinearSequence_s._default.seq_length$A@@0 T@U) (|s#0@@10| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_length$A@@0) TyType) (= (type |s#0@@10|) (SeqType BoxType))) ($Is |s#0@@10| (TSeq LinearSequence_s._default.seq_length$A@@0))) (= (|LinearExtern.__default.seq_length#requires| LinearSequence_s._default.seq_length$A@@0 |s#0@@10|) (INTERNAL_le_boogie (|Seq#Length| |s#0@@10|) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |2940|
 :pattern ( (|LinearExtern.__default.seq_length#requires| LinearSequence_s._default.seq_length$A@@0 |s#0@@10|))
)))
(assert (forall ((arg0@@466 T@U) ) (! (= (type (LinearExtern.__default.seq_empty arg0@@466)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_empty|
 :pattern ( (LinearExtern.__default.seq_empty arg0@@466))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_empty$A T@U) ) (!  (=> (and (= (type LinearSequence_s._default.seq_empty$A) TyType) true) (and (= (|Seq#Length| (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A)) (LitInt 0)) ($Is (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A) (TSeq LinearSequence_s._default.seq_empty$A))))
 :qid |unknown.0:0|
 :skolemid |2941|
 :pattern ( (LinearExtern.__default.seq_empty LinearSequence_s._default.seq_empty$A))
))))
(assert (forall ((LinearSequence_s._default.seq_empty$A@@0 T@U) ) (!  (=> (= (type LinearSequence_s._default.seq_empty$A@@0) TyType) (= (|LinearExtern.__default.seq_empty#requires| LinearSequence_s._default.seq_empty$A@@0) true))
 :qid |unknown.0:0|
 :skolemid |2942|
 :pattern ( (|LinearExtern.__default.seq_empty#requires| LinearSequence_s._default.seq_empty$A@@0))
)))
(assert (forall ((arg0@@467 T@U) (arg1@@192 Int) (arg2@@94 T@U) ) (! (= (type (LinearExtern.__default.seq_alloc arg0@@467 arg1@@192 arg2@@94)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_alloc|
 :pattern ( (LinearExtern.__default.seq_alloc arg0@@467 arg1@@192 arg2@@94))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_alloc$A T@U) (|length#0| Int) (|a#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_alloc$A) TyType) (= (type |a#0@@9|) BoxType)) (or (|LinearExtern.__default.seq_alloc#canCall| LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) (and (and (INTERNAL_le_boogie 0 |length#0|) (INTERNAL_lt_boogie |length#0| 18446744073709551616)) ($IsBox |a#0@@9| LinearSequence_s._default.seq_alloc$A)))) (and (and (= (|Seq#Length| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|)) |length#0|) (forall ((|i#0@@63| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@63|) (INTERNAL_lt_boogie |i#0@@63| (|Seq#Length| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|)))) (= (|Seq#Index| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) |i#0@@63|) |a#0@@9|)))
 :qid |LinearSequencesdfy.32:20|
 :skolemid |2943|
 :pattern ( (|Seq#Index| (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) |i#0@@63|))
))) ($Is (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|) (TSeq LinearSequence_s._default.seq_alloc$A))))
 :qid |unknown.0:0|
 :skolemid |2944|
 :pattern ( (LinearExtern.__default.seq_alloc LinearSequence_s._default.seq_alloc$A |length#0| |a#0@@9|))
))))
(assert (forall ((LinearSequence_s._default.seq_alloc$A@@0 T@U) (|length#0@@0| Int) (|a#0@@10| T@U) ) (!  (=> (and (= (type LinearSequence_s._default.seq_alloc$A@@0) TyType) (= (type |a#0@@10|) BoxType)) (=> (and (and (INTERNAL_le_boogie 0 |length#0@@0|) (INTERNAL_lt_boogie |length#0@@0| 18446744073709551616)) ($IsBox |a#0@@10| LinearSequence_s._default.seq_alloc$A@@0)) (= (|LinearExtern.__default.seq_alloc#requires| LinearSequence_s._default.seq_alloc$A@@0 |length#0@@0| |a#0@@10|) true)))
 :qid |unknown.0:0|
 :skolemid |2945|
 :pattern ( (|LinearExtern.__default.seq_alloc#requires| LinearSequence_s._default.seq_alloc$A@@0 |length#0@@0| |a#0@@10|))
)))
(assert (forall ((arg0@@468 T@U) (arg1@@193 T@U) ) (! (= (type (LinearExtern.__default.seq_free arg0@@468 arg1@@193)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.seq_free|
 :pattern ( (LinearExtern.__default.seq_free arg0@@468 arg1@@193))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_free$A T@U) (|s#0@@11| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_free$A) TyType) (= (type |s#0@@11|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_free#canCall| LinearSequence_s._default.seq_free$A |s#0@@11|) ($Is |s#0@@11| (TSeq LinearSequence_s._default.seq_free$A)))) ($Is (LinearExtern.__default.seq_free LinearSequence_s._default.seq_free$A |s#0@@11|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |2946|
 :pattern ( (LinearExtern.__default.seq_free LinearSequence_s._default.seq_free$A |s#0@@11|))
))))
(assert (forall ((LinearSequence_s._default.seq_free$A@@0 T@U) (|s#0@@12| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_free$A@@0) TyType) (= (type |s#0@@12|) (SeqType BoxType))) ($Is |s#0@@12| (TSeq LinearSequence_s._default.seq_free$A@@0))) (= (|LinearExtern.__default.seq_free#requires| LinearSequence_s._default.seq_free$A@@0 |s#0@@12|) true))
 :qid |unknown.0:0|
 :skolemid |2947|
 :pattern ( (|LinearExtern.__default.seq_free#requires| LinearSequence_s._default.seq_free$A@@0 |s#0@@12|))
)))
(assert (forall ((arg0@@469 T@U) (arg1@@194 T@U) ) (! (= (type (LinearExtern.__default.seq_unleash arg0@@469 arg1@@194)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.seq_unleash|
 :pattern ( (LinearExtern.__default.seq_unleash arg0@@469 arg1@@194))
)))
(assert  (=> true (forall ((LinearSequence_s._default.seq_unleash$A T@U) (|s1#0@@1| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_unleash$A) TyType) (= (type |s1#0@@1|) (SeqType BoxType))) (or (|LinearExtern.__default.seq_unleash#canCall| LinearSequence_s._default.seq_unleash$A |s1#0@@1|) ($Is |s1#0@@1| (TSeq LinearSequence_s._default.seq_unleash$A)))) (and (|Seq#Equal| |s1#0@@1| (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|)) ($Is (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|) (TSeq LinearSequence_s._default.seq_unleash$A))))
 :qid |unknown.0:0|
 :skolemid |2948|
 :pattern ( (LinearExtern.__default.seq_unleash LinearSequence_s._default.seq_unleash$A |s1#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.seq_unleash$A@@0 T@U) (|s1#0@@2| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.seq_unleash$A@@0) TyType) (= (type |s1#0@@2|) (SeqType BoxType))) ($Is |s1#0@@2| (TSeq LinearSequence_s._default.seq_unleash$A@@0))) (= (|LinearExtern.__default.seq_unleash#requires| LinearSequence_s._default.seq_unleash$A@@0 |s1#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |2949|
 :pattern ( (|LinearExtern.__default.seq_unleash#requires| LinearSequence_s._default.seq_unleash$A@@0 |s1#0@@2|))
)))
(assert  (and (forall ((arg0@@470 T@U) (arg1@@195 T@U) ) (! (= (type (LinearExtern.__default.lseqs__raw arg0@@470 arg1@@195)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.lseqs__raw|
 :pattern ( (LinearExtern.__default.lseqs__raw arg0@@470 arg1@@195))
)) (forall ((arg0@@471 T@U) ) (! (= (type (|#$lseq| arg0@@471)) TyType)
 :qid |funType:#$lseq|
 :pattern ( (|#$lseq| arg0@@471))
))))
(assert  (=> true (forall ((LinearSequence_s._default.lseqs_raw$A T@U) (|l#0| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseqs_raw$A) TyType) (= (type |l#0|) BoxType)) (or (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseqs_raw$A |l#0|) ($IsBox |l#0| (|#$lseq| LinearSequence_s._default.lseqs_raw$A)))) (and (_System.__default.rank__is__less__than (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A)) (|#$lseq| LinearSequence_s._default.lseqs_raw$A) ($Box (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|)) |l#0|) ($Is (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|) (TSeq (|#$maybe| LinearSequence_s._default.lseqs_raw$A)))))
 :qid |unknown.0:0|
 :skolemid |2950|
 :pattern ( (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseqs_raw$A |l#0|))
))))
(assert (forall ((LinearSequence_s._default.lseqs_raw$A@@0 T@U) (|l#0@@0| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseqs_raw$A@@0) TyType) (= (type |l#0@@0|) BoxType)) ($IsBox |l#0@@0| (|#$lseq| LinearSequence_s._default.lseqs_raw$A@@0))) (= (|LinearExtern.__default.lseqs__raw#requires| LinearSequence_s._default.lseqs_raw$A@@0 |l#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |2951|
 :pattern ( (|LinearExtern.__default.lseqs__raw#requires| LinearSequence_s._default.lseqs_raw$A@@0 |l#0@@0|))
)))
(assert (forall ((arg0@@472 T@U) (arg1@@196 T@U) ) (! (= (type (LinearExtern.__default.lseq__has arg0@@472 arg1@@196)) (SeqType BoxType))
 :qid |funType:LinearExtern.__default.lseq__has|
 :pattern ( (LinearExtern.__default.lseq__has arg0@@472 arg1@@196))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A T@U) (|l#0@@1| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_has$A) TyType) (= (type |l#0@@1|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A |l#0@@1|) ($IsBox |l#0@@1| (|#$lseq| LinearSequence_s._default.lseq_has$A)))) (and (= (|Seq#Length| (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|)) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A |l#0@@1|))) ($Is (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|) (TSeq TBool))))
 :qid |unknown.0:0|
 :skolemid |2952|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A |l#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.lseq_has$A@@0 T@U) ($Heap@@12 T@U) (|l#0@@2| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@0) TyType) (= (type $Heap@@12) (MapType0Type refType MapType1Type))) (= (type |l#0@@2|) BoxType)) (and ($IsGoodHeap $Heap@@12) ($IsBox |l#0@@2| (|#$lseq| LinearSequence_s._default.lseq_has$A@@0)))) (= (|LinearExtern.__default.lseq__has#requires| LinearSequence_s._default.lseq_has$A@@0 |l#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |2953|
 :pattern ( (|LinearExtern.__default.lseq__has#requires| LinearSequence_s._default.lseq_has$A@@0 |l#0@@2|) ($IsGoodHeap $Heap@@12))
)))
(assert  (and (and (and (and (forall ((arg0@@473 T@U) ) (! (= (type (|lambda#131| arg0@@473)) (MapType0Type LayerTypeType HandleTypeType))
 :qid |funType:lambda#131|
 :pattern ( (|lambda#131| arg0@@473))
)) (forall ((arg0@@474 T@U) (arg1@@197 T@U) ) (! (= (type (|lambda#127| arg0@@474 arg1@@197)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#127|
 :pattern ( (|lambda#127| arg0@@474 arg1@@197))
))) (forall ((arg0@@475 T@U) (arg1@@198 Int) (arg2@@95 Int) ) (! (= (type (|lambda#128| arg0@@475 arg1@@198 arg2@@95)) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))
 :qid |funType:lambda#128|
 :pattern ( (|lambda#128| arg0@@475 arg1@@198 arg2@@95))
))) (forall ((arg0@@476 T@U) ) (! (= (type (|lambda#130| arg0@@476)) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#130|
 :pattern ( (|lambda#130| arg0@@476))
))) (forall ((arg0@@477 Bool) ) (! (= (type (|lambda#129| arg0@@477)) (MapType0Type refType boolType))
 :qid |funType:lambda#129|
 :pattern ( (|lambda#129| arg0@@477))
))))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A@@1 T@U) ($Heap@@13 T@U) (|l#0@@3| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@1) TyType) (= (type $Heap@@13) (MapType0Type refType MapType1Type))) (= (type |l#0@@3|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (and ($IsGoodHeap $Heap@@13) ($IsBox |l#0@@3| (|#$lseq| LinearSequence_s._default.lseq_has$A@@1))))) (and (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (forall ((|$l#1#i#0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0|) (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (=> (and (INTERNAL_le_boogie 0 |$l#1#i#0|) (INTERNAL_lt_boogie |$l#1#i#0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)))) (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (|LinearMaybe.__default.has#canCall| LinearSequence_s._default.lseq_has$A@@1 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) |$l#1#i#0|)))))
 :qid |unknown.0:0|
 :skolemid |2954|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0|)
))) (= (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) (|Seq#Create| TBool $Heap@@13 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#127| LinearSequence_s._default.lseq_has$A@@1 (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|)) (|lambda#128| TInt 0 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :skolemid |2955|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@1 |l#0@@3|) ($IsGoodHeap $Heap@@13))
))))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_has$A@@2 T@U) ($Heap@@14 T@U) (|l#0@@4| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_has$A@@2) TyType) (= (type $Heap@@14) (MapType0Type refType MapType1Type))) (= (type |l#0@@4|) BoxType)) (or (|LinearExtern.__default.lseq__has#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (and ($IsGoodHeap $Heap@@14) ($IsBox |l#0@@4| (|#$lseq| LinearSequence_s._default.lseq_has$A@@2))))) (and (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (forall ((|$l#3#i#0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0|) (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (=> (and (INTERNAL_le_boogie 0 |$l#3#i#0|) (INTERNAL_lt_boogie |$l#3#i#0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))))) (and (|LinearExtern.__default.lseqs__raw#canCall| LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (|LinearMaybe.__default.has#canCall| LinearSequence_s._default.lseq_has$A@@2 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) |$l#3#i#0|)))))
 :qid |unknown.0:0|
 :skolemid |2956|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0|)
))) (= (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) (|Seq#Create| TBool $Heap@@14 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#127| LinearSequence_s._default.lseq_has$A@@2 (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|))) (|lambda#128| TInt 0 (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |2957|
 :pattern ( (LinearExtern.__default.lseq__has LinearSequence_s._default.lseq_has$A@@2 (Lit |l#0@@4|)) ($IsGoodHeap $Heap@@14))
))))
(assert (forall ((arg0@@478 T@U) (arg1@@199 T@U) ) (! (= (type (LinearExtern.__default.imagine__lseq__raw arg0@@478 arg1@@199)) BoxType)
 :qid |funType:LinearExtern.__default.imagine__lseq__raw|
 :pattern ( (LinearExtern.__default.imagine__lseq__raw arg0@@478 arg1@@199))
)))
(assert  (=> true (forall ((LinearSequence_s._default.imagine_lseq_raw$A T@U) (|s#0@@13| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.imagine_lseq_raw$A) TyType) (= (type |s#0@@13|) (SeqType BoxType))) (or (|LinearExtern.__default.imagine__lseq__raw#canCall| LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|) ($Is |s#0@@13| (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A))))) (and (|Seq#Equal| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.imagine_lseq_raw$A (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|)) |s#0@@13|) ($IsBox (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|) (|#$lseq| LinearSequence_s._default.imagine_lseq_raw$A))))
 :qid |unknown.0:0|
 :skolemid |2958|
 :pattern ( (LinearExtern.__default.imagine__lseq__raw LinearSequence_s._default.imagine_lseq_raw$A |s#0@@13|))
))))
(assert (forall ((LinearSequence_s._default.imagine_lseq_raw$A@@0 T@U) (|s#0@@14| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.imagine_lseq_raw$A@@0) TyType) (= (type |s#0@@14|) (SeqType BoxType))) ($Is |s#0@@14| (TSeq (|#$maybe| LinearSequence_s._default.imagine_lseq_raw$A@@0)))) (= (|LinearExtern.__default.imagine__lseq__raw#requires| LinearSequence_s._default.imagine_lseq_raw$A@@0 |s#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |2959|
 :pattern ( (|LinearExtern.__default.imagine__lseq__raw#requires| LinearSequence_s._default.imagine_lseq_raw$A@@0 |s#0@@14|))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_length_raw$A T@U) (|s#0@@15| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_length_raw$A) TyType) (= (type |s#0@@15|) BoxType)) (or (|LinearExtern.__default.lseq_length_raw#canCall| LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) (and ($IsBox |s#0@@15| (|#$lseq| LinearSequence_s._default.lseq_length_raw$A)) (INTERNAL_le_boogie (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|)) 18446744073709551615)))) (and (= (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|))) (and (INTERNAL_le_boogie 0 (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|)) (INTERNAL_lt_boogie (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |2960|
 :pattern ( (LinearExtern.__default.lseq_length_raw LinearSequence_s._default.lseq_length_raw$A |s#0@@15|))
))))
(assert (forall ((LinearSequence_s._default.lseq_length_raw$A@@0 T@U) (|s#0@@16| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_length_raw$A@@0) TyType) (= (type |s#0@@16|) BoxType)) ($IsBox |s#0@@16| (|#$lseq| LinearSequence_s._default.lseq_length_raw$A@@0))) (= (|LinearExtern.__default.lseq_length_raw#requires| LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|) (INTERNAL_le_boogie (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|)) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |2961|
 :pattern ( (|LinearExtern.__default.lseq_length_raw#requires| LinearSequence_s._default.lseq_length_raw$A@@0 |s#0@@16|))
)))
(assert (forall ((arg0@@479 T@U) (arg1@@200 Int) ) (! (= (type (LinearExtern.__default.lseq_alloc_raw arg0@@479 arg1@@200)) BoxType)
 :qid |funType:LinearExtern.__default.lseq_alloc_raw|
 :pattern ( (LinearExtern.__default.lseq_alloc_raw arg0@@479 arg1@@200))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_alloc_raw$A T@U) (|length#0@@1| Int) ) (!  (=> (and (= (type LinearSequence_s._default.lseq_alloc_raw$A) TyType) (or (|LinearExtern.__default.lseq_alloc_raw#canCall| LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|) (and (INTERNAL_le_boogie 0 |length#0@@1|) (INTERNAL_lt_boogie |length#0@@1| 18446744073709551616)))) (and (and (= (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|))) |length#0@@1|) (forall ((|i#0@@64| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@64|) (INTERNAL_lt_boogie |i#0@@64| |length#0@@1|)) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_alloc_raw$A (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|)) |i#0@@64|))))
 :qid |LinearSequencesdfy.92:22|
 :skolemid |2962|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_alloc_raw$A (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|)) |i#0@@64|))
))) ($IsBox (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|) (|#$lseq| LinearSequence_s._default.lseq_alloc_raw$A))))
 :qid |unknown.0:0|
 :skolemid |2963|
 :pattern ( (LinearExtern.__default.lseq_alloc_raw LinearSequence_s._default.lseq_alloc_raw$A |length#0@@1|))
))))
(assert (forall ((LinearSequence_s._default.lseq_alloc_raw$A@@0 T@U) (|length#0@@2| Int) ) (!  (=> (= (type LinearSequence_s._default.lseq_alloc_raw$A@@0) TyType) (=> (and (INTERNAL_le_boogie 0 |length#0@@2|) (INTERNAL_lt_boogie |length#0@@2| 18446744073709551616)) (= (|LinearExtern.__default.lseq_alloc_raw#requires| LinearSequence_s._default.lseq_alloc_raw$A@@0 |length#0@@2|) true)))
 :qid |unknown.0:0|
 :skolemid |2964|
 :pattern ( (|LinearExtern.__default.lseq_alloc_raw#requires| LinearSequence_s._default.lseq_alloc_raw$A@@0 |length#0@@2|))
)))
(assert (forall ((arg0@@480 T@U) (arg1@@201 T@U) ) (! (= (type (LinearExtern.__default.lseq_free_raw arg0@@480 arg1@@201)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.lseq_free_raw|
 :pattern ( (LinearExtern.__default.lseq_free_raw arg0@@480 arg1@@201))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_free_raw$A T@U) (|s#0@@17| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_free_raw$A) TyType) (= (type |s#0@@17|) BoxType)) (or (|LinearExtern.__default.lseq_free_raw#canCall| LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) (and ($IsBox |s#0@@17| (|#$lseq| LinearSequence_s._default.lseq_free_raw$A)) (forall ((|i#0@@65| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@65|) (INTERNAL_lt_boogie |i#0@@65| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|)))) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_free_raw$A (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) |i#0@@65|))))
 :qid |LinearSequencesdfy.95:23|
 :skolemid |2965|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) |i#0@@65|))
))))) ($Is (LinearExtern.__default.lseq_free_raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |2966|
 :pattern ( (LinearExtern.__default.lseq_free_raw LinearSequence_s._default.lseq_free_raw$A |s#0@@17|))
))))
(assert (forall ((LinearSequence_s._default.lseq_free_raw$A@@0 T@U) (|s#0@@18| T@U) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_free_raw$A@@0) TyType) (= (type |s#0@@18|) BoxType)) ($IsBox |s#0@@18| (|#$lseq| LinearSequence_s._default.lseq_free_raw$A@@0))) (= (|LinearExtern.__default.lseq_free_raw#requires| LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) (forall ((|i#1@@15| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@15|) (INTERNAL_lt_boogie |i#1@@15| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|)))) (not (LinearMaybe.__default.has LinearSequence_s._default.lseq_free_raw$A@@0 (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) |i#1@@15|))))
 :qid |LinearSequencesdfy.95:23|
 :skolemid |2967|
 :pattern ( (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|) |i#1@@15|))
))))
 :qid |unknown.0:0|
 :skolemid |2968|
 :pattern ( (|LinearExtern.__default.lseq_free_raw#requires| LinearSequence_s._default.lseq_free_raw$A@@0 |s#0@@18|))
)))
(assert (forall ((arg0@@481 T@U) (arg1@@202 T@U) (arg2@@96 Int) (arg3@@49 T@U) ) (! (= (type (LinearExtern.__default.lseq_swap_raw_fun arg0@@481 arg1@@202 arg2@@96 arg3@@49)) DatatypeTypeType)
 :qid |funType:LinearExtern.__default.lseq_swap_raw_fun|
 :pattern ( (LinearExtern.__default.lseq_swap_raw_fun arg0@@481 arg1@@202 arg2@@96 arg3@@49))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A T@U) (|s1#0@@3| T@U) (|i#0@@66| Int) (|a1#0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A) TyType) (= (type |s1#0@@3|) BoxType)) (= (type |a1#0|) BoxType)) (or (|LinearExtern.__default.lseq_swap_raw_fun#canCall| LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@66| |a1#0|) (and (and (and ($IsBox |s1#0@@3| (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A)) (and (INTERNAL_le_boogie 0 |i#0@@66|) (INTERNAL_lt_boogie |i#0@@66| 18446744073709551616))) ($IsBox |a1#0| (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A))) (INTERNAL_lt_boogie |i#0@@66| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|)))))) (and (and (= (_System.Tuple2OLL._1 (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@66| |a1#0|)) (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|) |i#0@@66|)) (|Seq#Equal| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A (_System.Tuple2OLL._0 (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@66| |a1#0|))) (|Seq#Update| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3|) |i#0@@66| |a1#0|))) ($Is (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@66| |a1#0|) (Tclass._System.Tuple2OLL (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A) (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A)))))
 :qid |unknown.0:0|
 :skolemid |2969|
 :pattern ( (LinearExtern.__default.lseq_swap_raw_fun LinearSequence_s._default.lseq_swap_raw_fun$A |s1#0@@3| |i#0@@66| |a1#0|))
))))
(assert (forall ((LinearSequence_s._default.lseq_swap_raw_fun$A@@0 T@U) (|s1#0@@4| T@U) (|i#0@@67| Int) (|a1#0@@0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_s._default.lseq_swap_raw_fun$A@@0) TyType) (= (type |s1#0@@4|) BoxType)) (= (type |a1#0@@0|) BoxType)) (and (and ($IsBox |s1#0@@4| (|#$lseq| LinearSequence_s._default.lseq_swap_raw_fun$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@67|) (INTERNAL_lt_boogie |i#0@@67| 18446744073709551616))) ($IsBox |a1#0@@0| (|#$maybe| LinearSequence_s._default.lseq_swap_raw_fun$A@@0)))) (= (|LinearExtern.__default.lseq_swap_raw_fun#requires| LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4| |i#0@@67| |a1#0@@0|) (INTERNAL_lt_boogie |i#0@@67| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4|)))))
 :qid |unknown.0:0|
 :skolemid |2970|
 :pattern ( (|LinearExtern.__default.lseq_swap_raw_fun#requires| LinearSequence_s._default.lseq_swap_raw_fun$A@@0 |s1#0@@4| |i#0@@67| |a1#0@@0|))
)))
(assert (forall ((arg0@@482 T@U) (arg1@@203 T@U) (arg2@@97 Int) ) (! (= (type (LinearExtern.__default.lseq_share_raw arg0@@482 arg1@@203 arg2@@97)) BoxType)
 :qid |funType:LinearExtern.__default.lseq_share_raw|
 :pattern ( (LinearExtern.__default.lseq_share_raw arg0@@482 arg1@@203 arg2@@97))
)))
(assert  (=> true (forall ((LinearSequence_s._default.lseq_share_raw$A T@U) (|s#0@@19| T@U) (|i#0@@68| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_share_raw$A) TyType) (= (type |s#0@@19|) BoxType)) (or (|LinearExtern.__default.lseq_share_raw#canCall| LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@68|) (and (and ($IsBox |s#0@@19| (|#$lseq| LinearSequence_s._default.lseq_share_raw$A)) (and (INTERNAL_le_boogie 0 |i#0@@68|) (INTERNAL_lt_boogie |i#0@@68| 18446744073709551616))) (INTERNAL_lt_boogie |i#0@@68| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19|)))))) (and (= (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@68|) (|Seq#Index| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19|) |i#0@@68|)) ($IsBox (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@68|) (|#$maybe| LinearSequence_s._default.lseq_share_raw$A))))
 :qid |unknown.0:0|
 :skolemid |2971|
 :pattern ( (LinearExtern.__default.lseq_share_raw LinearSequence_s._default.lseq_share_raw$A |s#0@@19| |i#0@@68|))
))))
(assert (forall ((LinearSequence_s._default.lseq_share_raw$A@@0 T@U) (|s#0@@20| T@U) (|i#0@@69| Int) ) (!  (=> (and (and (= (type LinearSequence_s._default.lseq_share_raw$A@@0) TyType) (= (type |s#0@@20|) BoxType)) (and ($IsBox |s#0@@20| (|#$lseq| LinearSequence_s._default.lseq_share_raw$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@69|) (INTERNAL_lt_boogie |i#0@@69| 18446744073709551616)))) (= (|LinearExtern.__default.lseq_share_raw#requires| LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20| |i#0@@69|) (INTERNAL_lt_boogie |i#0@@69| (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20|)))))
 :qid |unknown.0:0|
 :skolemid |2972|
 :pattern ( (|LinearExtern.__default.lseq_share_raw#requires| LinearSequence_s._default.lseq_share_raw$A@@0 |s#0@@20| |i#0@@69|))
)))
(assert (= (type |#ValueMessage.Delta.NoDelta|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#ValueMessage.Delta.NoDelta|) |##ValueMessage.Delta.NoDelta|))
(assert (forall ((d@@105 T@U) ) (!  (=> (= (type d@@105) DatatypeTypeType) (= (ValueMessage.Delta.NoDelta_q d@@105) (= (DatatypeCtorId d@@105) |##ValueMessage.Delta.NoDelta|)))
 :qid |unknown.0:0|
 :skolemid |2973|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@105))
)))
(assert (forall ((d@@106 T@U) ) (!  (=> (and (= (type d@@106) DatatypeTypeType) (ValueMessage.Delta.NoDelta_q d@@106)) (= d@@106 |#ValueMessage.Delta.NoDelta|))
 :qid |unknown.0:0|
 :skolemid |2974|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@106))
)))
(assert (= (type Tclass.ValueMessage.Delta) TyType))
(assert (= (Tag Tclass.ValueMessage.Delta) Tagclass.ValueMessage.Delta))
(assert (= (TagFamily Tclass.ValueMessage.Delta) tytagFamily$Delta))
(assert (forall ((bx@@144 T@U) ) (!  (=> (and (= (type bx@@144) BoxType) ($IsBox bx@@144 Tclass.ValueMessage.Delta)) (and (= ($Box ($Unbox DatatypeTypeType bx@@144)) bx@@144) ($Is ($Unbox DatatypeTypeType bx@@144) Tclass.ValueMessage.Delta)))
 :qid |unknown.0:0|
 :skolemid |2975|
 :pattern ( ($IsBox bx@@144 Tclass.ValueMessage.Delta))
)))
(assert ($Is |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta))
(assert (forall (($h@@121 T@U) ) (!  (=> (and (= (type $h@@121) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@121)) ($IsAlloc |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta $h@@121))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |2976|
 :pattern ( ($IsAlloc |#ValueMessage.Delta.NoDelta| Tclass.ValueMessage.Delta $h@@121))
)))
(assert (= |#ValueMessage.Delta.NoDelta| (Lit |#ValueMessage.Delta.NoDelta|)))
(assert (forall ((d@@107 T@U) ) (!  (=> (and (= (type d@@107) DatatypeTypeType) (|$IsA#ValueMessage.Delta| d@@107)) (ValueMessage.Delta.NoDelta_q d@@107))
 :qid |unknown.0:0|
 :skolemid |2977|
 :pattern ( (|$IsA#ValueMessage.Delta| d@@107))
)))
(assert (forall ((d@@108 T@U) ) (!  (=> (and (= (type d@@108) DatatypeTypeType) ($Is d@@108 Tclass.ValueMessage.Delta)) (ValueMessage.Delta.NoDelta_q d@@108))
 :qid |unknown.0:0|
 :skolemid |2978|
 :pattern ( (ValueMessage.Delta.NoDelta_q d@@108) ($Is d@@108 Tclass.ValueMessage.Delta))
)))
(assert (forall ((a@@149 T@U) (b@@98 T@U) ) (!  (=> (and (and (= (type a@@149) DatatypeTypeType) (= (type b@@98) DatatypeTypeType)) true) (= (|ValueMessage.Delta#Equal| a@@149 b@@98) true))
 :qid |unknown.0:0|
 :skolemid |2979|
 :pattern ( (|ValueMessage.Delta#Equal| a@@149 b@@98))
)))
(assert (forall ((a@@150 T@U) (b@@99 T@U) ) (!  (=> (and (= (type a@@150) DatatypeTypeType) (= (type b@@99) DatatypeTypeType)) (= (|ValueMessage.Delta#Equal| a@@150 b@@99) (= a@@150 b@@99)))
 :qid |unknown.0:0|
 :skolemid |2980|
 :pattern ( (|ValueMessage.Delta#Equal| a@@150 b@@99))
)))
(assert (= (type Tclass.ValueMessage.__default) TyType))
(assert (= (Tag Tclass.ValueMessage.__default) Tagclass.ValueMessage.__default))
(assert (= (TagFamily Tclass.ValueMessage.__default) tytagFamily$_default))
(assert (forall ((bx@@145 T@U) ) (!  (=> (and (= (type bx@@145) BoxType) ($IsBox bx@@145 Tclass.ValueMessage.__default)) (and (= ($Box ($Unbox refType bx@@145)) bx@@145) ($Is ($Unbox refType bx@@145) Tclass.ValueMessage.__default)))
 :qid |unknown.0:0|
 :skolemid |2981|
 :pattern ( ($IsBox bx@@145 Tclass.ValueMessage.__default))
)))
(assert (forall (($o@@25 T@U) ) (!  (=> (= (type $o@@25) refType) (= ($Is $o@@25 Tclass.ValueMessage.__default)  (or (= $o@@25 null) (= (dtype $o@@25) Tclass.ValueMessage.__default))))
 :qid |unknown.0:0|
 :skolemid |2982|
 :pattern ( ($Is $o@@25 Tclass.ValueMessage.__default))
)))
(assert (forall (($o@@26 T@U) ($h@@122 T@U) ) (!  (=> (and (= (type $o@@26) refType) (= (type $h@@122) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@122)  (or (= $o@@26 null) (U_2_bool (MapType1Select (MapType0Select $h@@122 $o@@26) alloc)))))
 :qid |unknown.0:0|
 :skolemid |2983|
 :pattern ( ($IsAlloc $o@@26 Tclass.ValueMessage.__default $h@@122))
)))
(assert (= (type ValueMessage.__default.NopDelta) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.NopDelta Tclass.ValueMessage.Delta))))
(assert (= |ValueMessage.__default.NopDelta#requires| true))
(assert  (=> true (=> true (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert  (=> true (=> true (= ValueMessage.__default.NopDelta (Lit |#ValueMessage.Delta.NoDelta|)))))
(assert  (=> true (=> true ($Is ValueMessage.__default.DefaultValue Tclass.ValueType.Value))))
(assert (= |ValueMessage.__default.DefaultValue#requires| true))
(assert  (=> true (=> true (and |ValueType.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultValue (Lit ValueType.__default.DefaultValue))))))
(assert  (=> true (=> true (and |ValueType.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultValue (Lit ValueType.__default.DefaultValue))))))
(assert (forall ((arg0@@483 T@U) (arg1@@204 T@U) ) (! (= (type (ValueMessage.__default.CombineDeltas arg0@@483 arg1@@204)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.CombineDeltas|
 :pattern ( (ValueMessage.__default.CombineDeltas arg0@@483 arg1@@204))
)))
(assert  (=> true (forall ((|newdelta#0| T@U) (|olddelta#0| T@U) ) (!  (=> (and (and (= (type |newdelta#0|) DatatypeTypeType) (= (type |olddelta#0|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| |newdelta#0| |olddelta#0|) (and ($Is |newdelta#0| Tclass.ValueMessage.Delta) ($Is |olddelta#0| Tclass.ValueMessage.Delta)))) (and (and (=> (|ValueMessage.Delta#Equal| |newdelta#0| ValueMessage.__default.NopDelta) (|ValueMessage.Delta#Equal| (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) |olddelta#0|)) (=> (|ValueMessage.Delta#Equal| |olddelta#0| ValueMessage.__default.NopDelta) (|ValueMessage.Delta#Equal| (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) |newdelta#0|))) ($Is (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|) Tclass.ValueMessage.Delta)))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |2984|
 :pattern ( (ValueMessage.__default.CombineDeltas |newdelta#0| |olddelta#0|))
))))
(assert (forall ((|newdelta#0@@0| T@U) (|olddelta#0@@0| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@0|) DatatypeTypeType) (= (type |olddelta#0@@0|) DatatypeTypeType)) (and ($Is |newdelta#0@@0| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@0| Tclass.ValueMessage.Delta))) (= (|ValueMessage.__default.CombineDeltas#requires| |newdelta#0@@0| |olddelta#0@@0|) true))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |2985|
 :pattern ( (|ValueMessage.__default.CombineDeltas#requires| |newdelta#0@@0| |olddelta#0@@0|))
)))
(assert  (=> true (forall ((|newdelta#0@@1| T@U) (|olddelta#0@@1| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@1|) DatatypeTypeType) (= (type |olddelta#0@@1|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| |newdelta#0@@1| |olddelta#0@@1|) (and ($Is |newdelta#0@@1| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@1| Tclass.ValueMessage.Delta)))) (= (ValueMessage.__default.CombineDeltas |newdelta#0@@1| |olddelta#0@@1|) (Lit |#ValueMessage.Delta.NoDelta|)))
 :qid |MessagesdfyValueMessage.20:33|
 :skolemid |2986|
 :pattern ( (ValueMessage.__default.CombineDeltas |newdelta#0@@1| |olddelta#0@@1|))
))))
(assert  (=> true (forall ((|newdelta#0@@2| T@U) (|olddelta#0@@2| T@U) ) (!  (=> (and (and (= (type |newdelta#0@@2|) DatatypeTypeType) (= (type |olddelta#0@@2|) DatatypeTypeType)) (or (|ValueMessage.__default.CombineDeltas#canCall| (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)) (and ($Is |newdelta#0@@2| Tclass.ValueMessage.Delta) ($Is |olddelta#0@@2| Tclass.ValueMessage.Delta)))) (= (ValueMessage.__default.CombineDeltas (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)) (Lit |#ValueMessage.Delta.NoDelta|)))
 :qid |MessagesdfyValueMessage.20:33|
 :weight 3
 :skolemid |2987|
 :pattern ( (ValueMessage.__default.CombineDeltas (Lit |newdelta#0@@2|) (Lit |olddelta#0@@2|)))
))))
(assert (forall ((arg0@@484 T@U) (arg1@@205 T@U) ) (! (= (type (ValueMessage.__default.ApplyDelta arg0@@484 arg1@@205)) (SeqType BoxType))
 :qid |funType:ValueMessage.__default.ApplyDelta|
 :pattern ( (ValueMessage.__default.ApplyDelta arg0@@484 arg1@@205))
)))
(assert  (=> true (forall ((|delta#0| T@U) (|value#0| T@U) ) (!  (=> (and (and (= (type |delta#0|) DatatypeTypeType) (= (type |value#0|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| |delta#0| |value#0|) (and ($Is |delta#0| Tclass.ValueMessage.Delta) ($Is |value#0| Tclass.ValueType.Value)))) (and (=> (|ValueMessage.Delta#Equal| |delta#0| ValueMessage.__default.NopDelta) (|Seq#Equal| (ValueMessage.__default.ApplyDelta |delta#0| |value#0|) |value#0|)) ($Is (ValueMessage.__default.ApplyDelta |delta#0| |value#0|) Tclass.ValueType.Value)))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |2988|
 :pattern ( (ValueMessage.__default.ApplyDelta |delta#0| |value#0|))
))))
(assert (forall ((|delta#0@@0| T@U) (|value#0@@0| T@U) ) (!  (=> (and (and (= (type |delta#0@@0|) DatatypeTypeType) (= (type |value#0@@0|) (SeqType BoxType))) (and ($Is |delta#0@@0| Tclass.ValueMessage.Delta) ($Is |value#0@@0| Tclass.ValueType.Value))) (= (|ValueMessage.__default.ApplyDelta#requires| |delta#0@@0| |value#0@@0|) true))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |2989|
 :pattern ( (|ValueMessage.__default.ApplyDelta#requires| |delta#0@@0| |value#0@@0|))
)))
(assert  (=> true (forall ((|delta#0@@1| T@U) (|value#0@@1| T@U) ) (!  (=> (and (and (= (type |delta#0@@1|) DatatypeTypeType) (= (type |value#0@@1|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| |delta#0@@1| |value#0@@1|) (and ($Is |delta#0@@1| Tclass.ValueMessage.Delta) ($Is |value#0@@1| Tclass.ValueType.Value)))) (= (ValueMessage.__default.ApplyDelta |delta#0@@1| |value#0@@1|) |value#0@@1|))
 :qid |MessagesdfyValueMessage.24:30|
 :skolemid |2990|
 :pattern ( (ValueMessage.__default.ApplyDelta |delta#0@@1| |value#0@@1|))
))))
(assert  (=> true (forall ((|delta#0@@2| T@U) (|value#0@@2| T@U) ) (!  (=> (and (and (= (type |delta#0@@2|) DatatypeTypeType) (= (type |value#0@@2|) (SeqType BoxType))) (or (|ValueMessage.__default.ApplyDelta#canCall| (Lit |delta#0@@2|) (Lit |value#0@@2|)) (and ($Is |delta#0@@2| Tclass.ValueMessage.Delta) ($Is |value#0@@2| Tclass.ValueType.Value)))) (= (ValueMessage.__default.ApplyDelta (Lit |delta#0@@2|) (Lit |value#0@@2|)) (Lit |value#0@@2|)))
 :qid |MessagesdfyValueMessage.24:30|
 :weight 3
 :skolemid |2991|
 :pattern ( (ValueMessage.__default.ApplyDelta (Lit |delta#0@@2|) (Lit |value#0@@2|)))
))))
(assert (forall ((arg0@@485 T@U) ) (! (= (type (ValueMessage.__default.MakeValueMessage arg0@@485)) DatatypeTypeType)
 :qid |funType:ValueMessage.__default.MakeValueMessage|
 :pattern ( (ValueMessage.__default.MakeValueMessage arg0@@485))
)))
(assert  (=> true (forall ((|value#0@@3| T@U) ) (!  (=> (and (= (type |value#0@@3|) (SeqType BoxType)) (or (|ValueMessage.__default.MakeValueMessage#canCall| |value#0@@3|) ($Is |value#0@@3| Tclass.ValueType.Value))) ($Is (ValueMessage.__default.MakeValueMessage |value#0@@3|) Tclass.ValueMessage.Message))
 :qid |Messagesdfy.90:29|
 :skolemid |2992|
 :pattern ( (ValueMessage.__default.MakeValueMessage |value#0@@3|))
))))
(assert (forall ((|value#0@@4| T@U) ) (!  (=> (and (= (type |value#0@@4|) (SeqType BoxType)) ($Is |value#0@@4| Tclass.ValueType.Value)) (= (|ValueMessage.__default.MakeValueMessage#requires| |value#0@@4|) true))
 :qid |Messagesdfy.90:29|
 :skolemid |2993|
 :pattern ( (|ValueMessage.__default.MakeValueMessage#requires| |value#0@@4|))
)))
(assert  (=> true (forall ((|msg#0| T@U) ) (!  (=> (and (= (type |msg#0|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| |msg#0|) ($Is |msg#0| Tclass.ValueMessage.Message))) true)
 :qid |Messagesdfy.100:30|
 :skolemid |2994|
 :pattern ( (ValueMessage.__default.EncodableMessage |msg#0|))
))))
(assert (forall ((|msg#0@@0| T@U) ) (!  (=> (and (= (type |msg#0@@0|) DatatypeTypeType) ($Is |msg#0@@0| Tclass.ValueMessage.Message)) (= (|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|) true))
 :qid |Messagesdfy.100:30|
 :skolemid |2995|
 :pattern ( (|ValueMessage.__default.EncodableMessage#requires| |msg#0@@0|))
)))
(assert  (=> true (forall ((|msg#0@@1| T@U) ) (!  (=> (and (= (type |msg#0@@1|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| |msg#0@@1|) ($Is |msg#0@@1| Tclass.ValueMessage.Message))) (= (ValueMessage.__default.EncodableMessage |msg#0@@1|)  (and true (ValueMessage.Message.Define_q |msg#0@@1|))))
 :qid |Messagesdfy.100:30|
 :skolemid |2996|
 :pattern ( (ValueMessage.__default.EncodableMessage |msg#0@@1|))
))))
(assert  (=> true (forall ((|msg#0@@2| T@U) ) (!  (=> (and (= (type |msg#0@@2|) DatatypeTypeType) (or (|ValueMessage.__default.EncodableMessage#canCall| (Lit |msg#0@@2|)) ($Is |msg#0@@2| Tclass.ValueMessage.Message))) (= (ValueMessage.__default.EncodableMessage (Lit |msg#0@@2|)) (U_2_bool (Lit (bool_2_U  (and true (ValueMessage.Message.Define_q (Lit |msg#0@@2|))))))))
 :qid |Messagesdfy.100:30|
 :weight 3
 :skolemid |2997|
 :pattern ( (ValueMessage.__default.EncodableMessage (Lit |msg#0@@2|)))
))))
(assert (forall ((arg0@@486 T@U) ) (! (= (type (ValueMessage.__default.EvaluateMessage arg0@@486)) (SeqType BoxType))
 :qid |funType:ValueMessage.__default.EvaluateMessage|
 :pattern ( (ValueMessage.__default.EvaluateMessage arg0@@486))
)))
(assert  (=> true (forall ((|m#0@@9| T@U) ) (!  (=> (and (= (type |m#0@@9|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| |m#0@@9|) (and ($Is |m#0@@9| Tclass.ValueMessage.Message) (ValueMessage.Message.Define_q |m#0@@9|)))) ($Is (ValueMessage.__default.EvaluateMessage |m#0@@9|) Tclass.ValueType.Value))
 :qid |Messagesdfy.105:28|
 :skolemid |2998|
 :pattern ( (ValueMessage.__default.EvaluateMessage |m#0@@9|))
))))
(assert (forall ((|m#0@@10| T@U) ) (!  (=> (and (= (type |m#0@@10|) DatatypeTypeType) ($Is |m#0@@10| Tclass.ValueMessage.Message)) (= (|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|) (ValueMessage.Message.Define_q |m#0@@10|)))
 :qid |Messagesdfy.105:28|
 :skolemid |2999|
 :pattern ( (|ValueMessage.__default.EvaluateMessage#requires| |m#0@@10|))
)))
(assert (forall ((arg0@@487 T@U) ) (! (= (type (ValueMessage.Message.value arg0@@487)) (SeqType BoxType))
 :qid |funType:ValueMessage.Message.value|
 :pattern ( (ValueMessage.Message.value arg0@@487))
)))
(assert  (=> true (forall ((|m#0@@11| T@U) ) (!  (=> (and (= (type |m#0@@11|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| |m#0@@11|) (and ($Is |m#0@@11| Tclass.ValueMessage.Message) (ValueMessage.Message.Define_q |m#0@@11|)))) (= (ValueMessage.__default.EvaluateMessage |m#0@@11|) (ValueMessage.Message.value |m#0@@11|)))
 :qid |Messagesdfy.105:28|
 :skolemid |3000|
 :pattern ( (ValueMessage.__default.EvaluateMessage |m#0@@11|))
))))
(assert  (=> true (forall ((|m#0@@12| T@U) ) (!  (=> (and (= (type |m#0@@12|) DatatypeTypeType) (or (|ValueMessage.__default.EvaluateMessage#canCall| (Lit |m#0@@12|)) (and ($Is |m#0@@12| Tclass.ValueMessage.Message) (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit |m#0@@12|)))))))) (= (ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|)) (Lit (ValueMessage.Message.value (Lit |m#0@@12|)))))
 :qid |Messagesdfy.105:28|
 :weight 3
 :skolemid |3001|
 :pattern ( (ValueMessage.__default.EvaluateMessage (Lit |m#0@@12|)))
))))
(assert  (=> true (forall ((|newmessage#0| T@U) (|oldmessage#0| T@U) ) (!  (=> (and (and (= (type |newmessage#0|) DatatypeTypeType) (= (type |oldmessage#0|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| |newmessage#0| |oldmessage#0|) (and ($Is |newmessage#0| Tclass.ValueMessage.Message) ($Is |oldmessage#0| Tclass.ValueMessage.Message)))) ($Is (ValueMessage.__default.Merge |newmessage#0| |oldmessage#0|) Tclass.ValueMessage.Message))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |3002|
 :pattern ( (ValueMessage.__default.Merge |newmessage#0| |oldmessage#0|))
))))
(assert (forall ((|newmessage#0@@0| T@U) (|oldmessage#0@@0| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@0|) DatatypeTypeType) (= (type |oldmessage#0@@0|) DatatypeTypeType)) (and ($Is |newmessage#0@@0| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@0| Tclass.ValueMessage.Message))) (= (|ValueMessage.__default.Merge#requires| |newmessage#0@@0| |oldmessage#0@@0|) true))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |3003|
 :pattern ( (|ValueMessage.__default.Merge#requires| |newmessage#0@@0| |oldmessage#0@@0|))
)))
(assert  (and (forall ((arg0@@488 T@U) ) (! (= (type (ValueMessage.Message.delta arg0@@488)) DatatypeTypeType)
 :qid |funType:ValueMessage.Message.delta|
 :pattern ( (ValueMessage.Message.delta arg0@@488))
)) (forall ((arg0@@489 T@U) ) (! (= (type (|#ValueMessage.Message.Update| arg0@@489)) DatatypeTypeType)
 :qid |funType:#ValueMessage.Message.Update|
 :pattern ( (|#ValueMessage.Message.Update| arg0@@489))
))))
(assert  (=> true (forall ((|newmessage#0@@1| T@U) (|oldmessage#0@@1| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@1|) DatatypeTypeType) (= (type |oldmessage#0@@1|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| |newmessage#0@@1| |oldmessage#0@@1|) (and ($Is |newmessage#0@@1| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@1| Tclass.ValueMessage.Message)))) (and (and (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (=> (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (=> (not (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))) (and (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (=> (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|value#1| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
 (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|delta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|ValueMessage.__default.ApplyDelta#canCall| |delta#1| |value#1|))))))) (=> (not (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))) (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|olddelta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
 (and (_System.Tuple2.___hMake2_q (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))) (let ((|newdelta#1| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|ValueMessage.__default.CombineDeltas#canCall| |newdelta#1| |olddelta#1|))))))))) (= (ValueMessage.__default.Merge |newmessage#0@@1| |oldmessage#0@@1|) (ite (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (let ((|newvalue#0| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Define| |newvalue#0|)) (ite (ValueMessage.Message.Define_q ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|))))) (let ((|value#0@@5| (ValueMessage.Message.value ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(let ((|delta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Define| (ValueMessage.__default.ApplyDelta |delta#0@@3| |value#0@@5|)))) (let ((|olddelta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._1 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(let ((|newdelta#0@@3| (ValueMessage.Message.delta ($Unbox DatatypeTypeType (_System.Tuple2._0 (|#_System._tuple#2._#Make2| ($Box |newmessage#0@@1|) ($Box |oldmessage#0@@1|)))))))
(|#ValueMessage.Message.Update| (ValueMessage.__default.CombineDeltas |newdelta#0@@3| |olddelta#0@@3|)))))))))
 :qid |MessagesdfyValueMessage.27:25|
 :skolemid |3004|
 :pattern ( (ValueMessage.__default.Merge |newmessage#0@@1| |oldmessage#0@@1|))
))))
(assert  (=> true (forall ((|newmessage#0@@2| T@U) (|oldmessage#0@@2| T@U) ) (!  (=> (and (and (= (type |newmessage#0@@2|) DatatypeTypeType) (= (type |oldmessage#0@@2|) DatatypeTypeType)) (or (|ValueMessage.__default.Merge#canCall| (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)) (and ($Is |newmessage#0@@2| Tclass.ValueMessage.Message) ($Is |oldmessage#0@@2| Tclass.ValueMessage.Message)))) (and (and (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))))))) (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))) (=> (not (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))) (and (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (=> (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))))))))) (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|value#3| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
 (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|delta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(|ValueMessage.__default.ApplyDelta#canCall| |delta#3| |value#3|))))))) (=> (not (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))) (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|olddelta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
 (and (_System.Tuple2.___hMake2_q (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|))))) (let ((|newdelta#3| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(|ValueMessage.__default.CombineDeltas#canCall| |newdelta#3| |olddelta#3|))))))))) (= (ValueMessage.__default.Merge (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)) (ite (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))) (let ((|newvalue#2| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Define| |newvalue#2|))) (ite (ValueMessage.Message.Define_q (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))) (let ((|value#2| (Lit (ValueMessage.Message.value (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(let ((|delta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Define| (Lit (ValueMessage.__default.ApplyDelta |delta#2| |value#2|)))))) (let ((|olddelta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._1 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(let ((|newdelta#2| (Lit (ValueMessage.Message.delta (Lit ($Unbox DatatypeTypeType (_System.Tuple2._0 (Lit (|#_System._tuple#2._#Make2| ($Box (Lit |newmessage#0@@2|)) ($Box (Lit |oldmessage#0@@2|)))))))))))
(Lit (|#ValueMessage.Message.Update| (Lit (ValueMessage.__default.CombineDeltas |newdelta#2| |olddelta#2|)))))))))))
 :qid |MessagesdfyValueMessage.27:25|
 :weight 3
 :skolemid |3005|
 :pattern ( (ValueMessage.__default.Merge (Lit |newmessage#0@@2|) (Lit |oldmessage#0@@2|)))
))))
(assert (= (type ValueMessage.__default.IdentityMessage) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.IdentityMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.IdentityMessage#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| (= ValueMessage.__default.IdentityMessage (Lit (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))))
(assert  (=> true (=> true (and |ValueMessage.__default.NopDelta#canCall| (= ValueMessage.__default.IdentityMessage (Lit (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))))
(assert (= (type ValueMessage.__default.DefaultMessage) DatatypeTypeType))
(assert  (=> true (=> true ($Is ValueMessage.__default.DefaultMessage Tclass.ValueMessage.Message))))
(assert (= |ValueMessage.__default.DefaultMessage#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultMessage (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultValue#canCall| (= ValueMessage.__default.DefaultMessage (Lit (|#ValueMessage.Message.Define| (Lit ValueMessage.__default.DefaultValue))))))))
(assert (forall ((|a#0#0#0@@5| T@U) ) (!  (=> (= (type |a#0#0#0@@5|) (SeqType BoxType)) (= (DatatypeCtorId (|#ValueMessage.Message.Define| |a#0#0#0@@5|)) |##ValueMessage.Message.Define|))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3006|
 :pattern ( (|#ValueMessage.Message.Define| |a#0#0#0@@5|))
)))
(assert (forall ((d@@109 T@U) ) (!  (=> (= (type d@@109) DatatypeTypeType) (= (ValueMessage.Message.Define_q d@@109) (= (DatatypeCtorId d@@109) |##ValueMessage.Message.Define|)))
 :qid |unknown.0:0|
 :skolemid |3007|
 :pattern ( (ValueMessage.Message.Define_q d@@109))
)))
(assert (forall ((d@@110 T@U) ) (!  (=> (and (= (type d@@110) DatatypeTypeType) (ValueMessage.Message.Define_q d@@110)) (exists ((|a#1#0#0@@5| T@U) ) (!  (and (= (type |a#1#0#0@@5|) (SeqType BoxType)) (= d@@110 (|#ValueMessage.Message.Define| |a#1#0#0@@5|)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3008|
 :no-pattern (type |a#1#0#0@@5|)
 :no-pattern (U_2_int |a#1#0#0@@5|)
 :no-pattern (U_2_bool |a#1#0#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |3009|
 :pattern ( (ValueMessage.Message.Define_q d@@110))
)))
(assert (forall ((|a#2#0#0@@5| T@U) ) (!  (=> (= (type |a#2#0#0@@5|) (SeqType BoxType)) (= ($Is (|#ValueMessage.Message.Define| |a#2#0#0@@5|) Tclass.ValueMessage.Message) ($Is |a#2#0#0@@5| Tclass.ValueType.Value)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3010|
 :pattern ( ($Is (|#ValueMessage.Message.Define| |a#2#0#0@@5|) Tclass.ValueMessage.Message))
)))
(assert (forall ((|a#3#0#0@@5| T@U) ($h@@123 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@5|) (SeqType BoxType)) (= (type $h@@123) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@123)) (= ($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@5|) Tclass.ValueMessage.Message $h@@123) ($IsAlloc |a#3#0#0@@5| Tclass.ValueType.Value $h@@123)))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3011|
 :pattern ( ($IsAlloc (|#ValueMessage.Message.Define| |a#3#0#0@@5|) Tclass.ValueMessage.Message $h@@123))
)))
(assert (forall ((d@@111 T@U) ($h@@124 T@U) ) (!  (=> (and (and (= (type d@@111) DatatypeTypeType) (= (type $h@@124) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@124) (and (ValueMessage.Message.Define_q d@@111) ($IsAlloc d@@111 Tclass.ValueMessage.Message $h@@124)))) ($IsAlloc (ValueMessage.Message.value d@@111) Tclass.ValueType.Value $h@@124))
 :qid |unknown.0:0|
 :skolemid |3012|
 :pattern ( ($IsAlloc (ValueMessage.Message.value d@@111) Tclass.ValueType.Value $h@@124))
)))
(assert (forall ((|a#4#0#0@@5| T@U) ) (!  (=> (= (type |a#4#0#0@@5|) (SeqType BoxType)) (= (|#ValueMessage.Message.Define| (Lit |a#4#0#0@@5|)) (Lit (|#ValueMessage.Message.Define| |a#4#0#0@@5|))))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3013|
 :pattern ( (|#ValueMessage.Message.Define| (Lit |a#4#0#0@@5|)))
)))
(assert (forall ((|a#5#0#0@@6| T@U) ) (!  (=> (= (type |a#5#0#0@@6|) (SeqType BoxType)) (= (ValueMessage.Message.value (|#ValueMessage.Message.Define| |a#5#0#0@@6|)) |a#5#0#0@@6|))
 :qid |MessagesdfyValueMessage.17:14|
 :skolemid |3014|
 :pattern ( (|#ValueMessage.Message.Define| |a#5#0#0@@6|))
)))
(assert (forall ((|a#6#0#0@@6| T@U) ) (!  (=> (= (type |a#6#0#0@@6|) DatatypeTypeType) (= (DatatypeCtorId (|#ValueMessage.Message.Update| |a#6#0#0@@6|)) |##ValueMessage.Message.Update|))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3015|
 :pattern ( (|#ValueMessage.Message.Update| |a#6#0#0@@6|))
)))
(assert (forall ((d@@112 T@U) ) (!  (=> (= (type d@@112) DatatypeTypeType) (= (ValueMessage.Message.Update_q d@@112) (= (DatatypeCtorId d@@112) |##ValueMessage.Message.Update|)))
 :qid |unknown.0:0|
 :skolemid |3016|
 :pattern ( (ValueMessage.Message.Update_q d@@112))
)))
(assert (forall ((d@@113 T@U) ) (!  (=> (and (= (type d@@113) DatatypeTypeType) (ValueMessage.Message.Update_q d@@113)) (exists ((|a#7#0#0@@5| T@U) ) (!  (and (= (type |a#7#0#0@@5|) DatatypeTypeType) (= d@@113 (|#ValueMessage.Message.Update| |a#7#0#0@@5|)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3017|
 :no-pattern (type |a#7#0#0@@5|)
 :no-pattern (U_2_int |a#7#0#0@@5|)
 :no-pattern (U_2_bool |a#7#0#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |3018|
 :pattern ( (ValueMessage.Message.Update_q d@@113))
)))
(assert (forall ((|a#8#0#0@@5| T@U) ) (!  (=> (= (type |a#8#0#0@@5|) DatatypeTypeType) (= ($Is (|#ValueMessage.Message.Update| |a#8#0#0@@5|) Tclass.ValueMessage.Message) ($Is |a#8#0#0@@5| Tclass.ValueMessage.Delta)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3019|
 :pattern ( ($Is (|#ValueMessage.Message.Update| |a#8#0#0@@5|) Tclass.ValueMessage.Message))
)))
(assert (forall ((|a#9#0#0@@1| T@U) ($h@@125 T@U) ) (!  (=> (and (and (= (type |a#9#0#0@@1|) DatatypeTypeType) (= (type $h@@125) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@125)) (= ($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@1|) Tclass.ValueMessage.Message $h@@125) ($IsAlloc |a#9#0#0@@1| Tclass.ValueMessage.Delta $h@@125)))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3020|
 :pattern ( ($IsAlloc (|#ValueMessage.Message.Update| |a#9#0#0@@1|) Tclass.ValueMessage.Message $h@@125))
)))
(assert (forall ((d@@114 T@U) ($h@@126 T@U) ) (!  (=> (and (and (= (type d@@114) DatatypeTypeType) (= (type $h@@126) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@126) (and (ValueMessage.Message.Update_q d@@114) ($IsAlloc d@@114 Tclass.ValueMessage.Message $h@@126)))) ($IsAlloc (ValueMessage.Message.delta d@@114) Tclass.ValueMessage.Delta $h@@126))
 :qid |unknown.0:0|
 :skolemid |3021|
 :pattern ( ($IsAlloc (ValueMessage.Message.delta d@@114) Tclass.ValueMessage.Delta $h@@126))
)))
(assert (forall ((|a#10#0#0@@1| T@U) ) (!  (=> (= (type |a#10#0#0@@1|) DatatypeTypeType) (= (|#ValueMessage.Message.Update| (Lit |a#10#0#0@@1|)) (Lit (|#ValueMessage.Message.Update| |a#10#0#0@@1|))))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3022|
 :pattern ( (|#ValueMessage.Message.Update| (Lit |a#10#0#0@@1|)))
)))
(assert (forall ((|a#11#0#0@@0| T@U) ) (!  (=> (= (type |a#11#0#0@@0|) DatatypeTypeType) (= (ValueMessage.Message.delta (|#ValueMessage.Message.Update| |a#11#0#0@@0|)) |a#11#0#0@@0|))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3023|
 :pattern ( (|#ValueMessage.Message.Update| |a#11#0#0@@0|))
)))
(assert (forall ((|a#12#0#0| T@U) ) (!  (=> (= (type |a#12#0#0|) DatatypeTypeType) (< (DtRank |a#12#0#0|) (DtRank (|#ValueMessage.Message.Update| |a#12#0#0|))))
 :qid |MessagesdfyValueMessage.18:14|
 :skolemid |3024|
 :pattern ( (|#ValueMessage.Message.Update| |a#12#0#0|))
)))
(assert (forall ((d@@115 T@U) ) (!  (=> (and (= (type d@@115) DatatypeTypeType) (|$IsA#ValueMessage.Message| d@@115)) (or (ValueMessage.Message.Define_q d@@115) (ValueMessage.Message.Update_q d@@115)))
 :qid |unknown.0:0|
 :skolemid |3025|
 :pattern ( (|$IsA#ValueMessage.Message| d@@115))
)))
(assert (forall ((d@@116 T@U) ) (!  (=> (and (= (type d@@116) DatatypeTypeType) ($Is d@@116 Tclass.ValueMessage.Message)) (or (ValueMessage.Message.Define_q d@@116) (ValueMessage.Message.Update_q d@@116)))
 :qid |unknown.0:0|
 :skolemid |3026|
 :pattern ( (ValueMessage.Message.Update_q d@@116) ($Is d@@116 Tclass.ValueMessage.Message))
 :pattern ( (ValueMessage.Message.Define_q d@@116) ($Is d@@116 Tclass.ValueMessage.Message))
)))
(assert (forall ((a@@151 T@U) (b@@100 T@U) ) (!  (=> (and (and (= (type a@@151) DatatypeTypeType) (= (type b@@100) DatatypeTypeType)) (and (ValueMessage.Message.Define_q a@@151) (ValueMessage.Message.Define_q b@@100))) (= (|ValueMessage.Message#Equal| a@@151 b@@100) (|Seq#Equal| (ValueMessage.Message.value a@@151) (ValueMessage.Message.value b@@100))))
 :qid |unknown.0:0|
 :skolemid |3027|
 :pattern ( (|ValueMessage.Message#Equal| a@@151 b@@100) (ValueMessage.Message.Define_q a@@151))
 :pattern ( (|ValueMessage.Message#Equal| a@@151 b@@100) (ValueMessage.Message.Define_q b@@100))
)))
(assert (forall ((a@@152 T@U) (b@@101 T@U) ) (!  (=> (and (and (= (type a@@152) DatatypeTypeType) (= (type b@@101) DatatypeTypeType)) (and (ValueMessage.Message.Update_q a@@152) (ValueMessage.Message.Update_q b@@101))) (= (|ValueMessage.Message#Equal| a@@152 b@@101) (|ValueMessage.Delta#Equal| (ValueMessage.Message.delta a@@152) (ValueMessage.Message.delta b@@101))))
 :qid |unknown.0:0|
 :skolemid |3028|
 :pattern ( (|ValueMessage.Message#Equal| a@@152 b@@101) (ValueMessage.Message.Update_q a@@152))
 :pattern ( (|ValueMessage.Message#Equal| a@@152 b@@101) (ValueMessage.Message.Update_q b@@101))
)))
(assert (forall ((a@@153 T@U) (b@@102 T@U) ) (!  (=> (and (= (type a@@153) DatatypeTypeType) (= (type b@@102) DatatypeTypeType)) (= (|ValueMessage.Message#Equal| a@@153 b@@102) (= a@@153 b@@102)))
 :qid |unknown.0:0|
 :skolemid |3029|
 :pattern ( (|ValueMessage.Message#Equal| a@@153 b@@102))
)))
(assert (= (type Tclass.TotalKMMapMod.__default) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.__default) Tagclass.TotalKMMapMod.__default))
(assert (= (TagFamily Tclass.TotalKMMapMod.__default) tytagFamily$_default))
(assert (forall ((bx@@146 T@U) ) (!  (=> (and (= (type bx@@146) BoxType) ($IsBox bx@@146 Tclass.TotalKMMapMod.__default)) (and (= ($Box ($Unbox refType bx@@146)) bx@@146) ($Is ($Unbox refType bx@@146) Tclass.TotalKMMapMod.__default)))
 :qid |unknown.0:0|
 :skolemid |3030|
 :pattern ( ($IsBox bx@@146 Tclass.TotalKMMapMod.__default))
)))
(assert (forall (($o@@27 T@U) ) (!  (=> (= (type $o@@27) refType) (= ($Is $o@@27 Tclass.TotalKMMapMod.__default)  (or (= $o@@27 null) (= (dtype $o@@27) Tclass.TotalKMMapMod.__default))))
 :qid |unknown.0:0|
 :skolemid |3031|
 :pattern ( ($Is $o@@27 Tclass.TotalKMMapMod.__default))
)))
(assert (forall (($o@@28 T@U) ($h@@127 T@U) ) (!  (=> (and (= (type $o@@28) refType) (= (type $h@@127) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@127)  (or (= $o@@28 null) (U_2_bool (MapType1Select (MapType0Select $h@@127 $o@@28) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3032|
 :pattern ( ($IsAlloc $o@@28 Tclass.TotalKMMapMod.__default $h@@127))
)))
(assert  (=> true (forall ((|v#0@@57| T@U) ) (!  (=> (and (= (type |v#0@@57|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| |v#0@@57|) ($Is |v#0@@57| Tclass.ValueMessage.Message))) true)
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |3033|
 :pattern ( (TotalKMMapMod.__default.TerminalValue |v#0@@57|))
))))
(assert (forall ((|v#0@@58| T@U) ) (!  (=> (and (= (type |v#0@@58|) DatatypeTypeType) ($Is |v#0@@58| Tclass.ValueMessage.Message)) (= (|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@58|) true))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |3034|
 :pattern ( (|TotalKMMapMod.__default.TerminalValue#requires| |v#0@@58|))
)))
(assert  (=> true (forall ((|v#0@@59| T@U) ) (!  (=> (and (= (type |v#0@@59|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| |v#0@@59|) ($Is |v#0@@59| Tclass.ValueMessage.Message))) (= (TotalKMMapMod.__default.TerminalValue |v#0@@59|) (ValueMessage.Message.Define_q |v#0@@59|)))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :skolemid |3035|
 :pattern ( (TotalKMMapMod.__default.TerminalValue |v#0@@59|))
))))
(assert  (=> true (forall ((|v#0@@60| T@U) ) (!  (=> (and (= (type |v#0@@60|) DatatypeTypeType) (or (|TotalKMMapMod.__default.TerminalValue#canCall| (Lit |v#0@@60|)) ($Is |v#0@@60| Tclass.ValueMessage.Message))) (= (TotalKMMapMod.__default.TerminalValue (Lit |v#0@@60|)) (U_2_bool (Lit (bool_2_U (ValueMessage.Message.Define_q (Lit |v#0@@60|)))))))
 :qid |TotalMapsdfyTotalKMMapMod.11:27|
 :weight 3
 :skolemid |3036|
 :pattern ( (TotalKMMapMod.__default.TerminalValue (Lit |v#0@@60|)))
))))
(assert (= (type TotalKMMapMod.__default.DefaultV) DatatypeTypeType))
(assert  (=> true (=> true (and (U_2_bool (Lit (bool_2_U (TotalKMMapMod.__default.TerminalValue (Lit TotalKMMapMod.__default.DefaultV))))) ($Is TotalKMMapMod.__default.DefaultV Tclass.ValueMessage.Message)))))
(assert (= |TotalKMMapMod.__default.DefaultV#requires| true))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultMessage#canCall| (= TotalKMMapMod.__default.DefaultV (Lit ValueMessage.__default.DefaultMessage))))))
(assert  (=> true (=> true (and |ValueMessage.__default.DefaultMessage#canCall| (= TotalKMMapMod.__default.DefaultV (Lit ValueMessage.__default.DefaultMessage))))))
(assert  (=> true (forall ((|k#0| T@U) ) (!  (=> (and (= (type |k#0|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| |k#0|) ($Is |k#0| Tclass.KeyType.Key))) true)
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |3037|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0|))
))))
(assert (forall ((|k#0@@0| T@U) ) (!  (=> (and (= (type |k#0@@0|) (SeqType BoxType)) ($Is |k#0@@0| Tclass.KeyType.Key)) (= (|TotalKMMapMod.__default.AnyKey#requires| |k#0@@0|) true))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |3038|
 :pattern ( (|TotalKMMapMod.__default.AnyKey#requires| |k#0@@0|))
)))
(assert  (=> true (forall ((|k#0@@1| T@U) ) (!  (=> (and (= (type |k#0@@1|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@1|) ($Is |k#0@@1| Tclass.KeyType.Key))) (= (TotalKMMapMod.__default.AnyKey |k#0@@1|) (U_2_bool (Lit (bool_2_U true)))))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :skolemid |3039|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@1|))
))))
(assert  (=> true (forall ((|k#0@@2| T@U) ) (!  (=> (and (= (type |k#0@@2|) (SeqType BoxType)) (or (|TotalKMMapMod.__default.AnyKey#canCall| (Lit |k#0@@2|)) ($Is |k#0@@2| Tclass.KeyType.Key))) (= (TotalKMMapMod.__default.AnyKey (Lit |k#0@@2|)) (U_2_bool (Lit (bool_2_U true)))))
 :qid |TotalMapsdfyTotalKMMapMod.15:20|
 :weight 3
 :skolemid |3040|
 :pattern ( (TotalKMMapMod.__default.AnyKey (Lit |k#0@@2|)))
))))
(assert  (=> true (forall ((|kvm#0| T@U) (|k#0@@3| T@U) ) (!  (=> (and (and (= (type |kvm#0|) (IMapType BoxType BoxType)) (= (type |k#0@@3|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0| |k#0@@3|) (and ($Is |kvm#0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@3| Tclass.KeyType.Key)))) true)
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |3041|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0| |k#0@@3|))
))))
(assert (forall ((|kvm#0@@0| T@U) (|k#0@@4| T@U) ) (!  (=> (and (and (= (type |kvm#0@@0|) (IMapType BoxType BoxType)) (= (type |k#0@@4|) (SeqType BoxType))) (and ($Is |kvm#0@@0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@4| Tclass.KeyType.Key))) (= (|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@4|) true))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |3042|
 :pattern ( (|TotalKMMapMod.__default.Defined#requires| |kvm#0@@0| |k#0@@4|))
)))
(assert  (=> true (forall ((|kvm#0@@1| T@U) (|k#0@@5| T@U) ) (!  (=> (and (and (= (type |kvm#0@@1|) (IMapType BoxType BoxType)) (= (type |k#0@@5|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@1| |k#0@@5|) (and ($Is |kvm#0@@1| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@5| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|) ($Box |k#0@@5|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@1|) ($Box |k#0@@5|))))) (= (TotalKMMapMod.__default.Defined |kvm#0@@1| |k#0@@5|)  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@1|) ($Box |k#0@@5|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@1|) ($Box |k#0@@5|))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :skolemid |3043|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@1| |k#0@@5|))
))))
(assert  (=> true (forall ((|kvm#0@@2| T@U) (|k#0@@6| T@U) ) (!  (=> (and (and (= (type |kvm#0@@2|) (IMapType BoxType BoxType)) (= (type |k#0@@6|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@2| (Lit |k#0@@6|)) (and ($Is |kvm#0@@2| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@6| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|) ($Box |k#0@@6|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@2|) ($Box (Lit |k#0@@6|)))))) (= (TotalKMMapMod.__default.Defined |kvm#0@@2| (Lit |k#0@@6|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@2|) ($Box |k#0@@6|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| |kvm#0@@2|) ($Box (Lit |k#0@@6|)))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :weight 3
 :skolemid |3044|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@2| (Lit |k#0@@6|)))
))))
(assert  (=> true (forall ((|kvm#0@@3| T@U) (|k#0@@7| T@U) ) (!  (=> (and (and (= (type |kvm#0@@3|) (IMapType BoxType BoxType)) (= (type |k#0@@7|) (SeqType BoxType))) (or (|TotalKMMapMod.__default.Defined#canCall| (Lit |kvm#0@@3|) (Lit |k#0@@7|)) (and ($Is |kvm#0@@3| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is |k#0@@7| Tclass.KeyType.Key)))) (and (=> (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|) ($Box |k#0@@7|))) (|TotalKMMapMod.__default.TerminalValue#canCall| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit |kvm#0@@3|)) ($Box (Lit |k#0@@7|)))))) (= (TotalKMMapMod.__default.Defined (Lit |kvm#0@@3|) (Lit |k#0@@7|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |kvm#0@@3|) ($Box |k#0@@7|))) (TotalKMMapMod.__default.TerminalValue ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit |kvm#0@@3|)) ($Box (Lit |k#0@@7|)))))))))
 :qid |TotalMapsdfyTotalKMMapMod.17:21|
 :weight 3
 :skolemid |3045|
 :pattern ( (TotalKMMapMod.__default.Defined (Lit |kvm#0@@3|) (Lit |k#0@@7|)))
))))
(assert  (=> true (forall ((|kvm#0@@4| T@U) ) (!  (=> (and (= (type |kvm#0@@4|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| |kvm#0@@4|) ($Is |kvm#0@@4| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) true)
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |3046|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@4|))
))))
(assert (forall ((|kvm#0@@5| T@U) ) (!  (=> (and (= (type |kvm#0@@5|) (IMapType BoxType BoxType)) ($Is |kvm#0@@5| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))) (= (|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|) true))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |3047|
 :pattern ( (|TotalKMMapMod.__default.TotalMapIsFull#requires| |kvm#0@@5|))
)))
(assert  (=> true (forall ((|kvm#0@@6| T@U) ) (!  (=> (and (= (type |kvm#0@@6|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| |kvm#0@@6|) ($Is |kvm#0@@6| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) (and (forall ((|k#0@@8| T@U) ) (!  (=> (and (= (type |k#0@@8|) (SeqType BoxType)) ($Is |k#0@@8| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@8|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@8|) (|TotalKMMapMod.__default.Defined#canCall| |kvm#0@@6| |k#0@@8|))))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |3049|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@8|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@8|))
)) (= (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@6|) (forall ((|k#0@@9| T@U) ) (!  (=> (= (type |k#0@@9|) (SeqType BoxType)) (=> (and ($Is |k#0@@9| Tclass.KeyType.Key) (TotalKMMapMod.__default.AnyKey |k#0@@9|)) (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@9|)))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |3048|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@6| |k#0@@9|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@9|))
)))))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :skolemid |3050|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull |kvm#0@@6|))
))))
(assert  (=> true (forall ((|kvm#0@@7| T@U) ) (!  (=> (and (= (type |kvm#0@@7|) (IMapType BoxType BoxType)) (or (|TotalKMMapMod.__default.TotalMapIsFull#canCall| (Lit |kvm#0@@7|)) ($Is |kvm#0@@7| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))) (and (forall ((|k#1| T@U) ) (!  (=> (and (= (type |k#1|) (SeqType BoxType)) ($Is |k#1| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#1|) (=> (TotalKMMapMod.__default.AnyKey |k#1|) (|TotalKMMapMod.__default.Defined#canCall| (Lit |kvm#0@@7|) |k#1|))))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |3052|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@7| |k#1|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#1|))
)) (= (TotalKMMapMod.__default.TotalMapIsFull (Lit |kvm#0@@7|)) (forall ((|k#1@@0| T@U) ) (!  (=> (= (type |k#1@@0|) (SeqType BoxType)) (=> (and ($Is |k#1@@0| Tclass.KeyType.Key) (TotalKMMapMod.__default.AnyKey |k#1@@0|)) (TotalKMMapMod.__default.Defined (Lit |kvm#0@@7|) |k#1@@0|)))
 :qid |TotalMapsdfyTotalKMMapMod.22:12|
 :skolemid |3051|
 :pattern ( (TotalKMMapMod.__default.Defined |kvm#0@@7| |k#1@@0|))
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#1@@0|))
)))))
 :qid |TotalMapsdfyTotalKMMapMod.21:28|
 :weight 3
 :skolemid |3053|
 :pattern ( (TotalKMMapMod.__default.TotalMapIsFull (Lit |kvm#0@@7|)))
))))
(assert (= (type TotalKMMapMod.__default.EmptyTotalMap) (IMapType BoxType BoxType)))
(assert  (=> true (=> true (and (U_2_bool (Lit (bool_2_U (TotalKMMapMod.__default.TotalMapIsFull (Lit TotalKMMapMod.__default.EmptyTotalMap))))) ($Is TotalKMMapMod.__default.EmptyTotalMap (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
(assert (= |TotalKMMapMod.__default.EmptyTotalMap#requires| true))
(assert  (and (forall ((arg0@@490 T@U) ) (! (= (type (|lambda#137| arg0@@490)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#137|
 :pattern ( (|lambda#137| arg0@@490))
)) (forall ((arg0@@491 T@U) ) (! (= (type (|lambda#138| arg0@@491)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#138|
 :pattern ( (|lambda#138| arg0@@491))
))))
(assert  (=> true (=> true (and (forall ((|k#0@@10| T@U) ) (!  (=> (and (= (type |k#0@@10|) (SeqType BoxType)) ($Is |k#0@@10| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@10|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@10|) |TotalKMMapMod.__default.DefaultV#canCall|)))
 :qid |TotalMapsdfyTotalKMMapMod.28:10|
 :skolemid |3054|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@10|))
)) (= TotalKMMapMod.__default.EmptyTotalMap (|IMap#Glue| (|lambda#137| Tclass.KeyType.Key) (|lambda#138| ($Box (Lit TotalKMMapMod.__default.DefaultV))) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))))
(assert  (=> true (=> true (and (forall ((|k#0@@11| T@U) ) (!  (=> (and (= (type |k#0@@11|) (SeqType BoxType)) ($Is |k#0@@11| Tclass.KeyType.Key)) (and (|TotalKMMapMod.__default.AnyKey#canCall| |k#0@@11|) (=> (TotalKMMapMod.__default.AnyKey |k#0@@11|) |TotalKMMapMod.__default.DefaultV#canCall|)))
 :qid |TotalMapsdfyTotalKMMapMod.28:10|
 :skolemid |3055|
 :pattern ( (TotalKMMapMod.__default.AnyKey |k#0@@11|))
)) (= TotalKMMapMod.__default.EmptyTotalMap (|IMap#Glue| (|lambda#137| Tclass.KeyType.Key) (|lambda#138| ($Box (Lit TotalKMMapMod.__default.DefaultV))) (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)))))))
(assert (= (type TotalKMMapMod.__default.Witness) (IMapType BoxType BoxType)))
(assert  (=> true (=> true (and (|IMap#Equal| TotalKMMapMod.__default.Witness TotalKMMapMod.__default.EmptyTotalMap) ($Is TotalKMMapMod.__default.Witness (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
(assert (= |TotalKMMapMod.__default.Witness#requires| true))
(assert (= (type Tclass.TotalKMMapMod.TotalMap) TyType))
(assert (= (Tag Tclass.TotalKMMapMod.TotalMap) Tagclass.TotalKMMapMod.TotalMap))
(assert (= (TagFamily Tclass.TotalKMMapMod.TotalMap) tytagFamily$TotalMap))
(assert (forall ((bx@@147 T@U) ) (!  (=> (and (= (type bx@@147) BoxType) ($IsBox bx@@147 Tclass.TotalKMMapMod.TotalMap)) (and (= ($Box ($Unbox (IMapType BoxType BoxType) bx@@147)) bx@@147) ($Is ($Unbox (IMapType BoxType BoxType) bx@@147) Tclass.TotalKMMapMod.TotalMap)))
 :qid |unknown.0:0|
 :skolemid |3056|
 :pattern ( ($IsBox bx@@147 Tclass.TotalKMMapMod.TotalMap))
)))
(assert (forall ((|ikv#0| T@U) ) (!  (=> (= (type |ikv#0|) (IMapType BoxType BoxType)) (= ($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap)  (and ($Is |ikv#0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) (TotalKMMapMod.__default.TotalMapIsFull |ikv#0|))))
 :qid |unknown.0:0|
 :skolemid |3057|
 :pattern ( ($Is |ikv#0| Tclass.TotalKMMapMod.TotalMap))
)))
(assert (forall ((|ikv#0@@0| T@U) ($h@@128 T@U) ) (!  (=> (and (= (type |ikv#0@@0|) (IMapType BoxType BoxType)) (= (type $h@@128) (MapType0Type refType MapType1Type))) (= ($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@128) ($IsAlloc |ikv#0@@0| (TIMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@128)))
 :qid |unknown.0:0|
 :skolemid |3058|
 :pattern ( ($IsAlloc |ikv#0@@0| Tclass.TotalKMMapMod.TotalMap $h@@128))
)))
(assert (= (type Tclass.LSNMod.__default) TyType))
(assert (= (Tag Tclass.LSNMod.__default) Tagclass.LSNMod.__default))
(assert (= (TagFamily Tclass.LSNMod.__default) tytagFamily$_default))
(assert (forall ((bx@@148 T@U) ) (!  (=> (and (= (type bx@@148) BoxType) ($IsBox bx@@148 Tclass.LSNMod.__default)) (and (= ($Box ($Unbox refType bx@@148)) bx@@148) ($Is ($Unbox refType bx@@148) Tclass.LSNMod.__default)))
 :qid |unknown.0:0|
 :skolemid |3059|
 :pattern ( ($IsBox bx@@148 Tclass.LSNMod.__default))
)))
(assert (forall (($o@@29 T@U) ) (!  (=> (= (type $o@@29) refType) (= ($Is $o@@29 Tclass.LSNMod.__default)  (or (= $o@@29 null) (= (dtype $o@@29) Tclass.LSNMod.__default))))
 :qid |unknown.0:0|
 :skolemid |3060|
 :pattern ( ($Is $o@@29 Tclass.LSNMod.__default))
)))
(assert (forall (($o@@30 T@U) ($h@@129 T@U) ) (!  (=> (and (= (type $o@@30) refType) (= (type $h@@129) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@129)  (or (= $o@@30 null) (U_2_bool (MapType1Select (MapType0Select $h@@129 $o@@30) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3061|
 :pattern ( ($IsAlloc $o@@30 Tclass.LSNMod.__default $h@@129))
)))
(assert (forall ((|a#0#0#0@@6| T@U) (|a#0#1#0@@4| Int) ) (!  (=> (= (type |a#0#0#0@@6|) BoxType) (= (DatatypeCtorId (|#StampedMod.Stamped.Stamped| |a#0#0#0@@6| |a#0#1#0@@4|)) |##StampedMod.Stamped.Stamped|))
 :qid |StampedMapidfy.18:33|
 :skolemid |3062|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#0#0#0@@6| |a#0#1#0@@4|))
)))
(assert (forall ((d@@117 T@U) ) (!  (=> (= (type d@@117) DatatypeTypeType) (= (StampedMod.Stamped.Stamped_q d@@117) (= (DatatypeCtorId d@@117) |##StampedMod.Stamped.Stamped|)))
 :qid |unknown.0:0|
 :skolemid |3063|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@117))
)))
(assert (forall ((d@@118 T@U) ) (!  (=> (and (= (type d@@118) DatatypeTypeType) (StampedMod.Stamped.Stamped_q d@@118)) (exists ((|a#1#0#0@@6| T@U) (|a#1#1#0@@4| Int) ) (!  (and (= (type |a#1#0#0@@6|) BoxType) (= d@@118 (|#StampedMod.Stamped.Stamped| |a#1#0#0@@6| |a#1#1#0@@4|)))
 :qid |StampedMapidfy.18:33|
 :skolemid |3064|
 :no-pattern (type |a#1#0#0@@6|)
 :no-pattern (U_2_int |a#1#0#0@@6|)
 :no-pattern (U_2_bool |a#1#0#0@@6|)
)))
 :qid |unknown.0:0|
 :skolemid |3065|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@118))
)))
(assert (forall ((StampedMod.Stamped$T@@2 T@U) (|a#2#0#0@@6| T@U) (|a#2#1#0@@4| Int) ) (!  (=> (and (= (type StampedMod.Stamped$T@@2) TyType) (= (type |a#2#0#0@@6|) BoxType)) (= ($Is (|#StampedMod.Stamped.Stamped| |a#2#0#0@@6| |a#2#1#0@@4|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2))  (and ($IsBox |a#2#0#0@@6| StampedMod.Stamped$T@@2) ($Is (int_2_U |a#2#1#0@@4|) Tclass._System.nat))))
 :qid |unknown.0:0|
 :skolemid |3066|
 :pattern ( ($Is (|#StampedMod.Stamped.Stamped| |a#2#0#0@@6| |a#2#1#0@@4|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@2)))
)))
(assert (forall ((StampedMod.Stamped$T@@3 T@U) (|a#3#0#0@@6| T@U) (|a#3#1#0@@4| Int) ($h@@130 T@U) ) (!  (=> (and (and (and (= (type StampedMod.Stamped$T@@3) TyType) (= (type |a#3#0#0@@6|) BoxType)) (= (type $h@@130) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@130)) (= ($IsAlloc (|#StampedMod.Stamped.Stamped| |a#3#0#0@@6| |a#3#1#0@@4|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3) $h@@130)  (and ($IsAllocBox |a#3#0#0@@6| StampedMod.Stamped$T@@3 $h@@130) ($IsAlloc (int_2_U |a#3#1#0@@4|) Tclass._System.nat $h@@130))))
 :qid |unknown.0:0|
 :skolemid |3067|
 :pattern ( ($IsAlloc (|#StampedMod.Stamped.Stamped| |a#3#0#0@@6| |a#3#1#0@@4|) (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@3) $h@@130))
)))
(assert (forall ((d@@119 T@U) (StampedMod.Stamped$T@@4 T@U) ($h@@131 T@U) ) (!  (=> (and (and (and (= (type d@@119) DatatypeTypeType) (= (type StampedMod.Stamped$T@@4) TyType)) (= (type $h@@131) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@131) (and (StampedMod.Stamped.Stamped_q d@@119) ($IsAlloc d@@119 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@4) $h@@131)))) ($IsAllocBox (StampedMod.Stamped.value d@@119) StampedMod.Stamped$T@@4 $h@@131))
 :qid |unknown.0:0|
 :skolemid |3068|
 :pattern ( ($IsAllocBox (StampedMod.Stamped.value d@@119) StampedMod.Stamped$T@@4 $h@@131))
)))
(assert (forall ((d@@120 T@U) ($h@@132 T@U) ) (!  (=> (and (and (= (type d@@120) DatatypeTypeType) (= (type $h@@132) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@132) (and (StampedMod.Stamped.Stamped_q d@@120) (exists ((StampedMod.Stamped$T@@5 T@U) ) (!  (and (= (type StampedMod.Stamped$T@@5) TyType) ($IsAlloc d@@120 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@5) $h@@132))
 :qid |unknown.0:0|
 :skolemid |3069|
 :pattern ( ($IsAlloc d@@120 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@5) $h@@132))
))))) ($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@120)) Tclass._System.nat $h@@132))
 :qid |unknown.0:0|
 :skolemid |3070|
 :pattern ( ($IsAlloc (int_2_U (StampedMod.Stamped.seqEnd d@@120)) Tclass._System.nat $h@@132))
)))
(assert (forall ((|a#4#0#0@@6| T@U) (|a#4#1#0@@4| Int) ) (!  (=> (= (type |a#4#0#0@@6|) BoxType) (= (|#StampedMod.Stamped.Stamped| (Lit |a#4#0#0@@6|) (LitInt |a#4#1#0@@4|)) (Lit (|#StampedMod.Stamped.Stamped| |a#4#0#0@@6| |a#4#1#0@@4|))))
 :qid |StampedMapidfy.18:33|
 :skolemid |3071|
 :pattern ( (|#StampedMod.Stamped.Stamped| (Lit |a#4#0#0@@6|) (LitInt |a#4#1#0@@4|)))
)))
(assert (forall ((|a#5#0#0@@7| T@U) (|a#5#1#0@@4| Int) ) (!  (=> (= (type |a#5#0#0@@7|) BoxType) (= (StampedMod.Stamped.value (|#StampedMod.Stamped.Stamped| |a#5#0#0@@7| |a#5#1#0@@4|)) |a#5#0#0@@7|))
 :qid |StampedMapidfy.18:33|
 :skolemid |3072|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#5#0#0@@7| |a#5#1#0@@4|))
)))
(assert (forall ((|a#6#0#0@@7| T@U) (|a#6#1#0@@4| Int) ) (!  (=> (= (type |a#6#0#0@@7|) BoxType) (< (BoxRank |a#6#0#0@@7|) (DtRank (|#StampedMod.Stamped.Stamped| |a#6#0#0@@7| |a#6#1#0@@4|))))
 :qid |StampedMapidfy.18:33|
 :skolemid |3073|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#6#0#0@@7| |a#6#1#0@@4|))
)))
(assert (forall ((|a#7#0#0@@6| T@U) (|a#7#1#0@@4| Int) ) (!  (=> (= (type |a#7#0#0@@6|) BoxType) (= (StampedMod.Stamped.seqEnd (|#StampedMod.Stamped.Stamped| |a#7#0#0@@6| |a#7#1#0@@4|)) |a#7#1#0@@4|))
 :qid |StampedMapidfy.18:33|
 :skolemid |3074|
 :pattern ( (|#StampedMod.Stamped.Stamped| |a#7#0#0@@6| |a#7#1#0@@4|))
)))
(assert (forall ((d@@121 T@U) ) (!  (=> (and (= (type d@@121) DatatypeTypeType) (|$IsA#StampedMod.Stamped| d@@121)) (StampedMod.Stamped.Stamped_q d@@121))
 :qid |unknown.0:0|
 :skolemid |3075|
 :pattern ( (|$IsA#StampedMod.Stamped| d@@121))
)))
(assert (forall ((StampedMod.Stamped$T@@6 T@U) (d@@122 T@U) ) (!  (=> (and (and (= (type StampedMod.Stamped$T@@6) TyType) (= (type d@@122) DatatypeTypeType)) ($Is d@@122 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6))) (StampedMod.Stamped.Stamped_q d@@122))
 :qid |unknown.0:0|
 :skolemid |3076|
 :pattern ( (StampedMod.Stamped.Stamped_q d@@122) ($Is d@@122 (Tclass.StampedMod.Stamped StampedMod.Stamped$T@@6)))
)))
(assert (forall ((a@@154 T@U) (b@@103 T@U) ) (!  (=> (and (and (= (type a@@154) DatatypeTypeType) (= (type b@@103) DatatypeTypeType)) true) (= (|StampedMod.Stamped#Equal| a@@154 b@@103)  (and (= (StampedMod.Stamped.value a@@154) (StampedMod.Stamped.value b@@103)) (= (StampedMod.Stamped.seqEnd a@@154) (StampedMod.Stamped.seqEnd b@@103)))))
 :qid |unknown.0:0|
 :skolemid |3077|
 :pattern ( (|StampedMod.Stamped#Equal| a@@154 b@@103))
)))
(assert (forall ((a@@155 T@U) (b@@104 T@U) ) (!  (=> (and (= (type a@@155) DatatypeTypeType) (= (type b@@104) DatatypeTypeType)) (= (|StampedMod.Stamped#Equal| a@@155 b@@104) (= a@@155 b@@104)))
 :qid |unknown.0:0|
 :skolemid |3078|
 :pattern ( (|StampedMod.Stamped#Equal| a@@155 b@@104))
)))
(assert (= (type Tclass.StampedMod.__default) TyType))
(assert (= (Tag Tclass.StampedMod.__default) Tagclass.StampedMod.__default))
(assert (= (TagFamily Tclass.StampedMod.__default) tytagFamily$_default))
(assert (forall ((bx@@149 T@U) ) (!  (=> (and (= (type bx@@149) BoxType) ($IsBox bx@@149 Tclass.StampedMod.__default)) (and (= ($Box ($Unbox refType bx@@149)) bx@@149) ($Is ($Unbox refType bx@@149) Tclass.StampedMod.__default)))
 :qid |unknown.0:0|
 :skolemid |3079|
 :pattern ( ($IsBox bx@@149 Tclass.StampedMod.__default))
)))
(assert (forall (($o@@31 T@U) ) (!  (=> (= (type $o@@31) refType) (= ($Is $o@@31 Tclass.StampedMod.__default)  (or (= $o@@31 null) (= (dtype $o@@31) Tclass.StampedMod.__default))))
 :qid |unknown.0:0|
 :skolemid |3080|
 :pattern ( ($Is $o@@31 Tclass.StampedMod.__default))
)))
(assert (forall (($o@@32 T@U) ($h@@133 T@U) ) (!  (=> (and (= (type $o@@32) refType) (= (type $h@@133) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@133)  (or (= $o@@32 null) (U_2_bool (MapType1Select (MapType0Select $h@@133 $o@@32) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3081|
 :pattern ( ($IsAlloc $o@@32 Tclass.StampedMod.__default $h@@133))
)))
(assert (= (type StampedMod.__default.Empty) DatatypeTypeType))
(assert  (=> true (=> true ($Is StampedMod.__default.Empty (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))))
(assert (= |StampedMod.__default.Empty#requires| true))
(assert  (=> true (=> true (and |TotalKMMapMod.__default.EmptyTotalMap#canCall| (= StampedMod.__default.Empty (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap)) (LitInt 0))))))))
(assert  (=> true (=> true (and |TotalKMMapMod.__default.EmptyTotalMap#canCall| (= StampedMod.__default.Empty (Lit (|#StampedMod.Stamped.Stamped| ($Box (Lit TotalKMMapMod.__default.EmptyTotalMap)) (LitInt 0))))))))
(assert (= (type Tclass.SequencesLite.__default) TyType))
(assert (= (Tag Tclass.SequencesLite.__default) Tagclass.SequencesLite.__default))
(assert (= (TagFamily Tclass.SequencesLite.__default) tytagFamily$_default))
(assert (forall ((bx@@150 T@U) ) (!  (=> (and (= (type bx@@150) BoxType) ($IsBox bx@@150 Tclass.SequencesLite.__default)) (and (= ($Box ($Unbox refType bx@@150)) bx@@150) ($Is ($Unbox refType bx@@150) Tclass.SequencesLite.__default)))
 :qid |unknown.0:0|
 :skolemid |3082|
 :pattern ( ($IsBox bx@@150 Tclass.SequencesLite.__default))
)))
(assert (forall (($o@@33 T@U) ) (!  (=> (= (type $o@@33) refType) (= ($Is $o@@33 Tclass.SequencesLite.__default)  (or (= $o@@33 null) (= (dtype $o@@33) Tclass.SequencesLite.__default))))
 :qid |unknown.0:0|
 :skolemid |3083|
 :pattern ( ($Is $o@@33 Tclass.SequencesLite.__default))
)))
(assert (forall (($o@@34 T@U) ($h@@134 T@U) ) (!  (=> (and (= (type $o@@34) refType) (= (type $h@@134) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@134)  (or (= $o@@34 null) (U_2_bool (MapType1Select (MapType0Select $h@@134 $o@@34) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3084|
 :pattern ( ($IsAlloc $o@@34 Tclass.SequencesLite.__default $h@@134))
)))
(assert (forall ((arg0@@492 T@U) (arg1@@206 T@U) ) (! (= (type (SequencesLite.__default.Last arg0@@492 arg1@@206)) BoxType)
 :qid |funType:SequencesLite.__default.Last|
 :pattern ( (SequencesLite.__default.Last arg0@@492 arg1@@206))
)))
(assert  (=> true (forall ((SequencesLite._default.Last$E T@U) (|run#0| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E) TyType) (= (type |run#0|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E |run#0|) (and ($Is |run#0| (TSeq SequencesLite._default.Last$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0|) 0)))) ($IsBox (SequencesLite.__default.Last SequencesLite._default.Last$E |run#0|) SequencesLite._default.Last$E))
 :qid |unknown.0:0|
 :skolemid |3085|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E |run#0|))
))))
(assert (forall ((SequencesLite._default.Last$E@@0 T@U) (|run#0@@0| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@0) TyType) (= (type |run#0@@0|) (SeqType BoxType))) ($Is |run#0@@0| (TSeq SequencesLite._default.Last$E@@0))) (= (|SequencesLite.__default.Last#requires| SequencesLite._default.Last$E@@0 |run#0@@0|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@0|) 0)))
 :qid |unknown.0:0|
 :skolemid |3086|
 :pattern ( (|SequencesLite.__default.Last#requires| SequencesLite._default.Last$E@@0 |run#0@@0|))
)))
(assert  (=> true (forall ((SequencesLite._default.Last$E@@1 T@U) (|run#0@@1| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@1) TyType) (= (type |run#0@@1|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E@@1 |run#0@@1|) (and ($Is |run#0@@1| (TSeq SequencesLite._default.Last$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@1|) 0)))) (= (SequencesLite.__default.Last SequencesLite._default.Last$E@@1 |run#0@@1|) (|Seq#Index| |run#0@@1| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@1|) 1))))
 :qid |unknown.0:0|
 :skolemid |3087|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E@@1 |run#0@@1|))
))))
(assert  (=> true (forall ((SequencesLite._default.Last$E@@2 T@U) (|run#0@@2| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.Last$E@@2) TyType) (= (type |run#0@@2|) (SeqType BoxType))) (or (|SequencesLite.__default.Last#canCall| SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)) (and ($Is |run#0@@2| (TSeq SequencesLite._default.Last$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@2|)) 0)))) (= (SequencesLite.__default.Last SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)) (|Seq#Index| (Lit |run#0@@2|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@2|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3088|
 :pattern ( (SequencesLite.__default.Last SequencesLite._default.Last$E@@2 (Lit |run#0@@2|)))
))))
(assert (forall ((arg0@@493 T@U) (arg1@@207 T@U) ) (! (= (type (SequencesLite.__default.DropLast arg0@@493 arg1@@207)) (SeqType BoxType))
 :qid |funType:SequencesLite.__default.DropLast|
 :pattern ( (SequencesLite.__default.DropLast arg0@@493 arg1@@207))
)))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E T@U) (|run#0@@3| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E) TyType) (= (type |run#0@@3|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E |run#0@@3|) (and ($Is |run#0@@3| (TSeq SequencesLite._default.DropLast$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@3|) 0)))) ($Is (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E |run#0@@3|) (TSeq SequencesLite._default.DropLast$E)))
 :qid |unknown.0:0|
 :skolemid |3089|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E |run#0@@3|))
))))
(assert (forall ((SequencesLite._default.DropLast$E@@0 T@U) (|run#0@@4| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@0) TyType) (= (type |run#0@@4|) (SeqType BoxType))) ($Is |run#0@@4| (TSeq SequencesLite._default.DropLast$E@@0))) (= (|SequencesLite.__default.DropLast#requires| SequencesLite._default.DropLast$E@@0 |run#0@@4|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@4|) 0)))
 :qid |unknown.0:0|
 :skolemid |3090|
 :pattern ( (|SequencesLite.__default.DropLast#requires| SequencesLite._default.DropLast$E@@0 |run#0@@4|))
)))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E@@1 T@U) (|run#0@@5| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@1) TyType) (= (type |run#0@@5|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E@@1 |run#0@@5|) (and ($Is |run#0@@5| (TSeq SequencesLite._default.DropLast$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@5|) 0)))) (= (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@1 |run#0@@5|) (|Seq#Take| |run#0@@5| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@5|) 1))))
 :qid |unknown.0:0|
 :skolemid |3091|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@1 |run#0@@5|))
))))
(assert  (=> true (forall ((SequencesLite._default.DropLast$E@@2 T@U) (|run#0@@6| T@U) ) (!  (=> (and (and (= (type SequencesLite._default.DropLast$E@@2) TyType) (= (type |run#0@@6|) (SeqType BoxType))) (or (|SequencesLite.__default.DropLast#canCall| SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)) (and ($Is |run#0@@6| (TSeq SequencesLite._default.DropLast$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@6|)) 0)))) (= (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)) (|Seq#Take| (Lit |run#0@@6|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@6|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3092|
 :pattern ( (SequencesLite.__default.DropLast SequencesLite._default.DropLast$E@@2 (Lit |run#0@@6|)))
))))
(assert (= (type Tclass.Mathematics.__default) TyType))
(assert (= (Tag Tclass.Mathematics.__default) Tagclass.Mathematics.__default))
(assert (= (TagFamily Tclass.Mathematics.__default) tytagFamily$_default))
(assert (forall ((bx@@151 T@U) ) (!  (=> (and (= (type bx@@151) BoxType) ($IsBox bx@@151 Tclass.Mathematics.__default)) (and (= ($Box ($Unbox refType bx@@151)) bx@@151) ($Is ($Unbox refType bx@@151) Tclass.Mathematics.__default)))
 :qid |unknown.0:0|
 :skolemid |3093|
 :pattern ( ($IsBox bx@@151 Tclass.Mathematics.__default))
)))
(assert (forall (($o@@35 T@U) ) (!  (=> (= (type $o@@35) refType) (= ($Is $o@@35 Tclass.Mathematics.__default)  (or (= $o@@35 null) (= (dtype $o@@35) Tclass.Mathematics.__default))))
 :qid |unknown.0:0|
 :skolemid |3094|
 :pattern ( ($Is $o@@35 Tclass.Mathematics.__default))
)))
(assert (forall (($o@@36 T@U) ($h@@135 T@U) ) (!  (=> (and (= (type $o@@36) refType) (= (type $h@@135) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@135)  (or (= $o@@36 null) (U_2_bool (MapType1Select (MapType0Select $h@@135 $o@@36) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3095|
 :pattern ( ($IsAlloc $o@@36 Tclass.Mathematics.__default $h@@135))
)))
(assert  (=> true (forall ((|a#0@@11| Int) (|b#0@@1| Int) ) (!  (=> true true)
 :qid |mathematicsidfy.6:15|
 :skolemid |3096|
 :pattern ( (Mathematics.__default.min |a#0@@11| |b#0@@1|))
))))
(assert (forall ((|a#0@@12| Int) (|b#0@@2| Int) ) (! (= (|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|) true)
 :qid |mathematicsidfy.6:15|
 :skolemid |3097|
 :pattern ( (|Mathematics.__default.min#requires| |a#0@@12| |b#0@@2|))
)))
(assert  (=> true (forall ((|a#0@@13| Int) (|b#0@@3| Int) ) (!  (=> true (= (Mathematics.__default.min |a#0@@13| |b#0@@3|) (ite (INTERNAL_lt_boogie |a#0@@13| |b#0@@3|) |a#0@@13| |b#0@@3|)))
 :qid |mathematicsidfy.6:15|
 :skolemid |3098|
 :pattern ( (Mathematics.__default.min |a#0@@13| |b#0@@3|))
))))
(assert  (=> true (forall ((|a#0@@14| Int) (|b#0@@4| Int) ) (!  (=> true (= (Mathematics.__default.min (LitInt |a#0@@14|) (LitInt |b#0@@4|)) (ite (INTERNAL_lt_boogie |a#0@@14| |b#0@@4|) |a#0@@14| |b#0@@4|)))
 :qid |mathematicsidfy.6:15|
 :weight 3
 :skolemid |3099|
 :pattern ( (Mathematics.__default.min (LitInt |a#0@@14|) (LitInt |b#0@@4|)))
))))
(assert  (=> true (forall ((|a#0@@15| Int) (|b#0@@5| Int) ) (!  (=> true true)
 :qid |mathematicsidfy.14:15|
 :skolemid |3100|
 :pattern ( (Mathematics.__default.max |a#0@@15| |b#0@@5|))
))))
(assert (forall ((|a#0@@16| Int) (|b#0@@6| Int) ) (! (= (|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|) true)
 :qid |mathematicsidfy.14:15|
 :skolemid |3101|
 :pattern ( (|Mathematics.__default.max#requires| |a#0@@16| |b#0@@6|))
)))
(assert  (=> true (forall ((|a#0@@17| Int) (|b#0@@7| Int) ) (!  (=> true (= (Mathematics.__default.max |a#0@@17| |b#0@@7|) (ite (INTERNAL_lt_boogie |a#0@@17| |b#0@@7|) |b#0@@7| |a#0@@17|)))
 :qid |mathematicsidfy.14:15|
 :skolemid |3102|
 :pattern ( (Mathematics.__default.max |a#0@@17| |b#0@@7|))
))))
(assert  (=> true (forall ((|a#0@@18| Int) (|b#0@@8| Int) ) (!  (=> true (= (Mathematics.__default.max (LitInt |a#0@@18|) (LitInt |b#0@@8|)) (ite (INTERNAL_lt_boogie |a#0@@18| |b#0@@8|) |b#0@@8| |a#0@@18|)))
 :qid |mathematicsidfy.14:15|
 :weight 3
 :skolemid |3103|
 :pattern ( (Mathematics.__default.max (LitInt |a#0@@18|) (LitInt |b#0@@8|)))
))))
(assert (forall ((arg0@@494 T@U) (arg1@@208 T@U) ) (! (= (type (Mathematics.__default.Set arg0@@494 arg1@@208)) (MapType0Type BoxType boolType))
 :qid |funType:Mathematics.__default.Set|
 :pattern ( (Mathematics.__default.Set arg0@@494 arg1@@208))
)))
(assert  (=> true (forall ((Mathematics._default.Set$T T@U) (|ms#0| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T) TyType) (= (type |ms#0|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T |ms#0|) ($Is |ms#0| (TMultiSet Mathematics._default.Set$T)))) ($Is (Mathematics.__default.Set Mathematics._default.Set$T |ms#0|) (TSet Mathematics._default.Set$T)))
 :qid |unknown.0:0|
 :skolemid |3104|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T |ms#0|))
))))
(assert (forall ((Mathematics._default.Set$T@@0 T@U) (|ms#0@@0| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@0) TyType) (= (type |ms#0@@0|) (MapType0Type BoxType intType))) ($Is |ms#0@@0| (TMultiSet Mathematics._default.Set$T@@0))) (= (|Mathematics.__default.Set#requires| Mathematics._default.Set$T@@0 |ms#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |3105|
 :pattern ( (|Mathematics.__default.Set#requires| Mathematics._default.Set$T@@0 |ms#0@@0|))
)))
(assert (forall ((arg0@@495 T@U) (arg1@@209 T@U) (arg2@@98 Int) ) (! (= (type (|lambda#141| arg0@@495 arg1@@209 arg2@@98)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#141|
 :pattern ( (|lambda#141| arg0@@495 arg1@@209 arg2@@98))
)))
(assert  (=> true (forall ((Mathematics._default.Set$T@@1 T@U) (|ms#0@@1| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@1) TyType) (= (type |ms#0@@1|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T@@1 |ms#0@@1|) ($Is |ms#0@@1| (TMultiSet Mathematics._default.Set$T@@1)))) (= (Mathematics.__default.Set Mathematics._default.Set$T@@1 |ms#0@@1|) (|lambda#141| Mathematics._default.Set$T@@1 |ms#0@@1| 0)))
 :qid |unknown.0:0|
 :skolemid |3106|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T@@1 |ms#0@@1|))
))))
(assert  (=> true (forall ((Mathematics._default.Set$T@@2 T@U) (|ms#0@@2| T@U) ) (!  (=> (and (and (= (type Mathematics._default.Set$T@@2) TyType) (= (type |ms#0@@2|) (MapType0Type BoxType intType))) (or (|Mathematics.__default.Set#canCall| Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)) ($Is |ms#0@@2| (TMultiSet Mathematics._default.Set$T@@2)))) (= (Mathematics.__default.Set Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)) (|lambda#141| Mathematics._default.Set$T@@2 (Lit |ms#0@@2|) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3107|
 :pattern ( (Mathematics.__default.Set Mathematics._default.Set$T@@2 (Lit |ms#0@@2|)))
))))
(assert (forall ((arg0@@496 T@U) (arg1@@210 T@U) ) (! (= (type (Mathematics.__default.ISet arg0@@496 arg1@@210)) (MapType0Type BoxType boolType))
 :qid |funType:Mathematics.__default.ISet|
 :pattern ( (Mathematics.__default.ISet arg0@@496 arg1@@210))
)))
(assert  (=> true (forall ((Mathematics._default.ISet$T T@U) (|ms#0@@3| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T) TyType) (= (type |ms#0@@3|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T |ms#0@@3|) ($Is |ms#0@@3| (TSet Mathematics._default.ISet$T)))) ($Is (Mathematics.__default.ISet Mathematics._default.ISet$T |ms#0@@3|) (TISet Mathematics._default.ISet$T)))
 :qid |unknown.0:0|
 :skolemid |3108|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T |ms#0@@3|))
))))
(assert (forall ((Mathematics._default.ISet$T@@0 T@U) (|ms#0@@4| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@0) TyType) (= (type |ms#0@@4|) (MapType0Type BoxType boolType))) ($Is |ms#0@@4| (TSet Mathematics._default.ISet$T@@0))) (= (|Mathematics.__default.ISet#requires| Mathematics._default.ISet$T@@0 |ms#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |3109|
 :pattern ( (|Mathematics.__default.ISet#requires| Mathematics._default.ISet$T@@0 |ms#0@@4|))
)))
(assert (forall ((arg0@@497 T@U) (arg1@@211 T@U) ) (! (= (type (|lambda#143| arg0@@497 arg1@@211)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#143|
 :pattern ( (|lambda#143| arg0@@497 arg1@@211))
)))
(assert  (=> true (forall ((Mathematics._default.ISet$T@@1 T@U) (|ms#0@@5| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@1) TyType) (= (type |ms#0@@5|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T@@1 |ms#0@@5|) ($Is |ms#0@@5| (TSet Mathematics._default.ISet$T@@1)))) (= (Mathematics.__default.ISet Mathematics._default.ISet$T@@1 |ms#0@@5|) (|lambda#143| Mathematics._default.ISet$T@@1 |ms#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |3110|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T@@1 |ms#0@@5|))
))))
(assert  (=> true (forall ((Mathematics._default.ISet$T@@2 T@U) (|ms#0@@6| T@U) ) (!  (=> (and (and (= (type Mathematics._default.ISet$T@@2) TyType) (= (type |ms#0@@6|) (MapType0Type BoxType boolType))) (or (|Mathematics.__default.ISet#canCall| Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)) ($Is |ms#0@@6| (TSet Mathematics._default.ISet$T@@2)))) (= (Mathematics.__default.ISet Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)) (|lambda#143| Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3111|
 :pattern ( (Mathematics.__default.ISet Mathematics._default.ISet$T@@2 (Lit |ms#0@@6|)))
))))
(assert (= (type Tclass.LinearSequence__i.__default) TyType))
(assert (= (Tag Tclass.LinearSequence__i.__default) Tagclass.LinearSequence__i.__default))
(assert (= (TagFamily Tclass.LinearSequence__i.__default) tytagFamily$_default))
(assert (forall (($o@@37 T@U) ) (!  (=> (= (type $o@@37) refType) (= ($Is $o@@37 Tclass.LinearSequence__i.__default)  (or (= $o@@37 null) (= (dtype $o@@37) Tclass.LinearSequence__i.__default))))
 :qid |unknown.0:0|
 :skolemid |3112|
 :pattern ( ($Is $o@@37 Tclass.LinearSequence__i.__default))
)))
(assert (forall (($o@@38 T@U) ($h@@136 T@U) ) (!  (=> (and (= (type $o@@38) refType) (= (type $h@@136) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@136)  (or (= $o@@38 null) (U_2_bool (MapType1Select (MapType0Select $h@@136 $o@@38) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3113|
 :pattern ( ($IsAlloc $o@@38 Tclass.LinearSequence__i.__default $h@@136))
)))
(assert (forall ((arg0@@498 T@U) (arg1@@212 Int) (arg2@@99 T@U) ) (! (= (type (LinearSequence__i.__default.seq__alloc__init arg0@@498 arg1@@212 arg2@@99)) (SeqType BoxType))
 :qid |funType:LinearSequence__i.__default.seq__alloc__init|
 :pattern ( (LinearSequence__i.__default.seq__alloc__init arg0@@498 arg1@@212 arg2@@99))
)))
(assert  (=> true (forall ((LinearSequence_i._default.seq_alloc_init$A T@U) (|length#0@@3| Int) (|a#0@@19| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.seq_alloc_init$A) TyType) (= (type |a#0@@19|) BoxType)) (or (|LinearSequence__i.__default.seq__alloc__init#canCall| LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) (and (and (INTERNAL_le_boogie 0 |length#0@@3|) (INTERNAL_lt_boogie |length#0@@3| 18446744073709551616)) ($IsBox |a#0@@19| LinearSequence_i._default.seq_alloc_init$A)))) (and (and (= (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|)) |length#0@@3|) (forall ((|i#0@@70| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@70|) (INTERNAL_lt_boogie |i#0@@70| (|Seq#Length| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|)))) (= (|Seq#Index| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) |i#0@@70|) |a#0@@19|))
 :qid |LinearSequenceidfy.22:22|
 :skolemid |3114|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) |i#0@@70|))
))) ($Is (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|) (TSeq LinearSequence_i._default.seq_alloc_init$A))))
 :qid |unknown.0:0|
 :skolemid |3115|
 :pattern ( (LinearSequence__i.__default.seq__alloc__init LinearSequence_i._default.seq_alloc_init$A |length#0@@3| |a#0@@19|))
))))
(assert (forall ((LinearSequence_i._default.seq_alloc_init$A@@0 T@U) (|length#0@@4| Int) (|a#0@@20| T@U) ) (!  (=> (and (= (type LinearSequence_i._default.seq_alloc_init$A@@0) TyType) (= (type |a#0@@20|) BoxType)) (=> (and (and (INTERNAL_le_boogie 0 |length#0@@4|) (INTERNAL_lt_boogie |length#0@@4| 18446744073709551616)) ($IsBox |a#0@@20| LinearSequence_i._default.seq_alloc_init$A@@0)) (= (|LinearSequence__i.__default.seq__alloc__init#requires| LinearSequence_i._default.seq_alloc_init$A@@0 |length#0@@4| |a#0@@20|) true)))
 :qid |unknown.0:0|
 :skolemid |3116|
 :pattern ( (|LinearSequence__i.__default.seq__alloc__init#requires| LinearSequence_i._default.seq_alloc_init$A@@0 |length#0@@4| |a#0@@20|))
)))
(assert (forall ((arg0@@499 T@U) (arg1@@213 T@U) ) (! (= (type (LinearSequence__i.__default.lseqs arg0@@499 arg1@@213)) (SeqType BoxType))
 :qid |funType:LinearSequence__i.__default.lseqs|
 :pattern ( (LinearSequence__i.__default.lseqs arg0@@499 arg1@@213))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseqs$A T@U) (|l#0@@5| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseqs$A) TyType) (= (type |l#0@@5|) BoxType)) (or (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseqs$A |l#0@@5|) ($IsBox |l#0@@5| (|#$lseq| LinearSequence_i._default.lseqs$A)))) (and (and (_System.__default.rank__is__less__than (TSeq LinearSequence_i._default.lseqs$A) (|#$lseq| LinearSequence_i._default.lseqs$A) ($Box (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|)) |l#0@@5|) (= (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|)) (|Seq#Length| (LinearExtern.__default.lseqs__raw LinearSequence_i._default.lseqs$A |l#0@@5|)))) ($Is (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|) (TSeq LinearSequence_i._default.lseqs$A))))
 :qid |unknown.0:0|
 :skolemid |3117|
 :pattern ( (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseqs$A |l#0@@5|))
))))
(assert (forall ((LinearSequence_i._default.lseqs$A@@0 T@U) (|l#0@@6| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseqs$A@@0) TyType) (= (type |l#0@@6|) BoxType)) ($IsBox |l#0@@6| (|#$lseq| LinearSequence_i._default.lseqs$A@@0))) (= (|LinearSequence__i.__default.lseqs#requires| LinearSequence_i._default.lseqs$A@@0 |l#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |3118|
 :pattern ( (|LinearSequence__i.__default.lseqs#requires| LinearSequence_i._default.lseqs$A@@0 |l#0@@6|))
)))
(assert (forall ((arg0@@500 T@U) (arg1@@214 T@U) ) (! (= (type (LinearSequence__i.__default.imagine__lseq arg0@@500 arg1@@214)) BoxType)
 :qid |funType:LinearSequence__i.__default.imagine__lseq|
 :pattern ( (LinearSequence__i.__default.imagine__lseq arg0@@500 arg1@@214))
)))
(assert  (=> true (forall ((LinearSequence_i._default.imagine_lseq$A T@U) (|s#0@@21| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.imagine_lseq$A) TyType) (= (type |s#0@@21|) (SeqType BoxType))) (or (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.imagine_lseq$A |s#0@@21|) ($Is |s#0@@21| (TSeq LinearSequence_i._default.imagine_lseq$A)))) (and (and (|Seq#Equal| (LinearSequence__i.__default.lseqs LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |s#0@@21|) (forall ((|i#0@@71| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@71|) (INTERNAL_lt_boogie |i#0@@71| (|Seq#Length| |s#0@@21|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |i#0@@71|)))))
 :qid |LinearSequenceidfy.38:20|
 :skolemid |3119|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.imagine_lseq$A (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|)) |i#0@@71|)))
))) ($IsBox (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|) (|#$lseq| LinearSequence_i._default.imagine_lseq$A))))
 :qid |unknown.0:0|
 :skolemid |3120|
 :pattern ( (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.imagine_lseq$A |s#0@@21|))
))))
(assert (forall ((LinearSequence_i._default.imagine_lseq$A@@0 T@U) (|s#0@@22| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.imagine_lseq$A@@0) TyType) (= (type |s#0@@22|) (SeqType BoxType))) ($Is |s#0@@22| (TSeq LinearSequence_i._default.imagine_lseq$A@@0))) (= (|LinearSequence__i.__default.imagine__lseq#requires| LinearSequence_i._default.imagine_lseq$A@@0 |s#0@@22|) true))
 :qid |unknown.0:0|
 :skolemid |3121|
 :pattern ( (|LinearSequence__i.__default.imagine__lseq#requires| LinearSequence_i._default.imagine_lseq$A@@0 |s#0@@22|))
)))
(assert (forall ((arg0@@501 T@U) (arg1@@215 T@U) ) (! (= (type (LinearSequence__i.__default.linLast arg0@@501 arg1@@215)) BoxType)
 :qid |funType:LinearSequence__i.__default.linLast|
 :pattern ( (LinearSequence__i.__default.linLast arg0@@501 arg1@@215))
)))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A T@U) (|l#0@@7| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A) TyType) (= (type |l#0@@7|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A |l#0@@7|) (and ($IsBox |l#0@@7| (|#$lseq| LinearSequence_i._default.linLast$A)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A |l#0@@7|))))) ($IsBox (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A |l#0@@7|) LinearSequence_i._default.linLast$A))
 :qid |unknown.0:0|
 :skolemid |3123|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A |l#0@@7|))
))))
(assert (forall ((LinearSequence_i._default.linLast$A@@0 T@U) (|l#0@@8| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@0) TyType) (= (type |l#0@@8|) BoxType)) ($IsBox |l#0@@8| (|#$lseq| LinearSequence_i._default.linLast$A@@0))) (= (|LinearSequence__i.__default.linLast#requires| LinearSequence_i._default.linLast$A@@0 |l#0@@8|) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@0 |l#0@@8|))))
 :qid |unknown.0:0|
 :skolemid |3124|
 :pattern ( (|LinearSequence__i.__default.linLast#requires| LinearSequence_i._default.linLast$A@@0 |l#0@@8|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A@@1 T@U) (|l#0@@9| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@1) TyType) (= (type |l#0@@9|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (and ($IsBox |l#0@@9| (|#$lseq| LinearSequence_i._default.linLast$A@@1)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@1 |l#0@@9|))))) (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.linLast$A@@1 |l#0@@9|)) (= (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.linLast$A@@1 |l#0@@9|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@1 |l#0@@9|) 1)))))
 :qid |unknown.0:0|
 :skolemid |3125|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@1 |l#0@@9|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.linLast$A@@2 T@U) (|l#0@@10| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.linLast$A@@2) TyType) (= (type |l#0@@10|) BoxType)) (or (|LinearSequence__i.__default.linLast#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (and ($IsBox |l#0@@10| (|#$lseq| LinearSequence_i._default.linLast$A@@2)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|))))))))) (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|))) (= (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)) 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3126|
 :pattern ( (LinearSequence__i.__default.linLast LinearSequence_i._default.linLast$A@@2 (Lit |l#0@@10|)))
))))
(assert (forall ((arg0@@502 T@U) (arg1@@216 T@U) ) (! (= (type (LinearSequence__i.__default.ldroplast arg0@@502 arg1@@216)) BoxType)
 :qid |funType:LinearSequence__i.__default.ldroplast|
 :pattern ( (LinearSequence__i.__default.ldroplast arg0@@502 arg1@@216))
)))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A T@U) (|l#0@@11| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A) TyType) (= (type |l#0@@11|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A |l#0@@11|) (and ($IsBox |l#0@@11| (|#$lseq| LinearSequence_i._default.ldroplast$A)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A |l#0@@11|))))) (and (and (= (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A |l#0@@11|) (INTERNAL_add_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) 1)) (forall ((|i#0@@72| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@72|) (INTERNAL_lt_boogie |i#0@@72| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)))) (= (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) |i#0@@72|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A |l#0@@11|) |i#0@@72|))))
 :qid |LinearSequenceidfy.59:20|
 :skolemid |3127|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A |l#0@@11|) |i#0@@72|))
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|)) |i#0@@72|))
))) ($IsBox (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|) (|#$lseq| LinearSequence_i._default.ldroplast$A))))
 :qid |unknown.0:0|
 :skolemid |3128|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A |l#0@@11|))
))))
(assert (forall ((LinearSequence_i._default.ldroplast$A@@0 T@U) (|l#0@@12| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@0) TyType) (= (type |l#0@@12|) BoxType)) ($IsBox |l#0@@12| (|#$lseq| LinearSequence_i._default.ldroplast$A@@0))) (= (|LinearSequence__i.__default.ldroplast#requires| LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|))))
 :qid |unknown.0:0|
 :skolemid |3129|
 :pattern ( (|LinearSequence__i.__default.ldroplast#requires| LinearSequence_i._default.ldroplast$A@@0 |l#0@@12|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A@@1 T@U) (|l#0@@13| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@1) TyType) (= (type |l#0@@13|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (and ($IsBox |l#0@@13| (|#$lseq| LinearSequence_i._default.ldroplast$A@@1)) (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|))))) (and (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|)) (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.ldroplast$A@@1 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) 1)))) (= (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.ldroplast$A@@1 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|) 1))))))
 :qid |unknown.0:0|
 :skolemid |3130|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@1 |l#0@@13|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.ldroplast$A@@2 T@U) (|l#0@@14| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.ldroplast$A@@2) TyType) (= (type |l#0@@14|) BoxType)) (or (|LinearSequence__i.__default.ldroplast#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (and ($IsBox |l#0@@14| (|#$lseq| LinearSequence_i._default.ldroplast$A@@2)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|))))))))) (and (and (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|))) (|LinearSequence__i.__default.imagine__lseq#canCall| LinearSequence_i._default.ldroplast$A@@2 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) 1))))) (= (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LinearSequence__i.__default.imagine__lseq LinearSequence_i._default.ldroplast$A@@2 (|Seq#Take| (LinearSequence__i.__default.lseqs LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) (LitInt (INTERNAL_sub_boogie (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)) 1)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3131|
 :pattern ( (LinearSequence__i.__default.ldroplast LinearSequence_i._default.ldroplast$A@@2 (Lit |l#0@@14|)))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A T@U) (|l#0@@15| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A) TyType) (= (type |l#0@@15|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A |l#0@@15|) ($IsBox |l#0@@15| (|#$lseq| LinearSequence_i._default.lseq_has_all$A)))) true)
 :qid |unknown.0:0|
 :skolemid |3132|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A |l#0@@15|))
))))
(assert (forall ((LinearSequence_i._default.lseq_has_all$A@@0 T@U) (|l#0@@16| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@0) TyType) (= (type |l#0@@16|) BoxType)) ($IsBox |l#0@@16| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@0))) (= (|LinearSequence__i.__default.lseq__has__all#requires| LinearSequence_i._default.lseq_has_all$A@@0 |l#0@@16|) true))
 :qid |unknown.0:0|
 :skolemid |3133|
 :pattern ( (|LinearSequence__i.__default.lseq__has__all#requires| LinearSequence_i._default.lseq_has_all$A@@0 |l#0@@16|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A@@1 T@U) (|l#0@@17| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@1) TyType) (= (type |l#0@@17|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) ($IsBox |l#0@@17| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@1)))) (and (forall ((|i#0@@73| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@73|) (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) (=> (INTERNAL_lt_boogie |i#0@@73| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|)) (|LinearExtern.__default.lseq__has#canCall| LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |3135|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@73|)))
)) (= (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) (forall ((|i#0@@74| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@74|) (INTERNAL_lt_boogie |i#0@@74| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@74|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |3134|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|) |i#0@@74|)))
)))))
 :qid |unknown.0:0|
 :skolemid |3136|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@1 |l#0@@17|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_has_all$A@@2 T@U) (|l#0@@18| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_has_all$A@@2) TyType) (= (type |l#0@@18|) BoxType)) (or (|LinearSequence__i.__default.lseq__has__all#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) ($IsBox |l#0@@18| (|#$lseq| LinearSequence_i._default.lseq_has_all$A@@2)))) (and (forall ((|i#1@@16| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@16|) (and (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) (=> (INTERNAL_lt_boogie |i#1@@16| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|))) (|LinearExtern.__default.lseq__has#canCall| LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |3138|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 |l#0@@18|) |i#1@@16|)))
)) (= (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)) (forall ((|i#1@@17| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@17|) (INTERNAL_lt_boogie |i#1@@17| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|))) |i#1@@17|)))))
 :qid |LinearSequenceidfy.81:12|
 :skolemid |3137|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_has_all$A@@2 |l#0@@18|) |i#1@@17|)))
)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3139|
 :pattern ( (LinearSequence__i.__default.lseq__has__all LinearSequence_i._default.lseq_has_all$A@@2 (Lit |l#0@@18|)))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length_as_uint64$A T@U) (|s#0@@23| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A) TyType) (= (type |s#0@@23|) BoxType)) (or (|LinearSequence__i.__default.lseq__length__as__uint64#canCall| LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) (and ($IsBox |s#0@@23| (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A)) (INTERNAL_le_boogie (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|)) 18446744073709551615)))) (and (= (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|))) (and (INTERNAL_le_boogie 0 (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|)) (INTERNAL_lt_boogie (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|) 18446744073709551616))))
 :qid |unknown.0:0|
 :skolemid |3140|
 :pattern ( (LinearSequence__i.__default.lseq__length__as__uint64 LinearSequence_i._default.lseq_length_as_uint64$A |s#0@@23|))
))))
(assert (forall ((LinearSequence_i._default.lseq_length_as_uint64$A@@0 T@U) (|s#0@@24| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length_as_uint64$A@@0) TyType) (= (type |s#0@@24|) BoxType)) ($IsBox |s#0@@24| (|#$lseq| LinearSequence_i._default.lseq_length_as_uint64$A@@0))) (= (|LinearSequence__i.__default.lseq__length__as__uint64#requires| LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|) (INTERNAL_le_boogie (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|)) 18446744073709551615)))
 :qid |unknown.0:0|
 :skolemid |3141|
 :pattern ( (|LinearSequence__i.__default.lseq__length__as__uint64#requires| LinearSequence_i._default.lseq_length_as_uint64$A@@0 |s#0@@24|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A T@U) (|s#0@@25| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A) TyType) (= (type |s#0@@25|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A |s#0@@25|) ($IsBox |s#0@@25| (|#$lseq| LinearSequence_i._default.lseq_length$A)))) (INTERNAL_le_boogie 0 (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A |s#0@@25|)))
 :qid |unknown.0:0|
 :skolemid |3143|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A |s#0@@25|))
))))
(assert (forall ((LinearSequence_i._default.lseq_length$A@@0 T@U) (|s#0@@26| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@0) TyType) (= (type |s#0@@26|) BoxType)) ($IsBox |s#0@@26| (|#$lseq| LinearSequence_i._default.lseq_length$A@@0))) (= (|LinearSequence__i.__default.lseq__length#requires| LinearSequence_i._default.lseq_length$A@@0 |s#0@@26|) true))
 :qid |unknown.0:0|
 :skolemid |3144|
 :pattern ( (|LinearSequence__i.__default.lseq__length#requires| LinearSequence_i._default.lseq_length$A@@0 |s#0@@26|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A@@1 T@U) (|s#0@@27| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@1) TyType) (= (type |s#0@@27|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) ($IsBox |s#0@@27| (|#$lseq| LinearSequence_i._default.lseq_length$A@@1)))) (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) (= (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|)))))
 :qid |unknown.0:0|
 :skolemid |3145|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@1 |s#0@@27|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_length$A@@2 T@U) (|s#0@@28| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_length$A@@2) TyType) (= (type |s#0@@28|) BoxType)) (or (|LinearSequence__i.__default.lseq__length#canCall| LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) ($IsBox |s#0@@28| (|#$lseq| LinearSequence_i._default.lseq_length$A@@2)))) (and (|LinearSequence__i.__default.lseqs#canCall| LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) (= (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)) (|Seq#Length| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3146|
 :pattern ( (LinearSequence__i.__default.lseq__length LinearSequence_i._default.lseq_length$A@@2 (Lit |s#0@@28|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A| T@U) (|s#0@@29| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A|) TyType) (= (type |s#0@@29|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|) ($IsBox |s#0@@29| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A|)))) (INTERNAL_le_boogie 0 (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |3147|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A| |s#0@@29|))
))))
(assert (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@0| T@U) (|s#0@@30| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@0|) TyType) (= (type |s#0@@30|) BoxType)) ($IsBox |s#0@@30| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@0|))) (= (|LinearSequence__i.__default.operator_kcardinality_qlseq#requires| |LinearSequence_i._default.operator'cardinality?lseq$A@@0| |s#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |3148|
 :pattern ( (|LinearSequence__i.__default.operator_kcardinality_qlseq#requires| |LinearSequence_i._default.operator'cardinality?lseq$A@@0| |s#0@@30|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@1| T@U) (|s#0@@31| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@1|) TyType) (= (type |s#0@@31|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) ($IsBox |s#0@@31| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@1|)))) (and (|LinearSequence__i.__default.lseq__length#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) (= (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|) (LinearSequence__i.__default.lseq__length |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|))))
 :qid |unknown.0:0|
 :skolemid |3149|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@1| |s#0@@31|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'cardinality?lseq$A@@2| T@U) (|s#0@@32| T@U) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'cardinality?lseq$A@@2|) TyType) (= (type |s#0@@32|) BoxType)) (or (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) ($IsBox |s#0@@32| (|#$lseq| |LinearSequence_i._default.operator'cardinality?lseq$A@@2|)))) (and (|LinearSequence__i.__default.lseq__length#canCall| |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) (= (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)) (LitInt (LinearSequence__i.__default.lseq__length |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3150|
 :pattern ( (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'cardinality?lseq$A@@2| (Lit |s#0@@32|)))
))))
(assert (forall ((arg0@@503 T@U) (arg1@@217 T@U) (arg2@@100 Int) ) (! (= (type (LinearSequence__i.__default.operator_ksubscript_qlseq arg0@@503 arg1@@217 arg2@@100)) BoxType)
 :qid |funType:LinearSequence__i.__default.operator_ksubscript_qlseq|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq arg0@@503 arg1@@217 arg2@@100))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A| T@U) (|s#0@@33| T@U) (|i#0@@75| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A|) TyType) (= (type |s#0@@33|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@75|) (and (and ($IsBox |s#0@@33| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A|)) (INTERNAL_le_boogie 0 |i#0@@75|)) (INTERNAL_lt_boogie |i#0@@75| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33|))))) ($IsBox (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@75|) |LinearSequence_i._default.operator'subscript?lseq$A|))
 :qid |unknown.0:0|
 :skolemid |3151|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A| |s#0@@33| |i#0@@75|))
))))
(assert (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@0| T@U) (|s#0@@34| T@U) (|i#0@@76| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@0|) TyType) (= (type |s#0@@34|) BoxType)) (and ($IsBox |s#0@@34| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@0|)) (INTERNAL_le_boogie 0 |i#0@@76|))) (= (|LinearSequence__i.__default.operator_ksubscript_qlseq#requires| |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34| |i#0@@76|) (INTERNAL_lt_boogie |i#0@@76| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34|))))
 :qid |unknown.0:0|
 :skolemid |3152|
 :pattern ( (|LinearSequence__i.__default.operator_ksubscript_qlseq#requires| |LinearSequence_i._default.operator'subscript?lseq$A@@0| |s#0@@34| |i#0@@76|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@1| T@U) (|s#0@@35| T@U) (|i#0@@77| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@1|) TyType) (= (type |s#0@@35|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@77|) (and (and ($IsBox |s#0@@35| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@1|)) (INTERNAL_le_boogie 0 |i#0@@77|)) (INTERNAL_lt_boogie |i#0@@77| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@77|) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35|) |i#0@@77|))))
 :qid |unknown.0:0|
 :skolemid |3153|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@1| |s#0@@35| |i#0@@77|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@2| T@U) (|s#0@@36| T@U) (|i#0@@78| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@2|) TyType) (= (type |s#0@@36|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@78|)) (and (and ($IsBox |s#0@@36| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@2|)) (INTERNAL_le_boogie 0 |i#0@@78|)) (INTERNAL_lt_boogie |i#0@@78| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@78|)) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36|) (LitInt |i#0@@78|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3154|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@2| |s#0@@36| (LitInt |i#0@@78|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'subscript?lseq$A@@3| T@U) (|s#0@@37| T@U) (|i#0@@79| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'subscript?lseq$A@@3|) TyType) (= (type |s#0@@37|) BoxType)) (or (|LinearSequence__i.__default.operator_ksubscript_qlseq#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@79|)) (and (and ($IsBox |s#0@@37| (|#$lseq| |LinearSequence_i._default.operator'subscript?lseq$A@@3|)) (INTERNAL_le_boogie 0 |i#0@@79|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie |i#0@@79| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|))))))))) (and (|LinearSequence__i.__default.lseqs#canCall| |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|)) (= (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@79|)) (|Seq#Index| (LinearSequence__i.__default.lseqs |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|)) (LitInt |i#0@@79|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3155|
 :pattern ( (LinearSequence__i.__default.operator_ksubscript_qlseq |LinearSequence_i._default.operator'subscript?lseq$A@@3| (Lit |s#0@@37|) (LitInt |i#0@@79|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A| T@U) (|s#0@@38| T@U) (|i#0@@80| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A|) TyType) (= (type |s#0@@38|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38| |i#0@@80|) (and (and ($IsBox |s#0@@38| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A|)) (INTERNAL_le_boogie 0 |i#0@@80|)) (INTERNAL_lt_boogie |i#0@@80| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38|))))) true)
 :qid |unknown.0:0|
 :skolemid |3156|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A| |s#0@@38| |i#0@@80|))
))))
(assert (forall ((|LinearSequence_i._default.operator'in?lseq$A@@0| T@U) (|s#0@@39| T@U) (|i#0@@81| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@0|) TyType) (= (type |s#0@@39|) BoxType)) (and ($IsBox |s#0@@39| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@0|)) (INTERNAL_le_boogie 0 |i#0@@81|))) (= (|LinearSequence__i.__default.operator_kin_qlseq#requires| |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39| |i#0@@81|) (INTERNAL_lt_boogie |i#0@@81| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39|))))
 :qid |unknown.0:0|
 :skolemid |3157|
 :pattern ( (|LinearSequence__i.__default.operator_kin_qlseq#requires| |LinearSequence_i._default.operator'in?lseq$A@@0| |s#0@@39| |i#0@@81|))
)))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@1| T@U) (|s#0@@40| T@U) (|i#0@@82| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@1|) TyType) (= (type |s#0@@40|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@82|) (and (and ($IsBox |s#0@@40| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@1|)) (INTERNAL_le_boogie 0 |i#0@@82|)) (INTERNAL_lt_boogie |i#0@@82| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@82|) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40|) |i#0@@82|))))))
 :qid |unknown.0:0|
 :skolemid |3158|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@1| |s#0@@40| |i#0@@82|))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@2| T@U) (|s#0@@41| T@U) (|i#0@@83| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@2|) TyType) (= (type |s#0@@41|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@83|)) (and (and ($IsBox |s#0@@41| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@2|)) (INTERNAL_le_boogie 0 |i#0@@83|)) (INTERNAL_lt_boogie |i#0@@83| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@83|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41|) (LitInt |i#0@@83|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3159|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@2| |s#0@@41| (LitInt |i#0@@83|)))
))))
(assert  (=> true (forall ((|LinearSequence_i._default.operator'in?lseq$A@@3| T@U) (|s#0@@42| T@U) (|i#0@@84| Int) ) (!  (=> (and (and (= (type |LinearSequence_i._default.operator'in?lseq$A@@3|) TyType) (= (type |s#0@@42|) BoxType)) (or (|LinearSequence__i.__default.operator_kin_qlseq#canCall| |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@84|)) (and (and ($IsBox |s#0@@42| (|#$lseq| |LinearSequence_i._default.operator'in?lseq$A@@3|)) (INTERNAL_le_boogie 0 |i#0@@84|)) (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie |i#0@@84| (LinearSequence__i.__default.operator_kcardinality_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|))))))))) (and (|LinearExtern.__default.lseq__has#canCall| |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|)) (= (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@84|)) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|))) (LitInt |i#0@@84|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3160|
 :pattern ( (LinearSequence__i.__default.operator_kin_qlseq |LinearSequence_i._default.operator'in?lseq$A@@3| (Lit |s#0@@42|) (LitInt |i#0@@84|)))
))))
(assert (forall ((arg0@@504 T@U) (arg1@@218 T@U) (arg2@@101 T@U) ) (! (= (type (LinearSequence__i.__default.lseq__add arg0@@504 arg1@@218 arg2@@101)) BoxType)
 :qid |funType:LinearSequence__i.__default.lseq__add|
 :pattern ( (LinearSequence__i.__default.lseq__add arg0@@504 arg1@@218 arg2@@101))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_add$A T@U) (|l#0@@19| T@U) (|r#0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_i._default.lseq_add$A) TyType) (= (type |l#0@@19|) BoxType)) (= (type |r#0|) BoxType)) (or (|LinearSequence__i.__default.lseq__add#canCall| LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|) (and ($IsBox |l#0@@19| (|#$lseq| LinearSequence_i._default.lseq_add$A)) ($IsBox |r#0| (|#$lseq| LinearSequence_i._default.lseq_add$A))))) ($IsBox (LinearSequence__i.__default.lseq__add LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|) (|#$lseq| LinearSequence_i._default.lseq_add$A)))
 :qid |unknown.0:0|
 :skolemid |3161|
 :pattern ( (LinearSequence__i.__default.lseq__add LinearSequence_i._default.lseq_add$A |l#0@@19| |r#0|))
))))
(assert (forall ((LinearSequence_i._default.lseq_add$A@@0 T@U) (|l#0@@20| T@U) (|r#0@@0| T@U) ) (!  (=> (and (and (and (= (type LinearSequence_i._default.lseq_add$A@@0) TyType) (= (type |l#0@@20|) BoxType)) (= (type |r#0@@0|) BoxType)) (and ($IsBox |l#0@@20| (|#$lseq| LinearSequence_i._default.lseq_add$A@@0)) ($IsBox |r#0@@0| (|#$lseq| LinearSequence_i._default.lseq_add$A@@0)))) (= (|LinearSequence__i.__default.lseq__add#requires| LinearSequence_i._default.lseq_add$A@@0 |l#0@@20| |r#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |3162|
 :pattern ( (|LinearSequence__i.__default.lseq__add#requires| LinearSequence_i._default.lseq_add$A@@0 |l#0@@20| |r#0@@0|))
)))
(assert (forall ((arg0@@505 T@U) (arg1@@219 T@U) (arg2@@102 Int) ) (! (= (type (LinearSequence__i.__default.lseq__peek arg0@@505 arg1@@219 arg2@@102)) BoxType)
 :qid |funType:LinearSequence__i.__default.lseq__peek|
 :pattern ( (LinearSequence__i.__default.lseq__peek arg0@@505 arg1@@219 arg2@@102))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_peek$A T@U) (|s#0@@43| T@U) (|i#0@@85| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_peek$A) TyType) (= (type |s#0@@43|) BoxType)) (or (|LinearSequence__i.__default.lseq__peek#canCall| LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@85|) (and (and ($IsBox |s#0@@43| (|#$lseq| LinearSequence_i._default.lseq_peek$A)) (and (INTERNAL_le_boogie 0 |i#0@@85|) (INTERNAL_lt_boogie |i#0@@85| 18446744073709551616))) (and (INTERNAL_lt_boogie |i#0@@85| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_peek$A |s#0@@43|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_peek$A |s#0@@43|) |i#0@@85|))))))) (and (= (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@85|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_peek$A |s#0@@43|) |i#0@@85|)) ($IsBox (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@85|) LinearSequence_i._default.lseq_peek$A)))
 :qid |unknown.0:0|
 :skolemid |3163|
 :pattern ( (LinearSequence__i.__default.lseq__peek LinearSequence_i._default.lseq_peek$A |s#0@@43| |i#0@@85|))
))))
(assert (forall ((LinearSequence_i._default.lseq_peek$A@@0 T@U) (|s#0@@44| T@U) (|i#0@@86| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_peek$A@@0) TyType) (= (type |s#0@@44|) BoxType)) (and ($IsBox |s#0@@44| (|#$lseq| LinearSequence_i._default.lseq_peek$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@86|) (INTERNAL_lt_boogie |i#0@@86| 18446744073709551616)))) (= (|LinearSequence__i.__default.lseq__peek#requires| LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44| |i#0@@86|)  (and (INTERNAL_lt_boogie |i#0@@86| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44|) |i#0@@86|))))))
 :qid |unknown.0:0|
 :skolemid |3164|
 :pattern ( (|LinearSequence__i.__default.lseq__peek#requires| LinearSequence_i._default.lseq_peek$A@@0 |s#0@@44| |i#0@@86|))
)))
(assert (forall ((arg0@@506 T@U) (arg1@@220 T@U) ) (! (= (type (LinearSequence__i.__default.lseq__free__fun arg0@@506 arg1@@220)) DatatypeTypeType)
 :qid |funType:LinearSequence__i.__default.lseq__free__fun|
 :pattern ( (LinearSequence__i.__default.lseq__free__fun arg0@@506 arg1@@220))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_free_fun$A T@U) (|s#0@@45| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_free_fun$A) TyType) (= (type |s#0@@45|) BoxType)) (or (|LinearSequence__i.__default.lseq__free__fun#canCall| LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) (and ($IsBox |s#0@@45| (|#$lseq| LinearSequence_i._default.lseq_free_fun$A)) (forall ((|i#0@@87| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@87|) (INTERNAL_lt_boogie |i#0@@87| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_free_fun$A |s#0@@45|))) (not (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) |i#0@@87|)))))
 :qid |LinearSequenceidfy.147:23|
 :skolemid |3170|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) |i#0@@87|)))
))))) ($Is (LinearSequence__i.__default.lseq__free__fun LinearSequence_i._default.lseq_free_fun$A |s#0@@45|) Tclass._System.Tuple0))
 :qid |unknown.0:0|
 :skolemid |3171|
 :pattern ( (LinearSequence__i.__default.lseq__free__fun LinearSequence_i._default.lseq_free_fun$A |s#0@@45|))
))))
(assert (forall ((LinearSequence_i._default.lseq_free_fun$A@@0 T@U) (|s#0@@46| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_free_fun$A@@0) TyType) (= (type |s#0@@46|) BoxType)) ($IsBox |s#0@@46| (|#$lseq| LinearSequence_i._default.lseq_free_fun$A@@0))) (= (|LinearSequence__i.__default.lseq__free__fun#requires| LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) (forall ((|i#1@@18| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@18|) (INTERNAL_lt_boogie |i#1@@18| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|))) (not (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) |i#1@@18|)))))
 :qid |LinearSequenceidfy.147:23|
 :skolemid |3172|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|) |i#1@@18|)))
))))
 :qid |unknown.0:0|
 :skolemid |3173|
 :pattern ( (|LinearSequence__i.__default.lseq__free__fun#requires| LinearSequence_i._default.lseq_free_fun$A@@0 |s#0@@46|))
)))
(assert (forall ((arg0@@507 T@U) (arg1@@221 T@U) (arg2@@103 Int) ) (! (= (type (LinearSequence__i.__default.lseq__take__fun arg0@@507 arg1@@221 arg2@@103)) DatatypeTypeType)
 :qid |funType:LinearSequence__i.__default.lseq__take__fun|
 :pattern ( (LinearSequence__i.__default.lseq__take__fun arg0@@507 arg1@@221 arg2@@103))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_take_fun$A T@U) (|s1#0@@5| T@U) (|i#0@@88| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_take_fun$A) TyType) (= (type |s1#0@@5|) BoxType)) (or (|LinearSequence__i.__default.lseq__take__fun#canCall| LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|) (and (and ($IsBox |s1#0@@5| (|#$lseq| LinearSequence_i._default.lseq_take_fun$A)) (and (INTERNAL_le_boogie 0 |i#0@@88|) (INTERNAL_lt_boogie |i#0@@88| 18446744073709551616))) (and (INTERNAL_lt_boogie |i#0@@88| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@88|))))))) (and (and (and (= (_System.Tuple2OLL._1 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|)) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@88|)) (|Seq#Equal| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|))) (|Seq#Update| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |i#0@@88| ($Box (Lit (bool_2_U false)))))) (forall ((|j#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |j#0|) (and (INTERNAL_lt_boogie |j#0| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|)) (not (= |j#0| |i#0@@88|)))) (= (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|))) |j#0|) (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |j#0|)))
 :qid |LinearSequenceidfy.200:22|
 :skolemid |3182|
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A |s1#0@@5|) |j#0|))
 :pattern ( (|Seq#Index| (LinearSequence__i.__default.lseqs LinearSequence_i._default.lseq_take_fun$A (_System.Tuple2OLL._0 (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|))) |j#0|))
))) ($Is (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|) (Tclass._System.Tuple2OLL (|#$lseq| LinearSequence_i._default.lseq_take_fun$A) LinearSequence_i._default.lseq_take_fun$A))))
 :qid |unknown.0:0|
 :skolemid |3183|
 :pattern ( (LinearSequence__i.__default.lseq__take__fun LinearSequence_i._default.lseq_take_fun$A |s1#0@@5| |i#0@@88|))
))))
(assert (forall ((LinearSequence_i._default.lseq_take_fun$A@@0 T@U) (|s1#0@@6| T@U) (|i#0@@89| Int) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_take_fun$A@@0) TyType) (= (type |s1#0@@6|) BoxType)) (and ($IsBox |s1#0@@6| (|#$lseq| LinearSequence_i._default.lseq_take_fun$A@@0)) (and (INTERNAL_le_boogie 0 |i#0@@89|) (INTERNAL_lt_boogie |i#0@@89| 18446744073709551616)))) (= (|LinearSequence__i.__default.lseq__take__fun#requires| LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6| |i#0@@89|)  (and (INTERNAL_lt_boogie |i#0@@89| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6|)) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6|) |i#0@@89|))))))
 :qid |unknown.0:0|
 :skolemid |3184|
 :pattern ( (|LinearSequence__i.__default.lseq__take__fun#requires| LinearSequence_i._default.lseq_take_fun$A@@0 |s1#0@@6| |i#0@@89|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A T@U) (|s#0@@47| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A) TyType) (= (type |s#0@@47|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A |s#0@@47|) ($IsBox |s#0@@47| (|#$lseq| LinearSequence_i._default.lseq_full$A)))) true)
 :qid |unknown.0:0|
 :skolemid |3187|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A |s#0@@47|))
))))
(assert (forall ((LinearSequence_i._default.lseq_full$A@@0 T@U) (|s#0@@48| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@0) TyType) (= (type |s#0@@48|) BoxType)) ($IsBox |s#0@@48| (|#$lseq| LinearSequence_i._default.lseq_full$A@@0))) (= (|LinearSequence__i.__default.lseq__full#requires| LinearSequence_i._default.lseq_full$A@@0 |s#0@@48|) true))
 :qid |unknown.0:0|
 :skolemid |3188|
 :pattern ( (|LinearSequence__i.__default.lseq__full#requires| LinearSequence_i._default.lseq_full$A@@0 |s#0@@48|))
)))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A@@1 T@U) (|s#0@@49| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@1) TyType) (= (type |s#0@@49|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) ($IsBox |s#0@@49| (|#$lseq| LinearSequence_i._default.lseq_full$A@@1)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@90| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@90|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|)) (=> (and (INTERNAL_le_boogie 0 |i#0@@90|) (INTERNAL_lt_boogie |i#0@@90| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))) (|LinearSequence__i.__default.operator_kin_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@1 |s#0@@49| |i#0@@90|)))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |3190|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@90|)))
))) (= (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|)  (and true (forall ((|i#0@@91| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@91|) (INTERNAL_lt_boogie |i#0@@91| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))) (U_2_bool ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@91|))))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |3189|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|) |i#0@@91|)))
))))))
 :qid |unknown.0:0|
 :skolemid |3191|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@1 |s#0@@49|))
))))
(assert  (=> true (forall ((LinearSequence_i._default.lseq_full$A@@2 T@U) (|s#0@@50| T@U) ) (!  (=> (and (and (= (type LinearSequence_i._default.lseq_full$A@@2) TyType) (= (type |s#0@@50|) BoxType)) (or (|LinearSequence__i.__default.lseq__full#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)) ($IsBox |s#0@@50| (|#$lseq| LinearSequence_i._default.lseq_full$A@@2)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@19| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#1@@19|) (|LinearSequence__i.__default.operator_kcardinality_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))) (=> (and (INTERNAL_le_boogie 0 |i#1@@19|) (INTERNAL_lt_boogie |i#1@@19| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))) (|LinearSequence__i.__default.operator_kin_qlseq#canCall| LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|) |i#1@@19|)))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |3193|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 |s#0@@50|) |i#1@@19|)))
))) (= (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))  (and true (forall ((|i#1@@20| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@20|) (INTERNAL_lt_boogie |i#1@@20| (LinearSequence__i.__default.operator_kcardinality_qlseq LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))) (U_2_bool ($Unbox boolType (|Seq#Index| (Lit (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|))) |i#1@@20|))))
 :qid |LinearSequenceidfy.231:18|
 :skolemid |3192|
 :pattern ( ($Unbox boolType (|Seq#Index| (LinearExtern.__default.lseq__has LinearSequence_i._default.lseq_full$A@@2 |s#0@@50|) |i#1@@20|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3194|
 :pattern ( (LinearSequence__i.__default.lseq__full LinearSequence_i._default.lseq_full$A@@2 (Lit |s#0@@50|)))
))))
(assert (= (type Tclass.Sequences.__default) TyType))
(assert (= (Tag Tclass.Sequences.__default) Tagclass.Sequences.__default))
(assert (= (TagFamily Tclass.Sequences.__default) tytagFamily$_default))
(assert (forall ((bx@@152 T@U) ) (!  (=> (and (= (type bx@@152) BoxType) ($IsBox bx@@152 Tclass.Sequences.__default)) (and (= ($Box ($Unbox refType bx@@152)) bx@@152) ($Is ($Unbox refType bx@@152) Tclass.Sequences.__default)))
 :qid |unknown.0:0|
 :skolemid |3228|
 :pattern ( ($IsBox bx@@152 Tclass.Sequences.__default))
)))
(assert (forall (($o@@39 T@U) ) (!  (=> (= (type $o@@39) refType) (= ($Is $o@@39 Tclass.Sequences.__default)  (or (= $o@@39 null) (= (dtype $o@@39) Tclass.Sequences.__default))))
 :qid |unknown.0:0|
 :skolemid |3229|
 :pattern ( ($Is $o@@39 Tclass.Sequences.__default))
)))
(assert (forall (($o@@40 T@U) ($h@@137 T@U) ) (!  (=> (and (= (type $o@@40) refType) (= (type $h@@137) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@40 Tclass.Sequences.__default $h@@137)  (or (= $o@@40 null) (U_2_bool (MapType1Select (MapType0Select $h@@137 $o@@40) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3230|
 :pattern ( ($IsAlloc $o@@40 Tclass.Sequences.__default $h@@137))
)))
(assert  (=> true (forall ((Sequences._default.Last$E T@U) (|run#0@@7| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E) TyType) (= (type |run#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E |run#0@@7|) (and ($Is |run#0@@7| (TSeq Sequences._default.Last$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@7|) 0)))) ($IsBox (Sequences.__default.Last Sequences._default.Last$E |run#0@@7|) Sequences._default.Last$E))
 :qid |unknown.0:0|
 :skolemid |3231|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E |run#0@@7|))
))))
(assert (forall ((Sequences._default.Last$E@@0 T@U) (|run#0@@8| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@0) TyType) (= (type |run#0@@8|) (SeqType BoxType))) ($Is |run#0@@8| (TSeq Sequences._default.Last$E@@0))) (= (|Sequences.__default.Last#requires| Sequences._default.Last$E@@0 |run#0@@8|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@8|) 0)))
 :qid |unknown.0:0|
 :skolemid |3232|
 :pattern ( (|Sequences.__default.Last#requires| Sequences._default.Last$E@@0 |run#0@@8|))
)))
(assert  (=> true (forall ((Sequences._default.Last$E@@1 T@U) (|run#0@@9| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@1) TyType) (= (type |run#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E@@1 |run#0@@9|) (and ($Is |run#0@@9| (TSeq Sequences._default.Last$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@9|) 0)))) (= (Sequences.__default.Last Sequences._default.Last$E@@1 |run#0@@9|) (|Seq#Index| |run#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@9|) 1))))
 :qid |unknown.0:0|
 :skolemid |3233|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E@@1 |run#0@@9|))
))))
(assert  (=> true (forall ((Sequences._default.Last$E@@2 T@U) (|run#0@@10| T@U) ) (!  (=> (and (and (= (type Sequences._default.Last$E@@2) TyType) (= (type |run#0@@10|) (SeqType BoxType))) (or (|Sequences.__default.Last#canCall| Sequences._default.Last$E@@2 (Lit |run#0@@10|)) (and ($Is |run#0@@10| (TSeq Sequences._default.Last$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@10|)) 0)))) (= (Sequences.__default.Last Sequences._default.Last$E@@2 (Lit |run#0@@10|)) (|Seq#Index| (Lit |run#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@10|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3234|
 :pattern ( (Sequences.__default.Last Sequences._default.Last$E@@2 (Lit |run#0@@10|)))
))))
(assert (forall ((arg0@@508 T@U) (arg1@@222 T@U) ) (! (= (type (Sequences.__default.FirstOpt arg0@@508 arg1@@222)) DatatypeTypeType)
 :qid |funType:Sequences.__default.FirstOpt|
 :pattern ( (Sequences.__default.FirstOpt arg0@@508 arg1@@222))
)))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E T@U) (|run#0@@11| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E) TyType) (= (type |run#0@@11|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E |run#0@@11|) ($Is |run#0@@11| (TSeq Sequences._default.FirstOpt$E)))) ($Is (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E |run#0@@11|) (Tclass.Options.Option Sequences._default.FirstOpt$E)))
 :qid |unknown.0:0|
 :skolemid |3235|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E |run#0@@11|))
))))
(assert (forall ((Sequences._default.FirstOpt$E@@0 T@U) (|run#0@@12| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@0) TyType) (= (type |run#0@@12|) (SeqType BoxType))) ($Is |run#0@@12| (TSeq Sequences._default.FirstOpt$E@@0))) (= (|Sequences.__default.FirstOpt#requires| Sequences._default.FirstOpt$E@@0 |run#0@@12|) true))
 :qid |unknown.0:0|
 :skolemid |3236|
 :pattern ( (|Sequences.__default.FirstOpt#requires| Sequences._default.FirstOpt$E@@0 |run#0@@12|))
)))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E@@1 T@U) (|run#0@@13| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@1) TyType) (= (type |run#0@@13|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E@@1 |run#0@@13|) ($Is |run#0@@13| (TSeq Sequences._default.FirstOpt$E@@1)))) (= (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@1 |run#0@@13|) (ite (= (|Seq#Length| |run#0@@13|) (LitInt 0)) |#Options.Option.None| (|#Options.Option.Some| (|Seq#Index| |run#0@@13| (LitInt 0))))))
 :qid |unknown.0:0|
 :skolemid |3237|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@1 |run#0@@13|))
))))
(assert  (=> true (forall ((Sequences._default.FirstOpt$E@@2 T@U) (|run#0@@14| T@U) ) (!  (=> (and (and (= (type Sequences._default.FirstOpt$E@@2) TyType) (= (type |run#0@@14|) (SeqType BoxType))) (or (|Sequences.__default.FirstOpt#canCall| Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)) ($Is |run#0@@14| (TSeq Sequences._default.FirstOpt$E@@2)))) (= (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)) (ite (= (|Seq#Length| (Lit |run#0@@14|)) (LitInt 0)) |#Options.Option.None| (|#Options.Option.Some| (|Seq#Index| (Lit |run#0@@14|) (LitInt 0))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3238|
 :pattern ( (Sequences.__default.FirstOpt Sequences._default.FirstOpt$E@@2 (Lit |run#0@@14|)))
))))
(assert (forall ((arg0@@509 T@U) (arg1@@223 T@U) ) (! (= (type (Sequences.__default.DropLast arg0@@509 arg1@@223)) (SeqType BoxType))
 :qid |funType:Sequences.__default.DropLast|
 :pattern ( (Sequences.__default.DropLast arg0@@509 arg1@@223))
)))
(assert  (=> true (forall ((Sequences._default.DropLast$E T@U) (|run#0@@15| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E) TyType) (= (type |run#0@@15|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E |run#0@@15|) (and ($Is |run#0@@15| (TSeq Sequences._default.DropLast$E)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@15|) 0)))) ($Is (Sequences.__default.DropLast Sequences._default.DropLast$E |run#0@@15|) (TSeq Sequences._default.DropLast$E)))
 :qid |unknown.0:0|
 :skolemid |3239|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E |run#0@@15|))
))))
(assert (forall ((Sequences._default.DropLast$E@@0 T@U) (|run#0@@16| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@0) TyType) (= (type |run#0@@16|) (SeqType BoxType))) ($Is |run#0@@16| (TSeq Sequences._default.DropLast$E@@0))) (= (|Sequences.__default.DropLast#requires| Sequences._default.DropLast$E@@0 |run#0@@16|) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@16|) 0)))
 :qid |unknown.0:0|
 :skolemid |3240|
 :pattern ( (|Sequences.__default.DropLast#requires| Sequences._default.DropLast$E@@0 |run#0@@16|))
)))
(assert  (=> true (forall ((Sequences._default.DropLast$E@@1 T@U) (|run#0@@17| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@1) TyType) (= (type |run#0@@17|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E@@1 |run#0@@17|) (and ($Is |run#0@@17| (TSeq Sequences._default.DropLast$E@@1)) (INTERNAL_gt_boogie (|Seq#Length| |run#0@@17|) 0)))) (= (Sequences.__default.DropLast Sequences._default.DropLast$E@@1 |run#0@@17|) (|Seq#Take| |run#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |run#0@@17|) 1))))
 :qid |unknown.0:0|
 :skolemid |3241|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E@@1 |run#0@@17|))
))))
(assert  (=> true (forall ((Sequences._default.DropLast$E@@2 T@U) (|run#0@@18| T@U) ) (!  (=> (and (and (= (type Sequences._default.DropLast$E@@2) TyType) (= (type |run#0@@18|) (SeqType BoxType))) (or (|Sequences.__default.DropLast#canCall| Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)) (and ($Is |run#0@@18| (TSeq Sequences._default.DropLast$E@@2)) (INTERNAL_gt_boogie (|Seq#Length| (Lit |run#0@@18|)) 0)))) (= (Sequences.__default.DropLast Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)) (|Seq#Take| (Lit |run#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |run#0@@18|)) 1))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3242|
 :pattern ( (Sequences.__default.DropLast Sequences._default.DropLast$E@@2 (Lit |run#0@@18|)))
))))
(assert (forall ((arg0@@510 T@U) (arg1@@224 T@U) ) (! (= (type (Sequences.__default.Set arg0@@510 arg1@@224)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.Set|
 :pattern ( (Sequences.__default.Set arg0@@510 arg1@@224))
)))
(assert  (=> true (forall ((Sequences._default.Set$T T@U) (|run#0@@19| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T) TyType) (= (type |run#0@@19|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T |run#0@@19|) ($Is |run#0@@19| (TSeq Sequences._default.Set$T)))) ($Is (Sequences.__default.Set Sequences._default.Set$T |run#0@@19|) (TSet Sequences._default.Set$T)))
 :qid |unknown.0:0|
 :skolemid |3243|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T |run#0@@19|))
))))
(assert (forall ((Sequences._default.Set$T@@0 T@U) (|run#0@@20| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@0) TyType) (= (type |run#0@@20|) (SeqType BoxType))) ($Is |run#0@@20| (TSeq Sequences._default.Set$T@@0))) (= (|Sequences.__default.Set#requires| Sequences._default.Set$T@@0 |run#0@@20|) true))
 :qid |unknown.0:0|
 :skolemid |3244|
 :pattern ( (|Sequences.__default.Set#requires| Sequences._default.Set$T@@0 |run#0@@20|))
)))
(assert  (=> true (forall ((Sequences._default.Set$T@@1 T@U) (|run#0@@21| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@1) TyType) (= (type |run#0@@21|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T@@1 |run#0@@21|) ($Is |run#0@@21| (TSeq Sequences._default.Set$T@@1)))) (= (Sequences.__default.Set Sequences._default.Set$T@@1 |run#0@@21|) (|lambda#141| Sequences._default.Set$T@@1 (|MultiSet#FromSeq| |run#0@@21|) 0)))
 :qid |unknown.0:0|
 :skolemid |3245|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T@@1 |run#0@@21|))
))))
(assert  (=> true (forall ((Sequences._default.Set$T@@2 T@U) (|run#0@@22| T@U) ) (!  (=> (and (and (= (type Sequences._default.Set$T@@2) TyType) (= (type |run#0@@22|) (SeqType BoxType))) (or (|Sequences.__default.Set#canCall| Sequences._default.Set$T@@2 (Lit |run#0@@22|)) ($Is |run#0@@22| (TSeq Sequences._default.Set$T@@2)))) (= (Sequences.__default.Set Sequences._default.Set$T@@2 (Lit |run#0@@22|)) (|lambda#141| Sequences._default.Set$T@@2 (|MultiSet#FromSeq| (Lit |run#0@@22|)) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3246|
 :pattern ( (Sequences.__default.Set Sequences._default.Set$T@@2 (Lit |run#0@@22|)))
))))
(assert (forall ((arg0@@511 T@U) (arg1@@225 T@U) ) (! (= (type (Sequences.__default.ISet arg0@@511 arg1@@225)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.ISet|
 :pattern ( (Sequences.__default.ISet arg0@@511 arg1@@225))
)))
(assert  (=> true (forall ((Sequences._default.ISet$T T@U) (|run#0@@23| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T) TyType) (= (type |run#0@@23|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T |run#0@@23|) ($Is |run#0@@23| (TSeq Sequences._default.ISet$T)))) ($Is (Sequences.__default.ISet Sequences._default.ISet$T |run#0@@23|) (TISet Sequences._default.ISet$T)))
 :qid |unknown.0:0|
 :skolemid |3247|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T |run#0@@23|))
))))
(assert (forall ((Sequences._default.ISet$T@@0 T@U) (|run#0@@24| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@0) TyType) (= (type |run#0@@24|) (SeqType BoxType))) ($Is |run#0@@24| (TSeq Sequences._default.ISet$T@@0))) (= (|Sequences.__default.ISet#requires| Sequences._default.ISet$T@@0 |run#0@@24|) true))
 :qid |unknown.0:0|
 :skolemid |3248|
 :pattern ( (|Sequences.__default.ISet#requires| Sequences._default.ISet$T@@0 |run#0@@24|))
)))
(assert  (=> true (forall ((Sequences._default.ISet$T@@1 T@U) (|run#0@@25| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@1) TyType) (= (type |run#0@@25|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T@@1 |run#0@@25|) ($Is |run#0@@25| (TSeq Sequences._default.ISet$T@@1)))) (= (Sequences.__default.ISet Sequences._default.ISet$T@@1 |run#0@@25|) (|lambda#141| Sequences._default.ISet$T@@1 (|MultiSet#FromSeq| |run#0@@25|) 0)))
 :qid |unknown.0:0|
 :skolemid |3249|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T@@1 |run#0@@25|))
))))
(assert  (=> true (forall ((Sequences._default.ISet$T@@2 T@U) (|run#0@@26| T@U) ) (!  (=> (and (and (= (type Sequences._default.ISet$T@@2) TyType) (= (type |run#0@@26|) (SeqType BoxType))) (or (|Sequences.__default.ISet#canCall| Sequences._default.ISet$T@@2 (Lit |run#0@@26|)) ($Is |run#0@@26| (TSeq Sequences._default.ISet$T@@2)))) (= (Sequences.__default.ISet Sequences._default.ISet$T@@2 (Lit |run#0@@26|)) (|lambda#141| Sequences._default.ISet$T@@2 (|MultiSet#FromSeq| (Lit |run#0@@26|)) 0)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3250|
 :pattern ( (Sequences.__default.ISet Sequences._default.ISet$T@@2 (Lit |run#0@@26|)))
))))
(assert (forall ((Sequences._default.NoDupes$T T@U) ($ly@@41 T@U) (|a#0@@21| T@U) ) (!  (=> (and (and (= (type Sequences._default.NoDupes$T) TyType) (= (type $ly@@41) LayerTypeType)) (= (type |a#0@@21|) (SeqType BoxType))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T ($LS $ly@@41) |a#0@@21|) (Sequences.__default.NoDupes Sequences._default.NoDupes$T $ly@@41 |a#0@@21|)))
 :qid |unknown.0:0|
 :skolemid |3251|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T ($LS $ly@@41) |a#0@@21|))
)))
(assert (forall ((Sequences._default.NoDupes$T@@0 T@U) ($ly@@42 T@U) (|a#0@@22| T@U) ) (!  (=> (and (and (= (type Sequences._default.NoDupes$T@@0) TyType) (= (type $ly@@42) LayerTypeType)) (= (type |a#0@@22|) (SeqType BoxType))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 $ly@@42 |a#0@@22|) (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 $LZ |a#0@@22|)))
 :qid |unknown.0:0|
 :skolemid |3252|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@0 (AsFuelBottom $ly@@42) |a#0@@22|))
)))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@1 T@U) ($ly@@43 T@U) (|a#0@@23| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@1) TyType) (= (type $ly@@43) LayerTypeType)) (= (type |a#0@@23|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@1 |a#0@@23|) ($Is |a#0@@23| (TSeq Sequences._default.NoDupes$T@@1)))) true)
 :qid |unknown.0:0|
 :skolemid |3253|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@1 $ly@@43 |a#0@@23|))
))))
(assert (forall ((Sequences._default.NoDupes$T@@2 T@U) ($ly@@44 T@U) (|a#0@@24| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@2) TyType) (= (type $ly@@44) LayerTypeType)) (= (type |a#0@@24|) (SeqType BoxType))) ($Is |a#0@@24| (TSeq Sequences._default.NoDupes$T@@2))) (= (|Sequences.__default.NoDupes#requires| Sequences._default.NoDupes$T@@2 $ly@@44 |a#0@@24|) true))
 :qid |unknown.0:0|
 :skolemid |3254|
 :pattern ( (|Sequences.__default.NoDupes#requires| Sequences._default.NoDupes$T@@2 $ly@@44 |a#0@@24|))
)))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@3 T@U) ($ly@@45 T@U) (|a#0@@25| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@3) TyType) (= (type $ly@@45) LayerTypeType)) (= (type |a#0@@25|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@3 |a#0@@25|) ($Is |a#0@@25| (TSeq Sequences._default.NoDupes$T@@3)))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@3 ($LS $ly@@45) |a#0@@25|) (forall ((|i#0@@92| Int) (|j#0@@0| Int) ) (!  (=> true (=> (and (and (and (INTERNAL_le_boogie 0 |i#0@@92|) (INTERNAL_lt_boogie |i#0@@92| (|Seq#Length| |a#0@@25|))) (and (INTERNAL_le_boogie 0 |j#0@@0|) (INTERNAL_lt_boogie |j#0@@0| (|Seq#Length| |a#0@@25|)))) (not (= |i#0@@92| |j#0@@0|))) (not (= (|Seq#Index| |a#0@@25| |i#0@@92|) (|Seq#Index| |a#0@@25| |j#0@@0|)))))
 :qid |Sequencesidfy.70:13|
 :skolemid |3255|
 :pattern ( (|Seq#Index| |a#0@@25| |j#0@@0|) (|Seq#Index| |a#0@@25| |i#0@@92|))
))))
 :qid |unknown.0:0|
 :skolemid |3256|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@3 ($LS $ly@@45) |a#0@@25|))
))))
(assert  (=> true (forall ((Sequences._default.NoDupes$T@@4 T@U) ($ly@@46 T@U) (|a#0@@26| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.NoDupes$T@@4) TyType) (= (type $ly@@46) LayerTypeType)) (= (type |a#0@@26|) (SeqType BoxType))) (or (|Sequences.__default.NoDupes#canCall| Sequences._default.NoDupes$T@@4 (Lit |a#0@@26|)) ($Is |a#0@@26| (TSeq Sequences._default.NoDupes$T@@4)))) (= (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@4 ($LS $ly@@46) (Lit |a#0@@26|)) (forall ((|i#1@@21| Int) (|j#1| Int) ) (!  (=> true (=> (and (and (and (INTERNAL_le_boogie 0 |i#1@@21|) (INTERNAL_lt_boogie |i#1@@21| (|Seq#Length| (Lit |a#0@@26|)))) (and (INTERNAL_le_boogie 0 |j#1|) (INTERNAL_lt_boogie |j#1| (|Seq#Length| (Lit |a#0@@26|))))) (not (= |i#1@@21| |j#1|))) (not (= (|Seq#Index| (Lit |a#0@@26|) |i#1@@21|) (|Seq#Index| (Lit |a#0@@26|) |j#1|)))))
 :qid |Sequencesidfy.70:13|
 :skolemid |3257|
 :pattern ( (|Seq#Index| |a#0@@26| |j#1|) (|Seq#Index| |a#0@@26| |i#1@@21|))
))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3258|
 :pattern ( (Sequences.__default.NoDupes Sequences._default.NoDupes$T@@4 ($LS $ly@@46) (Lit |a#0@@26|)))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T T@U) (|s#0@@51| T@U) (|e#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IndexOf$T) TyType) (= (type |s#0@@51|) (SeqType BoxType))) (= (type |e#0|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T |s#0@@51| |e#0|) (and (and ($Is |s#0@@51| (TSeq Sequences._default.IndexOf$T)) ($IsBox |e#0| Sequences._default.IndexOf$T)) (|Seq#Contains| |s#0@@51| |e#0|)))) (and (and (INTERNAL_le_boogie 0 (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|)) (INTERNAL_lt_boogie (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|) (|Seq#Length| |s#0@@51|))) (= (|Seq#Index| |s#0@@51| (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|)) |e#0|)))
 :qid |unknown.0:0|
 :skolemid |3259|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T |s#0@@51| |e#0|))
))))
(assert (forall ((Sequences._default.IndexOf$T@@0 T@U) ($Heap@@15 T@U) (|s#0@@52| T@U) (|e#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@0) TyType) (= (type $Heap@@15) (MapType0Type refType MapType1Type))) (= (type |s#0@@52|) (SeqType BoxType))) (= (type |e#0@@0|) BoxType)) (and (and ($IsGoodHeap $Heap@@15) ($Is |s#0@@52| (TSeq Sequences._default.IndexOf$T@@0))) ($IsBox |e#0@@0| Sequences._default.IndexOf$T@@0))) (= (|Sequences.__default.IndexOf#requires| Sequences._default.IndexOf$T@@0 |s#0@@52| |e#0@@0|) (|Seq#Contains| |s#0@@52| |e#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3260|
 :pattern ( (|Sequences.__default.IndexOf#requires| Sequences._default.IndexOf$T@@0 |s#0@@52| |e#0@@0|) ($IsGoodHeap $Heap@@15))
)))
(assert (forall ((Sequences._default.IndexOf$T@@1 T@U) (s@@49 T@U) (e T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IndexOf$T@@1) TyType) (= (type s@@49) (SeqType BoxType))) (= (type e) BoxType)) (|$let#0$canCall| Sequences._default.IndexOf$T@@1 s@@49 e)) (and (and (INTERNAL_le_boogie 0 (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e)) (INTERNAL_lt_boogie (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e) (|Seq#Length| s@@49))) (= (|Seq#Index| s@@49 (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e)) e)))
 :qid |Sequencesidfy.121:5|
 :skolemid |3261|
 :pattern ( (|$let#0_i| Sequences._default.IndexOf$T@@1 s@@49 e))
)))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@2 T@U) ($Heap@@16 T@U) (|s#0@@53| T@U) (|e#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@2) TyType) (= (type $Heap@@16) (MapType0Type refType MapType1Type))) (= (type |s#0@@53|) (SeqType BoxType))) (= (type |e#0@@1|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (and (and (and ($IsGoodHeap $Heap@@16) ($Is |s#0@@53| (TSeq Sequences._default.IndexOf$T@@2))) ($IsBox |e#0@@1| Sequences._default.IndexOf$T@@2)) (|Seq#Contains| |s#0@@53| |e#0@@1|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) (let ((|i#0@@93| (|$let#0_i| Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|)))
|i#0@@93|))))
 :qid |unknown.0:0|
 :skolemid |3262|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@2 |s#0@@53| |e#0@@1|) ($IsGoodHeap $Heap@@16))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@3 T@U) ($Heap@@17 T@U) (|s#0@@54| T@U) (|e#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@3) TyType) (= (type $Heap@@17) (MapType0Type refType MapType1Type))) (= (type |s#0@@54|) (SeqType BoxType))) (= (type |e#0@@2|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (and (and (and ($IsGoodHeap $Heap@@17) ($Is |s#0@@54| (TSeq Sequences._default.IndexOf$T@@3))) ($IsBox |e#0@@2| Sequences._default.IndexOf$T@@3)) (|Seq#Contains| |s#0@@54| |e#0@@2|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) (let ((|i#1@@22| (|$let#0_i| Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|)))
|i#1@@22|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3263|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@3 (Lit |s#0@@54|) |e#0@@2|) ($IsGoodHeap $Heap@@17))
))))
(assert  (=> true (forall ((Sequences._default.IndexOf$T@@4 T@U) ($Heap@@18 T@U) (|s#0@@55| T@U) (|e#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IndexOf$T@@4) TyType) (= (type $Heap@@18) (MapType0Type refType MapType1Type))) (= (type |s#0@@55|) (SeqType BoxType))) (= (type |e#0@@3|) BoxType)) (or (|Sequences.__default.IndexOf#canCall| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (and (and (and ($IsGoodHeap $Heap@@18) ($Is |s#0@@55| (TSeq Sequences._default.IndexOf$T@@4))) ($IsBox |e#0@@3| Sequences._default.IndexOf$T@@4)) (|Seq#Contains| |s#0@@55| |e#0@@3|)))) (and (|$let#0$canCall| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (= (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) (let ((|i#2@@5| (|$let#0_i| Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|))))
|i#2@@5|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3264|
 :pattern ( (Sequences.__default.IndexOf Sequences._default.IndexOf$T@@4 (Lit |s#0@@55|) (Lit |e#0@@3|)) ($IsGoodHeap $Heap@@18))
))))
(assert (forall ((arg0@@512 T@U) (arg1@@226 Int) ) (! (= (type (Sequences.__default.Range arg0@@512 arg1@@226)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Range|
 :pattern ( (Sequences.__default.Range arg0@@512 arg1@@226))
)))
(assert (forall (($ly@@47 T@U) (|n#0| Int) ) (!  (=> (= (type $ly@@47) LayerTypeType) (= (Sequences.__default.Range ($LS $ly@@47) |n#0|) (Sequences.__default.Range $ly@@47 |n#0|)))
 :qid |Sequencesidfy.125:22|
 :skolemid |3265|
 :pattern ( (Sequences.__default.Range ($LS $ly@@47) |n#0|))
)))
(assert (forall (($ly@@48 T@U) (|n#0@@0| Int) ) (!  (=> (= (type $ly@@48) LayerTypeType) (= (Sequences.__default.Range $ly@@48 |n#0@@0|) (Sequences.__default.Range $LZ |n#0@@0|)))
 :qid |Sequencesidfy.125:22|
 :skolemid |3266|
 :pattern ( (Sequences.__default.Range (AsFuelBottom $ly@@48) |n#0@@0|))
)))
(assert  (=> true (forall (($ly@@49 T@U) (|n#0@@1| Int) ) (!  (=> (and (= (type $ly@@49) LayerTypeType) (or (|Sequences.__default.Range#canCall| |n#0@@1|) (INTERNAL_ge_boogie |n#0@@1| 0))) (and (and (= (|Seq#Length| (Sequences.__default.Range $ly@@49 |n#0@@1|)) |n#0@@1|) (forall ((|i#0@@94| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@94|) (INTERNAL_lt_boogie |i#0@@94| |n#0@@1|)) (= (U_2_int ($Unbox intType (|Seq#Index| (Sequences.__default.Range $ly@@49 |n#0@@1|) |i#0@@94|))) |i#0@@94|))
 :qid |Sequencesidfy.128:20|
 :skolemid |3267|
 :pattern ( ($Unbox intType (|Seq#Index| (Sequences.__default.Range $ly@@49 |n#0@@1|) |i#0@@94|)))
))) ($Is (Sequences.__default.Range $ly@@49 |n#0@@1|) (TSeq TInt))))
 :qid |Sequencesidfy.125:22|
 :skolemid |3268|
 :pattern ( (Sequences.__default.Range $ly@@49 |n#0@@1|))
))))
(assert (forall (($ly@@50 T@U) (|n#0@@2| Int) ) (!  (=> (= (type $ly@@50) LayerTypeType) (= (|Sequences.__default.Range#requires| $ly@@50 |n#0@@2|) (INTERNAL_ge_boogie |n#0@@2| 0)))
 :qid |Sequencesidfy.125:22|
 :skolemid |3269|
 :pattern ( (|Sequences.__default.Range#requires| $ly@@50 |n#0@@2|))
)))
(assert  (=> true (forall (($ly@@51 T@U) (|n#0@@3| Int) ) (!  (=> (and (= (type $ly@@51) LayerTypeType) (or (|Sequences.__default.Range#canCall| |n#0@@3|) (INTERNAL_ge_boogie |n#0@@3| 0))) (and (=> (not (= |n#0@@3| (LitInt 0))) (|Sequences.__default.Range#canCall| (INTERNAL_sub_boogie |n#0@@3| 1))) (= (Sequences.__default.Range ($LS $ly@@51) |n#0@@3|) (ite (= |n#0@@3| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Range $ly@@51 (INTERNAL_sub_boogie |n#0@@3| 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (INTERNAL_sub_boogie |n#0@@3| 1)))))))))
 :qid |Sequencesidfy.125:22|
 :skolemid |3270|
 :pattern ( (Sequences.__default.Range ($LS $ly@@51) |n#0@@3|))
))))
(assert  (=> true (forall (($ly@@52 T@U) (|n#0@@4| Int) ) (!  (=> (and (= (type $ly@@52) LayerTypeType) (or (|Sequences.__default.Range#canCall| (LitInt |n#0@@4|)) (INTERNAL_ge_boogie |n#0@@4| 0))) (and (=> (not (= (LitInt |n#0@@4|) (LitInt 0))) (|Sequences.__default.Range#canCall| (LitInt (INTERNAL_sub_boogie |n#0@@4| 1)))) (= (Sequences.__default.Range ($LS $ly@@52) (LitInt |n#0@@4|)) (ite (= (LitInt |n#0@@4|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Range ($LS $ly@@52) (LitInt (INTERNAL_sub_boogie |n#0@@4| 1))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie |n#0@@4| 1))))))))))
 :qid |Sequencesidfy.125:22|
 :weight 3
 :skolemid |3271|
 :pattern ( (Sequences.__default.Range ($LS $ly@@52) (LitInt |n#0@@4|)))
))))
(assert (forall ((arg0@@513 T@U) (arg1@@227 T@U) (arg2@@104 T@U) (arg3@@50 T@U) ) (! (= (type (Sequences.__default.Apply arg0@@513 arg1@@227 arg2@@104 arg3@@50)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Apply|
 :pattern ( (Sequences.__default.Apply arg0@@513 arg1@@227 arg2@@104 arg3@@50))
)))
(assert  (=> true (forall ((Sequences._default.Apply$E T@U) (Sequences._default.Apply$R T@U) ($Heap@@19 T@U) (|f#0@@75| T@U) (|run#0@@27| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E) TyType) (= (type Sequences._default.Apply$R) TyType)) (= (type $Heap@@19) (MapType0Type refType MapType1Type))) (= (type |f#0@@75|) HandleTypeType)) (= (type |run#0@@27|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) (and (and (and ($IsGoodHeap $Heap@@19) ($Is |f#0@@75| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E Sequences._default.Apply$R))) ($Is |run#0@@27| (TSeq Sequences._default.Apply$E))) (forall ((|i#0@@95| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@95|) (INTERNAL_lt_boogie |i#0@@95| (|Seq#Length| |run#0@@27|))) (Requires1 Sequences._default.Apply$E Sequences._default.Apply$R $Heap@@19 |f#0@@75| (|Seq#Index| |run#0@@27| |i#0@@95|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |3272|
 :pattern ( (|Seq#Index| |run#0@@27| |i#0@@95|))
))))) (and (and (= (|Seq#Length| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|)) (|Seq#Length| |run#0@@27|)) (forall ((|i#1@@23| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@23|) (INTERNAL_lt_boogie |i#1@@23| (|Seq#Length| |run#0@@27|))) (= (|Seq#Index| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) |i#1@@23|) (Apply1 Sequences._default.Apply$E Sequences._default.Apply$R $Heap@@19 |f#0@@75| (|Seq#Index| |run#0@@27| |i#1@@23|)))))
 :qid |Sequencesidfy.136:20|
 :skolemid |3273|
 :pattern ( (|Seq#Index| |run#0@@27| |i#1@@23|))
 :pattern ( (|Seq#Index| (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) |i#1@@23|))
))) ($Is (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) (TSeq Sequences._default.Apply$R))))
 :qid |unknown.0:0|
 :skolemid |3274|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E Sequences._default.Apply$R |f#0@@75| |run#0@@27|) ($IsGoodHeap $Heap@@19))
))))
(assert (forall ((Sequences._default.Apply$E@@0 T@U) (Sequences._default.Apply$R@@0 T@U) ($Heap@@20 T@U) (|f#0@@76| T@U) (|run#0@@28| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@0) TyType) (= (type Sequences._default.Apply$R@@0) TyType)) (= (type $Heap@@20) (MapType0Type refType MapType1Type))) (= (type |f#0@@76|) HandleTypeType)) (= (type |run#0@@28|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@20) ($Is |f#0@@76| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0))) ($Is |run#0@@28| (TSeq Sequences._default.Apply$E@@0)))) (= (|Sequences.__default.Apply#requires| Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 |f#0@@76| |run#0@@28|) (forall ((|i#2@@6| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@6|) (INTERNAL_lt_boogie |i#2@@6| (|Seq#Length| |run#0@@28|))) (Requires1 Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 $Heap@@20 |f#0@@76| (|Seq#Index| |run#0@@28| |i#2@@6|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |3275|
 :pattern ( (|Seq#Index| |run#0@@28| |i#2@@6|))
))))
 :qid |unknown.0:0|
 :skolemid |3276|
 :pattern ( (|Sequences.__default.Apply#requires| Sequences._default.Apply$E@@0 Sequences._default.Apply$R@@0 |f#0@@76| |run#0@@28|) ($IsGoodHeap $Heap@@20))
)))
(assert  (and (and (forall ((arg0@@514 T@U) (arg1@@228 T@U) (arg2@@105 T@U) (arg3@@51 T@U) ) (! (= (type (|lambda#149| arg0@@514 arg1@@228 arg2@@105 arg3@@51)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#149|
 :pattern ( (|lambda#149| arg0@@514 arg1@@228 arg2@@105 arg3@@51))
)) (forall ((arg0@@515 T@U) (arg1@@229 Int) (arg2@@106 Int) (arg3@@52 T@U) (arg4@@31 T@U) (arg5@@16 T@U) (arg6@@6 T@U) ) (! (= (type (|lambda#150| arg0@@515 arg1@@229 arg2@@106 arg3@@52 arg4@@31 arg5@@16 arg6@@6)) (MapType2Type (MapType0Type refType MapType1Type) BoxType boolType))
 :qid |funType:lambda#150|
 :pattern ( (|lambda#150| arg0@@515 arg1@@229 arg2@@106 arg3@@52 arg4@@31 arg5@@16 arg6@@6))
))) (forall ((arg0@@516 T@U) (arg1@@230 Int) (arg2@@107 Int) (arg3@@53 T@U) (arg4@@32 T@U) (arg5@@17 T@U) (arg6@@7 T@U) (arg7@@3 T@U) (arg8@@3 T@U) (arg9@@1 T@U) (arg10@@1 T@U) ) (! (= (type (|lambda#152| arg0@@516 arg1@@230 arg2@@107 arg3@@53 arg4@@32 arg5@@17 arg6@@7 arg7@@3 arg8@@3 arg9@@1 arg10@@1)) (MapType2Type (MapType0Type refType MapType1Type) BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#152|
 :pattern ( (|lambda#152| arg0@@516 arg1@@230 arg2@@107 arg3@@53 arg4@@32 arg5@@17 arg6@@7 arg7@@3 arg8@@3 arg9@@1 arg10@@1))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@1 T@U) (Sequences._default.Apply$R@@1 T@U) ($Heap@@21 T@U) (|f#0@@77| T@U) (|run#0@@29| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@1) TyType) (= (type Sequences._default.Apply$R@@1) TyType)) (= (type $Heap@@21) (MapType0Type refType MapType1Type))) (= (type |f#0@@77|) HandleTypeType)) (= (type |run#0@@29|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (and (and (and ($IsGoodHeap $Heap@@21) ($Is |f#0@@77| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1))) ($Is |run#0@@29| (TSeq Sequences._default.Apply$E@@1))) (forall ((|i#2@@7| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@7|) (INTERNAL_lt_boogie |i#2@@7| (|Seq#Length| |run#0@@29|))) (Requires1 Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 $Heap@@21 |f#0@@77| (|Seq#Index| |run#0@@29| |i#2@@7|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |3275|
 :pattern ( (|Seq#Index| |run#0@@29| |i#2@@7|))
))))) (and (forall ((|$l#1#i#0@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@0|) (=> (INTERNAL_lt_boogie |$l#1#i#0@@0| (|Seq#Length| |run#0@@29|)) true))
 :qid |unknown.0:0|
 :skolemid |3278|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0@@0| (|Seq#Length| |run#0@@29|))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@0|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|Seq#Create| Sequences._default.Apply$R@@1 $Heap@@21 (|Seq#Length| |run#0@@29|) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#149| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|lambda#150| TInt 0 (|Seq#Length| |run#0@@29|) Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) (|lambda#152| Tclass._System.object? 0 (|Seq#Length| |run#0@@29|) Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29| Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :skolemid |3279|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@1 Sequences._default.Apply$R@@1 |f#0@@77| |run#0@@29|) ($IsGoodHeap $Heap@@21))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@2 T@U) (Sequences._default.Apply$R@@2 T@U) ($Heap@@22 T@U) (|f#0@@78| T@U) (|run#0@@30| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@2) TyType) (= (type Sequences._default.Apply$R@@2) TyType)) (= (type $Heap@@22) (MapType0Type refType MapType1Type))) (= (type |f#0@@78|) HandleTypeType)) (= (type |run#0@@30|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (and (and (and ($IsGoodHeap $Heap@@22) ($Is |f#0@@78| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2))) ($Is |run#0@@30| (TSeq Sequences._default.Apply$E@@2))) (forall ((|i#4| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4|) (INTERNAL_lt_boogie |i#4| (|Seq#Length| (Lit |run#0@@30|)))) (Requires1 Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 $Heap@@22 |f#0@@78| (|Seq#Index| (Lit |run#0@@30|) |i#4|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |3280|
 :pattern ( (|Seq#Index| |run#0@@30| |i#4|))
))))) (and (forall ((|$l#3#i#0@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@0|) (=> (INTERNAL_lt_boogie |$l#3#i#0@@0| (|Seq#Length| (Lit |run#0@@30|))) true))
 :qid |unknown.0:0|
 :skolemid |3282|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0@@0| (|Seq#Length| (Lit |run#0@@30|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@0|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|Seq#Create| Sequences._default.Apply$R@@2 $Heap@@22 (|Seq#Length| (Lit |run#0@@30|)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#149| Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|lambda#150| TInt 0 (|Seq#Length| (Lit |run#0@@30|)) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) (|lambda#152| Tclass._System.object? 0 (|Seq#Length| (Lit |run#0@@30|)) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|) Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| |run#0@@30|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3283|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@2 Sequences._default.Apply$R@@2 |f#0@@78| (Lit |run#0@@30|)) ($IsGoodHeap $Heap@@22))
))))
(assert  (=> true (forall ((Sequences._default.Apply$E@@3 T@U) (Sequences._default.Apply$R@@3 T@U) ($Heap@@23 T@U) (|f#0@@79| T@U) (|run#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Apply$E@@3) TyType) (= (type Sequences._default.Apply$R@@3) TyType)) (= (type $Heap@@23) (MapType0Type refType MapType1Type))) (= (type |f#0@@79|) HandleTypeType)) (= (type |run#0@@31|) (SeqType BoxType))) (or (|Sequences.__default.Apply#canCall| Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (and (and (and ($IsGoodHeap $Heap@@23) ($Is |f#0@@79| (Tclass._System.___hPartialFunc1 Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3))) ($Is |run#0@@31| (TSeq Sequences._default.Apply$E@@3))) (forall ((|i#6| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#6|) (INTERNAL_lt_boogie |i#6| (|Seq#Length| (Lit |run#0@@31|)))) (Requires1 Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 $Heap@@23 (Lit |f#0@@79|) (|Seq#Index| (Lit |run#0@@31|) |i#6|))))
 :qid |Sequencesidfy.134:21|
 :skolemid |3284|
 :pattern ( (|Seq#Index| |run#0@@31| |i#6|))
))))) (and (forall ((|$l#5#i#0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |$l#5#i#0|) (=> (INTERNAL_lt_boogie |$l#5#i#0| (|Seq#Length| (Lit |run#0@@31|))) true))
 :qid |unknown.0:0|
 :skolemid |3286|
 :no-pattern (INTERNAL_lt_boogie |$l#5#i#0| (|Seq#Length| (Lit |run#0@@31|)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0|)
)) (= (Sequences.__default.Apply Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|Seq#Create| Sequences._default.Apply$R@@3 $Heap@@23 (|Seq#Length| (Lit |run#0@@31|)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#149| Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|lambda#150| TInt 0 (|Seq#Length| (Lit |run#0@@31|)) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) (|lambda#152| Tclass._System.object? 0 (|Seq#Length| (Lit |run#0@@31|)) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|) Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 |f#0@@79| |run#0@@31|))) ($LS $LZ)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3287|
 :pattern ( (Sequences.__default.Apply Sequences._default.Apply$E@@3 Sequences._default.Apply$R@@3 (Lit |f#0@@79|) (Lit |run#0@@31|)) ($IsGoodHeap $Heap@@23))
))))
(assert (forall ((arg0@@517 T@U) (arg1@@231 T@U) (arg2@@108 T@U) (arg3@@54 T@U) (arg4@@33 T@U) ) (! (= (type (Sequences.__default.ApplyOpaque arg0@@517 arg1@@231 arg2@@108 arg3@@54 arg4@@33)) (SeqType BoxType))
 :qid |funType:Sequences.__default.ApplyOpaque|
 :pattern ( (Sequences.__default.ApplyOpaque arg0@@517 arg1@@231 arg2@@108 arg3@@54 arg4@@33))
)))
(assert (forall ((Sequences._default.ApplyOpaque$E T@U) (Sequences._default.ApplyOpaque$R T@U) ($ly@@53 T@U) (|f#0@@80| T@U) (|run#0@@32| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.ApplyOpaque$E) TyType) (= (type Sequences._default.ApplyOpaque$R) TyType)) (= (type $ly@@53) LayerTypeType)) (= (type |f#0@@80|) HandleTypeType)) (= (type |run#0@@32|) (SeqType BoxType))) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R ($LS $ly@@53) |f#0@@80| |run#0@@32|) (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R $ly@@53 |f#0@@80| |run#0@@32|)))
 :qid |unknown.0:0|
 :skolemid |3288|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E Sequences._default.ApplyOpaque$R ($LS $ly@@53) |f#0@@80| |run#0@@32|))
)))
(assert (forall ((Sequences._default.ApplyOpaque$E@@0 T@U) (Sequences._default.ApplyOpaque$R@@0 T@U) ($ly@@54 T@U) (|f#0@@81| T@U) (|run#0@@33| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@0) TyType) (= (type Sequences._default.ApplyOpaque$R@@0) TyType)) (= (type $ly@@54) LayerTypeType)) (= (type |f#0@@81|) HandleTypeType)) (= (type |run#0@@33|) (SeqType BoxType))) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 $ly@@54 |f#0@@81| |run#0@@33|) (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 $LZ |f#0@@81| |run#0@@33|)))
 :qid |unknown.0:0|
 :skolemid |3289|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@0 Sequences._default.ApplyOpaque$R@@0 (AsFuelBottom $ly@@54) |f#0@@81| |run#0@@33|))
)))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@1 T@U) (Sequences._default.ApplyOpaque$R@@1 T@U) ($ly@@55 T@U) ($Heap@@24 T@U) (|f#0@@82| T@U) (|run#0@@34| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@1) TyType) (= (type Sequences._default.ApplyOpaque$R@@1) TyType)) (= (type $ly@@55) LayerTypeType)) (= (type $Heap@@24) (MapType0Type refType MapType1Type))) (= (type |f#0@@82|) HandleTypeType)) (= (type |run#0@@34|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 |f#0@@82| |run#0@@34|) (and (and (and ($IsGoodHeap $Heap@@24) ($Is |f#0@@82| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1))) ($Is |run#0@@34| (TSeq Sequences._default.ApplyOpaque$E@@1))) (forall ((|i#0@@96| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@96|) (INTERNAL_lt_boogie |i#0@@96| (|Seq#Length| |run#0@@34|))) (Requires1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $Heap@@24 |f#0@@82| (|Seq#Index| |run#0@@34| |i#0@@96|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |3290|
 :pattern ( (|Seq#Index| |run#0@@34| |i#0@@96|))
))))) (and (and (= (|Seq#Length| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@55 |f#0@@82| |run#0@@34|)) (|Seq#Length| |run#0@@34|)) (forall ((|i#1@@24| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@24|) (INTERNAL_lt_boogie |i#1@@24| (|Seq#Length| |run#0@@34|))) (= (|Seq#Index| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@55 |f#0@@82| |run#0@@34|) |i#1@@24|) (Apply1 Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $Heap@@24 |f#0@@82| (|Seq#Index| |run#0@@34| |i#1@@24|)))))
 :qid |Sequencesidfy.158:20|
 :skolemid |3291|
 :pattern ( (|Seq#Index| |run#0@@34| |i#1@@24|))
 :pattern ( (|Seq#Index| (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@55 |f#0@@82| |run#0@@34|) |i#1@@24|))
))) ($Is (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@55 |f#0@@82| |run#0@@34|) (TSeq Sequences._default.ApplyOpaque$R@@1))))
 :qid |unknown.0:0|
 :skolemid |3292|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@1 Sequences._default.ApplyOpaque$R@@1 $ly@@55 |f#0@@82| |run#0@@34|) ($IsGoodHeap $Heap@@24))
))))
(assert (forall ((Sequences._default.ApplyOpaque$E@@2 T@U) (Sequences._default.ApplyOpaque$R@@2 T@U) ($ly@@56 T@U) ($Heap@@25 T@U) (|f#0@@83| T@U) (|run#0@@35| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@2) TyType) (= (type Sequences._default.ApplyOpaque$R@@2) TyType)) (= (type $ly@@56) LayerTypeType)) (= (type $Heap@@25) (MapType0Type refType MapType1Type))) (= (type |f#0@@83|) HandleTypeType)) (= (type |run#0@@35|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@25) ($Is |f#0@@83| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2))) ($Is |run#0@@35| (TSeq Sequences._default.ApplyOpaque$E@@2)))) (= (|Sequences.__default.ApplyOpaque#requires| Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $ly@@56 |f#0@@83| |run#0@@35|) (forall ((|i#2@@8| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@8|) (INTERNAL_lt_boogie |i#2@@8| (|Seq#Length| |run#0@@35|))) (Requires1 Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $Heap@@25 |f#0@@83| (|Seq#Index| |run#0@@35| |i#2@@8|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |3293|
 :pattern ( (|Seq#Index| |run#0@@35| |i#2@@8|))
))))
 :qid |unknown.0:0|
 :skolemid |3294|
 :pattern ( (|Sequences.__default.ApplyOpaque#requires| Sequences._default.ApplyOpaque$E@@2 Sequences._default.ApplyOpaque$R@@2 $ly@@56 |f#0@@83| |run#0@@35|) ($IsGoodHeap $Heap@@25))
)))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@3 T@U) (Sequences._default.ApplyOpaque$R@@3 T@U) ($ly@@57 T@U) ($Heap@@26 T@U) (|f#0@@84| T@U) (|run#0@@36| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@3) TyType) (= (type Sequences._default.ApplyOpaque$R@@3) TyType)) (= (type $ly@@57) LayerTypeType)) (= (type $Heap@@26) (MapType0Type refType MapType1Type))) (= (type |f#0@@84|) HandleTypeType)) (= (type |run#0@@36|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|) (and (and (and ($IsGoodHeap $Heap@@26) ($Is |f#0@@84| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3))) ($Is |run#0@@36| (TSeq Sequences._default.ApplyOpaque$E@@3))) (forall ((|i#2@@9| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#2@@9|) (INTERNAL_lt_boogie |i#2@@9| (|Seq#Length| |run#0@@36|))) (Requires1 Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 $Heap@@26 |f#0@@84| (|Seq#Index| |run#0@@36| |i#2@@9|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |3293|
 :pattern ( (|Seq#Index| |run#0@@36| |i#2@@9|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 ($LS $ly@@57) |f#0@@84| |run#0@@36|) (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 |f#0@@84| |run#0@@36|))))
 :qid |unknown.0:0|
 :skolemid |3295|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@3 Sequences._default.ApplyOpaque$R@@3 ($LS $ly@@57) |f#0@@84| |run#0@@36|) ($IsGoodHeap $Heap@@26))
))))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@4 T@U) (Sequences._default.ApplyOpaque$R@@4 T@U) ($ly@@58 T@U) ($Heap@@27 T@U) (|f#0@@85| T@U) (|run#0@@37| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@4) TyType) (= (type Sequences._default.ApplyOpaque$R@@4) TyType)) (= (type $ly@@58) LayerTypeType)) (= (type $Heap@@27) (MapType0Type refType MapType1Type))) (= (type |f#0@@85|) HandleTypeType)) (= (type |run#0@@37|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)) (and (and (and ($IsGoodHeap $Heap@@27) ($Is |f#0@@85| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4))) ($Is |run#0@@37| (TSeq Sequences._default.ApplyOpaque$E@@4))) (forall ((|i#3@@3| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#3@@3|) (INTERNAL_lt_boogie |i#3@@3| (|Seq#Length| (Lit |run#0@@37|)))) (Requires1 Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 $Heap@@27 |f#0@@85| (|Seq#Index| (Lit |run#0@@37|) |i#3@@3|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |3296|
 :pattern ( (|Seq#Index| |run#0@@37| |i#3@@3|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 ($LS $ly@@58) |f#0@@85| (Lit |run#0@@37|)) (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 |f#0@@85| (Lit |run#0@@37|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3297|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@4 Sequences._default.ApplyOpaque$R@@4 ($LS $ly@@58) |f#0@@85| (Lit |run#0@@37|)) ($IsGoodHeap $Heap@@27))
))))
(assert  (=> true (forall ((Sequences._default.ApplyOpaque$E@@5 T@U) (Sequences._default.ApplyOpaque$R@@5 T@U) ($ly@@59 T@U) ($Heap@@28 T@U) (|f#0@@86| T@U) (|run#0@@38| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.ApplyOpaque$E@@5) TyType) (= (type Sequences._default.ApplyOpaque$R@@5) TyType)) (= (type $ly@@59) LayerTypeType)) (= (type $Heap@@28) (MapType0Type refType MapType1Type))) (= (type |f#0@@86|) HandleTypeType)) (= (type |run#0@@38|) (SeqType BoxType))) (or (|Sequences.__default.ApplyOpaque#canCall| Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|)) (and (and (and ($IsGoodHeap $Heap@@28) ($Is |f#0@@86| (Tclass._System.___hPartialFunc1 Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5))) ($Is |run#0@@38| (TSeq Sequences._default.ApplyOpaque$E@@5))) (forall ((|i#4@@0| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@0|) (INTERNAL_lt_boogie |i#4@@0| (|Seq#Length| (Lit |run#0@@38|)))) (Requires1 Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 $Heap@@28 (Lit |f#0@@86|) (|Seq#Index| (Lit |run#0@@38|) |i#4@@0|))))
 :qid |Sequencesidfy.156:21|
 :skolemid |3298|
 :pattern ( (|Seq#Index| |run#0@@38| |i#4@@0|))
))))) (and (|Sequences.__default.Apply#canCall| Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|)) (= (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 ($LS $ly@@59) (Lit |f#0@@86|) (Lit |run#0@@38|)) (Lit (Sequences.__default.Apply Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 (Lit |f#0@@86|) (Lit |run#0@@38|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3299|
 :pattern ( (Sequences.__default.ApplyOpaque Sequences._default.ApplyOpaque$E@@5 Sequences._default.ApplyOpaque$R@@5 ($LS $ly@@59) (Lit |f#0@@86|) (Lit |run#0@@38|)) ($IsGoodHeap $Heap@@28))
))))
(assert (forall ((arg0@@518 T@U) (arg1@@232 T@U) (arg2@@109 T@U) (arg3@@55 T@U) ) (! (= (type (Sequences.__default.Filter arg0@@518 arg1@@232 arg2@@109 arg3@@55)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Filter|
 :pattern ( (Sequences.__default.Filter arg0@@518 arg1@@232 arg2@@109 arg3@@55))
)))
(assert (forall ((Sequences._default.Filter$E T@U) ($ly@@60 T@U) (|f#0@@87| T@U) (|run#0@@39| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Filter$E) TyType) (= (type $ly@@60) LayerTypeType)) (= (type |f#0@@87|) HandleTypeType)) (= (type |run#0@@39|) (SeqType BoxType))) (= (Sequences.__default.Filter Sequences._default.Filter$E ($LS $ly@@60) |f#0@@87| |run#0@@39|) (Sequences.__default.Filter Sequences._default.Filter$E $ly@@60 |f#0@@87| |run#0@@39|)))
 :qid |unknown.0:0|
 :skolemid |3300|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E ($LS $ly@@60) |f#0@@87| |run#0@@39|))
)))
(assert (forall ((Sequences._default.Filter$E@@0 T@U) ($ly@@61 T@U) (|f#0@@88| T@U) (|run#0@@40| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Filter$E@@0) TyType) (= (type $ly@@61) LayerTypeType)) (= (type |f#0@@88|) HandleTypeType)) (= (type |run#0@@40|) (SeqType BoxType))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@0 $ly@@61 |f#0@@88| |run#0@@40|) (Sequences.__default.Filter Sequences._default.Filter$E@@0 $LZ |f#0@@88| |run#0@@40|)))
 :qid |unknown.0:0|
 :skolemid |3301|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@0 (AsFuelBottom $ly@@61) |f#0@@88| |run#0@@40|))
)))
(assert  (=> true (forall ((Sequences._default.Filter$E@@1 T@U) ($ly@@62 T@U) ($Heap@@29 T@U) (|f#0@@89| T@U) (|run#0@@41| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@1) TyType) (= (type $ly@@62) LayerTypeType)) (= (type $Heap@@29) (MapType0Type refType MapType1Type))) (= (type |f#0@@89|) HandleTypeType)) (= (type |run#0@@41|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@1 |f#0@@89| |run#0@@41|) (and (and (and ($IsGoodHeap $Heap@@29) ($Is |f#0@@89| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@1 TBool))) ($Is |run#0@@41| (TSeq Sequences._default.Filter$E@@1))) (forall ((|i#0@@97| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@97|) (INTERNAL_lt_boogie |i#0@@97| (|Seq#Length| |run#0@@41|))) (Requires1 Sequences._default.Filter$E@@1 TBool $Heap@@29 |f#0@@89| (|Seq#Index| |run#0@@41| |i#0@@97|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |3302|
 :pattern ( (|Seq#Index| |run#0@@41| |i#0@@97|))
))))) (and (and (and (and (INTERNAL_le_boogie (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|)) (|Seq#Length| |run#0@@41|)) (forall ((|i#1@@25| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@25|) (INTERNAL_lt_boogie |i#1@@25| (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|)))) (|Seq#Contains| |run#0@@41| (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) |i#1@@25|)))
 :qid |Sequencesidfy.192:20|
 :skolemid |3303|
 :pattern ( (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) |i#1@@25|))
))) (forall ((|i#2@@10| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@10|) (INTERNAL_lt_boogie |i#2@@10| (|Seq#Length| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|)))) (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@1 TBool $Heap@@29 |f#0@@89| (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) |i#2@@10|)))))
 :qid |Sequencesidfy.193:20|
 :skolemid |3304|
 :pattern ( (|Seq#Index| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) |i#2@@10|))
))) (forall ((|i#3@@4| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#3@@4|) (and (INTERNAL_lt_boogie |i#3@@4| (|Seq#Length| |run#0@@41|)) (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@1 TBool $Heap@@29 |f#0@@89| (|Seq#Index| |run#0@@41| |i#3@@4|)))))) (|Seq#Contains| (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) (|Seq#Index| |run#0@@41| |i#3@@4|)))
 :qid |Sequencesidfy.194:20|
 :skolemid |3305|
 :pattern ( (|Seq#Index| |run#0@@41| |i#3@@4|))
))) ($Is (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) (TSeq Sequences._default.Filter$E@@1))))
 :qid |unknown.0:0|
 :skolemid |3306|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@1 $ly@@62 |f#0@@89| |run#0@@41|) ($IsGoodHeap $Heap@@29))
))))
(assert (forall ((Sequences._default.Filter$E@@2 T@U) ($ly@@63 T@U) ($Heap@@30 T@U) (|f#0@@90| T@U) (|run#0@@42| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@2) TyType) (= (type $ly@@63) LayerTypeType)) (= (type $Heap@@30) (MapType0Type refType MapType1Type))) (= (type |f#0@@90|) HandleTypeType)) (= (type |run#0@@42|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@30) ($Is |f#0@@90| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@2 TBool))) ($Is |run#0@@42| (TSeq Sequences._default.Filter$E@@2)))) (= (|Sequences.__default.Filter#requires| Sequences._default.Filter$E@@2 $ly@@63 |f#0@@90| |run#0@@42|) (forall ((|i#4@@1| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@1|) (INTERNAL_lt_boogie |i#4@@1| (|Seq#Length| |run#0@@42|))) (Requires1 Sequences._default.Filter$E@@2 TBool $Heap@@30 |f#0@@90| (|Seq#Index| |run#0@@42| |i#4@@1|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |3307|
 :pattern ( (|Seq#Index| |run#0@@42| |i#4@@1|))
))))
 :qid |unknown.0:0|
 :skolemid |3308|
 :pattern ( (|Sequences.__default.Filter#requires| Sequences._default.Filter$E@@2 $ly@@63 |f#0@@90| |run#0@@42|) ($IsGoodHeap $Heap@@30))
)))
(assert  (=> true (forall ((Sequences._default.Filter$E@@3 T@U) ($ly@@64 T@U) ($Heap@@31 T@U) (|f#0@@91| T@U) (|run#0@@43| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@3) TyType) (= (type $ly@@64) LayerTypeType)) (= (type $Heap@@31) (MapType0Type refType MapType1Type))) (= (type |f#0@@91|) HandleTypeType)) (= (type |run#0@@43|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| |run#0@@43|) (and (and (and ($IsGoodHeap $Heap@@31) ($Is |f#0@@91| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@3 TBool))) ($Is |run#0@@43| (TSeq Sequences._default.Filter$E@@3))) (forall ((|i#4@@2| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#4@@2|) (INTERNAL_lt_boogie |i#4@@2| (|Seq#Length| |run#0@@43|))) (Requires1 Sequences._default.Filter$E@@3 TBool $Heap@@31 |f#0@@91| (|Seq#Index| |run#0@@43| |i#4@@2|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |3307|
 :pattern ( (|Seq#Index| |run#0@@43| |i#4@@2|))
))))) (and (=> (not (= (|Seq#Length| |run#0@@43|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@31 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|)))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@3 |run#0@@43|)))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@31 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@3 |run#0@@43|) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@3 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@3 ($LS $ly@@64) |f#0@@91| |run#0@@43|) (ite (= (|Seq#Length| |run#0@@43|) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@3 TBool $Heap@@31 |f#0@@91| (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|)))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@3 $ly@@64 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)) (|Seq#Build| (|Seq#Empty| BoxType) (Sequences.__default.Last Sequences._default.Filter$E@@3 |run#0@@43|))) (Sequences.__default.Filter Sequences._default.Filter$E@@3 $ly@@64 |f#0@@91| (Sequences.__default.DropLast Sequences._default.Filter$E@@3 |run#0@@43|)))))))
 :qid |unknown.0:0|
 :skolemid |3309|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@3 ($LS $ly@@64) |f#0@@91| |run#0@@43|) ($IsGoodHeap $Heap@@31))
))))
(assert  (=> true (forall ((Sequences._default.Filter$E@@4 T@U) ($ly@@65 T@U) ($Heap@@32 T@U) (|f#0@@92| T@U) (|run#0@@44| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@4) TyType) (= (type $ly@@65) LayerTypeType)) (= (type $Heap@@32) (MapType0Type refType MapType1Type))) (= (type |f#0@@92|) HandleTypeType)) (= (type |run#0@@44|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit |run#0@@44|)) (and (and (and ($IsGoodHeap $Heap@@32) ($Is |f#0@@92| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@4 TBool))) ($Is |run#0@@44| (TSeq Sequences._default.Filter$E@@4))) (forall ((|i#5| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#5|) (INTERNAL_lt_boogie |i#5| (|Seq#Length| (Lit |run#0@@44|)))) (Requires1 Sequences._default.Filter$E@@4 TBool $Heap@@32 |f#0@@92| (|Seq#Index| (Lit |run#0@@44|) |i#5|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |3310|
 :pattern ( (|Seq#Index| |run#0@@44| |i#5|))
))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@32 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@32 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@4 (Lit |run#0@@44|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@4 |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@65) |f#0@@92| (Lit |run#0@@44|)) (ite (= (|Seq#Length| (Lit |run#0@@44|)) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@4 TBool $Heap@@32 |f#0@@92| (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@65) |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))) (|Seq#Build| (|Seq#Empty| BoxType) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@4 (Lit |run#0@@44|))))) (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@65) |f#0@@92| (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@4 (Lit |run#0@@44|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3311|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@4 ($LS $ly@@65) |f#0@@92| (Lit |run#0@@44|)) ($IsGoodHeap $Heap@@32))
))))
(assert  (=> true (forall ((Sequences._default.Filter$E@@5 T@U) ($ly@@66 T@U) ($Heap@@33 T@U) (|f#0@@93| T@U) (|run#0@@45| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Filter$E@@5) TyType) (= (type $ly@@66) LayerTypeType)) (= (type $Heap@@33) (MapType0Type refType MapType1Type))) (= (type |f#0@@93|) HandleTypeType)) (= (type |run#0@@45|) (SeqType BoxType))) (or (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit |run#0@@45|)) (and (and (and ($IsGoodHeap $Heap@@33) ($Is |f#0@@93| (Tclass._System.___hPartialFunc1 Sequences._default.Filter$E@@5 TBool))) ($Is |run#0@@45| (TSeq Sequences._default.Filter$E@@5))) (forall ((|i#6@@0| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#6@@0|) (INTERNAL_lt_boogie |i#6@@0| (|Seq#Length| (Lit |run#0@@45|)))) (Requires1 Sequences._default.Filter$E@@5 TBool $Heap@@33 (Lit |f#0@@93|) (|Seq#Index| (Lit |run#0@@45|) |i#6@@0|))))
 :qid |Sequencesidfy.190:21|
 :skolemid |3312|
 :pattern ( (|Seq#Index| |run#0@@45| |i#6@@0|))
))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (=> (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@33 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (|Sequences.__default.Last#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (=> (not (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@33 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))))) (and (|Sequences.__default.DropLast#canCall| Sequences._default.Filter$E@@5 (Lit |run#0@@45|)) (|Sequences.__default.Filter#canCall| Sequences._default.Filter$E@@5 (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))))) (= (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@66) (Lit |f#0@@93|) (Lit |run#0@@45|)) (ite (= (|Seq#Length| (Lit |run#0@@45|)) (LitInt 0)) (|Seq#Empty| BoxType) (ite (U_2_bool ($Unbox boolType (Apply1 Sequences._default.Filter$E@@5 TBool $Heap@@33 (Lit |f#0@@93|) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))) (|Seq#Append| (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@66) (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))) (|Seq#Build| (|Seq#Empty| BoxType) (Lit (Sequences.__default.Last Sequences._default.Filter$E@@5 (Lit |run#0@@45|))))) (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@66) (Lit |f#0@@93|) (Lit (Sequences.__default.DropLast Sequences._default.Filter$E@@5 (Lit |run#0@@45|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3313|
 :pattern ( (Sequences.__default.Filter Sequences._default.Filter$E@@5 ($LS $ly@@66) (Lit |f#0@@93|) (Lit |run#0@@45|)) ($IsGoodHeap $Heap@@33))
))))
(assert (forall ((arg0@@519 T@U) (arg1@@233 T@U) (arg2@@110 T@U) (arg3@@56 T@U) (arg4@@34 T@U) (arg5@@18 T@U) ) (! (= (type (Sequences.__default.FoldLeft arg0@@519 arg1@@233 arg2@@110 arg3@@56 arg4@@34 arg5@@18)) BoxType)
 :qid |funType:Sequences.__default.FoldLeft|
 :pattern ( (Sequences.__default.FoldLeft arg0@@519 arg1@@233 arg2@@110 arg3@@56 arg4@@34 arg5@@18))
)))
(assert (forall ((Sequences._default.FoldLeft$A T@U) (Sequences._default.FoldLeft$E T@U) ($ly@@67 T@U) (|f#0@@94| T@U) (|init#0| T@U) (|run#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldLeft$A) TyType) (= (type Sequences._default.FoldLeft$E) TyType)) (= (type $ly@@67) LayerTypeType)) (= (type |f#0@@94|) HandleTypeType)) (= (type |init#0|) BoxType)) (= (type |run#0@@46|) (SeqType BoxType))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E ($LS $ly@@67) |f#0@@94| |init#0| |run#0@@46|) (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E $ly@@67 |f#0@@94| |init#0| |run#0@@46|)))
 :qid |unknown.0:0|
 :skolemid |3314|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A Sequences._default.FoldLeft$E ($LS $ly@@67) |f#0@@94| |init#0| |run#0@@46|))
)))
(assert (forall ((Sequences._default.FoldLeft$A@@0 T@U) (Sequences._default.FoldLeft$E@@0 T@U) ($ly@@68 T@U) (|f#0@@95| T@U) (|init#0@@0| T@U) (|run#0@@47| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@0) TyType) (= (type Sequences._default.FoldLeft$E@@0) TyType)) (= (type $ly@@68) LayerTypeType)) (= (type |f#0@@95|) HandleTypeType)) (= (type |init#0@@0|) BoxType)) (= (type |run#0@@47|) (SeqType BoxType))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 $ly@@68 |f#0@@95| |init#0@@0| |run#0@@47|) (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 $LZ |f#0@@95| |init#0@@0| |run#0@@47|)))
 :qid |unknown.0:0|
 :skolemid |3315|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@0 Sequences._default.FoldLeft$E@@0 (AsFuelBottom $ly@@68) |f#0@@95| |init#0@@0| |run#0@@47|))
)))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@1 T@U) (Sequences._default.FoldLeft$E@@1 T@U) ($ly@@69 T@U) (|f#0@@96| T@U) (|init#0@@1| T@U) (|run#0@@48| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@1) TyType) (= (type Sequences._default.FoldLeft$E@@1) TyType)) (= (type $ly@@69) LayerTypeType)) (= (type |f#0@@96|) HandleTypeType)) (= (type |init#0@@1|) BoxType)) (= (type |run#0@@48|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 |f#0@@96| |init#0@@1| |run#0@@48|) (and (and ($Is |f#0@@96| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 Sequences._default.FoldLeft$A@@1)) ($IsBox |init#0@@1| Sequences._default.FoldLeft$A@@1)) ($Is |run#0@@48| (TSeq Sequences._default.FoldLeft$E@@1))))) ($IsBox (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 $ly@@69 |f#0@@96| |init#0@@1| |run#0@@48|) Sequences._default.FoldLeft$A@@1))
 :qid |unknown.0:0|
 :skolemid |3316|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@1 Sequences._default.FoldLeft$E@@1 $ly@@69 |f#0@@96| |init#0@@1| |run#0@@48|))
))))
(assert (forall ((Sequences._default.FoldLeft$A@@2 T@U) (Sequences._default.FoldLeft$E@@2 T@U) ($ly@@70 T@U) ($Heap@@34 T@U) (|f#0@@97| T@U) (|init#0@@2| T@U) (|run#0@@49| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@2) TyType) (= (type Sequences._default.FoldLeft$E@@2) TyType)) (= (type $ly@@70) LayerTypeType)) (= (type $Heap@@34) (MapType0Type refType MapType1Type))) (= (type |f#0@@97|) HandleTypeType)) (= (type |init#0@@2|) BoxType)) (= (type |run#0@@49|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@34) ($Is |f#0@@97| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 Sequences._default.FoldLeft$A@@2))) ($IsBox |init#0@@2| Sequences._default.FoldLeft$A@@2)) ($Is |run#0@@49| (TSeq Sequences._default.FoldLeft$E@@2)))) (= (|Sequences.__default.FoldLeft#requires| Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 $ly@@70 |f#0@@97| |init#0@@2| |run#0@@49|) true))
 :qid |unknown.0:0|
 :skolemid |3317|
 :pattern ( (|Sequences.__default.FoldLeft#requires| Sequences._default.FoldLeft$A@@2 Sequences._default.FoldLeft$E@@2 $ly@@70 |f#0@@97| |init#0@@2| |run#0@@49|) ($IsGoodHeap $Heap@@34))
)))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@3 T@U) (Sequences._default.FoldLeft$E@@3 T@U) ($ly@@71 T@U) ($Heap@@35 T@U) (|f#0@@98| T@U) (|init#0@@3| T@U) (|run#0@@50| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@3) TyType) (= (type Sequences._default.FoldLeft$E@@3) TyType)) (= (type $ly@@71) LayerTypeType)) (= (type $Heap@@35) (MapType0Type refType MapType1Type))) (= (type |f#0@@98|) HandleTypeType)) (= (type |init#0@@3|) BoxType)) (= (type |run#0@@50|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 |f#0@@98| |init#0@@3| |run#0@@50|) (and (and (and ($IsGoodHeap $Heap@@35) ($Is |f#0@@98| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3))) ($IsBox |init#0@@3| Sequences._default.FoldLeft$A@@3)) ($Is |run#0@@50| (TSeq Sequences._default.FoldLeft$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@50|) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 |f#0@@98| (Apply2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3 $Heap@@35 |f#0@@98| |init#0@@3| (|Seq#Index| |run#0@@50| (LitInt 0))) (|Seq#Drop| |run#0@@50| (LitInt 1)))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 ($LS $ly@@71) |f#0@@98| |init#0@@3| |run#0@@50|) (ite (= (|Seq#Length| |run#0@@50|) (LitInt 0)) |init#0@@3| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 $ly@@71 |f#0@@98| (Apply2 Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 Sequences._default.FoldLeft$A@@3 $Heap@@35 |f#0@@98| |init#0@@3| (|Seq#Index| |run#0@@50| (LitInt 0))) (|Seq#Drop| |run#0@@50| (LitInt 1)))))))
 :qid |unknown.0:0|
 :skolemid |3318|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@3 Sequences._default.FoldLeft$E@@3 ($LS $ly@@71) |f#0@@98| |init#0@@3| |run#0@@50|) ($IsGoodHeap $Heap@@35))
))))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@4 T@U) (Sequences._default.FoldLeft$E@@4 T@U) ($ly@@72 T@U) ($Heap@@36 T@U) (|f#0@@99| T@U) (|init#0@@4| T@U) (|run#0@@51| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@4) TyType) (= (type Sequences._default.FoldLeft$E@@4) TyType)) (= (type $ly@@72) LayerTypeType)) (= (type $Heap@@36) (MapType0Type refType MapType1Type))) (= (type |f#0@@99|) HandleTypeType)) (= (type |init#0@@4|) BoxType)) (= (type |run#0@@51|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) (and (and (and ($IsGoodHeap $Heap@@36) ($Is |f#0@@99| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4))) ($IsBox |init#0@@4| Sequences._default.FoldLeft$A@@4)) ($Is |run#0@@51| (TSeq Sequences._default.FoldLeft$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 |f#0@@99| (Apply2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4 $Heap@@36 |f#0@@99| |init#0@@4| (|Seq#Index| (Lit |run#0@@51|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1))))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@72) |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) (ite (= (|Seq#Length| (Lit |run#0@@51|)) (LitInt 0)) |init#0@@4| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@72) |f#0@@99| (Apply2 Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 Sequences._default.FoldLeft$A@@4 $Heap@@36 |f#0@@99| |init#0@@4| (|Seq#Index| (Lit |run#0@@51|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@51|) (LitInt 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3319|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@4 Sequences._default.FoldLeft$E@@4 ($LS $ly@@72) |f#0@@99| |init#0@@4| (Lit |run#0@@51|)) ($IsGoodHeap $Heap@@36))
))))
(assert  (=> true (forall ((Sequences._default.FoldLeft$A@@5 T@U) (Sequences._default.FoldLeft$E@@5 T@U) ($ly@@73 T@U) ($Heap@@37 T@U) (|f#0@@100| T@U) (|init#0@@5| T@U) (|run#0@@52| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldLeft$A@@5) TyType) (= (type Sequences._default.FoldLeft$E@@5) TyType)) (= (type $ly@@73) LayerTypeType)) (= (type $Heap@@37) (MapType0Type refType MapType1Type))) (= (type |f#0@@100|) HandleTypeType)) (= (type |init#0@@5|) BoxType)) (= (type |run#0@@52|) (SeqType BoxType))) (or (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) (and (and (and ($IsGoodHeap $Heap@@37) ($Is |f#0@@100| (Tclass._System.___hTotalFunc2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5))) ($IsBox |init#0@@5| Sequences._default.FoldLeft$A@@5)) ($Is |run#0@@52| (TSeq Sequences._default.FoldLeft$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0))) (|Sequences.__default.FoldLeft#canCall| Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 (Lit |f#0@@100|) (Apply2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5 $Heap@@37 (Lit |f#0@@100|) (Lit |init#0@@5|) (|Seq#Index| (Lit |run#0@@52|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1))))) (= (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@73) (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) (ite (= (|Seq#Length| (Lit |run#0@@52|)) (LitInt 0)) |init#0@@5| (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@73) (Lit |f#0@@100|) (Apply2 Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 Sequences._default.FoldLeft$A@@5 $Heap@@37 (Lit |f#0@@100|) (Lit |init#0@@5|) (|Seq#Index| (Lit |run#0@@52|) (LitInt 0))) (Lit (|Seq#Drop| (Lit |run#0@@52|) (LitInt 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3320|
 :pattern ( (Sequences.__default.FoldLeft Sequences._default.FoldLeft$A@@5 Sequences._default.FoldLeft$E@@5 ($LS $ly@@73) (Lit |f#0@@100|) (Lit |init#0@@5|) (Lit |run#0@@52|)) ($IsGoodHeap $Heap@@37))
))))
(assert (forall ((arg0@@520 T@U) (arg1@@234 T@U) (arg2@@111 T@U) (arg3@@57 T@U) (arg4@@35 T@U) (arg5@@19 T@U) ) (! (= (type (Sequences.__default.FoldRight arg0@@520 arg1@@234 arg2@@111 arg3@@57 arg4@@35 arg5@@19)) BoxType)
 :qid |funType:Sequences.__default.FoldRight|
 :pattern ( (Sequences.__default.FoldRight arg0@@520 arg1@@234 arg2@@111 arg3@@57 arg4@@35 arg5@@19))
)))
(assert (forall ((Sequences._default.FoldRight$A T@U) (Sequences._default.FoldRight$E T@U) ($ly@@74 T@U) (|f#0@@101| T@U) (|init#0@@6| T@U) (|run#0@@53| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldRight$A) TyType) (= (type Sequences._default.FoldRight$E) TyType)) (= (type $ly@@74) LayerTypeType)) (= (type |f#0@@101|) HandleTypeType)) (= (type |init#0@@6|) BoxType)) (= (type |run#0@@53|) (SeqType BoxType))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E ($LS $ly@@74) |f#0@@101| |init#0@@6| |run#0@@53|) (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E $ly@@74 |f#0@@101| |init#0@@6| |run#0@@53|)))
 :qid |unknown.0:0|
 :skolemid |3321|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A Sequences._default.FoldRight$E ($LS $ly@@74) |f#0@@101| |init#0@@6| |run#0@@53|))
)))
(assert (forall ((Sequences._default.FoldRight$A@@0 T@U) (Sequences._default.FoldRight$E@@0 T@U) ($ly@@75 T@U) (|f#0@@102| T@U) (|init#0@@7| T@U) (|run#0@@54| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@0) TyType) (= (type Sequences._default.FoldRight$E@@0) TyType)) (= (type $ly@@75) LayerTypeType)) (= (type |f#0@@102|) HandleTypeType)) (= (type |init#0@@7|) BoxType)) (= (type |run#0@@54|) (SeqType BoxType))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 $ly@@75 |f#0@@102| |init#0@@7| |run#0@@54|) (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 $LZ |f#0@@102| |init#0@@7| |run#0@@54|)))
 :qid |unknown.0:0|
 :skolemid |3322|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@0 Sequences._default.FoldRight$E@@0 (AsFuelBottom $ly@@75) |f#0@@102| |init#0@@7| |run#0@@54|))
)))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@1 T@U) (Sequences._default.FoldRight$E@@1 T@U) ($ly@@76 T@U) (|f#0@@103| T@U) (|init#0@@8| T@U) (|run#0@@55| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@1) TyType) (= (type Sequences._default.FoldRight$E@@1) TyType)) (= (type $ly@@76) LayerTypeType)) (= (type |f#0@@103|) HandleTypeType)) (= (type |init#0@@8|) BoxType)) (= (type |run#0@@55|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 |f#0@@103| |init#0@@8| |run#0@@55|) (and (and ($Is |f#0@@103| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 Sequences._default.FoldRight$A@@1)) ($IsBox |init#0@@8| Sequences._default.FoldRight$A@@1)) ($Is |run#0@@55| (TSeq Sequences._default.FoldRight$E@@1))))) ($IsBox (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 $ly@@76 |f#0@@103| |init#0@@8| |run#0@@55|) Sequences._default.FoldRight$A@@1))
 :qid |unknown.0:0|
 :skolemid |3323|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@1 Sequences._default.FoldRight$E@@1 $ly@@76 |f#0@@103| |init#0@@8| |run#0@@55|))
))))
(assert (forall ((Sequences._default.FoldRight$A@@2 T@U) (Sequences._default.FoldRight$E@@2 T@U) ($ly@@77 T@U) ($Heap@@38 T@U) (|f#0@@104| T@U) (|init#0@@9| T@U) (|run#0@@56| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@2) TyType) (= (type Sequences._default.FoldRight$E@@2) TyType)) (= (type $ly@@77) LayerTypeType)) (= (type $Heap@@38) (MapType0Type refType MapType1Type))) (= (type |f#0@@104|) HandleTypeType)) (= (type |init#0@@9|) BoxType)) (= (type |run#0@@56|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@38) ($Is |f#0@@104| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 Sequences._default.FoldRight$A@@2))) ($IsBox |init#0@@9| Sequences._default.FoldRight$A@@2)) ($Is |run#0@@56| (TSeq Sequences._default.FoldRight$E@@2)))) (= (|Sequences.__default.FoldRight#requires| Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 $ly@@77 |f#0@@104| |init#0@@9| |run#0@@56|) true))
 :qid |unknown.0:0|
 :skolemid |3324|
 :pattern ( (|Sequences.__default.FoldRight#requires| Sequences._default.FoldRight$A@@2 Sequences._default.FoldRight$E@@2 $ly@@77 |f#0@@104| |init#0@@9| |run#0@@56|) ($IsGoodHeap $Heap@@38))
)))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@3 T@U) (Sequences._default.FoldRight$E@@3 T@U) ($ly@@78 T@U) ($Heap@@39 T@U) (|f#0@@105| T@U) (|init#0@@10| T@U) (|run#0@@57| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@3) TyType) (= (type Sequences._default.FoldRight$E@@3) TyType)) (= (type $ly@@78) LayerTypeType)) (= (type $Heap@@39) (MapType0Type refType MapType1Type))) (= (type |f#0@@105|) HandleTypeType)) (= (type |init#0@@10|) BoxType)) (= (type |run#0@@57|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 |f#0@@105| |init#0@@10| |run#0@@57|) (and (and (and ($IsGoodHeap $Heap@@39) ($Is |f#0@@105| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 Sequences._default.FoldRight$A@@3))) ($IsBox |init#0@@10| Sequences._default.FoldRight$A@@3)) ($Is |run#0@@57| (TSeq Sequences._default.FoldRight$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@57|) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 |f#0@@105| |init#0@@10| (|Seq#Drop| |run#0@@57| (LitInt 1)))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 ($LS $ly@@78) |f#0@@105| |init#0@@10| |run#0@@57|) (ite (= (|Seq#Length| |run#0@@57|) (LitInt 0)) |init#0@@10| (Apply2 Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 Sequences._default.FoldRight$A@@3 $Heap@@39 |f#0@@105| (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 $ly@@78 |f#0@@105| |init#0@@10| (|Seq#Drop| |run#0@@57| (LitInt 1))) (|Seq#Index| |run#0@@57| (LitInt 0)))))))
 :qid |unknown.0:0|
 :skolemid |3325|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@3 Sequences._default.FoldRight$E@@3 ($LS $ly@@78) |f#0@@105| |init#0@@10| |run#0@@57|) ($IsGoodHeap $Heap@@39))
))))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@4 T@U) (Sequences._default.FoldRight$E@@4 T@U) ($ly@@79 T@U) ($Heap@@40 T@U) (|f#0@@106| T@U) (|init#0@@11| T@U) (|run#0@@58| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@4) TyType) (= (type Sequences._default.FoldRight$E@@4) TyType)) (= (type $ly@@79) LayerTypeType)) (= (type $Heap@@40) (MapType0Type refType MapType1Type))) (= (type |f#0@@106|) HandleTypeType)) (= (type |init#0@@11|) BoxType)) (= (type |run#0@@58|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) (and (and (and ($IsGoodHeap $Heap@@40) ($Is |f#0@@106| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 Sequences._default.FoldRight$A@@4))) ($IsBox |init#0@@11| Sequences._default.FoldRight$A@@4)) ($Is |run#0@@58| (TSeq Sequences._default.FoldRight$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 |f#0@@106| |init#0@@11| (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1))))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@79) |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) (ite (= (|Seq#Length| (Lit |run#0@@58|)) (LitInt 0)) |init#0@@11| (Apply2 Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 Sequences._default.FoldRight$A@@4 $Heap@@40 |f#0@@106| (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@79) |f#0@@106| |init#0@@11| (Lit (|Seq#Drop| (Lit |run#0@@58|) (LitInt 1)))) (|Seq#Index| (Lit |run#0@@58|) (LitInt 0)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3326|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@4 Sequences._default.FoldRight$E@@4 ($LS $ly@@79) |f#0@@106| |init#0@@11| (Lit |run#0@@58|)) ($IsGoodHeap $Heap@@40))
))))
(assert  (=> true (forall ((Sequences._default.FoldRight$A@@5 T@U) (Sequences._default.FoldRight$E@@5 T@U) ($ly@@80 T@U) ($Heap@@41 T@U) (|f#0@@107| T@U) (|init#0@@12| T@U) (|run#0@@59| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldRight$A@@5) TyType) (= (type Sequences._default.FoldRight$E@@5) TyType)) (= (type $ly@@80) LayerTypeType)) (= (type $Heap@@41) (MapType0Type refType MapType1Type))) (= (type |f#0@@107|) HandleTypeType)) (= (type |init#0@@12|) BoxType)) (= (type |run#0@@59|) (SeqType BoxType))) (or (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) (and (and (and ($IsGoodHeap $Heap@@41) ($Is |f#0@@107| (Tclass._System.___hTotalFunc2 Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 Sequences._default.FoldRight$A@@5))) ($IsBox |init#0@@12| Sequences._default.FoldRight$A@@5)) ($Is |run#0@@59| (TSeq Sequences._default.FoldRight$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0))) (|Sequences.__default.FoldRight#canCall| Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1))))) (= (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@80) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) (ite (= (|Seq#Length| (Lit |run#0@@59|)) (LitInt 0)) |init#0@@12| (Apply2 Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 Sequences._default.FoldRight$A@@5 $Heap@@41 (Lit |f#0@@107|) (Lit (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@80) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit (|Seq#Drop| (Lit |run#0@@59|) (LitInt 1))))) (|Seq#Index| (Lit |run#0@@59|) (LitInt 0)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3327|
 :pattern ( (Sequences.__default.FoldRight Sequences._default.FoldRight$A@@5 Sequences._default.FoldRight$E@@5 ($LS $ly@@80) (Lit |f#0@@107|) (Lit |init#0@@12|) (Lit |run#0@@59|)) ($IsGoodHeap $Heap@@41))
))))
(assert (forall ((arg0@@521 T@U) (arg1@@235 T@U) (arg2@@112 T@U) (arg3@@58 T@U) (arg4@@36 T@U) (arg5@@20 T@U) ) (! (= (type (Sequences.__default.FoldFromRight arg0@@521 arg1@@235 arg2@@112 arg3@@58 arg4@@36 arg5@@20)) BoxType)
 :qid |funType:Sequences.__default.FoldFromRight|
 :pattern ( (Sequences.__default.FoldFromRight arg0@@521 arg1@@235 arg2@@112 arg3@@58 arg4@@36 arg5@@20))
)))
(assert (forall ((Sequences._default.FoldFromRight$A T@U) (Sequences._default.FoldFromRight$E T@U) ($ly@@81 T@U) (|f#0@@108| T@U) (|init#0@@13| T@U) (|run#0@@60| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A) TyType) (= (type Sequences._default.FoldFromRight$E) TyType)) (= (type $ly@@81) LayerTypeType)) (= (type |f#0@@108|) HandleTypeType)) (= (type |init#0@@13|) BoxType)) (= (type |run#0@@60|) (SeqType BoxType))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E ($LS $ly@@81) |f#0@@108| |init#0@@13| |run#0@@60|) (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E $ly@@81 |f#0@@108| |init#0@@13| |run#0@@60|)))
 :qid |unknown.0:0|
 :skolemid |3328|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A Sequences._default.FoldFromRight$E ($LS $ly@@81) |f#0@@108| |init#0@@13| |run#0@@60|))
)))
(assert (forall ((Sequences._default.FoldFromRight$A@@0 T@U) (Sequences._default.FoldFromRight$E@@0 T@U) ($ly@@82 T@U) (|f#0@@109| T@U) (|init#0@@14| T@U) (|run#0@@61| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@0) TyType) (= (type Sequences._default.FoldFromRight$E@@0) TyType)) (= (type $ly@@82) LayerTypeType)) (= (type |f#0@@109|) HandleTypeType)) (= (type |init#0@@14|) BoxType)) (= (type |run#0@@61|) (SeqType BoxType))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 $ly@@82 |f#0@@109| |init#0@@14| |run#0@@61|) (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 $LZ |f#0@@109| |init#0@@14| |run#0@@61|)))
 :qid |unknown.0:0|
 :skolemid |3329|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@0 Sequences._default.FoldFromRight$E@@0 (AsFuelBottom $ly@@82) |f#0@@109| |init#0@@14| |run#0@@61|))
)))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@1 T@U) (Sequences._default.FoldFromRight$E@@1 T@U) ($ly@@83 T@U) (|f#0@@110| T@U) (|init#0@@15| T@U) (|run#0@@62| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@1) TyType) (= (type Sequences._default.FoldFromRight$E@@1) TyType)) (= (type $ly@@83) LayerTypeType)) (= (type |f#0@@110|) HandleTypeType)) (= (type |init#0@@15|) BoxType)) (= (type |run#0@@62|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 |f#0@@110| |init#0@@15| |run#0@@62|) (and (and ($Is |f#0@@110| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 Sequences._default.FoldFromRight$A@@1)) ($IsBox |init#0@@15| Sequences._default.FoldFromRight$A@@1)) ($Is |run#0@@62| (TSeq Sequences._default.FoldFromRight$E@@1))))) ($IsBox (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 $ly@@83 |f#0@@110| |init#0@@15| |run#0@@62|) Sequences._default.FoldFromRight$A@@1))
 :qid |unknown.0:0|
 :skolemid |3330|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@1 Sequences._default.FoldFromRight$E@@1 $ly@@83 |f#0@@110| |init#0@@15| |run#0@@62|))
))))
(assert (forall ((Sequences._default.FoldFromRight$A@@2 T@U) (Sequences._default.FoldFromRight$E@@2 T@U) ($ly@@84 T@U) ($Heap@@42 T@U) (|f#0@@111| T@U) (|init#0@@16| T@U) (|run#0@@63| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@2) TyType) (= (type Sequences._default.FoldFromRight$E@@2) TyType)) (= (type $ly@@84) LayerTypeType)) (= (type $Heap@@42) (MapType0Type refType MapType1Type))) (= (type |f#0@@111|) HandleTypeType)) (= (type |init#0@@16|) BoxType)) (= (type |run#0@@63|) (SeqType BoxType))) (and (and (and ($IsGoodHeap $Heap@@42) ($Is |f#0@@111| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 Sequences._default.FoldFromRight$A@@2))) ($IsBox |init#0@@16| Sequences._default.FoldFromRight$A@@2)) ($Is |run#0@@63| (TSeq Sequences._default.FoldFromRight$E@@2)))) (= (|Sequences.__default.FoldFromRight#requires| Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 $ly@@84 |f#0@@111| |init#0@@16| |run#0@@63|) true))
 :qid |unknown.0:0|
 :skolemid |3331|
 :pattern ( (|Sequences.__default.FoldFromRight#requires| Sequences._default.FoldFromRight$A@@2 Sequences._default.FoldFromRight$E@@2 $ly@@84 |f#0@@111| |init#0@@16| |run#0@@63|) ($IsGoodHeap $Heap@@42))
)))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@3 T@U) (Sequences._default.FoldFromRight$E@@3 T@U) ($ly@@85 T@U) ($Heap@@43 T@U) (|f#0@@112| T@U) (|init#0@@17| T@U) (|run#0@@64| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@3) TyType) (= (type Sequences._default.FoldFromRight$E@@3) TyType)) (= (type $ly@@85) LayerTypeType)) (= (type $Heap@@43) (MapType0Type refType MapType1Type))) (= (type |f#0@@112|) HandleTypeType)) (= (type |init#0@@17|) BoxType)) (= (type |run#0@@64|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 |f#0@@112| |init#0@@17| |run#0@@64|) (and (and (and ($IsGoodHeap $Heap@@43) ($Is |f#0@@112| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 Sequences._default.FoldFromRight$A@@3))) ($IsBox |init#0@@17| Sequences._default.FoldFromRight$A@@3)) ($Is |run#0@@64| (TSeq Sequences._default.FoldFromRight$E@@3))))) (and (=> (not (= (|Seq#Length| |run#0@@64|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@3 |run#0@@64|) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 |f#0@@112| |init#0@@17| (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@3 |run#0@@64|))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@3 |run#0@@64|))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 ($LS $ly@@85) |f#0@@112| |init#0@@17| |run#0@@64|) (ite (= (|Seq#Length| |run#0@@64|) (LitInt 0)) |init#0@@17| (Apply2 Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 Sequences._default.FoldFromRight$A@@3 $Heap@@43 |f#0@@112| (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 $ly@@85 |f#0@@112| |init#0@@17| (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@3 |run#0@@64|)) (Sequences.__default.Last Sequences._default.FoldFromRight$E@@3 |run#0@@64|))))))
 :qid |unknown.0:0|
 :skolemid |3332|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@3 Sequences._default.FoldFromRight$E@@3 ($LS $ly@@85) |f#0@@112| |init#0@@17| |run#0@@64|) ($IsGoodHeap $Heap@@43))
))))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@4 T@U) (Sequences._default.FoldFromRight$E@@4 T@U) ($ly@@86 T@U) ($Heap@@44 T@U) (|f#0@@113| T@U) (|init#0@@18| T@U) (|run#0@@65| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@4) TyType) (= (type Sequences._default.FoldFromRight$E@@4) TyType)) (= (type $ly@@86) LayerTypeType)) (= (type $Heap@@44) (MapType0Type refType MapType1Type))) (= (type |f#0@@113|) HandleTypeType)) (= (type |init#0@@18|) BoxType)) (= (type |run#0@@65|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) (and (and (and ($IsGoodHeap $Heap@@44) ($Is |f#0@@113| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 Sequences._default.FoldFromRight$A@@4))) ($IsBox |init#0@@18| Sequences._default.FoldFromRight$A@@4)) ($Is |run#0@@65| (TSeq Sequences._default.FoldFromRight$E@@4))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 |f#0@@113| |init#0@@18| (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|))))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@86) |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) (ite (= (|Seq#Length| (Lit |run#0@@65|)) (LitInt 0)) |init#0@@18| (Apply2 Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 Sequences._default.FoldFromRight$A@@4 $Heap@@44 |f#0@@113| (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@86) |f#0@@113| |init#0@@18| (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|)))) (Lit (Sequences.__default.Last Sequences._default.FoldFromRight$E@@4 (Lit |run#0@@65|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3333|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@4 Sequences._default.FoldFromRight$E@@4 ($LS $ly@@86) |f#0@@113| |init#0@@18| (Lit |run#0@@65|)) ($IsGoodHeap $Heap@@44))
))))
(assert  (=> true (forall ((Sequences._default.FoldFromRight$A@@5 T@U) (Sequences._default.FoldFromRight$E@@5 T@U) ($ly@@87 T@U) ($Heap@@45 T@U) (|f#0@@114| T@U) (|init#0@@19| T@U) (|run#0@@66| T@U) ) (!  (=> (and (and (and (and (and (and (and (= (type Sequences._default.FoldFromRight$A@@5) TyType) (= (type Sequences._default.FoldFromRight$E@@5) TyType)) (= (type $ly@@87) LayerTypeType)) (= (type $Heap@@45) (MapType0Type refType MapType1Type))) (= (type |f#0@@114|) HandleTypeType)) (= (type |init#0@@19|) BoxType)) (= (type |run#0@@66|) (SeqType BoxType))) (or (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) (and (and (and ($IsGoodHeap $Heap@@45) ($Is |f#0@@114| (Tclass._System.___hTotalFunc2 Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 Sequences._default.FoldFromRight$A@@5))) ($IsBox |init#0@@19| Sequences._default.FoldFromRight$A@@5)) ($Is |run#0@@66| (TSeq Sequences._default.FoldFromRight$E@@5))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|)) (|Sequences.__default.FoldFromRight#canCall| Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))) (|Sequences.__default.Last#canCall| Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|)))) (= (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@87) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) (ite (= (|Seq#Length| (Lit |run#0@@66|)) (LitInt 0)) |init#0@@19| (Apply2 Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 Sequences._default.FoldFromRight$A@@5 $Heap@@45 (Lit |f#0@@114|) (Lit (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@87) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit (Sequences.__default.DropLast Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))) (Lit (Sequences.__default.Last Sequences._default.FoldFromRight$E@@5 (Lit |run#0@@66|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3334|
 :pattern ( (Sequences.__default.FoldFromRight Sequences._default.FoldFromRight$A@@5 Sequences._default.FoldFromRight$E@@5 ($LS $ly@@87) (Lit |f#0@@114|) (Lit |init#0@@19|) (Lit |run#0@@66|)) ($IsGoodHeap $Heap@@45))
))))
(assert (forall ((arg0@@522 T@U) (arg1@@236 T@U) ) (! (= (type (Sequences.__default.FoldSets arg0@@522 arg1@@236)) (MapType0Type BoxType boolType))
 :qid |funType:Sequences.__default.FoldSets|
 :pattern ( (Sequences.__default.FoldSets arg0@@522 arg1@@236))
)))
(assert  (=> true (forall ((Sequences._default.FoldSets$E T@U) (|run#0@@67| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E) TyType) (= (type |run#0@@67|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E |run#0@@67|) ($Is |run#0@@67| (TSeq (TSet Sequences._default.FoldSets$E))))) ($Is (Sequences.__default.FoldSets Sequences._default.FoldSets$E |run#0@@67|) (TSet Sequences._default.FoldSets$E)))
 :qid |unknown.0:0|
 :skolemid |3335|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E |run#0@@67|))
))))
(assert (forall ((Sequences._default.FoldSets$E@@0 T@U) (|run#0@@68| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@0) TyType) (= (type |run#0@@68|) (SeqType BoxType))) ($Is |run#0@@68| (TSeq (TSet Sequences._default.FoldSets$E@@0)))) (= (|Sequences.__default.FoldSets#requires| Sequences._default.FoldSets$E@@0 |run#0@@68|) true))
 :qid |unknown.0:0|
 :skolemid |3336|
 :pattern ( (|Sequences.__default.FoldSets#requires| Sequences._default.FoldSets$E@@0 |run#0@@68|))
)))
(assert  (and (and (= (type |lambda#164|) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType BoxType)) (forall ((arg0@@523 T@U) (arg1@@237 T@U) ) (! (= (type (|lambda#165| arg0@@523 arg1@@237)) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType boolType))
 :qid |funType:lambda#165|
 :pattern ( (|lambda#165| arg0@@523 arg1@@237))
))) (forall ((arg0@@524 T@U) ) (! (= (type (|lambda#167| arg0@@524)) (MapType3Type (MapType0Type refType MapType1Type) BoxType BoxType (MapType0Type BoxType boolType)))
 :qid |funType:lambda#167|
 :pattern ( (|lambda#167| arg0@@524))
))))
(assert  (=> true (forall ((Sequences._default.FoldSets$E@@1 T@U) (|run#0@@69| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@1) TyType) (= (type |run#0@@69|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E@@1 |run#0@@69|) ($Is |run#0@@69| (TSeq (TSet Sequences._default.FoldSets$E@@1))))) (and (|Sequences.__default.FoldRight#canCall| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1) (Lit (AtLayer (|lambda#131| (Handle2 |lambda#164| (|lambda#165| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1)) (|lambda#167| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) |run#0@@69|) (= (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@1 |run#0@@69|) ($Unbox (MapType0Type BoxType boolType) (Sequences.__default.FoldRight (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1) ($LS $LZ) (Lit (AtLayer (|lambda#131| (Handle2 |lambda#164| (|lambda#165| (TSet Sequences._default.FoldSets$E@@1) (TSet Sequences._default.FoldSets$E@@1)) (|lambda#167| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) |run#0@@69|)))))
 :qid |unknown.0:0|
 :skolemid |3337|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@1 |run#0@@69|))
))))
(assert  (=> true (forall ((Sequences._default.FoldSets$E@@2 T@U) (|run#0@@70| T@U) ) (!  (=> (and (and (= (type Sequences._default.FoldSets$E@@2) TyType) (= (type |run#0@@70|) (SeqType BoxType))) (or (|Sequences.__default.FoldSets#canCall| Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)) ($Is |run#0@@70| (TSeq (TSet Sequences._default.FoldSets$E@@2))))) (and (|Sequences.__default.FoldRight#canCall| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2) (Lit (AtLayer (|lambda#131| (Handle2 |lambda#164| (|lambda#165| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2)) (|lambda#167| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) (Lit |run#0@@70|)) (= (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)) (Lit ($Unbox (MapType0Type BoxType boolType) (Sequences.__default.FoldRight (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2) ($LS $LZ) (Lit (AtLayer (|lambda#131| (Handle2 |lambda#164| (|lambda#165| (TSet Sequences._default.FoldSets$E@@2) (TSet Sequences._default.FoldSets$E@@2)) (|lambda#167| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))) ($Box (Lit (|Set#Empty| BoxType))) (Lit |run#0@@70|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3338|
 :pattern ( (Sequences.__default.FoldSets Sequences._default.FoldSets$E@@2 (Lit |run#0@@70|)))
))))
(assert (forall ((arg0@@525 T@U) (arg1@@238 T@U) (arg2@@113 T@U) (arg3@@59 Int) ) (! (= (type (Sequences.__default.remove arg0@@525 arg1@@238 arg2@@113 arg3@@59)) (SeqType BoxType))
 :qid |funType:Sequences.__default.remove|
 :pattern ( (Sequences.__default.remove arg0@@525 arg1@@238 arg2@@113 arg3@@59))
)))
(assert (forall ((Sequences._default.remove$A T@U) ($ly@@88 T@U) (|s#0@@56| T@U) (|pos#0| Int) ) (!  (=> (and (and (= (type Sequences._default.remove$A) TyType) (= (type $ly@@88) LayerTypeType)) (= (type |s#0@@56|) (SeqType BoxType))) (= (Sequences.__default.remove Sequences._default.remove$A ($LS $ly@@88) |s#0@@56| |pos#0|) (Sequences.__default.remove Sequences._default.remove$A $ly@@88 |s#0@@56| |pos#0|)))
 :qid |unknown.0:0|
 :skolemid |3339|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A ($LS $ly@@88) |s#0@@56| |pos#0|))
)))
(assert (forall ((Sequences._default.remove$A@@0 T@U) ($ly@@89 T@U) (|s#0@@57| T@U) (|pos#0@@0| Int) ) (!  (=> (and (and (= (type Sequences._default.remove$A@@0) TyType) (= (type $ly@@89) LayerTypeType)) (= (type |s#0@@57|) (SeqType BoxType))) (= (Sequences.__default.remove Sequences._default.remove$A@@0 $ly@@89 |s#0@@57| |pos#0@@0|) (Sequences.__default.remove Sequences._default.remove$A@@0 $LZ |s#0@@57| |pos#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3340|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@0 (AsFuelBottom $ly@@89) |s#0@@57| |pos#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.remove$A@@1 T@U) ($ly@@90 T@U) (|s#0@@58| T@U) (|pos#0@@1| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@1) TyType) (= (type $ly@@90) LayerTypeType)) (= (type |s#0@@58|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@1 |s#0@@58| |pos#0@@1|) (and ($Is |s#0@@58| (TSeq Sequences._default.remove$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@1|) (INTERNAL_lt_boogie |pos#0@@1| (|Seq#Length| |s#0@@58|)))))) (and (and (and (= (|Seq#Length| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|)) (INTERNAL_sub_boogie (|Seq#Length| |s#0@@58|) 1)) (forall ((|i#0@@98| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@98|) (INTERNAL_lt_boogie |i#0@@98| |pos#0@@1|)) (= (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|) |i#0@@98|) (|Seq#Index| |s#0@@58| |i#0@@98|)))
 :qid |Sequencesidfy.369:18|
 :skolemid |3341|
 :pattern ( (|Seq#Index| |s#0@@58| |i#0@@98|))
 :pattern ( (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|) |i#0@@98|))
))) (forall ((|i#1@@26| Int) ) (!  (=> (and (INTERNAL_le_boogie |pos#0@@1| |i#1@@26|) (INTERNAL_lt_boogie |i#1@@26| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@58|) 1))) (= (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|) |i#1@@26|) (|Seq#Index| |s#0@@58| (INTERNAL_add_boogie |i#1@@26| 1))))
 :qid |Sequencesidfy.370:18|
 :skolemid |3342|
 :pattern ( (|Seq#Index| |s#0@@58| (INTERNAL_add_boogie |i#1@@26| 1)))
 :pattern ( (|Seq#Index| (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|) |i#1@@26|))
))) ($Is (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|) (TSeq Sequences._default.remove$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3343|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@1 $ly@@90 |s#0@@58| |pos#0@@1|))
))))
(assert (forall ((Sequences._default.remove$A@@2 T@U) ($ly@@91 T@U) (|s#0@@59| T@U) (|pos#0@@2| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@2) TyType) (= (type $ly@@91) LayerTypeType)) (= (type |s#0@@59|) (SeqType BoxType))) ($Is |s#0@@59| (TSeq Sequences._default.remove$A@@2))) (= (|Sequences.__default.remove#requires| Sequences._default.remove$A@@2 $ly@@91 |s#0@@59| |pos#0@@2|)  (and (INTERNAL_le_boogie 0 |pos#0@@2|) (INTERNAL_lt_boogie |pos#0@@2| (|Seq#Length| |s#0@@59|)))))
 :qid |unknown.0:0|
 :skolemid |3344|
 :pattern ( (|Sequences.__default.remove#requires| Sequences._default.remove$A@@2 $ly@@91 |s#0@@59| |pos#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.remove$A@@3 T@U) ($ly@@92 T@U) (|s#0@@60| T@U) (|pos#0@@3| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@3) TyType) (= (type $ly@@92) LayerTypeType)) (= (type |s#0@@60|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@3 |s#0@@60| |pos#0@@3|) (and ($Is |s#0@@60| (TSeq Sequences._default.remove$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@3|) (INTERNAL_lt_boogie |pos#0@@3| (|Seq#Length| |s#0@@60|)))))) (= (Sequences.__default.remove Sequences._default.remove$A@@3 ($LS $ly@@92) |s#0@@60| |pos#0@@3|) (|Seq#Append| (|Seq#Take| |s#0@@60| |pos#0@@3|) (|Seq#Drop| |s#0@@60| (INTERNAL_add_boogie |pos#0@@3| 1)))))
 :qid |unknown.0:0|
 :skolemid |3345|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@3 ($LS $ly@@92) |s#0@@60| |pos#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.remove$A@@4 T@U) ($ly@@93 T@U) (|s#0@@61| T@U) (|pos#0@@4| Int) ) (!  (=> (and (and (and (= (type Sequences._default.remove$A@@4) TyType) (= (type $ly@@93) LayerTypeType)) (= (type |s#0@@61|) (SeqType BoxType))) (or (|Sequences.__default.remove#canCall| Sequences._default.remove$A@@4 (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (and ($Is |s#0@@61| (TSeq Sequences._default.remove$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@4|) (INTERNAL_lt_boogie |pos#0@@4| (|Seq#Length| (Lit |s#0@@61|))))))) (= (Sequences.__default.remove Sequences._default.remove$A@@4 ($LS $ly@@93) (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (|Seq#Append| (|Seq#Take| (Lit |s#0@@61|) (LitInt |pos#0@@4|)) (|Seq#Drop| (Lit |s#0@@61|) (LitInt (INTERNAL_add_boogie |pos#0@@4| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3346|
 :pattern ( (Sequences.__default.remove Sequences._default.remove$A@@4 ($LS $ly@@93) (Lit |s#0@@61|) (LitInt |pos#0@@4|)))
))))
(assert (forall ((arg0@@526 T@U) (arg1@@239 T@U) (arg2@@114 T@U) (arg3@@60 T@U) ) (! (= (type (Sequences.__default.RemoveOneValue arg0@@526 arg1@@239 arg2@@114 arg3@@60)) (SeqType BoxType))
 :qid |funType:Sequences.__default.RemoveOneValue|
 :pattern ( (Sequences.__default.RemoveOneValue arg0@@526 arg1@@239 arg2@@114 arg3@@60))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V T@U) ($ly@@94 T@U) (|s#0@@62| T@U) (|v#0@@61| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V) TyType) (= (type $ly@@94) LayerTypeType)) (= (type |s#0@@62|) (SeqType BoxType))) (= (type |v#0@@61|) BoxType)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V ($LS $ly@@94) |s#0@@62| |v#0@@61|) (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V $ly@@94 |s#0@@62| |v#0@@61|)))
 :qid |unknown.0:0|
 :skolemid |3347|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V ($LS $ly@@94) |s#0@@62| |v#0@@61|))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@0 T@U) ($ly@@95 T@U) (|s#0@@63| T@U) (|v#0@@62| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V@@0) TyType) (= (type $ly@@95) LayerTypeType)) (= (type |s#0@@63|) (SeqType BoxType))) (= (type |v#0@@62|) BoxType)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 $ly@@95 |s#0@@63| |v#0@@62|) (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 $LZ |s#0@@63| |v#0@@62|)))
 :qid |unknown.0:0|
 :skolemid |3348|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@0 (AsFuelBottom $ly@@95) |s#0@@63| |v#0@@62|))
)))
(assert (= (type StartFuel_Sequences._default.NoDupes) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@1 T@U) ($ly@@96 T@U) (|s#0@@64| T@U) (|v#0@@63| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@1) TyType) (= (type $ly@@96) LayerTypeType)) (= (type |s#0@@64|) (SeqType BoxType))) (= (type |v#0@@63|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@1 |s#0@@64| |v#0@@63|) (and ($Is |s#0@@64| (TSeq Sequences._default.RemoveOneValue$V@@1)) ($IsBox |v#0@@63| Sequences._default.RemoveOneValue$V@@1)))) (and (=> (Sequences.__default.NoDupes Sequences._default.RemoveOneValue$V@@1 StartFuel_Sequences._default.NoDupes |s#0@@64|) (and (Sequences.__default.NoDupes Sequences._default.RemoveOneValue$V@@1 StartFuel_Sequences._default.NoDupes (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@96 |s#0@@64| |v#0@@63|)) (|Set#Equal| (Sequences.__default.Set Sequences._default.RemoveOneValue$V@@1 (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@96 |s#0@@64| |v#0@@63|)) (|Set#Difference| (Sequences.__default.Set Sequences._default.RemoveOneValue$V@@1 |s#0@@64|) (|Set#UnionOne| (|Set#Empty| BoxType) |v#0@@63|))))) ($Is (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@96 |s#0@@64| |v#0@@63|) (TSeq Sequences._default.RemoveOneValue$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3349|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@1 $ly@@96 |s#0@@64| |v#0@@63|))
))))
(assert (forall ((Sequences._default.RemoveOneValue$V@@2 T@U) ($ly@@97 T@U) ($Heap@@46 T@U) (|s#0@@65| T@U) (|v#0@@64| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@2) TyType) (= (type $ly@@97) LayerTypeType)) (= (type $Heap@@46) (MapType0Type refType MapType1Type))) (= (type |s#0@@65|) (SeqType BoxType))) (= (type |v#0@@64|) BoxType)) (and (and ($IsGoodHeap $Heap@@46) ($Is |s#0@@65| (TSeq Sequences._default.RemoveOneValue$V@@2))) ($IsBox |v#0@@64| Sequences._default.RemoveOneValue$V@@2))) (= (|Sequences.__default.RemoveOneValue#requires| Sequences._default.RemoveOneValue$V@@2 $ly@@97 |s#0@@65| |v#0@@64|) true))
 :qid |unknown.0:0|
 :skolemid |3350|
 :pattern ( (|Sequences.__default.RemoveOneValue#requires| Sequences._default.RemoveOneValue$V@@2 $ly@@97 |s#0@@65| |v#0@@64|) ($IsGoodHeap $Heap@@46))
)))
(assert (forall ((Sequences._default.RemoveOneValue$V@@3 T@U) (s@@50 T@U) (v@@52 T@U) ) (!  (=> (and (and (and (= (type Sequences._default.RemoveOneValue$V@@3) TyType) (= (type s@@50) (SeqType BoxType))) (= (type v@@52) BoxType)) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) (and (and (INTERNAL_le_boogie 0 (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) (INTERNAL_lt_boogie (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52) (|Seq#Length| s@@50))) (= (|Seq#Index| s@@50 (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52)) v@@52)))
 :qid |Sequencesidfy.380:5|
 :skolemid |3351|
 :pattern ( (|$let#4_i| Sequences._default.RemoveOneValue$V@@3 s@@50 v@@52))
)))
(assert  (and (= (type MoreFuel_Sequences._default.NoDupes0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.NoDupes) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@4 T@U) ($ly@@98 T@U) ($Heap@@47 T@U) (|s#0@@66| T@U) (|v#0@@65| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@4) TyType) (= (type $ly@@98) LayerTypeType)) (= (type $Heap@@47) (MapType0Type refType MapType1Type))) (= (type |s#0@@66|) (SeqType BoxType))) (= (type |v#0@@65|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@65|) (and (and ($IsGoodHeap $Heap@@47) ($Is |s#0@@66| (TSeq Sequences._default.RemoveOneValue$V@@4))) ($IsBox |v#0@@65| Sequences._default.RemoveOneValue$V@@4)))) (and (=> (|Seq#Contains| |s#0@@66| |v#0@@65|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@65|)) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes0)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes0)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes0) MoreFuel_Sequences._default.NoDupes0)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@4 ($LS $ly@@98) |s#0@@66| |v#0@@65|) (ite  (not (|Seq#Contains| |s#0@@66| |v#0@@65|)) |s#0@@66| (let ((|i#0@@99| (|$let#4_i| Sequences._default.RemoveOneValue$V@@4 |s#0@@66| |v#0@@65|)))
(|Seq#Append| (|Seq#Take| |s#0@@66| |i#0@@99|) (|Seq#Drop| |s#0@@66| (INTERNAL_add_boogie |i#0@@99| 1)))))))))
 :qid |unknown.0:0|
 :skolemid |3352|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@4 ($LS $ly@@98) |s#0@@66| |v#0@@65|) ($IsGoodHeap $Heap@@47))
))))
(assert (= (type MoreFuel_Sequences._default.NoDupes1) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@5 T@U) ($ly@@99 T@U) ($Heap@@48 T@U) (|s#0@@67| T@U) (|v#0@@66| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@5) TyType) (= (type $ly@@99) LayerTypeType)) (= (type $Heap@@48) (MapType0Type refType MapType1Type))) (= (type |s#0@@67|) (SeqType BoxType))) (= (type |v#0@@66|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@66|) (and (and ($IsGoodHeap $Heap@@48) ($Is |s#0@@67| (TSeq Sequences._default.RemoveOneValue$V@@5))) ($IsBox |v#0@@66| Sequences._default.RemoveOneValue$V@@5)))) (and (=> (|Seq#Contains| |s#0@@67| |v#0@@66|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@66|)) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes1)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes1)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes1) MoreFuel_Sequences._default.NoDupes1)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@5 ($LS $ly@@99) (Lit |s#0@@67|) |v#0@@66|) (ite  (not (|Seq#Contains| |s#0@@67| |v#0@@66|)) |s#0@@67| (let ((|i#1@@27| (|$let#4_i| Sequences._default.RemoveOneValue$V@@5 (Lit |s#0@@67|) |v#0@@66|)))
(|Seq#Append| (|Seq#Take| (Lit |s#0@@67|) |i#1@@27|) (|Seq#Drop| (Lit |s#0@@67|) (INTERNAL_add_boogie |i#1@@27| 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3353|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@5 ($LS $ly@@99) (Lit |s#0@@67|) |v#0@@66|) ($IsGoodHeap $Heap@@48))
))))
(assert (= (type MoreFuel_Sequences._default.NoDupes2) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.RemoveOneValue$V@@6 T@U) ($ly@@100 T@U) ($Heap@@49 T@U) (|s#0@@68| T@U) (|v#0@@67| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.RemoveOneValue$V@@6) TyType) (= (type $ly@@100) LayerTypeType)) (= (type $Heap@@49) (MapType0Type refType MapType1Type))) (= (type |s#0@@68|) (SeqType BoxType))) (= (type |v#0@@67|) BoxType)) (or (|Sequences.__default.RemoveOneValue#canCall| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@67|)) (and (and ($IsGoodHeap $Heap@@49) ($Is |s#0@@68| (TSeq Sequences._default.RemoveOneValue$V@@6))) ($IsBox |v#0@@67| Sequences._default.RemoveOneValue$V@@6)))) (and (=> (|Seq#Contains| |s#0@@68| |v#0@@67|) (|$let#4$canCall| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@67|))) (and (and (and (= StartFuel_Sequences._default.NoDupes ($LS MoreFuel_Sequences._default.NoDupes2)) (= StartFuelAssert_Sequences._default.NoDupes ($LS ($LS MoreFuel_Sequences._default.NoDupes2)))) (= (AsFuelBottom MoreFuel_Sequences._default.NoDupes2) MoreFuel_Sequences._default.NoDupes2)) (= (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@6 ($LS $ly@@100) (Lit |s#0@@68|) (Lit |v#0@@67|)) (ite  (not (|Seq#Contains| |s#0@@68| |v#0@@67|)) |s#0@@68| (let ((|i#2@@11| (|$let#4_i| Sequences._default.RemoveOneValue$V@@6 (Lit |s#0@@68|) (Lit |v#0@@67|))))
(|Seq#Append| (|Seq#Take| (Lit |s#0@@68|) |i#2@@11|) (|Seq#Drop| (Lit |s#0@@68|) (INTERNAL_add_boogie |i#2@@11| 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3354|
 :pattern ( (Sequences.__default.RemoveOneValue Sequences._default.RemoveOneValue$V@@6 ($LS $ly@@100) (Lit |s#0@@68|) (Lit |v#0@@67|)) ($IsGoodHeap $Heap@@49))
))))
(assert (forall ((arg0@@527 T@U) (arg1@@240 T@U) (arg2@@115 T@U) (arg3@@61 T@U) (arg4@@37 Int) ) (! (= (type (Sequences.__default.insert arg0@@527 arg1@@240 arg2@@115 arg3@@61 arg4@@37)) (SeqType BoxType))
 :qid |funType:Sequences.__default.insert|
 :pattern ( (Sequences.__default.insert arg0@@527 arg1@@240 arg2@@115 arg3@@61 arg4@@37))
)))
(assert (forall ((Sequences._default.insert$A T@U) ($ly@@101 T@U) (|s#0@@69| T@U) (|a#0@@27| T@U) (|pos#0@@5| Int) ) (!  (=> (and (and (and (= (type Sequences._default.insert$A) TyType) (= (type $ly@@101) LayerTypeType)) (= (type |s#0@@69|) (SeqType BoxType))) (= (type |a#0@@27|) BoxType)) (= (Sequences.__default.insert Sequences._default.insert$A ($LS $ly@@101) |s#0@@69| |a#0@@27| |pos#0@@5|) (Sequences.__default.insert Sequences._default.insert$A $ly@@101 |s#0@@69| |a#0@@27| |pos#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |3355|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A ($LS $ly@@101) |s#0@@69| |a#0@@27| |pos#0@@5|))
)))
(assert (forall ((Sequences._default.insert$A@@0 T@U) ($ly@@102 T@U) (|s#0@@70| T@U) (|a#0@@28| T@U) (|pos#0@@6| Int) ) (!  (=> (and (and (and (= (type Sequences._default.insert$A@@0) TyType) (= (type $ly@@102) LayerTypeType)) (= (type |s#0@@70|) (SeqType BoxType))) (= (type |a#0@@28|) BoxType)) (= (Sequences.__default.insert Sequences._default.insert$A@@0 $ly@@102 |s#0@@70| |a#0@@28| |pos#0@@6|) (Sequences.__default.insert Sequences._default.insert$A@@0 $LZ |s#0@@70| |a#0@@28| |pos#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3356|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@0 (AsFuelBottom $ly@@102) |s#0@@70| |a#0@@28| |pos#0@@6|))
)))
(assert  (=> true (forall ((Sequences._default.insert$A@@1 T@U) ($ly@@103 T@U) (|s#0@@71| T@U) (|a#0@@29| T@U) (|pos#0@@7| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@1) TyType) (= (type $ly@@103) LayerTypeType)) (= (type |s#0@@71|) (SeqType BoxType))) (= (type |a#0@@29|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@1 |s#0@@71| |a#0@@29| |pos#0@@7|) (and (and ($Is |s#0@@71| (TSeq Sequences._default.insert$A@@1)) ($IsBox |a#0@@29| Sequences._default.insert$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@7|) (INTERNAL_le_boogie |pos#0@@7| (|Seq#Length| |s#0@@71|)))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|)) (INTERNAL_add_boogie (|Seq#Length| |s#0@@71|) 1)) (forall ((|i#0@@100| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@100|) (INTERNAL_lt_boogie |i#0@@100| |pos#0@@7|)) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) |i#0@@100|) (|Seq#Index| |s#0@@71| |i#0@@100|))))
 :qid |Sequencesidfy.387:18|
 :skolemid |3357|
 :pattern ( (|Seq#Index| |s#0@@71| |i#0@@100|))
 :pattern ( (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) |i#0@@100|))
))) (forall ((|i#1@@28| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie |pos#0@@7| |i#1@@28|) (INTERNAL_lt_boogie |i#1@@28| (|Seq#Length| |s#0@@71|))) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) (INTERNAL_add_boogie |i#1@@28| 1)) (|Seq#Index| |s#0@@71| |i#1@@28|))))
 :qid |Sequencesidfy.388:18|
 :skolemid |3358|
 :pattern ( (|Seq#Index| |s#0@@71| |i#1@@28|))
 :pattern ( (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) (INTERNAL_add_boogie |i#1@@28| 1)))
))) (= (|Seq#Index| (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) |pos#0@@7|) |a#0@@29|)) ($Is (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|) (TSeq Sequences._default.insert$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3359|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@1 $ly@@103 |s#0@@71| |a#0@@29| |pos#0@@7|))
))))
(assert (forall ((Sequences._default.insert$A@@2 T@U) ($ly@@104 T@U) (|s#0@@72| T@U) (|a#0@@30| T@U) (|pos#0@@8| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@2) TyType) (= (type $ly@@104) LayerTypeType)) (= (type |s#0@@72|) (SeqType BoxType))) (= (type |a#0@@30|) BoxType)) (and ($Is |s#0@@72| (TSeq Sequences._default.insert$A@@2)) ($IsBox |a#0@@30| Sequences._default.insert$A@@2))) (= (|Sequences.__default.insert#requires| Sequences._default.insert$A@@2 $ly@@104 |s#0@@72| |a#0@@30| |pos#0@@8|)  (and (INTERNAL_le_boogie 0 |pos#0@@8|) (INTERNAL_le_boogie |pos#0@@8| (|Seq#Length| |s#0@@72|)))))
 :qid |unknown.0:0|
 :skolemid |3360|
 :pattern ( (|Sequences.__default.insert#requires| Sequences._default.insert$A@@2 $ly@@104 |s#0@@72| |a#0@@30| |pos#0@@8|))
)))
(assert  (=> true (forall ((Sequences._default.insert$A@@3 T@U) ($ly@@105 T@U) (|s#0@@73| T@U) (|a#0@@31| T@U) (|pos#0@@9| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@3) TyType) (= (type $ly@@105) LayerTypeType)) (= (type |s#0@@73|) (SeqType BoxType))) (= (type |a#0@@31|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@3 |s#0@@73| |a#0@@31| |pos#0@@9|) (and (and ($Is |s#0@@73| (TSeq Sequences._default.insert$A@@3)) ($IsBox |a#0@@31| Sequences._default.insert$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@9|) (INTERNAL_le_boogie |pos#0@@9| (|Seq#Length| |s#0@@73|)))))) (= (Sequences.__default.insert Sequences._default.insert$A@@3 ($LS $ly@@105) |s#0@@73| |a#0@@31| |pos#0@@9|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@73| |pos#0@@9|) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@31|)) (|Seq#Drop| |s#0@@73| |pos#0@@9|))))
 :qid |unknown.0:0|
 :skolemid |3361|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@3 ($LS $ly@@105) |s#0@@73| |a#0@@31| |pos#0@@9|))
))))
(assert  (=> true (forall ((Sequences._default.insert$A@@4 T@U) ($ly@@106 T@U) (|s#0@@74| T@U) (|a#0@@32| T@U) (|pos#0@@10| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@4) TyType) (= (type $ly@@106) LayerTypeType)) (= (type |s#0@@74|) (SeqType BoxType))) (= (type |a#0@@32|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@4 (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)) (and (and ($Is |s#0@@74| (TSeq Sequences._default.insert$A@@4)) ($IsBox |a#0@@32| Sequences._default.insert$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@10|) (INTERNAL_le_boogie |pos#0@@10| (|Seq#Length| (Lit |s#0@@74|))))))) (= (Sequences.__default.insert Sequences._default.insert$A@@4 ($LS $ly@@106) (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@74|) (LitInt |pos#0@@10|)) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@32|)) (|Seq#Drop| (Lit |s#0@@74|) (LitInt |pos#0@@10|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3362|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@4 ($LS $ly@@106) (Lit |s#0@@74|) |a#0@@32| (LitInt |pos#0@@10|)))
))))
(assert  (=> true (forall ((Sequences._default.insert$A@@5 T@U) ($ly@@107 T@U) (|s#0@@75| T@U) (|a#0@@33| T@U) (|pos#0@@11| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.insert$A@@5) TyType) (= (type $ly@@107) LayerTypeType)) (= (type |s#0@@75|) (SeqType BoxType))) (= (type |a#0@@33|) BoxType)) (or (|Sequences.__default.insert#canCall| Sequences._default.insert$A@@5 (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)) (and (and ($Is |s#0@@75| (TSeq Sequences._default.insert$A@@5)) ($IsBox |a#0@@33| Sequences._default.insert$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@11|) (INTERNAL_le_boogie |pos#0@@11| (|Seq#Length| (Lit |s#0@@75|))))))) (= (Sequences.__default.insert Sequences._default.insert$A@@5 ($LS $ly@@107) (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@75|) (LitInt |pos#0@@11|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@33|))) (|Seq#Drop| (Lit |s#0@@75|) (LitInt |pos#0@@11|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3363|
 :pattern ( (Sequences.__default.insert Sequences._default.insert$A@@5 ($LS $ly@@107) (Lit |s#0@@75|) (Lit |a#0@@33|) (LitInt |pos#0@@11|)))
))))
(assert (forall ((Sequences._default.replace1with2$A T@U) ($ly@@108 T@U) (|s#0@@76| T@U) (|a#0@@34| T@U) (|b#0@@9| T@U) (|pos#0@@12| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace1with2$A) TyType) (= (type $ly@@108) LayerTypeType)) (= (type |s#0@@76|) (SeqType BoxType))) (= (type |a#0@@34|) BoxType)) (= (type |b#0@@9|) BoxType)) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A ($LS $ly@@108) |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|) (Sequences.__default.replace1with2 Sequences._default.replace1with2$A $ly@@108 |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |3364|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A ($LS $ly@@108) |s#0@@76| |a#0@@34| |b#0@@9| |pos#0@@12|))
)))
(assert (forall ((Sequences._default.replace1with2$A@@0 T@U) ($ly@@109 T@U) (|s#0@@77| T@U) (|a#0@@35| T@U) (|b#0@@10| T@U) (|pos#0@@13| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace1with2$A@@0) TyType) (= (type $ly@@109) LayerTypeType)) (= (type |s#0@@77|) (SeqType BoxType))) (= (type |a#0@@35|) BoxType)) (= (type |b#0@@10|) BoxType)) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 $ly@@109 |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|) (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 $LZ |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|)))
 :qid |unknown.0:0|
 :skolemid |3365|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@0 (AsFuelBottom $ly@@109) |s#0@@77| |a#0@@35| |b#0@@10| |pos#0@@13|))
)))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@1 T@U) ($ly@@110 T@U) (|s#0@@78| T@U) (|a#0@@36| T@U) (|b#0@@11| T@U) (|pos#0@@14| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@1) TyType) (= (type $ly@@110) LayerTypeType)) (= (type |s#0@@78|) (SeqType BoxType))) (= (type |a#0@@36|) BoxType)) (= (type |b#0@@11|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@1 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (and (and (and ($Is |s#0@@78| (TSeq Sequences._default.replace1with2$A@@1)) ($IsBox |a#0@@36| Sequences._default.replace1with2$A@@1)) ($IsBox |b#0@@11| Sequences._default.replace1with2$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@14|) (INTERNAL_lt_boogie |pos#0@@14| (|Seq#Length| |s#0@@78|)))))) (and (and (and (and (and (= (|Seq#Length| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|)) (INTERNAL_add_boogie (|Seq#Length| |s#0@@78|) 1)) (forall ((|i#0@@101| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@101|) (INTERNAL_lt_boogie |i#0@@101| |pos#0@@14|)) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |i#0@@101|) (|Seq#Index| |s#0@@78| |i#0@@101|))))
 :qid |Sequencesidfy.412:18|
 :skolemid |3366|
 :pattern ( (|Seq#Index| |s#0@@78| |i#0@@101|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |i#0@@101|))
))) (forall ((|i#1@@29| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie |pos#0@@14| |i#1@@29|) (INTERNAL_lt_boogie |i#1@@29| (|Seq#Length| |s#0@@78|))) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |i#1@@29| 1)) (|Seq#Index| |s#0@@78| |i#1@@29|))))
 :qid |Sequencesidfy.413:18|
 :skolemid |3367|
 :pattern ( (|Seq#Index| |s#0@@78| |i#1@@29|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |i#1@@29| 1)))
))) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) |pos#0@@14|) |a#0@@36|)) (= (|Seq#Index| (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (INTERNAL_add_boogie |pos#0@@14| 1)) |b#0@@11|)) ($Is (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|) (TSeq Sequences._default.replace1with2$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3368|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@1 $ly@@110 |s#0@@78| |a#0@@36| |b#0@@11| |pos#0@@14|))
))))
(assert (forall ((Sequences._default.replace1with2$A@@2 T@U) ($ly@@111 T@U) (|s#0@@79| T@U) (|a#0@@37| T@U) (|b#0@@12| T@U) (|pos#0@@15| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@2) TyType) (= (type $ly@@111) LayerTypeType)) (= (type |s#0@@79|) (SeqType BoxType))) (= (type |a#0@@37|) BoxType)) (= (type |b#0@@12|) BoxType)) (and (and ($Is |s#0@@79| (TSeq Sequences._default.replace1with2$A@@2)) ($IsBox |a#0@@37| Sequences._default.replace1with2$A@@2)) ($IsBox |b#0@@12| Sequences._default.replace1with2$A@@2))) (= (|Sequences.__default.replace1with2#requires| Sequences._default.replace1with2$A@@2 $ly@@111 |s#0@@79| |a#0@@37| |b#0@@12| |pos#0@@15|)  (and (INTERNAL_le_boogie 0 |pos#0@@15|) (INTERNAL_lt_boogie |pos#0@@15| (|Seq#Length| |s#0@@79|)))))
 :qid |unknown.0:0|
 :skolemid |3369|
 :pattern ( (|Sequences.__default.replace1with2#requires| Sequences._default.replace1with2$A@@2 $ly@@111 |s#0@@79| |a#0@@37| |b#0@@12| |pos#0@@15|))
)))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@3 T@U) ($ly@@112 T@U) (|s#0@@80| T@U) (|a#0@@38| T@U) (|b#0@@13| T@U) (|pos#0@@16| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@3) TyType) (= (type $ly@@112) LayerTypeType)) (= (type |s#0@@80|) (SeqType BoxType))) (= (type |a#0@@38|) BoxType)) (= (type |b#0@@13|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@3 |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|) (and (and (and ($Is |s#0@@80| (TSeq Sequences._default.replace1with2$A@@3)) ($IsBox |a#0@@38| Sequences._default.replace1with2$A@@3)) ($IsBox |b#0@@13| Sequences._default.replace1with2$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@16|) (INTERNAL_lt_boogie |pos#0@@16| (|Seq#Length| |s#0@@80|)))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@3 ($LS $ly@@112) |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@80| |pos#0@@16|) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@38|) |b#0@@13|)) (|Seq#Drop| |s#0@@80| (INTERNAL_add_boogie |pos#0@@16| 1)))))
 :qid |unknown.0:0|
 :skolemid |3370|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@3 ($LS $ly@@112) |s#0@@80| |a#0@@38| |b#0@@13| |pos#0@@16|))
))))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@4 T@U) ($ly@@113 T@U) (|s#0@@81| T@U) (|a#0@@39| T@U) (|b#0@@14| T@U) (|pos#0@@17| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@4) TyType) (= (type $ly@@113) LayerTypeType)) (= (type |s#0@@81|) (SeqType BoxType))) (= (type |a#0@@39|) BoxType)) (= (type |b#0@@14|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@4 (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)) (and (and (and ($Is |s#0@@81| (TSeq Sequences._default.replace1with2$A@@4)) ($IsBox |a#0@@39| Sequences._default.replace1with2$A@@4)) ($IsBox |b#0@@14| Sequences._default.replace1with2$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@17|) (INTERNAL_lt_boogie |pos#0@@17| (|Seq#Length| (Lit |s#0@@81|))))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@4 ($LS $ly@@113) (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@81|) (LitInt |pos#0@@17|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@39|) |b#0@@14|)) (|Seq#Drop| (Lit |s#0@@81|) (LitInt (INTERNAL_add_boogie |pos#0@@17| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3371|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@4 ($LS $ly@@113) (Lit |s#0@@81|) |a#0@@39| |b#0@@14| (LitInt |pos#0@@17|)))
))))
(assert  (=> true (forall ((Sequences._default.replace1with2$A@@5 T@U) ($ly@@114 T@U) (|s#0@@82| T@U) (|a#0@@40| T@U) (|b#0@@15| T@U) (|pos#0@@18| Int) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.replace1with2$A@@5) TyType) (= (type $ly@@114) LayerTypeType)) (= (type |s#0@@82|) (SeqType BoxType))) (= (type |a#0@@40|) BoxType)) (= (type |b#0@@15|) BoxType)) (or (|Sequences.__default.replace1with2#canCall| Sequences._default.replace1with2$A@@5 (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)) (and (and (and ($Is |s#0@@82| (TSeq Sequences._default.replace1with2$A@@5)) ($IsBox |a#0@@40| Sequences._default.replace1with2$A@@5)) ($IsBox |b#0@@15| Sequences._default.replace1with2$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@18|) (INTERNAL_lt_boogie |pos#0@@18| (|Seq#Length| (Lit |s#0@@82|))))))) (= (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@5 ($LS $ly@@114) (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@82|) (LitInt |pos#0@@18|)) (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@40|)) (Lit |b#0@@15|))) (|Seq#Drop| (Lit |s#0@@82|) (LitInt (INTERNAL_add_boogie |pos#0@@18| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3372|
 :pattern ( (Sequences.__default.replace1with2 Sequences._default.replace1with2$A@@5 ($LS $ly@@114) (Lit |s#0@@82|) (Lit |a#0@@40|) (Lit |b#0@@15|) (LitInt |pos#0@@18|)))
))))
(assert (forall ((arg0@@528 T@U) (arg1@@241 T@U) (arg2@@116 T@U) (arg3@@62 T@U) (arg4@@38 Int) ) (! (= (type (Sequences.__default.replace2with1 arg0@@528 arg1@@241 arg2@@116 arg3@@62 arg4@@38)) (SeqType BoxType))
 :qid |funType:Sequences.__default.replace2with1|
 :pattern ( (Sequences.__default.replace2with1 arg0@@528 arg1@@241 arg2@@116 arg3@@62 arg4@@38))
)))
(assert (forall ((Sequences._default.replace2with1$A T@U) ($ly@@115 T@U) (|s#0@@83| T@U) (|a#0@@41| T@U) (|pos#0@@19| Int) ) (!  (=> (and (and (and (= (type Sequences._default.replace2with1$A) TyType) (= (type $ly@@115) LayerTypeType)) (= (type |s#0@@83|) (SeqType BoxType))) (= (type |a#0@@41|) BoxType)) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A ($LS $ly@@115) |s#0@@83| |a#0@@41| |pos#0@@19|) (Sequences.__default.replace2with1 Sequences._default.replace2with1$A $ly@@115 |s#0@@83| |a#0@@41| |pos#0@@19|)))
 :qid |unknown.0:0|
 :skolemid |3373|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A ($LS $ly@@115) |s#0@@83| |a#0@@41| |pos#0@@19|))
)))
(assert (forall ((Sequences._default.replace2with1$A@@0 T@U) ($ly@@116 T@U) (|s#0@@84| T@U) (|a#0@@42| T@U) (|pos#0@@20| Int) ) (!  (=> (and (and (and (= (type Sequences._default.replace2with1$A@@0) TyType) (= (type $ly@@116) LayerTypeType)) (= (type |s#0@@84|) (SeqType BoxType))) (= (type |a#0@@42|) BoxType)) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 $ly@@116 |s#0@@84| |a#0@@42| |pos#0@@20|) (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 $LZ |s#0@@84| |a#0@@42| |pos#0@@20|)))
 :qid |unknown.0:0|
 :skolemid |3374|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@0 (AsFuelBottom $ly@@116) |s#0@@84| |a#0@@42| |pos#0@@20|))
)))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@1 T@U) ($ly@@117 T@U) (|s#0@@85| T@U) (|a#0@@43| T@U) (|pos#0@@21| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@1) TyType) (= (type $ly@@117) LayerTypeType)) (= (type |s#0@@85|) (SeqType BoxType))) (= (type |a#0@@43|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@1 |s#0@@85| |a#0@@43| |pos#0@@21|) (and (and ($Is |s#0@@85| (TSeq Sequences._default.replace2with1$A@@1)) ($IsBox |a#0@@43| Sequences._default.replace2with1$A@@1)) (and (INTERNAL_le_boogie 0 |pos#0@@21|) (INTERNAL_lt_boogie |pos#0@@21| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1)))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|)) (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1)) (forall ((|i#0@@102| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@102|) (INTERNAL_lt_boogie |i#0@@102| |pos#0@@21|)) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#0@@102|) (|Seq#Index| |s#0@@85| |i#0@@102|))))
 :qid |Sequencesidfy.431:18|
 :skolemid |3375|
 :pattern ( (|Seq#Index| |s#0@@85| |i#0@@102|))
 :pattern ( (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#0@@102|))
))) (forall ((|i#1@@30| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie |pos#0@@21| |i#1@@30|) (INTERNAL_lt_boogie |i#1@@30| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@85|) 1))) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#1@@30|) (|Seq#Index| |s#0@@85| (INTERNAL_add_boogie |i#1@@30| 1)))))
 :qid |Sequencesidfy.432:18|
 :skolemid |3376|
 :pattern ( (|Seq#Index| |s#0@@85| (INTERNAL_add_boogie |i#1@@30| 1)))
 :pattern ( (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) |i#1@@30|))
))) (= (|Seq#Index| (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) |pos#0@@21|) |a#0@@43|)) ($Is (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|) (TSeq Sequences._default.replace2with1$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3377|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@1 $ly@@117 |s#0@@85| |a#0@@43| |pos#0@@21|))
))))
(assert (forall ((Sequences._default.replace2with1$A@@2 T@U) ($ly@@118 T@U) (|s#0@@86| T@U) (|a#0@@44| T@U) (|pos#0@@22| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@2) TyType) (= (type $ly@@118) LayerTypeType)) (= (type |s#0@@86|) (SeqType BoxType))) (= (type |a#0@@44|) BoxType)) (and ($Is |s#0@@86| (TSeq Sequences._default.replace2with1$A@@2)) ($IsBox |a#0@@44| Sequences._default.replace2with1$A@@2))) (= (|Sequences.__default.replace2with1#requires| Sequences._default.replace2with1$A@@2 $ly@@118 |s#0@@86| |a#0@@44| |pos#0@@22|)  (and (INTERNAL_le_boogie 0 |pos#0@@22|) (INTERNAL_lt_boogie |pos#0@@22| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@86|) 1)))))
 :qid |unknown.0:0|
 :skolemid |3378|
 :pattern ( (|Sequences.__default.replace2with1#requires| Sequences._default.replace2with1$A@@2 $ly@@118 |s#0@@86| |a#0@@44| |pos#0@@22|))
)))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@3 T@U) ($ly@@119 T@U) (|s#0@@87| T@U) (|a#0@@45| T@U) (|pos#0@@23| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@3) TyType) (= (type $ly@@119) LayerTypeType)) (= (type |s#0@@87|) (SeqType BoxType))) (= (type |a#0@@45|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@3 |s#0@@87| |a#0@@45| |pos#0@@23|) (and (and ($Is |s#0@@87| (TSeq Sequences._default.replace2with1$A@@3)) ($IsBox |a#0@@45| Sequences._default.replace2with1$A@@3)) (and (INTERNAL_le_boogie 0 |pos#0@@23|) (INTERNAL_lt_boogie |pos#0@@23| (INTERNAL_sub_boogie (|Seq#Length| |s#0@@87|) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@3 ($LS $ly@@119) |s#0@@87| |a#0@@45| |pos#0@@23|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@87| |pos#0@@23|) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@45|)) (|Seq#Drop| |s#0@@87| (INTERNAL_add_boogie |pos#0@@23| 2)))))
 :qid |unknown.0:0|
 :skolemid |3379|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@3 ($LS $ly@@119) |s#0@@87| |a#0@@45| |pos#0@@23|))
))))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@4 T@U) ($ly@@120 T@U) (|s#0@@88| T@U) (|a#0@@46| T@U) (|pos#0@@24| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@4) TyType) (= (type $ly@@120) LayerTypeType)) (= (type |s#0@@88|) (SeqType BoxType))) (= (type |a#0@@46|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@4 (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)) (and (and ($Is |s#0@@88| (TSeq Sequences._default.replace2with1$A@@4)) ($IsBox |a#0@@46| Sequences._default.replace2with1$A@@4)) (and (INTERNAL_le_boogie 0 |pos#0@@24|) (INTERNAL_lt_boogie |pos#0@@24| (INTERNAL_sub_boogie (|Seq#Length| (Lit |s#0@@88|)) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@4 ($LS $ly@@120) (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@88|) (LitInt |pos#0@@24|)) (|Seq#Build| (|Seq#Empty| BoxType) |a#0@@46|)) (|Seq#Drop| (Lit |s#0@@88|) (LitInt (INTERNAL_add_boogie |pos#0@@24| 2))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3380|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@4 ($LS $ly@@120) (Lit |s#0@@88|) |a#0@@46| (LitInt |pos#0@@24|)))
))))
(assert  (=> true (forall ((Sequences._default.replace2with1$A@@5 T@U) ($ly@@121 T@U) (|s#0@@89| T@U) (|a#0@@47| T@U) (|pos#0@@25| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.replace2with1$A@@5) TyType) (= (type $ly@@121) LayerTypeType)) (= (type |s#0@@89|) (SeqType BoxType))) (= (type |a#0@@47|) BoxType)) (or (|Sequences.__default.replace2with1#canCall| Sequences._default.replace2with1$A@@5 (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)) (and (and ($Is |s#0@@89| (TSeq Sequences._default.replace2with1$A@@5)) ($IsBox |a#0@@47| Sequences._default.replace2with1$A@@5)) (and (INTERNAL_le_boogie 0 |pos#0@@25|) (INTERNAL_lt_boogie |pos#0@@25| (INTERNAL_sub_boogie (|Seq#Length| (Lit |s#0@@89|)) 1)))))) (= (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@5 ($LS $ly@@121) (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@89|) (LitInt |pos#0@@25|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |a#0@@47|))) (|Seq#Drop| (Lit |s#0@@89|) (LitInt (INTERNAL_add_boogie |pos#0@@25| 2))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3381|
 :pattern ( (Sequences.__default.replace2with1 Sequences._default.replace2with1$A@@5 ($LS $ly@@121) (Lit |s#0@@89|) (Lit |a#0@@47|) (LitInt |pos#0@@25|)))
))))
(assert (forall ((arg0@@529 T@U) (arg1@@242 T@U) (arg2@@117 T@U) (arg3@@63 T@U) ) (! (= (type (Sequences.__default.concat arg0@@529 arg1@@242 arg2@@117 arg3@@63)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concat|
 :pattern ( (Sequences.__default.concat arg0@@529 arg1@@242 arg2@@117 arg3@@63))
)))
(assert (forall ((Sequences._default.concat$A T@U) ($ly@@122 T@U) (|a#0@@48| T@U) (|b#0@@16| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concat$A) TyType) (= (type $ly@@122) LayerTypeType)) (= (type |a#0@@48|) (SeqType BoxType))) (= (type |b#0@@16|) (SeqType BoxType))) (= (Sequences.__default.concat Sequences._default.concat$A ($LS $ly@@122) |a#0@@48| |b#0@@16|) (Sequences.__default.concat Sequences._default.concat$A $ly@@122 |a#0@@48| |b#0@@16|)))
 :qid |unknown.0:0|
 :skolemid |3382|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A ($LS $ly@@122) |a#0@@48| |b#0@@16|))
)))
(assert (forall ((Sequences._default.concat$A@@0 T@U) ($ly@@123 T@U) (|a#0@@49| T@U) (|b#0@@17| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concat$A@@0) TyType) (= (type $ly@@123) LayerTypeType)) (= (type |a#0@@49|) (SeqType BoxType))) (= (type |b#0@@17|) (SeqType BoxType))) (= (Sequences.__default.concat Sequences._default.concat$A@@0 $ly@@123 |a#0@@49| |b#0@@17|) (Sequences.__default.concat Sequences._default.concat$A@@0 $LZ |a#0@@49| |b#0@@17|)))
 :qid |unknown.0:0|
 :skolemid |3383|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@0 (AsFuelBottom $ly@@123) |a#0@@49| |b#0@@17|))
)))
(assert  (=> true (forall ((Sequences._default.concat$A@@1 T@U) ($ly@@124 T@U) (|a#0@@50| T@U) (|b#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@1) TyType) (= (type $ly@@124) LayerTypeType)) (= (type |a#0@@50|) (SeqType BoxType))) (= (type |b#0@@18|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@1 |a#0@@50| |b#0@@18|) (and ($Is |a#0@@50| (TSeq Sequences._default.concat$A@@1)) ($Is |b#0@@18| (TSeq Sequences._default.concat$A@@1))))) (and (and (and (= (|Seq#Length| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|)) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) (|Seq#Length| |b#0@@18|))) (forall ((|i#0@@103| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@103|) (INTERNAL_lt_boogie |i#0@@103| (|Seq#Length| |a#0@@50|))) (= (|Seq#Index| |a#0@@50| |i#0@@103|) (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|) |i#0@@103|))))
 :qid |Sequencesidfy.440:18|
 :skolemid |3384|
 :pattern ( (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|) |i#0@@103|))
 :pattern ( (|Seq#Index| |a#0@@50| |i#0@@103|))
))) (forall ((|i#1@@31| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@31|) (INTERNAL_lt_boogie |i#1@@31| (|Seq#Length| |b#0@@18|))) (= (|Seq#Index| |b#0@@18| |i#1@@31|) (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) |i#1@@31|)))))
 :qid |Sequencesidfy.441:18|
 :skolemid |3385|
 :pattern ( (|Seq#Index| (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|) (INTERNAL_add_boogie (|Seq#Length| |a#0@@50|) |i#1@@31|)))
 :pattern ( (|Seq#Index| |b#0@@18| |i#1@@31|))
))) ($Is (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|) (TSeq Sequences._default.concat$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3386|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@1 $ly@@124 |a#0@@50| |b#0@@18|))
))))
(assert (forall ((Sequences._default.concat$A@@2 T@U) ($ly@@125 T@U) (|a#0@@51| T@U) (|b#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@2) TyType) (= (type $ly@@125) LayerTypeType)) (= (type |a#0@@51|) (SeqType BoxType))) (= (type |b#0@@19|) (SeqType BoxType))) (and ($Is |a#0@@51| (TSeq Sequences._default.concat$A@@2)) ($Is |b#0@@19| (TSeq Sequences._default.concat$A@@2)))) (= (|Sequences.__default.concat#requires| Sequences._default.concat$A@@2 $ly@@125 |a#0@@51| |b#0@@19|) true))
 :qid |unknown.0:0|
 :skolemid |3387|
 :pattern ( (|Sequences.__default.concat#requires| Sequences._default.concat$A@@2 $ly@@125 |a#0@@51| |b#0@@19|))
)))
(assert  (=> true (forall ((Sequences._default.concat$A@@3 T@U) ($ly@@126 T@U) (|a#0@@52| T@U) (|b#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@3) TyType) (= (type $ly@@126) LayerTypeType)) (= (type |a#0@@52|) (SeqType BoxType))) (= (type |b#0@@20|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@3 |a#0@@52| |b#0@@20|) (and ($Is |a#0@@52| (TSeq Sequences._default.concat$A@@3)) ($Is |b#0@@20| (TSeq Sequences._default.concat$A@@3))))) (= (Sequences.__default.concat Sequences._default.concat$A@@3 ($LS $ly@@126) |a#0@@52| |b#0@@20|) (|Seq#Append| |a#0@@52| |b#0@@20|)))
 :qid |unknown.0:0|
 :skolemid |3388|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@3 ($LS $ly@@126) |a#0@@52| |b#0@@20|))
))))
(assert  (=> true (forall ((Sequences._default.concat$A@@4 T@U) ($ly@@127 T@U) (|a#0@@53| T@U) (|b#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat$A@@4) TyType) (= (type $ly@@127) LayerTypeType)) (= (type |a#0@@53|) (SeqType BoxType))) (= (type |b#0@@21|) (SeqType BoxType))) (or (|Sequences.__default.concat#canCall| Sequences._default.concat$A@@4 (Lit |a#0@@53|) (Lit |b#0@@21|)) (and ($Is |a#0@@53| (TSeq Sequences._default.concat$A@@4)) ($Is |b#0@@21| (TSeq Sequences._default.concat$A@@4))))) (= (Sequences.__default.concat Sequences._default.concat$A@@4 ($LS $ly@@127) (Lit |a#0@@53|) (Lit |b#0@@21|)) (|Seq#Append| |a#0@@53| |b#0@@21|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3389|
 :pattern ( (Sequences.__default.concat Sequences._default.concat$A@@4 ($LS $ly@@127) (Lit |a#0@@53|) (Lit |b#0@@21|)))
))))
(assert (forall ((arg0@@530 T@U) (arg1@@243 T@U) (arg2@@118 T@U) (arg3@@64 T@U) (arg4@@39 T@U) ) (! (= (type (Sequences.__default.concat3 arg0@@530 arg1@@243 arg2@@118 arg3@@64 arg4@@39)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concat3|
 :pattern ( (Sequences.__default.concat3 arg0@@530 arg1@@243 arg2@@118 arg3@@64 arg4@@39))
)))
(assert (forall ((Sequences._default.concat3$A T@U) ($ly@@128 T@U) (|a#0@@54| T@U) (|b#0@@22| T@U) (|c#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat3$A) TyType) (= (type $ly@@128) LayerTypeType)) (= (type |a#0@@54|) (SeqType BoxType))) (= (type |b#0@@22|) BoxType)) (= (type |c#0@@3|) (SeqType BoxType))) (= (Sequences.__default.concat3 Sequences._default.concat3$A ($LS $ly@@128) |a#0@@54| |b#0@@22| |c#0@@3|) (Sequences.__default.concat3 Sequences._default.concat3$A $ly@@128 |a#0@@54| |b#0@@22| |c#0@@3|)))
 :qid |unknown.0:0|
 :skolemid |3390|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A ($LS $ly@@128) |a#0@@54| |b#0@@22| |c#0@@3|))
)))
(assert (forall ((Sequences._default.concat3$A@@0 T@U) ($ly@@129 T@U) (|a#0@@55| T@U) (|b#0@@23| T@U) (|c#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.concat3$A@@0) TyType) (= (type $ly@@129) LayerTypeType)) (= (type |a#0@@55|) (SeqType BoxType))) (= (type |b#0@@23|) BoxType)) (= (type |c#0@@4|) (SeqType BoxType))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@0 $ly@@129 |a#0@@55| |b#0@@23| |c#0@@4|) (Sequences.__default.concat3 Sequences._default.concat3$A@@0 $LZ |a#0@@55| |b#0@@23| |c#0@@4|)))
 :qid |unknown.0:0|
 :skolemid |3391|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@0 (AsFuelBottom $ly@@129) |a#0@@55| |b#0@@23| |c#0@@4|))
)))
(assert  (=> true (forall ((Sequences._default.concat3$A@@1 T@U) ($ly@@130 T@U) (|a#0@@56| T@U) (|b#0@@24| T@U) (|c#0@@5| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@1) TyType) (= (type $ly@@130) LayerTypeType)) (= (type |a#0@@56|) (SeqType BoxType))) (= (type |b#0@@24|) BoxType)) (= (type |c#0@@5|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@1 |a#0@@56| |b#0@@24| |c#0@@5|) (and (and ($Is |a#0@@56| (TSeq Sequences._default.concat3$A@@1)) ($IsBox |b#0@@24| Sequences._default.concat3$A@@1)) ($Is |c#0@@5| (TSeq Sequences._default.concat3$A@@1))))) (and (and (and (and (= (|Seq#Length| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|)) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) (|Seq#Length| |c#0@@5|)) 1)) (forall ((|i#0@@104| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@104|) (INTERNAL_lt_boogie |i#0@@104| (|Seq#Length| |a#0@@56|))) (= (|Seq#Index| |a#0@@56| |i#0@@104|) (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) |i#0@@104|))))
 :qid |Sequencesidfy.448:18|
 :skolemid |3392|
 :pattern ( (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) |i#0@@104|))
 :pattern ( (|Seq#Index| |a#0@@56| |i#0@@104|))
))) (= (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) (|Seq#Length| |a#0@@56|)) |b#0@@24|)) (forall ((|i#1@@32| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#1@@32|) (INTERNAL_lt_boogie |i#1@@32| (|Seq#Length| |c#0@@5|))) (= (|Seq#Index| |c#0@@5| |i#1@@32|) (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) 1) |i#1@@32|)))))
 :qid |Sequencesidfy.450:18|
 :skolemid |3393|
 :pattern ( (|Seq#Index| (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) (INTERNAL_add_boogie (INTERNAL_add_boogie (|Seq#Length| |a#0@@56|) 1) |i#1@@32|)))
 :pattern ( (|Seq#Index| |c#0@@5| |i#1@@32|))
))) ($Is (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|) (TSeq Sequences._default.concat3$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3394|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@1 $ly@@130 |a#0@@56| |b#0@@24| |c#0@@5|))
))))
(assert (forall ((Sequences._default.concat3$A@@2 T@U) ($ly@@131 T@U) (|a#0@@57| T@U) (|b#0@@25| T@U) (|c#0@@6| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@2) TyType) (= (type $ly@@131) LayerTypeType)) (= (type |a#0@@57|) (SeqType BoxType))) (= (type |b#0@@25|) BoxType)) (= (type |c#0@@6|) (SeqType BoxType))) (and (and ($Is |a#0@@57| (TSeq Sequences._default.concat3$A@@2)) ($IsBox |b#0@@25| Sequences._default.concat3$A@@2)) ($Is |c#0@@6| (TSeq Sequences._default.concat3$A@@2)))) (= (|Sequences.__default.concat3#requires| Sequences._default.concat3$A@@2 $ly@@131 |a#0@@57| |b#0@@25| |c#0@@6|) true))
 :qid |unknown.0:0|
 :skolemid |3395|
 :pattern ( (|Sequences.__default.concat3#requires| Sequences._default.concat3$A@@2 $ly@@131 |a#0@@57| |b#0@@25| |c#0@@6|))
)))
(assert  (=> true (forall ((Sequences._default.concat3$A@@3 T@U) ($ly@@132 T@U) (|a#0@@58| T@U) (|b#0@@26| T@U) (|c#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@3) TyType) (= (type $ly@@132) LayerTypeType)) (= (type |a#0@@58|) (SeqType BoxType))) (= (type |b#0@@26|) BoxType)) (= (type |c#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@3 |a#0@@58| |b#0@@26| |c#0@@7|) (and (and ($Is |a#0@@58| (TSeq Sequences._default.concat3$A@@3)) ($IsBox |b#0@@26| Sequences._default.concat3$A@@3)) ($Is |c#0@@7| (TSeq Sequences._default.concat3$A@@3))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@3 ($LS $ly@@132) |a#0@@58| |b#0@@26| |c#0@@7|) (|Seq#Append| (|Seq#Append| |a#0@@58| (|Seq#Build| (|Seq#Empty| BoxType) |b#0@@26|)) |c#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |3396|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@3 ($LS $ly@@132) |a#0@@58| |b#0@@26| |c#0@@7|))
))))
(assert  (=> true (forall ((Sequences._default.concat3$A@@4 T@U) ($ly@@133 T@U) (|a#0@@59| T@U) (|b#0@@27| T@U) (|c#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@4) TyType) (= (type $ly@@133) LayerTypeType)) (= (type |a#0@@59|) (SeqType BoxType))) (= (type |b#0@@27|) BoxType)) (= (type |c#0@@8|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@4 (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)) (and (and ($Is |a#0@@59| (TSeq Sequences._default.concat3$A@@4)) ($IsBox |b#0@@27| Sequences._default.concat3$A@@4)) ($Is |c#0@@8| (TSeq Sequences._default.concat3$A@@4))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@4 ($LS $ly@@133) (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)) (|Seq#Append| (|Seq#Append| |a#0@@59| (|Seq#Build| (|Seq#Empty| BoxType) |b#0@@27|)) |c#0@@8|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3397|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@4 ($LS $ly@@133) (Lit |a#0@@59|) |b#0@@27| (Lit |c#0@@8|)))
))))
(assert  (=> true (forall ((Sequences._default.concat3$A@@5 T@U) ($ly@@134 T@U) (|a#0@@60| T@U) (|b#0@@28| T@U) (|c#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.concat3$A@@5) TyType) (= (type $ly@@134) LayerTypeType)) (= (type |a#0@@60|) (SeqType BoxType))) (= (type |b#0@@28|) BoxType)) (= (type |c#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.concat3#canCall| Sequences._default.concat3$A@@5 (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)) (and (and ($Is |a#0@@60| (TSeq Sequences._default.concat3$A@@5)) ($IsBox |b#0@@28| Sequences._default.concat3$A@@5)) ($Is |c#0@@9| (TSeq Sequences._default.concat3$A@@5))))) (= (Sequences.__default.concat3 Sequences._default.concat3$A@@5 ($LS $ly@@134) (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)) (|Seq#Append| (|Seq#Append| |a#0@@60| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |b#0@@28|))) |c#0@@9|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3398|
 :pattern ( (Sequences.__default.concat3 Sequences._default.concat3$A@@5 ($LS $ly@@134) (Lit |a#0@@60|) (Lit |b#0@@28|) (Lit |c#0@@9|)))
))))
(assert (forall ((arg0@@531 T@U) (arg1@@244 T@U) (arg2@@119 T@U) ) (! (= (type (Sequences.__default.concatSeq arg0@@531 arg1@@244 arg2@@119)) (SeqType BoxType))
 :qid |funType:Sequences.__default.concatSeq|
 :pattern ( (Sequences.__default.concatSeq arg0@@531 arg1@@244 arg2@@119))
)))
(assert (forall ((Sequences._default.concatSeq$A T@U) ($ly@@135 T@U) (|a#0@@61| T@U) ) (!  (=> (and (and (= (type Sequences._default.concatSeq$A) TyType) (= (type $ly@@135) LayerTypeType)) (= (type |a#0@@61|) (SeqType BoxType))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A ($LS $ly@@135) |a#0@@61|) (Sequences.__default.concatSeq Sequences._default.concatSeq$A $ly@@135 |a#0@@61|)))
 :qid |unknown.0:0|
 :skolemid |3399|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A ($LS $ly@@135) |a#0@@61|))
)))
(assert (forall ((Sequences._default.concatSeq$A@@0 T@U) ($ly@@136 T@U) (|a#0@@62| T@U) ) (!  (=> (and (and (= (type Sequences._default.concatSeq$A@@0) TyType) (= (type $ly@@136) LayerTypeType)) (= (type |a#0@@62|) (SeqType BoxType))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 $ly@@136 |a#0@@62|) (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 $LZ |a#0@@62|)))
 :qid |unknown.0:0|
 :skolemid |3400|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@0 (AsFuelBottom $ly@@136) |a#0@@62|))
)))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@1 T@U) ($ly@@137 T@U) (|a#0@@63| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@1) TyType) (= (type $ly@@137) LayerTypeType)) (= (type |a#0@@63|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@1 |a#0@@63|) ($Is |a#0@@63| (TSeq (TSeq Sequences._default.concatSeq$A@@1))))) ($Is (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@1 $ly@@137 |a#0@@63|) (TSeq Sequences._default.concatSeq$A@@1)))
 :qid |unknown.0:0|
 :skolemid |3401|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@1 $ly@@137 |a#0@@63|))
))))
(assert (forall ((Sequences._default.concatSeq$A@@2 T@U) ($ly@@138 T@U) (|a#0@@64| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@2) TyType) (= (type $ly@@138) LayerTypeType)) (= (type |a#0@@64|) (SeqType BoxType))) ($Is |a#0@@64| (TSeq (TSeq Sequences._default.concatSeq$A@@2)))) (= (|Sequences.__default.concatSeq#requires| Sequences._default.concatSeq$A@@2 $ly@@138 |a#0@@64|) true))
 :qid |unknown.0:0|
 :skolemid |3402|
 :pattern ( (|Sequences.__default.concatSeq#requires| Sequences._default.concatSeq$A@@2 $ly@@138 |a#0@@64|))
)))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@3 T@U) ($ly@@139 T@U) (|a#0@@65| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@3) TyType) (= (type $ly@@139) LayerTypeType)) (= (type |a#0@@65|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@3 |a#0@@65|) ($Is |a#0@@65| (TSeq (TSeq Sequences._default.concatSeq$A@@3))))) (and (=> (not (= (|Seq#Length| |a#0@@65|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|) (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 ($LS $ly@@139) |a#0@@65|) (ite (= (|Seq#Length| |a#0@@65|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 $ly@@139 (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|)) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.concatSeq$A@@3) |a#0@@65|)))))))
 :qid |unknown.0:0|
 :skolemid |3403|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@3 ($LS $ly@@139) |a#0@@65|))
))))
(assert  (=> true (forall ((Sequences._default.concatSeq$A@@4 T@U) ($ly@@140 T@U) (|a#0@@66| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.concatSeq$A@@4) TyType) (= (type $ly@@140) LayerTypeType)) (= (type |a#0@@66|) (SeqType BoxType))) (or (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@4 (Lit |a#0@@66|)) ($Is |a#0@@66| (TSeq (TSeq Sequences._default.concatSeq$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)) (|Sequences.__default.concatSeq#canCall| Sequences._default.concatSeq$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)))) (= (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@140) (Lit |a#0@@66|)) (ite (= (|Seq#Length| (Lit |a#0@@66|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@140) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|)))) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.concatSeq$A@@4) (Lit |a#0@@66|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3404|
 :pattern ( (Sequences.__default.concatSeq Sequences._default.concatSeq$A@@4 ($LS $ly@@140) (Lit |a#0@@66|)))
))))
(assert (forall ((Sequences._default.IsPrefix$A T@U) ($ly@@141 T@U) (|a#0@@67| T@U) (|b#0@@29| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsPrefix$A) TyType) (= (type $ly@@141) LayerTypeType)) (= (type |a#0@@67|) (SeqType BoxType))) (= (type |b#0@@29|) (SeqType BoxType))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A ($LS $ly@@141) |a#0@@67| |b#0@@29|) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A $ly@@141 |a#0@@67| |b#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |3405|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A ($LS $ly@@141) |a#0@@67| |b#0@@29|))
)))
(assert (forall ((Sequences._default.IsPrefix$A@@0 T@U) ($ly@@142 T@U) (|a#0@@68| T@U) (|b#0@@30| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsPrefix$A@@0) TyType) (= (type $ly@@142) LayerTypeType)) (= (type |a#0@@68|) (SeqType BoxType))) (= (type |b#0@@30|) (SeqType BoxType))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 $ly@@142 |a#0@@68| |b#0@@30|) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 $LZ |a#0@@68| |b#0@@30|)))
 :qid |unknown.0:0|
 :skolemid |3406|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@0 (AsFuelBottom $ly@@142) |a#0@@68| |b#0@@30|))
)))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@1 T@U) ($ly@@143 T@U) (|a#0@@69| T@U) (|b#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.IsPrefix$A@@1) TyType) (= (type $ly@@143) LayerTypeType)) (= (type |a#0@@69|) (SeqType BoxType))) (= (type |b#0@@31|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@1 |a#0@@69| |b#0@@31|) (and ($Is |a#0@@69| (TSeq Sequences._default.IsPrefix$A@@1)) ($Is |b#0@@31| (TSeq Sequences._default.IsPrefix$A@@1))))) (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@1 $ly@@143 |a#0@@69| |b#0@@31|)) (INTERNAL_le_boogie (|Seq#Length| |a#0@@69|) (|Seq#Length| |b#0@@31|)))
 :qid |unknown.0:0|
 :skolemid |3407|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@1 $ly@@143 |a#0@@69| |b#0@@31|))
))))
(assert (forall ((Sequences._default.IsPrefix$A@@2 T@U) ($ly@@144 T@U) (|a#0@@70| T@U) (|b#0@@32| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@2) TyType) (= (type $ly@@144) LayerTypeType)) (= (type |a#0@@70|) (SeqType BoxType))) (= (type |b#0@@32|) (SeqType BoxType))) (and ($Is |a#0@@70| (TSeq Sequences._default.IsPrefix$A@@2)) ($Is |b#0@@32| (TSeq Sequences._default.IsPrefix$A@@2)))) (= (|Sequences.__default.IsPrefix#requires| Sequences._default.IsPrefix$A@@2 $ly@@144 |a#0@@70| |b#0@@32|) true))
 :qid |unknown.0:0|
 :skolemid |3408|
 :pattern ( (|Sequences.__default.IsPrefix#requires| Sequences._default.IsPrefix$A@@2 $ly@@144 |a#0@@70| |b#0@@32|))
)))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@3 T@U) ($ly@@145 T@U) (|a#0@@71| T@U) (|b#0@@33| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@3) TyType) (= (type $ly@@145) LayerTypeType)) (= (type |a#0@@71|) (SeqType BoxType))) (= (type |b#0@@33|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@3 |a#0@@71| |b#0@@33|) (and ($Is |a#0@@71| (TSeq Sequences._default.IsPrefix$A@@3)) ($Is |b#0@@33| (TSeq Sequences._default.IsPrefix$A@@3))))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@3 ($LS $ly@@145) |a#0@@71| |b#0@@33|)  (and (INTERNAL_le_boogie (|Seq#Length| |a#0@@71|) (|Seq#Length| |b#0@@33|)) (|Seq#Equal| |a#0@@71| (|Seq#Take| |b#0@@33| (|Seq#Length| |a#0@@71|))))))
 :qid |unknown.0:0|
 :skolemid |3409|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@3 ($LS $ly@@145) |a#0@@71| |b#0@@33|))
))))
(assert  (=> true (forall ((Sequences._default.IsPrefix$A@@4 T@U) ($ly@@146 T@U) (|a#0@@72| T@U) (|b#0@@34| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsPrefix$A@@4) TyType) (= (type $ly@@146) LayerTypeType)) (= (type |a#0@@72|) (SeqType BoxType))) (= (type |b#0@@34|) (SeqType BoxType))) (or (|Sequences.__default.IsPrefix#canCall| Sequences._default.IsPrefix$A@@4 (Lit |a#0@@72|) (Lit |b#0@@34|)) (and ($Is |a#0@@72| (TSeq Sequences._default.IsPrefix$A@@4)) ($Is |b#0@@34| (TSeq Sequences._default.IsPrefix$A@@4))))) (= (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@4 ($LS $ly@@146) (Lit |a#0@@72|) (Lit |b#0@@34|))  (and (INTERNAL_le_boogie (|Seq#Length| (Lit |a#0@@72|)) (|Seq#Length| (Lit |b#0@@34|))) (|Seq#Equal| |a#0@@72| (|Seq#Take| (Lit |b#0@@34|) (|Seq#Length| (Lit |a#0@@72|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3410|
 :pattern ( (Sequences.__default.IsPrefix Sequences._default.IsPrefix$A@@4 ($LS $ly@@146) (Lit |a#0@@72|) (Lit |b#0@@34|)))
))))
(assert (forall ((Sequences._default.IsSuffix$A T@U) ($ly@@147 T@U) (|a#0@@73| T@U) (|b#0@@35| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsSuffix$A) TyType) (= (type $ly@@147) LayerTypeType)) (= (type |a#0@@73|) (SeqType BoxType))) (= (type |b#0@@35|) (SeqType BoxType))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A ($LS $ly@@147) |a#0@@73| |b#0@@35|) (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A $ly@@147 |a#0@@73| |b#0@@35|)))
 :qid |unknown.0:0|
 :skolemid |3411|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A ($LS $ly@@147) |a#0@@73| |b#0@@35|))
)))
(assert (forall ((Sequences._default.IsSuffix$A@@0 T@U) ($ly@@148 T@U) (|a#0@@74| T@U) (|b#0@@36| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.IsSuffix$A@@0) TyType) (= (type $ly@@148) LayerTypeType)) (= (type |a#0@@74|) (SeqType BoxType))) (= (type |b#0@@36|) (SeqType BoxType))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 $ly@@148 |a#0@@74| |b#0@@36|) (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 $LZ |a#0@@74| |b#0@@36|)))
 :qid |unknown.0:0|
 :skolemid |3412|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@0 (AsFuelBottom $ly@@148) |a#0@@74| |b#0@@36|))
)))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@1 T@U) ($ly@@149 T@U) (|a#0@@75| T@U) (|b#0@@37| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@1) TyType) (= (type $ly@@149) LayerTypeType)) (= (type |a#0@@75|) (SeqType BoxType))) (= (type |b#0@@37|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@1 |a#0@@75| |b#0@@37|) (and ($Is |a#0@@75| (TSeq Sequences._default.IsSuffix$A@@1)) ($Is |b#0@@37| (TSeq Sequences._default.IsSuffix$A@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |3413|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@1 $ly@@149 |a#0@@75| |b#0@@37|))
))))
(assert (forall ((Sequences._default.IsSuffix$A@@2 T@U) ($ly@@150 T@U) (|a#0@@76| T@U) (|b#0@@38| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@2) TyType) (= (type $ly@@150) LayerTypeType)) (= (type |a#0@@76|) (SeqType BoxType))) (= (type |b#0@@38|) (SeqType BoxType))) (and ($Is |a#0@@76| (TSeq Sequences._default.IsSuffix$A@@2)) ($Is |b#0@@38| (TSeq Sequences._default.IsSuffix$A@@2)))) (= (|Sequences.__default.IsSuffix#requires| Sequences._default.IsSuffix$A@@2 $ly@@150 |a#0@@76| |b#0@@38|) true))
 :qid |unknown.0:0|
 :skolemid |3414|
 :pattern ( (|Sequences.__default.IsSuffix#requires| Sequences._default.IsSuffix$A@@2 $ly@@150 |a#0@@76| |b#0@@38|))
)))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@3 T@U) ($ly@@151 T@U) (|a#0@@77| T@U) (|b#0@@39| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@3) TyType) (= (type $ly@@151) LayerTypeType)) (= (type |a#0@@77|) (SeqType BoxType))) (= (type |b#0@@39|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@3 |a#0@@77| |b#0@@39|) (and ($Is |a#0@@77| (TSeq Sequences._default.IsSuffix$A@@3)) ($Is |b#0@@39| (TSeq Sequences._default.IsSuffix$A@@3))))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@3 ($LS $ly@@151) |a#0@@77| |b#0@@39|)  (and (INTERNAL_le_boogie (|Seq#Length| |a#0@@77|) (|Seq#Length| |b#0@@39|)) (|Seq#Equal| |a#0@@77| (|Seq#Drop| |b#0@@39| (INTERNAL_sub_boogie (|Seq#Length| |b#0@@39|) (|Seq#Length| |a#0@@77|)))))))
 :qid |unknown.0:0|
 :skolemid |3415|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@3 ($LS $ly@@151) |a#0@@77| |b#0@@39|))
))))
(assert  (=> true (forall ((Sequences._default.IsSuffix$A@@4 T@U) ($ly@@152 T@U) (|a#0@@78| T@U) (|b#0@@40| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.IsSuffix$A@@4) TyType) (= (type $ly@@152) LayerTypeType)) (= (type |a#0@@78|) (SeqType BoxType))) (= (type |b#0@@40|) (SeqType BoxType))) (or (|Sequences.__default.IsSuffix#canCall| Sequences._default.IsSuffix$A@@4 (Lit |a#0@@78|) (Lit |b#0@@40|)) (and ($Is |a#0@@78| (TSeq Sequences._default.IsSuffix$A@@4)) ($Is |b#0@@40| (TSeq Sequences._default.IsSuffix$A@@4))))) (= (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@4 ($LS $ly@@152) (Lit |a#0@@78|) (Lit |b#0@@40|))  (and (INTERNAL_le_boogie (|Seq#Length| (Lit |a#0@@78|)) (|Seq#Length| (Lit |b#0@@40|))) (|Seq#Equal| |a#0@@78| (|Seq#Drop| (Lit |b#0@@40|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |b#0@@40|)) (|Seq#Length| (Lit |a#0@@78|))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3416|
 :pattern ( (Sequences.__default.IsSuffix Sequences._default.IsSuffix$A@@4 ($LS $ly@@152) (Lit |a#0@@78|) (Lit |b#0@@40|)))
))))
(assert (forall ((arg0@@532 T@U) (arg1@@245 T@U) (arg2@@120 T@U) (arg3@@65 T@U) (arg4@@40 Int) ) (! (= (type (Sequences.__default.SeqIndexIterate arg0@@532 arg1@@245 arg2@@120 arg3@@65 arg4@@40)) DatatypeTypeType)
 :qid |funType:Sequences.__default.SeqIndexIterate|
 :pattern ( (Sequences.__default.SeqIndexIterate arg0@@532 arg1@@245 arg2@@120 arg3@@65 arg4@@40))
)))
(assert (forall ((Sequences._default.SeqIndexIterate$A T@U) ($ly@@153 T@U) (|run#0@@71| T@U) (|needle#0| T@U) (|i#0@@105| Int) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexIterate$A) TyType) (= (type $ly@@153) LayerTypeType)) (= (type |run#0@@71|) (SeqType BoxType))) (= (type |needle#0|) BoxType)) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A ($LS $ly@@153) |run#0@@71| |needle#0| |i#0@@105|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A $ly@@153 |run#0@@71| |needle#0| |i#0@@105|)))
 :qid |unknown.0:0|
 :skolemid |3417|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A ($LS $ly@@153) |run#0@@71| |needle#0| |i#0@@105|))
)))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@0 T@U) ($ly@@154 T@U) (|run#0@@72| T@U) (|needle#0@@0| T@U) (|i#0@@106| Int) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@0) TyType) (= (type $ly@@154) LayerTypeType)) (= (type |run#0@@72|) (SeqType BoxType))) (= (type |needle#0@@0|) BoxType)) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 $ly@@154 |run#0@@72| |needle#0@@0| |i#0@@106|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 $LZ |run#0@@72| |needle#0@@0| |i#0@@106|)))
 :qid |unknown.0:0|
 :skolemid |3418|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@0 (AsFuelBottom $ly@@154) |run#0@@72| |needle#0@@0| |i#0@@106|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@1 T@U) ($ly@@155 T@U) (|run#0@@73| T@U) (|needle#0@@1| T@U) (|i#0@@107| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@1) TyType) (= (type $ly@@155) LayerTypeType)) (= (type |run#0@@73|) (SeqType BoxType))) (= (type |needle#0@@1|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@1 |run#0@@73| |needle#0@@1| |i#0@@107|) (and (and ($Is |run#0@@73| (TSeq Sequences._default.SeqIndexIterate$A@@1)) ($IsBox |needle#0@@1| Sequences._default.SeqIndexIterate$A@@1)) (and (INTERNAL_le_boogie 0 |i#0@@107|) (INTERNAL_le_boogie |i#0@@107| (|Seq#Length| |run#0@@73|)))))) (and (and (=> (Options.Option.Some_q (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|)) (and (and (INTERNAL_le_boogie 0 (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|))))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|)))) (|Seq#Length| |run#0@@73|))) (= (|Seq#Index| |run#0@@73| (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|))))) |needle#0@@1|))) (=> (Options.Option.None_q (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|)) (forall ((|j#0@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie |i#0@@107| |j#0@@1|) (INTERNAL_lt_boogie |j#0@@1| (|Seq#Length| |run#0@@73|))) (not (= (|Seq#Index| |run#0@@73| |j#0@@1|) |needle#0@@1|)))
 :qid |Sequencesidfy.530:32|
 :skolemid |3419|
 :pattern ( (|Seq#Index| |run#0@@73| |j#0@@1|))
)))) ($Is (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|) (Tclass.Options.Option TInt))))
 :qid |unknown.0:0|
 :skolemid |3420|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@1 $ly@@155 |run#0@@73| |needle#0@@1| |i#0@@107|))
))))
(assert (forall ((Sequences._default.SeqIndexIterate$A@@2 T@U) ($ly@@156 T@U) (|run#0@@74| T@U) (|needle#0@@2| T@U) (|i#0@@108| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@2) TyType) (= (type $ly@@156) LayerTypeType)) (= (type |run#0@@74|) (SeqType BoxType))) (= (type |needle#0@@2|) BoxType)) (and ($Is |run#0@@74| (TSeq Sequences._default.SeqIndexIterate$A@@2)) ($IsBox |needle#0@@2| Sequences._default.SeqIndexIterate$A@@2))) (= (|Sequences.__default.SeqIndexIterate#requires| Sequences._default.SeqIndexIterate$A@@2 $ly@@156 |run#0@@74| |needle#0@@2| |i#0@@108|)  (and (INTERNAL_le_boogie 0 |i#0@@108|) (INTERNAL_le_boogie |i#0@@108| (|Seq#Length| |run#0@@74|)))))
 :qid |unknown.0:0|
 :skolemid |3421|
 :pattern ( (|Sequences.__default.SeqIndexIterate#requires| Sequences._default.SeqIndexIterate$A@@2 $ly@@156 |run#0@@74| |needle#0@@2| |i#0@@108|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@3 T@U) ($ly@@157 T@U) (|run#0@@75| T@U) (|needle#0@@3| T@U) (|i#0@@109| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@3) TyType) (= (type $ly@@157) LayerTypeType)) (= (type |run#0@@75|) (SeqType BoxType))) (= (type |needle#0@@3|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@3 |run#0@@75| |needle#0@@3| |i#0@@109|) (and (and ($Is |run#0@@75| (TSeq Sequences._default.SeqIndexIterate$A@@3)) ($IsBox |needle#0@@3| Sequences._default.SeqIndexIterate$A@@3)) (and (INTERNAL_le_boogie 0 |i#0@@109|) (INTERNAL_le_boogie |i#0@@109| (|Seq#Length| |run#0@@75|)))))) (and (=> (not (= |i#0@@109| (|Seq#Length| |run#0@@75|))) (=> (not (= (|Seq#Index| |run#0@@75| |i#0@@109|) |needle#0@@3|)) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@3 |run#0@@75| |needle#0@@3| (INTERNAL_add_boogie |i#0@@109| 1)))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 ($LS $ly@@157) |run#0@@75| |needle#0@@3| |i#0@@109|) (ite (= |i#0@@109| (|Seq#Length| |run#0@@75|)) |#Options.Option.None| (ite (= (|Seq#Index| |run#0@@75| |i#0@@109|) |needle#0@@3|) (|#Options.Option.Some| ($Box (int_2_U |i#0@@109|))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 $ly@@157 |run#0@@75| |needle#0@@3| (INTERNAL_add_boogie |i#0@@109| 1)))))))
 :qid |unknown.0:0|
 :skolemid |3422|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@3 ($LS $ly@@157) |run#0@@75| |needle#0@@3| |i#0@@109|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@4 T@U) ($ly@@158 T@U) (|run#0@@76| T@U) (|needle#0@@4| T@U) (|i#0@@110| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@4) TyType) (= (type $ly@@158) LayerTypeType)) (= (type |run#0@@76|) (SeqType BoxType))) (= (type |needle#0@@4|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@4 (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@110|)) (and (and ($Is |run#0@@76| (TSeq Sequences._default.SeqIndexIterate$A@@4)) ($IsBox |needle#0@@4| Sequences._default.SeqIndexIterate$A@@4)) (and (INTERNAL_le_boogie 0 |i#0@@110|) (INTERNAL_le_boogie |i#0@@110| (|Seq#Length| (Lit |run#0@@76|))))))) (and (=> (not (= (LitInt |i#0@@110|) (|Seq#Length| (Lit |run#0@@76|)))) (=> (not (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@110|)) |needle#0@@4|)) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@4 (Lit |run#0@@76|) |needle#0@@4| (LitInt (INTERNAL_add_boogie |i#0@@110| 1))))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@158) (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@110|)) (ite (= (LitInt |i#0@@110|) (|Seq#Length| (Lit |run#0@@76|))) |#Options.Option.None| (ite (= (|Seq#Index| (Lit |run#0@@76|) (LitInt |i#0@@110|)) |needle#0@@4|) (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@110|)))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@158) (Lit |run#0@@76|) |needle#0@@4| (LitInt (INTERNAL_add_boogie |i#0@@110| 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3423|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@4 ($LS $ly@@158) (Lit |run#0@@76|) |needle#0@@4| (LitInt |i#0@@110|)))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexIterate$A@@5 T@U) ($ly@@159 T@U) (|run#0@@77| T@U) (|needle#0@@5| T@U) (|i#0@@111| Int) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexIterate$A@@5) TyType) (= (type $ly@@159) LayerTypeType)) (= (type |run#0@@77|) (SeqType BoxType))) (= (type |needle#0@@5|) BoxType)) (or (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@5 (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@111|)) (and (and ($Is |run#0@@77| (TSeq Sequences._default.SeqIndexIterate$A@@5)) ($IsBox |needle#0@@5| Sequences._default.SeqIndexIterate$A@@5)) (and (INTERNAL_le_boogie 0 |i#0@@111|) (INTERNAL_le_boogie |i#0@@111| (|Seq#Length| (Lit |run#0@@77|))))))) (and (=> (not (= (LitInt |i#0@@111|) (|Seq#Length| (Lit |run#0@@77|)))) (=> (not (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@111|)) (Lit |needle#0@@5|))) (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndexIterate$A@@5 (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt (INTERNAL_add_boogie |i#0@@111| 1))))) (= (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@159) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@111|)) (ite (= (LitInt |i#0@@111|) (|Seq#Length| (Lit |run#0@@77|))) |#Options.Option.None| (ite (= (|Seq#Index| (Lit |run#0@@77|) (LitInt |i#0@@111|)) (Lit |needle#0@@5|)) (|#Options.Option.Some| ($Box (int_2_U (LitInt |i#0@@111|)))) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@159) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt (INTERNAL_add_boogie |i#0@@111| 1))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3424|
 :pattern ( (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndexIterate$A@@5 ($LS $ly@@159) (Lit |run#0@@77|) (Lit |needle#0@@5|) (LitInt |i#0@@111|)))
))))
(assert (forall ((arg0@@533 T@U) (arg1@@246 T@U) (arg2@@121 T@U) (arg3@@66 T@U) ) (! (= (type (Sequences.__default.SeqIndex arg0@@533 arg1@@246 arg2@@121 arg3@@66)) DatatypeTypeType)
 :qid |funType:Sequences.__default.SeqIndex|
 :pattern ( (Sequences.__default.SeqIndex arg0@@533 arg1@@246 arg2@@121 arg3@@66))
)))
(assert (forall ((Sequences._default.SeqIndex$A T@U) ($ly@@160 T@U) (|run#0@@78| T@U) (|needle#0@@6| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndex$A) TyType) (= (type $ly@@160) LayerTypeType)) (= (type |run#0@@78|) (SeqType BoxType))) (= (type |needle#0@@6|) BoxType)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A ($LS $ly@@160) |run#0@@78| |needle#0@@6|) (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A $ly@@160 |run#0@@78| |needle#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3425|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A ($LS $ly@@160) |run#0@@78| |needle#0@@6|))
)))
(assert (forall ((Sequences._default.SeqIndex$A@@0 T@U) ($ly@@161 T@U) (|run#0@@79| T@U) (|needle#0@@7| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndex$A@@0) TyType) (= (type $ly@@161) LayerTypeType)) (= (type |run#0@@79|) (SeqType BoxType))) (= (type |needle#0@@7|) BoxType)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 $ly@@161 |run#0@@79| |needle#0@@7|) (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 $LZ |run#0@@79| |needle#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |3426|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@0 (AsFuelBottom $ly@@161) |run#0@@79| |needle#0@@7|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@1 T@U) ($ly@@162 T@U) (|run#0@@80| T@U) (|needle#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@1) TyType) (= (type $ly@@162) LayerTypeType)) (= (type |run#0@@80|) (SeqType BoxType))) (= (type |needle#0@@8|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@1 |run#0@@80| |needle#0@@8|) (and ($Is |run#0@@80| (TSeq Sequences._default.SeqIndex$A@@1)) ($IsBox |needle#0@@8| Sequences._default.SeqIndex$A@@1)))) (and (and (=> (Options.Option.Some_q (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|)) (and (and (INTERNAL_le_boogie 0 (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|))))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|)))) (|Seq#Length| |run#0@@80|))) (= (|Seq#Index| |run#0@@80| (U_2_int ($Unbox intType (Options.Option.value (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|))))) |needle#0@@8|))) (=> (Options.Option.None_q (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|)) (forall ((|i#0@@112| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@112|) (INTERNAL_lt_boogie |i#0@@112| (|Seq#Length| |run#0@@80|))) (not (= (|Seq#Index| |run#0@@80| |i#0@@112|) |needle#0@@8|)))
 :qid |Sequencesidfy.540:32|
 :skolemid |3427|
 :pattern ( (|Seq#Index| |run#0@@80| |i#0@@112|))
)))) ($Is (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|) (Tclass.Options.Option TInt))))
 :qid |unknown.0:0|
 :skolemid |3428|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@1 $ly@@162 |run#0@@80| |needle#0@@8|))
))))
(assert (forall ((Sequences._default.SeqIndex$A@@2 T@U) ($ly@@163 T@U) (|run#0@@81| T@U) (|needle#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@2) TyType) (= (type $ly@@163) LayerTypeType)) (= (type |run#0@@81|) (SeqType BoxType))) (= (type |needle#0@@9|) BoxType)) (and ($Is |run#0@@81| (TSeq Sequences._default.SeqIndex$A@@2)) ($IsBox |needle#0@@9| Sequences._default.SeqIndex$A@@2))) (= (|Sequences.__default.SeqIndex#requires| Sequences._default.SeqIndex$A@@2 $ly@@163 |run#0@@81| |needle#0@@9|) true))
 :qid |unknown.0:0|
 :skolemid |3429|
 :pattern ( (|Sequences.__default.SeqIndex#requires| Sequences._default.SeqIndex$A@@2 $ly@@163 |run#0@@81| |needle#0@@9|))
)))
(assert (= (type StartFuel_Sequences._default.SeqIndexIterate) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@3 T@U) ($ly@@164 T@U) (|run#0@@82| T@U) (|needle#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@3) TyType) (= (type $ly@@164) LayerTypeType)) (= (type |run#0@@82|) (SeqType BoxType))) (= (type |needle#0@@10|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@3 |run#0@@82| |needle#0@@10|) (and ($Is |run#0@@82| (TSeq Sequences._default.SeqIndex$A@@3)) ($IsBox |needle#0@@10| Sequences._default.SeqIndex$A@@3)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@3 |run#0@@82| |needle#0@@10| (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@3 ($LS $ly@@164) |run#0@@82| |needle#0@@10|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@3 StartFuel_Sequences._default.SeqIndexIterate |run#0@@82| |needle#0@@10| (LitInt 0)))))
 :qid |unknown.0:0|
 :skolemid |3430|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@3 ($LS $ly@@164) |run#0@@82| |needle#0@@10|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@4 T@U) ($ly@@165 T@U) (|run#0@@83| T@U) (|needle#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@4) TyType) (= (type $ly@@165) LayerTypeType)) (= (type |run#0@@83|) (SeqType BoxType))) (= (type |needle#0@@11|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@4 (Lit |run#0@@83|) |needle#0@@11|) (and ($Is |run#0@@83| (TSeq Sequences._default.SeqIndex$A@@4)) ($IsBox |needle#0@@11| Sequences._default.SeqIndex$A@@4)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@4 (Lit |run#0@@83|) |needle#0@@11| (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@4 ($LS $ly@@165) (Lit |run#0@@83|) |needle#0@@11|) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@4 StartFuel_Sequences._default.SeqIndexIterate (Lit |run#0@@83|) |needle#0@@11| (LitInt 0)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3431|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@4 ($LS $ly@@165) (Lit |run#0@@83|) |needle#0@@11|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndex$A@@5 T@U) ($ly@@166 T@U) (|run#0@@84| T@U) (|needle#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndex$A@@5) TyType) (= (type $ly@@166) LayerTypeType)) (= (type |run#0@@84|) (SeqType BoxType))) (= (type |needle#0@@12|) BoxType)) (or (|Sequences.__default.SeqIndex#canCall| Sequences._default.SeqIndex$A@@5 (Lit |run#0@@84|) (Lit |needle#0@@12|)) (and ($Is |run#0@@84| (TSeq Sequences._default.SeqIndex$A@@5)) ($IsBox |needle#0@@12| Sequences._default.SeqIndex$A@@5)))) (and (|Sequences.__default.SeqIndexIterate#canCall| Sequences._default.SeqIndex$A@@5 (Lit |run#0@@84|) (Lit |needle#0@@12|) (LitInt 0)) (= (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@5 ($LS $ly@@166) (Lit |run#0@@84|) (Lit |needle#0@@12|)) (Sequences.__default.SeqIndexIterate Sequences._default.SeqIndex$A@@5 StartFuel_Sequences._default.SeqIndexIterate (Lit |run#0@@84|) (Lit |needle#0@@12|) (LitInt 0)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3432|
 :pattern ( (Sequences.__default.SeqIndex Sequences._default.SeqIndex$A@@5 ($LS $ly@@166) (Lit |run#0@@84|) (Lit |needle#0@@12|)))
))))
(assert (forall ((arg0@@534 T@U) (arg1@@247 T@U) (arg2@@122 Int) (arg3@@67 T@U) ) (! (= (type (Sequences.__default.SeqOfLength arg0@@534 arg1@@247 arg2@@122 arg3@@67)) (SeqType BoxType))
 :qid |funType:Sequences.__default.SeqOfLength|
 :pattern ( (Sequences.__default.SeqOfLength arg0@@534 arg1@@247 arg2@@122 arg3@@67))
)))
(assert (forall ((Sequences._default.SeqOfLength$V T@U) ($ly@@167 T@U) (|length#0@@5| Int) (|v#0@@68| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqOfLength$V) TyType) (= (type $ly@@167) LayerTypeType)) (= (type |v#0@@68|) BoxType)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V ($LS $ly@@167) |length#0@@5| |v#0@@68|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V $ly@@167 |length#0@@5| |v#0@@68|)))
 :qid |unknown.0:0|
 :skolemid |3433|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V ($LS $ly@@167) |length#0@@5| |v#0@@68|))
)))
(assert (forall ((Sequences._default.SeqOfLength$V@@0 T@U) ($ly@@168 T@U) (|length#0@@6| Int) (|v#0@@69| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqOfLength$V@@0) TyType) (= (type $ly@@168) LayerTypeType)) (= (type |v#0@@69|) BoxType)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 $ly@@168 |length#0@@6| |v#0@@69|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 $LZ |length#0@@6| |v#0@@69|)))
 :qid |unknown.0:0|
 :skolemid |3434|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@0 (AsFuelBottom $ly@@168) |length#0@@6| |v#0@@69|))
)))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@1 T@U) ($ly@@169 T@U) (|length#0@@7| Int) (|v#0@@70| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@1) TyType) (= (type $ly@@169) LayerTypeType)) (= (type |v#0@@70|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@1 |length#0@@7| |v#0@@70|) (and (INTERNAL_le_boogie 0 |length#0@@7|) ($IsBox |v#0@@70| Sequences._default.SeqOfLength$V@@1)))) (and (and (= (|Seq#Length| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|)) |length#0@@7|) (forall ((|i#0@@113| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@113|) (INTERNAL_lt_boogie |i#0@@113| (|Seq#Length| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|)))) (= (|Seq#Index| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|) |i#0@@113|) |v#0@@70|))
 :qid |Sequencesidfy.547:18|
 :skolemid |3435|
 :pattern ( (|Seq#Index| (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|) |i#0@@113|))
))) ($Is (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|) (TSeq Sequences._default.SeqOfLength$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3436|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@1 $ly@@169 |length#0@@7| |v#0@@70|))
))))
(assert (forall ((Sequences._default.SeqOfLength$V@@2 T@U) ($ly@@170 T@U) (|length#0@@8| Int) (|v#0@@71| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@2) TyType) (= (type $ly@@170) LayerTypeType)) (= (type |v#0@@71|) BoxType)) (and (INTERNAL_le_boogie 0 |length#0@@8|) ($IsBox |v#0@@71| Sequences._default.SeqOfLength$V@@2))) (= (|Sequences.__default.SeqOfLength#requires| Sequences._default.SeqOfLength$V@@2 $ly@@170 |length#0@@8| |v#0@@71|) true))
 :qid |unknown.0:0|
 :skolemid |3437|
 :pattern ( (|Sequences.__default.SeqOfLength#requires| Sequences._default.SeqOfLength$V@@2 $ly@@170 |length#0@@8| |v#0@@71|))
)))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@3 T@U) ($ly@@171 T@U) (|length#0@@9| Int) (|v#0@@72| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@3) TyType) (= (type $ly@@171) LayerTypeType)) (= (type |v#0@@72|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@3 |length#0@@9| |v#0@@72|) (and (INTERNAL_le_boogie 0 |length#0@@9|) ($IsBox |v#0@@72| Sequences._default.SeqOfLength$V@@3)))) (and (=> (not (= |length#0@@9| (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@3 (INTERNAL_sub_boogie |length#0@@9| 1) |v#0@@72|)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 ($LS $ly@@171) |length#0@@9| |v#0@@72|) (ite (= |length#0@@9| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) |v#0@@72|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 $ly@@171 (INTERNAL_sub_boogie |length#0@@9| 1) |v#0@@72|))))))
 :qid |unknown.0:0|
 :skolemid |3438|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@3 ($LS $ly@@171) |length#0@@9| |v#0@@72|))
))))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@4 T@U) ($ly@@172 T@U) (|length#0@@10| Int) (|v#0@@73| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@4) TyType) (= (type $ly@@172) LayerTypeType)) (= (type |v#0@@73|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@4 (LitInt |length#0@@10|) |v#0@@73|) (and (INTERNAL_le_boogie 0 |length#0@@10|) ($IsBox |v#0@@73| Sequences._default.SeqOfLength$V@@4)))) (and (=> (not (= (LitInt |length#0@@10|) (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@4 (LitInt (INTERNAL_sub_boogie |length#0@@10| 1)) |v#0@@73|)) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@172) (LitInt |length#0@@10|) |v#0@@73|) (ite (= (LitInt |length#0@@10|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) |v#0@@73|) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@172) (LitInt (INTERNAL_sub_boogie |length#0@@10| 1)) |v#0@@73|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3439|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@4 ($LS $ly@@172) (LitInt |length#0@@10|) |v#0@@73|))
))))
(assert  (=> true (forall ((Sequences._default.SeqOfLength$V@@5 T@U) ($ly@@173 T@U) (|length#0@@11| Int) (|v#0@@74| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqOfLength$V@@5) TyType) (= (type $ly@@173) LayerTypeType)) (= (type |v#0@@74|) BoxType)) (or (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@5 (LitInt |length#0@@11|) (Lit |v#0@@74|)) (and (INTERNAL_le_boogie 0 |length#0@@11|) ($IsBox |v#0@@74| Sequences._default.SeqOfLength$V@@5)))) (and (=> (not (= (LitInt |length#0@@11|) (LitInt 0))) (|Sequences.__default.SeqOfLength#canCall| Sequences._default.SeqOfLength$V@@5 (LitInt (INTERNAL_sub_boogie |length#0@@11| 1)) (Lit |v#0@@74|))) (= (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@173) (LitInt |length#0@@11|) (Lit |v#0@@74|)) (ite (= (LitInt |length#0@@11|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) (Lit |v#0@@74|)) (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@173) (LitInt (INTERNAL_sub_boogie |length#0@@11| 1)) (Lit |v#0@@74|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3440|
 :pattern ( (Sequences.__default.SeqOfLength Sequences._default.SeqOfLength$V@@5 ($LS $ly@@173) (LitInt |length#0@@11|) (Lit |v#0@@74|)))
))))
(assert (forall ((arg0@@535 T@U) (arg1@@248 T@U) (arg2@@123 T@U) (arg3@@68 Int) (arg4@@41 T@U) ) (! (= (type (Sequences.__default.SeqIndexUpdate arg0@@535 arg1@@248 arg2@@123 arg3@@68 arg4@@41)) (SeqType BoxType))
 :qid |funType:Sequences.__default.SeqIndexUpdate|
 :pattern ( (Sequences.__default.SeqIndexUpdate arg0@@535 arg1@@248 arg2@@123 arg3@@68 arg4@@41))
)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T T@U) ($ly@@174 T@U) (|s#0@@90| T@U) (|i#0@@114| Int) (|t#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexUpdate$T) TyType) (= (type $ly@@174) LayerTypeType)) (= (type |s#0@@90|) (SeqType BoxType))) (= (type |t#0|) BoxType)) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T ($LS $ly@@174) |s#0@@90| |i#0@@114| |t#0|) (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T $ly@@174 |s#0@@90| |i#0@@114| |t#0|)))
 :qid |unknown.0:0|
 :skolemid |3441|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T ($LS $ly@@174) |s#0@@90| |i#0@@114| |t#0|))
)))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@0 T@U) ($ly@@175 T@U) (|s#0@@91| T@U) (|i#0@@115| Int) (|t#0@@0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@0) TyType) (= (type $ly@@175) LayerTypeType)) (= (type |s#0@@91|) (SeqType BoxType))) (= (type |t#0@@0|) BoxType)) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 $ly@@175 |s#0@@91| |i#0@@115| |t#0@@0|) (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 $LZ |s#0@@91| |i#0@@115| |t#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3442|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@0 (AsFuelBottom $ly@@175) |s#0@@91| |i#0@@115| |t#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@1 T@U) ($ly@@176 T@U) (|s#0@@92| T@U) (|i#0@@116| Int) (|t#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@1) TyType) (= (type $ly@@176) LayerTypeType)) (= (type |s#0@@92|) (SeqType BoxType))) (= (type |t#0@@1|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@1 |s#0@@92| |i#0@@116| |t#0@@1|) (and (and (and ($Is |s#0@@92| (TSeq Sequences._default.SeqIndexUpdate$T@@1)) (and (INTERNAL_le_boogie 0 |i#0@@116|) (INTERNAL_lt_boogie |i#0@@116| 18446744073709551616))) ($IsBox |t#0@@1| Sequences._default.SeqIndexUpdate$T@@1)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@116| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@116|) (INTERNAL_lt_boogie |i#0@@116| (|Seq#Length| |s#0@@92|))))))) (and (|Seq#Equal| (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@176 |s#0@@92| |i#0@@116| |t#0@@1|) (|Seq#Update| |s#0@@92| |i#0@@116| |t#0@@1|)) ($Is (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@176 |s#0@@92| |i#0@@116| |t#0@@1|) (TSeq Sequences._default.SeqIndexUpdate$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3443|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@1 $ly@@176 |s#0@@92| |i#0@@116| |t#0@@1|))
))))
(assert (forall ((Sequences._default.SeqIndexUpdate$T@@2 T@U) ($ly@@177 T@U) (|s#0@@93| T@U) (|i#0@@117| Int) (|t#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@2) TyType) (= (type $ly@@177) LayerTypeType)) (= (type |s#0@@93|) (SeqType BoxType))) (= (type |t#0@@2|) BoxType)) (and (and ($Is |s#0@@93| (TSeq Sequences._default.SeqIndexUpdate$T@@2)) (and (INTERNAL_le_boogie 0 |i#0@@117|) (INTERNAL_lt_boogie |i#0@@117| 18446744073709551616))) ($IsBox |t#0@@2| Sequences._default.SeqIndexUpdate$T@@2))) (= (|Sequences.__default.SeqIndexUpdate#requires| Sequences._default.SeqIndexUpdate$T@@2 $ly@@177 |s#0@@93| |i#0@@117| |t#0@@2|)  (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@117| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@117|) (INTERNAL_lt_boogie |i#0@@117| (|Seq#Length| |s#0@@93|))))))
 :qid |unknown.0:0|
 :skolemid |3444|
 :pattern ( (|Sequences.__default.SeqIndexUpdate#requires| Sequences._default.SeqIndexUpdate$T@@2 $ly@@177 |s#0@@93| |i#0@@117| |t#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@3 T@U) ($ly@@178 T@U) (|s#0@@94| T@U) (|i#0@@118| Int) (|t#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@3) TyType) (= (type $ly@@178) LayerTypeType)) (= (type |s#0@@94|) (SeqType BoxType))) (= (type |t#0@@3|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@3 |s#0@@94| |i#0@@118| |t#0@@3|) (and (and (and ($Is |s#0@@94| (TSeq Sequences._default.SeqIndexUpdate$T@@3)) (and (INTERNAL_le_boogie 0 |i#0@@118|) (INTERNAL_lt_boogie |i#0@@118| 18446744073709551616))) ($IsBox |t#0@@3| Sequences._default.SeqIndexUpdate$T@@3)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@118| 1) 18446744073709551616) (and (INTERNAL_le_boogie 0 |i#0@@118|) (INTERNAL_lt_boogie |i#0@@118| (|Seq#Length| |s#0@@94|))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@3 ($LS $ly@@178) |s#0@@94| |i#0@@118| |t#0@@3|) (|Seq#Append| (|Seq#Append| (|Seq#Take| |s#0@@94| |i#0@@118|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@3|)) (|Seq#Drop| |s#0@@94| (INTERNAL_add_boogie |i#0@@118| 1)))))
 :qid |unknown.0:0|
 :skolemid |3445|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@3 ($LS $ly@@178) |s#0@@94| |i#0@@118| |t#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@4 T@U) ($ly@@179 T@U) (|s#0@@95| T@U) (|i#0@@119| Int) (|t#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@4) TyType) (= (type $ly@@179) LayerTypeType)) (= (type |s#0@@95|) (SeqType BoxType))) (= (type |t#0@@4|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@4 (Lit |s#0@@95|) (LitInt |i#0@@119|) |t#0@@4|) (and (and (and ($Is |s#0@@95| (TSeq Sequences._default.SeqIndexUpdate$T@@4)) (and (INTERNAL_le_boogie 0 |i#0@@119|) (INTERNAL_lt_boogie |i#0@@119| 18446744073709551616))) ($IsBox |t#0@@4| Sequences._default.SeqIndexUpdate$T@@4)) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@119| 1) 18446744073709551616)))) (and (INTERNAL_le_boogie 0 |i#0@@119|) (INTERNAL_lt_boogie |i#0@@119| (|Seq#Length| (Lit |s#0@@95|)))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@4 ($LS $ly@@179) (Lit |s#0@@95|) (LitInt |i#0@@119|) |t#0@@4|) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@95|) (LitInt |i#0@@119|)) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@4|)) (|Seq#Drop| (Lit |s#0@@95|) (LitInt (INTERNAL_add_boogie |i#0@@119| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3446|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@4 ($LS $ly@@179) (Lit |s#0@@95|) (LitInt |i#0@@119|) |t#0@@4|))
))))
(assert  (=> true (forall ((Sequences._default.SeqIndexUpdate$T@@5 T@U) ($ly@@180 T@U) (|s#0@@96| T@U) (|i#0@@120| Int) (|t#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.SeqIndexUpdate$T@@5) TyType) (= (type $ly@@180) LayerTypeType)) (= (type |s#0@@96|) (SeqType BoxType))) (= (type |t#0@@5|) BoxType)) (or (|Sequences.__default.SeqIndexUpdate#canCall| Sequences._default.SeqIndexUpdate$T@@5 (Lit |s#0@@96|) (LitInt |i#0@@120|) (Lit |t#0@@5|)) (and (and (and ($Is |s#0@@96| (TSeq Sequences._default.SeqIndexUpdate$T@@5)) (and (INTERNAL_le_boogie 0 |i#0@@120|) (INTERNAL_lt_boogie |i#0@@120| 18446744073709551616))) ($IsBox |t#0@@5| Sequences._default.SeqIndexUpdate$T@@5)) (and (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |i#0@@120| 1) 18446744073709551616)))) (and (INTERNAL_le_boogie 0 |i#0@@120|) (INTERNAL_lt_boogie |i#0@@120| (|Seq#Length| (Lit |s#0@@96|)))))))) (= (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@5 ($LS $ly@@180) (Lit |s#0@@96|) (LitInt |i#0@@120|) (Lit |t#0@@5|)) (|Seq#Append| (|Seq#Append| (|Seq#Take| (Lit |s#0@@96|) (LitInt |i#0@@120|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |t#0@@5|))) (|Seq#Drop| (Lit |s#0@@96|) (LitInt (INTERNAL_add_boogie |i#0@@120| 1))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3447|
 :pattern ( (Sequences.__default.SeqIndexUpdate Sequences._default.SeqIndexUpdate$T@@5 ($LS $ly@@180) (Lit |s#0@@96|) (LitInt |i#0@@120|) (Lit |t#0@@5|)))
))))
(assert (forall ((arg0@@536 T@U) (arg1@@249 T@U) (arg2@@124 T@U) (arg3@@69 T@U) (arg4@@42 T@U) ) (! (= (type (Sequences.__default.Zip arg0@@536 arg1@@249 arg2@@124 arg3@@69 arg4@@42)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Zip|
 :pattern ( (Sequences.__default.Zip arg0@@536 arg1@@249 arg2@@124 arg3@@69 arg4@@42))
)))
(assert (forall ((Sequences._default.Zip$A T@U) (Sequences._default.Zip$B T@U) ($ly@@181 T@U) (|a#0@@79| T@U) (|b#0@@41| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Zip$A) TyType) (= (type Sequences._default.Zip$B) TyType)) (= (type $ly@@181) LayerTypeType)) (= (type |a#0@@79|) (SeqType BoxType))) (= (type |b#0@@41|) (SeqType BoxType))) (= (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B ($LS $ly@@181) |a#0@@79| |b#0@@41|) (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B $ly@@181 |a#0@@79| |b#0@@41|)))
 :qid |unknown.0:0|
 :skolemid |3448|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A Sequences._default.Zip$B ($LS $ly@@181) |a#0@@79| |b#0@@41|))
)))
(assert (forall ((Sequences._default.Zip$A@@0 T@U) (Sequences._default.Zip$B@@0 T@U) ($ly@@182 T@U) (|a#0@@80| T@U) (|b#0@@42| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Zip$A@@0) TyType) (= (type Sequences._default.Zip$B@@0) TyType)) (= (type $ly@@182) LayerTypeType)) (= (type |a#0@@80|) (SeqType BoxType))) (= (type |b#0@@42|) (SeqType BoxType))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 $ly@@182 |a#0@@80| |b#0@@42|) (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 $LZ |a#0@@80| |b#0@@42|)))
 :qid |unknown.0:0|
 :skolemid |3449|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@0 Sequences._default.Zip$B@@0 (AsFuelBottom $ly@@182) |a#0@@80| |b#0@@42|))
)))
(assert  (=> true (forall ((Sequences._default.Zip$A@@1 T@U) (Sequences._default.Zip$B@@1 T@U) ($ly@@183 T@U) (|a#0@@81| T@U) (|b#0@@43| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@1) TyType) (= (type Sequences._default.Zip$B@@1) TyType)) (= (type $ly@@183) LayerTypeType)) (= (type |a#0@@81|) (SeqType BoxType))) (= (type |b#0@@43|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 |a#0@@81| |b#0@@43|) (and (and ($Is |a#0@@81| (TSeq Sequences._default.Zip$A@@1)) ($Is |b#0@@43| (TSeq Sequences._default.Zip$B@@1))) (= (|Seq#Length| |a#0@@81|) (|Seq#Length| |b#0@@43|))))) (and (and (= (|Seq#Length| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|)) (|Seq#Length| |a#0@@81|)) (forall ((|i#0@@121| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@121|) (INTERNAL_lt_boogie |i#0@@121| (|Seq#Length| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|)))) (|_System.Tuple2#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|) |i#0@@121|)) (|#_System._tuple#2._#Make2| (|Seq#Index| |a#0@@81| |i#0@@121|) (|Seq#Index| |b#0@@43| |i#0@@121|)))))
 :qid |Sequencesidfy.568:20|
 :skolemid |3450|
 :pattern ( (|Seq#Index| |b#0@@43| |i#0@@121|))
 :pattern ( (|Seq#Index| |a#0@@81| |i#0@@121|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|) |i#0@@121|)))
))) ($Is (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|) (TSeq (Tclass._System.Tuple2 Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1)))))
 :qid |unknown.0:0|
 :skolemid |3451|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@1 Sequences._default.Zip$B@@1 $ly@@183 |a#0@@81| |b#0@@43|))
))))
(assert (forall ((Sequences._default.Zip$A@@2 T@U) (Sequences._default.Zip$B@@2 T@U) ($ly@@184 T@U) (|a#0@@82| T@U) (|b#0@@44| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@2) TyType) (= (type Sequences._default.Zip$B@@2) TyType)) (= (type $ly@@184) LayerTypeType)) (= (type |a#0@@82|) (SeqType BoxType))) (= (type |b#0@@44|) (SeqType BoxType))) (and ($Is |a#0@@82| (TSeq Sequences._default.Zip$A@@2)) ($Is |b#0@@44| (TSeq Sequences._default.Zip$B@@2)))) (= (|Sequences.__default.Zip#requires| Sequences._default.Zip$A@@2 Sequences._default.Zip$B@@2 $ly@@184 |a#0@@82| |b#0@@44|) (= (|Seq#Length| |a#0@@82|) (|Seq#Length| |b#0@@44|))))
 :qid |unknown.0:0|
 :skolemid |3452|
 :pattern ( (|Sequences.__default.Zip#requires| Sequences._default.Zip$A@@2 Sequences._default.Zip$B@@2 $ly@@184 |a#0@@82| |b#0@@44|))
)))
(assert  (=> true (forall ((Sequences._default.Zip$A@@3 T@U) (Sequences._default.Zip$B@@3 T@U) ($ly@@185 T@U) (|a#0@@83| T@U) (|b#0@@45| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@3) TyType) (= (type Sequences._default.Zip$B@@3) TyType)) (= (type $ly@@185) LayerTypeType)) (= (type |a#0@@83|) (SeqType BoxType))) (= (type |b#0@@45|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 |a#0@@83| |b#0@@45|) (and (and ($Is |a#0@@83| (TSeq Sequences._default.Zip$A@@3)) ($Is |b#0@@45| (TSeq Sequences._default.Zip$B@@3))) (= (|Seq#Length| |a#0@@83|) (|Seq#Length| |b#0@@45|))))) (and (=> (not (= (|Seq#Length| |a#0@@83|) (LitInt 0))) (and (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$A@@3 |a#0@@83|) (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$B@@3 |b#0@@45|)) (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 (Sequences.__default.DropLast Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.DropLast Sequences._default.Zip$B@@3 |b#0@@45|))) (and (|Sequences.__default.Last#canCall| Sequences._default.Zip$A@@3 |a#0@@83|) (|Sequences.__default.Last#canCall| Sequences._default.Zip$B@@3 |b#0@@45|)))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 ($LS $ly@@185) |a#0@@83| |b#0@@45|) (ite (= (|Seq#Length| |a#0@@83|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 $ly@@185 (Sequences.__default.DropLast Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.DropLast Sequences._default.Zip$B@@3 |b#0@@45|)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (|#_System._tuple#2._#Make2| (Sequences.__default.Last Sequences._default.Zip$A@@3 |a#0@@83|) (Sequences.__default.Last Sequences._default.Zip$B@@3 |b#0@@45|)))))))))
 :qid |unknown.0:0|
 :skolemid |3453|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@3 Sequences._default.Zip$B@@3 ($LS $ly@@185) |a#0@@83| |b#0@@45|))
))))
(assert  (=> true (forall ((Sequences._default.Zip$A@@4 T@U) (Sequences._default.Zip$B@@4 T@U) ($ly@@186 T@U) (|a#0@@84| T@U) (|b#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Sequences._default.Zip$A@@4) TyType) (= (type Sequences._default.Zip$B@@4) TyType)) (= (type $ly@@186) LayerTypeType)) (= (type |a#0@@84|) (SeqType BoxType))) (= (type |b#0@@46|) (SeqType BoxType))) (or (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 (Lit |a#0@@84|) (Lit |b#0@@46|)) (and (and ($Is |a#0@@84| (TSeq Sequences._default.Zip$A@@4)) ($Is |b#0@@46| (TSeq Sequences._default.Zip$B@@4))) (= (|Seq#Length| (Lit |a#0@@84|)) (|Seq#Length| (Lit |b#0@@46|)))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0))) (and (and (and (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$A@@4 (Lit |a#0@@84|)) (|Sequences.__default.DropLast#canCall| Sequences._default.Zip$B@@4 (Lit |b#0@@46|))) (|Sequences.__default.Zip#canCall| Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 (Lit (Sequences.__default.DropLast Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.DropLast Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))) (and (|Sequences.__default.Last#canCall| Sequences._default.Zip$A@@4 (Lit |a#0@@84|)) (|Sequences.__default.Last#canCall| Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))) (= (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@186) (Lit |a#0@@84|) (Lit |b#0@@46|)) (ite (= (|Seq#Length| (Lit |a#0@@84|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@186) (Lit (Sequences.__default.DropLast Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.DropLast Sequences._default.Zip$B@@4 (Lit |b#0@@46|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#_System._tuple#2._#Make2| (Lit (Sequences.__default.Last Sequences._default.Zip$A@@4 (Lit |a#0@@84|))) (Lit (Sequences.__default.Last Sequences._default.Zip$B@@4 (Lit |b#0@@46|))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3454|
 :pattern ( (Sequences.__default.Zip Sequences._default.Zip$A@@4 Sequences._default.Zip$B@@4 ($LS $ly@@186) (Lit |a#0@@84|) (Lit |b#0@@46|)))
))))
(assert (forall ((arg0@@537 T@U) (arg1@@250 T@U) (arg2@@125 T@U) (arg3@@70 T@U) ) (! (= (type (Sequences.__default.Unzip arg0@@537 arg1@@250 arg2@@125 arg3@@70)) DatatypeTypeType)
 :qid |funType:Sequences.__default.Unzip|
 :pattern ( (Sequences.__default.Unzip arg0@@537 arg1@@250 arg2@@125 arg3@@70))
)))
(assert (forall ((Sequences._default.Unzip$A T@U) (Sequences._default.Unzip$B T@U) ($ly@@187 T@U) (|z#0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Unzip$A) TyType) (= (type Sequences._default.Unzip$B) TyType)) (= (type $ly@@187) LayerTypeType)) (= (type |z#0|) (SeqType BoxType))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B ($LS $ly@@187) |z#0|) (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B $ly@@187 |z#0|)))
 :qid |unknown.0:0|
 :skolemid |3455|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A Sequences._default.Unzip$B ($LS $ly@@187) |z#0|))
)))
(assert (forall ((Sequences._default.Unzip$A@@0 T@U) (Sequences._default.Unzip$B@@0 T@U) ($ly@@188 T@U) (|z#0@@0| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Unzip$A@@0) TyType) (= (type Sequences._default.Unzip$B@@0) TyType)) (= (type $ly@@188) LayerTypeType)) (= (type |z#0@@0|) (SeqType BoxType))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 $ly@@188 |z#0@@0|) (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 $LZ |z#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3456|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@0 Sequences._default.Unzip$B@@0 (AsFuelBottom $ly@@188) |z#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@1 T@U) (Sequences._default.Unzip$B@@1 T@U) ($ly@@189 T@U) (|z#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@1) TyType) (= (type Sequences._default.Unzip$B@@1) TyType)) (= (type $ly@@189) LayerTypeType)) (= (type |z#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 |z#0@@1|) ($Is |z#0@@1| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1))))) (and (and (and (= (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|)))) (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))))) (= (|Seq#Length| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|)))) (|Seq#Length| |z#0@@1|))) (forall ((|i#0@@122| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@122|) (INTERNAL_lt_boogie |i#0@@122| (|Seq#Length| |z#0@@1|))) (|_System.Tuple2#Equal| (|#_System._tuple#2._#Make2| (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))) |i#0@@122|) (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))) |i#0@@122|)) ($Unbox DatatypeTypeType (|Seq#Index| |z#0@@1| |i#0@@122|)))))
 :qid |Sequencesidfy.576:20|
 :skolemid |3457|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |z#0@@1| |i#0@@122|)))
 :pattern ( (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))) |i#0@@122|))
 :pattern ( (|Seq#Index| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))) |i#0@@122|))
))) ($Is (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|) (Tclass._System.Tuple2 (TSeq Sequences._default.Unzip$A@@1) (TSeq Sequences._default.Unzip$B@@1)))))
 :qid |unknown.0:0|
 :skolemid |3458|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@1 Sequences._default.Unzip$B@@1 $ly@@189 |z#0@@1|))
))))
(assert (forall ((Sequences._default.Unzip$A@@2 T@U) (Sequences._default.Unzip$B@@2 T@U) ($ly@@190 T@U) (|z#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@2) TyType) (= (type Sequences._default.Unzip$B@@2) TyType)) (= (type $ly@@190) LayerTypeType)) (= (type |z#0@@2|) (SeqType BoxType))) ($Is |z#0@@2| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2)))) (= (|Sequences.__default.Unzip#requires| Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2 $ly@@190 |z#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |3459|
 :pattern ( (|Sequences.__default.Unzip#requires| Sequences._default.Unzip$A@@2 Sequences._default.Unzip$B@@2 $ly@@190 |z#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@3 T@U) (Sequences._default.Unzip$B@@3 T@U) ($ly@@191 T@U) (|z#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@3) TyType) (= (type Sequences._default.Unzip$B@@3) TyType)) (= (type $ly@@191) LayerTypeType)) (= (type |z#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 |z#0@@3|) ($Is |z#0@@3| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3))))) (and (=> (not (= (|Seq#Length| |z#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))) (and (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))) (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 ($LS $ly@@191) |z#0@@3|) (ite (= (|Seq#Length| |z#0@@3|) (LitInt 0)) (|#_System._tuple#2._#Make2| ($Box (Lit (|Seq#Empty| BoxType))) ($Box (Lit (|Seq#Empty| BoxType)))) (let ((|b#0@@47| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 $ly@@191 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))
(let ((|a#0@@85| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 $ly@@191 (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|))))))
(|#_System._tuple#2._#Make2| ($Box (|Seq#Append| |a#0@@85| (|Seq#Build| (|Seq#Empty| BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))))) ($Box (|Seq#Append| |b#0@@47| (|Seq#Build| (|Seq#Empty| BoxType) (_System.Tuple2._1 ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3) |z#0@@3|)))))))))))))
 :qid |unknown.0:0|
 :skolemid |3460|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@3 Sequences._default.Unzip$B@@3 ($LS $ly@@191) |z#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.Unzip$A@@4 T@U) (Sequences._default.Unzip$B@@4 T@U) ($ly@@192 T@U) (|z#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Sequences._default.Unzip$A@@4) TyType) (= (type Sequences._default.Unzip$B@@4) TyType)) (= (type $ly@@192) LayerTypeType)) (= (type |z#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 (Lit |z#0@@4|)) ($Is |z#0@@4| (TSeq (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4))))) (and (=> (not (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (|Sequences.__default.Unzip#canCall| Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))) (and (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (_System.Tuple2.___hMake2_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)))))) (and (|Sequences.__default.Last#canCall| (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|)) (_System.Tuple2.___hMake2_q (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))) (= (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@192) (Lit |z#0@@4|)) (ite (= (|Seq#Length| (Lit |z#0@@4|)) (LitInt 0)) (|#_System._tuple#2._#Make2| ($Box (Lit (|Seq#Empty| BoxType))) ($Box (Lit (|Seq#Empty| BoxType)))) (let ((|b#1| ($Unbox (SeqType BoxType) (_System.Tuple2._1 (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@192) (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))
(let ((|a#1| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@192) (Lit (Sequences.__default.DropLast (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))
(|#_System._tuple#2._#Make2| ($Box (|Seq#Append| |a#1| (|Seq#Build| (|Seq#Empty| BoxType) (Lit (_System.Tuple2._0 (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))) ($Box (|Seq#Append| |b#1| (|Seq#Build| (|Seq#Empty| BoxType) (Lit (_System.Tuple2._1 (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last (Tclass._System.Tuple2 Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4) (Lit |z#0@@4|))))))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3461|
 :pattern ( (Sequences.__default.Unzip Sequences._default.Unzip$A@@4 Sequences._default.Unzip$B@@4 ($LS $ly@@192) (Lit |z#0@@4|)))
))))
(assert (forall ((arg0@@538 T@U) (arg1@@251 T@U) (arg2@@126 T@U) ) (! (= (type (Sequences.__default.FlattenShape arg0@@538 arg1@@251 arg2@@126)) (SeqType BoxType))
 :qid |funType:Sequences.__default.FlattenShape|
 :pattern ( (Sequences.__default.FlattenShape arg0@@538 arg1@@251 arg2@@126))
)))
(assert (forall ((Sequences._default.FlattenShape$A T@U) ($ly@@193 T@U) (|seqs#0| T@U) ) (!  (=> (and (and (= (type Sequences._default.FlattenShape$A) TyType) (= (type $ly@@193) LayerTypeType)) (= (type |seqs#0|) (SeqType BoxType))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A ($LS $ly@@193) |seqs#0|) (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A $ly@@193 |seqs#0|)))
 :qid |unknown.0:0|
 :skolemid |3462|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A ($LS $ly@@193) |seqs#0|))
)))
(assert (forall ((Sequences._default.FlattenShape$A@@0 T@U) ($ly@@194 T@U) (|seqs#0@@0| T@U) ) (!  (=> (and (and (= (type Sequences._default.FlattenShape$A@@0) TyType) (= (type $ly@@194) LayerTypeType)) (= (type |seqs#0@@0|) (SeqType BoxType))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 $ly@@194 |seqs#0@@0|) (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 $LZ |seqs#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3463|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@0 (AsFuelBottom $ly@@194) |seqs#0@@0|))
)))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@1 T@U) ($ly@@195 T@U) (|seqs#0@@1| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@1) TyType) (= (type $ly@@195) LayerTypeType)) (= (type |seqs#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@1 |seqs#0@@1|) ($Is |seqs#0@@1| (TSeq (TSeq Sequences._default.FlattenShape$A@@1))))) (and (and (= (|Seq#Length| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|)) (|Seq#Length| |seqs#0@@1|)) (forall ((|i#0@@123| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@123|) (INTERNAL_lt_boogie |i#0@@123| (|Seq#Length| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|)))) (= (U_2_int ($Unbox intType (|Seq#Index| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|) |i#0@@123|))) (|Seq#Length| ($Unbox (SeqType BoxType) (|Seq#Index| |seqs#0@@1| |i#0@@123|))))))
 :qid |Sequencesidfy.598:20|
 :skolemid |3464|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |seqs#0@@1| |i#0@@123|)))
 :pattern ( ($Unbox intType (|Seq#Index| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|) |i#0@@123|)))
))) ($Is (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|) (TSeq Tclass._System.nat))))
 :qid |unknown.0:0|
 :skolemid |3465|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@1 $ly@@195 |seqs#0@@1|))
))))
(assert (forall ((Sequences._default.FlattenShape$A@@2 T@U) ($ly@@196 T@U) (|seqs#0@@2| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@2) TyType) (= (type $ly@@196) LayerTypeType)) (= (type |seqs#0@@2|) (SeqType BoxType))) ($Is |seqs#0@@2| (TSeq (TSeq Sequences._default.FlattenShape$A@@2)))) (= (|Sequences.__default.FlattenShape#requires| Sequences._default.FlattenShape$A@@2 $ly@@196 |seqs#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |3466|
 :pattern ( (|Sequences.__default.FlattenShape#requires| Sequences._default.FlattenShape$A@@2 $ly@@196 |seqs#0@@2|))
)))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@3 T@U) ($ly@@197 T@U) (|seqs#0@@3| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@3) TyType) (= (type $ly@@197) LayerTypeType)) (= (type |seqs#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@3 |seqs#0@@3|) ($Is |seqs#0@@3| (TSeq (TSeq Sequences._default.FlattenShape$A@@3))))) (and (=> (not (= (|Seq#Length| |seqs#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|) (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 ($LS $ly@@197) |seqs#0@@3|) (ite (= (|Seq#Length| |seqs#0@@3|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 $ly@@197 (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (|Seq#Length| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.FlattenShape$A@@3) |seqs#0@@3|)))))))))))
 :qid |unknown.0:0|
 :skolemid |3467|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@3 ($LS $ly@@197) |seqs#0@@3|))
))))
(assert  (=> true (forall ((Sequences._default.FlattenShape$A@@4 T@U) ($ly@@198 T@U) (|seqs#0@@4| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.FlattenShape$A@@4) TyType) (= (type $ly@@198) LayerTypeType)) (= (type |seqs#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@4 (Lit |seqs#0@@4|)) ($Is |seqs#0@@4| (TSeq (TSeq Sequences._default.FlattenShape$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)) (|Sequences.__default.FlattenShape#canCall| Sequences._default.FlattenShape$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))) (= (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@198) (Lit |seqs#0@@4|)) (ite (= (|Seq#Length| (Lit |seqs#0@@4|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@198) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U (|Seq#Length| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.FlattenShape$A@@4) (Lit |seqs#0@@4|)))))))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3468|
 :pattern ( (Sequences.__default.FlattenShape Sequences._default.FlattenShape$A@@4 ($LS $ly@@198) (Lit |seqs#0@@4|)))
))))
(assert (forall (($ly@@199 T@U) (|shape#0| T@U) ) (!  (=> (and (= (type $ly@@199) LayerTypeType) (= (type |shape#0|) (SeqType BoxType))) (= (Sequences.__default.FlattenLength ($LS $ly@@199) |shape#0|) (Sequences.__default.FlattenLength $ly@@199 |shape#0|)))
 :qid |Sequencesidfy.609:22|
 :skolemid |3469|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@199) |shape#0|))
)))
(assert (forall (($ly@@200 T@U) (|shape#0@@0| T@U) ) (!  (=> (and (= (type $ly@@200) LayerTypeType) (= (type |shape#0@@0|) (SeqType BoxType))) (= (Sequences.__default.FlattenLength $ly@@200 |shape#0@@0|) (Sequences.__default.FlattenLength $LZ |shape#0@@0|)))
 :qid |Sequencesidfy.609:22|
 :skolemid |3470|
 :pattern ( (Sequences.__default.FlattenLength (AsFuelBottom $ly@@200) |shape#0@@0|))
)))
(assert  (=> true (forall (($ly@@201 T@U) (|shape#0@@1| T@U) ) (!  (=> (and (and (= (type $ly@@201) LayerTypeType) (= (type |shape#0@@1|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| |shape#0@@1|) ($Is |shape#0@@1| (TSeq Tclass._System.nat)))) (and (=> (= (|Seq#Length| |shape#0@@1|) (LitInt 0)) (= (Sequences.__default.FlattenLength $ly@@201 |shape#0@@1|) (LitInt 0))) (INTERNAL_le_boogie 0 (Sequences.__default.FlattenLength $ly@@201 |shape#0@@1|))))
 :qid |Sequencesidfy.609:22|
 :skolemid |3471|
 :pattern ( (Sequences.__default.FlattenLength $ly@@201 |shape#0@@1|))
))))
(assert (forall (($ly@@202 T@U) (|shape#0@@2| T@U) ) (!  (=> (and (and (= (type $ly@@202) LayerTypeType) (= (type |shape#0@@2|) (SeqType BoxType))) ($Is |shape#0@@2| (TSeq Tclass._System.nat))) (= (|Sequences.__default.FlattenLength#requires| $ly@@202 |shape#0@@2|) true))
 :qid |Sequencesidfy.609:22|
 :skolemid |3472|
 :pattern ( (|Sequences.__default.FlattenLength#requires| $ly@@202 |shape#0@@2|))
)))
(assert  (=> true (forall (($ly@@203 T@U) (|shape#0@@3| T@U) ) (!  (=> (and (and (= (type $ly@@203) LayerTypeType) (= (type |shape#0@@3|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| |shape#0@@3|) ($Is |shape#0@@3| (TSeq Tclass._System.nat)))) (and (=> (not (= (|Seq#Length| |shape#0@@3|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@3|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@3|))) (|Sequences.__default.Last#canCall| Tclass._System.nat |shape#0@@3|))) (= (Sequences.__default.FlattenLength ($LS $ly@@203) |shape#0@@3|) (ite (= (|Seq#Length| |shape#0@@3|) (LitInt 0)) 0 (INTERNAL_add_boogie (Sequences.__default.FlattenLength $ly@@203 (Sequences.__default.DropLast Tclass._System.nat |shape#0@@3|)) (U_2_int ($Unbox intType (Sequences.__default.Last Tclass._System.nat |shape#0@@3|))))))))
 :qid |Sequencesidfy.609:22|
 :skolemid |3473|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@203) |shape#0@@3|))
))))
(assert  (=> true (forall (($ly@@204 T@U) (|shape#0@@4| T@U) ) (!  (=> (and (and (= (type $ly@@204) LayerTypeType) (= (type |shape#0@@4|) (SeqType BoxType))) (or (|Sequences.__default.FlattenLength#canCall| (Lit |shape#0@@4|)) ($Is |shape#0@@4| (TSeq Tclass._System.nat)))) (and (=> (not (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@4|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@4|))))) (|Sequences.__default.Last#canCall| Tclass._System.nat (Lit |shape#0@@4|)))) (= (Sequences.__default.FlattenLength ($LS $ly@@204) (Lit |shape#0@@4|)) (ite (= (|Seq#Length| (Lit |shape#0@@4|)) (LitInt 0)) 0 (INTERNAL_add_boogie (Sequences.__default.FlattenLength ($LS $ly@@204) (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@4|)))) (U_2_int ($Unbox intType (Sequences.__default.Last Tclass._System.nat (Lit |shape#0@@4|)))))))))
 :qid |Sequencesidfy.609:22|
 :weight 3
 :skolemid |3474|
 :pattern ( (Sequences.__default.FlattenLength ($LS $ly@@204) (Lit |shape#0@@4|)))
))))
(assert (forall ((arg0@@539 T@U) (arg1@@252 T@U) (arg2@@127 T@U) ) (! (= (type (Sequences.__default.Flatten arg0@@539 arg1@@252 arg2@@127)) (SeqType BoxType))
 :qid |funType:Sequences.__default.Flatten|
 :pattern ( (Sequences.__default.Flatten arg0@@539 arg1@@252 arg2@@127))
)))
(assert (forall ((Sequences._default.Flatten$A T@U) ($ly@@205 T@U) (|seqs#0@@5| T@U) ) (!  (=> (and (and (= (type Sequences._default.Flatten$A) TyType) (= (type $ly@@205) LayerTypeType)) (= (type |seqs#0@@5|) (SeqType BoxType))) (= (Sequences.__default.Flatten Sequences._default.Flatten$A ($LS $ly@@205) |seqs#0@@5|) (Sequences.__default.Flatten Sequences._default.Flatten$A $ly@@205 |seqs#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |3475|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A ($LS $ly@@205) |seqs#0@@5|))
)))
(assert (forall ((Sequences._default.Flatten$A@@0 T@U) ($ly@@206 T@U) (|seqs#0@@6| T@U) ) (!  (=> (and (and (= (type Sequences._default.Flatten$A@@0) TyType) (= (type $ly@@206) LayerTypeType)) (= (type |seqs#0@@6|) (SeqType BoxType))) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 $ly@@206 |seqs#0@@6|) (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 $LZ |seqs#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3476|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@0 (AsFuelBottom $ly@@206) |seqs#0@@6|))
)))
(assert  (and (= (type StartFuel_Sequences._default.FlattenLength) LayerTypeType) (= (type StartFuel_Sequences._default.FlattenShape) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@1 T@U) ($ly@@207 T@U) (|seqs#0@@7| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@1) TyType) (= (type $ly@@207) LayerTypeType)) (= (type |seqs#0@@7|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@1 |seqs#0@@7|) ($Is |seqs#0@@7| (TSeq (TSeq Sequences._default.Flatten$A@@1))))) (and (and (= (|Seq#Length| (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@207 |seqs#0@@7|)) (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.FlattenShape Sequences._default.Flatten$A@@1 StartFuel_Sequences._default.FlattenShape |seqs#0@@7|))) (=> (= (|Seq#Length| |seqs#0@@7|) (LitInt 0)) (= (|Seq#Length| (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@207 |seqs#0@@7|)) (LitInt 0)))) ($Is (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@207 |seqs#0@@7|) (TSeq Sequences._default.Flatten$A@@1))))
 :qid |unknown.0:0|
 :skolemid |3477|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@1 $ly@@207 |seqs#0@@7|))
))))
(assert (forall ((Sequences._default.Flatten$A@@2 T@U) ($ly@@208 T@U) (|seqs#0@@8| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@2) TyType) (= (type $ly@@208) LayerTypeType)) (= (type |seqs#0@@8|) (SeqType BoxType))) ($Is |seqs#0@@8| (TSeq (TSeq Sequences._default.Flatten$A@@2)))) (= (|Sequences.__default.Flatten#requires| Sequences._default.Flatten$A@@2 $ly@@208 |seqs#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |3478|
 :pattern ( (|Sequences.__default.Flatten#requires| Sequences._default.Flatten$A@@2 $ly@@208 |seqs#0@@8|))
)))
(assert  (and (= (type MoreFuel_Sequences._default.FlattenShape0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.FlattenShape) LayerTypeType)))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@3 T@U) ($ly@@209 T@U) (|seqs#0@@9| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@3) TyType) (= (type $ly@@209) LayerTypeType)) (= (type |seqs#0@@9|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@3 |seqs#0@@9|) ($Is |seqs#0@@9| (TSeq (TSeq Sequences._default.Flatten$A@@3))))) (and (=> (not (= (|Seq#Length| |seqs#0@@9|) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|) (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@3 (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))) (and (and (and (= StartFuel_Sequences._default.FlattenShape ($LS MoreFuel_Sequences._default.FlattenShape0)) (= StartFuelAssert_Sequences._default.FlattenShape ($LS ($LS MoreFuel_Sequences._default.FlattenShape0)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape0) MoreFuel_Sequences._default.FlattenShape0)) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 ($LS $ly@@209) |seqs#0@@9|) (ite (= (|Seq#Length| |seqs#0@@9|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 $ly@@209 (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|)) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.Flatten$A@@3) |seqs#0@@9|))))))))
 :qid |unknown.0:0|
 :skolemid |3479|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@3 ($LS $ly@@209) |seqs#0@@9|))
))))
(assert (= (type MoreFuel_Sequences._default.FlattenShape1) LayerTypeType))
(assert  (=> true (forall ((Sequences._default.Flatten$A@@4 T@U) ($ly@@210 T@U) (|seqs#0@@10| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.Flatten$A@@4) TyType) (= (type $ly@@210) LayerTypeType)) (= (type |seqs#0@@10|) (SeqType BoxType))) (or (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@4 (Lit |seqs#0@@10|)) ($Is |seqs#0@@10| (TSeq (TSeq Sequences._default.Flatten$A@@4))))) (and (=> (not (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0))) (and (and (|Sequences.__default.DropLast#canCall| (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)) (|Sequences.__default.Flatten#canCall| Sequences._default.Flatten$A@@4 (Lit (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|))))) (|Sequences.__default.Last#canCall| (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))) (and (and (and (= StartFuel_Sequences._default.FlattenShape ($LS MoreFuel_Sequences._default.FlattenShape1)) (= StartFuelAssert_Sequences._default.FlattenShape ($LS ($LS MoreFuel_Sequences._default.FlattenShape1)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenShape1) MoreFuel_Sequences._default.FlattenShape1)) (= (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@210) (Lit |seqs#0@@10|)) (ite (= (|Seq#Length| (Lit |seqs#0@@10|)) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@210) (Lit (Sequences.__default.DropLast (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))) ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Sequences._default.Flatten$A@@4) (Lit |seqs#0@@10|)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3480|
 :pattern ( (Sequences.__default.Flatten Sequences._default.Flatten$A@@4 ($LS $ly@@210) (Lit |seqs#0@@10|)))
))))
(assert  (=> true (forall ((|shape#0@@5| T@U) (|i#0@@124| Int) (|j#0@@2| Int) ) (!  (=> (and (= (type |shape#0@@5|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| |shape#0@@5| |i#0@@124| |j#0@@2|) (and (and (and ($Is |shape#0@@5| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@124|)) (INTERNAL_le_boogie 0 |j#0@@2|)) (and (INTERNAL_lt_boogie |i#0@@124| (|Seq#Length| |shape#0@@5|)) (INTERNAL_lt_boogie |j#0@@2| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@5| |i#0@@124|)))))))) (INTERNAL_le_boogie 0 (Sequences.__default.FlattenIndex |shape#0@@5| |i#0@@124| |j#0@@2|)))
 :qid |Sequencesidfy.678:25|
 :skolemid |3481|
 :pattern ( (Sequences.__default.FlattenIndex |shape#0@@5| |i#0@@124| |j#0@@2|))
))))
(assert (forall ((|shape#0@@6| T@U) (|i#0@@125| Int) (|j#0@@3| Int) ) (!  (=> (= (type |shape#0@@6|) (SeqType BoxType)) (=> (and (and ($Is |shape#0@@6| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@125|)) (INTERNAL_le_boogie 0 |j#0@@3|)) (= (|Sequences.__default.FlattenIndex#requires| |shape#0@@6| |i#0@@125| |j#0@@3|)  (and (INTERNAL_lt_boogie |i#0@@125| (|Seq#Length| |shape#0@@6|)) (INTERNAL_lt_boogie |j#0@@3| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@6| |i#0@@125|))))))))
 :qid |Sequencesidfy.678:25|
 :skolemid |3482|
 :pattern ( (|Sequences.__default.FlattenIndex#requires| |shape#0@@6| |i#0@@125| |j#0@@3|))
)))
(assert  (=> true (forall ((|shape#0@@7| T@U) (|i#0@@126| Int) (|j#0@@4| Int) ) (!  (=> (and (= (type |shape#0@@7|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| |shape#0@@7| |i#0@@126| |j#0@@4|) (and (and (and ($Is |shape#0@@7| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@126|)) (INTERNAL_le_boogie 0 |j#0@@4|)) (and (INTERNAL_lt_boogie |i#0@@126| (|Seq#Length| |shape#0@@7|)) (INTERNAL_lt_boogie |j#0@@4| (U_2_int ($Unbox intType (|Seq#Index| |shape#0@@7| |i#0@@126|)))))))) (and (|Sequences.__default.FlattenLength#canCall| (|Seq#Take| |shape#0@@7| |i#0@@126|)) (= (Sequences.__default.FlattenIndex |shape#0@@7| |i#0@@126| |j#0@@4|) (INTERNAL_add_boogie (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (|Seq#Take| |shape#0@@7| |i#0@@126|)) |j#0@@4|))))
 :qid |Sequencesidfy.678:25|
 :skolemid |3483|
 :pattern ( (Sequences.__default.FlattenIndex |shape#0@@7| |i#0@@126| |j#0@@4|))
))))
(assert  (=> true (forall ((|shape#0@@8| T@U) (|i#0@@127| Int) (|j#0@@5| Int) ) (!  (=> (and (= (type |shape#0@@8|) (SeqType BoxType)) (or (|Sequences.__default.FlattenIndex#canCall| (Lit |shape#0@@8|) (LitInt |i#0@@127|) (LitInt |j#0@@5|)) (and (and (and ($Is |shape#0@@8| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@127|)) (INTERNAL_le_boogie 0 |j#0@@5|)) (and (INTERNAL_lt_boogie |i#0@@127| (|Seq#Length| (Lit |shape#0@@8|))) (INTERNAL_lt_boogie |j#0@@5| (U_2_int ($Unbox intType (|Seq#Index| (Lit |shape#0@@8|) (LitInt |i#0@@127|))))))))) (and (|Sequences.__default.FlattenLength#canCall| (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@127|)))) (= (Sequences.__default.FlattenIndex (Lit |shape#0@@8|) (LitInt |i#0@@127|) (LitInt |j#0@@5|)) (INTERNAL_add_boogie (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (|Seq#Take| (Lit |shape#0@@8|) (LitInt |i#0@@127|)))) |j#0@@5|))))
 :qid |Sequencesidfy.678:25|
 :weight 3
 :skolemid |3484|
 :pattern ( (Sequences.__default.FlattenIndex (Lit |shape#0@@8|) (LitInt |i#0@@127|) (LitInt |j#0@@5|)))
))))
(assert (forall ((arg0@@540 T@U) (arg1@@253 T@U) (arg2@@128 Int) ) (! (= (type (Sequences.__default.UnflattenIndex arg0@@540 arg1@@253 arg2@@128)) DatatypeTypeType)
 :qid |funType:Sequences.__default.UnflattenIndex|
 :pattern ( (Sequences.__default.UnflattenIndex arg0@@540 arg1@@253 arg2@@128))
)))
(assert (forall (($ly@@211 T@U) (|shape#0@@9| T@U) (|i#0@@128| Int) ) (!  (=> (and (= (type $ly@@211) LayerTypeType) (= (type |shape#0@@9|) (SeqType BoxType))) (= (Sequences.__default.UnflattenIndex ($LS $ly@@211) |shape#0@@9| |i#0@@128|) (Sequences.__default.UnflattenIndex $ly@@211 |shape#0@@9| |i#0@@128|)))
 :qid |Sequencesidfy.685:12|
 :skolemid |3485|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@211) |shape#0@@9| |i#0@@128|))
)))
(assert (forall (($ly@@212 T@U) (|shape#0@@10| T@U) (|i#0@@129| Int) ) (!  (=> (and (= (type $ly@@212) LayerTypeType) (= (type |shape#0@@10|) (SeqType BoxType))) (= (Sequences.__default.UnflattenIndex $ly@@212 |shape#0@@10| |i#0@@129|) (Sequences.__default.UnflattenIndex $LZ |shape#0@@10| |i#0@@129|)))
 :qid |Sequencesidfy.685:12|
 :skolemid |3486|
 :pattern ( (Sequences.__default.UnflattenIndex (AsFuelBottom $ly@@212) |shape#0@@10| |i#0@@129|))
)))
(assert  (=> true (forall (($ly@@213 T@U) (|shape#0@@11| T@U) (|i#0@@130| Int) ) (!  (=> (and (and (= (type $ly@@213) LayerTypeType) (= (type |shape#0@@11|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| |shape#0@@11| |i#0@@130|) (and (and ($Is |shape#0@@11| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@130|)) (INTERNAL_lt_boogie |i#0@@130| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@11|))))) ($Is (Sequences.__default.UnflattenIndex $ly@@213 |shape#0@@11| |i#0@@130|) (Tclass._System.Tuple2 Tclass._System.nat Tclass._System.nat)))
 :qid |Sequencesidfy.685:12|
 :skolemid |3487|
 :pattern ( (Sequences.__default.UnflattenIndex $ly@@213 |shape#0@@11| |i#0@@130|))
))))
(assert (forall (($ly@@214 T@U) (|shape#0@@12| T@U) (|i#0@@131| Int) ) (!  (=> (and (and (= (type $ly@@214) LayerTypeType) (= (type |shape#0@@12|) (SeqType BoxType))) (and ($Is |shape#0@@12| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@131|))) (= (|Sequences.__default.UnflattenIndex#requires| $ly@@214 |shape#0@@12| |i#0@@131|) (INTERNAL_lt_boogie |i#0@@131| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@12|))))
 :qid |Sequencesidfy.685:12|
 :skolemid |3488|
 :pattern ( (|Sequences.__default.UnflattenIndex#requires| $ly@@214 |shape#0@@12| |i#0@@131|))
)))
(assert  (and (= (type MoreFuel_Sequences._default.FlattenLength0) LayerTypeType) (= (type StartFuelAssert_Sequences._default.FlattenLength) LayerTypeType)))
(assert  (=> true (forall (($ly@@215 T@U) (|shape#0@@13| T@U) (|i#0@@132| Int) ) (!  (=> (and (and (= (type $ly@@215) LayerTypeType) (= (type |shape#0@@13|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| |shape#0@@13| |i#0@@132|) (and (and ($Is |shape#0@@13| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@132|)) (INTERNAL_lt_boogie |i#0@@132| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength |shape#0@@13|))))) (and (and (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (=> (INTERNAL_lt_boogie |i#0@@132| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.UnflattenIndex#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|) |i#0@@132|)))) (=> (not (INTERNAL_lt_boogie |i#0@@132| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|)))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat |shape#0@@13|) (|Sequences.__default.FlattenLength#canCall| (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))))) (and (and (and (= StartFuel_Sequences._default.FlattenLength ($LS MoreFuel_Sequences._default.FlattenLength0)) (= StartFuelAssert_Sequences._default.FlattenLength ($LS ($LS MoreFuel_Sequences._default.FlattenLength0)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength0) MoreFuel_Sequences._default.FlattenLength0)) (= (Sequences.__default.UnflattenIndex ($LS $ly@@215) |shape#0@@13| |i#0@@132|) (ite (INTERNAL_lt_boogie |i#0@@132| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|))) (Sequences.__default.UnflattenIndex $ly@@215 (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|) |i#0@@132|) (|#_System._tuple#2._#Make2| ($Box (int_2_U (INTERNAL_sub_boogie (|Seq#Length| |shape#0@@13|) 1))) ($Box (int_2_U (INTERNAL_sub_boogie |i#0@@132| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Sequences.__default.DropLast Tclass._System.nat |shape#0@@13|)))))))))))
 :qid |Sequencesidfy.685:12|
 :skolemid |3489|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@215) |shape#0@@13| |i#0@@132|))
))))
(assert (= (type MoreFuel_Sequences._default.FlattenLength1) LayerTypeType))
(assert  (=> true (forall (($ly@@216 T@U) (|shape#0@@14| T@U) (|i#0@@133| Int) ) (!  (=> (and (and (= (type $ly@@216) LayerTypeType) (= (type |shape#0@@14|) (SeqType BoxType))) (or (|Sequences.__default.UnflattenIndex#canCall| (Lit |shape#0@@14|) (LitInt |i#0@@133|)) (and (and ($Is |shape#0@@14| (TSeq Tclass._System.nat)) (INTERNAL_le_boogie 0 |i#0@@133|)) (INTERNAL_lt_boogie |i#0@@133| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit |shape#0@@14|)))))) (and (and (and (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (=> (INTERNAL_lt_boogie |i#0@@133| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.UnflattenIndex#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))) (LitInt |i#0@@133|))))) (=> (not (INTERNAL_lt_boogie |i#0@@133| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass._System.nat (Lit |shape#0@@14|)) (|Sequences.__default.FlattenLength#canCall| (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))))) (and (and (and (= StartFuel_Sequences._default.FlattenLength ($LS MoreFuel_Sequences._default.FlattenLength1)) (= StartFuelAssert_Sequences._default.FlattenLength ($LS ($LS MoreFuel_Sequences._default.FlattenLength1)))) (= (AsFuelBottom MoreFuel_Sequences._default.FlattenLength1) MoreFuel_Sequences._default.FlattenLength1)) (= (Sequences.__default.UnflattenIndex ($LS $ly@@216) (Lit |shape#0@@14|) (LitInt |i#0@@133|)) (ite (INTERNAL_lt_boogie |i#0@@133| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))))) (Sequences.__default.UnflattenIndex ($LS $ly@@216) (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|))) (LitInt |i#0@@133|)) (|#_System._tuple#2._#Make2| ($Box (int_2_U (INTERNAL_sub_boogie (|Seq#Length| (Lit |shape#0@@14|)) 1))) ($Box (int_2_U (INTERNAL_sub_boogie |i#0@@133| (Sequences.__default.FlattenLength StartFuel_Sequences._default.FlattenLength (Lit (Sequences.__default.DropLast Tclass._System.nat (Lit |shape#0@@14|)))))))))))))
 :qid |Sequencesidfy.685:12|
 :weight 3
 :skolemid |3490|
 :pattern ( (Sequences.__default.UnflattenIndex ($LS $ly@@216) (Lit |shape#0@@14|) (LitInt |i#0@@133|)))
))))
(assert (forall (($ly@@217 T@U) (|s#0@@97| T@U) ) (!  (=> (and (= (type $ly@@217) LayerTypeType) (= (type |s#0@@97|) (SeqType BoxType))) (= (Sequences.__default.seqMax ($LS $ly@@217) |s#0@@97|) (Sequences.__default.seqMax $ly@@217 |s#0@@97|)))
 :qid |Sequencesidfy.795:22|
 :skolemid |3491|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@217) |s#0@@97|))
)))
(assert (forall (($ly@@218 T@U) (|s#0@@98| T@U) ) (!  (=> (and (= (type $ly@@218) LayerTypeType) (= (type |s#0@@98|) (SeqType BoxType))) (= (Sequences.__default.seqMax $ly@@218 |s#0@@98|) (Sequences.__default.seqMax $LZ |s#0@@98|)))
 :qid |Sequencesidfy.795:22|
 :skolemid |3492|
 :pattern ( (Sequences.__default.seqMax (AsFuelBottom $ly@@218) |s#0@@98|))
)))
(assert  (=> true (forall (($ly@@219 T@U) (|s#0@@99| T@U) ) (!  (=> (and (and (= (type $ly@@219) LayerTypeType) (= (type |s#0@@99|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| |s#0@@99|) (and ($Is |s#0@@99| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@99|))))) (and (forall ((|k#0@@12| T@U) ) (!  (=> (and (and (= (type |k#0@@12|) intType) true) (|Seq#Contains| |s#0@@99| ($Box |k#0@@12|))) (INTERNAL_ge_boogie (Sequences.__default.seqMax $ly@@219 |s#0@@99|) (U_2_int |k#0@@12|)))
 :qid |Sequencesidfy.797:20|
 :skolemid |3493|
 :pattern ( (|Seq#Contains| |s#0@@99| ($Box |k#0@@12|)))
)) (|Seq#Contains| |s#0@@99| ($Box (int_2_U (Sequences.__default.seqMax $ly@@219 |s#0@@99|))))))
 :qid |Sequencesidfy.795:22|
 :skolemid |3494|
 :pattern ( (Sequences.__default.seqMax $ly@@219 |s#0@@99|))
))))
(assert (forall (($ly@@220 T@U) (|s#0@@100| T@U) ) (!  (=> (and (and (= (type $ly@@220) LayerTypeType) (= (type |s#0@@100|) (SeqType BoxType))) ($Is |s#0@@100| (TSeq TInt))) (= (|Sequences.__default.seqMax#requires| $ly@@220 |s#0@@100|) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@100|))))
 :qid |Sequencesidfy.795:22|
 :skolemid |3495|
 :pattern ( (|Sequences.__default.seqMax#requires| $ly@@220 |s#0@@100|))
)))
(assert  (=> true (forall (($ly@@221 T@U) (|s#0@@101| T@U) ) (!  (=> (and (and (= (type $ly@@221) LayerTypeType) (= (type |s#0@@101|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| |s#0@@101|) (and ($Is |s#0@@101| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| |s#0@@101|))))) (and (=> (not (= (|Seq#Length| |s#0@@101|) (LitInt 1))) (and (and (and (|Sequences.__default.DropLast#canCall| TInt |s#0@@101|) (|Sequences.__default.seqMax#canCall| (Sequences.__default.DropLast TInt |s#0@@101|))) (|Sequences.__default.Last#canCall| TInt |s#0@@101|)) (|Mathematics.__default.max#canCall| (Sequences.__default.seqMax $ly@@221 (Sequences.__default.DropLast TInt |s#0@@101|)) (U_2_int ($Unbox intType (Sequences.__default.Last TInt |s#0@@101|)))))) (= (Sequences.__default.seqMax ($LS $ly@@221) |s#0@@101|) (ite (= (|Seq#Length| |s#0@@101|) (LitInt 1)) (U_2_int ($Unbox intType (|Seq#Index| |s#0@@101| (LitInt 0)))) (Mathematics.__default.max (Sequences.__default.seqMax $ly@@221 (Sequences.__default.DropLast TInt |s#0@@101|)) (U_2_int ($Unbox intType (Sequences.__default.Last TInt |s#0@@101|))))))))
 :qid |Sequencesidfy.795:22|
 :skolemid |3496|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@221) |s#0@@101|))
))))
(assert  (=> true (forall (($ly@@222 T@U) (|s#0@@102| T@U) ) (!  (=> (and (and (= (type $ly@@222) LayerTypeType) (= (type |s#0@@102|) (SeqType BoxType))) (or (|Sequences.__default.seqMax#canCall| (Lit |s#0@@102|)) (and ($Is |s#0@@102| (TSeq TInt)) (INTERNAL_lt_boogie 0 (|Seq#Length| (Lit |s#0@@102|)))))) (and (=> (not (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1))) (and (and (and (|Sequences.__default.DropLast#canCall| TInt (Lit |s#0@@102|)) (|Sequences.__default.seqMax#canCall| (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|))))) (|Sequences.__default.Last#canCall| TInt (Lit |s#0@@102|))) (|Mathematics.__default.max#canCall| (Sequences.__default.seqMax ($LS $ly@@222) (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))) (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last TInt (Lit |s#0@@102|)))))))) (= (Sequences.__default.seqMax ($LS $ly@@222) (Lit |s#0@@102|)) (ite (= (|Seq#Length| (Lit |s#0@@102|)) (LitInt 1)) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@102|) (LitInt 0)))) (Mathematics.__default.max (Sequences.__default.seqMax ($LS $ly@@222) (Lit (Sequences.__default.DropLast TInt (Lit |s#0@@102|)))) (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last TInt (Lit |s#0@@102|))))))))))
 :qid |Sequencesidfy.795:22|
 :weight 3
 :skolemid |3497|
 :pattern ( (Sequences.__default.seqMax ($LS $ly@@222) (Lit |s#0@@102|)))
))))
(assert (forall ((arg0@@541 T@U) (arg1@@254 T@U) (arg2@@129 Int) (arg3@@71 T@U) ) (! (= (type (Sequences.__default.fill arg0@@541 arg1@@254 arg2@@129 arg3@@71)) (SeqType BoxType))
 :qid |funType:Sequences.__default.fill|
 :pattern ( (Sequences.__default.fill arg0@@541 arg1@@254 arg2@@129 arg3@@71))
)))
(assert (forall ((Sequences._default.fill$T T@U) ($ly@@223 T@U) (|n#0@@5| Int) (|t#0@@6| T@U) ) (!  (=> (and (and (= (type Sequences._default.fill$T) TyType) (= (type $ly@@223) LayerTypeType)) (= (type |t#0@@6|) BoxType)) (= (Sequences.__default.fill Sequences._default.fill$T ($LS $ly@@223) |n#0@@5| |t#0@@6|) (Sequences.__default.fill Sequences._default.fill$T $ly@@223 |n#0@@5| |t#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3498|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T ($LS $ly@@223) |n#0@@5| |t#0@@6|))
)))
(assert (forall ((Sequences._default.fill$T@@0 T@U) ($ly@@224 T@U) (|n#0@@6| Int) (|t#0@@7| T@U) ) (!  (=> (and (and (= (type Sequences._default.fill$T@@0) TyType) (= (type $ly@@224) LayerTypeType)) (= (type |t#0@@7|) BoxType)) (= (Sequences.__default.fill Sequences._default.fill$T@@0 $ly@@224 |n#0@@6| |t#0@@7|) (Sequences.__default.fill Sequences._default.fill$T@@0 $LZ |n#0@@6| |t#0@@7|)))
 :qid |unknown.0:0|
 :skolemid |3499|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@0 (AsFuelBottom $ly@@224) |n#0@@6| |t#0@@7|))
)))
(assert  (=> true (forall ((Sequences._default.fill$T@@1 T@U) ($ly@@225 T@U) (|n#0@@7| Int) (|t#0@@8| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@1) TyType) (= (type $ly@@225) LayerTypeType)) (= (type |t#0@@8|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@1 |n#0@@7| |t#0@@8|) (and ($IsBox |t#0@@8| Sequences._default.fill$T@@1) (INTERNAL_ge_boogie |n#0@@7| 0)))) (and (and (= (|Seq#Length| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@225 |n#0@@7| |t#0@@8|)) |n#0@@7|) (forall ((|i#0@@134| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@134|) (INTERNAL_lt_boogie |i#0@@134| |n#0@@7|)) (= (|Seq#Index| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@225 |n#0@@7| |t#0@@8|) |i#0@@134|) |t#0@@8|))
 :qid |Sequencesidfy.884:18|
 :skolemid |3500|
 :pattern ( (|Seq#Index| (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@225 |n#0@@7| |t#0@@8|) |i#0@@134|))
))) ($Is (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@225 |n#0@@7| |t#0@@8|) (TSeq Sequences._default.fill$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3501|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@1 $ly@@225 |n#0@@7| |t#0@@8|))
))))
(assert (forall ((Sequences._default.fill$T@@2 T@U) ($ly@@226 T@U) (|n#0@@8| Int) (|t#0@@9| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@2) TyType) (= (type $ly@@226) LayerTypeType)) (= (type |t#0@@9|) BoxType)) ($IsBox |t#0@@9| Sequences._default.fill$T@@2)) (= (|Sequences.__default.fill#requires| Sequences._default.fill$T@@2 $ly@@226 |n#0@@8| |t#0@@9|) (INTERNAL_ge_boogie |n#0@@8| 0)))
 :qid |unknown.0:0|
 :skolemid |3502|
 :pattern ( (|Sequences.__default.fill#requires| Sequences._default.fill$T@@2 $ly@@226 |n#0@@8| |t#0@@9|))
)))
(assert  (=> true (forall ((Sequences._default.fill$T@@3 T@U) ($ly@@227 T@U) (|n#0@@9| Int) (|t#0@@10| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@3) TyType) (= (type $ly@@227) LayerTypeType)) (= (type |t#0@@10|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@3 |n#0@@9| |t#0@@10|) (and ($IsBox |t#0@@10| Sequences._default.fill$T@@3) (INTERNAL_ge_boogie |n#0@@9| 0)))) (and (=> (not (= |n#0@@9| (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@3 (INTERNAL_sub_boogie |n#0@@9| 1) |t#0@@10|)) (= (Sequences.__default.fill Sequences._default.fill$T@@3 ($LS $ly@@227) |n#0@@9| |t#0@@10|) (ite (= |n#0@@9| (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@3 $ly@@227 (INTERNAL_sub_boogie |n#0@@9| 1) |t#0@@10|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@10|))))))
 :qid |unknown.0:0|
 :skolemid |3503|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@3 ($LS $ly@@227) |n#0@@9| |t#0@@10|))
))))
(assert  (=> true (forall ((Sequences._default.fill$T@@4 T@U) ($ly@@228 T@U) (|n#0@@10| Int) (|t#0@@11| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@4) TyType) (= (type $ly@@228) LayerTypeType)) (= (type |t#0@@11|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@4 (LitInt |n#0@@10|) |t#0@@11|) (and ($IsBox |t#0@@11| Sequences._default.fill$T@@4) (INTERNAL_ge_boogie |n#0@@10| 0)))) (and (=> (not (= (LitInt |n#0@@10|) (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@4 (LitInt (INTERNAL_sub_boogie |n#0@@10| 1)) |t#0@@11|)) (= (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@228) (LitInt |n#0@@10|) |t#0@@11|) (ite (= (LitInt |n#0@@10|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@228) (LitInt (INTERNAL_sub_boogie |n#0@@10| 1)) |t#0@@11|) (|Seq#Build| (|Seq#Empty| BoxType) |t#0@@11|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3504|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@4 ($LS $ly@@228) (LitInt |n#0@@10|) |t#0@@11|))
))))
(assert  (=> true (forall ((Sequences._default.fill$T@@5 T@U) ($ly@@229 T@U) (|n#0@@11| Int) (|t#0@@12| T@U) ) (!  (=> (and (and (and (= (type Sequences._default.fill$T@@5) TyType) (= (type $ly@@229) LayerTypeType)) (= (type |t#0@@12|) BoxType)) (or (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@5 (LitInt |n#0@@11|) (Lit |t#0@@12|)) (and ($IsBox |t#0@@12| Sequences._default.fill$T@@5) (INTERNAL_ge_boogie |n#0@@11| 0)))) (and (=> (not (= (LitInt |n#0@@11|) (LitInt 0))) (|Sequences.__default.fill#canCall| Sequences._default.fill$T@@5 (LitInt (INTERNAL_sub_boogie |n#0@@11| 1)) (Lit |t#0@@12|))) (= (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@229) (LitInt |n#0@@11|) (Lit |t#0@@12|)) (ite (= (LitInt |n#0@@11|) (LitInt 0)) (|Seq#Empty| BoxType) (|Seq#Append| (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@229) (LitInt (INTERNAL_sub_boogie |n#0@@11| 1)) (Lit |t#0@@12|)) (|Seq#Build| (|Seq#Empty| BoxType) (Lit |t#0@@12|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3505|
 :pattern ( (Sequences.__default.fill Sequences._default.fill$T@@5 ($LS $ly@@229) (LitInt |n#0@@11|) (Lit |t#0@@12|)))
))))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T T@U) (|s#0@@103| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T) TyType) (= (type |s#0@@103|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T |s#0@@103|) ($Is |s#0@@103| (TSeq Sequences._default.SeqHasUniqueElems$T)))) true)
 :qid |unknown.0:0|
 :skolemid |3506|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T |s#0@@103|))
))))
(assert (forall ((Sequences._default.SeqHasUniqueElems$T@@0 T@U) (|s#0@@104| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@0) TyType) (= (type |s#0@@104|) (SeqType BoxType))) ($Is |s#0@@104| (TSeq Sequences._default.SeqHasUniqueElems$T@@0))) (= (|Sequences.__default.SeqHasUniqueElems#requires| Sequences._default.SeqHasUniqueElems$T@@0 |s#0@@104|) true))
 :qid |unknown.0:0|
 :skolemid |3507|
 :pattern ( (|Sequences.__default.SeqHasUniqueElems#requires| Sequences._default.SeqHasUniqueElems$T@@0 |s#0@@104|))
)))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T@@1 T@U) (|s#0@@105| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@1) TyType) (= (type |s#0@@105|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|) ($Is |s#0@@105| (TSeq Sequences._default.SeqHasUniqueElems$T@@1)))) (= (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|) (forall ((|i#0@@135| Int) (|j#0@@6| Int) ) (!  (=> (and (and (and (INTERNAL_le_boogie 0 |i#0@@135|) (INTERNAL_lt_boogie |i#0@@135| (|Seq#Length| |s#0@@105|))) (and (INTERNAL_le_boogie 0 |j#0@@6|) (INTERNAL_lt_boogie |j#0@@6| (|Seq#Length| |s#0@@105|)))) (= (|Seq#Index| |s#0@@105| |i#0@@135|) (|Seq#Index| |s#0@@105| |j#0@@6|))) (= |i#0@@135| |j#0@@6|))
 :qid |Sequencesidfy.896:12|
 :skolemid |3508|
 :pattern ( (|Seq#Index| |s#0@@105| |j#0@@6|) (|Seq#Index| |s#0@@105| |i#0@@135|))
))))
 :qid |unknown.0:0|
 :skolemid |3509|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@1 |s#0@@105|))
))))
(assert  (=> true (forall ((Sequences._default.SeqHasUniqueElems$T@@2 T@U) (|s#0@@106| T@U) ) (!  (=> (and (and (= (type Sequences._default.SeqHasUniqueElems$T@@2) TyType) (= (type |s#0@@106|) (SeqType BoxType))) (or (|Sequences.__default.SeqHasUniqueElems#canCall| Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)) ($Is |s#0@@106| (TSeq Sequences._default.SeqHasUniqueElems$T@@2)))) (= (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)) (forall ((|i#1@@33| Int) (|j#1@@0| Int) ) (!  (=> (and (and (and (INTERNAL_le_boogie 0 |i#1@@33|) (INTERNAL_lt_boogie |i#1@@33| (|Seq#Length| (Lit |s#0@@106|)))) (and (INTERNAL_le_boogie 0 |j#1@@0|) (INTERNAL_lt_boogie |j#1@@0| (|Seq#Length| (Lit |s#0@@106|))))) (= (|Seq#Index| (Lit |s#0@@106|) |i#1@@33|) (|Seq#Index| (Lit |s#0@@106|) |j#1@@0|))) (= |i#1@@33| |j#1@@0|))
 :qid |Sequencesidfy.896:12|
 :skolemid |3510|
 :pattern ( (|Seq#Index| |s#0@@106| |j#1@@0|) (|Seq#Index| |s#0@@106| |i#1@@33|))
))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3511|
 :pattern ( (Sequences.__default.SeqHasUniqueElems Sequences._default.SeqHasUniqueElems$T@@2 (Lit |s#0@@106|)))
))))
(assert (= (type Tclass.MapRemove_s.__default) TyType))
(assert (= (Tag Tclass.MapRemove_s.__default) Tagclass.MapRemove_s.__default))
(assert (= (TagFamily Tclass.MapRemove_s.__default) tytagFamily$_default))
(assert (forall ((bx@@153 T@U) ) (!  (=> (and (= (type bx@@153) BoxType) ($IsBox bx@@153 Tclass.MapRemove_s.__default)) (and (= ($Box ($Unbox refType bx@@153)) bx@@153) ($Is ($Unbox refType bx@@153) Tclass.MapRemove_s.__default)))
 :qid |unknown.0:0|
 :skolemid |3512|
 :pattern ( ($IsBox bx@@153 Tclass.MapRemove_s.__default))
)))
(assert (forall (($o@@41 T@U) ) (!  (=> (= (type $o@@41) refType) (= ($Is $o@@41 Tclass.MapRemove_s.__default)  (or (= $o@@41 null) (= (dtype $o@@41) Tclass.MapRemove_s.__default))))
 :qid |unknown.0:0|
 :skolemid |3513|
 :pattern ( ($Is $o@@41 Tclass.MapRemove_s.__default))
)))
(assert (forall (($o@@42 T@U) ($h@@138 T@U) ) (!  (=> (and (= (type $o@@42) refType) (= (type $h@@138) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@138)  (or (= $o@@42 null) (U_2_bool (MapType1Select (MapType0Select $h@@138 $o@@42) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3514|
 :pattern ( ($IsAlloc $o@@42 Tclass.MapRemove_s.__default $h@@138))
)))
(assert (forall ((arg0@@542 T@U) (arg1@@255 T@U) (arg2@@130 T@U) (arg3@@72 T@U) (arg4@@43 T@U) ) (! (= (type (MapRemove_s.__default.MapRemove1 arg0@@542 arg1@@255 arg2@@130 arg3@@72 arg4@@43)) (MapType BoxType BoxType))
 :qid |funType:MapRemove_s.__default.MapRemove1|
 :pattern ( (MapRemove_s.__default.MapRemove1 arg0@@542 arg1@@255 arg2@@130 arg3@@72 arg4@@43))
)))
(assert (forall ((MapRemove_s._default.MapRemove1$K T@U) (MapRemove_s._default.MapRemove1$V T@U) ($ly@@230 T@U) (|m#0@@13| T@U) (|k#0@@13| T@U) ) (!  (=> (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K) TyType) (= (type MapRemove_s._default.MapRemove1$V) TyType)) (= (type $ly@@230) LayerTypeType)) (= (type |m#0@@13|) (MapType BoxType BoxType))) (= (type |k#0@@13|) BoxType)) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V ($LS $ly@@230) |m#0@@13| |k#0@@13|) (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V $ly@@230 |m#0@@13| |k#0@@13|)))
 :qid |unknown.0:0|
 :skolemid |3515|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K MapRemove_s._default.MapRemove1$V ($LS $ly@@230) |m#0@@13| |k#0@@13|))
)))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@0 T@U) (MapRemove_s._default.MapRemove1$V@@0 T@U) ($ly@@231 T@U) (|m#0@@14| T@U) (|k#0@@14| T@U) ) (!  (=> (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@0) TyType) (= (type MapRemove_s._default.MapRemove1$V@@0) TyType)) (= (type $ly@@231) LayerTypeType)) (= (type |m#0@@14|) (MapType BoxType BoxType))) (= (type |k#0@@14|) BoxType)) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 $ly@@231 |m#0@@14| |k#0@@14|) (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 $LZ |m#0@@14| |k#0@@14|)))
 :qid |unknown.0:0|
 :skolemid |3516|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@0 MapRemove_s._default.MapRemove1$V@@0 (AsFuelBottom $ly@@231) |m#0@@14| |k#0@@14|))
)))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@1 T@U) (MapRemove_s._default.MapRemove1$V@@1 T@U) ($ly@@232 T@U) (|m#0@@15| T@U) (|k#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@1) TyType) (= (type MapRemove_s._default.MapRemove1$V@@1) TyType)) (= (type $ly@@232) LayerTypeType)) (= (type |m#0@@15|) (MapType BoxType BoxType))) (= (type |k#0@@15|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 |m#0@@15| |k#0@@15|) (and ($Is |m#0@@15| (TMap MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1)) ($IsBox |k#0@@15| MapRemove_s._default.MapRemove1$K@@1)))) (and (and (and (and (and (and (forall ((|j#0@@7| T@U) ) (!  (=> (and (and (= (type |j#0@@7|) BoxType) ($IsBox |j#0@@7| MapRemove_s._default.MapRemove1$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |j#0@@7|)) (not (= |j#0@@7| |k#0@@15|)))) (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#0@@7|)))
 :qid |MapRemovesdfy.15:20|
 :skolemid |3517|
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#0@@7|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@15|) |j#0@@7|))
)) (forall ((|j#1@@1| T@U) ) (!  (=> (and (= (type |j#1@@1|) BoxType) ($IsBox |j#1@@1| MapRemove_s._default.MapRemove1$K@@1)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#1@@1|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |j#1@@1|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#1@@1|)) (not (= |j#1@@1| |k#0@@15|)))))
 :qid |MapRemovesdfy.16:20|
 :skolemid |3518|
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@15|) |j#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#1@@1|))
))) (forall ((|j#2| T@U) ) (!  (=> (and (and (= (type |j#2|) BoxType) ($IsBox |j#2| MapRemove_s._default.MapRemove1$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#2|))) (= (MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#2|) (MapType0Select (|Map#Elements| |m#0@@15|) |j#2|)))
 :qid |MapRemovesdfy.17:20|
 :skolemid |3519|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@15|) |j#2|))
 :pattern ( (MapType0Select (|Map#Elements| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#2|))
 :pattern ( (MapType0Select (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) |j#2|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|))) (|Set#Card| (|Map#Domain| |m#0@@15|)))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |k#0@@15|)) (= (|Map#Card| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) (INTERNAL_sub_boogie (|Map#Card| |m#0@@15|) 1)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@15|) |k#0@@15|))) (= (|Map#Card| (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|)) (|Map#Card| |m#0@@15|)))) ($Is (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|) (TMap MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3520|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@1 MapRemove_s._default.MapRemove1$V@@1 $ly@@232 |m#0@@15| |k#0@@15|))
))))
(assert (forall ((MapRemove_s._default.MapRemove1$K@@2 T@U) (MapRemove_s._default.MapRemove1$V@@2 T@U) ($ly@@233 T@U) (|m#0@@16| T@U) (|k#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@2) TyType) (= (type MapRemove_s._default.MapRemove1$V@@2) TyType)) (= (type $ly@@233) LayerTypeType)) (= (type |m#0@@16|) (MapType BoxType BoxType))) (= (type |k#0@@16|) BoxType)) (and ($Is |m#0@@16| (TMap MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2)) ($IsBox |k#0@@16| MapRemove_s._default.MapRemove1$K@@2))) (= (|MapRemove_s.__default.MapRemove1#requires| MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2 $ly@@233 |m#0@@16| |k#0@@16|) true))
 :qid |unknown.0:0|
 :skolemid |3521|
 :pattern ( (|MapRemove_s.__default.MapRemove1#requires| MapRemove_s._default.MapRemove1$K@@2 MapRemove_s._default.MapRemove1$V@@2 $ly@@233 |m#0@@16| |k#0@@16|))
)))
(assert  (and (forall ((arg0@@543 T@U) (arg1@@256 T@U) (arg2@@131 T@U) ) (! (= (type (|lambda#184| arg0@@543 arg1@@256 arg2@@131)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#184|
 :pattern ( (|lambda#184| arg0@@543 arg1@@256 arg2@@131))
)) (forall ((arg0@@544 T@U) ) (! (= (type (|lambda#185| arg0@@544)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#185|
 :pattern ( (|lambda#185| arg0@@544))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@3 T@U) (MapRemove_s._default.MapRemove1$V@@3 T@U) ($ly@@234 T@U) (|m#0@@17| T@U) (|k#0@@17| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@3) TyType) (= (type MapRemove_s._default.MapRemove1$V@@3) TyType)) (= (type $ly@@234) LayerTypeType)) (= (type |m#0@@17|) (MapType BoxType BoxType))) (= (type |k#0@@17|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 |m#0@@17| |k#0@@17|) (and ($Is |m#0@@17| (TMap MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3)) ($IsBox |k#0@@17| MapRemove_s._default.MapRemove1$K@@3)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 ($LS $ly@@234) |m#0@@17| |k#0@@17|) (let ((|m'#0| (|Map#Glue| (|lambda#184| MapRemove_s._default.MapRemove1$K@@3 (|Map#Domain| |m#0@@17|) |k#0@@17|) (|lambda#185| (|Map#Elements| |m#0@@17|)) (TMap MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3))))
|m'#0|)))
 :qid |unknown.0:0|
 :skolemid |3522|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@3 MapRemove_s._default.MapRemove1$V@@3 ($LS $ly@@234) |m#0@@17| |k#0@@17|))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@4 T@U) (MapRemove_s._default.MapRemove1$V@@4 T@U) ($ly@@235 T@U) (|m#0@@18| T@U) (|k#0@@18| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@4) TyType) (= (type MapRemove_s._default.MapRemove1$V@@4) TyType)) (= (type $ly@@235) LayerTypeType)) (= (type |m#0@@18|) (MapType BoxType BoxType))) (= (type |k#0@@18|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 (Lit |m#0@@18|) |k#0@@18|) (and ($Is |m#0@@18| (TMap MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4)) ($IsBox |k#0@@18| MapRemove_s._default.MapRemove1$K@@4)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 ($LS $ly@@235) (Lit |m#0@@18|) |k#0@@18|) (let ((|m'#1| (|Map#Glue| (|lambda#184| MapRemove_s._default.MapRemove1$K@@4 (|Map#Domain| |m#0@@18|) |k#0@@18|) (|lambda#185| (|Map#Elements| (Lit |m#0@@18|))) (TMap MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4))))
|m'#1|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3523|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@4 MapRemove_s._default.MapRemove1$V@@4 ($LS $ly@@235) (Lit |m#0@@18|) |k#0@@18|))
))))
(assert  (=> true (forall ((MapRemove_s._default.MapRemove1$K@@5 T@U) (MapRemove_s._default.MapRemove1$V@@5 T@U) ($ly@@236 T@U) (|m#0@@19| T@U) (|k#0@@19| T@U) ) (!  (=> (and (and (and (and (and (= (type MapRemove_s._default.MapRemove1$K@@5) TyType) (= (type MapRemove_s._default.MapRemove1$V@@5) TyType)) (= (type $ly@@236) LayerTypeType)) (= (type |m#0@@19|) (MapType BoxType BoxType))) (= (type |k#0@@19|) BoxType)) (or (|MapRemove_s.__default.MapRemove1#canCall| MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 (Lit |m#0@@19|) (Lit |k#0@@19|)) (and ($Is |m#0@@19| (TMap MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5)) ($IsBox |k#0@@19| MapRemove_s._default.MapRemove1$K@@5)))) (= (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 ($LS $ly@@236) (Lit |m#0@@19|) (Lit |k#0@@19|)) (let ((|m'#2| (|Map#Glue| (|lambda#184| MapRemove_s._default.MapRemove1$K@@5 (|Map#Domain| |m#0@@19|) |k#0@@19|) (|lambda#185| (|Map#Elements| (Lit |m#0@@19|))) (TMap MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5))))
|m'#2|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3524|
 :pattern ( (MapRemove_s.__default.MapRemove1 MapRemove_s._default.MapRemove1$K@@5 MapRemove_s._default.MapRemove1$V@@5 ($LS $ly@@236) (Lit |m#0@@19|) (Lit |k#0@@19|)))
))))
(assert (= (type Tclass.Maps.__default) TyType))
(assert (= (Tag Tclass.Maps.__default) Tagclass.Maps.__default))
(assert (= (TagFamily Tclass.Maps.__default) tytagFamily$_default))
(assert (forall ((bx@@154 T@U) ) (!  (=> (and (= (type bx@@154) BoxType) ($IsBox bx@@154 Tclass.Maps.__default)) (and (= ($Box ($Unbox refType bx@@154)) bx@@154) ($Is ($Unbox refType bx@@154) Tclass.Maps.__default)))
 :qid |unknown.0:0|
 :skolemid |3525|
 :pattern ( ($IsBox bx@@154 Tclass.Maps.__default))
)))
(assert (forall (($o@@43 T@U) ) (!  (=> (= (type $o@@43) refType) (= ($Is $o@@43 Tclass.Maps.__default)  (or (= $o@@43 null) (= (dtype $o@@43) Tclass.Maps.__default))))
 :qid |unknown.0:0|
 :skolemid |3526|
 :pattern ( ($Is $o@@43 Tclass.Maps.__default))
)))
(assert (forall (($o@@44 T@U) ($h@@139 T@U) ) (!  (=> (and (= (type $o@@44) refType) (= (type $h@@139) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@44 Tclass.Maps.__default $h@@139)  (or (= $o@@44 null) (U_2_bool (MapType1Select (MapType0Select $h@@139 $o@@44) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3527|
 :pattern ( ($IsAlloc $o@@44 Tclass.Maps.__default $h@@139))
)))
(assert  (=> true (forall ((Maps._default.IMapsTo$K T@U) (Maps._default.IMapsTo$V T@U) (|m#0@@20| T@U) (|k#0@@20| T@U) (|v#0@@75| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K) TyType) (= (type Maps._default.IMapsTo$V) TyType)) (= (type |m#0@@20|) (IMapType BoxType BoxType))) (= (type |k#0@@20|) BoxType)) (= (type |v#0@@75|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K Maps._default.IMapsTo$V |m#0@@20| |k#0@@20| |v#0@@75|) (and (and ($Is |m#0@@20| (TIMap Maps._default.IMapsTo$K Maps._default.IMapsTo$V)) ($IsBox |k#0@@20| Maps._default.IMapsTo$K)) ($IsBox |v#0@@75| Maps._default.IMapsTo$V)))) true)
 :qid |unknown.0:0|
 :skolemid |3528|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K Maps._default.IMapsTo$V |m#0@@20| |k#0@@20| |v#0@@75|))
))))
(assert (forall ((Maps._default.IMapsTo$K@@0 T@U) (Maps._default.IMapsTo$V@@0 T@U) (|m#0@@21| T@U) (|k#0@@21| T@U) (|v#0@@76| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@0) TyType) (= (type Maps._default.IMapsTo$V@@0) TyType)) (= (type |m#0@@21|) (IMapType BoxType BoxType))) (= (type |k#0@@21|) BoxType)) (= (type |v#0@@76|) BoxType)) (and (and ($Is |m#0@@21| (TIMap Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0)) ($IsBox |k#0@@21| Maps._default.IMapsTo$K@@0)) ($IsBox |v#0@@76| Maps._default.IMapsTo$V@@0))) (= (|Maps.__default.IMapsTo#requires| Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0 |m#0@@21| |k#0@@21| |v#0@@76|) true))
 :qid |unknown.0:0|
 :skolemid |3529|
 :pattern ( (|Maps.__default.IMapsTo#requires| Maps._default.IMapsTo$K@@0 Maps._default.IMapsTo$V@@0 |m#0@@21| |k#0@@21| |v#0@@76|))
)))
(assert  (=> true (forall ((Maps._default.IMapsTo$K@@1 T@U) (Maps._default.IMapsTo$V@@1 T@U) (|m#0@@22| T@U) (|k#0@@22| T@U) (|v#0@@77| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@1) TyType) (= (type Maps._default.IMapsTo$V@@1) TyType)) (= (type |m#0@@22|) (IMapType BoxType BoxType))) (= (type |k#0@@22|) BoxType)) (= (type |v#0@@77|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@77|) (and (and ($Is |m#0@@22| (TIMap Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1)) ($IsBox |k#0@@22| Maps._default.IMapsTo$K@@1)) ($IsBox |v#0@@77| Maps._default.IMapsTo$V@@1)))) (= (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@77|)  (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@22|) |k#0@@22|)) (= (MapType0Select (|IMap#Elements| |m#0@@22|) |k#0@@22|) |v#0@@77|))))
 :qid |unknown.0:0|
 :skolemid |3530|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@1 Maps._default.IMapsTo$V@@1 |m#0@@22| |k#0@@22| |v#0@@77|))
))))
(assert  (=> true (forall ((Maps._default.IMapsTo$K@@2 T@U) (Maps._default.IMapsTo$V@@2 T@U) (|m#0@@23| T@U) (|k#0@@23| T@U) (|v#0@@78| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsTo$K@@2) TyType) (= (type Maps._default.IMapsTo$V@@2) TyType)) (= (type |m#0@@23|) (IMapType BoxType BoxType))) (= (type |k#0@@23|) BoxType)) (= (type |v#0@@78|) BoxType)) (or (|Maps.__default.IMapsTo#canCall| Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@78|)) (and (and ($Is |m#0@@23| (TIMap Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2)) ($IsBox |k#0@@23| Maps._default.IMapsTo$K@@2)) ($IsBox |v#0@@78| Maps._default.IMapsTo$V@@2)))) (= (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@78|))  (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@23|) |k#0@@23|)) (= (MapType0Select (|IMap#Elements| (Lit |m#0@@23|)) (Lit |k#0@@23|)) (Lit |v#0@@78|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3531|
 :pattern ( (Maps.__default.IMapsTo Maps._default.IMapsTo$K@@2 Maps._default.IMapsTo$V@@2 (Lit |m#0@@23|) (Lit |k#0@@23|) (Lit |v#0@@78|)))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K T@U) (Maps._default.MapsTo$V T@U) (|m#0@@24| T@U) (|k#0@@24| T@U) (|v#0@@79| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K) TyType) (= (type Maps._default.MapsTo$V) TyType)) (= (type |m#0@@24|) (MapType BoxType BoxType))) (= (type |k#0@@24|) BoxType)) (= (type |v#0@@79|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K Maps._default.MapsTo$V |m#0@@24| |k#0@@24| |v#0@@79|) (and (and ($Is |m#0@@24| (TMap Maps._default.MapsTo$K Maps._default.MapsTo$V)) ($IsBox |k#0@@24| Maps._default.MapsTo$K)) ($IsBox |v#0@@79| Maps._default.MapsTo$V)))) true)
 :qid |unknown.0:0|
 :skolemid |3532|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K Maps._default.MapsTo$V |m#0@@24| |k#0@@24| |v#0@@79|))
))))
(assert (forall ((Maps._default.MapsTo$K@@0 T@U) (Maps._default.MapsTo$V@@0 T@U) (|m#0@@25| T@U) (|k#0@@25| T@U) (|v#0@@80| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@0) TyType) (= (type Maps._default.MapsTo$V@@0) TyType)) (= (type |m#0@@25|) (MapType BoxType BoxType))) (= (type |k#0@@25|) BoxType)) (= (type |v#0@@80|) BoxType)) (and (and ($Is |m#0@@25| (TMap Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0)) ($IsBox |k#0@@25| Maps._default.MapsTo$K@@0)) ($IsBox |v#0@@80| Maps._default.MapsTo$V@@0))) (= (|Maps.__default.MapsTo#requires| Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0 |m#0@@25| |k#0@@25| |v#0@@80|) true))
 :qid |unknown.0:0|
 :skolemid |3533|
 :pattern ( (|Maps.__default.MapsTo#requires| Maps._default.MapsTo$K@@0 Maps._default.MapsTo$V@@0 |m#0@@25| |k#0@@25| |v#0@@80|))
)))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@1 T@U) (Maps._default.MapsTo$V@@1 T@U) (|m#0@@26| T@U) (|k#0@@26| T@U) (|v#0@@81| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@1) TyType) (= (type Maps._default.MapsTo$V@@1) TyType)) (= (type |m#0@@26|) (MapType BoxType BoxType))) (= (type |k#0@@26|) BoxType)) (= (type |v#0@@81|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@81|) (and (and ($Is |m#0@@26| (TMap Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1)) ($IsBox |k#0@@26| Maps._default.MapsTo$K@@1)) ($IsBox |v#0@@81| Maps._default.MapsTo$V@@1)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@81|)  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@26|) |k#0@@26|)) (= (MapType0Select (|Map#Elements| |m#0@@26|) |k#0@@26|) |v#0@@81|))))
 :qid |unknown.0:0|
 :skolemid |3534|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@1 Maps._default.MapsTo$V@@1 |m#0@@26| |k#0@@26| |v#0@@81|))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@2 T@U) (Maps._default.MapsTo$V@@2 T@U) (|m#0@@27| T@U) (|k#0@@27| T@U) (|v#0@@82| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@2) TyType) (= (type Maps._default.MapsTo$V@@2) TyType)) (= (type |m#0@@27|) (MapType BoxType BoxType))) (= (type |k#0@@27|) BoxType)) (= (type |v#0@@82|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@82|) (and (and ($Is |m#0@@27| (TMap Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2)) ($IsBox |k#0@@27| Maps._default.MapsTo$K@@2)) ($IsBox |v#0@@82| Maps._default.MapsTo$V@@2)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@82|)  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@27|) |k#0@@27|)) (= (MapType0Select (|Map#Elements| (Lit |m#0@@27|)) |k#0@@27|) |v#0@@82|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3535|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@2 Maps._default.MapsTo$V@@2 (Lit |m#0@@27|) |k#0@@27| |v#0@@82|))
))))
(assert  (=> true (forall ((Maps._default.MapsTo$K@@3 T@U) (Maps._default.MapsTo$V@@3 T@U) (|m#0@@28| T@U) (|k#0@@28| T@U) (|v#0@@83| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsTo$K@@3) TyType) (= (type Maps._default.MapsTo$V@@3) TyType)) (= (type |m#0@@28|) (MapType BoxType BoxType))) (= (type |k#0@@28|) BoxType)) (= (type |v#0@@83|) BoxType)) (or (|Maps.__default.MapsTo#canCall| Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@83|)) (and (and ($Is |m#0@@28| (TMap Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3)) ($IsBox |k#0@@28| Maps._default.MapsTo$K@@3)) ($IsBox |v#0@@83| Maps._default.MapsTo$V@@3)))) (= (Maps.__default.MapsTo Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@83|))  (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@28|) |k#0@@28|)) (= (MapType0Select (|Map#Elements| (Lit |m#0@@28|)) (Lit |k#0@@28|)) (Lit |v#0@@83|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3536|
 :pattern ( (Maps.__default.MapsTo Maps._default.MapsTo$K@@3 Maps._default.MapsTo$V@@3 (Lit |m#0@@28|) (Lit |k#0@@28|) (Lit |v#0@@83|)))
))))
(assert  (=> true (forall ((Maps._default.IMapInjective$K T@U) (Maps._default.IMapInjective$V T@U) (|m#0@@29| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K) TyType) (= (type Maps._default.IMapInjective$V) TyType)) (= (type |m#0@@29|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K Maps._default.IMapInjective$V |m#0@@29|) ($Is |m#0@@29| (TIMap Maps._default.IMapInjective$K Maps._default.IMapInjective$V)))) true)
 :qid |unknown.0:0|
 :skolemid |3537|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K Maps._default.IMapInjective$V |m#0@@29|))
))))
(assert (forall ((Maps._default.IMapInjective$K@@0 T@U) (Maps._default.IMapInjective$V@@0 T@U) (|m#0@@30| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@0) TyType) (= (type Maps._default.IMapInjective$V@@0) TyType)) (= (type |m#0@@30|) (IMapType BoxType BoxType))) ($Is |m#0@@30| (TIMap Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0))) (= (|Maps.__default.IMapInjective#requires| Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0 |m#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |3538|
 :pattern ( (|Maps.__default.IMapInjective#requires| Maps._default.IMapInjective$K@@0 Maps._default.IMapInjective$V@@0 |m#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.IMapInjective$K@@1 T@U) (Maps._default.IMapInjective$V@@1 T@U) (|m#0@@31| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@1) TyType) (= (type Maps._default.IMapInjective$V@@1) TyType)) (= (type |m#0@@31|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|) ($Is |m#0@@31| (TIMap Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1)))) (= (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|)  (and true (forall ((|k1#0| T@U) (|k2#0| T@U) ) (!  (=> (and (= (type |k1#0|) BoxType) (= (type |k2#0|) BoxType)) (=> (and (and ($IsBox |k1#0| Maps._default.IMapInjective$K@@1) ($IsBox |k2#0| Maps._default.IMapInjective$K@@1)) (and (and (not (= |k1#0| |k2#0|)) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|)))) (not (= (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|) (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|)))))
 :qid |Mapsidfy.22:16|
 :skolemid |3539|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@31|) |k1#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|))
 :pattern ( (MapType0Select (|IMap#Domain| |m#0@@31|) |k2#0|) (MapType0Select (|IMap#Domain| |m#0@@31|) |k1#0|))
)))))
 :qid |unknown.0:0|
 :skolemid |3540|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@1 Maps._default.IMapInjective$V@@1 |m#0@@31|))
))))
(assert  (=> true (forall ((Maps._default.IMapInjective$K@@2 T@U) (Maps._default.IMapInjective$V@@2 T@U) (|m#0@@32| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInjective$K@@2) TyType) (= (type Maps._default.IMapInjective$V@@2) TyType)) (= (type |m#0@@32|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInjective#canCall| Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|)) ($Is |m#0@@32| (TIMap Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2)))) (= (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|))  (and true (forall ((|k1#1| T@U) (|k2#1| T@U) ) (!  (=> (and (= (type |k1#1|) BoxType) (= (type |k2#1|) BoxType)) (=> (and (and ($IsBox |k1#1| Maps._default.IMapInjective$K@@2) ($IsBox |k2#1| Maps._default.IMapInjective$K@@2)) (and (and (not (= |k1#1| |k2#1|)) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))) (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|)))) (not (= (MapType0Select (|IMap#Elements| (Lit |m#0@@32|)) |k1#1|) (MapType0Select (|IMap#Elements| (Lit |m#0@@32|)) |k2#1|)))))
 :qid |Mapsidfy.22:16|
 :skolemid |3541|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Elements| |m#0@@32|) |k1#1|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@32|) |k1#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|))
 :pattern ( (MapType0Select (|IMap#Domain| |m#0@@32|) |k2#1|) (MapType0Select (|IMap#Domain| |m#0@@32|) |k1#1|))
)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3542|
 :pattern ( (Maps.__default.IMapInjective Maps._default.IMapInjective$K@@2 Maps._default.IMapInjective$V@@2 (Lit |m#0@@32|)))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K T@U) (Maps._default.MapsAgreeOnKey$V T@U) (|m#0@@33| T@U) (|m'#0@@0| T@U) (|k#0@@29| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K) TyType) (= (type Maps._default.MapsAgreeOnKey$V) TyType)) (= (type |m#0@@33|) (MapType BoxType BoxType))) (= (type |m'#0@@0|) (MapType BoxType BoxType))) (= (type |k#0@@29|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V |m#0@@33| |m'#0@@0| |k#0@@29|) (and (and ($Is |m#0@@33| (TMap Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V)) ($Is |m'#0@@0| (TMap Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V))) ($IsBox |k#0@@29| Maps._default.MapsAgreeOnKey$K)))) true)
 :qid |unknown.0:0|
 :skolemid |3543|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K Maps._default.MapsAgreeOnKey$V |m#0@@33| |m'#0@@0| |k#0@@29|))
))))
(assert (forall ((Maps._default.MapsAgreeOnKey$K@@0 T@U) (Maps._default.MapsAgreeOnKey$V@@0 T@U) (|m#0@@34| T@U) (|m'#0@@1| T@U) (|k#0@@30| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@0) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@0) TyType)) (= (type |m#0@@34|) (MapType BoxType BoxType))) (= (type |m'#0@@1|) (MapType BoxType BoxType))) (= (type |k#0@@30|) BoxType)) (and (and ($Is |m#0@@34| (TMap Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0)) ($Is |m'#0@@1| (TMap Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0))) ($IsBox |k#0@@30| Maps._default.MapsAgreeOnKey$K@@0))) (= (|Maps.__default.MapsAgreeOnKey#requires| Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0 |m#0@@34| |m'#0@@1| |k#0@@30|) true))
 :qid |unknown.0:0|
 :skolemid |3544|
 :pattern ( (|Maps.__default.MapsAgreeOnKey#requires| Maps._default.MapsAgreeOnKey$K@@0 Maps._default.MapsAgreeOnKey$V@@0 |m#0@@34| |m'#0@@1| |k#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@1 T@U) (Maps._default.MapsAgreeOnKey$V@@1 T@U) (|m#0@@35| T@U) (|m'#0@@2| T@U) (|k#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@1) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@1) TyType)) (= (type |m#0@@35|) (MapType BoxType BoxType))) (= (type |m'#0@@2|) (MapType BoxType BoxType))) (= (type |k#0@@31|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|) (and (and ($Is |m#0@@35| (TMap Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1)) ($Is |m'#0@@2| (TMap Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1))) ($IsBox |k#0@@31| Maps._default.MapsAgreeOnKey$K@@1)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|)  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|) |k#0@@31|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|) |k#0@@31|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@35|) |k#0@@31|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@2|) |k#0@@31|))) (= (MapType0Select (|Map#Elements| |m#0@@35|) |k#0@@31|) (MapType0Select (|Map#Elements| |m'#0@@2|) |k#0@@31|))))))
 :qid |unknown.0:0|
 :skolemid |3545|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@1 Maps._default.MapsAgreeOnKey$V@@1 |m#0@@35| |m'#0@@2| |k#0@@31|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@2 T@U) (Maps._default.MapsAgreeOnKey$V@@2 T@U) (|m#0@@36| T@U) (|m'#0@@3| T@U) (|k#0@@32| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@2) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@2) TyType)) (= (type |m#0@@36|) (MapType BoxType BoxType))) (= (type |m'#0@@3|) (MapType BoxType BoxType))) (= (type |k#0@@32|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|) (and (and ($Is |m#0@@36| (TMap Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2)) ($Is |m'#0@@3| (TMap Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2))) ($IsBox |k#0@@32| Maps._default.MapsAgreeOnKey$K@@2)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|)  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|) |k#0@@32|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|) |k#0@@32|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@36|) |k#0@@32|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@3|) |k#0@@32|))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@36|)) |k#0@@32|) (MapType0Select (|Map#Elements| (Lit |m'#0@@3|)) |k#0@@32|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3546|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@2 Maps._default.MapsAgreeOnKey$V@@2 (Lit |m#0@@36|) (Lit |m'#0@@3|) |k#0@@32|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgreeOnKey$K@@3 T@U) (Maps._default.MapsAgreeOnKey$V@@3 T@U) (|m#0@@37| T@U) (|m'#0@@4| T@U) (|k#0@@33| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapsAgreeOnKey$K@@3) TyType) (= (type Maps._default.MapsAgreeOnKey$V@@3) TyType)) (= (type |m#0@@37|) (MapType BoxType BoxType))) (= (type |m'#0@@4|) (MapType BoxType BoxType))) (= (type |k#0@@33|) BoxType)) (or (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|)) (and (and ($Is |m#0@@37| (TMap Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3)) ($Is |m'#0@@4| (TMap Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3))) ($IsBox |k#0@@33| Maps._default.MapsAgreeOnKey$K@@3)))) (= (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|))  (or (and (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|) |k#0@@33|))) (not (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|) |k#0@@33|)))) (and (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@37|) |k#0@@33|)) (U_2_bool (MapType0Select (|Map#Domain| |m'#0@@4|) |k#0@@33|))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@37|)) (Lit |k#0@@33|)) (MapType0Select (|Map#Elements| (Lit |m'#0@@4|)) (Lit |k#0@@33|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3547|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgreeOnKey$K@@3 Maps._default.MapsAgreeOnKey$V@@3 (Lit |m#0@@37|) (Lit |m'#0@@4|) (Lit |k#0@@33|)))
))))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K T@U) (Maps._default.IMapsAgreeOnKey$V T@U) (|m#0@@38| T@U) (|m'#0@@5| T@U) (|k#0@@34| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K) TyType) (= (type Maps._default.IMapsAgreeOnKey$V) TyType)) (= (type |m#0@@38|) (IMapType BoxType BoxType))) (= (type |m'#0@@5|) (IMapType BoxType BoxType))) (= (type |k#0@@34|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V |m#0@@38| |m'#0@@5| |k#0@@34|) (and (and ($Is |m#0@@38| (TIMap Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V)) ($Is |m'#0@@5| (TIMap Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V))) ($IsBox |k#0@@34| Maps._default.IMapsAgreeOnKey$K)))) true)
 :qid |unknown.0:0|
 :skolemid |3548|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K Maps._default.IMapsAgreeOnKey$V |m#0@@38| |m'#0@@5| |k#0@@34|))
))))
(assert (forall ((Maps._default.IMapsAgreeOnKey$K@@0 T@U) (Maps._default.IMapsAgreeOnKey$V@@0 T@U) (|m#0@@39| T@U) (|m'#0@@6| T@U) (|k#0@@35| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@0) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@0) TyType)) (= (type |m#0@@39|) (IMapType BoxType BoxType))) (= (type |m'#0@@6|) (IMapType BoxType BoxType))) (= (type |k#0@@35|) BoxType)) (and (and ($Is |m#0@@39| (TIMap Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0)) ($Is |m'#0@@6| (TIMap Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0))) ($IsBox |k#0@@35| Maps._default.IMapsAgreeOnKey$K@@0))) (= (|Maps.__default.IMapsAgreeOnKey#requires| Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0 |m#0@@39| |m'#0@@6| |k#0@@35|) true))
 :qid |unknown.0:0|
 :skolemid |3549|
 :pattern ( (|Maps.__default.IMapsAgreeOnKey#requires| Maps._default.IMapsAgreeOnKey$K@@0 Maps._default.IMapsAgreeOnKey$V@@0 |m#0@@39| |m'#0@@6| |k#0@@35|))
)))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K@@1 T@U) (Maps._default.IMapsAgreeOnKey$V@@1 T@U) (|m#0@@40| T@U) (|m'#0@@7| T@U) (|k#0@@36| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@1) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@1) TyType)) (= (type |m#0@@40|) (IMapType BoxType BoxType))) (= (type |m'#0@@7|) (IMapType BoxType BoxType))) (= (type |k#0@@36|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|) (and (and ($Is |m#0@@40| (TIMap Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1)) ($Is |m'#0@@7| (TIMap Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1))) ($IsBox |k#0@@36| Maps._default.IMapsAgreeOnKey$K@@1)))) (= (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|)  (or (and (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|) |k#0@@36|))) (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|) |k#0@@36|)))) (and (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@40|) |k#0@@36|)) (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@7|) |k#0@@36|))) (= (MapType0Select (|IMap#Elements| |m#0@@40|) |k#0@@36|) (MapType0Select (|IMap#Elements| |m'#0@@7|) |k#0@@36|))))))
 :qid |unknown.0:0|
 :skolemid |3550|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@1 Maps._default.IMapsAgreeOnKey$V@@1 |m#0@@40| |m'#0@@7| |k#0@@36|))
))))
(assert  (=> true (forall ((Maps._default.IMapsAgreeOnKey$K@@2 T@U) (Maps._default.IMapsAgreeOnKey$V@@2 T@U) (|m#0@@41| T@U) (|m'#0@@8| T@U) (|k#0@@37| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapsAgreeOnKey$K@@2) TyType) (= (type Maps._default.IMapsAgreeOnKey$V@@2) TyType)) (= (type |m#0@@41|) (IMapType BoxType BoxType))) (= (type |m'#0@@8|) (IMapType BoxType BoxType))) (= (type |k#0@@37|) BoxType)) (or (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|)) (and (and ($Is |m#0@@41| (TIMap Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2)) ($Is |m'#0@@8| (TIMap Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2))) ($IsBox |k#0@@37| Maps._default.IMapsAgreeOnKey$K@@2)))) (= (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|))  (or (and (not (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|) |k#0@@37|))) (not (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|) |k#0@@37|)))) (and (and (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@41|) |k#0@@37|)) (U_2_bool (MapType0Select (|IMap#Domain| |m'#0@@8|) |k#0@@37|))) (= (MapType0Select (|IMap#Elements| (Lit |m#0@@41|)) (Lit |k#0@@37|)) (MapType0Select (|IMap#Elements| (Lit |m'#0@@8|)) (Lit |k#0@@37|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3551|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IMapsAgreeOnKey$K@@2 Maps._default.IMapsAgreeOnKey$V@@2 (Lit |m#0@@41|) (Lit |m'#0@@8|) (Lit |k#0@@37|)))
))))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K T@U) (Maps._default.IsSubIMap$V T@U) (|sub#0| T@U) (|sup#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K) TyType) (= (type Maps._default.IsSubIMap$V) TyType)) (= (type |sub#0|) (IMapType BoxType BoxType))) (= (type |sup#0|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V |sub#0| |sup#0|) (and ($Is |sub#0| (TIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V)) ($Is |sup#0| (TIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V))))) true)
 :qid |unknown.0:0|
 :skolemid |3552|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K Maps._default.IsSubIMap$V |sub#0| |sup#0|))
))))
(assert (forall ((Maps._default.IsSubIMap$K@@0 T@U) (Maps._default.IsSubIMap$V@@0 T@U) (|sub#0@@0| T@U) (|sup#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@0) TyType) (= (type Maps._default.IsSubIMap$V@@0) TyType)) (= (type |sub#0@@0|) (IMapType BoxType BoxType))) (= (type |sup#0@@0|) (IMapType BoxType BoxType))) (and ($Is |sub#0@@0| (TIMap Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0)) ($Is |sup#0@@0| (TIMap Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0)))) (= (|Maps.__default.IsSubIMap#requires| Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0 |sub#0@@0| |sup#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |3553|
 :pattern ( (|Maps.__default.IsSubIMap#requires| Maps._default.IsSubIMap$K@@0 Maps._default.IsSubIMap$V@@0 |sub#0@@0| |sup#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K@@1 T@U) (Maps._default.IsSubIMap$V@@1 T@U) (|sub#0@@1| T@U) (|sup#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@1) TyType) (= (type Maps._default.IsSubIMap$V@@1) TyType)) (= (type |sub#0@@1|) (IMapType BoxType BoxType))) (= (type |sup#0@@1|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|) (and ($Is |sub#0@@1| (TIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1)) ($Is |sup#0@@1| (TIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1))))) (and (=> (|ISet#Subset| (|IMap#Domain| |sub#0@@1|) (|IMap#Domain| |sup#0@@1|)) (forall ((|key#0@@12| T@U) ) (!  (=> (and (and (= (type |key#0@@12|) BoxType) ($IsBox |key#0@@12| Maps._default.IsSubIMap$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@12|))) (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@12|))
 :qid |Mapsidfy.35:16|
 :skolemid |3555|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@12|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@12|))
))) (= (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|)  (and (|ISet#Subset| (|IMap#Domain| |sub#0@@1|) (|IMap#Domain| |sup#0@@1|)) (forall ((|key#0@@13| T@U) ) (!  (=> (and (and (= (type |key#0@@13|) BoxType) ($IsBox |key#0@@13| Maps._default.IsSubIMap$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@13|))) (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@13|))
 :qid |Mapsidfy.35:16|
 :skolemid |3554|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1| |key#0@@13|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@1|) |key#0@@13|))
))))))
 :qid |unknown.0:0|
 :skolemid |3556|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@1 Maps._default.IsSubIMap$V@@1 |sub#0@@1| |sup#0@@1|))
))))
(assert  (=> true (forall ((Maps._default.IsSubIMap$K@@2 T@U) (Maps._default.IsSubIMap$V@@2 T@U) (|sub#0@@2| T@U) (|sup#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubIMap$K@@2) TyType) (= (type Maps._default.IsSubIMap$V@@2) TyType)) (= (type |sub#0@@2|) (IMapType BoxType BoxType))) (= (type |sup#0@@2|) (IMapType BoxType BoxType))) (or (|Maps.__default.IsSubIMap#canCall| Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|)) (and ($Is |sub#0@@2| (TIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2)) ($Is |sup#0@@2| (TIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2))))) (and (=> (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|)) (|IMap#Domain| (Lit |sup#0@@2|))) (forall ((|key#1@@0| T@U) ) (!  (=> (and (and (= (type |key#1@@0|) BoxType) ($IsBox |key#1@@0| Maps._default.IsSubIMap$K@@2)) (U_2_bool (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|))) |key#1@@0|))) (|Maps.__default.IMapsAgreeOnKey#canCall| Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|) |key#1@@0|))
 :qid |Mapsidfy.35:16|
 :skolemid |3558|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 |sub#0@@2| |sup#0@@2| |key#1@@0|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@2|) |key#1@@0|))
))) (= (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|))  (and (|ISet#Subset| (|IMap#Domain| (Lit |sub#0@@2|)) (|IMap#Domain| (Lit |sup#0@@2|))) (forall ((|key#1@@1| T@U) ) (!  (=> (and (and (= (type |key#1@@1|) BoxType) ($IsBox |key#1@@1| Maps._default.IsSubIMap$K@@2)) (U_2_bool (MapType0Select (Lit (|IMap#Domain| (Lit |sub#0@@2|))) |key#1@@1|))) (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|) |key#1@@1|))
 :qid |Mapsidfy.35:16|
 :skolemid |3557|
 :pattern ( (Maps.__default.IMapsAgreeOnKey Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 |sub#0@@2| |sup#0@@2| |key#1@@1|))
 :pattern ( (MapType0Select (|IMap#Domain| |sub#0@@2|) |key#1@@1|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3559|
 :pattern ( (Maps.__default.IsSubIMap Maps._default.IsSubIMap$K@@2 Maps._default.IsSubIMap$V@@2 (Lit |sub#0@@2|) (Lit |sup#0@@2|)))
))))
(assert  (=> true (forall ((Maps._default.IsSubMap$K T@U) (Maps._default.IsSubMap$V T@U) (|sub#0@@3| T@U) (|sup#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K) TyType) (= (type Maps._default.IsSubMap$V) TyType)) (= (type |sub#0@@3|) (MapType BoxType BoxType))) (= (type |sup#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K Maps._default.IsSubMap$V |sub#0@@3| |sup#0@@3|) (and ($Is |sub#0@@3| (TMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V)) ($Is |sup#0@@3| (TMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V))))) true)
 :qid |unknown.0:0|
 :skolemid |3560|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K Maps._default.IsSubMap$V |sub#0@@3| |sup#0@@3|))
))))
(assert (forall ((Maps._default.IsSubMap$K@@0 T@U) (Maps._default.IsSubMap$V@@0 T@U) (|sub#0@@4| T@U) (|sup#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@0) TyType) (= (type Maps._default.IsSubMap$V@@0) TyType)) (= (type |sub#0@@4|) (MapType BoxType BoxType))) (= (type |sup#0@@4|) (MapType BoxType BoxType))) (and ($Is |sub#0@@4| (TMap Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0)) ($Is |sup#0@@4| (TMap Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0)))) (= (|Maps.__default.IsSubMap#requires| Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0 |sub#0@@4| |sup#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |3561|
 :pattern ( (|Maps.__default.IsSubMap#requires| Maps._default.IsSubMap$K@@0 Maps._default.IsSubMap$V@@0 |sub#0@@4| |sup#0@@4|))
)))
(assert  (=> true (forall ((Maps._default.IsSubMap$K@@1 T@U) (Maps._default.IsSubMap$V@@1 T@U) (|sub#0@@5| T@U) (|sup#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@1) TyType) (= (type Maps._default.IsSubMap$V@@1) TyType)) (= (type |sub#0@@5|) (MapType BoxType BoxType))) (= (type |sup#0@@5|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|) (and ($Is |sub#0@@5| (TMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1)) ($Is |sup#0@@5| (TMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1))))) (and (=> (|Set#Subset| (|Map#Domain| |sub#0@@5|) (|Map#Domain| |sup#0@@5|)) (forall ((|key#0@@14| T@U) ) (!  (=> (and (and (= (type |key#0@@14|) BoxType) ($IsBox |key#0@@14| Maps._default.IsSubMap$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@14|))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@14|))
 :qid |Mapsidfy.40:16|
 :skolemid |3563|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@14|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@14|))
))) (= (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|)  (and (|Set#Subset| (|Map#Domain| |sub#0@@5|) (|Map#Domain| |sup#0@@5|)) (forall ((|key#0@@15| T@U) ) (!  (=> (and (and (= (type |key#0@@15|) BoxType) ($IsBox |key#0@@15| Maps._default.IsSubMap$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@15|))) (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@15|))
 :qid |Mapsidfy.40:16|
 :skolemid |3562|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5| |key#0@@15|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@5|) |key#0@@15|))
))))))
 :qid |unknown.0:0|
 :skolemid |3564|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@1 Maps._default.IsSubMap$V@@1 |sub#0@@5| |sup#0@@5|))
))))
(assert  (=> true (forall ((Maps._default.IsSubMap$K@@2 T@U) (Maps._default.IsSubMap$V@@2 T@U) (|sub#0@@6| T@U) (|sup#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IsSubMap$K@@2) TyType) (= (type Maps._default.IsSubMap$V@@2) TyType)) (= (type |sub#0@@6|) (MapType BoxType BoxType))) (= (type |sup#0@@6|) (MapType BoxType BoxType))) (or (|Maps.__default.IsSubMap#canCall| Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|)) (and ($Is |sub#0@@6| (TMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2)) ($Is |sup#0@@6| (TMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2))))) (and (=> (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|)) (|Map#Domain| (Lit |sup#0@@6|))) (forall ((|key#1@@2| T@U) ) (!  (=> (and (and (= (type |key#1@@2|) BoxType) ($IsBox |key#1@@2| Maps._default.IsSubMap$K@@2)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|))) |key#1@@2|))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|) |key#1@@2|))
 :qid |Mapsidfy.40:16|
 :skolemid |3566|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 |sub#0@@6| |sup#0@@6| |key#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@6|) |key#1@@2|))
))) (= (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|))  (and (|Set#Subset| (|Map#Domain| (Lit |sub#0@@6|)) (|Map#Domain| (Lit |sup#0@@6|))) (forall ((|key#1@@3| T@U) ) (!  (=> (and (and (= (type |key#1@@3|) BoxType) ($IsBox |key#1@@3| Maps._default.IsSubMap$K@@2)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |sub#0@@6|))) |key#1@@3|))) (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|) |key#1@@3|))
 :qid |Mapsidfy.40:16|
 :skolemid |3565|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 |sub#0@@6| |sup#0@@6| |key#1@@3|))
 :pattern ( (MapType0Select (|Map#Domain| |sub#0@@6|) |key#1@@3|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3567|
 :pattern ( (Maps.__default.IsSubMap Maps._default.IsSubMap$K@@2 Maps._default.IsSubMap$V@@2 (Lit |sub#0@@6|) (Lit |sup#0@@6|)))
))))
(assert  (=> true (forall ((Maps._default.MapsAgree$K T@U) (Maps._default.MapsAgree$V T@U) (|ma#0| T@U) (|mb#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K) TyType) (= (type Maps._default.MapsAgree$V) TyType)) (= (type |ma#0|) (MapType BoxType BoxType))) (= (type |mb#0|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K Maps._default.MapsAgree$V |ma#0| |mb#0|) (and ($Is |ma#0| (TMap Maps._default.MapsAgree$K Maps._default.MapsAgree$V)) ($Is |mb#0| (TMap Maps._default.MapsAgree$K Maps._default.MapsAgree$V))))) true)
 :qid |unknown.0:0|
 :skolemid |3568|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K Maps._default.MapsAgree$V |ma#0| |mb#0|))
))))
(assert (forall ((Maps._default.MapsAgree$K@@0 T@U) (Maps._default.MapsAgree$V@@0 T@U) (|ma#0@@0| T@U) (|mb#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@0) TyType) (= (type Maps._default.MapsAgree$V@@0) TyType)) (= (type |ma#0@@0|) (MapType BoxType BoxType))) (= (type |mb#0@@0|) (MapType BoxType BoxType))) (and ($Is |ma#0@@0| (TMap Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0)) ($Is |mb#0@@0| (TMap Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0)))) (= (|Maps.__default.MapsAgree#requires| Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0 |ma#0@@0| |mb#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |3569|
 :pattern ( (|Maps.__default.MapsAgree#requires| Maps._default.MapsAgree$K@@0 Maps._default.MapsAgree$V@@0 |ma#0@@0| |mb#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapsAgree$K@@1 T@U) (Maps._default.MapsAgree$V@@1 T@U) (|ma#0@@1| T@U) (|mb#0@@1| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@1) TyType) (= (type Maps._default.MapsAgree$V@@1) TyType)) (= (type |ma#0@@1|) (MapType BoxType BoxType))) (= (type |mb#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|) (and ($Is |ma#0@@1| (TMap Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1)) ($Is |mb#0@@1| (TMap Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|key#0@@16| T@U) ) (!  (=> (and (and (= (type |key#0@@16|) BoxType) ($IsBox |key#0@@16| Maps._default.MapsAgree$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@16|)) (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@16|)))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@16|))
 :qid |Mapsidfy.44:16|
 :skolemid |3571|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@16|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@16|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@16|))
))) (= (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|)  (and true (forall ((|key#0@@17| T@U) ) (!  (=> (= (type |key#0@@17|) BoxType) (=> (and ($IsBox |key#0@@17| Maps._default.MapsAgree$K@@1) (and (U_2_bool (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@17|)) (U_2_bool (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@17|)))) (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@17|)))
 :qid |Mapsidfy.44:16|
 :skolemid |3570|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1| |key#0@@17|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@1|) |key#0@@17|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@1|) |key#0@@17|))
))))))
 :qid |unknown.0:0|
 :skolemid |3572|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@1 Maps._default.MapsAgree$V@@1 |ma#0@@1| |mb#0@@1|))
))))
(assert  (=> true (forall ((Maps._default.MapsAgree$K@@2 T@U) (Maps._default.MapsAgree$V@@2 T@U) (|ma#0@@2| T@U) (|mb#0@@2| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapsAgree$K@@2) TyType) (= (type Maps._default.MapsAgree$V@@2) TyType)) (= (type |ma#0@@2|) (MapType BoxType BoxType))) (= (type |mb#0@@2|) (MapType BoxType BoxType))) (or (|Maps.__default.MapsAgree#canCall| Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|)) (and ($Is |ma#0@@2| (TMap Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2)) ($Is |mb#0@@2| (TMap Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|key#1@@4| T@U) ) (!  (=> (and (and (= (type |key#1@@4|) BoxType) ($IsBox |key#1@@4| Maps._default.MapsAgree$K@@2)) (and (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|))) |key#1@@4|)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|))) |key#1@@4|)))) (|Maps.__default.MapsAgreeOnKey#canCall| Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|) |key#1@@4|))
 :qid |Mapsidfy.44:16|
 :skolemid |3574|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 |ma#0@@2| |mb#0@@2| |key#1@@4|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@2|) |key#1@@4|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@2|) |key#1@@4|))
))) (= (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|))  (and true (forall ((|key#1@@5| T@U) ) (!  (=> (= (type |key#1@@5|) BoxType) (=> (and ($IsBox |key#1@@5| Maps._default.MapsAgree$K@@2) (and (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |ma#0@@2|))) |key#1@@5|)) (U_2_bool (MapType0Select (Lit (|Map#Domain| (Lit |mb#0@@2|))) |key#1@@5|)))) (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|) |key#1@@5|)))
 :qid |Mapsidfy.44:16|
 :skolemid |3573|
 :pattern ( (Maps.__default.MapsAgreeOnKey Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 |ma#0@@2| |mb#0@@2| |key#1@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |mb#0@@2|) |key#1@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |ma#0@@2|) |key#1@@5|))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3575|
 :pattern ( (Maps.__default.MapsAgree Maps._default.MapsAgree$K@@2 Maps._default.MapsAgree$V@@2 (Lit |ma#0@@2|) (Lit |mb#0@@2|)))
))))
(assert (forall ((arg0@@545 T@U) (arg1@@257 T@U) (arg2@@132 T@U) (arg3@@73 T@U) (arg4@@44 T@U) ) (! (= (type (Maps.__default.MapRemove arg0@@545 arg1@@257 arg2@@132 arg3@@73 arg4@@44)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove|
 :pattern ( (Maps.__default.MapRemove arg0@@545 arg1@@257 arg2@@132 arg3@@73 arg4@@44))
)))
(assert (forall ((Maps._default.MapRemove$K T@U) (Maps._default.MapRemove$V T@U) ($ly@@237 T@U) (|m#0@@42| T@U) (|ks#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove$K) TyType) (= (type Maps._default.MapRemove$V) TyType)) (= (type $ly@@237) LayerTypeType)) (= (type |m#0@@42|) (MapType BoxType BoxType))) (= (type |ks#0|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V ($LS $ly@@237) |m#0@@42| |ks#0|) (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V $ly@@237 |m#0@@42| |ks#0|)))
 :qid |unknown.0:0|
 :skolemid |3576|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K Maps._default.MapRemove$V ($LS $ly@@237) |m#0@@42| |ks#0|))
)))
(assert (forall ((Maps._default.MapRemove$K@@0 T@U) (Maps._default.MapRemove$V@@0 T@U) ($ly@@238 T@U) (|m#0@@43| T@U) (|ks#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove$K@@0) TyType) (= (type Maps._default.MapRemove$V@@0) TyType)) (= (type $ly@@238) LayerTypeType)) (= (type |m#0@@43|) (MapType BoxType BoxType))) (= (type |ks#0@@0|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 $ly@@238 |m#0@@43| |ks#0@@0|) (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 $LZ |m#0@@43| |ks#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3577|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@0 Maps._default.MapRemove$V@@0 (AsFuelBottom $ly@@238) |m#0@@43| |ks#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@1 T@U) (Maps._default.MapRemove$V@@1 T@U) ($ly@@239 T@U) (|m#0@@44| T@U) (|ks#0@@1| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@1) TyType) (= (type Maps._default.MapRemove$V@@1) TyType)) (= (type $ly@@239) LayerTypeType)) (= (type |m#0@@44|) (MapType BoxType BoxType))) (= (type |ks#0@@1|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 |m#0@@44| |ks#0@@1|) (and ($Is |m#0@@44| (TMap Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1)) ($Is |ks#0@@1| (TSet Maps._default.MapRemove$K@@1))))) (and (and (and (and (and (forall ((|k#0@@38| T@U) ) (!  (=> (and (and (= (type |k#0@@38|) BoxType) ($IsBox |k#0@@38| Maps._default.MapRemove$K@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|) |k#0@@38|)) (not (U_2_bool (MapType0Select |ks#0@@1| |k#0@@38|))))) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |k#0@@38|)))
 :qid |Mapsidfy.48:20|
 :skolemid |3578|
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |k#0@@38|))
 :pattern ( (MapType0Select |ks#0@@1| |k#0@@38|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@44|) |k#0@@38|))
)) (forall ((|k#1@@1| T@U) ) (!  (=> (and (= (type |k#1@@1|) BoxType) ($IsBox |k#1@@1| Maps._default.MapRemove$K@@1)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |k#1@@1|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@44|) |k#1@@1|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |k#1@@1|)) (not (U_2_bool (MapType0Select |ks#0@@1| |k#1@@1|))))))
 :qid |Mapsidfy.49:20|
 :skolemid |3579|
 :pattern ( (MapType0Select |ks#0@@1| |k#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@44|) |k#1@@1|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |k#1@@1|))
))) (forall ((|j#0@@8| T@U) ) (!  (=> (and (and (= (type |j#0@@8|) BoxType) ($IsBox |j#0@@8| Maps._default.MapRemove$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |j#0@@8|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |j#0@@8|) (MapType0Select (|Map#Elements| |m#0@@44|) |j#0@@8|)))
 :qid |Mapsidfy.50:20|
 :skolemid |3580|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@44|) |j#0@@8|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |j#0@@8|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) |j#0@@8|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|))) (|Set#Card| (|Map#Domain| |m#0@@44|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|)) (|Map#Card| |m#0@@44|))) ($Is (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|) (TMap Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3581|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@1 Maps._default.MapRemove$V@@1 $ly@@239 |m#0@@44| |ks#0@@1|))
))))
(assert (forall ((Maps._default.MapRemove$K@@2 T@U) (Maps._default.MapRemove$V@@2 T@U) ($ly@@240 T@U) (|m#0@@45| T@U) (|ks#0@@2| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@2) TyType) (= (type Maps._default.MapRemove$V@@2) TyType)) (= (type $ly@@240) LayerTypeType)) (= (type |m#0@@45|) (MapType BoxType BoxType))) (= (type |ks#0@@2|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@45| (TMap Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2)) ($Is |ks#0@@2| (TSet Maps._default.MapRemove$K@@2)))) (= (|Maps.__default.MapRemove#requires| Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2 $ly@@240 |m#0@@45| |ks#0@@2|) true))
 :qid |unknown.0:0|
 :skolemid |3582|
 :pattern ( (|Maps.__default.MapRemove#requires| Maps._default.MapRemove$K@@2 Maps._default.MapRemove$V@@2 $ly@@240 |m#0@@45| |ks#0@@2|))
)))
(assert (forall ((arg0@@546 T@U) (arg1@@258 T@U) (arg2@@133 T@U) ) (! (= (type (|lambda#190| arg0@@546 arg1@@258 arg2@@133)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#190|
 :pattern ( (|lambda#190| arg0@@546 arg1@@258 arg2@@133))
)))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@3 T@U) (Maps._default.MapRemove$V@@3 T@U) ($ly@@241 T@U) (|m#0@@46| T@U) (|ks#0@@3| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@3) TyType) (= (type Maps._default.MapRemove$V@@3) TyType)) (= (type $ly@@241) LayerTypeType)) (= (type |m#0@@46|) (MapType BoxType BoxType))) (= (type |ks#0@@3|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 |m#0@@46| |ks#0@@3|) (and ($Is |m#0@@46| (TMap Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3)) ($Is |ks#0@@3| (TSet Maps._default.MapRemove$K@@3))))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 ($LS $ly@@241) |m#0@@46| |ks#0@@3|) (let ((|m'#0@@9| (|Map#Glue| (|lambda#190| Maps._default.MapRemove$K@@3 (|Map#Domain| |m#0@@46|) |ks#0@@3|) (|lambda#185| (|Map#Elements| |m#0@@46|)) (TMap Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3))))
|m'#0@@9|)))
 :qid |unknown.0:0|
 :skolemid |3583|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@3 Maps._default.MapRemove$V@@3 ($LS $ly@@241) |m#0@@46| |ks#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove$K@@4 T@U) (Maps._default.MapRemove$V@@4 T@U) ($ly@@242 T@U) (|m#0@@47| T@U) (|ks#0@@4| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove$K@@4) TyType) (= (type Maps._default.MapRemove$V@@4) TyType)) (= (type $ly@@242) LayerTypeType)) (= (type |m#0@@47|) (MapType BoxType BoxType))) (= (type |ks#0@@4|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemove#canCall| Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 (Lit |m#0@@47|) (Lit |ks#0@@4|)) (and ($Is |m#0@@47| (TMap Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4)) ($Is |ks#0@@4| (TSet Maps._default.MapRemove$K@@4))))) (= (Maps.__default.MapRemove Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 ($LS $ly@@242) (Lit |m#0@@47|) (Lit |ks#0@@4|)) (let ((|m'#1@@0| (|Map#Glue| (|lambda#190| Maps._default.MapRemove$K@@4 (|Map#Domain| |m#0@@47|) (Lit |ks#0@@4|)) (|lambda#185| (|Map#Elements| (Lit |m#0@@47|))) (TMap Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4))))
|m'#1@@0|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3584|
 :pattern ( (Maps.__default.MapRemove Maps._default.MapRemove$K@@4 Maps._default.MapRemove$V@@4 ($LS $ly@@242) (Lit |m#0@@47|) (Lit |ks#0@@4|)))
))))
(assert (forall ((arg0@@547 T@U) (arg1@@259 T@U) (arg2@@134 T@U) (arg3@@74 T@U) (arg4@@45 T@U) ) (! (= (type (Maps.__default.MapRemoveStrong arg0@@547 arg1@@259 arg2@@134 arg3@@74 arg4@@45)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemoveStrong|
 :pattern ( (Maps.__default.MapRemoveStrong arg0@@547 arg1@@259 arg2@@134 arg3@@74 arg4@@45))
)))
(assert (forall ((Maps._default.MapRemoveStrong$K T@U) (Maps._default.MapRemoveStrong$V T@U) ($ly@@243 T@U) (|m#0@@48| T@U) (|ks#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemoveStrong$K) TyType) (= (type Maps._default.MapRemoveStrong$V) TyType)) (= (type $ly@@243) LayerTypeType)) (= (type |m#0@@48|) (MapType BoxType BoxType))) (= (type |ks#0@@5|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V ($LS $ly@@243) |m#0@@48| |ks#0@@5|) (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V $ly@@243 |m#0@@48| |ks#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |3585|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K Maps._default.MapRemoveStrong$V ($LS $ly@@243) |m#0@@48| |ks#0@@5|))
)))
(assert (forall ((Maps._default.MapRemoveStrong$K@@0 T@U) (Maps._default.MapRemoveStrong$V@@0 T@U) ($ly@@244 T@U) (|m#0@@49| T@U) (|ks#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@0) TyType) (= (type Maps._default.MapRemoveStrong$V@@0) TyType)) (= (type $ly@@244) LayerTypeType)) (= (type |m#0@@49|) (MapType BoxType BoxType))) (= (type |ks#0@@6|) (MapType0Type BoxType boolType))) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 $ly@@244 |m#0@@49| |ks#0@@6|) (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 $LZ |m#0@@49| |ks#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3586|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@0 Maps._default.MapRemoveStrong$V@@0 (AsFuelBottom $ly@@244) |m#0@@49| |ks#0@@6|))
)))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@1 T@U) (Maps._default.MapRemoveStrong$V@@1 T@U) ($ly@@245 T@U) (|m#0@@50| T@U) (|ks#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@1) TyType) (= (type Maps._default.MapRemoveStrong$V@@1) TyType)) (= (type $ly@@245) LayerTypeType)) (= (type |m#0@@50|) (MapType BoxType BoxType))) (= (type |ks#0@@7|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 |m#0@@50| |ks#0@@7|) (and ($Is |m#0@@50| (TMap Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1)) ($Is |ks#0@@7| (TSet Maps._default.MapRemoveStrong$K@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) (|Set#Difference| (|Map#Domain| |m#0@@50|) |ks#0@@7|)) (forall ((|j#0@@9| T@U) ) (!  (=> (and (and (= (type |j#0@@9|) BoxType) ($IsBox |j#0@@9| Maps._default.MapRemoveStrong$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) |j#0@@9|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) |j#0@@9|) (MapType0Select (|Map#Elements| |m#0@@50|) |j#0@@9|)))
 :qid |Mapsidfy.61:20|
 :skolemid |3587|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@50|) |j#0@@9|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) |j#0@@9|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) |j#0@@9|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|))) (|Set#Card| (|Map#Domain| |m#0@@50|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|)) (|Map#Card| |m#0@@50|))) ($Is (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|) (TMap Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3588|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@1 Maps._default.MapRemoveStrong$V@@1 $ly@@245 |m#0@@50| |ks#0@@7|))
))))
(assert (forall ((Maps._default.MapRemoveStrong$K@@2 T@U) (Maps._default.MapRemoveStrong$V@@2 T@U) ($ly@@246 T@U) (|m#0@@51| T@U) (|ks#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@2) TyType) (= (type Maps._default.MapRemoveStrong$V@@2) TyType)) (= (type $ly@@246) LayerTypeType)) (= (type |m#0@@51|) (MapType BoxType BoxType))) (= (type |ks#0@@8|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@51| (TMap Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2)) ($Is |ks#0@@8| (TSet Maps._default.MapRemoveStrong$K@@2)))) (= (|Maps.__default.MapRemoveStrong#requires| Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2 $ly@@246 |m#0@@51| |ks#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |3589|
 :pattern ( (|Maps.__default.MapRemoveStrong#requires| Maps._default.MapRemoveStrong$K@@2 Maps._default.MapRemoveStrong$V@@2 $ly@@246 |m#0@@51| |ks#0@@8|))
)))
(assert  (and (and (= (type StartFuel_Maps._default.MapRemove) LayerTypeType) (= (type MoreFuel_Maps._default.MapRemove0) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemove) LayerTypeType)))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@3 T@U) (Maps._default.MapRemoveStrong$V@@3 T@U) ($ly@@247 T@U) (|m#0@@52| T@U) (|ks#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@3) TyType) (= (type Maps._default.MapRemoveStrong$V@@3) TyType)) (= (type $ly@@247) LayerTypeType)) (= (type |m#0@@52|) (MapType BoxType BoxType))) (= (type |ks#0@@9|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 |m#0@@52| |ks#0@@9|) (and ($Is |m#0@@52| (TMap Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3)) ($Is |ks#0@@9| (TSet Maps._default.MapRemoveStrong$K@@3))))) (and (|Maps.__default.MapRemove#canCall| Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 |m#0@@52| |ks#0@@9|) (and (and (and (= StartFuel_Maps._default.MapRemove ($LS MoreFuel_Maps._default.MapRemove0)) (= StartFuelAssert_Maps._default.MapRemove ($LS ($LS MoreFuel_Maps._default.MapRemove0)))) (= (AsFuelBottom MoreFuel_Maps._default.MapRemove0) MoreFuel_Maps._default.MapRemove0)) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 ($LS $ly@@247) |m#0@@52| |ks#0@@9|) (Maps.__default.MapRemove Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 StartFuel_Maps._default.MapRemove |m#0@@52| |ks#0@@9|)))))
 :qid |unknown.0:0|
 :skolemid |3590|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@3 Maps._default.MapRemoveStrong$V@@3 ($LS $ly@@247) |m#0@@52| |ks#0@@9|))
))))
(assert (= (type MoreFuel_Maps._default.MapRemove1) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemoveStrong$K@@4 T@U) (Maps._default.MapRemoveStrong$V@@4 T@U) ($ly@@248 T@U) (|m#0@@53| T@U) (|ks#0@@10| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemoveStrong$K@@4) TyType) (= (type Maps._default.MapRemoveStrong$V@@4) TyType)) (= (type $ly@@248) LayerTypeType)) (= (type |m#0@@53|) (MapType BoxType BoxType))) (= (type |ks#0@@10|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRemoveStrong#canCall| Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 (Lit |m#0@@53|) (Lit |ks#0@@10|)) (and ($Is |m#0@@53| (TMap Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4)) ($Is |ks#0@@10| (TSet Maps._default.MapRemoveStrong$K@@4))))) (and (|Maps.__default.MapRemove#canCall| Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 (Lit |m#0@@53|) (Lit |ks#0@@10|)) (and (and (and (= StartFuel_Maps._default.MapRemove ($LS MoreFuel_Maps._default.MapRemove1)) (= StartFuelAssert_Maps._default.MapRemove ($LS ($LS MoreFuel_Maps._default.MapRemove1)))) (= (AsFuelBottom MoreFuel_Maps._default.MapRemove1) MoreFuel_Maps._default.MapRemove1)) (= (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 ($LS $ly@@248) (Lit |m#0@@53|) (Lit |ks#0@@10|)) (Maps.__default.MapRemove Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 StartFuel_Maps._default.MapRemove (Lit |m#0@@53|) (Lit |ks#0@@10|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3591|
 :pattern ( (Maps.__default.MapRemoveStrong Maps._default.MapRemoveStrong$K@@4 Maps._default.MapRemoveStrong$V@@4 ($LS $ly@@248) (Lit |m#0@@53|) (Lit |ks#0@@10|)))
))))
(assert (forall ((arg0@@548 T@U) (arg1@@260 T@U) (arg2@@135 T@U) (arg3@@75 T@U) ) (! (= (type (Maps.__default.MapRemove1 arg0@@548 arg1@@260 arg2@@135 arg3@@75)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove1|
 :pattern ( (Maps.__default.MapRemove1 arg0@@548 arg1@@260 arg2@@135 arg3@@75))
)))
(assert  (=> true (forall ((Maps._default.MapRemove1$K T@U) (Maps._default.MapRemove1$V T@U) (|m#0@@54| T@U) (|k#0@@39| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K) TyType) (= (type Maps._default.MapRemove1$V) TyType)) (= (type |m#0@@54|) (MapType BoxType BoxType))) (= (type |k#0@@39|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|) (and ($Is |m#0@@54| (TMap Maps._default.MapRemove1$K Maps._default.MapRemove1$V)) ($IsBox |k#0@@39| Maps._default.MapRemove1$K)))) (and (and (and (and (and (and (forall ((|j#0@@10| T@U) ) (!  (=> (and (and (= (type |j#0@@10|) BoxType) ($IsBox |j#0@@10| Maps._default.MapRemove1$K)) (and (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |j#0@@10|)) (not (= |j#0@@10| |k#0@@39|)))) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#0@@10|)))
 :qid |Mapsidfy.70:18|
 :skolemid |3592|
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#0@@10|))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@54|) |j#0@@10|))
)) (forall ((|j#1@@2| T@U) ) (!  (=> (and (= (type |j#1@@2|) BoxType) ($IsBox |j#1@@2| Maps._default.MapRemove1$K)) (and (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |j#1@@2|))) (=> (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|)) (not (= |j#1@@2| |k#0@@39|)))))
 :qid |Mapsidfy.71:18|
 :skolemid |3593|
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@54|) |j#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#1@@2|))
))) (forall ((|j#2@@0| T@U) ) (!  (=> (and (and (= (type |j#2@@0|) BoxType) ($IsBox |j#2@@0| Maps._default.MapRemove1$K)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|) (MapType0Select (|Map#Elements| |m#0@@54|) |j#2@@0|)))
 :qid |Mapsidfy.72:18|
 :skolemid |3594|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@54|) |j#2@@0|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) |j#2@@0|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|))) (|Set#Card| (|Map#Domain| |m#0@@54|)))) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |k#0@@39|)) (= (|Map#Card| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) (INTERNAL_sub_boogie (|Map#Card| |m#0@@54|) 1)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| |m#0@@54|) |k#0@@39|))) (= (|Map#Card| (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|)) (|Map#Card| |m#0@@54|)))) ($Is (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|) (TMap Maps._default.MapRemove1$K Maps._default.MapRemove1$V))))
 :qid |unknown.0:0|
 :skolemid |3595|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K Maps._default.MapRemove1$V |m#0@@54| |k#0@@39|))
))))
(assert (forall ((Maps._default.MapRemove1$K@@0 T@U) (Maps._default.MapRemove1$V@@0 T@U) (|m#0@@55| T@U) (|k#0@@40| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@0) TyType) (= (type Maps._default.MapRemove1$V@@0) TyType)) (= (type |m#0@@55|) (MapType BoxType BoxType))) (= (type |k#0@@40|) BoxType)) (and ($Is |m#0@@55| (TMap Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0)) ($IsBox |k#0@@40| Maps._default.MapRemove1$K@@0))) (= (|Maps.__default.MapRemove1#requires| Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0 |m#0@@55| |k#0@@40|) true))
 :qid |unknown.0:0|
 :skolemid |3596|
 :pattern ( (|Maps.__default.MapRemove1#requires| Maps._default.MapRemove1$K@@0 Maps._default.MapRemove1$V@@0 |m#0@@55| |k#0@@40|))
)))
(assert (= (type StartFuel_MapRemove_s._default.MapRemove1) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@1 T@U) (Maps._default.MapRemove1$V@@1 T@U) (|m#0@@56| T@U) (|k#0@@41| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@1) TyType) (= (type Maps._default.MapRemove1$V@@1) TyType)) (= (type |m#0@@56|) (MapType BoxType BoxType))) (= (type |k#0@@41|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (and ($Is |m#0@@56| (TMap Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1)) ($IsBox |k#0@@41| Maps._default.MapRemove1$K@@1)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 StartFuel_MapRemove_s._default.MapRemove1 |m#0@@56| |k#0@@41|))))
 :qid |unknown.0:0|
 :skolemid |3597|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@1 Maps._default.MapRemove1$V@@1 |m#0@@56| |k#0@@41|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@2 T@U) (Maps._default.MapRemove1$V@@2 T@U) (|m#0@@57| T@U) (|k#0@@42| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@2) TyType) (= (type Maps._default.MapRemove1$V@@2) TyType)) (= (type |m#0@@57|) (MapType BoxType BoxType))) (= (type |k#0@@42|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (and ($Is |m#0@@57| (TMap Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2)) ($IsBox |k#0@@42| Maps._default.MapRemove1$K@@2)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 StartFuel_MapRemove_s._default.MapRemove1 (Lit |m#0@@57|) |k#0@@42|))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3598|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@2 Maps._default.MapRemove1$V@@2 (Lit |m#0@@57|) |k#0@@42|))
))))
(assert  (=> true (forall ((Maps._default.MapRemove1$K@@3 T@U) (Maps._default.MapRemove1$V@@3 T@U) (|m#0@@58| T@U) (|k#0@@43| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1$K@@3) TyType) (= (type Maps._default.MapRemove1$V@@3) TyType)) (= (type |m#0@@58|) (MapType BoxType BoxType))) (= (type |k#0@@43|) BoxType)) (or (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (and ($Is |m#0@@58| (TMap Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3)) ($IsBox |k#0@@43| Maps._default.MapRemove1$K@@3)))) (and (|MapRemove_s.__default.MapRemove1#canCall| Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (= (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)) (MapRemove_s.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 StartFuel_MapRemove_s._default.MapRemove1 (Lit |m#0@@58|) (Lit |k#0@@43|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3599|
 :pattern ( (Maps.__default.MapRemove1 Maps._default.MapRemove1$K@@3 Maps._default.MapRemove1$V@@3 (Lit |m#0@@58|) (Lit |k#0@@43|)))
))))
(assert (forall ((arg0@@549 T@U) (arg1@@261 T@U) (arg2@@136 T@U) (arg3@@76 T@U) (arg4@@46 T@U) ) (! (= (type (Maps.__default.MapRemove1Strong arg0@@549 arg1@@261 arg2@@136 arg3@@76 arg4@@46)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRemove1Strong|
 :pattern ( (Maps.__default.MapRemove1Strong arg0@@549 arg1@@261 arg2@@136 arg3@@76 arg4@@46))
)))
(assert (forall ((Maps._default.MapRemove1Strong$K T@U) (Maps._default.MapRemove1Strong$V T@U) ($ly@@249 T@U) (|m#0@@59| T@U) (|k#0@@44| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1Strong$K) TyType) (= (type Maps._default.MapRemove1Strong$V) TyType)) (= (type $ly@@249) LayerTypeType)) (= (type |m#0@@59|) (MapType BoxType BoxType))) (= (type |k#0@@44|) BoxType)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V ($LS $ly@@249) |m#0@@59| |k#0@@44|) (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V $ly@@249 |m#0@@59| |k#0@@44|)))
 :qid |unknown.0:0|
 :skolemid |3600|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K Maps._default.MapRemove1Strong$V ($LS $ly@@249) |m#0@@59| |k#0@@44|))
)))
(assert (forall ((Maps._default.MapRemove1Strong$K@@0 T@U) (Maps._default.MapRemove1Strong$V@@0 T@U) ($ly@@250 T@U) (|m#0@@60| T@U) (|k#0@@45| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@0) TyType) (= (type Maps._default.MapRemove1Strong$V@@0) TyType)) (= (type $ly@@250) LayerTypeType)) (= (type |m#0@@60|) (MapType BoxType BoxType))) (= (type |k#0@@45|) BoxType)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 $ly@@250 |m#0@@60| |k#0@@45|) (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 $LZ |m#0@@60| |k#0@@45|)))
 :qid |unknown.0:0|
 :skolemid |3601|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@0 Maps._default.MapRemove1Strong$V@@0 (AsFuelBottom $ly@@250) |m#0@@60| |k#0@@45|))
)))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@1 T@U) (Maps._default.MapRemove1Strong$V@@1 T@U) ($ly@@251 T@U) (|m#0@@61| T@U) (|k#0@@46| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@1) TyType) (= (type Maps._default.MapRemove1Strong$V@@1) TyType)) (= (type $ly@@251) LayerTypeType)) (= (type |m#0@@61|) (MapType BoxType BoxType))) (= (type |k#0@@46|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 |m#0@@61| |k#0@@46|) (and ($Is |m#0@@61| (TMap Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1)) ($IsBox |k#0@@46| Maps._default.MapRemove1Strong$K@@1)))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) (|Set#Difference| (|Map#Domain| |m#0@@61|) (|Set#UnionOne| (|Set#Empty| BoxType) |k#0@@46|))) (forall ((|j#0@@11| T@U) ) (!  (=> (and (and (= (type |j#0@@11|) BoxType) ($IsBox |j#0@@11| Maps._default.MapRemove1Strong$K@@1)) (U_2_bool (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) |j#0@@11|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) |j#0@@11|) (MapType0Select (|Map#Elements| |m#0@@61|) |j#0@@11|)))
 :qid |Mapsidfy.82:20|
 :skolemid |3602|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@61|) |j#0@@11|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) |j#0@@11|))
 :pattern ( (MapType0Select (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) |j#0@@11|))
))) (INTERNAL_le_boogie (|Set#Card| (|Map#Domain| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|))) (|Set#Card| (|Map#Domain| |m#0@@61|)))) (INTERNAL_le_boogie (|Map#Card| (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|)) (|Map#Card| |m#0@@61|))) ($Is (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|) (TMap Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3603|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@1 Maps._default.MapRemove1Strong$V@@1 $ly@@251 |m#0@@61| |k#0@@46|))
))))
(assert (forall ((Maps._default.MapRemove1Strong$K@@2 T@U) (Maps._default.MapRemove1Strong$V@@2 T@U) ($ly@@252 T@U) (|m#0@@62| T@U) (|k#0@@47| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@2) TyType) (= (type Maps._default.MapRemove1Strong$V@@2) TyType)) (= (type $ly@@252) LayerTypeType)) (= (type |m#0@@62|) (MapType BoxType BoxType))) (= (type |k#0@@47|) BoxType)) (and ($Is |m#0@@62| (TMap Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2)) ($IsBox |k#0@@47| Maps._default.MapRemove1Strong$K@@2))) (= (|Maps.__default.MapRemove1Strong#requires| Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2 $ly@@252 |m#0@@62| |k#0@@47|) true))
 :qid |unknown.0:0|
 :skolemid |3604|
 :pattern ( (|Maps.__default.MapRemove1Strong#requires| Maps._default.MapRemove1Strong$K@@2 Maps._default.MapRemove1Strong$V@@2 $ly@@252 |m#0@@62| |k#0@@47|))
)))
(assert  (and (= (type MoreFuel_MapRemove_s._default.MapRemove10) LayerTypeType) (= (type StartFuelAssert_MapRemove_s._default.MapRemove1) LayerTypeType)))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@3 T@U) (Maps._default.MapRemove1Strong$V@@3 T@U) ($ly@@253 T@U) (|m#0@@63| T@U) (|k#0@@48| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@3) TyType) (= (type Maps._default.MapRemove1Strong$V@@3) TyType)) (= (type $ly@@253) LayerTypeType)) (= (type |m#0@@63|) (MapType BoxType BoxType))) (= (type |k#0@@48|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|) (and ($Is |m#0@@63| (TMap Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3)) ($IsBox |k#0@@48| Maps._default.MapRemove1Strong$K@@3)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove10)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove10)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove10) MoreFuel_MapRemove_s._default.MapRemove10)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 ($LS $ly@@253) |m#0@@63| |k#0@@48|) (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 |m#0@@63| |k#0@@48|)))))
 :qid |unknown.0:0|
 :skolemid |3605|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@3 Maps._default.MapRemove1Strong$V@@3 ($LS $ly@@253) |m#0@@63| |k#0@@48|))
))))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove11) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@4 T@U) (Maps._default.MapRemove1Strong$V@@4 T@U) ($ly@@254 T@U) (|m#0@@64| T@U) (|k#0@@49| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@4) TyType) (= (type Maps._default.MapRemove1Strong$V@@4) TyType)) (= (type $ly@@254) LayerTypeType)) (= (type |m#0@@64|) (MapType BoxType BoxType))) (= (type |k#0@@49|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|) (and ($Is |m#0@@64| (TMap Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4)) ($IsBox |k#0@@49| Maps._default.MapRemove1Strong$K@@4)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove11)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove11)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove11) MoreFuel_MapRemove_s._default.MapRemove11)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 ($LS $ly@@254) (Lit |m#0@@64|) |k#0@@49|) (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 (Lit |m#0@@64|) |k#0@@49|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3606|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@4 Maps._default.MapRemove1Strong$V@@4 ($LS $ly@@254) (Lit |m#0@@64|) |k#0@@49|))
))))
(assert (= (type MoreFuel_MapRemove_s._default.MapRemove12) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapRemove1Strong$K@@5 T@U) (Maps._default.MapRemove1Strong$V@@5 T@U) ($ly@@255 T@U) (|m#0@@65| T@U) (|k#0@@50| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapRemove1Strong$K@@5) TyType) (= (type Maps._default.MapRemove1Strong$V@@5) TyType)) (= (type $ly@@255) LayerTypeType)) (= (type |m#0@@65|) (MapType BoxType BoxType))) (= (type |k#0@@50|) BoxType)) (or (|Maps.__default.MapRemove1Strong#canCall| Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)) (and ($Is |m#0@@65| (TMap Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5)) ($IsBox |k#0@@50| Maps._default.MapRemove1Strong$K@@5)))) (and (|Maps.__default.MapRemove1#canCall| Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)) (and (and (and (= StartFuel_MapRemove_s._default.MapRemove1 ($LS MoreFuel_MapRemove_s._default.MapRemove12)) (= StartFuelAssert_MapRemove_s._default.MapRemove1 ($LS ($LS MoreFuel_MapRemove_s._default.MapRemove12)))) (= (AsFuelBottom MoreFuel_MapRemove_s._default.MapRemove12) MoreFuel_MapRemove_s._default.MapRemove12)) (= (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 ($LS $ly@@255) (Lit |m#0@@65|) (Lit |k#0@@50|)) (Lit (Maps.__default.MapRemove1 Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 (Lit |m#0@@65|) (Lit |k#0@@50|)))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3607|
 :pattern ( (Maps.__default.MapRemove1Strong Maps._default.MapRemove1Strong$K@@5 Maps._default.MapRemove1Strong$V@@5 ($LS $ly@@255) (Lit |m#0@@65|) (Lit |k#0@@50|)))
))))
(assert (forall ((arg0@@550 T@U) (arg1@@262 T@U) (arg2@@137 T@U) (arg3@@77 T@U) ) (! (= (type (Maps.__default.IMapInvert arg0@@550 arg1@@262 arg2@@137 arg3@@77)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapInvert|
 :pattern ( (Maps.__default.IMapInvert arg0@@550 arg1@@262 arg2@@137 arg3@@77))
)))
(assert (forall ((Maps._default.IMapInvert$K T@U) (Maps._default.IMapInvert$V T@U) ($ly@@256 T@U) (|m#0@@66| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInvert$K) TyType) (= (type Maps._default.IMapInvert$V) TyType)) (= (type $ly@@256) LayerTypeType)) (= (type |m#0@@66|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V ($LS $ly@@256) |m#0@@66|) (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V $ly@@256 |m#0@@66|)))
 :qid |unknown.0:0|
 :skolemid |3608|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K Maps._default.IMapInvert$V ($LS $ly@@256) |m#0@@66|))
)))
(assert (forall ((Maps._default.IMapInvert$K@@0 T@U) (Maps._default.IMapInvert$V@@0 T@U) ($ly@@257 T@U) (|m#0@@67| T@U) ) (!  (=> (and (and (and (= (type Maps._default.IMapInvert$K@@0) TyType) (= (type Maps._default.IMapInvert$V@@0) TyType)) (= (type $ly@@257) LayerTypeType)) (= (type |m#0@@67|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 $ly@@257 |m#0@@67|) (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 $LZ |m#0@@67|)))
 :qid |unknown.0:0|
 :skolemid |3609|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@0 Maps._default.IMapInvert$V@@0 (AsFuelBottom $ly@@257) |m#0@@67|))
)))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@1 T@U) (Maps._default.IMapInvert$V@@1 T@U) ($ly@@258 T@U) (|m#0@@68| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapInvert$K@@1) TyType) (= (type Maps._default.IMapInvert$V@@1) TyType)) (= (type $ly@@258) LayerTypeType)) (= (type |m#0@@68|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 |m#0@@68|) ($Is |m#0@@68| (TIMap Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1)))) ($Is (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 $ly@@258 |m#0@@68|) (TIMap Maps._default.IMapInvert$V@@1 Maps._default.IMapInvert$K@@1)))
 :qid |unknown.0:0|
 :skolemid |3610|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@1 Maps._default.IMapInvert$V@@1 $ly@@258 |m#0@@68|))
))))
(assert (forall ((Maps._default.IMapInvert$K@@2 T@U) (Maps._default.IMapInvert$V@@2 T@U) ($ly@@259 T@U) ($Heap@@50 T@U) (|m#0@@69| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@2) TyType) (= (type Maps._default.IMapInvert$V@@2) TyType)) (= (type $ly@@259) LayerTypeType)) (= (type $Heap@@50) (MapType0Type refType MapType1Type))) (= (type |m#0@@69|) (IMapType BoxType BoxType))) (and ($IsGoodHeap $Heap@@50) ($Is |m#0@@69| (TIMap Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2)))) (= (|Maps.__default.IMapInvert#requires| Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2 $ly@@259 |m#0@@69|) true))
 :qid |unknown.0:0|
 :skolemid |3611|
 :pattern ( (|Maps.__default.IMapInvert#requires| Maps._default.IMapInvert$K@@2 Maps._default.IMapInvert$V@@2 $ly@@259 |m#0@@69|) ($IsGoodHeap $Heap@@50))
)))
(assert (forall ((arg0@@551 T@U) (arg1@@263 T@U) (arg2@@138 T@U) (arg3@@78 T@U) ) (! (= (type (|$let#8_a| arg0@@551 arg1@@263 arg2@@138 arg3@@78)) BoxType)
 :qid |funType:$let#8_a|
 :pattern ( (|$let#8_a| arg0@@551 arg1@@263 arg2@@138 arg3@@78))
)))
(assert (forall ((Maps._default.IMapInvert$K@@3 T@U) (Maps._default.IMapInvert$V@@3 T@U) (m@@67 T@U) (b@@105 T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapInvert$K@@3) TyType) (= (type Maps._default.IMapInvert$V@@3) TyType)) (= (type m@@67) (IMapType BoxType BoxType))) (= (type b@@105) BoxType)) (|$let#8$canCall| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@105)) (and (U_2_bool (MapType0Select (|IMap#Domain| m@@67) (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@105))) (= (MapType0Select (|IMap#Elements| m@@67) (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@105)) b@@105)))
 :qid |Mapsidfy.92:31|
 :skolemid |3612|
 :pattern ( (|$let#8_a| Maps._default.IMapInvert$K@@3 Maps._default.IMapInvert$V@@3 m@@67 b@@105))
)))
(assert (forall ((arg0@@552 T@U) (arg1@@264 T@U) (arg2@@139 T@U) ) (! (= (type (|lambda#195| arg0@@552 arg1@@264 arg2@@139)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#195|
 :pattern ( (|lambda#195| arg0@@552 arg1@@264 arg2@@139))
)))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@4 T@U) (Maps._default.IMapInvert$V@@4 T@U) ($ly@@260 T@U) ($Heap@@51 T@U) (|m#0@@70| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@4) TyType) (= (type Maps._default.IMapInvert$V@@4) TyType)) (= (type $ly@@260) LayerTypeType)) (= (type $Heap@@51) (MapType0Type refType MapType1Type))) (= (type |m#0@@70|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70|) (and ($IsGoodHeap $Heap@@51) ($Is |m#0@@70| (TIMap Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4))))) (and (forall ((|b#0@@48| T@U) ) (!  (=> (and (and (= (type |b#0@@48|) BoxType) ($IsBox |b#0@@48| Maps._default.IMapInvert$V@@4)) (U_2_bool (MapType0Select (|IMap#Values| |m#0@@70|) |b#0@@48|))) (|$let#8$canCall| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70| |b#0@@48|))
 :qid |Mapsidfy.92:10|
 :skolemid |3613|
 :pattern ( (MapType0Select (|IMap#Values| |m#0@@70|) |b#0@@48|))
)) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 ($LS $ly@@260) |m#0@@70|) (|IMap#Glue| (|lambda#143| Maps._default.IMapInvert$V@@4 (|IMap#Values| |m#0@@70|)) (|lambda#195| Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 |m#0@@70|) (TIMap Maps._default.IMapInvert$V@@4 Maps._default.IMapInvert$K@@4)))))
 :qid |unknown.0:0|
 :skolemid |3614|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@4 Maps._default.IMapInvert$V@@4 ($LS $ly@@260) |m#0@@70|) ($IsGoodHeap $Heap@@51))
))))
(assert  (=> true (forall ((Maps._default.IMapInvert$K@@5 T@U) (Maps._default.IMapInvert$V@@5 T@U) ($ly@@261 T@U) ($Heap@@52 T@U) (|m#0@@71| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapInvert$K@@5) TyType) (= (type Maps._default.IMapInvert$V@@5) TyType)) (= (type $ly@@261) LayerTypeType)) (= (type $Heap@@52) (MapType0Type refType MapType1Type))) (= (type |m#0@@71|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapInvert#canCall| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|)) (and ($IsGoodHeap $Heap@@52) ($Is |m#0@@71| (TIMap Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5))))) (and (forall ((|b#0@@49| T@U) ) (!  (=> (and (and (= (type |b#0@@49|) BoxType) ($IsBox |b#0@@49| Maps._default.IMapInvert$V@@5)) (U_2_bool (MapType0Select (Lit (|IMap#Values| (Lit |m#0@@71|))) |b#0@@49|))) (|$let#8$canCall| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|) |b#0@@49|))
 :qid |Mapsidfy.92:10|
 :skolemid |3615|
 :pattern ( (MapType0Select (|IMap#Values| |m#0@@71|) |b#0@@49|))
)) (= (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 ($LS $ly@@261) (Lit |m#0@@71|)) (|IMap#Glue| (|lambda#143| Maps._default.IMapInvert$V@@5 (Lit (|IMap#Values| (Lit |m#0@@71|)))) (|lambda#195| Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 (Lit |m#0@@71|)) (TIMap Maps._default.IMapInvert$V@@5 Maps._default.IMapInvert$K@@5)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3616|
 :pattern ( (Maps.__default.IMapInvert Maps._default.IMapInvert$K@@5 Maps._default.IMapInvert$V@@5 ($LS $ly@@261) (Lit |m#0@@71|)) ($IsGoodHeap $Heap@@52))
))))
(assert (forall ((arg0@@553 T@U) (arg1@@265 T@U) (arg2@@140 T@U) (arg3@@79 T@U) (arg4@@47 T@U) ) (! (= (type (Maps.__default.IMapRemove arg0@@553 arg1@@265 arg2@@140 arg3@@79 arg4@@47)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRemove|
 :pattern ( (Maps.__default.IMapRemove arg0@@553 arg1@@265 arg2@@140 arg3@@79 arg4@@47))
)))
(assert (forall ((Maps._default.IMapRemove$K T@U) (Maps._default.IMapRemove$V T@U) ($ly@@262 T@U) (|m#0@@72| T@U) (|ks#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove$K) TyType) (= (type Maps._default.IMapRemove$V) TyType)) (= (type $ly@@262) LayerTypeType)) (= (type |m#0@@72|) (IMapType BoxType BoxType))) (= (type |ks#0@@11|) (MapType0Type BoxType boolType))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V ($LS $ly@@262) |m#0@@72| |ks#0@@11|) (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V $ly@@262 |m#0@@72| |ks#0@@11|)))
 :qid |unknown.0:0|
 :skolemid |3617|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K Maps._default.IMapRemove$V ($LS $ly@@262) |m#0@@72| |ks#0@@11|))
)))
(assert (forall ((Maps._default.IMapRemove$K@@0 T@U) (Maps._default.IMapRemove$V@@0 T@U) ($ly@@263 T@U) (|m#0@@73| T@U) (|ks#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove$K@@0) TyType) (= (type Maps._default.IMapRemove$V@@0) TyType)) (= (type $ly@@263) LayerTypeType)) (= (type |m#0@@73|) (IMapType BoxType BoxType))) (= (type |ks#0@@12|) (MapType0Type BoxType boolType))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 $ly@@263 |m#0@@73| |ks#0@@12|) (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 $LZ |m#0@@73| |ks#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |3618|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@0 Maps._default.IMapRemove$V@@0 (AsFuelBottom $ly@@263) |m#0@@73| |ks#0@@12|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@1 T@U) (Maps._default.IMapRemove$V@@1 T@U) ($ly@@264 T@U) (|m#0@@74| T@U) (|ks#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@1) TyType) (= (type Maps._default.IMapRemove$V@@1) TyType)) (= (type $ly@@264) LayerTypeType)) (= (type |m#0@@74|) (IMapType BoxType BoxType))) (= (type |ks#0@@13|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 |m#0@@74| |ks#0@@13|) (and ($Is |m#0@@74| (TIMap Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1)) ($Is |ks#0@@13| (TISet Maps._default.IMapRemove$K@@1))))) (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|)) (|ISet#Difference| (|IMap#Domain| |m#0@@74|) |ks#0@@13|)) (forall ((|j#0@@12| T@U) ) (!  (=> (and (and (= (type |j#0@@12|) BoxType) ($IsBox |j#0@@12| Maps._default.IMapRemove$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|)) |j#0@@12|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|)) |j#0@@12|) (MapType0Select (|IMap#Elements| |m#0@@74|) |j#0@@12|)))
 :qid |Mapsidfy.103:20|
 :skolemid |3619|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@74|) |j#0@@12|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|)) |j#0@@12|))
 :pattern ( (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|)) |j#0@@12|))
))) ($Is (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|) (TIMap Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3620|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@1 Maps._default.IMapRemove$V@@1 $ly@@264 |m#0@@74| |ks#0@@13|))
))))
(assert (forall ((Maps._default.IMapRemove$K@@2 T@U) (Maps._default.IMapRemove$V@@2 T@U) ($ly@@265 T@U) (|m#0@@75| T@U) (|ks#0@@14| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@2) TyType) (= (type Maps._default.IMapRemove$V@@2) TyType)) (= (type $ly@@265) LayerTypeType)) (= (type |m#0@@75|) (IMapType BoxType BoxType))) (= (type |ks#0@@14|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@75| (TIMap Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2)) ($Is |ks#0@@14| (TISet Maps._default.IMapRemove$K@@2)))) (= (|Maps.__default.IMapRemove#requires| Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2 $ly@@265 |m#0@@75| |ks#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |3621|
 :pattern ( (|Maps.__default.IMapRemove#requires| Maps._default.IMapRemove$K@@2 Maps._default.IMapRemove$V@@2 $ly@@265 |m#0@@75| |ks#0@@14|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@3 T@U) (Maps._default.IMapRemove$V@@3 T@U) ($ly@@266 T@U) (|m#0@@76| T@U) (|ks#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@3) TyType) (= (type Maps._default.IMapRemove$V@@3) TyType)) (= (type $ly@@266) LayerTypeType)) (= (type |m#0@@76|) (IMapType BoxType BoxType))) (= (type |ks#0@@15|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 |m#0@@76| |ks#0@@15|) (and ($Is |m#0@@76| (TIMap Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3)) ($Is |ks#0@@15| (TISet Maps._default.IMapRemove$K@@3))))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 ($LS $ly@@266) |m#0@@76| |ks#0@@15|) (|IMap#Glue| (|lambda#190| Maps._default.IMapRemove$K@@3 (|IMap#Domain| |m#0@@76|) |ks#0@@15|) (|lambda#185| (|IMap#Elements| |m#0@@76|)) (TIMap Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3))))
 :qid |unknown.0:0|
 :skolemid |3622|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@3 Maps._default.IMapRemove$V@@3 ($LS $ly@@266) |m#0@@76| |ks#0@@15|))
))))
(assert  (=> true (forall ((Maps._default.IMapRemove$K@@4 T@U) (Maps._default.IMapRemove$V@@4 T@U) ($ly@@267 T@U) (|m#0@@77| T@U) (|ks#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove$K@@4) TyType) (= (type Maps._default.IMapRemove$V@@4) TyType)) (= (type $ly@@267) LayerTypeType)) (= (type |m#0@@77|) (IMapType BoxType BoxType))) (= (type |ks#0@@16|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRemove#canCall| Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 (Lit |m#0@@77|) (Lit |ks#0@@16|)) (and ($Is |m#0@@77| (TIMap Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4)) ($Is |ks#0@@16| (TISet Maps._default.IMapRemove$K@@4))))) (= (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 ($LS $ly@@267) (Lit |m#0@@77|) (Lit |ks#0@@16|)) (|IMap#Glue| (|lambda#190| Maps._default.IMapRemove$K@@4 (|IMap#Domain| |m#0@@77|) (Lit |ks#0@@16|)) (|lambda#185| (|IMap#Elements| (Lit |m#0@@77|))) (TIMap Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3623|
 :pattern ( (Maps.__default.IMapRemove Maps._default.IMapRemove$K@@4 Maps._default.IMapRemove$V@@4 ($LS $ly@@267) (Lit |m#0@@77|) (Lit |ks#0@@16|)))
))))
(assert (forall ((arg0@@554 T@U) (arg1@@266 T@U) (arg2@@141 T@U) (arg3@@80 T@U) (arg4@@48 T@U) ) (! (= (type (Maps.__default.IMapRemove1 arg0@@554 arg1@@266 arg2@@141 arg3@@80 arg4@@48)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRemove1|
 :pattern ( (Maps.__default.IMapRemove1 arg0@@554 arg1@@266 arg2@@141 arg3@@80 arg4@@48))
)))
(assert (forall ((Maps._default.IMapRemove1$K T@U) (Maps._default.IMapRemove1$V T@U) ($ly@@268 T@U) (|m#0@@78| T@U) (|k#0@@51| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove1$K) TyType) (= (type Maps._default.IMapRemove1$V) TyType)) (= (type $ly@@268) LayerTypeType)) (= (type |m#0@@78|) (IMapType BoxType BoxType))) (= (type |k#0@@51|) BoxType)) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V ($LS $ly@@268) |m#0@@78| |k#0@@51|) (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V $ly@@268 |m#0@@78| |k#0@@51|)))
 :qid |unknown.0:0|
 :skolemid |3624|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K Maps._default.IMapRemove1$V ($LS $ly@@268) |m#0@@78| |k#0@@51|))
)))
(assert (forall ((Maps._default.IMapRemove1$K@@0 T@U) (Maps._default.IMapRemove1$V@@0 T@U) ($ly@@269 T@U) (|m#0@@79| T@U) (|k#0@@52| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRemove1$K@@0) TyType) (= (type Maps._default.IMapRemove1$V@@0) TyType)) (= (type $ly@@269) LayerTypeType)) (= (type |m#0@@79|) (IMapType BoxType BoxType))) (= (type |k#0@@52|) BoxType)) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 $ly@@269 |m#0@@79| |k#0@@52|) (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 $LZ |m#0@@79| |k#0@@52|)))
 :qid |unknown.0:0|
 :skolemid |3625|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@0 Maps._default.IMapRemove1$V@@0 (AsFuelBottom $ly@@269) |m#0@@79| |k#0@@52|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@1 T@U) (Maps._default.IMapRemove1$V@@1 T@U) ($ly@@270 T@U) (|m#0@@80| T@U) (|k#0@@53| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@1) TyType) (= (type Maps._default.IMapRemove1$V@@1) TyType)) (= (type $ly@@270) LayerTypeType)) (= (type |m#0@@80|) (IMapType BoxType BoxType))) (= (type |k#0@@53|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 |m#0@@80| |k#0@@53|) (and ($Is |m#0@@80| (TIMap Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1)) ($IsBox |k#0@@53| Maps._default.IMapRemove1$K@@1)))) (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|)) (|ISet#Difference| (|IMap#Domain| |m#0@@80|) (|ISet#UnionOne| (|ISet#Empty| BoxType) |k#0@@53|))) (forall ((|j#0@@13| T@U) ) (!  (=> (and (and (= (type |j#0@@13|) BoxType) ($IsBox |j#0@@13| Maps._default.IMapRemove1$K@@1)) (U_2_bool (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|)) |j#0@@13|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|)) |j#0@@13|) (MapType0Select (|IMap#Elements| |m#0@@80|) |j#0@@13|)))
 :qid |Mapsidfy.110:20|
 :skolemid |3626|
 :pattern ( (MapType0Select (|IMap#Elements| |m#0@@80|) |j#0@@13|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|)) |j#0@@13|))
 :pattern ( (MapType0Select (|IMap#Domain| (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|)) |j#0@@13|))
))) ($Is (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|) (TIMap Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3627|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@1 Maps._default.IMapRemove1$V@@1 $ly@@270 |m#0@@80| |k#0@@53|))
))))
(assert (forall ((Maps._default.IMapRemove1$K@@2 T@U) (Maps._default.IMapRemove1$V@@2 T@U) ($ly@@271 T@U) (|m#0@@81| T@U) (|k#0@@54| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@2) TyType) (= (type Maps._default.IMapRemove1$V@@2) TyType)) (= (type $ly@@271) LayerTypeType)) (= (type |m#0@@81|) (IMapType BoxType BoxType))) (= (type |k#0@@54|) BoxType)) (and ($Is |m#0@@81| (TIMap Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2)) ($IsBox |k#0@@54| Maps._default.IMapRemove1$K@@2))) (= (|Maps.__default.IMapRemove1#requires| Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2 $ly@@271 |m#0@@81| |k#0@@54|) true))
 :qid |unknown.0:0|
 :skolemid |3628|
 :pattern ( (|Maps.__default.IMapRemove1#requires| Maps._default.IMapRemove1$K@@2 Maps._default.IMapRemove1$V@@2 $ly@@271 |m#0@@81| |k#0@@54|))
)))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@3 T@U) (Maps._default.IMapRemove1$V@@3 T@U) ($ly@@272 T@U) (|m#0@@82| T@U) (|k#0@@55| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@3) TyType) (= (type Maps._default.IMapRemove1$V@@3) TyType)) (= (type $ly@@272) LayerTypeType)) (= (type |m#0@@82|) (IMapType BoxType BoxType))) (= (type |k#0@@55|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 |m#0@@82| |k#0@@55|) (and ($Is |m#0@@82| (TIMap Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3)) ($IsBox |k#0@@55| Maps._default.IMapRemove1$K@@3)))) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 ($LS $ly@@272) |m#0@@82| |k#0@@55|) (|IMap#Glue| (|lambda#184| Maps._default.IMapRemove1$K@@3 (|IMap#Domain| |m#0@@82|) |k#0@@55|) (|lambda#185| (|IMap#Elements| |m#0@@82|)) (TIMap Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3))))
 :qid |unknown.0:0|
 :skolemid |3629|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@3 Maps._default.IMapRemove1$V@@3 ($LS $ly@@272) |m#0@@82| |k#0@@55|))
))))
(assert  (=> true (forall ((Maps._default.IMapRemove1$K@@4 T@U) (Maps._default.IMapRemove1$V@@4 T@U) ($ly@@273 T@U) (|m#0@@83| T@U) (|k#0@@56| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapRemove1$K@@4) TyType) (= (type Maps._default.IMapRemove1$V@@4) TyType)) (= (type $ly@@273) LayerTypeType)) (= (type |m#0@@83|) (IMapType BoxType BoxType))) (= (type |k#0@@56|) BoxType)) (or (|Maps.__default.IMapRemove1#canCall| Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 (Lit |m#0@@83|) (Lit |k#0@@56|)) (and ($Is |m#0@@83| (TIMap Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4)) ($IsBox |k#0@@56| Maps._default.IMapRemove1$K@@4)))) (= (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 ($LS $ly@@273) (Lit |m#0@@83|) (Lit |k#0@@56|)) (|IMap#Glue| (|lambda#184| Maps._default.IMapRemove1$K@@4 (|IMap#Domain| |m#0@@83|) |k#0@@56|) (|lambda#185| (|IMap#Elements| (Lit |m#0@@83|))) (TIMap Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3630|
 :pattern ( (Maps.__default.IMapRemove1 Maps._default.IMapRemove1$K@@4 Maps._default.IMapRemove1$V@@4 ($LS $ly@@273) (Lit |m#0@@83|) (Lit |k#0@@56|)))
))))
(assert (forall ((arg0@@555 T@U) (arg1@@267 T@U) (arg2@@142 T@U) (arg3@@81 T@U) ) (! (= (type (Maps.__default.MapRestrict arg0@@555 arg1@@267 arg2@@142 arg3@@81)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapRestrict|
 :pattern ( (Maps.__default.MapRestrict arg0@@555 arg1@@267 arg2@@142 arg3@@81))
)))
(assert  (=> true (forall ((Maps._default.MapRestrict$K T@U) (Maps._default.MapRestrict$V T@U) (|m#0@@84| T@U) (|ks#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K) TyType) (= (type Maps._default.MapRestrict$V) TyType)) (= (type |m#0@@84|) (MapType BoxType BoxType))) (= (type |ks#0@@17|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|) (and ($Is |m#0@@84| (TMap Maps._default.MapRestrict$K Maps._default.MapRestrict$V)) ($Is |ks#0@@17| (TSet Maps._default.MapRestrict$K))))) ($Is (Maps.__default.MapRestrict Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|) (TMap Maps._default.MapRestrict$K Maps._default.MapRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |3631|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K Maps._default.MapRestrict$V |m#0@@84| |ks#0@@17|))
))))
(assert (forall ((Maps._default.MapRestrict$K@@0 T@U) (Maps._default.MapRestrict$V@@0 T@U) (|m#0@@85| T@U) (|ks#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@0) TyType) (= (type Maps._default.MapRestrict$V@@0) TyType)) (= (type |m#0@@85|) (MapType BoxType BoxType))) (= (type |ks#0@@18|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@85| (TMap Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0)) ($Is |ks#0@@18| (TSet Maps._default.MapRestrict$K@@0)))) (= (|Maps.__default.MapRestrict#requires| Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0 |m#0@@85| |ks#0@@18|) true))
 :qid |unknown.0:0|
 :skolemid |3632|
 :pattern ( (|Maps.__default.MapRestrict#requires| Maps._default.MapRestrict$K@@0 Maps._default.MapRestrict$V@@0 |m#0@@85| |ks#0@@18|))
)))
(assert (forall ((arg0@@556 T@U) (arg1@@268 T@U) (arg2@@143 T@U) ) (! (= (type (|lambda#206| arg0@@556 arg1@@268 arg2@@143)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#206|
 :pattern ( (|lambda#206| arg0@@556 arg1@@268 arg2@@143))
)))
(assert  (=> true (forall ((Maps._default.MapRestrict$K@@1 T@U) (Maps._default.MapRestrict$V@@1 T@U) (|m#0@@86| T@U) (|ks#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@1) TyType) (= (type Maps._default.MapRestrict$V@@1) TyType)) (= (type |m#0@@86|) (MapType BoxType BoxType))) (= (type |ks#0@@19|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|) (and ($Is |m#0@@86| (TMap Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1)) ($Is |ks#0@@19| (TSet Maps._default.MapRestrict$K@@1))))) (= (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|) (|Map#Glue| (|lambda#206| Maps._default.MapRestrict$K@@1 |ks#0@@19| (|Map#Domain| |m#0@@86|)) (|lambda#185| (|Map#Elements| |m#0@@86|)) (TMap Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3633|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@1 Maps._default.MapRestrict$V@@1 |m#0@@86| |ks#0@@19|))
))))
(assert  (=> true (forall ((Maps._default.MapRestrict$K@@2 T@U) (Maps._default.MapRestrict$V@@2 T@U) (|m#0@@87| T@U) (|ks#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapRestrict$K@@2) TyType) (= (type Maps._default.MapRestrict$V@@2) TyType)) (= (type |m#0@@87|) (MapType BoxType BoxType))) (= (type |ks#0@@20|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapRestrict#canCall| Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)) (and ($Is |m#0@@87| (TMap Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2)) ($Is |ks#0@@20| (TSet Maps._default.MapRestrict$K@@2))))) (= (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)) (|Map#Glue| (|lambda#206| Maps._default.MapRestrict$K@@2 (Lit |ks#0@@20|) (|Map#Domain| |m#0@@87|)) (|lambda#185| (|Map#Elements| (Lit |m#0@@87|))) (TMap Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3634|
 :pattern ( (Maps.__default.MapRestrict Maps._default.MapRestrict$K@@2 Maps._default.MapRestrict$V@@2 (Lit |m#0@@87|) (Lit |ks#0@@20|)))
))))
(assert (forall ((arg0@@557 T@U) (arg1@@269 T@U) (arg2@@144 T@U) (arg3@@82 T@U) ) (! (= (type (Maps.__default.MapIRestrict arg0@@557 arg1@@269 arg2@@144 arg3@@82)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapIRestrict|
 :pattern ( (Maps.__default.MapIRestrict arg0@@557 arg1@@269 arg2@@144 arg3@@82))
)))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K T@U) (Maps._default.MapIRestrict$V T@U) (|m#0@@88| T@U) (|ks#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K) TyType) (= (type Maps._default.MapIRestrict$V) TyType)) (= (type |m#0@@88|) (MapType BoxType BoxType))) (= (type |ks#0@@21|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|) (and ($Is |m#0@@88| (TMap Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V)) ($Is |ks#0@@21| (TISet Maps._default.MapIRestrict$K))))) ($Is (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|) (TMap Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |3635|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K Maps._default.MapIRestrict$V |m#0@@88| |ks#0@@21|))
))))
(assert (forall ((Maps._default.MapIRestrict$K@@0 T@U) (Maps._default.MapIRestrict$V@@0 T@U) (|m#0@@89| T@U) (|ks#0@@22| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@0) TyType) (= (type Maps._default.MapIRestrict$V@@0) TyType)) (= (type |m#0@@89|) (MapType BoxType BoxType))) (= (type |ks#0@@22|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@89| (TMap Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0)) ($Is |ks#0@@22| (TISet Maps._default.MapIRestrict$K@@0)))) (= (|Maps.__default.MapIRestrict#requires| Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0 |m#0@@89| |ks#0@@22|) true))
 :qid |unknown.0:0|
 :skolemid |3636|
 :pattern ( (|Maps.__default.MapIRestrict#requires| Maps._default.MapIRestrict$K@@0 Maps._default.MapIRestrict$V@@0 |m#0@@89| |ks#0@@22|))
)))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@1 T@U) (Maps._default.MapIRestrict$V@@1 T@U) (|m#0@@90| T@U) (|ks#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@1) TyType) (= (type Maps._default.MapIRestrict$V@@1) TyType)) (= (type |m#0@@90|) (MapType BoxType BoxType))) (= (type |ks#0@@23|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|) (and ($Is |m#0@@90| (TMap Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1)) ($Is |ks#0@@23| (TISet Maps._default.MapIRestrict$K@@1))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|) (|Map#Glue| (|lambda#206| Maps._default.MapIRestrict$K@@1 (|Map#Domain| |m#0@@90|) |ks#0@@23|) (|lambda#185| (|Map#Elements| |m#0@@90|)) (TMap Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3637|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@1 Maps._default.MapIRestrict$V@@1 |m#0@@90| |ks#0@@23|))
))))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@2 T@U) (Maps._default.MapIRestrict$V@@2 T@U) (|m#0@@91| T@U) (|ks#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@2) TyType) (= (type Maps._default.MapIRestrict$V@@2) TyType)) (= (type |m#0@@91|) (MapType BoxType BoxType))) (= (type |ks#0@@24|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|) (and ($Is |m#0@@91| (TMap Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2)) ($Is |ks#0@@24| (TISet Maps._default.MapIRestrict$K@@2))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|) (|Map#Glue| (|lambda#206| Maps._default.MapIRestrict$K@@2 (|Map#Domain| |m#0@@91|) |ks#0@@24|) (|lambda#185| (|Map#Elements| (Lit |m#0@@91|))) (TMap Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3638|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@2 Maps._default.MapIRestrict$V@@2 (Lit |m#0@@91|) |ks#0@@24|))
))))
(assert  (=> true (forall ((Maps._default.MapIRestrict$K@@3 T@U) (Maps._default.MapIRestrict$V@@3 T@U) (|m#0@@92| T@U) (|ks#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapIRestrict$K@@3) TyType) (= (type Maps._default.MapIRestrict$V@@3) TyType)) (= (type |m#0@@92|) (MapType BoxType BoxType))) (= (type |ks#0@@25|) (MapType0Type BoxType boolType))) (or (|Maps.__default.MapIRestrict#canCall| Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)) (and ($Is |m#0@@92| (TMap Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3)) ($Is |ks#0@@25| (TISet Maps._default.MapIRestrict$K@@3))))) (= (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)) (|Map#Glue| (|lambda#206| Maps._default.MapIRestrict$K@@3 (|Map#Domain| |m#0@@92|) (Lit |ks#0@@25|)) (|lambda#185| (|Map#Elements| (Lit |m#0@@92|))) (TMap Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3639|
 :pattern ( (Maps.__default.MapIRestrict Maps._default.MapIRestrict$K@@3 Maps._default.MapIRestrict$V@@3 (Lit |m#0@@92|) (Lit |ks#0@@25|)))
))))
(assert (forall ((arg0@@558 T@U) (arg1@@270 T@U) (arg2@@145 T@U) (arg3@@83 T@U) ) (! (= (type (Maps.__default.IMapRestrict arg0@@558 arg1@@270 arg2@@145 arg3@@83)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapRestrict|
 :pattern ( (Maps.__default.IMapRestrict arg0@@558 arg1@@270 arg2@@145 arg3@@83))
)))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K T@U) (Maps._default.IMapRestrict$V T@U) (|m#0@@93| T@U) (|ks#0@@26| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K) TyType) (= (type Maps._default.IMapRestrict$V) TyType)) (= (type |m#0@@93|) (IMapType BoxType BoxType))) (= (type |ks#0@@26|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|) (and ($Is |m#0@@93| (TIMap Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V)) ($Is |ks#0@@26| (TISet Maps._default.IMapRestrict$K))))) ($Is (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|) (TIMap Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V)))
 :qid |unknown.0:0|
 :skolemid |3640|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K Maps._default.IMapRestrict$V |m#0@@93| |ks#0@@26|))
))))
(assert (forall ((Maps._default.IMapRestrict$K@@0 T@U) (Maps._default.IMapRestrict$V@@0 T@U) (|m#0@@94| T@U) (|ks#0@@27| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@0) TyType) (= (type Maps._default.IMapRestrict$V@@0) TyType)) (= (type |m#0@@94|) (IMapType BoxType BoxType))) (= (type |ks#0@@27|) (MapType0Type BoxType boolType))) (and ($Is |m#0@@94| (TIMap Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0)) ($Is |ks#0@@27| (TISet Maps._default.IMapRestrict$K@@0)))) (= (|Maps.__default.IMapRestrict#requires| Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0 |m#0@@94| |ks#0@@27|) true))
 :qid |unknown.0:0|
 :skolemid |3641|
 :pattern ( (|Maps.__default.IMapRestrict#requires| Maps._default.IMapRestrict$K@@0 Maps._default.IMapRestrict$V@@0 |m#0@@94| |ks#0@@27|))
)))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K@@1 T@U) (Maps._default.IMapRestrict$V@@1 T@U) (|m#0@@95| T@U) (|ks#0@@28| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@1) TyType) (= (type Maps._default.IMapRestrict$V@@1) TyType)) (= (type |m#0@@95|) (IMapType BoxType BoxType))) (= (type |ks#0@@28|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|) (and ($Is |m#0@@95| (TIMap Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1)) ($Is |ks#0@@28| (TISet Maps._default.IMapRestrict$K@@1))))) (= (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|) (|IMap#Glue| (|lambda#206| Maps._default.IMapRestrict$K@@1 |ks#0@@28| (|IMap#Domain| |m#0@@95|)) (|lambda#185| (|IMap#Elements| |m#0@@95|)) (TIMap Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3642|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@1 Maps._default.IMapRestrict$V@@1 |m#0@@95| |ks#0@@28|))
))))
(assert  (=> true (forall ((Maps._default.IMapRestrict$K@@2 T@U) (Maps._default.IMapRestrict$V@@2 T@U) (|m#0@@96| T@U) (|ks#0@@29| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapRestrict$K@@2) TyType) (= (type Maps._default.IMapRestrict$V@@2) TyType)) (= (type |m#0@@96|) (IMapType BoxType BoxType))) (= (type |ks#0@@29|) (MapType0Type BoxType boolType))) (or (|Maps.__default.IMapRestrict#canCall| Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)) (and ($Is |m#0@@96| (TIMap Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2)) ($Is |ks#0@@29| (TISet Maps._default.IMapRestrict$K@@2))))) (= (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)) (|IMap#Glue| (|lambda#206| Maps._default.IMapRestrict$K@@2 (Lit |ks#0@@29|) (|IMap#Domain| |m#0@@96|)) (|lambda#185| (|IMap#Elements| (Lit |m#0@@96|))) (TIMap Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3643|
 :pattern ( (Maps.__default.IMapRestrict Maps._default.IMapRestrict$K@@2 Maps._default.IMapRestrict$V@@2 (Lit |m#0@@96|) (Lit |ks#0@@29|)))
))))
(assert (forall ((arg0@@559 T@U) (arg1@@271 T@U) (arg2@@146 T@U) (arg3@@84 T@U) (arg4@@49 T@U) ) (! (= (type (Maps.__default.MapDisjointUnion arg0@@559 arg1@@271 arg2@@146 arg3@@84 arg4@@49)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapDisjointUnion|
 :pattern ( (Maps.__default.MapDisjointUnion arg0@@559 arg1@@271 arg2@@146 arg3@@84 arg4@@49))
)))
(assert (forall ((Maps._default.MapDisjointUnion$U T@U) (Maps._default.MapDisjointUnion$T T@U) ($ly@@274 T@U) (|mapa#0| T@U) (|mapb#0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapDisjointUnion$U) TyType) (= (type Maps._default.MapDisjointUnion$T) TyType)) (= (type $ly@@274) LayerTypeType)) (= (type |mapa#0|) (MapType BoxType BoxType))) (= (type |mapb#0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T ($LS $ly@@274) |mapa#0| |mapb#0|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T $ly@@274 |mapa#0| |mapb#0|)))
 :qid |unknown.0:0|
 :skolemid |3644|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U Maps._default.MapDisjointUnion$T ($LS $ly@@274) |mapa#0| |mapb#0|))
)))
(assert (forall ((Maps._default.MapDisjointUnion$U@@0 T@U) (Maps._default.MapDisjointUnion$T@@0 T@U) ($ly@@275 T@U) (|mapa#0@@0| T@U) (|mapb#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@0) TyType) (= (type Maps._default.MapDisjointUnion$T@@0) TyType)) (= (type $ly@@275) LayerTypeType)) (= (type |mapa#0@@0|) (MapType BoxType BoxType))) (= (type |mapb#0@@0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 $ly@@275 |mapa#0@@0| |mapb#0@@0|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 $LZ |mapa#0@@0| |mapb#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3645|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@0 Maps._default.MapDisjointUnion$T@@0 (AsFuelBottom $ly@@275) |mapa#0@@0| |mapb#0@@0|))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@1 T@U) (Maps._default.MapDisjointUnion$T@@1 T@U) ($ly@@276 T@U) (|mapa#0@@1| T@U) (|mapb#0@@1| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@1) TyType) (= (type Maps._default.MapDisjointUnion$T@@1) TyType)) (= (type $ly@@276) LayerTypeType)) (= (type |mapa#0@@1|) (MapType BoxType BoxType))) (= (type |mapb#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 |mapa#0@@1| |mapb#0@@1|) (and (and ($Is |mapa#0@@1| (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1)) ($Is |mapb#0@@1| (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1))) (|Set#Disjoint| (|Map#Domain| |mapa#0@@1|) (|Map#Domain| |mapb#0@@1|))))) (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|)) (|Set#Union| (|Map#Domain| |mapa#0@@1|) (|Map#Domain| |mapb#0@@1|))) (forall ((|k#0@@57| T@U) ) (!  (=> (and (and (= (type |k#0@@57|) BoxType) ($IsBox |k#0@@57| Maps._default.MapDisjointUnion$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@1|) |k#0@@57|))) (= (MapType0Select (|Map#Elements| |mapa#0@@1|) |k#0@@57|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|)) |k#0@@57|)))
 :qid |Mapsidfy.131:18|
 :skolemid |3646|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|)) |k#0@@57|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@1|) |k#0@@57|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@1|) |k#0@@57|))
))) (forall ((|k#1@@2| T@U) ) (!  (=> (and (and (= (type |k#1@@2|) BoxType) ($IsBox |k#1@@2| Maps._default.MapDisjointUnion$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@1|) |k#1@@2|))) (= (MapType0Select (|Map#Elements| |mapb#0@@1|) |k#1@@2|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|)) |k#1@@2|)))
 :qid |Mapsidfy.132:18|
 :skolemid |3647|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|)) |k#1@@2|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@1|) |k#1@@2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@1|) |k#1@@2|))
))) ($Is (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|) (TMap Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3648|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@1 Maps._default.MapDisjointUnion$T@@1 $ly@@276 |mapa#0@@1| |mapb#0@@1|))
))))
(assert (forall ((Maps._default.MapDisjointUnion$U@@2 T@U) (Maps._default.MapDisjointUnion$T@@2 T@U) ($ly@@277 T@U) (|mapa#0@@2| T@U) (|mapb#0@@2| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@2) TyType) (= (type Maps._default.MapDisjointUnion$T@@2) TyType)) (= (type $ly@@277) LayerTypeType)) (= (type |mapa#0@@2|) (MapType BoxType BoxType))) (= (type |mapb#0@@2|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@2| (TMap Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2)) ($Is |mapb#0@@2| (TMap Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2)))) (= (|Maps.__default.MapDisjointUnion#requires| Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2 $ly@@277 |mapa#0@@2| |mapb#0@@2|) (|Set#Disjoint| (|Map#Domain| |mapa#0@@2|) (|Map#Domain| |mapb#0@@2|))))
 :qid |unknown.0:0|
 :skolemid |3649|
 :pattern ( (|Maps.__default.MapDisjointUnion#requires| Maps._default.MapDisjointUnion$U@@2 Maps._default.MapDisjointUnion$T@@2 $ly@@277 |mapa#0@@2| |mapb#0@@2|))
)))
(assert (forall ((arg0@@560 T@U) (arg1@@272 T@U) (arg2@@147 T@U) ) (! (= (type (|lambda#221| arg0@@560 arg1@@272 arg2@@147)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#221|
 :pattern ( (|lambda#221| arg0@@560 arg1@@272 arg2@@147))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@3 T@U) (Maps._default.MapDisjointUnion$T@@3 T@U) ($ly@@278 T@U) (|mapa#0@@3| T@U) (|mapb#0@@3| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@3) TyType) (= (type Maps._default.MapDisjointUnion$T@@3) TyType)) (= (type $ly@@278) LayerTypeType)) (= (type |mapa#0@@3|) (MapType BoxType BoxType))) (= (type |mapb#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 |mapa#0@@3| |mapb#0@@3|) (and (and ($Is |mapa#0@@3| (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3)) ($Is |mapb#0@@3| (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3))) (|Set#Disjoint| (|Map#Domain| |mapa#0@@3|) (|Map#Domain| |mapb#0@@3|))))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 ($LS $ly@@278) |mapa#0@@3| |mapb#0@@3|) (|Map#Glue| (|lambda#143| Maps._default.MapDisjointUnion$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@3|) (|Map#Domain| |mapb#0@@3|))) (|lambda#221| (|Map#Domain| |mapa#0@@3|) (|Map#Elements| |mapa#0@@3|) (|Map#Elements| |mapb#0@@3|)) (TMap Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3650|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@3 Maps._default.MapDisjointUnion$T@@3 ($LS $ly@@278) |mapa#0@@3| |mapb#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion$U@@4 T@U) (Maps._default.MapDisjointUnion$T@@4 T@U) ($ly@@279 T@U) (|mapa#0@@4| T@U) (|mapb#0@@4| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion$U@@4) TyType) (= (type Maps._default.MapDisjointUnion$T@@4) TyType)) (= (type $ly@@279) LayerTypeType)) (= (type |mapa#0@@4|) (MapType BoxType BoxType))) (= (type |mapb#0@@4|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion#canCall| Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)) (and (and ($Is |mapa#0@@4| (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4)) ($Is |mapb#0@@4| (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4))) (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@4|)) (|Map#Domain| (Lit |mapb#0@@4|)))))) (= (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 ($LS $ly@@279) (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)) (|Map#Glue| (|lambda#143| Maps._default.MapDisjointUnion$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@4|)) (|Map#Domain| (Lit |mapb#0@@4|)))) (|lambda#221| (|Map#Domain| |mapa#0@@4|) (|Map#Elements| (Lit |mapa#0@@4|)) (|Map#Elements| (Lit |mapb#0@@4|))) (TMap Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3651|
 :pattern ( (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion$U@@4 Maps._default.MapDisjointUnion$T@@4 ($LS $ly@@279) (Lit |mapa#0@@4|) (Lit |mapb#0@@4|)))
))))
(assert (forall ((arg0@@561 T@U) (arg1@@273 T@U) (arg2@@148 T@U) (arg3@@85 T@U) (arg4@@50 T@U) ) (! (= (type (Maps.__default.MapUnionPreferA arg0@@561 arg1@@273 arg2@@148 arg3@@85 arg4@@50)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnionPreferA|
 :pattern ( (Maps.__default.MapUnionPreferA arg0@@561 arg1@@273 arg2@@148 arg3@@85 arg4@@50))
)))
(assert (forall ((Maps._default.MapUnionPreferA$U T@U) (Maps._default.MapUnionPreferA$T T@U) ($ly@@280 T@U) (|mapa#0@@5| T@U) (|mapb#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferA$U) TyType) (= (type Maps._default.MapUnionPreferA$T) TyType)) (= (type $ly@@280) LayerTypeType)) (= (type |mapa#0@@5|) (MapType BoxType BoxType))) (= (type |mapb#0@@5|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T ($LS $ly@@280) |mapa#0@@5| |mapb#0@@5|) (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T $ly@@280 |mapa#0@@5| |mapb#0@@5|)))
 :qid |unknown.0:0|
 :skolemid |3652|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U Maps._default.MapUnionPreferA$T ($LS $ly@@280) |mapa#0@@5| |mapb#0@@5|))
)))
(assert (forall ((Maps._default.MapUnionPreferA$U@@0 T@U) (Maps._default.MapUnionPreferA$T@@0 T@U) ($ly@@281 T@U) (|mapa#0@@6| T@U) (|mapb#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@0) TyType) (= (type Maps._default.MapUnionPreferA$T@@0) TyType)) (= (type $ly@@281) LayerTypeType)) (= (type |mapa#0@@6|) (MapType BoxType BoxType))) (= (type |mapb#0@@6|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 $ly@@281 |mapa#0@@6| |mapb#0@@6|) (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 $LZ |mapa#0@@6| |mapb#0@@6|)))
 :qid |unknown.0:0|
 :skolemid |3653|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@0 Maps._default.MapUnionPreferA$T@@0 (AsFuelBottom $ly@@281) |mapa#0@@6| |mapb#0@@6|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@1 T@U) (Maps._default.MapUnionPreferA$T@@1 T@U) ($ly@@282 T@U) (|mapa#0@@7| T@U) (|mapb#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@1) TyType) (= (type Maps._default.MapUnionPreferA$T@@1) TyType)) (= (type $ly@@282) LayerTypeType)) (= (type |mapa#0@@7|) (MapType BoxType BoxType))) (= (type |mapb#0@@7|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 |mapa#0@@7| |mapb#0@@7|) (and ($Is |mapa#0@@7| (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1)) ($Is |mapb#0@@7| (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) (|Set#Union| (|Map#Domain| |mapa#0@@7|) (|Map#Domain| |mapb#0@@7|))) (forall ((|k#0@@58| T@U) ) (!  (=> (and (and (= (type |k#0@@58|) BoxType) ($IsBox |k#0@@58| Maps._default.MapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#0@@58|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#0@@58|) (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#0@@58|)))
 :qid |Mapsidfy.141:20|
 :skolemid |3654|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#0@@58|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#0@@58|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#0@@58|))
))) (forall ((|k#1@@3| T@U) ) (!  (=> (and (and (= (type |k#1@@3|) BoxType) ($IsBox |k#1@@3| Maps._default.MapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|) (|Map#Domain| |mapa#0@@7|)) |k#1@@3|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#1@@3|) (MapType0Select (|Map#Elements| |mapb#0@@7|) |k#1@@3|)))
 :qid |Mapsidfy.142:20|
 :skolemid |3655|
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@7|) |k#1@@3|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#1@@3|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@7|) (|Map#Domain| |mapa#0@@7|)) |k#1@@3|))
))) (forall ((|k#2| T@U) ) (!  (=> (and (and (= (type |k#2|) BoxType) ($IsBox |k#2| Maps._default.MapUnionPreferA$U@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#2|)) (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@7|) |k#2|))))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#2|) (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#2|)))
 :qid |Mapsidfy.143:20|
 :skolemid |3656|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@7|) |k#2|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|)) |k#2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@7|) |k#2|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@7|) |k#2|))
))) ($Is (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|) (TMap Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3657|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@1 Maps._default.MapUnionPreferA$T@@1 $ly@@282 |mapa#0@@7| |mapb#0@@7|))
))))
(assert (forall ((Maps._default.MapUnionPreferA$U@@2 T@U) (Maps._default.MapUnionPreferA$T@@2 T@U) ($ly@@283 T@U) (|mapa#0@@8| T@U) (|mapb#0@@8| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@2) TyType) (= (type Maps._default.MapUnionPreferA$T@@2) TyType)) (= (type $ly@@283) LayerTypeType)) (= (type |mapa#0@@8|) (MapType BoxType BoxType))) (= (type |mapb#0@@8|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@8| (TMap Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2)) ($Is |mapb#0@@8| (TMap Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2)))) (= (|Maps.__default.MapUnionPreferA#requires| Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2 $ly@@283 |mapa#0@@8| |mapb#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |3658|
 :pattern ( (|Maps.__default.MapUnionPreferA#requires| Maps._default.MapUnionPreferA$U@@2 Maps._default.MapUnionPreferA$T@@2 $ly@@283 |mapa#0@@8| |mapb#0@@8|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@3 T@U) (Maps._default.MapUnionPreferA$T@@3 T@U) ($ly@@284 T@U) (|mapa#0@@9| T@U) (|mapb#0@@9| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@3) TyType) (= (type Maps._default.MapUnionPreferA$T@@3) TyType)) (= (type $ly@@284) LayerTypeType)) (= (type |mapa#0@@9|) (MapType BoxType BoxType))) (= (type |mapb#0@@9|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 |mapa#0@@9| |mapb#0@@9|) (and ($Is |mapa#0@@9| (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3)) ($Is |mapb#0@@9| (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3))))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 ($LS $ly@@284) |mapa#0@@9| |mapb#0@@9|) (|Map#Glue| (|lambda#143| Maps._default.MapUnionPreferA$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@9|) (|Map#Domain| |mapb#0@@9|))) (|lambda#221| (|Map#Domain| |mapa#0@@9|) (|Map#Elements| |mapa#0@@9|) (|Map#Elements| |mapb#0@@9|)) (TMap Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3659|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@3 Maps._default.MapUnionPreferA$T@@3 ($LS $ly@@284) |mapa#0@@9| |mapb#0@@9|))
))))
(assert  (=> true (forall ((Maps._default.MapUnionPreferA$U@@4 T@U) (Maps._default.MapUnionPreferA$T@@4 T@U) ($ly@@285 T@U) (|mapa#0@@10| T@U) (|mapb#0@@10| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferA$U@@4) TyType) (= (type Maps._default.MapUnionPreferA$T@@4) TyType)) (= (type $ly@@285) LayerTypeType)) (= (type |mapa#0@@10|) (MapType BoxType BoxType))) (= (type |mapb#0@@10|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)) (and ($Is |mapa#0@@10| (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4)) ($Is |mapb#0@@10| (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4))))) (= (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 ($LS $ly@@285) (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)) (|Map#Glue| (|lambda#143| Maps._default.MapUnionPreferA$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@10|)) (|Map#Domain| (Lit |mapb#0@@10|)))) (|lambda#221| (|Map#Domain| |mapa#0@@10|) (|Map#Elements| (Lit |mapa#0@@10|)) (|Map#Elements| (Lit |mapb#0@@10|))) (TMap Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3660|
 :pattern ( (Maps.__default.MapUnionPreferA Maps._default.MapUnionPreferA$U@@4 Maps._default.MapUnionPreferA$T@@4 ($LS $ly@@285) (Lit |mapa#0@@10|) (Lit |mapb#0@@10|)))
))))
(assert (forall ((arg0@@562 T@U) (arg1@@274 T@U) (arg2@@149 T@U) (arg3@@86 T@U) (arg4@@51 T@U) ) (! (= (type (Maps.__default.MapUnionPreferB arg0@@562 arg1@@274 arg2@@149 arg3@@86 arg4@@51)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnionPreferB|
 :pattern ( (Maps.__default.MapUnionPreferB arg0@@562 arg1@@274 arg2@@149 arg3@@86 arg4@@51))
)))
(assert (forall ((Maps._default.MapUnionPreferB$U T@U) (Maps._default.MapUnionPreferB$T T@U) ($ly@@286 T@U) (|mapa#0@@11| T@U) (|mapb#0@@11| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferB$U) TyType) (= (type Maps._default.MapUnionPreferB$T) TyType)) (= (type $ly@@286) LayerTypeType)) (= (type |mapa#0@@11|) (MapType BoxType BoxType))) (= (type |mapb#0@@11|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T ($LS $ly@@286) |mapa#0@@11| |mapb#0@@11|) (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T $ly@@286 |mapa#0@@11| |mapb#0@@11|)))
 :qid |unknown.0:0|
 :skolemid |3661|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U Maps._default.MapUnionPreferB$T ($LS $ly@@286) |mapa#0@@11| |mapb#0@@11|))
)))
(assert (forall ((Maps._default.MapUnionPreferB$U@@0 T@U) (Maps._default.MapUnionPreferB$T@@0 T@U) ($ly@@287 T@U) (|mapa#0@@12| T@U) (|mapb#0@@12| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@0) TyType) (= (type Maps._default.MapUnionPreferB$T@@0) TyType)) (= (type $ly@@287) LayerTypeType)) (= (type |mapa#0@@12|) (MapType BoxType BoxType))) (= (type |mapb#0@@12|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 $ly@@287 |mapa#0@@12| |mapb#0@@12|) (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 $LZ |mapa#0@@12| |mapb#0@@12|)))
 :qid |unknown.0:0|
 :skolemid |3662|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@0 Maps._default.MapUnionPreferB$T@@0 (AsFuelBottom $ly@@287) |mapa#0@@12| |mapb#0@@12|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@1 T@U) (Maps._default.MapUnionPreferB$T@@1 T@U) ($ly@@288 T@U) (|mapa#0@@13| T@U) (|mapb#0@@13| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@1) TyType) (= (type Maps._default.MapUnionPreferB$T@@1) TyType)) (= (type $ly@@288) LayerTypeType)) (= (type |mapa#0@@13|) (MapType BoxType BoxType))) (= (type |mapb#0@@13|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 |mapa#0@@13| |mapb#0@@13|) (and ($Is |mapa#0@@13| (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1)) ($Is |mapb#0@@13| (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1))))) (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) (|Set#Union| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|))) (forall ((|k#0@@59| T@U) ) (!  (=> (and (and (= (type |k#0@@59|) BoxType) ($IsBox |k#0@@59| Maps._default.MapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#0@@59|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#0@@59|) (MapType0Select (|Map#Elements| |mapb#0@@13|) |k#0@@59|)))
 :qid |Mapsidfy.150:20|
 :skolemid |3663|
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@13|) |k#0@@59|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#0@@59|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#0@@59|))
))) (forall ((|k#1@@4| T@U) ) (!  (=> (and (and (= (type |k#1@@4|) BoxType) ($IsBox |k#1@@4| Maps._default.MapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|)) |k#1@@4|))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#1@@4|) (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#1@@4|)))
 :qid |Mapsidfy.151:20|
 :skolemid |3664|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#1@@4|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#1@@4|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@13|) (|Map#Domain| |mapb#0@@13|)) |k#1@@4|))
))) (forall ((|k#2@@0| T@U) ) (!  (=> (and (and (= (type |k#2@@0|) BoxType) ($IsBox |k#2@@0| Maps._default.MapUnionPreferB$U@@1)) (and (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@13|) |k#2@@0|)) (not (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#2@@0|))))) (= (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#2@@0|) (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#2@@0|)))
 :qid |Mapsidfy.152:20|
 :skolemid |3665|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@13|) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|)) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@13|) |k#2@@0|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@13|) |k#2@@0|))
))) ($Is (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|) (TMap Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3666|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@1 Maps._default.MapUnionPreferB$T@@1 $ly@@288 |mapa#0@@13| |mapb#0@@13|))
))))
(assert (forall ((Maps._default.MapUnionPreferB$U@@2 T@U) (Maps._default.MapUnionPreferB$T@@2 T@U) ($ly@@289 T@U) (|mapa#0@@14| T@U) (|mapb#0@@14| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@2) TyType) (= (type Maps._default.MapUnionPreferB$T@@2) TyType)) (= (type $ly@@289) LayerTypeType)) (= (type |mapa#0@@14|) (MapType BoxType BoxType))) (= (type |mapb#0@@14|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@14| (TMap Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2)) ($Is |mapb#0@@14| (TMap Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2)))) (= (|Maps.__default.MapUnionPreferB#requires| Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2 $ly@@289 |mapa#0@@14| |mapb#0@@14|) true))
 :qid |unknown.0:0|
 :skolemid |3667|
 :pattern ( (|Maps.__default.MapUnionPreferB#requires| Maps._default.MapUnionPreferB$U@@2 Maps._default.MapUnionPreferB$T@@2 $ly@@289 |mapa#0@@14| |mapb#0@@14|))
)))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@3 T@U) (Maps._default.MapUnionPreferB$T@@3 T@U) ($ly@@290 T@U) (|mapa#0@@15| T@U) (|mapb#0@@15| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@3) TyType) (= (type Maps._default.MapUnionPreferB$T@@3) TyType)) (= (type $ly@@290) LayerTypeType)) (= (type |mapa#0@@15|) (MapType BoxType BoxType))) (= (type |mapb#0@@15|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 |mapa#0@@15| |mapb#0@@15|) (and ($Is |mapa#0@@15| (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3)) ($Is |mapb#0@@15| (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3))))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 ($LS $ly@@290) |mapa#0@@15| |mapb#0@@15|) (|Map#Glue| (|lambda#143| Maps._default.MapUnionPreferB$U@@3 (|Set#Union| (|Map#Domain| |mapa#0@@15|) (|Map#Domain| |mapb#0@@15|))) (|lambda#221| (|Map#Domain| |mapb#0@@15|) (|Map#Elements| |mapb#0@@15|) (|Map#Elements| |mapa#0@@15|)) (TMap Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3668|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@3 Maps._default.MapUnionPreferB$T@@3 ($LS $ly@@290) |mapa#0@@15| |mapb#0@@15|))
))))
(assert  (=> true (forall ((Maps._default.MapUnionPreferB$U@@4 T@U) (Maps._default.MapUnionPreferB$T@@4 T@U) ($ly@@291 T@U) (|mapa#0@@16| T@U) (|mapb#0@@16| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnionPreferB$U@@4) TyType) (= (type Maps._default.MapUnionPreferB$T@@4) TyType)) (= (type $ly@@291) LayerTypeType)) (= (type |mapa#0@@16|) (MapType BoxType BoxType))) (= (type |mapb#0@@16|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnionPreferB#canCall| Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)) (and ($Is |mapa#0@@16| (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4)) ($Is |mapb#0@@16| (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4))))) (= (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 ($LS $ly@@291) (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)) (|Map#Glue| (|lambda#143| Maps._default.MapUnionPreferB$U@@4 (|Set#Union| (|Map#Domain| (Lit |mapa#0@@16|)) (|Map#Domain| (Lit |mapb#0@@16|)))) (|lambda#221| (|Map#Domain| |mapb#0@@16|) (|Map#Elements| (Lit |mapb#0@@16|)) (|Map#Elements| (Lit |mapa#0@@16|))) (TMap Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3669|
 :pattern ( (Maps.__default.MapUnionPreferB Maps._default.MapUnionPreferB$U@@4 Maps._default.MapUnionPreferB$T@@4 ($LS $ly@@291) (Lit |mapa#0@@16|) (Lit |mapb#0@@16|)))
))))
(assert (forall ((arg0@@563 T@U) (arg1@@275 T@U) (arg2@@150 T@U) (arg3@@87 T@U) (arg4@@52 T@U) ) (! (= (type (Maps.__default.MapUnion arg0@@563 arg1@@275 arg2@@150 arg3@@87 arg4@@52)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapUnion|
 :pattern ( (Maps.__default.MapUnion arg0@@563 arg1@@275 arg2@@150 arg3@@87 arg4@@52))
)))
(assert (forall ((Maps._default.MapUnion$U T@U) (Maps._default.MapUnion$T T@U) ($ly@@292 T@U) (|mapa#0@@17| T@U) (|mapb#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnion$U) TyType) (= (type Maps._default.MapUnion$T) TyType)) (= (type $ly@@292) LayerTypeType)) (= (type |mapa#0@@17|) (MapType BoxType BoxType))) (= (type |mapb#0@@17|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T ($LS $ly@@292) |mapa#0@@17| |mapb#0@@17|) (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T $ly@@292 |mapa#0@@17| |mapb#0@@17|)))
 :qid |unknown.0:0|
 :skolemid |3670|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U Maps._default.MapUnion$T ($LS $ly@@292) |mapa#0@@17| |mapb#0@@17|))
)))
(assert (forall ((Maps._default.MapUnion$U@@0 T@U) (Maps._default.MapUnion$T@@0 T@U) ($ly@@293 T@U) (|mapa#0@@18| T@U) (|mapb#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapUnion$U@@0) TyType) (= (type Maps._default.MapUnion$T@@0) TyType)) (= (type $ly@@293) LayerTypeType)) (= (type |mapa#0@@18|) (MapType BoxType BoxType))) (= (type |mapb#0@@18|) (MapType BoxType BoxType))) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 $ly@@293 |mapa#0@@18| |mapb#0@@18|) (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 $LZ |mapa#0@@18| |mapb#0@@18|)))
 :qid |unknown.0:0|
 :skolemid |3671|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@0 Maps._default.MapUnion$T@@0 (AsFuelBottom $ly@@293) |mapa#0@@18| |mapb#0@@18|))
)))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@1 T@U) (Maps._default.MapUnion$T@@1 T@U) ($ly@@294 T@U) (|mapa#0@@19| T@U) (|mapb#0@@19| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@1) TyType) (= (type Maps._default.MapUnion$T@@1) TyType)) (= (type $ly@@294) LayerTypeType)) (= (type |mapa#0@@19|) (MapType BoxType BoxType))) (= (type |mapb#0@@19|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapa#0@@19| |mapb#0@@19|) (and ($Is |mapa#0@@19| (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1)) ($Is |mapb#0@@19| (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1))))) (and (and (and (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) (|Set#Union| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|))) (forall ((|k#0@@60| T@U) ) (!  (=> (and (and (= (type |k#0@@60|) BoxType) ($IsBox |k#0@@60| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#0@@60|))) (= (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#0@@60|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#0@@60|)))
 :qid |Mapsidfy.161:18|
 :skolemid |3672|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#0@@60|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#0@@60|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#0@@60|))
))) (forall ((|k#1@@5| T@U) ) (!  (=> (and (and (= (type |k#1@@5|) BoxType) ($IsBox |k#1@@5| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|) (|Map#Domain| |mapa#0@@19|)) |k#1@@5|))) (= (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#1@@5|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#1@@5|)))
 :qid |Mapsidfy.162:18|
 :skolemid |3673|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#1@@5|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#1@@5|))
 :pattern ( (MapType0Select (|Set#Difference| (|Map#Domain| |mapb#0@@19|) (|Map#Domain| |mapa#0@@19|)) |k#1@@5|))
))) (forall ((|k#2@@1| T@U) ) (!  (=> (and (and (= (type |k#2@@1|) BoxType) ($IsBox |k#2@@1| Maps._default.MapUnion$U@@1)) (U_2_bool (MapType0Select (|Set#Intersection| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#2@@1|))) (or (= (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#2@@1|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|)) (= (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#2@@1|) (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|))))
 :qid |Mapsidfy.163:18|
 :skolemid |3674|
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@19|) |k#2@@1|))
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) |k#2@@1|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@19|) |k#2@@1|))
 :pattern ( (MapType0Select (|Set#Intersection| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) |k#2@@1|))
))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (|Set#Equal| (|Map#Values| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)) (|Set#Union| (|Map#Values| |mapa#0@@19|) (|Map#Values| |mapb#0@@19|))))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (Maps.__default.IsSubMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapa#0@@19| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)))) (=> (|Set#Disjoint| (|Map#Domain| |mapa#0@@19|) (|Map#Domain| |mapb#0@@19|)) (Maps.__default.IsSubMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 |mapb#0@@19| (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|)))) ($Is (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|) (TMap Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3675|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@1 Maps._default.MapUnion$T@@1 $ly@@294 |mapa#0@@19| |mapb#0@@19|))
))))
(assert (forall ((Maps._default.MapUnion$U@@2 T@U) (Maps._default.MapUnion$T@@2 T@U) ($ly@@295 T@U) (|mapa#0@@20| T@U) (|mapb#0@@20| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@2) TyType) (= (type Maps._default.MapUnion$T@@2) TyType)) (= (type $ly@@295) LayerTypeType)) (= (type |mapa#0@@20|) (MapType BoxType BoxType))) (= (type |mapb#0@@20|) (MapType BoxType BoxType))) (and ($Is |mapa#0@@20| (TMap Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2)) ($Is |mapb#0@@20| (TMap Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2)))) (= (|Maps.__default.MapUnion#requires| Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2 $ly@@295 |mapa#0@@20| |mapb#0@@20|) true))
 :qid |unknown.0:0|
 :skolemid |3676|
 :pattern ( (|Maps.__default.MapUnion#requires| Maps._default.MapUnion$U@@2 Maps._default.MapUnion$T@@2 $ly@@295 |mapa#0@@20| |mapb#0@@20|))
)))
(assert (= (type StartFuel_Maps._default.MapUnionPreferA) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@3 T@U) (Maps._default.MapUnion$T@@3 T@U) ($ly@@296 T@U) (|mapa#0@@21| T@U) (|mapb#0@@21| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@3) TyType) (= (type Maps._default.MapUnion$T@@3) TyType)) (= (type $ly@@296) LayerTypeType)) (= (type |mapa#0@@21|) (MapType BoxType BoxType))) (= (type |mapb#0@@21|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 |mapa#0@@21| |mapb#0@@21|) (and ($Is |mapa#0@@21| (TMap Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3)) ($Is |mapb#0@@21| (TMap Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3))))) (and (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 |mapa#0@@21| |mapb#0@@21|) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 ($LS $ly@@296) |mapa#0@@21| |mapb#0@@21|) (Maps.__default.MapUnionPreferA Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 StartFuel_Maps._default.MapUnionPreferA |mapa#0@@21| |mapb#0@@21|))))
 :qid |unknown.0:0|
 :skolemid |3677|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@3 Maps._default.MapUnion$T@@3 ($LS $ly@@296) |mapa#0@@21| |mapb#0@@21|))
))))
(assert  (=> true (forall ((Maps._default.MapUnion$U@@4 T@U) (Maps._default.MapUnion$T@@4 T@U) ($ly@@297 T@U) (|mapa#0@@22| T@U) (|mapb#0@@22| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapUnion$U@@4) TyType) (= (type Maps._default.MapUnion$T@@4) TyType)) (= (type $ly@@297) LayerTypeType)) (= (type |mapa#0@@22|) (MapType BoxType BoxType))) (= (type |mapb#0@@22|) (MapType BoxType BoxType))) (or (|Maps.__default.MapUnion#canCall| Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (and ($Is |mapa#0@@22| (TMap Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4)) ($Is |mapb#0@@22| (TMap Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4))))) (and (|Maps.__default.MapUnionPreferA#canCall| Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (= (Maps.__default.MapUnion Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 ($LS $ly@@297) (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)) (Maps.__default.MapUnionPreferA Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 StartFuel_Maps._default.MapUnionPreferA (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3678|
 :pattern ( (Maps.__default.MapUnion Maps._default.MapUnion$U@@4 Maps._default.MapUnion$T@@4 ($LS $ly@@297) (Lit |mapa#0@@22|) (Lit |mapb#0@@22|)))
))))
(assert (forall ((arg0@@564 T@U) (arg1@@276 T@U) (arg2@@151 T@U) (arg3@@88 T@U) (arg4@@53 T@U) ) (! (= (type (Maps.__default.IMapUnionPreferA arg0@@564 arg1@@276 arg2@@151 arg3@@88 arg4@@53)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnionPreferA|
 :pattern ( (Maps.__default.IMapUnionPreferA arg0@@564 arg1@@276 arg2@@151 arg3@@88 arg4@@53))
)))
(assert (forall ((Maps._default.IMapUnionPreferA$U T@U) (Maps._default.IMapUnionPreferA$T T@U) ($ly@@298 T@U) (|mapa#0@@23| T@U) (|mapb#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U) TyType) (= (type Maps._default.IMapUnionPreferA$T) TyType)) (= (type $ly@@298) LayerTypeType)) (= (type |mapa#0@@23|) (IMapType BoxType BoxType))) (= (type |mapb#0@@23|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T ($LS $ly@@298) |mapa#0@@23| |mapb#0@@23|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T $ly@@298 |mapa#0@@23| |mapb#0@@23|)))
 :qid |unknown.0:0|
 :skolemid |3679|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U Maps._default.IMapUnionPreferA$T ($LS $ly@@298) |mapa#0@@23| |mapb#0@@23|))
)))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@0 T@U) (Maps._default.IMapUnionPreferA$T@@0 T@U) ($ly@@299 T@U) (|mapa#0@@24| T@U) (|mapb#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@0) TyType) (= (type Maps._default.IMapUnionPreferA$T@@0) TyType)) (= (type $ly@@299) LayerTypeType)) (= (type |mapa#0@@24|) (IMapType BoxType BoxType))) (= (type |mapb#0@@24|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 $ly@@299 |mapa#0@@24| |mapb#0@@24|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 $LZ |mapa#0@@24| |mapb#0@@24|)))
 :qid |unknown.0:0|
 :skolemid |3680|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@0 Maps._default.IMapUnionPreferA$T@@0 (AsFuelBottom $ly@@299) |mapa#0@@24| |mapb#0@@24|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@1 T@U) (Maps._default.IMapUnionPreferA$T@@1 T@U) ($ly@@300 T@U) (|mapa#0@@25| T@U) (|mapb#0@@25| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@1) TyType) (= (type Maps._default.IMapUnionPreferA$T@@1) TyType)) (= (type $ly@@300) LayerTypeType)) (= (type |mapa#0@@25|) (IMapType BoxType BoxType))) (= (type |mapb#0@@25|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 |mapa#0@@25| |mapb#0@@25|) (and ($Is |mapa#0@@25| (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1)) ($Is |mapb#0@@25| (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@25|) (|IMap#Domain| |mapb#0@@25|))) (forall ((|k#0@@61| T@U) ) (!  (=> (and (and (= (type |k#0@@61|) BoxType) ($IsBox |k#0@@61| Maps._default.IMapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#0@@61|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#0@@61|) (MapType0Select (|IMap#Elements| |mapa#0@@25|) |k#0@@61|)))
 :qid |Mapsidfy.173:20|
 :skolemid |3681|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@25|) |k#0@@61|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#0@@61|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#0@@61|))
))) (forall ((|k#1@@6| T@U) ) (!  (=> (and (and (= (type |k#1@@6|) BoxType) ($IsBox |k#1@@6| Maps._default.IMapUnionPreferA$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@25|) (|IMap#Domain| |mapa#0@@25|)) |k#1@@6|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#1@@6|) (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#1@@6|)))
 :qid |Mapsidfy.174:20|
 :skolemid |3682|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#1@@6|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#1@@6|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@25|) (|IMap#Domain| |mapa#0@@25|)) |k#1@@6|))
))) (forall ((|k#2@@2| T@U) ) (!  (=> (and (and (= (type |k#2@@2|) BoxType) ($IsBox |k#2@@2| Maps._default.IMapUnionPreferA$U@@1)) (and (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@25|) |k#2@@2|)) (not (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#2@@2|))))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#2@@2|) (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#2@@2|)))
 :qid |Mapsidfy.175:20|
 :skolemid |3683|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@25|) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|)) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@25|) |k#2@@2|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@25|) |k#2@@2|))
))) ($Is (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|) (TIMap Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3684|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@1 Maps._default.IMapUnionPreferA$T@@1 $ly@@300 |mapa#0@@25| |mapb#0@@25|))
))))
(assert (forall ((Maps._default.IMapUnionPreferA$U@@2 T@U) (Maps._default.IMapUnionPreferA$T@@2 T@U) ($ly@@301 T@U) (|mapa#0@@26| T@U) (|mapb#0@@26| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@2) TyType) (= (type Maps._default.IMapUnionPreferA$T@@2) TyType)) (= (type $ly@@301) LayerTypeType)) (= (type |mapa#0@@26|) (IMapType BoxType BoxType))) (= (type |mapb#0@@26|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@26| (TIMap Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2)) ($Is |mapb#0@@26| (TIMap Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2)))) (= (|Maps.__default.IMapUnionPreferA#requires| Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2 $ly@@301 |mapa#0@@26| |mapb#0@@26|) true))
 :qid |unknown.0:0|
 :skolemid |3685|
 :pattern ( (|Maps.__default.IMapUnionPreferA#requires| Maps._default.IMapUnionPreferA$U@@2 Maps._default.IMapUnionPreferA$T@@2 $ly@@301 |mapa#0@@26| |mapb#0@@26|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@3 T@U) (Maps._default.IMapUnionPreferA$T@@3 T@U) ($ly@@302 T@U) (|mapa#0@@27| T@U) (|mapb#0@@27| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@3) TyType) (= (type Maps._default.IMapUnionPreferA$T@@3) TyType)) (= (type $ly@@302) LayerTypeType)) (= (type |mapa#0@@27|) (IMapType BoxType BoxType))) (= (type |mapb#0@@27|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 |mapa#0@@27| |mapb#0@@27|) (and ($Is |mapa#0@@27| (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3)) ($Is |mapb#0@@27| (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3))))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 ($LS $ly@@302) |mapa#0@@27| |mapb#0@@27|) (|IMap#Glue| (|lambda#143| Maps._default.IMapUnionPreferA$U@@3 (|ISet#Union| (|IMap#Domain| |mapa#0@@27|) (|IMap#Domain| |mapb#0@@27|))) (|lambda#221| (|IMap#Domain| |mapa#0@@27|) (|IMap#Elements| |mapa#0@@27|) (|IMap#Elements| |mapb#0@@27|)) (TIMap Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3686|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@3 Maps._default.IMapUnionPreferA$T@@3 ($LS $ly@@302) |mapa#0@@27| |mapb#0@@27|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferA$U@@4 T@U) (Maps._default.IMapUnionPreferA$T@@4 T@U) ($ly@@303 T@U) (|mapa#0@@28| T@U) (|mapb#0@@28| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferA$U@@4) TyType) (= (type Maps._default.IMapUnionPreferA$T@@4) TyType)) (= (type $ly@@303) LayerTypeType)) (= (type |mapa#0@@28|) (IMapType BoxType BoxType))) (= (type |mapb#0@@28|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)) (and ($Is |mapa#0@@28| (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4)) ($Is |mapb#0@@28| (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4))))) (= (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 ($LS $ly@@303) (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)) (|IMap#Glue| (|lambda#143| Maps._default.IMapUnionPreferA$U@@4 (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@28|)) (|IMap#Domain| (Lit |mapb#0@@28|)))) (|lambda#221| (|IMap#Domain| |mapa#0@@28|) (|IMap#Elements| (Lit |mapa#0@@28|)) (|IMap#Elements| (Lit |mapb#0@@28|))) (TIMap Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3687|
 :pattern ( (Maps.__default.IMapUnionPreferA Maps._default.IMapUnionPreferA$U@@4 Maps._default.IMapUnionPreferA$T@@4 ($LS $ly@@303) (Lit |mapa#0@@28|) (Lit |mapb#0@@28|)))
))))
(assert (forall ((arg0@@565 T@U) (arg1@@277 T@U) (arg2@@152 T@U) (arg3@@89 T@U) (arg4@@54 T@U) ) (! (= (type (Maps.__default.IMapUnionPreferB arg0@@565 arg1@@277 arg2@@152 arg3@@89 arg4@@54)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnionPreferB|
 :pattern ( (Maps.__default.IMapUnionPreferB arg0@@565 arg1@@277 arg2@@152 arg3@@89 arg4@@54))
)))
(assert (forall ((Maps._default.IMapUnionPreferB$U T@U) (Maps._default.IMapUnionPreferB$T T@U) ($ly@@304 T@U) (|mapa#0@@29| T@U) (|mapb#0@@29| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U) TyType) (= (type Maps._default.IMapUnionPreferB$T) TyType)) (= (type $ly@@304) LayerTypeType)) (= (type |mapa#0@@29|) (IMapType BoxType BoxType))) (= (type |mapb#0@@29|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T ($LS $ly@@304) |mapa#0@@29| |mapb#0@@29|) (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T $ly@@304 |mapa#0@@29| |mapb#0@@29|)))
 :qid |unknown.0:0|
 :skolemid |3688|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U Maps._default.IMapUnionPreferB$T ($LS $ly@@304) |mapa#0@@29| |mapb#0@@29|))
)))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@0 T@U) (Maps._default.IMapUnionPreferB$T@@0 T@U) ($ly@@305 T@U) (|mapa#0@@30| T@U) (|mapb#0@@30| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@0) TyType) (= (type Maps._default.IMapUnionPreferB$T@@0) TyType)) (= (type $ly@@305) LayerTypeType)) (= (type |mapa#0@@30|) (IMapType BoxType BoxType))) (= (type |mapb#0@@30|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 $ly@@305 |mapa#0@@30| |mapb#0@@30|) (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 $LZ |mapa#0@@30| |mapb#0@@30|)))
 :qid |unknown.0:0|
 :skolemid |3689|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@0 Maps._default.IMapUnionPreferB$T@@0 (AsFuelBottom $ly@@305) |mapa#0@@30| |mapb#0@@30|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@1 T@U) (Maps._default.IMapUnionPreferB$T@@1 T@U) ($ly@@306 T@U) (|mapa#0@@31| T@U) (|mapb#0@@31| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@1) TyType) (= (type Maps._default.IMapUnionPreferB$T@@1) TyType)) (= (type $ly@@306) LayerTypeType)) (= (type |mapa#0@@31|) (IMapType BoxType BoxType))) (= (type |mapb#0@@31|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 |mapa#0@@31| |mapb#0@@31|) (and ($Is |mapa#0@@31| (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1)) ($Is |mapb#0@@31| (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|))) (forall ((|k#0@@62| T@U) ) (!  (=> (and (and (= (type |k#0@@62|) BoxType) ($IsBox |k#0@@62| Maps._default.IMapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#0@@62|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#0@@62|) (MapType0Select (|IMap#Elements| |mapb#0@@31|) |k#0@@62|)))
 :qid |Mapsidfy.182:20|
 :skolemid |3690|
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@31|) |k#0@@62|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#0@@62|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#0@@62|))
))) (forall ((|k#1@@7| T@U) ) (!  (=> (and (and (= (type |k#1@@7|) BoxType) ($IsBox |k#1@@7| Maps._default.IMapUnionPreferB$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|)) |k#1@@7|))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#1@@7|) (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#1@@7|)))
 :qid |Mapsidfy.183:20|
 :skolemid |3691|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#1@@7|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#1@@7|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@31|) (|IMap#Domain| |mapb#0@@31|)) |k#1@@7|))
))) (forall ((|k#2@@3| T@U) ) (!  (=> (and (and (= (type |k#2@@3|) BoxType) ($IsBox |k#2@@3| Maps._default.IMapUnionPreferB$U@@1)) (and (U_2_bool (MapType0Select (|IMap#Domain| |mapa#0@@31|) |k#2@@3|)) (not (U_2_bool (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#2@@3|))))) (= (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#2@@3|) (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#2@@3|)))
 :qid |Mapsidfy.184:20|
 :skolemid |3692|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@31|) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|)) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapb#0@@31|) |k#2@@3|))
 :pattern ( (MapType0Select (|IMap#Domain| |mapa#0@@31|) |k#2@@3|))
))) ($Is (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|) (TIMap Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3693|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@1 Maps._default.IMapUnionPreferB$T@@1 $ly@@306 |mapa#0@@31| |mapb#0@@31|))
))))
(assert (forall ((Maps._default.IMapUnionPreferB$U@@2 T@U) (Maps._default.IMapUnionPreferB$T@@2 T@U) ($ly@@307 T@U) (|mapa#0@@32| T@U) (|mapb#0@@32| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@2) TyType) (= (type Maps._default.IMapUnionPreferB$T@@2) TyType)) (= (type $ly@@307) LayerTypeType)) (= (type |mapa#0@@32|) (IMapType BoxType BoxType))) (= (type |mapb#0@@32|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@32| (TIMap Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2)) ($Is |mapb#0@@32| (TIMap Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2)))) (= (|Maps.__default.IMapUnionPreferB#requires| Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2 $ly@@307 |mapa#0@@32| |mapb#0@@32|) true))
 :qid |unknown.0:0|
 :skolemid |3694|
 :pattern ( (|Maps.__default.IMapUnionPreferB#requires| Maps._default.IMapUnionPreferB$U@@2 Maps._default.IMapUnionPreferB$T@@2 $ly@@307 |mapa#0@@32| |mapb#0@@32|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@3 T@U) (Maps._default.IMapUnionPreferB$T@@3 T@U) ($ly@@308 T@U) (|mapa#0@@33| T@U) (|mapb#0@@33| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@3) TyType) (= (type Maps._default.IMapUnionPreferB$T@@3) TyType)) (= (type $ly@@308) LayerTypeType)) (= (type |mapa#0@@33|) (IMapType BoxType BoxType))) (= (type |mapb#0@@33|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 |mapa#0@@33| |mapb#0@@33|) (and ($Is |mapa#0@@33| (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3)) ($Is |mapb#0@@33| (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3))))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 ($LS $ly@@308) |mapa#0@@33| |mapb#0@@33|) (|IMap#Glue| (|lambda#143| Maps._default.IMapUnionPreferB$U@@3 (|ISet#Union| (|IMap#Domain| |mapa#0@@33|) (|IMap#Domain| |mapb#0@@33|))) (|lambda#221| (|IMap#Domain| |mapb#0@@33|) (|IMap#Elements| |mapb#0@@33|) (|IMap#Elements| |mapa#0@@33|)) (TIMap Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3695|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@3 Maps._default.IMapUnionPreferB$T@@3 ($LS $ly@@308) |mapa#0@@33| |mapb#0@@33|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnionPreferB$U@@4 T@U) (Maps._default.IMapUnionPreferB$T@@4 T@U) ($ly@@309 T@U) (|mapa#0@@34| T@U) (|mapb#0@@34| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnionPreferB$U@@4) TyType) (= (type Maps._default.IMapUnionPreferB$T@@4) TyType)) (= (type $ly@@309) LayerTypeType)) (= (type |mapa#0@@34|) (IMapType BoxType BoxType))) (= (type |mapb#0@@34|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnionPreferB#canCall| Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)) (and ($Is |mapa#0@@34| (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4)) ($Is |mapb#0@@34| (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4))))) (= (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 ($LS $ly@@309) (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)) (|IMap#Glue| (|lambda#143| Maps._default.IMapUnionPreferB$U@@4 (|ISet#Union| (|IMap#Domain| (Lit |mapa#0@@34|)) (|IMap#Domain| (Lit |mapb#0@@34|)))) (|lambda#221| (|IMap#Domain| |mapb#0@@34|) (|IMap#Elements| (Lit |mapb#0@@34|)) (|IMap#Elements| (Lit |mapa#0@@34|))) (TIMap Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3696|
 :pattern ( (Maps.__default.IMapUnionPreferB Maps._default.IMapUnionPreferB$U@@4 Maps._default.IMapUnionPreferB$T@@4 ($LS $ly@@309) (Lit |mapa#0@@34|) (Lit |mapb#0@@34|)))
))))
(assert (forall ((arg0@@566 T@U) (arg1@@278 T@U) (arg2@@153 T@U) (arg3@@90 T@U) (arg4@@55 T@U) ) (! (= (type (Maps.__default.IMapUnion arg0@@566 arg1@@278 arg2@@153 arg3@@90 arg4@@55)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.IMapUnion|
 :pattern ( (Maps.__default.IMapUnion arg0@@566 arg1@@278 arg2@@153 arg3@@90 arg4@@55))
)))
(assert (forall ((Maps._default.IMapUnion$U T@U) (Maps._default.IMapUnion$T T@U) ($ly@@310 T@U) (|mapa#0@@35| T@U) (|mapb#0@@35| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnion$U) TyType) (= (type Maps._default.IMapUnion$T) TyType)) (= (type $ly@@310) LayerTypeType)) (= (type |mapa#0@@35|) (IMapType BoxType BoxType))) (= (type |mapb#0@@35|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T ($LS $ly@@310) |mapa#0@@35| |mapb#0@@35|) (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T $ly@@310 |mapa#0@@35| |mapb#0@@35|)))
 :qid |unknown.0:0|
 :skolemid |3697|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U Maps._default.IMapUnion$T ($LS $ly@@310) |mapa#0@@35| |mapb#0@@35|))
)))
(assert (forall ((Maps._default.IMapUnion$U@@0 T@U) (Maps._default.IMapUnion$T@@0 T@U) ($ly@@311 T@U) (|mapa#0@@36| T@U) (|mapb#0@@36| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.IMapUnion$U@@0) TyType) (= (type Maps._default.IMapUnion$T@@0) TyType)) (= (type $ly@@311) LayerTypeType)) (= (type |mapa#0@@36|) (IMapType BoxType BoxType))) (= (type |mapb#0@@36|) (IMapType BoxType BoxType))) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 $ly@@311 |mapa#0@@36| |mapb#0@@36|) (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 $LZ |mapa#0@@36| |mapb#0@@36|)))
 :qid |unknown.0:0|
 :skolemid |3698|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@0 Maps._default.IMapUnion$T@@0 (AsFuelBottom $ly@@311) |mapa#0@@36| |mapb#0@@36|))
)))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@1 T@U) (Maps._default.IMapUnion$T@@1 T@U) ($ly@@312 T@U) (|mapa#0@@37| T@U) (|mapb#0@@37| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@1) TyType) (= (type Maps._default.IMapUnion$T@@1) TyType)) (= (type $ly@@312) LayerTypeType)) (= (type |mapa#0@@37|) (IMapType BoxType BoxType))) (= (type |mapb#0@@37|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 |mapa#0@@37| |mapb#0@@37|) (and ($Is |mapa#0@@37| (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1)) ($Is |mapb#0@@37| (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1))))) (and (and (and (and (|ISet#Equal| (|IMap#Domain| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) (|ISet#Union| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|))) (forall ((|k#0@@63| T@U) ) (!  (=> (and (and (= (type |k#0@@63|) BoxType) ($IsBox |k#0@@63| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#0@@63|))) (= (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#0@@63|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#0@@63|)))
 :qid |Mapsidfy.193:18|
 :skolemid |3699|
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#0@@63|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#0@@63|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#0@@63|))
))) (forall ((|k#1@@8| T@U) ) (!  (=> (and (and (= (type |k#1@@8|) BoxType) ($IsBox |k#1@@8| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@37|) (|IMap#Domain| |mapa#0@@37|)) |k#1@@8|))) (= (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#1@@8|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#1@@8|)))
 :qid |Mapsidfy.194:18|
 :skolemid |3700|
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#1@@8|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#1@@8|))
 :pattern ( (MapType0Select (|ISet#Difference| (|IMap#Domain| |mapb#0@@37|) (|IMap#Domain| |mapa#0@@37|)) |k#1@@8|))
))) (forall ((|k#2@@4| T@U) ) (!  (=> (and (and (= (type |k#2@@4|) BoxType) ($IsBox |k#2@@4| Maps._default.IMapUnion$U@@1)) (U_2_bool (MapType0Select (|ISet#Intersection| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#2@@4|))) (or (= (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#2@@4|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|)) (= (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#2@@4|) (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|))))
 :qid |Mapsidfy.195:18|
 :skolemid |3701|
 :pattern ( (MapType0Select (|IMap#Elements| |mapa#0@@37|) |k#2@@4|))
 :pattern ( (MapType0Select (|IMap#Elements| (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|)) |k#2@@4|))
 :pattern ( (MapType0Select (|IMap#Elements| |mapb#0@@37|) |k#2@@4|))
 :pattern ( (MapType0Select (|ISet#Intersection| (|IMap#Domain| |mapa#0@@37|) (|IMap#Domain| |mapb#0@@37|)) |k#2@@4|))
))) ($Is (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|) (TIMap Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3702|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@1 Maps._default.IMapUnion$T@@1 $ly@@312 |mapa#0@@37| |mapb#0@@37|))
))))
(assert (forall ((Maps._default.IMapUnion$U@@2 T@U) (Maps._default.IMapUnion$T@@2 T@U) ($ly@@313 T@U) (|mapa#0@@38| T@U) (|mapb#0@@38| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@2) TyType) (= (type Maps._default.IMapUnion$T@@2) TyType)) (= (type $ly@@313) LayerTypeType)) (= (type |mapa#0@@38|) (IMapType BoxType BoxType))) (= (type |mapb#0@@38|) (IMapType BoxType BoxType))) (and ($Is |mapa#0@@38| (TIMap Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2)) ($Is |mapb#0@@38| (TIMap Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2)))) (= (|Maps.__default.IMapUnion#requires| Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2 $ly@@313 |mapa#0@@38| |mapb#0@@38|) true))
 :qid |unknown.0:0|
 :skolemid |3703|
 :pattern ( (|Maps.__default.IMapUnion#requires| Maps._default.IMapUnion$U@@2 Maps._default.IMapUnion$T@@2 $ly@@313 |mapa#0@@38| |mapb#0@@38|))
)))
(assert (= (type StartFuel_Maps._default.IMapUnionPreferA) LayerTypeType))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@3 T@U) (Maps._default.IMapUnion$T@@3 T@U) ($ly@@314 T@U) (|mapa#0@@39| T@U) (|mapb#0@@39| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@3) TyType) (= (type Maps._default.IMapUnion$T@@3) TyType)) (= (type $ly@@314) LayerTypeType)) (= (type |mapa#0@@39|) (IMapType BoxType BoxType))) (= (type |mapb#0@@39|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 |mapa#0@@39| |mapb#0@@39|) (and ($Is |mapa#0@@39| (TIMap Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3)) ($Is |mapb#0@@39| (TIMap Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3))))) (and (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 |mapa#0@@39| |mapb#0@@39|) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 ($LS $ly@@314) |mapa#0@@39| |mapb#0@@39|) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 StartFuel_Maps._default.IMapUnionPreferA |mapa#0@@39| |mapb#0@@39|))))
 :qid |unknown.0:0|
 :skolemid |3704|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@3 Maps._default.IMapUnion$T@@3 ($LS $ly@@314) |mapa#0@@39| |mapb#0@@39|))
))))
(assert  (=> true (forall ((Maps._default.IMapUnion$U@@4 T@U) (Maps._default.IMapUnion$T@@4 T@U) ($ly@@315 T@U) (|mapa#0@@40| T@U) (|mapb#0@@40| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.IMapUnion$U@@4) TyType) (= (type Maps._default.IMapUnion$T@@4) TyType)) (= (type $ly@@315) LayerTypeType)) (= (type |mapa#0@@40|) (IMapType BoxType BoxType))) (= (type |mapb#0@@40|) (IMapType BoxType BoxType))) (or (|Maps.__default.IMapUnion#canCall| Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (and ($Is |mapa#0@@40| (TIMap Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4)) ($Is |mapb#0@@40| (TIMap Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4))))) (and (|Maps.__default.IMapUnionPreferA#canCall| Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (= (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 ($LS $ly@@315) (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)) (Maps.__default.IMapUnionPreferA Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 StartFuel_Maps._default.IMapUnionPreferA (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3705|
 :pattern ( (Maps.__default.IMapUnion Maps._default.IMapUnion$U@@4 Maps._default.IMapUnion$T@@4 ($LS $ly@@315) (Lit |mapa#0@@40|) (Lit |mapb#0@@40|)))
))))
(assert (forall ((arg0@@567 T@U) (arg1@@279 T@U) (arg2@@154 T@U) (arg3@@91 T@U) (arg4@@56 T@U) (arg5@@21 T@U) ) (! (= (type (Maps.__default.MapDisjointUnion3 arg0@@567 arg1@@279 arg2@@154 arg3@@91 arg4@@56 arg5@@21)) (MapType BoxType BoxType))
 :qid |funType:Maps.__default.MapDisjointUnion3|
 :pattern ( (Maps.__default.MapDisjointUnion3 arg0@@567 arg1@@279 arg2@@154 arg3@@91 arg4@@56 arg5@@21))
)))
(assert (forall ((Maps._default.MapDisjointUnion3$U T@U) (Maps._default.MapDisjointUnion3$T T@U) ($ly@@316 T@U) (|mapa#0@@41| T@U) (|mapb#0@@41| T@U) (|mapc#0| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U) TyType) (= (type Maps._default.MapDisjointUnion3$T) TyType)) (= (type $ly@@316) LayerTypeType)) (= (type |mapa#0@@41|) (MapType BoxType BoxType))) (= (type |mapb#0@@41|) (MapType BoxType BoxType))) (= (type |mapc#0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T ($LS $ly@@316) |mapa#0@@41| |mapb#0@@41| |mapc#0|) (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T $ly@@316 |mapa#0@@41| |mapb#0@@41| |mapc#0|)))
 :qid |unknown.0:0|
 :skolemid |3706|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U Maps._default.MapDisjointUnion3$T ($LS $ly@@316) |mapa#0@@41| |mapb#0@@41| |mapc#0|))
)))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@0 T@U) (Maps._default.MapDisjointUnion3$T@@0 T@U) ($ly@@317 T@U) (|mapa#0@@42| T@U) (|mapb#0@@42| T@U) (|mapc#0@@0| T@U) ) (!  (=> (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@0) TyType) (= (type Maps._default.MapDisjointUnion3$T@@0) TyType)) (= (type $ly@@317) LayerTypeType)) (= (type |mapa#0@@42|) (MapType BoxType BoxType))) (= (type |mapb#0@@42|) (MapType BoxType BoxType))) (= (type |mapc#0@@0|) (MapType BoxType BoxType))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 $ly@@317 |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|) (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 $LZ |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|)))
 :qid |unknown.0:0|
 :skolemid |3707|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@0 Maps._default.MapDisjointUnion3$T@@0 (AsFuelBottom $ly@@317) |mapa#0@@42| |mapb#0@@42| |mapc#0@@0|))
)))
(assert (= (type StartFuel_Maps._default.MapDisjointUnion) LayerTypeType))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@1 T@U) (Maps._default.MapDisjointUnion3$T@@1 T@U) ($ly@@318 T@U) (|mapa#0@@43| T@U) (|mapb#0@@43| T@U) (|mapc#0@@1| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@1) TyType) (= (type Maps._default.MapDisjointUnion3$T@@1) TyType)) (= (type $ly@@318) LayerTypeType)) (= (type |mapa#0@@43|) (MapType BoxType BoxType))) (= (type |mapb#0@@43|) (MapType BoxType BoxType))) (= (type |mapc#0@@1|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (and (and (and ($Is |mapa#0@@43| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1)) ($Is |mapb#0@@43| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))) ($Is |mapc#0@@1| (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))) (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Map#Domain| |mapc#0@@1|)))))) (and (and (and (and (and (and (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@43|) (|Map#Domain| |mapb#0@@43|)) (|Map#Domain| |mapc#0@@1|))) (=> (or (or (not (|Set#Equal| (|Map#Domain| |mapa#0@@43|) (|Set#Empty| BoxType))) (not (|Set#Equal| (|Map#Domain| |mapb#0@@43|) (|Set#Empty| BoxType)))) (not (|Set#Equal| (|Map#Domain| |mapc#0@@1|) (|Set#Empty| BoxType)))) (not (|Set#Equal| (|Map#Domain| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) (|Set#Empty| BoxType))))) (forall ((|k#0@@64| T@U) ) (!  (=> (and (and (= (type |k#0@@64|) BoxType) ($IsBox |k#0@@64| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapa#0@@43|) |k#0@@64|))) (= (MapType0Select (|Map#Elements| |mapa#0@@43|) |k#0@@64|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#0@@64|)))
 :qid |Mapsidfy.205:18|
 :skolemid |3708|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#0@@64|))
 :pattern ( (MapType0Select (|Map#Elements| |mapa#0@@43|) |k#0@@64|))
 :pattern ( (MapType0Select (|Map#Domain| |mapa#0@@43|) |k#0@@64|))
))) (forall ((|k#1@@9| T@U) ) (!  (=> (and (and (= (type |k#1@@9|) BoxType) ($IsBox |k#1@@9| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapb#0@@43|) |k#1@@9|))) (= (MapType0Select (|Map#Elements| |mapb#0@@43|) |k#1@@9|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#1@@9|)))
 :qid |Mapsidfy.206:18|
 :skolemid |3709|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#1@@9|))
 :pattern ( (MapType0Select (|Map#Elements| |mapb#0@@43|) |k#1@@9|))
 :pattern ( (MapType0Select (|Map#Domain| |mapb#0@@43|) |k#1@@9|))
))) (forall ((|k#2@@5| T@U) ) (!  (=> (and (and (= (type |k#2@@5|) BoxType) ($IsBox |k#2@@5| Maps._default.MapDisjointUnion3$U@@1)) (U_2_bool (MapType0Select (|Map#Domain| |mapc#0@@1|) |k#2@@5|))) (= (MapType0Select (|Map#Elements| |mapc#0@@1|) |k#2@@5|) (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#2@@5|)))
 :qid |Mapsidfy.207:18|
 :skolemid |3710|
 :pattern ( (MapType0Select (|Map#Elements| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|)) |k#2@@5|))
 :pattern ( (MapType0Select (|Map#Elements| |mapc#0@@1|) |k#2@@5|))
 :pattern ( (MapType0Select (|Map#Domain| |mapc#0@@1|) |k#2@@5|))
))) (and (|Map#Equal| (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapb#0@@43| |mapc#0@@1|))) (|Map#Equal| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapb#0@@43| |mapc#0@@1|)) (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion (Maps.__default.MapDisjointUnion Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 StartFuel_Maps._default.MapDisjointUnion |mapa#0@@43| |mapb#0@@43|) |mapc#0@@1|)))) ($Is (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|) (TMap Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1))))
 :qid |unknown.0:0|
 :skolemid |3711|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@1 Maps._default.MapDisjointUnion3$T@@1 $ly@@318 |mapa#0@@43| |mapb#0@@43| |mapc#0@@1|))
))))
(assert (forall ((Maps._default.MapDisjointUnion3$U@@2 T@U) (Maps._default.MapDisjointUnion3$T@@2 T@U) ($ly@@319 T@U) (|mapa#0@@44| T@U) (|mapb#0@@44| T@U) (|mapc#0@@2| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@2) TyType) (= (type Maps._default.MapDisjointUnion3$T@@2) TyType)) (= (type $ly@@319) LayerTypeType)) (= (type |mapa#0@@44|) (MapType BoxType BoxType))) (= (type |mapb#0@@44|) (MapType BoxType BoxType))) (= (type |mapc#0@@2|) (MapType BoxType BoxType))) (and (and ($Is |mapa#0@@44| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2)) ($Is |mapb#0@@44| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2))) ($Is |mapc#0@@2| (TMap Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2)))) (= (|Maps.__default.MapDisjointUnion3#requires| Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2 $ly@@319 |mapa#0@@44| |mapb#0@@44| |mapc#0@@2|)  (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@44|) (|Map#Domain| |mapb#0@@44|)) (|Map#Domain| |mapc#0@@2|)))))
 :qid |unknown.0:0|
 :skolemid |3712|
 :pattern ( (|Maps.__default.MapDisjointUnion3#requires| Maps._default.MapDisjointUnion3$U@@2 Maps._default.MapDisjointUnion3$T@@2 $ly@@319 |mapa#0@@44| |mapb#0@@44| |mapc#0@@2|))
)))
(assert (forall ((arg0@@568 T@U) (arg1@@280 T@U) (arg2@@155 T@U) (arg3@@92 T@U) (arg4@@57 T@U) ) (! (= (type (|lambda#241| arg0@@568 arg1@@280 arg2@@155 arg3@@92 arg4@@57)) (MapType0Type BoxType BoxType))
 :qid |funType:lambda#241|
 :pattern ( (|lambda#241| arg0@@568 arg1@@280 arg2@@155 arg3@@92 arg4@@57))
)))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@3 T@U) (Maps._default.MapDisjointUnion3$T@@3 T@U) ($ly@@320 T@U) (|mapa#0@@45| T@U) (|mapb#0@@45| T@U) (|mapc#0@@3| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@3) TyType) (= (type Maps._default.MapDisjointUnion3$T@@3) TyType)) (= (type $ly@@320) LayerTypeType)) (= (type |mapa#0@@45|) (MapType BoxType BoxType))) (= (type |mapb#0@@45|) (MapType BoxType BoxType))) (= (type |mapc#0@@3|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|) (and (and (and ($Is |mapa#0@@45| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3)) ($Is |mapb#0@@45| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))) ($Is |mapc#0@@3| (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))) (and (and (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Set#Disjoint| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Map#Domain| |mapc#0@@3|)))))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 ($LS $ly@@320) |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|) (|Map#Glue| (|lambda#143| Maps._default.MapDisjointUnion3$U@@3 (|Set#Union| (|Set#Union| (|Map#Domain| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|)) (|Map#Domain| |mapc#0@@3|))) (|lambda#241| (|Map#Domain| |mapa#0@@45|) (|Map#Elements| |mapa#0@@45|) (|Map#Domain| |mapb#0@@45|) (|Map#Elements| |mapb#0@@45|) (|Map#Elements| |mapc#0@@3|)) (TMap Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3))))
 :qid |unknown.0:0|
 :skolemid |3713|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@3 Maps._default.MapDisjointUnion3$T@@3 ($LS $ly@@320) |mapa#0@@45| |mapb#0@@45| |mapc#0@@3|))
))))
(assert  (=> true (forall ((Maps._default.MapDisjointUnion3$U@@4 T@U) (Maps._default.MapDisjointUnion3$T@@4 T@U) ($ly@@321 T@U) (|mapa#0@@46| T@U) (|mapb#0@@46| T@U) (|mapc#0@@4| T@U) ) (!  (=> (and (and (and (and (and (and (= (type Maps._default.MapDisjointUnion3$U@@4) TyType) (= (type Maps._default.MapDisjointUnion3$T@@4) TyType)) (= (type $ly@@321) LayerTypeType)) (= (type |mapa#0@@46|) (MapType BoxType BoxType))) (= (type |mapb#0@@46|) (MapType BoxType BoxType))) (= (type |mapc#0@@4|) (MapType BoxType BoxType))) (or (|Maps.__default.MapDisjointUnion3#canCall| Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)) (and (and (and ($Is |mapa#0@@46| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4)) ($Is |mapb#0@@46| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))) ($Is |mapc#0@@4| (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))) (and (and (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Set#Disjoint| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|)))) (|Set#Disjoint| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Map#Domain| (Lit |mapc#0@@4|))))))) (= (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 ($LS $ly@@321) (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)) (|Map#Glue| (|lambda#143| Maps._default.MapDisjointUnion3$U@@4 (|Set#Union| (|Set#Union| (|Map#Domain| (Lit |mapa#0@@46|)) (|Map#Domain| (Lit |mapb#0@@46|))) (|Map#Domain| (Lit |mapc#0@@4|)))) (|lambda#241| (|Map#Domain| |mapa#0@@46|) (|Map#Elements| (Lit |mapa#0@@46|)) (|Map#Domain| |mapb#0@@46|) (|Map#Elements| (Lit |mapb#0@@46|)) (|Map#Elements| (Lit |mapc#0@@4|))) (TMap Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3714|
 :pattern ( (Maps.__default.MapDisjointUnion3 Maps._default.MapDisjointUnion3$U@@4 Maps._default.MapDisjointUnion3$T@@4 ($LS $ly@@321) (Lit |mapa#0@@46|) (Lit |mapb#0@@46|) (Lit |mapc#0@@4|)))
))))
(assert (forall ((arg0@@569 T@U) (arg1@@281 T@U) (arg2@@156 T@U) ) (! (= (type (Maps.__default.MapToImap arg0@@569 arg1@@281 arg2@@156)) (IMapType BoxType BoxType))
 :qid |funType:Maps.__default.MapToImap|
 :pattern ( (Maps.__default.MapToImap arg0@@569 arg1@@281 arg2@@156))
)))
(assert  (=> true (forall ((Maps._default.MapToImap$K T@U) (Maps._default.MapToImap$V T@U) (|m#0@@97| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K) TyType) (= (type Maps._default.MapToImap$V) TyType)) (= (type |m#0@@97|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|) ($Is |m#0@@97| (TMap Maps._default.MapToImap$K Maps._default.MapToImap$V)))) ($Is (Maps.__default.MapToImap Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|) (TIMap Maps._default.MapToImap$K Maps._default.MapToImap$V)))
 :qid |unknown.0:0|
 :skolemid |3715|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K Maps._default.MapToImap$V |m#0@@97|))
))))
(assert (forall ((Maps._default.MapToImap$K@@0 T@U) (Maps._default.MapToImap$V@@0 T@U) (|m#0@@98| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@0) TyType) (= (type Maps._default.MapToImap$V@@0) TyType)) (= (type |m#0@@98|) (MapType BoxType BoxType))) ($Is |m#0@@98| (TMap Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0))) (= (|Maps.__default.MapToImap#requires| Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0 |m#0@@98|) true))
 :qid |unknown.0:0|
 :skolemid |3716|
 :pattern ( (|Maps.__default.MapToImap#requires| Maps._default.MapToImap$K@@0 Maps._default.MapToImap$V@@0 |m#0@@98|))
)))
(assert  (=> true (forall ((Maps._default.MapToImap$K@@1 T@U) (Maps._default.MapToImap$V@@1 T@U) (|m#0@@99| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@1) TyType) (= (type Maps._default.MapToImap$V@@1) TyType)) (= (type |m#0@@99|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|) ($Is |m#0@@99| (TMap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1)))) (= (Maps.__default.MapToImap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|) (|IMap#Glue| (|lambda#143| Maps._default.MapToImap$K@@1 (|Map#Domain| |m#0@@99|)) (|lambda#185| (|Map#Elements| |m#0@@99|)) (TIMap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1))))
 :qid |unknown.0:0|
 :skolemid |3717|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K@@1 Maps._default.MapToImap$V@@1 |m#0@@99|))
))))
(assert  (=> true (forall ((Maps._default.MapToImap$K@@2 T@U) (Maps._default.MapToImap$V@@2 T@U) (|m#0@@100| T@U) ) (!  (=> (and (and (and (= (type Maps._default.MapToImap$K@@2) TyType) (= (type Maps._default.MapToImap$V@@2) TyType)) (= (type |m#0@@100|) (MapType BoxType BoxType))) (or (|Maps.__default.MapToImap#canCall| Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)) ($Is |m#0@@100| (TMap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2)))) (= (Maps.__default.MapToImap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)) (|IMap#Glue| (|lambda#143| Maps._default.MapToImap$K@@2 (|Map#Domain| |m#0@@100|)) (|lambda#185| (|Map#Elements| (Lit |m#0@@100|))) (TIMap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3718|
 :pattern ( (Maps.__default.MapToImap Maps._default.MapToImap$K@@2 Maps._default.MapToImap$V@@2 (Lit |m#0@@100|)))
))))
(assert (forall ((arg0@@570 T@U) (arg1@@282 T@U) (arg2@@157 T@U) (arg3@@93 T@U) ) (! (= (type (Maps.__default.MapLookupOption arg0@@570 arg1@@282 arg2@@157 arg3@@93)) DatatypeTypeType)
 :qid |funType:Maps.__default.MapLookupOption|
 :pattern ( (Maps.__default.MapLookupOption arg0@@570 arg1@@282 arg2@@157 arg3@@93))
)))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K T@U) (Maps._default.MapLookupOption$V T@U) (|m#0@@101| T@U) (|key#0@@18| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K) TyType) (= (type Maps._default.MapLookupOption$V) TyType)) (= (type |m#0@@101|) (MapType BoxType BoxType))) (= (type |key#0@@18|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@18|) (and ($Is |m#0@@101| (TMap Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V)) ($IsBox |key#0@@18| Maps._default.MapLookupOption$K)))) ($Is (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@18|) (Tclass.Options.Option Maps._default.MapLookupOption$V)))
 :qid |unknown.0:0|
 :skolemid |3719|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K Maps._default.MapLookupOption$V |m#0@@101| |key#0@@18|))
))))
(assert (forall ((Maps._default.MapLookupOption$K@@0 T@U) (Maps._default.MapLookupOption$V@@0 T@U) (|m#0@@102| T@U) (|key#0@@19| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@0) TyType) (= (type Maps._default.MapLookupOption$V@@0) TyType)) (= (type |m#0@@102|) (MapType BoxType BoxType))) (= (type |key#0@@19|) BoxType)) (and ($Is |m#0@@102| (TMap Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0)) ($IsBox |key#0@@19| Maps._default.MapLookupOption$K@@0))) (= (|Maps.__default.MapLookupOption#requires| Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0 |m#0@@102| |key#0@@19|) true))
 :qid |unknown.0:0|
 :skolemid |3720|
 :pattern ( (|Maps.__default.MapLookupOption#requires| Maps._default.MapLookupOption$K@@0 Maps._default.MapLookupOption$V@@0 |m#0@@102| |key#0@@19|))
)))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@1 T@U) (Maps._default.MapLookupOption$V@@1 T@U) (|m#0@@103| T@U) (|key#0@@20| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@1) TyType) (= (type Maps._default.MapLookupOption$V@@1) TyType)) (= (type |m#0@@103|) (MapType BoxType BoxType))) (= (type |key#0@@20|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@20|) (and ($Is |m#0@@103| (TMap Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1)) ($IsBox |key#0@@20| Maps._default.MapLookupOption$K@@1)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@20|) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@103|) |key#0@@20|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| |m#0@@103|) |key#0@@20|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |3721|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@1 Maps._default.MapLookupOption$V@@1 |m#0@@103| |key#0@@20|))
))))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@2 T@U) (Maps._default.MapLookupOption$V@@2 T@U) (|m#0@@104| T@U) (|key#0@@21| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@2) TyType) (= (type Maps._default.MapLookupOption$V@@2) TyType)) (= (type |m#0@@104|) (MapType BoxType BoxType))) (= (type |key#0@@21|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@21|) (and ($Is |m#0@@104| (TMap Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2)) ($IsBox |key#0@@21| Maps._default.MapLookupOption$K@@2)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@21|) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@104|) |key#0@@21|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| (Lit |m#0@@104|)) |key#0@@21|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3722|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@2 Maps._default.MapLookupOption$V@@2 (Lit |m#0@@104|) |key#0@@21|))
))))
(assert  (=> true (forall ((Maps._default.MapLookupOption$K@@3 T@U) (Maps._default.MapLookupOption$V@@3 T@U) (|m#0@@105| T@U) (|key#0@@22| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.MapLookupOption$K@@3) TyType) (= (type Maps._default.MapLookupOption$V@@3) TyType)) (= (type |m#0@@105|) (MapType BoxType BoxType))) (= (type |key#0@@22|) BoxType)) (or (|Maps.__default.MapLookupOption#canCall| Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@22|)) (and ($Is |m#0@@105| (TMap Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3)) ($IsBox |key#0@@22| Maps._default.MapLookupOption$K@@3)))) (= (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@22|)) (ite (U_2_bool (MapType0Select (|Map#Domain| |m#0@@105|) |key#0@@22|)) (|#Options.Option.Some| (MapType0Select (|Map#Elements| (Lit |m#0@@105|)) (Lit |key#0@@22|))) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3723|
 :pattern ( (Maps.__default.MapLookupOption Maps._default.MapLookupOption$K@@3 Maps._default.MapLookupOption$V@@3 (Lit |m#0@@105|) (Lit |key#0@@22|)))
))))
(assert (forall ((arg0@@571 T@U) (arg1@@283 T@U) (arg2@@158 T@U) (arg3@@94 T@U) ) (! (= (type (Maps.__default.ImapLookupOption arg0@@571 arg1@@283 arg2@@158 arg3@@94)) DatatypeTypeType)
 :qid |funType:Maps.__default.ImapLookupOption|
 :pattern ( (Maps.__default.ImapLookupOption arg0@@571 arg1@@283 arg2@@158 arg3@@94))
)))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K T@U) (Maps._default.ImapLookupOption$V T@U) (|m#0@@106| T@U) (|key#0@@23| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K) TyType) (= (type Maps._default.ImapLookupOption$V) TyType)) (= (type |m#0@@106|) (IMapType BoxType BoxType))) (= (type |key#0@@23|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@23|) (and ($Is |m#0@@106| (TIMap Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V)) ($IsBox |key#0@@23| Maps._default.ImapLookupOption$K)))) ($Is (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@23|) (Tclass.Options.Option Maps._default.ImapLookupOption$V)))
 :qid |unknown.0:0|
 :skolemid |3724|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K Maps._default.ImapLookupOption$V |m#0@@106| |key#0@@23|))
))))
(assert (forall ((Maps._default.ImapLookupOption$K@@0 T@U) (Maps._default.ImapLookupOption$V@@0 T@U) (|m#0@@107| T@U) (|key#0@@24| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@0) TyType) (= (type Maps._default.ImapLookupOption$V@@0) TyType)) (= (type |m#0@@107|) (IMapType BoxType BoxType))) (= (type |key#0@@24|) BoxType)) (and ($Is |m#0@@107| (TIMap Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0)) ($IsBox |key#0@@24| Maps._default.ImapLookupOption$K@@0))) (= (|Maps.__default.ImapLookupOption#requires| Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0 |m#0@@107| |key#0@@24|) true))
 :qid |unknown.0:0|
 :skolemid |3725|
 :pattern ( (|Maps.__default.ImapLookupOption#requires| Maps._default.ImapLookupOption$K@@0 Maps._default.ImapLookupOption$V@@0 |m#0@@107| |key#0@@24|))
)))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K@@1 T@U) (Maps._default.ImapLookupOption$V@@1 T@U) (|m#0@@108| T@U) (|key#0@@25| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@1) TyType) (= (type Maps._default.ImapLookupOption$V@@1) TyType)) (= (type |m#0@@108|) (IMapType BoxType BoxType))) (= (type |key#0@@25|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@25|) (and ($Is |m#0@@108| (TIMap Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1)) ($IsBox |key#0@@25| Maps._default.ImapLookupOption$K@@1)))) (= (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@25|) (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@108|) |key#0@@25|)) (|#Options.Option.Some| (MapType0Select (|IMap#Elements| |m#0@@108|) |key#0@@25|)) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :skolemid |3726|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@1 Maps._default.ImapLookupOption$V@@1 |m#0@@108| |key#0@@25|))
))))
(assert  (=> true (forall ((Maps._default.ImapLookupOption$K@@2 T@U) (Maps._default.ImapLookupOption$V@@2 T@U) (|m#0@@109| T@U) (|key#0@@26| T@U) ) (!  (=> (and (and (and (and (= (type Maps._default.ImapLookupOption$K@@2) TyType) (= (type Maps._default.ImapLookupOption$V@@2) TyType)) (= (type |m#0@@109|) (IMapType BoxType BoxType))) (= (type |key#0@@26|) BoxType)) (or (|Maps.__default.ImapLookupOption#canCall| Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@26|)) (and ($Is |m#0@@109| (TIMap Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2)) ($IsBox |key#0@@26| Maps._default.ImapLookupOption$K@@2)))) (= (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@26|)) (ite (U_2_bool (MapType0Select (|IMap#Domain| |m#0@@109|) |key#0@@26|)) (|#Options.Option.Some| (MapType0Select (|IMap#Elements| (Lit |m#0@@109|)) (Lit |key#0@@26|))) |#Options.Option.None|)))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |3727|
 :pattern ( (Maps.__default.ImapLookupOption Maps._default.ImapLookupOption$K@@2 Maps._default.ImapLookupOption$V@@2 (Lit |m#0@@109|) (Lit |key#0@@26|)))
))))
(assert (forall ((arg0@@572 T@U) (arg1@@284 T@U) ) (! (= (type (|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@572 arg1@@284)) DatatypeTypeType)
 :qid |funType:#MsgHistoryMod.KeyedMessage.KeyedMessage|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| arg0@@572 arg1@@284))
)))
(assert (forall ((|a#0#0#0@@7| T@U) (|a#0#1#0@@5| T@U) ) (!  (=> (and (= (type |a#0#0#0@@7|) (SeqType BoxType)) (= (type |a#0#1#0@@5|) DatatypeTypeType)) (= (DatatypeCtorId (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#0#0#0@@7| |a#0#1#0@@5|)) |##MsgHistoryMod.KeyedMessage.KeyedMessage|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3728|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#0#0#0@@7| |a#0#1#0@@5|))
)))
(assert (forall ((d@@123 T@U) ) (!  (=> (= (type d@@123) DatatypeTypeType) (= (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@123) (= (DatatypeCtorId d@@123) |##MsgHistoryMod.KeyedMessage.KeyedMessage|)))
 :qid |unknown.0:0|
 :skolemid |3729|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@123))
)))
(assert (forall ((d@@124 T@U) ) (!  (=> (and (= (type d@@124) DatatypeTypeType) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@124)) (exists ((|a#1#0#0@@7| T@U) (|a#1#1#0@@5| T@U) ) (!  (and (and (= (type |a#1#0#0@@7|) (SeqType BoxType)) (= (type |a#1#1#0@@5|) DatatypeTypeType)) (= d@@124 (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#1#0#0@@7| |a#1#1#0@@5|)))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3730|
 :no-pattern (type |a#1#0#0@@7|)
 :no-pattern (type |a#1#1#0@@5|)
 :no-pattern (U_2_int |a#1#0#0@@7|)
 :no-pattern (U_2_bool |a#1#0#0@@7|)
 :no-pattern (U_2_int |a#1#1#0@@5|)
 :no-pattern (U_2_bool |a#1#1#0@@5|)
)))
 :qid |unknown.0:0|
 :skolemid |3731|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@124))
)))
(assert (= (type Tclass.MsgHistoryMod.KeyedMessage) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.KeyedMessage) Tagclass.MsgHistoryMod.KeyedMessage))
(assert (= (TagFamily Tclass.MsgHistoryMod.KeyedMessage) tytagFamily$KeyedMessage))
(assert (forall ((bx@@155 T@U) ) (!  (=> (and (= (type bx@@155) BoxType) ($IsBox bx@@155 Tclass.MsgHistoryMod.KeyedMessage)) (and (= ($Box ($Unbox DatatypeTypeType bx@@155)) bx@@155) ($Is ($Unbox DatatypeTypeType bx@@155) Tclass.MsgHistoryMod.KeyedMessage)))
 :qid |unknown.0:0|
 :skolemid |3732|
 :pattern ( ($IsBox bx@@155 Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((|a#2#0#0@@7| T@U) (|a#2#1#0@@5| T@U) ) (!  (=> (and (= (type |a#2#0#0@@7|) (SeqType BoxType)) (= (type |a#2#1#0@@5|) DatatypeTypeType)) (= ($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#2#0#0@@7| |a#2#1#0@@5|) Tclass.MsgHistoryMod.KeyedMessage)  (and ($Is |a#2#0#0@@7| Tclass.KeyType.Key) ($Is |a#2#1#0@@5| Tclass.ValueMessage.Message))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3733|
 :pattern ( ($Is (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#2#0#0@@7| |a#2#1#0@@5|) Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((|a#3#0#0@@7| T@U) (|a#3#1#0@@5| T@U) ($h@@140 T@U) ) (!  (=> (and (and (and (= (type |a#3#0#0@@7|) (SeqType BoxType)) (= (type |a#3#1#0@@5|) DatatypeTypeType)) (= (type $h@@140) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@140)) (= ($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#3#0#0@@7| |a#3#1#0@@5|) Tclass.MsgHistoryMod.KeyedMessage $h@@140)  (and ($IsAlloc |a#3#0#0@@7| Tclass.KeyType.Key $h@@140) ($IsAlloc |a#3#1#0@@5| Tclass.ValueMessage.Message $h@@140))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3734|
 :pattern ( ($IsAlloc (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#3#0#0@@7| |a#3#1#0@@5|) Tclass.MsgHistoryMod.KeyedMessage $h@@140))
)))
(assert (forall ((arg0@@573 T@U) ) (! (= (type (MsgHistoryMod.KeyedMessage.key arg0@@573)) (SeqType BoxType))
 :qid |funType:MsgHistoryMod.KeyedMessage.key|
 :pattern ( (MsgHistoryMod.KeyedMessage.key arg0@@573))
)))
(assert (forall ((d@@125 T@U) ($h@@141 T@U) ) (!  (=> (and (and (= (type d@@125) DatatypeTypeType) (= (type $h@@141) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@141) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@125) ($IsAlloc d@@125 Tclass.MsgHistoryMod.KeyedMessage $h@@141)))) ($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@125) Tclass.KeyType.Key $h@@141))
 :qid |unknown.0:0|
 :skolemid |3735|
 :pattern ( ($IsAlloc (MsgHistoryMod.KeyedMessage.key d@@125) Tclass.KeyType.Key $h@@141))
)))
(assert (forall ((arg0@@574 T@U) ) (! (= (type (MsgHistoryMod.KeyedMessage.message arg0@@574)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.KeyedMessage.message|
 :pattern ( (MsgHistoryMod.KeyedMessage.message arg0@@574))
)))
(assert (forall ((d@@126 T@U) ($h@@142 T@U) ) (!  (=> (and (and (= (type d@@126) DatatypeTypeType) (= (type $h@@142) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@142) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@126) ($IsAlloc d@@126 Tclass.MsgHistoryMod.KeyedMessage $h@@142)))) ($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@126) Tclass.ValueMessage.Message $h@@142))
 :qid |unknown.0:0|
 :skolemid |3736|
 :pattern ( ($IsAlloc (MsgHistoryMod.KeyedMessage.message d@@126) Tclass.ValueMessage.Message $h@@142))
)))
(assert (forall ((|a#4#0#0@@7| T@U) (|a#4#1#0@@5| T@U) ) (!  (=> (and (= (type |a#4#0#0@@7|) (SeqType BoxType)) (= (type |a#4#1#0@@5|) DatatypeTypeType)) (= (|#MsgHistoryMod.KeyedMessage.KeyedMessage| (Lit |a#4#0#0@@7|) (Lit |a#4#1#0@@5|)) (Lit (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#4#0#0@@7| |a#4#1#0@@5|))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3737|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| (Lit |a#4#0#0@@7|) (Lit |a#4#1#0@@5|)))
)))
(assert (forall ((|a#5#0#0@@8| T@U) (|a#5#1#0@@5| T@U) ) (!  (=> (and (= (type |a#5#0#0@@8|) (SeqType BoxType)) (= (type |a#5#1#0@@5|) DatatypeTypeType)) (= (MsgHistoryMod.KeyedMessage.key (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#5#0#0@@8| |a#5#1#0@@5|)) |a#5#0#0@@8|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3738|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#5#0#0@@8| |a#5#1#0@@5|))
)))
(assert (forall ((|a#6#0#0@@8| T@U) (|a#6#1#0@@5| T@U) ) (!  (=> (and (= (type |a#6#0#0@@8|) (SeqType BoxType)) (= (type |a#6#1#0@@5|) DatatypeTypeType)) (= (MsgHistoryMod.KeyedMessage.message (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#6#0#0@@8| |a#6#1#0@@5|)) |a#6#1#0@@5|))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3739|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#6#0#0@@8| |a#6#1#0@@5|))
)))
(assert (forall ((|a#7#0#0@@7| T@U) (|a#7#1#0@@5| T@U) ) (!  (=> (and (= (type |a#7#0#0@@7|) (SeqType BoxType)) (= (type |a#7#1#0@@5|) DatatypeTypeType)) (< (DtRank |a#7#1#0@@5|) (DtRank (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#7#0#0@@7| |a#7#1#0@@5|))))
 :qid |MsgHistoryidfy.25:40|
 :skolemid |3740|
 :pattern ( (|#MsgHistoryMod.KeyedMessage.KeyedMessage| |a#7#0#0@@7| |a#7#1#0@@5|))
)))
(assert (forall ((d@@127 T@U) ) (!  (=> (and (= (type d@@127) DatatypeTypeType) (|$IsA#MsgHistoryMod.KeyedMessage| d@@127)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@127))
 :qid |unknown.0:0|
 :skolemid |3741|
 :pattern ( (|$IsA#MsgHistoryMod.KeyedMessage| d@@127))
)))
(assert (forall ((d@@128 T@U) ) (!  (=> (and (= (type d@@128) DatatypeTypeType) ($Is d@@128 Tclass.MsgHistoryMod.KeyedMessage)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@128))
 :qid |unknown.0:0|
 :skolemid |3742|
 :pattern ( (MsgHistoryMod.KeyedMessage.KeyedMessage_q d@@128) ($Is d@@128 Tclass.MsgHistoryMod.KeyedMessage))
)))
(assert (forall ((a@@156 T@U) (b@@106 T@U) ) (!  (=> (and (and (= (type a@@156) DatatypeTypeType) (= (type b@@106) DatatypeTypeType)) true) (= (|MsgHistoryMod.KeyedMessage#Equal| a@@156 b@@106)  (and (|Seq#Equal| (MsgHistoryMod.KeyedMessage.key a@@156) (MsgHistoryMod.KeyedMessage.key b@@106)) (|ValueMessage.Message#Equal| (MsgHistoryMod.KeyedMessage.message a@@156) (MsgHistoryMod.KeyedMessage.message b@@106)))))
 :qid |unknown.0:0|
 :skolemid |3743|
 :pattern ( (|MsgHistoryMod.KeyedMessage#Equal| a@@156 b@@106))
)))
(assert (forall ((a@@157 T@U) (b@@107 T@U) ) (!  (=> (and (= (type a@@157) DatatypeTypeType) (= (type b@@107) DatatypeTypeType)) (= (|MsgHistoryMod.KeyedMessage#Equal| a@@157 b@@107) (= a@@157 b@@107)))
 :qid |unknown.0:0|
 :skolemid |3744|
 :pattern ( (|MsgHistoryMod.KeyedMessage#Equal| a@@157 b@@107))
)))
(assert (forall ((arg0@@575 T@U) (arg1@@285 Int) (arg2@@159 Int) ) (! (= (type (|#MsgHistoryMod.MsgHistory.MsgHistory| arg0@@575 arg1@@285 arg2@@159)) DatatypeTypeType)
 :qid |funType:#MsgHistoryMod.MsgHistory.MsgHistory|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| arg0@@575 arg1@@285 arg2@@159))
)))
(assert (forall ((|a#8#0#0@@6| T@U) (|a#8#1#0@@4| Int) (|a#8#2#0@@1| Int) ) (!  (=> (= (type |a#8#0#0@@6|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#8#0#0@@6| |a#8#1#0@@4| |a#8#2#0@@1|)) |##MsgHistoryMod.MsgHistory.MsgHistory|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3745|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#8#0#0@@6| |a#8#1#0@@4| |a#8#2#0@@1|))
)))
(assert (forall ((d@@129 T@U) ) (!  (=> (= (type d@@129) DatatypeTypeType) (= (MsgHistoryMod.MsgHistory.MsgHistory_q d@@129) (= (DatatypeCtorId d@@129) |##MsgHistoryMod.MsgHistory.MsgHistory|)))
 :qid |unknown.0:0|
 :skolemid |3746|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@129))
)))
(assert (forall ((d@@130 T@U) ) (!  (=> (and (= (type d@@130) DatatypeTypeType) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@130)) (exists ((|a#9#0#0@@2| T@U) (|a#9#1#0@@0| Int) (|a#9#2#0@@0| Int) ) (!  (and (= (type |a#9#0#0@@2|) (MapType BoxType BoxType)) (= d@@130 (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#9#0#0@@2| |a#9#1#0@@0| |a#9#2#0@@0|)))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3747|
 :no-pattern (type |a#9#0#0@@2|)
 :no-pattern (U_2_int |a#9#0#0@@2|)
 :no-pattern (U_2_bool |a#9#0#0@@2|)
)))
 :qid |unknown.0:0|
 :skolemid |3748|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@130))
)))
(assert (forall ((|a#10#0#0@@2| T@U) (|a#10#1#0@@0| Int) (|a#10#2#0@@0| Int) ) (!  (=> (= (type |a#10#0#0@@2|) (MapType BoxType BoxType)) (= ($Is (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#10#0#0@@2| |a#10#1#0@@0| |a#10#2#0@@0|) Tclass.MsgHistoryMod.MsgHistory)  (and (and ($Is |a#10#0#0@@2| (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage)) ($Is (int_2_U |a#10#1#0@@0|) Tclass._System.nat)) ($Is (int_2_U |a#10#2#0@@0|) Tclass._System.nat))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3749|
 :pattern ( ($Is (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#10#0#0@@2| |a#10#1#0@@0| |a#10#2#0@@0|) Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (forall ((|a#11#0#0@@1| T@U) (|a#11#1#0| Int) (|a#11#2#0| Int) ($h@@143 T@U) ) (!  (=> (and (and (= (type |a#11#0#0@@1|) (MapType BoxType BoxType)) (= (type $h@@143) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@143)) (= ($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#11#0#0@@1| |a#11#1#0| |a#11#2#0|) Tclass.MsgHistoryMod.MsgHistory $h@@143)  (and (and ($IsAlloc |a#11#0#0@@1| (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@143) ($IsAlloc (int_2_U |a#11#1#0|) Tclass._System.nat $h@@143)) ($IsAlloc (int_2_U |a#11#2#0|) Tclass._System.nat $h@@143))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3750|
 :pattern ( ($IsAlloc (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#11#0#0@@1| |a#11#1#0| |a#11#2#0|) Tclass.MsgHistoryMod.MsgHistory $h@@143))
)))
(assert (forall ((arg0@@576 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.msgs arg0@@576)) (MapType BoxType BoxType))
 :qid |funType:MsgHistoryMod.MsgHistory.msgs|
 :pattern ( (MsgHistoryMod.MsgHistory.msgs arg0@@576))
)))
(assert (forall ((d@@131 T@U) ($h@@144 T@U) ) (!  (=> (and (and (= (type d@@131) DatatypeTypeType) (= (type $h@@144) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@144) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@131) ($IsAlloc d@@131 Tclass.MsgHistoryMod.MsgHistory $h@@144)))) ($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@131) (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@144))
 :qid |unknown.0:0|
 :skolemid |3751|
 :pattern ( ($IsAlloc (MsgHistoryMod.MsgHistory.msgs d@@131) (TMap Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage) $h@@144))
)))
(assert (forall ((d@@132 T@U) ($h@@145 T@U) ) (!  (=> (and (and (= (type d@@132) DatatypeTypeType) (= (type $h@@145) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@145) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@132) ($IsAlloc d@@132 Tclass.MsgHistoryMod.MsgHistory $h@@145)))) ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@132)) Tclass._System.nat $h@@145))
 :qid |unknown.0:0|
 :skolemid |3752|
 :pattern ( ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqStart d@@132)) Tclass._System.nat $h@@145))
)))
(assert (forall ((d@@133 T@U) ($h@@146 T@U) ) (!  (=> (and (and (= (type d@@133) DatatypeTypeType) (= (type $h@@146) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@146) (and (MsgHistoryMod.MsgHistory.MsgHistory_q d@@133) ($IsAlloc d@@133 Tclass.MsgHistoryMod.MsgHistory $h@@146)))) ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@133)) Tclass._System.nat $h@@146))
 :qid |unknown.0:0|
 :skolemid |3753|
 :pattern ( ($IsAlloc (int_2_U (MsgHistoryMod.MsgHistory.seqEnd d@@133)) Tclass._System.nat $h@@146))
)))
(assert (forall ((|a#12#0#0@@0| T@U) (|a#12#1#0| Int) (|a#12#2#0| Int) ) (!  (=> (= (type |a#12#0#0@@0|) (MapType BoxType BoxType)) (= (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit |a#12#0#0@@0|) (LitInt |a#12#1#0|) (LitInt |a#12#2#0|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#12#0#0@@0| |a#12#1#0| |a#12#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3754|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit |a#12#0#0@@0|) (LitInt |a#12#1#0|) (LitInt |a#12#2#0|)))
)))
(assert (forall ((|a#13#0#0| T@U) (|a#13#1#0| Int) (|a#13#2#0| Int) ) (!  (=> (= (type |a#13#0#0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.msgs (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#13#0#0| |a#13#1#0| |a#13#2#0|)) |a#13#0#0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3755|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#13#0#0| |a#13#1#0| |a#13#2#0|))
)))
(assert (forall ((|a#14#0#0@@0| T@U) (|a#14#1#0@@0| Int) (|a#14#2#0| Int) (d@@134 T@U) ) (!  (=> (and (and (= (type |a#14#0#0@@0|) (MapType BoxType BoxType)) (= (type d@@134) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#14#0#0@@0|) ($Box d@@134)))) (< (DtRank d@@134) (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#14#0#0@@0| |a#14#1#0@@0| |a#14#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3756|
 :pattern ( (MapType0Select (|Map#Domain| |a#14#0#0@@0|) ($Box d@@134)) (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#14#0#0@@0| |a#14#1#0@@0| |a#14#2#0|))
)))
(assert (forall ((|a#15#0#0@@0| T@U) (|a#15#1#0@@0| Int) (|a#15#2#0| Int) (bx@@156 T@U) ) (!  (=> (and (and (= (type |a#15#0#0@@0|) (MapType BoxType BoxType)) (= (type bx@@156) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#15#0#0@@0|) bx@@156))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#15#0#0@@0|) bx@@156))) (DtRank (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#15#0#0@@0| |a#15#1#0@@0| |a#15#2#0|))))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3757|
 :pattern ( (MapType0Select (|Map#Domain| |a#15#0#0@@0|) bx@@156) (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#15#0#0@@0| |a#15#1#0@@0| |a#15#2#0|))
)))
(assert (forall ((|a#16#0#0@@0| T@U) (|a#16#1#0@@0| Int) (|a#16#2#0| Int) ) (!  (=> (= (type |a#16#0#0@@0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.seqStart (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#16#0#0@@0| |a#16#1#0@@0| |a#16#2#0|)) |a#16#1#0@@0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3758|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#16#0#0@@0| |a#16#1#0@@0| |a#16#2#0|))
)))
(assert (forall ((|a#17#0#0@@0| T@U) (|a#17#1#0@@0| Int) (|a#17#2#0| Int) ) (!  (=> (= (type |a#17#0#0@@0|) (MapType BoxType BoxType)) (= (MsgHistoryMod.MsgHistory.seqEnd (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#17#0#0@@0| |a#17#1#0@@0| |a#17#2#0|)) |a#17#2#0|))
 :qid |MsgHistoryidfy.28:36|
 :skolemid |3759|
 :pattern ( (|#MsgHistoryMod.MsgHistory.MsgHistory| |a#17#0#0@@0| |a#17#1#0@@0| |a#17#2#0|))
)))
(assert (forall ((d@@135 T@U) ) (!  (=> (and (= (type d@@135) DatatypeTypeType) (|$IsA#MsgHistoryMod.MsgHistory| d@@135)) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@135))
 :qid |unknown.0:0|
 :skolemid |3760|
 :pattern ( (|$IsA#MsgHistoryMod.MsgHistory| d@@135))
)))
(assert (forall ((d@@136 T@U) ) (!  (=> (and (= (type d@@136) DatatypeTypeType) ($Is d@@136 Tclass.MsgHistoryMod.MsgHistory)) (MsgHistoryMod.MsgHistory.MsgHistory_q d@@136))
 :qid |unknown.0:0|
 :skolemid |3761|
 :pattern ( (MsgHistoryMod.MsgHistory.MsgHistory_q d@@136) ($Is d@@136 Tclass.MsgHistoryMod.MsgHistory))
)))
(assert (forall ((a@@158 T@U) (b@@108 T@U) ) (!  (=> (and (and (= (type a@@158) DatatypeTypeType) (= (type b@@108) DatatypeTypeType)) true) (= (|MsgHistoryMod.MsgHistory#Equal| a@@158 b@@108)  (and (and (|Map#Equal| (MsgHistoryMod.MsgHistory.msgs a@@158) (MsgHistoryMod.MsgHistory.msgs b@@108)) (= (MsgHistoryMod.MsgHistory.seqStart a@@158) (MsgHistoryMod.MsgHistory.seqStart b@@108))) (= (MsgHistoryMod.MsgHistory.seqEnd a@@158) (MsgHistoryMod.MsgHistory.seqEnd b@@108)))))
 :qid |unknown.0:0|
 :skolemid |3762|
 :pattern ( (|MsgHistoryMod.MsgHistory#Equal| a@@158 b@@108))
)))
(assert (forall ((a@@159 T@U) (b@@109 T@U) ) (!  (=> (and (= (type a@@159) DatatypeTypeType) (= (type b@@109) DatatypeTypeType)) (= (|MsgHistoryMod.MsgHistory#Equal| a@@159 b@@109) (= a@@159 b@@109)))
 :qid |unknown.0:0|
 :skolemid |3763|
 :pattern ( (|MsgHistoryMod.MsgHistory#Equal| a@@159 b@@109))
)))
(assert  (=> true (forall ((this@@183 T@U) ) (!  (=> (and (= (type this@@183) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| this@@183) ($Is this@@183 Tclass.MsgHistoryMod.MsgHistory))) true)
 :qid |MsgHistoryidfy.34:15|
 :skolemid |3764|
 :pattern ( (MsgHistoryMod.MsgHistory.WF this@@183))
))))
(assert (forall ((this@@184 T@U) ) (!  (=> (and (= (type this@@184) DatatypeTypeType) ($Is this@@184 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.WF#requires| this@@184) true))
 :qid |MsgHistoryidfy.34:15|
 :skolemid |3765|
 :pattern ( (|MsgHistoryMod.MsgHistory.WF#requires| this@@184))
)))
(assert  (=> true (forall ((this@@185 T@U) ) (!  (=> (and (= (type this@@185) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| this@@185) ($Is this@@185 Tclass.MsgHistoryMod.MsgHistory))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@185) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@185)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@185) (MsgHistoryMod.MsgHistory.seqEnd this@@185)) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@185) (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@185 (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs this@@185)))))) (= (MsgHistoryMod.MsgHistory.WF this@@185)  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@185) (MsgHistoryMod.MsgHistory.seqEnd this@@185)) (MsgHistoryMod.MsgHistory.ContainsExactly this@@185 (|Map#Domain| (MsgHistoryMod.MsgHistory.msgs this@@185)))))))
 :qid |MsgHistoryidfy.34:15|
 :skolemid |3766|
 :pattern ( (MsgHistoryMod.MsgHistory.WF this@@185))
))))
(assert  (=> true (forall ((this@@186 T@U) ) (!  (=> (and (= (type this@@186) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.WF#canCall| (Lit this@@186)) ($Is this@@186 Tclass.MsgHistoryMod.MsgHistory))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@186)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@186))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@186)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@186))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@186)) (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (Lit this@@186) (Lit (|Map#Domain| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@186))))))))) (= (MsgHistoryMod.MsgHistory.WF (Lit this@@186))  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@186)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@186))) (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@186) (Lit (|Map#Domain| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@186))))))))))
 :qid |MsgHistoryidfy.34:15|
 :weight 3
 :skolemid |3767|
 :pattern ( (MsgHistoryMod.MsgHistory.WF (Lit this@@186)))
))))
(assert  (=> true (forall ((this@@187 T@U) (|lsns#0| T@U) ) (!  (=> (and (and (= (type this@@187) DatatypeTypeType) (= (type |lsns#0|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@187 |lsns#0|) (and ($Is this@@187 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0| (TSet Tclass._System.nat))))) true)
 :qid |MsgHistoryidfy.40:15|
 :skolemid |3768|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly this@@187 |lsns#0|))
))))
(assert (forall ((this@@188 T@U) (|lsns#0@@0| T@U) ) (!  (=> (and (and (= (type this@@188) DatatypeTypeType) (= (type |lsns#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@188 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@0| (TSet Tclass._System.nat)))) (= (|MsgHistoryMod.MsgHistory.ContainsExactly#requires| this@@188 |lsns#0@@0|) true))
 :qid |MsgHistoryidfy.40:15|
 :skolemid |3769|
 :pattern ( (|MsgHistoryMod.MsgHistory.ContainsExactly#requires| this@@188 |lsns#0@@0|))
)))
(assert  (=> true (forall ((this@@189 T@U) (|lsns#0@@1| T@U) ) (!  (=> (and (and (= (type this@@189) DatatypeTypeType) (= (type |lsns#0@@1|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| this@@189 |lsns#0@@1|) (and ($Is this@@189 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@1| (TSet Tclass._System.nat))))) (and (forall ((|lsn#0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0|) (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@189 |lsn#0|))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |3771|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@189 |lsn#0|))
 :pattern ( (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0|))))
)) (= (MsgHistoryMod.MsgHistory.ContainsExactly this@@189 |lsns#0@@1|) (forall ((|lsn#0@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@0|) (= (U_2_bool (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0@@0|)))) (MsgHistoryMod.MsgHistory.Contains this@@189 |lsn#0@@0|)))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |3770|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@189 |lsn#0@@0|))
 :pattern ( (MapType0Select |lsns#0@@1| ($Box (int_2_U |lsn#0@@0|))))
)))))
 :qid |MsgHistoryidfy.40:15|
 :skolemid |3772|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly this@@189 |lsns#0@@1|))
))))
(assert  (=> true (forall ((this@@190 T@U) (|lsns#0@@2| T@U) ) (!  (=> (and (and (= (type this@@190) DatatypeTypeType) (= (type |lsns#0@@2|) (MapType0Type BoxType boolType))) (or (|MsgHistoryMod.MsgHistory.ContainsExactly#canCall| (Lit this@@190) (Lit |lsns#0@@2|)) (and ($Is this@@190 Tclass.MsgHistoryMod.MsgHistory) ($Is |lsns#0@@2| (TSet Tclass._System.nat))))) (and (forall ((|lsn#1| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1|) (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@190) |lsn#1|))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |3774|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@190 |lsn#1|))
 :pattern ( (MapType0Select |lsns#0@@2| ($Box (int_2_U |lsn#1|))))
)) (= (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@190) (Lit |lsns#0@@2|)) (forall ((|lsn#1@@0| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1@@0|) (= (U_2_bool (MapType0Select (Lit |lsns#0@@2|) ($Box (int_2_U |lsn#1@@0|)))) (MsgHistoryMod.MsgHistory.Contains (Lit this@@190) |lsn#1@@0|)))
 :qid |MsgHistoryidfy.42:14|
 :skolemid |3773|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@190 |lsn#1@@0|))
 :pattern ( (MapType0Select |lsns#0@@2| ($Box (int_2_U |lsn#1@@0|))))
)))))
 :qid |MsgHistoryidfy.40:15|
 :weight 3
 :skolemid |3775|
 :pattern ( (MsgHistoryMod.MsgHistory.ContainsExactly (Lit this@@190) (Lit |lsns#0@@2|)))
))))
(assert  (=> true (forall ((this@@191 T@U) (|lsn#0@@1| Int) ) (!  (=> (and (= (type this@@191) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@191 |lsn#0@@1|) (and ($Is this@@191 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@1|)))) true)
 :qid |MsgHistoryidfy.45:15|
 :skolemid |3776|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@191 |lsn#0@@1|))
))))
(assert (forall ((this@@192 T@U) (|lsn#0@@2| Int) ) (!  (=> (= (type this@@192) DatatypeTypeType) (=> (and ($Is this@@192 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@2|)) (= (|MsgHistoryMod.MsgHistory.Contains#requires| this@@192 |lsn#0@@2|) true)))
 :qid |MsgHistoryidfy.45:15|
 :skolemid |3777|
 :pattern ( (|MsgHistoryMod.MsgHistory.Contains#requires| this@@192 |lsn#0@@2|))
)))
(assert  (=> true (forall ((this@@193 T@U) (|lsn#0@@3| Int) ) (!  (=> (and (= (type this@@193) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@193 |lsn#0@@3|) (and ($Is this@@193 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@3|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@193) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@193) |lsn#0@@3|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@193)))) (= (MsgHistoryMod.MsgHistory.Contains this@@193 |lsn#0@@3|)  (and true (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@193) |lsn#0@@3|) (INTERNAL_lt_boogie |lsn#0@@3| (MsgHistoryMod.MsgHistory.seqEnd this@@193)))))))
 :qid |MsgHistoryidfy.45:15|
 :skolemid |3778|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@193 |lsn#0@@3|))
))))
(assert  (=> true (forall ((this@@194 T@U) (|lsn#0@@4| Int) ) (!  (=> (and (= (type this@@194) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@194) (LitInt |lsn#0@@4|)) (and ($Is this@@194 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@4|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@194)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@194)) |lsn#0@@4|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@194))))) (= (MsgHistoryMod.MsgHistory.Contains (Lit this@@194) (LitInt |lsn#0@@4|))  (and true (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@194)) |lsn#0@@4|) (INTERNAL_lt_boogie |lsn#0@@4| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@194))))))))
 :qid |MsgHistoryidfy.45:15|
 :weight 3
 :skolemid |3779|
 :pattern ( (MsgHistoryMod.MsgHistory.Contains (Lit this@@194) (LitInt |lsn#0@@4|)))
))))
(assert (forall ((arg0@@577 T@U) (arg1@@286 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.LSNSet arg0@@577 arg1@@286)) (MapType0Type BoxType boolType))
 :qid |funType:MsgHistoryMod.MsgHistory.LSNSet|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet arg0@@577 arg1@@286))
)))
(assert (forall (($ly@@322 T@U) (this@@195 T@U) ) (!  (=> (and (= (type $ly@@322) LayerTypeType) (= (type this@@195) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@322) this@@195) (MsgHistoryMod.MsgHistory.LSNSet $ly@@322 this@@195)))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |3780|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@322) this@@195))
)))
(assert (forall (($ly@@323 T@U) (this@@196 T@U) ) (!  (=> (and (= (type $ly@@323) LayerTypeType) (= (type this@@196) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.LSNSet $ly@@323 this@@196) (MsgHistoryMod.MsgHistory.LSNSet $LZ this@@196)))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |3781|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet (AsFuelBottom $ly@@323) this@@196))
)))
(assert  (=> true (forall (($ly@@324 T@U) (this@@197 T@U) ) (!  (=> (and (and (= (type $ly@@324) LayerTypeType) (= (type this@@197) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| this@@197) ($Is this@@197 Tclass.MsgHistoryMod.MsgHistory))) (and (MsgHistoryMod.MsgHistory.ContainsExactly this@@197 (MsgHistoryMod.MsgHistory.LSNSet $ly@@324 this@@197)) ($Is (MsgHistoryMod.MsgHistory.LSNSet $ly@@324 this@@197) (TSet Tclass._System.nat))))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |3782|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet $ly@@324 this@@197))
))))
(assert (forall (($ly@@325 T@U) (this@@198 T@U) ) (!  (=> (and (and (= (type $ly@@325) LayerTypeType) (= (type this@@198) DatatypeTypeType)) ($Is this@@198 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@325 this@@198) true))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |3783|
 :pattern ( (|MsgHistoryMod.MsgHistory.LSNSet#requires| $ly@@325 this@@198))
)))
(assert (forall ((arg0@@578 T@U) (arg1@@287 Int) (arg2@@160 Int) ) (! (= (type (|lambda#248| arg0@@578 arg1@@287 arg2@@160)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#248|
 :pattern ( (|lambda#248| arg0@@578 arg1@@287 arg2@@160))
)))
(assert  (=> true (forall (($ly@@326 T@U) (this@@199 T@U) ) (!  (=> (and (and (= (type $ly@@326) LayerTypeType) (= (type this@@199) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| this@@199) ($Is this@@199 Tclass.MsgHistoryMod.MsgHistory))) (and (forall ((|lsn#0@@5| Int) ) (!  (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@199) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@199) |lsn#0@@5|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@199)))
 :qid |MsgHistoryidfy.55:11|
 :skolemid |3784|
 :pattern ( (INTERNAL_lt_boogie |lsn#0@@5| (MsgHistoryMod.MsgHistory.seqEnd this@@199)))
 :pattern ( (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@199) |lsn#0@@5|))
)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@326) this@@199) (|lambda#248| TInt (MsgHistoryMod.MsgHistory.seqStart this@@199) (MsgHistoryMod.MsgHistory.seqEnd this@@199)))))
 :qid |MsgHistoryidfy.52:24|
 :skolemid |3785|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@326) this@@199))
))))
(assert  (=> true (forall (($ly@@327 T@U) (this@@200 T@U) ) (!  (=> (and (and (= (type $ly@@327) LayerTypeType) (= (type this@@200) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.LSNSet#canCall| (Lit this@@200)) ($Is this@@200 Tclass.MsgHistoryMod.MsgHistory))) (and (forall ((|lsn#1@@1| Int) ) (!  (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@200)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@200)) |lsn#1@@1|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@200))))
 :qid |MsgHistoryidfy.55:11|
 :skolemid |3786|
 :pattern ( (INTERNAL_lt_boogie |lsn#1@@1| (MsgHistoryMod.MsgHistory.seqEnd this@@200)))
 :pattern ( (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@200) |lsn#1@@1|))
)) (= (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@327) (Lit this@@200)) (|lambda#248| TInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@200)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@200))))))
 :qid |MsgHistoryidfy.52:24|
 :weight 3
 :skolemid |3787|
 :pattern ( (MsgHistoryMod.MsgHistory.LSNSet ($LS $ly@@327) (Lit this@@200)))
))))
(assert  (=> true (forall ((this@@201 T@U) ) (!  (=> (and (= (type this@@201) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@201) (and ($Is this@@201 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@201)))) true)
 :qid |MsgHistoryidfy.58:15|
 :skolemid |3788|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty this@@201))
))))
(assert (forall ((this@@202 T@U) ) (!  (=> (and (= (type this@@202) DatatypeTypeType) ($Is this@@202 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@202) (MsgHistoryMod.MsgHistory.WF this@@202)))
 :qid |MsgHistoryidfy.58:15|
 :skolemid |3789|
 :pattern ( (|MsgHistoryMod.MsgHistory.IsEmpty#requires| this@@202))
)))
(assert  (=> true (forall ((this@@203 T@U) ) (!  (=> (and (= (type this@@203) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@203) (and ($Is this@@203 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@203)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@203) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@203)) (= (MsgHistoryMod.MsgHistory.IsEmpty this@@203) (= (MsgHistoryMod.MsgHistory.seqEnd this@@203) (MsgHistoryMod.MsgHistory.seqStart this@@203)))))
 :qid |MsgHistoryidfy.58:15|
 :skolemid |3790|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty this@@203))
))))
(assert  (=> true (forall ((this@@204 T@U) ) (!  (=> (and (= (type this@@204) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@204)) (and ($Is this@@204 Tclass.MsgHistoryMod.MsgHistory) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@204)))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@204)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@204))) (= (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@204)) (= (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@204))) (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@204)))))))
 :qid |MsgHistoryidfy.58:15|
 :weight 3
 :skolemid |3791|
 :pattern ( (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@204)))
))))
(assert  (=> true (forall ((this@@205 T@U) ) (!  (=> (and (= (type this@@205) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| this@@205) (and ($Is this@@205 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@205)))) (INTERNAL_le_boogie 0 (MsgHistoryMod.MsgHistory.Len this@@205)))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |3792|
 :pattern ( (MsgHistoryMod.MsgHistory.Len this@@205))
))))
(assert (forall ((this@@206 T@U) ) (!  (=> (and (= (type this@@206) DatatypeTypeType) ($Is this@@206 Tclass.MsgHistoryMod.MsgHistory)) (= (|MsgHistoryMod.MsgHistory.Len#requires| this@@206) (MsgHistoryMod.MsgHistory.WF this@@206)))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |3793|
 :pattern ( (|MsgHistoryMod.MsgHistory.Len#requires| this@@206))
)))
(assert  (=> true (forall ((this@@207 T@U) ) (!  (=> (and (= (type this@@207) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| this@@207) (and ($Is this@@207 Tclass.MsgHistoryMod.MsgHistory) (MsgHistoryMod.MsgHistory.WF this@@207)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@207) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@207)) (= (MsgHistoryMod.MsgHistory.Len this@@207) (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@207) (MsgHistoryMod.MsgHistory.seqStart this@@207)))))
 :qid |MsgHistoryidfy.64:14|
 :skolemid |3794|
 :pattern ( (MsgHistoryMod.MsgHistory.Len this@@207))
))))
(assert  (=> true (forall ((this@@208 T@U) ) (!  (=> (and (= (type this@@208) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.Len#canCall| (Lit this@@208)) (and ($Is this@@208 Tclass.MsgHistoryMod.MsgHistory) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@208)))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@208)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@208))) (= (MsgHistoryMod.MsgHistory.Len (Lit this@@208)) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@208)) (MsgHistoryMod.MsgHistory.seqStart (Lit this@@208)))))))
 :qid |MsgHistoryidfy.64:14|
 :weight 3
 :skolemid |3795|
 :pattern ( (MsgHistoryMod.MsgHistory.Len (Lit this@@208)))
))))
(assert  (=> true (forall ((this@@209 T@U) (|other#0| T@U) ) (!  (=> (and (and (= (type this@@209) DatatypeTypeType) (= (type |other#0|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| this@@209 |other#0|) (and (and ($Is this@@209 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@209) (MsgHistoryMod.MsgHistory.WF |other#0|))))) true)
 :qid |MsgHistoryidfy.70:15|
 :skolemid |3796|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat this@@209 |other#0|))
))))
(assert (forall ((this@@210 T@U) (|other#0@@0| T@U) ) (!  (=> (and (and (= (type this@@210) DatatypeTypeType) (= (type |other#0@@0|) DatatypeTypeType)) (and ($Is this@@210 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@0| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.CanConcat#requires| this@@210 |other#0@@0|)  (and (MsgHistoryMod.MsgHistory.WF this@@210) (MsgHistoryMod.MsgHistory.WF |other#0@@0|))))
 :qid |MsgHistoryidfy.70:15|
 :skolemid |3797|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanConcat#requires| this@@210 |other#0@@0|))
)))
(assert  (=> true (forall ((this@@211 T@U) (|other#0@@1| T@U) ) (!  (=> (and (and (= (type this@@211) DatatypeTypeType) (= (type |other#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| this@@211 |other#0@@1|) (and (and ($Is this@@211 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@211) (MsgHistoryMod.MsgHistory.WF |other#0@@1|))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@211) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| |other#0@@1| (MsgHistoryMod.MsgHistory.seqEnd this@@211))) (= (MsgHistoryMod.MsgHistory.CanConcat this@@211 |other#0@@1|) (MsgHistoryMod.MsgHistory.CanFollow |other#0@@1| (MsgHistoryMod.MsgHistory.seqEnd this@@211)))))
 :qid |MsgHistoryidfy.70:15|
 :skolemid |3798|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat this@@211 |other#0@@1|))
))))
(assert  (=> true (forall ((this@@212 T@U) (|other#0@@2| T@U) ) (!  (=> (and (and (= (type this@@212) DatatypeTypeType) (= (type |other#0@@2|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.CanConcat#canCall| (Lit this@@212) (Lit |other#0@@2|)) (and (and ($Is this@@212 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@212))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |other#0@@2|))))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@212)) (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (Lit |other#0@@2|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@212))))) (= (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@212) (Lit |other#0@@2|)) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit |other#0@@2|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@212))))))))))
 :qid |MsgHistoryidfy.70:15|
 :weight 3
 :skolemid |3799|
 :pattern ( (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@212) (Lit |other#0@@2|)))
))))
(assert  (and (forall ((arg0@@579 T@U) (arg1@@288 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.Concat arg0@@579 arg1@@288)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.Concat|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat arg0@@579 arg1@@288))
)) (= (type StartFuel_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType)))
(assert  (=> true (forall ((this@@213 T@U) (|other#0@@3| T@U) ) (!  (=> (and (and (= (type this@@213) DatatypeTypeType) (= (type |other#0@@3|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| this@@213 |other#0@@3|) (and (and ($Is this@@213 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@3| Tclass.MsgHistoryMod.MsgHistory)) (and (and (MsgHistoryMod.MsgHistory.WF this@@213) (MsgHistoryMod.MsgHistory.WF |other#0@@3|)) (MsgHistoryMod.MsgHistory.CanConcat this@@213 |other#0@@3|))))) (and (and (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.Concat this@@213 |other#0@@3|)) (|Set#Equal| (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet (MsgHistoryMod.MsgHistory.Concat this@@213 |other#0@@3|)) (|Set#Union| (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet this@@213) (MsgHistoryMod.MsgHistory.LSNSet StartFuel_MsgHistoryMod.MsgHistory.LSNSet |other#0@@3|)))) (=> (MsgHistoryMod.MsgHistory.IsEmpty |other#0@@3|) (|MsgHistoryMod.MsgHistory#Equal| (MsgHistoryMod.MsgHistory.Concat this@@213 |other#0@@3|) this@@213))) ($Is (MsgHistoryMod.MsgHistory.Concat this@@213 |other#0@@3|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |3800|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat this@@213 |other#0@@3|))
))))
(assert (forall ((this@@214 T@U) (|other#0@@4| T@U) ) (!  (=> (and (and (= (type this@@214) DatatypeTypeType) (= (type |other#0@@4|) DatatypeTypeType)) (and ($Is this@@214 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@4| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.Concat#requires| this@@214 |other#0@@4|)  (and (and (MsgHistoryMod.MsgHistory.WF this@@214) (MsgHistoryMod.MsgHistory.WF |other#0@@4|)) (MsgHistoryMod.MsgHistory.CanConcat this@@214 |other#0@@4|))))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |3801|
 :pattern ( (|MsgHistoryMod.MsgHistory.Concat#requires| this@@214 |other#0@@4|))
)))
(assert  (=> true (forall ((this@@215 T@U) (|other#0@@5| T@U) ) (!  (=> (and (and (= (type this@@215) DatatypeTypeType) (= (type |other#0@@5|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| this@@215 |other#0@@5|) (and (and ($Is this@@215 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@5| Tclass.MsgHistoryMod.MsgHistory)) (and (and (MsgHistoryMod.MsgHistory.WF this@@215) (MsgHistoryMod.MsgHistory.WF |other#0@@5|)) (MsgHistoryMod.MsgHistory.CanConcat this@@215 |other#0@@5|))))) (and (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@215) (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@5|)) (|Maps.__default.MapDisjointUnion#canCall| Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage (MsgHistoryMod.MsgHistory.msgs this@@215) (MsgHistoryMod.MsgHistory.msgs |other#0@@5|))) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@215)) (MsgHistoryMod.MsgHistory.MsgHistory_q |other#0@@5|)) (= (MsgHistoryMod.MsgHistory.Concat this@@215 |other#0@@5|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Maps.__default.MapDisjointUnion Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage StartFuel_Maps._default.MapDisjointUnion (MsgHistoryMod.MsgHistory.msgs this@@215) (MsgHistoryMod.MsgHistory.msgs |other#0@@5|)) (MsgHistoryMod.MsgHistory.seqStart this@@215) (MsgHistoryMod.MsgHistory.seqEnd |other#0@@5|)))))
 :qid |MsgHistoryidfy.77:14|
 :skolemid |3802|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat this@@215 |other#0@@5|))
))))
(assert  (=> true (forall ((this@@216 T@U) (|other#0@@6| T@U) ) (!  (=> (and (and (= (type this@@216) DatatypeTypeType) (= (type |other#0@@6|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.Concat#canCall| (Lit this@@216) (Lit |other#0@@6|)) (and (and ($Is this@@216 Tclass.MsgHistoryMod.MsgHistory) ($Is |other#0@@6| Tclass.MsgHistoryMod.MsgHistory)) (and (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@216))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |other#0@@6|)))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanConcat (Lit this@@216) (Lit |other#0@@6|))))))))) (and (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@216)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |other#0@@6|))) (|Maps.__default.MapDisjointUnion#canCall| Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@216))) (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@6|))))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@216))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |other#0@@6|))) (= (MsgHistoryMod.MsgHistory.Concat (Lit this@@216) (Lit |other#0@@6|)) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Maps.__default.MapDisjointUnion Tclass._System.nat Tclass.MsgHistoryMod.KeyedMessage StartFuel_Maps._default.MapDisjointUnion (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@216))) (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |other#0@@6|)))) (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@216))) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit |other#0@@6|)))))))
 :qid |MsgHistoryidfy.77:14|
 :weight 3
 :skolemid |3803|
 :pattern ( (MsgHistoryMod.MsgHistory.Concat (Lit this@@216) (Lit |other#0@@6|)))
))))
(assert  (=> true (forall ((this@@217 T@U) (|lsn#0@@6| Int) ) (!  (=> (and (= (type this@@217) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| this@@217 |lsn#0@@6|) (and ($Is this@@217 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@6|)))) true)
 :qid |MsgHistoryidfy.89:15|
 :skolemid |3804|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow this@@217 |lsn#0@@6|))
))))
(assert (forall ((this@@218 T@U) (|lsn#0@@7| Int) ) (!  (=> (= (type this@@218) DatatypeTypeType) (=> (and ($Is this@@218 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@7|)) (= (|MsgHistoryMod.MsgHistory.CanFollow#requires| this@@218 |lsn#0@@7|) true)))
 :qid |MsgHistoryidfy.89:15|
 :skolemid |3805|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanFollow#requires| this@@218 |lsn#0@@7|))
)))
(assert  (=> true (forall ((this@@219 T@U) (|lsn#0@@8| Int) ) (!  (=> (and (= (type this@@219) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| this@@219 |lsn#0@@8|) (and ($Is this@@219 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@8|)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@219) (= (MsgHistoryMod.MsgHistory.CanFollow this@@219 |lsn#0@@8|) (= (MsgHistoryMod.MsgHistory.seqStart this@@219) |lsn#0@@8|))))
 :qid |MsgHistoryidfy.89:15|
 :skolemid |3806|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow this@@219 |lsn#0@@8|))
))))
(assert  (=> true (forall ((this@@220 T@U) (|lsn#0@@9| Int) ) (!  (=> (and (= (type this@@220) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanFollow#canCall| (Lit this@@220) (LitInt |lsn#0@@9|)) (and ($Is this@@220 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@9|)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@220)) (= (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@220) (LitInt |lsn#0@@9|)) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@220))) (LitInt |lsn#0@@9|)))))
 :qid |MsgHistoryidfy.89:15|
 :weight 3
 :skolemid |3807|
 :pattern ( (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@220) (LitInt |lsn#0@@9|)))
))))
(assert (forall ((arg0@@580 T@U) (arg1@@289 T@U) (arg2@@161 T@U) ) (! (= (type (MsgHistoryMod.MsgHistory.ApplyToStampedMap arg0@@580 arg1@@289 arg2@@161)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.ApplyToStampedMap|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap arg0@@580 arg1@@289 arg2@@161))
)))
(assert (forall (($ly@@328 T@U) (this@@221 T@U) (|orig#0| T@U) ) (!  (=> (and (and (= (type $ly@@328) LayerTypeType) (= (type this@@221) DatatypeTypeType)) (= (type |orig#0|) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@328) this@@221 |orig#0|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@328 this@@221 |orig#0|)))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |3808|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@328) this@@221 |orig#0|))
)))
(assert (forall (($ly@@329 T@U) (this@@222 T@U) (|orig#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@329) LayerTypeType) (= (type this@@222) DatatypeTypeType)) (= (type |orig#0@@0|) DatatypeTypeType)) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@329 this@@222 |orig#0@@0|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap $LZ this@@222 |orig#0@@0|)))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |3809|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap (AsFuelBottom $ly@@329) this@@222 |orig#0@@0|))
)))
(assert  (=> true (forall (($ly@@330 T@U) (this@@223 T@U) (|orig#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@330) LayerTypeType) (= (type this@@223) DatatypeTypeType)) (= (type |orig#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| this@@223 |orig#0@@1|) (and (and ($Is this@@223 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (MsgHistoryMod.MsgHistory.WF this@@223) (MsgHistoryMod.MsgHistory.CanFollow this@@223 (StampedMod.Stamped.seqEnd |orig#0@@1|)))))) (and (= (StampedMod.Stamped.seqEnd (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@330 this@@223 |orig#0@@1|)) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |orig#0@@1|) (MsgHistoryMod.MsgHistory.Len this@@223))) ($Is (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@330 this@@223 |orig#0@@1|) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |3810|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@330 this@@223 |orig#0@@1|))
))))
(assert (forall (($ly@@331 T@U) (this@@224 T@U) (|orig#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@331) LayerTypeType) (= (type this@@224) DatatypeTypeType)) (= (type |orig#0@@2|) DatatypeTypeType)) (and ($Is this@@224 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))) (= (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| $ly@@331 this@@224 |orig#0@@2|)  (and (MsgHistoryMod.MsgHistory.WF this@@224) (MsgHistoryMod.MsgHistory.CanFollow this@@224 (StampedMod.Stamped.seqEnd |orig#0@@2|)))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |3811|
 :pattern ( (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#requires| $ly@@331 this@@224 |orig#0@@2|))
)))
(assert (forall ((arg0@@581 T@U) (arg1@@290 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.DiscardRecent arg0@@581 arg1@@290)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.DiscardRecent|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent arg0@@581 arg1@@290))
)))
(assert  (=> true (forall (($ly@@332 T@U) (this@@225 T@U) (|orig#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@332) LayerTypeType) (= (type this@@225) DatatypeTypeType)) (= (type |orig#0@@3|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| this@@225 |orig#0@@3|) (and (and ($Is this@@225 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@3| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (MsgHistoryMod.MsgHistory.WF this@@225) (MsgHistoryMod.MsgHistory.CanFollow this@@225 (StampedMod.Stamped.seqEnd |orig#0@@3|)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| this@@225) (=> (not (MsgHistoryMod.MsgHistory.IsEmpty this@@225)) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@225) (let ((|lastLsn#0| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@225) 1)))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@225 |lastLsn#0|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent this@@225 |lastLsn#0|) |orig#0@@3|)) (let ((|subMap#0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@332 (MsgHistoryMod.MsgHistory.DiscardRecent this@@225 |lastLsn#0|) |orig#0@@3|)))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@225) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0|)))))) (let ((|key#0@@27| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@225) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0|)))))) (let ((|newMessage#0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#0|) (let ((|oldMessage#0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0|))) ($Box |key#0@@27|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#0|) (|ValueMessage.__default.Merge#canCall| |newMessage#0| |oldMessage#0|)) (StampedMod.Stamped.Stamped_q |subMap#0|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@332) this@@225 |orig#0@@3|) (ite (MsgHistoryMod.MsgHistory.IsEmpty this@@225) |orig#0@@3| (let ((|lastLsn#0@@0| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd this@@225) 1)))
(let ((|subMap#0@@0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap $ly@@332 (MsgHistoryMod.MsgHistory.DiscardRecent this@@225 |lastLsn#0@@0|) |orig#0@@3|)))
(let ((|key#0@@28| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0@@0|)))))))
(let ((|newMessage#0@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@225)) ($Box (int_2_U |lastLsn#0@@0|)))))))
(let ((|oldMessage#0@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0@@0|))) ($Box |key#0@@28|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#0@@0|)) ($Box |key#0@@28|) ($Box (ValueMessage.__default.Merge |newMessage#0@@0| |oldMessage#0@@0|)))) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#0@@0|) 1)))))))))))
 :qid |MsgHistoryidfy.94:14|
 :skolemid |3812|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@332) this@@225 |orig#0@@3|))
))))
(assert  (=> true (forall (($ly@@333 T@U) (this@@226 T@U) (|orig#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@333) LayerTypeType) (= (type this@@226) DatatypeTypeType)) (= (type |orig#0@@4|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit this@@226) |orig#0@@4|) (and (and ($Is this@@226 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@4| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@226))))) (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@226) (StampedMod.Stamped.seqEnd |orig#0@@4|)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@226)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@226)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@226)) (let ((|lastLsn#1| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@226)) 1))))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@226) |lastLsn#1|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@226) |lastLsn#1|) |orig#0@@4|)) (let ((|subMap#1| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@333) (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@226) |lastLsn#1|) |orig#0@@4|)))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@226)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1|)))))) (let ((|key#1@@6| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@226)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1|)))))) (let ((|newMessage#1| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#1|) (let ((|oldMessage#1| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1|))) ($Box |key#1@@6|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#1|) (|ValueMessage.__default.Merge#canCall| |newMessage#1| |oldMessage#1|)) (StampedMod.Stamped.Stamped_q |subMap#1|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@333) (Lit this@@226) |orig#0@@4|) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@226)) |orig#0@@4| (let ((|lastLsn#1@@0| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@226)) 1))))
(let ((|subMap#1@@0| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@333) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@226) |lastLsn#1@@0|)) |orig#0@@4|)))
(let ((|key#1@@7| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1@@0|)))))))
(let ((|newMessage#1@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@226)))) ($Box (int_2_U |lastLsn#1@@0|)))))))
(let ((|oldMessage#1@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1@@0|))) ($Box |key#1@@7|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#1@@0|)) ($Box |key#1@@7|) ($Box (ValueMessage.__default.Merge |newMessage#1@@0| |oldMessage#1@@0|)))) (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#1@@0|) 1)))))))))))
 :qid |MsgHistoryidfy.94:14|
 :weight 3
 :skolemid |3813|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@333) (Lit this@@226) |orig#0@@4|))
))))
(assert  (=> true (forall (($ly@@334 T@U) (this@@227 T@U) (|orig#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@334) LayerTypeType) (= (type this@@227) DatatypeTypeType)) (= (type |orig#0@@5|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit this@@227) (Lit |orig#0@@5|)) (and (and ($Is this@@227 Tclass.MsgHistoryMod.MsgHistory) ($Is |orig#0@@5| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap))) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@227))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit this@@227) (LitInt (StampedMod.Stamped.seqEnd (Lit |orig#0@@5|))))))))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit this@@227)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@227)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@227)) (let ((|lastLsn#2| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@227)) 1))))
 (and (and (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@227) |lastLsn#2|) (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@227) |lastLsn#2|) (Lit |orig#0@@5|))) (let ((|subMap#2| (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@334) (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@227) |lastLsn#2|) (Lit |orig#0@@5|))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@227)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2|)))))) (let ((|key#2| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2|)))))))
 (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@227)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2|)))))) (let ((|newMessage#2| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2|)))))))
 (and (StampedMod.Stamped.Stamped_q |subMap#2|) (let ((|oldMessage#2| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2|))) ($Box |key#2|)))))
 (and (and (StampedMod.Stamped.Stamped_q |subMap#2|) (|ValueMessage.__default.Merge#canCall| |newMessage#2| |oldMessage#2|)) (StampedMod.Stamped.Stamped_q |subMap#2|)))))))))))))) (= (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@334) (Lit this@@227) (Lit |orig#0@@5|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit this@@227)) |orig#0@@5| (let ((|lastLsn#2@@0| (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@227)) 1))))
(let ((|subMap#2@@0| (Lit (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@334) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@227) |lastLsn#2@@0|)) (Lit |orig#0@@5|)))))
(let ((|key#2@@0| (MsgHistoryMod.KeyedMessage.key ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2@@0|)))))))
(let ((|newMessage#2@@0| (MsgHistoryMod.KeyedMessage.message ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@227)))) ($Box (int_2_U |lastLsn#2@@0|)))))))
(let ((|oldMessage#2@@0| ($Unbox DatatypeTypeType (MapType0Select (|IMap#Elements| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2@@0|)))) ($Box |key#2@@0|)))))
(|#StampedMod.Stamped.Stamped| ($Box (|IMap#Build| (Lit ($Unbox (IMapType BoxType BoxType) (StampedMod.Stamped.value |subMap#2@@0|))) ($Box |key#2@@0|) ($Box (ValueMessage.__default.Merge |newMessage#2@@0| |oldMessage#2@@0|)))) (LitInt (INTERNAL_add_boogie (StampedMod.Stamped.seqEnd |subMap#2@@0|) 1))))))))))))
 :qid |MsgHistoryidfy.94:14|
 :weight 3
 :skolemid |3814|
 :pattern ( (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $ly@@334) (Lit this@@227) (Lit |orig#0@@5|)))
))))
(assert  (=> true (forall ((this@@228 T@U) (|lsn#0@@10| Int) ) (!  (=> (and (= (type this@@228) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| this@@228 |lsn#0@@10|) (and ($Is this@@228 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@10|)))) true)
 :qid |MsgHistoryidfy.112:15|
 :skolemid |3815|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo this@@228 |lsn#0@@10|))
))))
(assert (forall ((this@@229 T@U) (|lsn#0@@11| Int) ) (!  (=> (= (type this@@229) DatatypeTypeType) (=> (and ($Is this@@229 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@11|)) (= (|MsgHistoryMod.MsgHistory.CanDiscardTo#requires| this@@229 |lsn#0@@11|) true)))
 :qid |MsgHistoryidfy.112:15|
 :skolemid |3816|
 :pattern ( (|MsgHistoryMod.MsgHistory.CanDiscardTo#requires| this@@229 |lsn#0@@11|))
)))
(assert  (=> true (forall ((this@@230 T@U) (|lsn#0@@12| Int) ) (!  (=> (and (= (type this@@230) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| this@@230 |lsn#0@@12|) (and ($Is this@@230 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@12|)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@230) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@230) |lsn#0@@12|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@230))) (= (MsgHistoryMod.MsgHistory.CanDiscardTo this@@230 |lsn#0@@12|)  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@230) |lsn#0@@12|) (INTERNAL_le_boogie |lsn#0@@12| (MsgHistoryMod.MsgHistory.seqEnd this@@230))))))
 :qid |MsgHistoryidfy.112:15|
 :skolemid |3817|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo this@@230 |lsn#0@@12|))
))))
(assert  (=> true (forall ((this@@231 T@U) (|lsn#0@@13| Int) ) (!  (=> (and (= (type this@@231) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.CanDiscardTo#canCall| (Lit this@@231) (LitInt |lsn#0@@13|)) (and ($Is this@@231 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@13|)))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@231)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@231)) |lsn#0@@13|) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@231)))) (= (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@231) (LitInt |lsn#0@@13|))  (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@231)) |lsn#0@@13|) (INTERNAL_le_boogie |lsn#0@@13| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@231)))))))
 :qid |MsgHistoryidfy.112:15|
 :weight 3
 :skolemid |3818|
 :pattern ( (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@231) (LitInt |lsn#0@@13|)))
))))
(assert (forall ((arg0@@582 T@U) (arg1@@291 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.DiscardOld arg0@@582 arg1@@291)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.DiscardOld|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld arg0@@582 arg1@@291))
)))
(assert  (=> true (forall ((this@@232 T@U) (|lsn#0@@14| Int) ) (!  (=> (and (= (type this@@232) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@232 |lsn#0@@14|) (and (and ($Is this@@232 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@14|)) (and (MsgHistoryMod.MsgHistory.WF this@@232) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@232 |lsn#0@@14|))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.DiscardOld this@@232 |lsn#0@@14|)) ($Is (MsgHistoryMod.MsgHistory.DiscardOld this@@232 |lsn#0@@14|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |3819|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld this@@232 |lsn#0@@14|))
))))
(assert (forall ((this@@233 T@U) (|lsn#0@@15| Int) ) (!  (=> (= (type this@@233) DatatypeTypeType) (=> (and ($Is this@@233 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@15|)) (= (|MsgHistoryMod.MsgHistory.DiscardOld#requires| this@@233 |lsn#0@@15|)  (and (MsgHistoryMod.MsgHistory.WF this@@233) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@233 |lsn#0@@15|)))))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |3820|
 :pattern ( (|MsgHistoryMod.MsgHistory.DiscardOld#requires| this@@233 |lsn#0@@15|))
)))
(assert  (=> true (forall ((this@@234 T@U) (|lsn#0@@16| Int) ) (!  (=> (and (= (type this@@234) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@234 |lsn#0@@16|) (and (and ($Is this@@234 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@16|)) (and (MsgHistoryMod.MsgHistory.WF this@@234) (MsgHistoryMod.MsgHistory.CanDiscardTo this@@234 |lsn#0@@16|))))) (and (and (forall ((|k#0@@65| T@U) ) (!  (=> (= (type |k#0@@65|) intType) (and (=> (INTERNAL_le_boogie |lsn#0@@16| (U_2_int |k#0@@65|)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@234)) (=> (and (INTERNAL_le_boogie |lsn#0@@16| (U_2_int |k#0@@65|)) (INTERNAL_lt_boogie (U_2_int |k#0@@65|) (MsgHistoryMod.MsgHistory.seqEnd this@@234))) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@234))))
 :qid |MsgHistoryidfy.126:26|
 :skolemid |3821|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@234)) ($Box |k#0@@65|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@234)) (= (MsgHistoryMod.MsgHistory.DiscardOld this@@234 |lsn#0@@16|) (let ((|keepMap#0| (|Map#Glue| (|lambda#248| TInt |lsn#0@@16| (MsgHistoryMod.MsgHistory.seqEnd this@@234)) (|lambda#185| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@234))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#0| |lsn#0@@16| (MsgHistoryMod.MsgHistory.seqEnd this@@234))))))
 :qid |MsgHistoryidfy.121:14|
 :skolemid |3822|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld this@@234 |lsn#0@@16|))
))))
(assert  (=> true (forall ((this@@235 T@U) (|lsn#0@@17| Int) ) (!  (=> (and (= (type this@@235) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| (Lit this@@235) (LitInt |lsn#0@@17|)) (and (and ($Is this@@235 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@17|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@235))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@235) (LitInt |lsn#0@@17|))))))))) (and (and (forall ((|k#0@@66| T@U) ) (!  (=> (= (type |k#0@@66|) intType) (and (=> (INTERNAL_le_boogie |lsn#0@@17| (U_2_int |k#0@@66|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@235))) (=> (and (INTERNAL_le_boogie |lsn#0@@17| (U_2_int |k#0@@66|)) (INTERNAL_lt_boogie (U_2_int |k#0@@66|) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@235)))) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@235)))))
 :qid |MsgHistoryidfy.126:26|
 :skolemid |3823|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@235)) ($Box |k#0@@66|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@235))) (= (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@235) (LitInt |lsn#0@@17|)) (let ((|keepMap#1| (|Map#Glue| (|lambda#248| TInt |lsn#0@@17| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@235))) (|lambda#185| (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@235))))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#1| (LitInt |lsn#0@@17|) (LitInt (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@235))))))))
 :qid |MsgHistoryidfy.121:14|
 :weight 3
 :skolemid |3824|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@235) (LitInt |lsn#0@@17|)))
))))
(assert (forall ((arg0@@583 T@U) (arg1@@292 Int) ) (! (= (type (MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@583 arg1@@292)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.MsgHistory.MaybeDiscardOld|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld arg0@@583 arg1@@292))
)))
(assert  (=> true (forall ((this@@236 T@U) (|lsn#0@@18| Int) ) (!  (=> (and (= (type this@@236) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| this@@236 |lsn#0@@18|) (and (and ($Is this@@236 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@18|)) (and (MsgHistoryMod.MsgHistory.WF this@@236) (INTERNAL_le_boogie |lsn#0@@18| (MsgHistoryMod.MsgHistory.seqEnd this@@236)))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@236 |lsn#0@@18|)) ($Is (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@236 |lsn#0@@18|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |3825|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@236 |lsn#0@@18|))
))))
(assert (forall ((this@@237 T@U) (|lsn#0@@19| Int) ) (!  (=> (= (type this@@237) DatatypeTypeType) (=> (and ($Is this@@237 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@19|)) (= (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| this@@237 |lsn#0@@19|)  (and (MsgHistoryMod.MsgHistory.WF this@@237) (INTERNAL_le_boogie |lsn#0@@19| (MsgHistoryMod.MsgHistory.seqEnd this@@237))))))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |3826|
 :pattern ( (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#requires| this@@237 |lsn#0@@19|))
)))
(assert  (=> true (forall ((this@@238 T@U) (|lsn#0@@20| Int) ) (!  (=> (and (= (type this@@238) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| this@@238 |lsn#0@@20|) (and (and ($Is this@@238 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@20|)) (and (MsgHistoryMod.MsgHistory.WF this@@238) (INTERNAL_le_boogie |lsn#0@@20| (MsgHistoryMod.MsgHistory.seqEnd this@@238)))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@238) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@238) |lsn#0@@20|) (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| this@@238 |lsn#0@@20|))) (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@238 |lsn#0@@20|) (ite (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@238) |lsn#0@@20|) (MsgHistoryMod.MsgHistory.DiscardOld this@@238 |lsn#0@@20|) this@@238))))
 :qid |MsgHistoryidfy.130:14|
 :skolemid |3827|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld this@@238 |lsn#0@@20|))
))))
(assert  (=> true (forall ((this@@239 T@U) (|lsn#0@@21| Int) ) (!  (=> (and (= (type this@@239) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.MaybeDiscardOld#canCall| (Lit this@@239) (LitInt |lsn#0@@21|)) (and (and ($Is this@@239 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@21|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@239))))) (INTERNAL_le_boogie |lsn#0@@21| (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@239))))))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@239)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@239)) |lsn#0@@21|) (|MsgHistoryMod.MsgHistory.DiscardOld#canCall| (Lit this@@239) (LitInt |lsn#0@@21|)))) (= (MsgHistoryMod.MsgHistory.MaybeDiscardOld (Lit this@@239) (LitInt |lsn#0@@21|)) (ite (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@239)) |lsn#0@@21|) (MsgHistoryMod.MsgHistory.DiscardOld (Lit this@@239) (LitInt |lsn#0@@21|)) this@@239))))
 :qid |MsgHistoryidfy.130:14|
 :weight 3
 :skolemid |3828|
 :pattern ( (MsgHistoryMod.MsgHistory.MaybeDiscardOld (Lit this@@239) (LitInt |lsn#0@@21|)))
))))
(assert  (=> true (forall ((this@@240 T@U) (|lsn#0@@22| Int) ) (!  (=> (and (= (type this@@240) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@240 |lsn#0@@22|) (and (and ($Is this@@240 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@22|)) (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@240 |lsn#0@@22|) (MsgHistoryMod.MsgHistory.WF this@@240))))) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.MsgHistory.DiscardRecent this@@240 |lsn#0@@22|)) ($Is (MsgHistoryMod.MsgHistory.DiscardRecent this@@240 |lsn#0@@22|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |3829|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent this@@240 |lsn#0@@22|))
))))
(assert (forall ((this@@241 T@U) (|lsn#0@@23| Int) ) (!  (=> (= (type this@@241) DatatypeTypeType) (=> (and ($Is this@@241 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@23|)) (= (|MsgHistoryMod.MsgHistory.DiscardRecent#requires| this@@241 |lsn#0@@23|)  (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@241 |lsn#0@@23|) (MsgHistoryMod.MsgHistory.WF this@@241)))))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |3830|
 :pattern ( (|MsgHistoryMod.MsgHistory.DiscardRecent#requires| this@@241 |lsn#0@@23|))
)))
(assert  (=> true (forall ((this@@242 T@U) (|lsn#0@@24| Int) ) (!  (=> (and (= (type this@@242) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| this@@242 |lsn#0@@24|) (and (and ($Is this@@242 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@24|)) (and (MsgHistoryMod.MsgHistory.CanDiscardTo this@@242 |lsn#0@@24|) (MsgHistoryMod.MsgHistory.WF this@@242))))) (and (and (forall ((|k#0@@67| T@U) ) (!  (=> (= (type |k#0@@67|) intType) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@242) (=> (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@242) (U_2_int |k#0@@67|)) (INTERNAL_lt_boogie (U_2_int |k#0@@67|) |lsn#0@@24|)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@242))))
 :qid |MsgHistoryidfy.145:26|
 :skolemid |3831|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@242)) ($Box |k#0@@67|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@242)) (= (MsgHistoryMod.MsgHistory.DiscardRecent this@@242 |lsn#0@@24|) (let ((|keepMap#0@@0| (|Map#Glue| (|lambda#248| TInt (MsgHistoryMod.MsgHistory.seqStart this@@242) |lsn#0@@24|) (|lambda#185| (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@242))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#0@@0| (MsgHistoryMod.MsgHistory.seqStart this@@242) |lsn#0@@24|)))))
 :qid |MsgHistoryidfy.140:14|
 :skolemid |3832|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent this@@242 |lsn#0@@24|))
))))
(assert  (=> true (forall ((this@@243 T@U) (|lsn#0@@25| Int) ) (!  (=> (and (= (type this@@243) DatatypeTypeType) (or (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit this@@243) (LitInt |lsn#0@@25|)) (and (and ($Is this@@243 Tclass.MsgHistoryMod.MsgHistory) (INTERNAL_le_boogie 0 |lsn#0@@25|)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanDiscardTo (Lit this@@243) (LitInt |lsn#0@@25|))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@243))))))))) (and (and (forall ((|k#0@@68| T@U) ) (!  (=> (= (type |k#0@@68|) intType) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@243)) (=> (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@243)) (U_2_int |k#0@@68|)) (INTERNAL_lt_boogie (U_2_int |k#0@@68|) |lsn#0@@25|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@243)))))
 :qid |MsgHistoryidfy.145:26|
 :skolemid |3833|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@243)) ($Box |k#0@@68|))))
)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@243))) (= (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@243) (LitInt |lsn#0@@25|)) (let ((|keepMap#1@@0| (|Map#Glue| (|lambda#248| TInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@243)) |lsn#0@@25|) (|lambda#185| (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@243))))) (TMap TInt Tclass.MsgHistoryMod.KeyedMessage))))
(|#MsgHistoryMod.MsgHistory.MsgHistory| |keepMap#1@@0| (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit this@@243))) (LitInt |lsn#0@@25|))))))
 :qid |MsgHistoryidfy.140:14|
 :weight 3
 :skolemid |3834|
 :pattern ( (MsgHistoryMod.MsgHistory.DiscardRecent (Lit this@@243) (LitInt |lsn#0@@25|)))
))))
(assert  (=> true (forall ((this@@244 T@U) (|subseq#0| T@U) ) (!  (=> (and (and (and (= (type this@@244) DatatypeTypeType) (= (type |subseq#0|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| this@@244 |subseq#0|) (and (and ($Is this@@244 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@244) (MsgHistoryMod.MsgHistory.WF |subseq#0|))))) (and (MsgHistoryMod.MsgHistory.IncludesSubseq this@@244 |subseq#0|) (MsgHistoryMod.MsgHistory.IsEmpty this@@244))) (MsgHistoryMod.MsgHistory.IsEmpty |subseq#0|))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |3835|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq this@@244 |subseq#0|))
))))
(assert (forall ((this@@245 T@U) (|subseq#0@@0| T@U) ) (!  (=> (and (and (= (type this@@245) DatatypeTypeType) (= (type |subseq#0@@0|) DatatypeTypeType)) (and ($Is this@@245 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@0| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.MsgHistory.IncludesSubseq#requires| this@@245 |subseq#0@@0|)  (and (MsgHistoryMod.MsgHistory.WF this@@245) (MsgHistoryMod.MsgHistory.WF |subseq#0@@0|))))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |3836|
 :pattern ( (|MsgHistoryMod.MsgHistory.IncludesSubseq#requires| this@@245 |subseq#0@@0|))
)))
(assert  (=> true (forall ((this@@246 T@U) (|subseq#0@@1| T@U) ) (!  (=> (and (and (= (type this@@246) DatatypeTypeType) (= (type |subseq#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| this@@246 |subseq#0@@1|) (and (and ($Is this@@246 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF this@@246) (MsgHistoryMod.MsgHistory.WF |subseq#0@@1|))))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@246) (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@246) (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|)) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|) (MsgHistoryMod.MsgHistory.MsgHistory_q this@@246)) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|) (MsgHistoryMod.MsgHistory.seqEnd this@@246)) (forall ((|lsn#0@@26| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@26|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| |subseq#0@@1| |lsn#0@@26|) (=> (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@26|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| this@@246 |lsn#0@@26|) (=> (MsgHistoryMod.MsgHistory.Contains this@@246 |lsn#0@@26|) (and (and (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@246)) ($Box (int_2_U |lsn#0@@26|))))) (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@26|)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q this@@246) (MsgHistoryMod.MsgHistory.MsgHistory_q |subseq#0@@1|))))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |3838|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@26|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@246)) ($Box (int_2_U |lsn#0@@26|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@246 |lsn#0@@26|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@26|))
)))))) (= (MsgHistoryMod.MsgHistory.IncludesSubseq this@@246 |subseq#0@@1|)  (and (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart this@@246) (MsgHistoryMod.MsgHistory.seqStart |subseq#0@@1|)) (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd |subseq#0@@1|) (MsgHistoryMod.MsgHistory.seqEnd this@@246))) (let ((|result#0| (forall ((|lsn#0@@27| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |lsn#0@@27|) (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@27|)) (and (MsgHistoryMod.MsgHistory.Contains this@@246 |lsn#0@@27|) (|MsgHistoryMod.KeyedMessage#Equal| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@246)) ($Box (int_2_U |lsn#0@@27|)))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@27|)))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |3837|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@1|)) ($Box (int_2_U |lsn#0@@27|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@246)) ($Box (int_2_U |lsn#0@@27|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@246 |lsn#0@@27|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@1| |lsn#0@@27|))
))))
|result#0|)))))
 :qid |MsgHistoryidfy.149:15|
 :skolemid |3840|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq this@@246 |subseq#0@@1|))
))))
(assert  (=> true (forall ((this@@247 T@U) (|subseq#0@@2| T@U) ) (!  (=> (and (and (= (type this@@247) DatatypeTypeType) (= (type |subseq#0@@2|) DatatypeTypeType)) (or (|MsgHistoryMod.MsgHistory.IncludesSubseq#canCall| (Lit this@@247) (Lit |subseq#0@@2|)) (and (and ($Is this@@247 Tclass.MsgHistoryMod.MsgHistory) ($Is |subseq#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit this@@247))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |subseq#0@@2|))))))))) (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@247)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@247)) (MsgHistoryMod.MsgHistory.seqStart (Lit |subseq#0@@2|))) (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@247))) (=> (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@247))) (forall ((|lsn#1@@2| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#1@@2|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit |subseq#0@@2|) |lsn#1@@2|) (=> (MsgHistoryMod.MsgHistory.Contains (Lit |subseq#0@@2|) |lsn#1@@2|) (and (|MsgHistoryMod.MsgHistory.Contains#canCall| (Lit this@@247) |lsn#1@@2|) (=> (MsgHistoryMod.MsgHistory.Contains (Lit this@@247) |lsn#1@@2|) (and (and (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@247)))) ($Box (int_2_U |lsn#1@@2|))))) (|$IsA#MsgHistoryMod.KeyedMessage| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |subseq#0@@2|)))) ($Box (int_2_U |lsn#1@@2|)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit this@@247)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |subseq#0@@2|)))))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |3842|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@2|)) ($Box (int_2_U |lsn#1@@2|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@247)) ($Box (int_2_U |lsn#1@@2|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@247 |lsn#1@@2|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@2| |lsn#1@@2|))
)))))) (= (MsgHistoryMod.MsgHistory.IncludesSubseq (Lit this@@247) (Lit |subseq#0@@2|))  (and (and (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqStart (Lit this@@247)) (MsgHistoryMod.MsgHistory.seqStart (Lit |subseq#0@@2|))) (INTERNAL_le_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |subseq#0@@2|)) (MsgHistoryMod.MsgHistory.seqEnd (Lit this@@247)))) (let ((|result#1| (forall ((|lsn#1@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |lsn#1@@3|) (MsgHistoryMod.MsgHistory.Contains (Lit |subseq#0@@2|) |lsn#1@@3|)) (and (MsgHistoryMod.MsgHistory.Contains (Lit this@@247) |lsn#1@@3|) (|MsgHistoryMod.KeyedMessage#Equal| ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit this@@247)))) ($Box (int_2_U |lsn#1@@3|)))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |subseq#0@@2|)))) ($Box (int_2_U |lsn#1@@3|)))))))
 :qid |MsgHistoryidfy.156:31|
 :skolemid |3841|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |subseq#0@@2|)) ($Box (int_2_U |lsn#1@@3|)))))
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs this@@247)) ($Box (int_2_U |lsn#1@@3|)))))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains this@@247 |lsn#1@@3|))
 :pattern ( (MsgHistoryMod.MsgHistory.Contains |subseq#0@@2| |lsn#1@@3|))
))))
|result#1|)))))
 :qid |MsgHistoryidfy.149:15|
 :weight 3
 :skolemid |3844|
 :pattern ( (MsgHistoryMod.MsgHistory.IncludesSubseq (Lit this@@247) (Lit |subseq#0@@2|)))
))))
(assert (= (type Tclass.MsgHistoryMod.__default) TyType))
(assert (= (Tag Tclass.MsgHistoryMod.__default) Tagclass.MsgHistoryMod.__default))
(assert (= (TagFamily Tclass.MsgHistoryMod.__default) tytagFamily$_default))
(assert (forall ((bx@@157 T@U) ) (!  (=> (and (= (type bx@@157) BoxType) ($IsBox bx@@157 Tclass.MsgHistoryMod.__default)) (and (= ($Box ($Unbox refType bx@@157)) bx@@157) ($Is ($Unbox refType bx@@157) Tclass.MsgHistoryMod.__default)))
 :qid |unknown.0:0|
 :skolemid |3845|
 :pattern ( ($IsBox bx@@157 Tclass.MsgHistoryMod.__default))
)))
(assert (forall (($o@@45 T@U) ) (!  (=> (= (type $o@@45) refType) (= ($Is $o@@45 Tclass.MsgHistoryMod.__default)  (or (= $o@@45 null) (= (dtype $o@@45) Tclass.MsgHistoryMod.__default))))
 :qid |unknown.0:0|
 :skolemid |3846|
 :pattern ( ($Is $o@@45 Tclass.MsgHistoryMod.__default))
)))
(assert (forall (($o@@46 T@U) ($h@@147 T@U) ) (!  (=> (and (= (type $o@@46) refType) (= (type $h@@147) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@147)  (or (= $o@@46 null) (U_2_bool (MapType1Select (MapType0Select $h@@147 $o@@46) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3847|
 :pattern ( ($IsAlloc $o@@46 Tclass.MsgHistoryMod.__default $h@@147))
)))
(assert (forall ((arg0@@584 Int) ) (! (= (type (MsgHistoryMod.__default.EmptyHistoryAt arg0@@584)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.EmptyHistoryAt|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt arg0@@584))
)))
(assert  (=> true (forall ((|lsn#0@@28| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| |lsn#0@@28|) (INTERNAL_le_boogie 0 |lsn#0@@28|)) (and (MsgHistoryMod.MsgHistory.WF (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|)) ($Is (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|) Tclass.MsgHistoryMod.MsgHistory)))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |3848|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@28|))
))))
(assert (forall ((|lsn#0@@29| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@29|) (= (|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|) true))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |3849|
 :pattern ( (|MsgHistoryMod.__default.EmptyHistoryAt#requires| |lsn#0@@29|))
)))
(assert  (=> true (forall ((|lsn#0@@30| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| |lsn#0@@30|) (INTERNAL_le_boogie 0 |lsn#0@@30|)) (= (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@30|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Empty| BoxType BoxType)) |lsn#0@@30| |lsn#0@@30|)))
 :qid |MsgHistoryidfy.162:27|
 :skolemid |3850|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt |lsn#0@@30|))
))))
(assert  (=> true (forall ((|lsn#0@@31| Int) ) (!  (=> (or (|MsgHistoryMod.__default.EmptyHistoryAt#canCall| (LitInt |lsn#0@@31|)) (INTERNAL_le_boogie 0 |lsn#0@@31|)) (= (MsgHistoryMod.__default.EmptyHistoryAt (LitInt |lsn#0@@31|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Empty| BoxType BoxType)) (LitInt |lsn#0@@31|) (LitInt |lsn#0@@31|)))))
 :qid |MsgHistoryidfy.162:27|
 :weight 3
 :skolemid |3851|
 :pattern ( (MsgHistoryMod.__default.EmptyHistoryAt (LitInt |lsn#0@@31|)))
))))
(assert (forall ((arg0@@585 Int) (arg1@@293 T@U) ) (! (= (type (MsgHistoryMod.__default.SingletonAt arg0@@585 arg1@@293)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.SingletonAt|
 :pattern ( (MsgHistoryMod.__default.SingletonAt arg0@@585 arg1@@293))
)))
(assert  (=> true (forall ((|lsn#0@@32| Int) (|msg#0@@3| T@U) ) (!  (=> (and (= (type |msg#0@@3|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| |lsn#0@@32| |msg#0@@3|) (and (INTERNAL_le_boogie 0 |lsn#0@@32|) ($Is |msg#0@@3| Tclass.MsgHistoryMod.KeyedMessage)))) ($Is (MsgHistoryMod.__default.SingletonAt |lsn#0@@32| |msg#0@@3|) Tclass.MsgHistoryMod.MsgHistory))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |3852|
 :pattern ( (MsgHistoryMod.__default.SingletonAt |lsn#0@@32| |msg#0@@3|))
))))
(assert (forall ((|lsn#0@@33| Int) (|msg#0@@4| T@U) ) (!  (=> (= (type |msg#0@@4|) DatatypeTypeType) (=> (and (INTERNAL_le_boogie 0 |lsn#0@@33|) ($Is |msg#0@@4| Tclass.MsgHistoryMod.KeyedMessage)) (= (|MsgHistoryMod.__default.SingletonAt#requires| |lsn#0@@33| |msg#0@@4|) true)))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |3853|
 :pattern ( (|MsgHistoryMod.__default.SingletonAt#requires| |lsn#0@@33| |msg#0@@4|))
)))
(assert  (=> true (forall ((|lsn#0@@34| Int) (|msg#0@@5| T@U) ) (!  (=> (and (= (type |msg#0@@5|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| |lsn#0@@34| |msg#0@@5|) (and (INTERNAL_le_boogie 0 |lsn#0@@34|) ($Is |msg#0@@5| Tclass.MsgHistoryMod.KeyedMessage)))) (= (MsgHistoryMod.__default.SingletonAt |lsn#0@@34| |msg#0@@5|) (|#MsgHistoryMod.MsgHistory.MsgHistory| (|Map#Build| (|Map#Empty| BoxType BoxType) ($Box (int_2_U |lsn#0@@34|)) ($Box |msg#0@@5|)) |lsn#0@@34| (INTERNAL_add_boogie |lsn#0@@34| 1))))
 :qid |MsgHistoryidfy.168:24|
 :skolemid |3854|
 :pattern ( (MsgHistoryMod.__default.SingletonAt |lsn#0@@34| |msg#0@@5|))
))))
(assert  (=> true (forall ((|lsn#0@@35| Int) (|msg#0@@6| T@U) ) (!  (=> (and (= (type |msg#0@@6|) DatatypeTypeType) (or (|MsgHistoryMod.__default.SingletonAt#canCall| (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)) (and (INTERNAL_le_boogie 0 |lsn#0@@35|) ($Is |msg#0@@6| Tclass.MsgHistoryMod.KeyedMessage)))) (= (MsgHistoryMod.__default.SingletonAt (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)) (Lit (|#MsgHistoryMod.MsgHistory.MsgHistory| (Lit (|Map#Build| (|Map#Empty| BoxType BoxType) ($Box (int_2_U (LitInt |lsn#0@@35|))) ($Box (Lit |msg#0@@6|)))) (LitInt |lsn#0@@35|) (LitInt (INTERNAL_add_boogie |lsn#0@@35| 1))))))
 :qid |MsgHistoryidfy.168:24|
 :weight 3
 :skolemid |3855|
 :pattern ( (MsgHistoryMod.__default.SingletonAt (LitInt |lsn#0@@35|) (Lit |msg#0@@6|)))
))))
(assert (forall ((arg0@@586 T@U) (arg1@@294 T@U) ) (! (= (type (MsgHistoryMod.__default.MapPlusHistory arg0@@586 arg1@@294)) DatatypeTypeType)
 :qid |funType:MsgHistoryMod.__default.MapPlusHistory|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory arg0@@586 arg1@@294))
)))
(assert  (=> true (forall ((|stampedMap#0| T@U) (|history#0| T@U) ) (!  (=> (and (and (= (type |stampedMap#0|) DatatypeTypeType) (= (type |history#0|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| |stampedMap#0| |history#0|) (and (and ($Is |stampedMap#0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |history#0|) (MsgHistoryMod.MsgHistory.CanFollow |history#0| (StampedMod.Stamped.seqEnd |stampedMap#0|)))))) ($Is (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0| |history#0|) (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |3856|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0| |history#0|))
))))
(assert (forall ((|stampedMap#0@@0| T@U) (|history#0@@0| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@0|) DatatypeTypeType) (= (type |history#0@@0|) DatatypeTypeType)) (and ($Is |stampedMap#0@@0| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@0| Tclass.MsgHistoryMod.MsgHistory))) (= (|MsgHistoryMod.__default.MapPlusHistory#requires| |stampedMap#0@@0| |history#0@@0|)  (and (MsgHistoryMod.MsgHistory.WF |history#0@@0|) (MsgHistoryMod.MsgHistory.CanFollow |history#0@@0| (StampedMod.Stamped.seqEnd |stampedMap#0@@0|)))))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |3857|
 :pattern ( (|MsgHistoryMod.__default.MapPlusHistory#requires| |stampedMap#0@@0| |history#0@@0|))
)))
(assert  (=> true (forall ((|stampedMap#0@@1| T@U) (|history#0@@1| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@1|) DatatypeTypeType) (= (type |history#0@@1|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| |stampedMap#0@@1| |history#0@@1|) (and (and ($Is |stampedMap#0@@1| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |history#0@@1|) (MsgHistoryMod.MsgHistory.CanFollow |history#0@@1| (StampedMod.Stamped.seqEnd |stampedMap#0@@1|)))))) (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| |history#0@@1| |stampedMap#0@@1|) (= (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0@@1| |history#0@@1|) (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $LZ) |history#0@@1| |stampedMap#0@@1|))))
 :qid |MsgHistoryidfy.178:27|
 :skolemid |3858|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory |stampedMap#0@@1| |history#0@@1|))
))))
(assert  (=> true (forall ((|stampedMap#0@@2| T@U) (|history#0@@2| T@U) ) (!  (=> (and (and (= (type |stampedMap#0@@2|) DatatypeTypeType) (= (type |history#0@@2|) DatatypeTypeType)) (or (|MsgHistoryMod.__default.MapPlusHistory#canCall| (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)) (and (and ($Is |stampedMap#0@@2| (Tclass.StampedMod.Stamped Tclass.TotalKMMapMod.TotalMap)) ($Is |history#0@@2| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |history#0@@2|))))) (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.CanFollow (Lit |history#0@@2|) (LitInt (StampedMod.Stamped.seqEnd (Lit |stampedMap#0@@2|))))))))))) (and (|MsgHistoryMod.MsgHistory.ApplyToStampedMap#canCall| (Lit |history#0@@2|) (Lit |stampedMap#0@@2|)) (= (MsgHistoryMod.__default.MapPlusHistory (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)) (Lit (MsgHistoryMod.MsgHistory.ApplyToStampedMap ($LS $LZ) (Lit |history#0@@2|) (Lit |stampedMap#0@@2|))))))
 :qid |MsgHistoryidfy.178:27|
 :weight 3
 :skolemid |3859|
 :pattern ( (MsgHistoryMod.__default.MapPlusHistory (Lit |stampedMap#0@@2|) (Lit |history#0@@2|)))
))))
(assert (forall ((|a#0#0#0@@8| T@U) ) (!  (=> (= (type |a#0#0#0@@8|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#Buffers.Buffer.Buffer| |a#0#0#0@@8|)) |##Buffers.Buffer.Buffer|))
 :qid |Buffersidfy.25:28|
 :skolemid |3860|
 :pattern ( (|#Buffers.Buffer.Buffer| |a#0#0#0@@8|))
)))
(assert (forall ((d@@137 T@U) ) (!  (=> (= (type d@@137) DatatypeTypeType) (= (Buffers.Buffer.Buffer_q d@@137) (= (DatatypeCtorId d@@137) |##Buffers.Buffer.Buffer|)))
 :qid |unknown.0:0|
 :skolemid |3861|
 :pattern ( (Buffers.Buffer.Buffer_q d@@137))
)))
(assert (forall ((d@@138 T@U) ) (!  (=> (and (= (type d@@138) DatatypeTypeType) (Buffers.Buffer.Buffer_q d@@138)) (exists ((|a#1#0#0@@8| T@U) ) (!  (and (= (type |a#1#0#0@@8|) (MapType BoxType BoxType)) (= d@@138 (|#Buffers.Buffer.Buffer| |a#1#0#0@@8|)))
 :qid |Buffersidfy.25:28|
 :skolemid |3862|
 :no-pattern (type |a#1#0#0@@8|)
 :no-pattern (U_2_int |a#1#0#0@@8|)
 :no-pattern (U_2_bool |a#1#0#0@@8|)
)))
 :qid |unknown.0:0|
 :skolemid |3863|
 :pattern ( (Buffers.Buffer.Buffer_q d@@138))
)))
(assert (forall ((|a#2#0#0@@8| T@U) ) (!  (=> (= (type |a#2#0#0@@8|) (MapType BoxType BoxType)) (= ($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@8|) Tclass.Buffers.Buffer) ($Is |a#2#0#0@@8| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))
 :qid |Buffersidfy.25:28|
 :skolemid |3864|
 :pattern ( ($Is (|#Buffers.Buffer.Buffer| |a#2#0#0@@8|) Tclass.Buffers.Buffer))
)))
(assert (forall ((|a#3#0#0@@8| T@U) ($h@@148 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@8|) (MapType BoxType BoxType)) (= (type $h@@148) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@148)) (= ($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@8|) Tclass.Buffers.Buffer $h@@148) ($IsAlloc |a#3#0#0@@8| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@148)))
 :qid |Buffersidfy.25:28|
 :skolemid |3865|
 :pattern ( ($IsAlloc (|#Buffers.Buffer.Buffer| |a#3#0#0@@8|) Tclass.Buffers.Buffer $h@@148))
)))
(assert (forall ((arg0@@587 T@U) ) (! (= (type (Buffers.Buffer.mapp arg0@@587)) (MapType BoxType BoxType))
 :qid |funType:Buffers.Buffer.mapp|
 :pattern ( (Buffers.Buffer.mapp arg0@@587))
)))
(assert (forall ((d@@139 T@U) ($h@@149 T@U) ) (!  (=> (and (and (= (type d@@139) DatatypeTypeType) (= (type $h@@149) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@149) (and (Buffers.Buffer.Buffer_q d@@139) ($IsAlloc d@@139 Tclass.Buffers.Buffer $h@@149)))) ($IsAlloc (Buffers.Buffer.mapp d@@139) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@149))
 :qid |unknown.0:0|
 :skolemid |3866|
 :pattern ( ($IsAlloc (Buffers.Buffer.mapp d@@139) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@149))
)))
(assert (forall ((|a#4#0#0@@8| T@U) ) (!  (=> (= (type |a#4#0#0@@8|) (MapType BoxType BoxType)) (= (|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@8|)) (Lit (|#Buffers.Buffer.Buffer| |a#4#0#0@@8|))))
 :qid |Buffersidfy.25:28|
 :skolemid |3867|
 :pattern ( (|#Buffers.Buffer.Buffer| (Lit |a#4#0#0@@8|)))
)))
(assert (forall ((|a#5#0#0@@9| T@U) ) (!  (=> (= (type |a#5#0#0@@9|) (MapType BoxType BoxType)) (= (Buffers.Buffer.mapp (|#Buffers.Buffer.Buffer| |a#5#0#0@@9|)) |a#5#0#0@@9|))
 :qid |Buffersidfy.25:28|
 :skolemid |3868|
 :pattern ( (|#Buffers.Buffer.Buffer| |a#5#0#0@@9|))
)))
(assert (forall ((|a#6#0#0@@9| T@U) (d@@140 T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@9|) (MapType BoxType BoxType)) (= (type d@@140) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@9|) ($Box d@@140)))) (< (DtRank d@@140) (DtRank (|#Buffers.Buffer.Buffer| |a#6#0#0@@9|))))
 :qid |Buffersidfy.25:28|
 :skolemid |3869|
 :pattern ( (MapType0Select (|Map#Domain| |a#6#0#0@@9|) ($Box d@@140)) (|#Buffers.Buffer.Buffer| |a#6#0#0@@9|))
)))
(assert (forall ((|a#7#0#0@@8| T@U) (bx@@158 T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@8|) (MapType BoxType BoxType)) (= (type bx@@158) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@8|) bx@@158))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#7#0#0@@8|) bx@@158))) (DtRank (|#Buffers.Buffer.Buffer| |a#7#0#0@@8|))))
 :qid |Buffersidfy.25:28|
 :skolemid |3870|
 :pattern ( (MapType0Select (|Map#Domain| |a#7#0#0@@8|) bx@@158) (|#Buffers.Buffer.Buffer| |a#7#0#0@@8|))
)))
(assert (forall ((d@@141 T@U) ) (!  (=> (and (= (type d@@141) DatatypeTypeType) (|$IsA#Buffers.Buffer| d@@141)) (Buffers.Buffer.Buffer_q d@@141))
 :qid |unknown.0:0|
 :skolemid |3871|
 :pattern ( (|$IsA#Buffers.Buffer| d@@141))
)))
(assert (forall ((d@@142 T@U) ) (!  (=> (and (= (type d@@142) DatatypeTypeType) ($Is d@@142 Tclass.Buffers.Buffer)) (Buffers.Buffer.Buffer_q d@@142))
 :qid |unknown.0:0|
 :skolemid |3872|
 :pattern ( (Buffers.Buffer.Buffer_q d@@142) ($Is d@@142 Tclass.Buffers.Buffer))
)))
(assert (forall ((a@@160 T@U) (b@@110 T@U) ) (!  (=> (and (and (= (type a@@160) DatatypeTypeType) (= (type b@@110) DatatypeTypeType)) true) (= (|Buffers.Buffer#Equal| a@@160 b@@110) (|Map#Equal| (Buffers.Buffer.mapp a@@160) (Buffers.Buffer.mapp b@@110))))
 :qid |unknown.0:0|
 :skolemid |3873|
 :pattern ( (|Buffers.Buffer#Equal| a@@160 b@@110))
)))
(assert (forall ((a@@161 T@U) (b@@111 T@U) ) (!  (=> (and (= (type a@@161) DatatypeTypeType) (= (type b@@111) DatatypeTypeType)) (= (|Buffers.Buffer#Equal| a@@161 b@@111) (= a@@161 b@@111)))
 :qid |unknown.0:0|
 :skolemid |3874|
 :pattern ( (|Buffers.Buffer#Equal| a@@161 b@@111))
)))
(assert (forall ((arg0@@588 T@U) (arg1@@295 T@U) ) (! (= (type (Buffers.Buffer.Query arg0@@588 arg1@@295)) DatatypeTypeType)
 :qid |funType:Buffers.Buffer.Query|
 :pattern ( (Buffers.Buffer.Query arg0@@588 arg1@@295))
)))
(assert  (=> true (forall ((this@@248 T@U) (|key#0@@29| T@U) ) (!  (=> (and (and (= (type this@@248) DatatypeTypeType) (= (type |key#0@@29|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| this@@248 |key#0@@29|) (and ($Is this@@248 Tclass.Buffers.Buffer) ($Is |key#0@@29| Tclass.KeyType.Key)))) ($Is (Buffers.Buffer.Query this@@248 |key#0@@29|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.27:14|
 :skolemid |3875|
 :pattern ( (Buffers.Buffer.Query this@@248 |key#0@@29|))
))))
(assert (forall ((this@@249 T@U) (|key#0@@30| T@U) ) (!  (=> (and (and (= (type this@@249) DatatypeTypeType) (= (type |key#0@@30|) (SeqType BoxType))) (and ($Is this@@249 Tclass.Buffers.Buffer) ($Is |key#0@@30| Tclass.KeyType.Key))) (= (|Buffers.Buffer.Query#requires| this@@249 |key#0@@30|) true))
 :qid |Buffersidfy.27:14|
 :skolemid |3876|
 :pattern ( (|Buffers.Buffer.Query#requires| this@@249 |key#0@@30|))
)))
(assert  (=> true (forall ((this@@250 T@U) (|key#0@@31| T@U) ) (!  (=> (and (and (= (type this@@250) DatatypeTypeType) (= (type |key#0@@31|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| this@@250 |key#0@@31|) (and ($Is this@@250 Tclass.Buffers.Buffer) ($Is |key#0@@31| Tclass.KeyType.Key)))) (and (and (and (Buffers.Buffer.Buffer_q this@@250) (=> (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@250)) ($Box |key#0@@31|))) (Buffers.Buffer.Buffer_q this@@250))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@250)) ($Box |key#0@@31|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (Buffers.Buffer.Query this@@250 |key#0@@31|) (ite (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@250)) ($Box |key#0@@31|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@250)) ($Box |key#0@@31|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Buffersidfy.27:14|
 :skolemid |3877|
 :pattern ( (Buffers.Buffer.Query this@@250 |key#0@@31|))
))))
(assert  (=> true (forall ((this@@251 T@U) (|key#0@@32| T@U) ) (!  (=> (and (and (= (type this@@251) DatatypeTypeType) (= (type |key#0@@32|) (SeqType BoxType))) (or (|Buffers.Buffer.Query#canCall| (Lit this@@251) (Lit |key#0@@32|)) (and ($Is this@@251 Tclass.Buffers.Buffer) ($Is |key#0@@32| Tclass.KeyType.Key)))) (and (and (and (Buffers.Buffer.Buffer_q (Lit this@@251)) (=> (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@251))) ($Box |key#0@@32|))) (Buffers.Buffer.Buffer_q (Lit this@@251)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@251))) ($Box |key#0@@32|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (Buffers.Buffer.Query (Lit this@@251) (Lit |key#0@@32|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@251))) ($Box |key#0@@32|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@251)))) ($Box (Lit |key#0@@32|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Buffersidfy.27:14|
 :weight 3
 :skolemid |3878|
 :pattern ( (Buffers.Buffer.Query (Lit this@@251) (Lit |key#0@@32|)))
))))
(assert (forall ((arg0@@589 T@U) (arg1@@296 T@U) ) (! (= (type (Buffers.Buffer.ApplyFilter arg0@@589 arg1@@296)) DatatypeTypeType)
 :qid |funType:Buffers.Buffer.ApplyFilter|
 :pattern ( (Buffers.Buffer.ApplyFilter arg0@@589 arg1@@296))
)))
(assert  (=> true (forall ((this@@252 T@U) (|accept#0| T@U) ) (!  (=> (and (and (= (type this@@252) DatatypeTypeType) (= (type |accept#0|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| this@@252 |accept#0|) (and ($Is this@@252 Tclass.Buffers.Buffer) ($Is |accept#0| (TISet Tclass.KeyType.Key))))) ($Is (Buffers.Buffer.ApplyFilter this@@252 |accept#0|) Tclass.Buffers.Buffer))
 :qid |Buffersidfy.32:14|
 :skolemid |3879|
 :pattern ( (Buffers.Buffer.ApplyFilter this@@252 |accept#0|))
))))
(assert (forall ((this@@253 T@U) (|accept#0@@0| T@U) ) (!  (=> (and (and (= (type this@@253) DatatypeTypeType) (= (type |accept#0@@0|) (MapType0Type BoxType boolType))) (and ($Is this@@253 Tclass.Buffers.Buffer) ($Is |accept#0@@0| (TISet Tclass.KeyType.Key)))) (= (|Buffers.Buffer.ApplyFilter#requires| this@@253 |accept#0@@0|) true))
 :qid |Buffersidfy.32:14|
 :skolemid |3880|
 :pattern ( (|Buffers.Buffer.ApplyFilter#requires| this@@253 |accept#0@@0|))
)))
(assert  (=> true (forall ((this@@254 T@U) (|accept#0@@1| T@U) ) (!  (=> (and (and (= (type this@@254) DatatypeTypeType) (= (type |accept#0@@1|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| this@@254 |accept#0@@1|) (and ($Is this@@254 Tclass.Buffers.Buffer) ($Is |accept#0@@1| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@69| T@U) ) (!  (=> (and (= (type |k#0@@69|) (SeqType BoxType)) ($Is |k#0@@69| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q this@@254) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@254)) ($Box |k#0@@69|))) (U_2_bool (MapType0Select |accept#0@@1| ($Box |k#0@@69|)))) (Buffers.Buffer.Buffer_q this@@254))))
 :qid |Buffersidfy.34:18|
 :skolemid |3881|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@254)) ($Box |k#0@@69|))))
 :pattern ( (MapType0Select |accept#0@@1| ($Box |k#0@@69|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@254)) ($Box |k#0@@69|)))
)) (= (Buffers.Buffer.ApplyFilter this@@254 |accept#0@@1|) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#206| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp this@@254)) |accept#0@@1|) (|lambda#185| (|Map#Elements| (Buffers.Buffer.mapp this@@254))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :skolemid |3882|
 :pattern ( (Buffers.Buffer.ApplyFilter this@@254 |accept#0@@1|))
))))
(assert  (=> true (forall ((this@@255 T@U) (|accept#0@@2| T@U) ) (!  (=> (and (and (= (type this@@255) DatatypeTypeType) (= (type |accept#0@@2|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| (Lit this@@255) |accept#0@@2|) (and ($Is this@@255 Tclass.Buffers.Buffer) ($Is |accept#0@@2| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@70| T@U) ) (!  (=> (and (= (type |k#0@@70|) (SeqType BoxType)) ($Is |k#0@@70| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q (Lit this@@255)) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@255))) ($Box |k#0@@70|))) (U_2_bool (MapType0Select |accept#0@@2| ($Box |k#0@@70|)))) (Buffers.Buffer.Buffer_q (Lit this@@255)))))
 :qid |Buffersidfy.34:18|
 :skolemid |3883|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@255)) ($Box |k#0@@70|))))
 :pattern ( (MapType0Select |accept#0@@2| ($Box |k#0@@70|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@255)) ($Box |k#0@@70|)))
)) (= (Buffers.Buffer.ApplyFilter (Lit this@@255) |accept#0@@2|) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#206| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@255))) |accept#0@@2|) (|lambda#185| (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@255))))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :weight 3
 :skolemid |3884|
 :pattern ( (Buffers.Buffer.ApplyFilter (Lit this@@255) |accept#0@@2|))
))))
(assert  (=> true (forall ((this@@256 T@U) (|accept#0@@3| T@U) ) (!  (=> (and (and (= (type this@@256) DatatypeTypeType) (= (type |accept#0@@3|) (MapType0Type BoxType boolType))) (or (|Buffers.Buffer.ApplyFilter#canCall| (Lit this@@256) (Lit |accept#0@@3|)) (and ($Is this@@256 Tclass.Buffers.Buffer) ($Is |accept#0@@3| (TISet Tclass.KeyType.Key))))) (and (forall ((|k#0@@71| T@U) ) (!  (=> (and (= (type |k#0@@71|) (SeqType BoxType)) ($Is |k#0@@71| Tclass.KeyType.Key)) (and (Buffers.Buffer.Buffer_q (Lit this@@256)) (=> (and (U_2_bool (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@256))) ($Box |k#0@@71|))) (U_2_bool (MapType0Select (Lit |accept#0@@3|) ($Box |k#0@@71|)))) (Buffers.Buffer.Buffer_q (Lit this@@256)))))
 :qid |Buffersidfy.34:18|
 :skolemid |3885|
 :pattern ( ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Buffers.Buffer.mapp this@@256)) ($Box |k#0@@71|))))
 :pattern ( (MapType0Select |accept#0@@3| ($Box |k#0@@71|)))
 :pattern ( (MapType0Select (|Map#Domain| (Buffers.Buffer.mapp this@@256)) ($Box |k#0@@71|)))
)) (= (Buffers.Buffer.ApplyFilter (Lit this@@256) (Lit |accept#0@@3|)) (|#Buffers.Buffer.Buffer| (|Map#Glue| (|lambda#206| Tclass.KeyType.Key (|Map#Domain| (Buffers.Buffer.mapp (Lit this@@256))) (Lit |accept#0@@3|)) (|lambda#185| (|Map#Elements| (Lit (Buffers.Buffer.mapp (Lit this@@256))))) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message))))))
 :qid |Buffersidfy.32:14|
 :weight 3
 :skolemid |3886|
 :pattern ( (Buffers.Buffer.ApplyFilter (Lit this@@256) (Lit |accept#0@@3|)))
))))
(assert (forall ((|a#0#0#0@@9| T@U) ) (!  (=> (= (type |a#0#0#0@@9|) (SeqType BoxType)) (= (DatatypeCtorId (|#Buffers.BufferStack.BufferStack| |a#0#0#0@@9|)) |##Buffers.BufferStack.BufferStack|))
 :qid |Buffersidfy.39:38|
 :skolemid |3887|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#0#0#0@@9|))
)))
(assert (forall ((d@@143 T@U) ) (!  (=> (= (type d@@143) DatatypeTypeType) (= (Buffers.BufferStack.BufferStack_q d@@143) (= (DatatypeCtorId d@@143) |##Buffers.BufferStack.BufferStack|)))
 :qid |unknown.0:0|
 :skolemid |3888|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@143))
)))
(assert (forall ((d@@144 T@U) ) (!  (=> (and (= (type d@@144) DatatypeTypeType) (Buffers.BufferStack.BufferStack_q d@@144)) (exists ((|a#1#0#0@@9| T@U) ) (!  (and (= (type |a#1#0#0@@9|) (SeqType BoxType)) (= d@@144 (|#Buffers.BufferStack.BufferStack| |a#1#0#0@@9|)))
 :qid |Buffersidfy.39:38|
 :skolemid |3889|
 :no-pattern (type |a#1#0#0@@9|)
 :no-pattern (U_2_int |a#1#0#0@@9|)
 :no-pattern (U_2_bool |a#1#0#0@@9|)
)))
 :qid |unknown.0:0|
 :skolemid |3890|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@144))
)))
(assert (forall ((|a#2#0#0@@9| T@U) ) (!  (=> (= (type |a#2#0#0@@9|) (SeqType BoxType)) (= ($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@9|) Tclass.Buffers.BufferStack) ($Is |a#2#0#0@@9| (TSeq Tclass.Buffers.Buffer))))
 :qid |Buffersidfy.39:38|
 :skolemid |3891|
 :pattern ( ($Is (|#Buffers.BufferStack.BufferStack| |a#2#0#0@@9|) Tclass.Buffers.BufferStack))
)))
(assert (forall ((|a#3#0#0@@9| T@U) ($h@@150 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@9|) (SeqType BoxType)) (= (type $h@@150) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@150)) (= ($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@9|) Tclass.Buffers.BufferStack $h@@150) ($IsAlloc |a#3#0#0@@9| (TSeq Tclass.Buffers.Buffer) $h@@150)))
 :qid |Buffersidfy.39:38|
 :skolemid |3892|
 :pattern ( ($IsAlloc (|#Buffers.BufferStack.BufferStack| |a#3#0#0@@9|) Tclass.Buffers.BufferStack $h@@150))
)))
(assert (forall ((arg0@@590 T@U) ) (! (= (type (Buffers.BufferStack.buffers arg0@@590)) (SeqType BoxType))
 :qid |funType:Buffers.BufferStack.buffers|
 :pattern ( (Buffers.BufferStack.buffers arg0@@590))
)))
(assert (forall ((d@@145 T@U) ($h@@151 T@U) ) (!  (=> (and (and (= (type d@@145) DatatypeTypeType) (= (type $h@@151) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@151) (and (Buffers.BufferStack.BufferStack_q d@@145) ($IsAlloc d@@145 Tclass.Buffers.BufferStack $h@@151)))) ($IsAlloc (Buffers.BufferStack.buffers d@@145) (TSeq Tclass.Buffers.Buffer) $h@@151))
 :qid |unknown.0:0|
 :skolemid |3893|
 :pattern ( ($IsAlloc (Buffers.BufferStack.buffers d@@145) (TSeq Tclass.Buffers.Buffer) $h@@151))
)))
(assert (forall ((|a#4#0#0@@9| T@U) ) (!  (=> (= (type |a#4#0#0@@9|) (SeqType BoxType)) (= (|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@9|)) (Lit (|#Buffers.BufferStack.BufferStack| |a#4#0#0@@9|))))
 :qid |Buffersidfy.39:38|
 :skolemid |3894|
 :pattern ( (|#Buffers.BufferStack.BufferStack| (Lit |a#4#0#0@@9|)))
)))
(assert (forall ((|a#5#0#0@@10| T@U) ) (!  (=> (= (type |a#5#0#0@@10|) (SeqType BoxType)) (= (Buffers.BufferStack.buffers (|#Buffers.BufferStack.BufferStack| |a#5#0#0@@10|)) |a#5#0#0@@10|))
 :qid |Buffersidfy.39:38|
 :skolemid |3895|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#5#0#0@@10|))
)))
(assert (forall ((|a#6#0#0@@10| T@U) (i@@28 Int) ) (!  (=> (= (type |a#6#0#0@@10|) (SeqType BoxType)) (=> (and (<= 0 i@@28) (< i@@28 (|Seq#Length| |a#6#0#0@@10|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#6#0#0@@10| i@@28))) (DtRank (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@10|)))))
 :qid |Buffersidfy.39:38|
 :skolemid |3896|
 :pattern ( (|Seq#Index| |a#6#0#0@@10| i@@28) (|#Buffers.BufferStack.BufferStack| |a#6#0#0@@10|))
)))
(assert (forall ((|a#7#0#0@@9| T@U) ) (!  (=> (= (type |a#7#0#0@@9|) (SeqType BoxType)) (< (|Seq#Rank| |a#7#0#0@@9|) (DtRank (|#Buffers.BufferStack.BufferStack| |a#7#0#0@@9|))))
 :qid |Buffersidfy.39:38|
 :skolemid |3897|
 :pattern ( (|#Buffers.BufferStack.BufferStack| |a#7#0#0@@9|))
)))
(assert (forall ((d@@146 T@U) ) (!  (=> (and (= (type d@@146) DatatypeTypeType) (|$IsA#Buffers.BufferStack| d@@146)) (Buffers.BufferStack.BufferStack_q d@@146))
 :qid |unknown.0:0|
 :skolemid |3898|
 :pattern ( (|$IsA#Buffers.BufferStack| d@@146))
)))
(assert (forall ((d@@147 T@U) ) (!  (=> (and (= (type d@@147) DatatypeTypeType) ($Is d@@147 Tclass.Buffers.BufferStack)) (Buffers.BufferStack.BufferStack_q d@@147))
 :qid |unknown.0:0|
 :skolemid |3899|
 :pattern ( (Buffers.BufferStack.BufferStack_q d@@147) ($Is d@@147 Tclass.Buffers.BufferStack))
)))
(assert (forall ((a@@162 T@U) (b@@112 T@U) ) (!  (=> (and (and (= (type a@@162) DatatypeTypeType) (= (type b@@112) DatatypeTypeType)) true) (= (|Buffers.BufferStack#Equal| a@@162 b@@112) (|Seq#Equal| (Buffers.BufferStack.buffers a@@162) (Buffers.BufferStack.buffers b@@112))))
 :qid |unknown.0:0|
 :skolemid |3900|
 :pattern ( (|Buffers.BufferStack#Equal| a@@162 b@@112))
)))
(assert (forall ((a@@163 T@U) (b@@113 T@U) ) (!  (=> (and (= (type a@@163) DatatypeTypeType) (= (type b@@113) DatatypeTypeType)) (= (|Buffers.BufferStack#Equal| a@@163 b@@113) (= a@@163 b@@113)))
 :qid |unknown.0:0|
 :skolemid |3901|
 :pattern ( (|Buffers.BufferStack#Equal| a@@163 b@@113))
)))
(assert (forall ((arg0@@591 T@U) (arg1@@297 T@U) (arg2@@162 T@U) (arg3@@95 Int) ) (! (= (type (Buffers.BufferStack.QueryUpTo arg0@@591 arg1@@297 arg2@@162 arg3@@95)) DatatypeTypeType)
 :qid |funType:Buffers.BufferStack.QueryUpTo|
 :pattern ( (Buffers.BufferStack.QueryUpTo arg0@@591 arg1@@297 arg2@@162 arg3@@95))
)))
(assert (forall (($ly@@335 T@U) (this@@257 T@U) (|key#0@@33| T@U) (|count#0| Int) ) (!  (=> (and (and (= (type $ly@@335) LayerTypeType) (= (type this@@257) DatatypeTypeType)) (= (type |key#0@@33|) (SeqType BoxType))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@335) this@@257 |key#0@@33| |count#0|) (Buffers.BufferStack.QueryUpTo $ly@@335 this@@257 |key#0@@33| |count#0|)))
 :qid |Buffersidfy.41:14|
 :skolemid |3902|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@335) this@@257 |key#0@@33| |count#0|))
)))
(assert (forall (($ly@@336 T@U) (this@@258 T@U) (|key#0@@34| T@U) (|count#0@@0| Int) ) (!  (=> (and (and (= (type $ly@@336) LayerTypeType) (= (type this@@258) DatatypeTypeType)) (= (type |key#0@@34|) (SeqType BoxType))) (= (Buffers.BufferStack.QueryUpTo $ly@@336 this@@258 |key#0@@34| |count#0@@0|) (Buffers.BufferStack.QueryUpTo $LZ this@@258 |key#0@@34| |count#0@@0|)))
 :qid |Buffersidfy.41:14|
 :skolemid |3903|
 :pattern ( (Buffers.BufferStack.QueryUpTo (AsFuelBottom $ly@@336) this@@258 |key#0@@34| |count#0@@0|))
)))
(assert  (=> true (forall (($ly@@337 T@U) (this@@259 T@U) (|key#0@@35| T@U) (|count#0@@1| Int) ) (!  (=> (and (and (and (= (type $ly@@337) LayerTypeType) (= (type this@@259) DatatypeTypeType)) (= (type |key#0@@35|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| this@@259 |key#0@@35| |count#0@@1|) (and (and (and ($Is this@@259 Tclass.Buffers.BufferStack) ($Is |key#0@@35| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@1|)) (INTERNAL_le_boogie |count#0@@1| (|Seq#Length| (Buffers.BufferStack.buffers this@@259)))))) ($Is (Buffers.BufferStack.QueryUpTo $ly@@337 this@@259 |key#0@@35| |count#0@@1|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.41:14|
 :skolemid |3904|
 :pattern ( (Buffers.BufferStack.QueryUpTo $ly@@337 this@@259 |key#0@@35| |count#0@@1|))
))))
(assert (forall (($ly@@338 T@U) (this@@260 T@U) (|key#0@@36| T@U) (|count#0@@2| Int) ) (!  (=> (and (and (and (= (type $ly@@338) LayerTypeType) (= (type this@@260) DatatypeTypeType)) (= (type |key#0@@36|) (SeqType BoxType))) (and (and ($Is this@@260 Tclass.Buffers.BufferStack) ($Is |key#0@@36| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@2|))) (= (|Buffers.BufferStack.QueryUpTo#requires| $ly@@338 this@@260 |key#0@@36| |count#0@@2|) (INTERNAL_le_boogie |count#0@@2| (|Seq#Length| (Buffers.BufferStack.buffers this@@260)))))
 :qid |Buffersidfy.41:14|
 :skolemid |3905|
 :pattern ( (|Buffers.BufferStack.QueryUpTo#requires| $ly@@338 this@@260 |key#0@@36| |count#0@@2|))
)))
(assert  (=> true (forall (($ly@@339 T@U) (this@@261 T@U) (|key#0@@37| T@U) (|count#0@@3| Int) ) (!  (=> (and (and (and (= (type $ly@@339) LayerTypeType) (= (type this@@261) DatatypeTypeType)) (= (type |key#0@@37|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| this@@261 |key#0@@37| |count#0@@3|) (and (and (and ($Is this@@261 Tclass.Buffers.BufferStack) ($Is |key#0@@37| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@3|)) (INTERNAL_le_boogie |count#0@@3| (|Seq#Length| (Buffers.BufferStack.buffers this@@261)))))) (and (and (=> (= |count#0@@3| (LitInt 0)) |ValueMessage.__default.NopDelta#canCall|) (=> (not (= |count#0@@3| (LitInt 0))) (and (and (|Buffers.BufferStack.QueryUpTo#canCall| this@@261 |key#0@@37| (INTERNAL_sub_boogie |count#0@@3| 1)) (and (Buffers.BufferStack.BufferStack_q this@@261) (|Buffers.Buffer.Query#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@261) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@37|))) (|ValueMessage.__default.Merge#canCall| (Buffers.BufferStack.QueryUpTo $ly@@339 this@@261 |key#0@@37| (INTERNAL_sub_boogie |count#0@@3| 1)) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@261) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@37|))))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@339) this@@261 |key#0@@37| |count#0@@3|) (ite (= |count#0@@3| (LitInt 0)) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta)) (ValueMessage.__default.Merge (Buffers.BufferStack.QueryUpTo $ly@@339 this@@261 |key#0@@37| (INTERNAL_sub_boogie |count#0@@3| 1)) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@261) (INTERNAL_sub_boogie |count#0@@3| 1))) |key#0@@37|))))))
 :qid |Buffersidfy.41:14|
 :skolemid |3906|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@339) this@@261 |key#0@@37| |count#0@@3|))
))))
(assert  (=> true (forall (($ly@@340 T@U) (this@@262 T@U) (|key#0@@38| T@U) (|count#0@@4| Int) ) (!  (=> (and (and (and (= (type $ly@@340) LayerTypeType) (= (type this@@262) DatatypeTypeType)) (= (type |key#0@@38|) (SeqType BoxType))) (or (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@262) (Lit |key#0@@38|) (LitInt |count#0@@4|)) (and (and (and ($Is this@@262 Tclass.Buffers.BufferStack) ($Is |key#0@@38| Tclass.KeyType.Key)) (INTERNAL_le_boogie 0 |count#0@@4|)) (INTERNAL_le_boogie |count#0@@4| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@262)))))))) (and (and (=> (= (LitInt |count#0@@4|) (LitInt 0)) |ValueMessage.__default.NopDelta#canCall|) (=> (not (= (LitInt |count#0@@4|) (LitInt 0))) (and (and (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@262) (Lit |key#0@@38|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@262)) (|Buffers.Buffer.Query#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@262))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@38|)))) (|ValueMessage.__default.Merge#canCall| (Lit (Buffers.BufferStack.QueryUpTo ($LS $ly@@340) (Lit this@@262) (Lit |key#0@@38|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@262))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@38|)))))) (= (Buffers.BufferStack.QueryUpTo ($LS $ly@@340) (Lit this@@262) (Lit |key#0@@38|) (LitInt |count#0@@4|)) (ite (= (LitInt |count#0@@4|) (LitInt 0)) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta)) (ValueMessage.__default.Merge (Lit (Buffers.BufferStack.QueryUpTo ($LS $ly@@340) (Lit this@@262) (Lit |key#0@@38|) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Buffers.Buffer.Query ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@262))) (LitInt (INTERNAL_sub_boogie |count#0@@4| 1)))) (Lit |key#0@@38|)))))))
 :qid |Buffersidfy.41:14|
 :weight 3
 :skolemid |3907|
 :pattern ( (Buffers.BufferStack.QueryUpTo ($LS $ly@@340) (Lit this@@262) (Lit |key#0@@38|) (LitInt |count#0@@4|)))
))))
(assert  (=> true (forall ((this@@263 T@U) (|key#0@@39| T@U) ) (!  (=> (and (and (= (type this@@263) DatatypeTypeType) (= (type |key#0@@39|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| this@@263 |key#0@@39|) (and ($Is this@@263 Tclass.Buffers.BufferStack) ($Is |key#0@@39| Tclass.KeyType.Key)))) ($Is (Buffers.BufferStack.Query this@@263 |key#0@@39|) Tclass.ValueMessage.Message))
 :qid |Buffersidfy.48:14|
 :skolemid |3908|
 :pattern ( (Buffers.BufferStack.Query this@@263 |key#0@@39|))
))))
(assert (forall ((this@@264 T@U) (|key#0@@40| T@U) ) (!  (=> (and (and (= (type this@@264) DatatypeTypeType) (= (type |key#0@@40|) (SeqType BoxType))) (and ($Is this@@264 Tclass.Buffers.BufferStack) ($Is |key#0@@40| Tclass.KeyType.Key))) (= (|Buffers.BufferStack.Query#requires| this@@264 |key#0@@40|) true))
 :qid |Buffersidfy.48:14|
 :skolemid |3909|
 :pattern ( (|Buffers.BufferStack.Query#requires| this@@264 |key#0@@40|))
)))
(assert  (=> true (forall ((this@@265 T@U) (|key#0@@41| T@U) ) (!  (=> (and (and (= (type this@@265) DatatypeTypeType) (= (type |key#0@@41|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| this@@265 |key#0@@41|) (and ($Is this@@265 Tclass.Buffers.BufferStack) ($Is |key#0@@41| Tclass.KeyType.Key)))) (and (and (Buffers.BufferStack.BufferStack_q this@@265) (|Buffers.BufferStack.QueryUpTo#canCall| this@@265 |key#0@@41| (|Seq#Length| (Buffers.BufferStack.buffers this@@265)))) (= (Buffers.BufferStack.Query this@@265 |key#0@@41|) (Buffers.BufferStack.QueryUpTo ($LS $LZ) this@@265 |key#0@@41| (|Seq#Length| (Buffers.BufferStack.buffers this@@265))))))
 :qid |Buffersidfy.48:14|
 :skolemid |3910|
 :pattern ( (Buffers.BufferStack.Query this@@265 |key#0@@41|))
))))
(assert  (=> true (forall ((this@@266 T@U) (|key#0@@42| T@U) ) (!  (=> (and (and (= (type this@@266) DatatypeTypeType) (= (type |key#0@@42|) (SeqType BoxType))) (or (|Buffers.BufferStack.Query#canCall| (Lit this@@266) (Lit |key#0@@42|)) (and ($Is this@@266 Tclass.Buffers.BufferStack) ($Is |key#0@@42| Tclass.KeyType.Key)))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@266)) (|Buffers.BufferStack.QueryUpTo#canCall| (Lit this@@266) (Lit |key#0@@42|) (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@266)))))) (= (Buffers.BufferStack.Query (Lit this@@266) (Lit |key#0@@42|)) (Buffers.BufferStack.QueryUpTo ($LS $LZ) (Lit this@@266) (Lit |key#0@@42|) (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@266))))))))
 :qid |Buffersidfy.48:14|
 :weight 3
 :skolemid |3911|
 :pattern ( (Buffers.BufferStack.Query (Lit this@@266) (Lit |key#0@@42|)))
))))
(assert  (=> true (forall ((this@@267 T@U) (|accept#0@@4| T@U) ) (!  (=> (and (and (= (type this@@267) DatatypeTypeType) (= (type |accept#0@@4|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| this@@267 |accept#0@@4|) (and ($Is this@@267 Tclass.Buffers.BufferStack) ($Is |accept#0@@4| (TISet Tclass.KeyType.Key))))) ($Is (Buffers.BufferStack.ApplyFilter this@@267 |accept#0@@4|) Tclass.Buffers.BufferStack))
 :qid |Buffersidfy.53:14|
 :skolemid |3912|
 :pattern ( (Buffers.BufferStack.ApplyFilter this@@267 |accept#0@@4|))
))))
(assert (forall (($Heap@@53 T@U) (this@@268 T@U) (|accept#0@@5| T@U) ) (!  (=> (and (and (and (= (type $Heap@@53) (MapType0Type refType MapType1Type)) (= (type this@@268) DatatypeTypeType)) (= (type |accept#0@@5|) (MapType0Type BoxType boolType))) (and (and ($IsGoodHeap $Heap@@53) (and ($Is this@@268 Tclass.Buffers.BufferStack) ($IsAlloc this@@268 Tclass.Buffers.BufferStack $Heap@@53))) ($Is |accept#0@@5| (TISet Tclass.KeyType.Key)))) (= (|Buffers.BufferStack.ApplyFilter#requires| this@@268 |accept#0@@5|) true))
 :qid |Buffersidfy.53:14|
 :skolemid |3913|
 :pattern ( (|Buffers.BufferStack.ApplyFilter#requires| this@@268 |accept#0@@5|) ($IsGoodHeap $Heap@@53))
)))
(assert (forall ((arg0@@592 T@U) (arg1@@298 T@U) ) (! (= (type (|lambda#264| arg0@@592 arg1@@298)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#264|
 :pattern ( (|lambda#264| arg0@@592 arg1@@298))
)))
(assert  (=> true (forall (($Heap@@54 T@U) (this@@269 T@U) (|accept#0@@6| T@U) ) (!  (=> (and (and (and (= (type $Heap@@54) (MapType0Type refType MapType1Type)) (= (type this@@269) DatatypeTypeType)) (= (type |accept#0@@6|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| this@@269 |accept#0@@6|) (and (and ($IsGoodHeap $Heap@@54) (and ($Is this@@269 Tclass.Buffers.BufferStack) ($IsAlloc this@@269 Tclass.Buffers.BufferStack $Heap@@54))) ($Is |accept#0@@6| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q this@@269) (forall ((|$l#1#i#0@@1| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#1#i#0@@1|) (Buffers.BufferStack.BufferStack_q this@@269)) (=> (and (INTERNAL_le_boogie 0 |$l#1#i#0@@1|) (INTERNAL_lt_boogie |$l#1#i#0@@1| (|Seq#Length| (Buffers.BufferStack.buffers this@@269)))) (and (Buffers.BufferStack.BufferStack_q this@@269) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Buffers.BufferStack.buffers this@@269) |$l#1#i#0@@1|)) |accept#0@@6|))))
 :qid |unknown.0:0|
 :skolemid |3914|
 :no-pattern (INTERNAL_lt_boogie |$l#1#i#0@@1| (|Seq#Length| (Buffers.BufferStack.buffers this@@269)))
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#1#i#0@@1|)
))) (= (Buffers.BufferStack.ApplyFilter this@@269 |accept#0@@6|) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@54 (|Seq#Length| (Buffers.BufferStack.buffers this@@269)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#264| (Buffers.BufferStack.buffers this@@269) |accept#0@@6|) (|lambda#128| TInt 0 (|Seq#Length| (Buffers.BufferStack.buffers this@@269))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :skolemid |3915|
 :pattern ( (Buffers.BufferStack.ApplyFilter this@@269 |accept#0@@6|) ($IsGoodHeap $Heap@@54))
))))
(assert  (=> true (forall (($Heap@@55 T@U) (this@@270 T@U) (|accept#0@@7| T@U) ) (!  (=> (and (and (and (= (type $Heap@@55) (MapType0Type refType MapType1Type)) (= (type this@@270) DatatypeTypeType)) (= (type |accept#0@@7|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| (Lit this@@270) |accept#0@@7|) (and (and ($IsGoodHeap $Heap@@55) (and ($Is this@@270 Tclass.Buffers.BufferStack) ($IsAlloc this@@270 Tclass.Buffers.BufferStack $Heap@@55))) ($Is |accept#0@@7| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@270)) (forall ((|$l#3#i#0@@1| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#3#i#0@@1|) (Buffers.BufferStack.BufferStack_q (Lit this@@270))) (=> (and (INTERNAL_le_boogie 0 |$l#3#i#0@@1|) (INTERNAL_lt_boogie |$l#3#i#0@@1| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@270)))))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@270)) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@270))) |$l#3#i#0@@1|)) |accept#0@@7|))))
 :qid |unknown.0:0|
 :skolemid |3916|
 :no-pattern (INTERNAL_lt_boogie |$l#3#i#0@@1| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@270)))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#3#i#0@@1|)
))) (= (Buffers.BufferStack.ApplyFilter (Lit this@@270) |accept#0@@7|) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@55 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@270)))) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#264| (Lit (Buffers.BufferStack.buffers (Lit this@@270))) |accept#0@@7|) (|lambda#128| TInt 0 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@270))))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :weight 3
 :skolemid |3917|
 :pattern ( (Buffers.BufferStack.ApplyFilter (Lit this@@270) |accept#0@@7|) ($IsGoodHeap $Heap@@55))
))))
(assert  (=> true (forall (($Heap@@56 T@U) (this@@271 T@U) (|accept#0@@8| T@U) ) (!  (=> (and (and (and (= (type $Heap@@56) (MapType0Type refType MapType1Type)) (= (type this@@271) DatatypeTypeType)) (= (type |accept#0@@8|) (MapType0Type BoxType boolType))) (or (|Buffers.BufferStack.ApplyFilter#canCall| (Lit this@@271) (Lit |accept#0@@8|)) (and (and ($IsGoodHeap $Heap@@56) (and ($Is this@@271 Tclass.Buffers.BufferStack) ($IsAlloc this@@271 Tclass.Buffers.BufferStack $Heap@@56))) ($Is |accept#0@@8| (TISet Tclass.KeyType.Key))))) (and (and (Buffers.BufferStack.BufferStack_q (Lit this@@271)) (forall ((|$l#5#i#0@@0| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |$l#5#i#0@@0|) (Buffers.BufferStack.BufferStack_q (Lit this@@271))) (=> (and (INTERNAL_le_boogie 0 |$l#5#i#0@@0|) (INTERNAL_lt_boogie |$l#5#i#0@@0| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@271)))))) (and (Buffers.BufferStack.BufferStack_q (Lit this@@271)) (|Buffers.Buffer.ApplyFilter#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit (Buffers.BufferStack.buffers (Lit this@@271))) |$l#5#i#0@@0|)) (Lit |accept#0@@8|)))))
 :qid |unknown.0:0|
 :skolemid |3918|
 :no-pattern (INTERNAL_lt_boogie |$l#5#i#0@@0| (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@271)))))
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
 :no-pattern (INTERNAL_le_boogie 0 |$l#5#i#0@@0|)
))) (= (Buffers.BufferStack.ApplyFilter (Lit this@@271) (Lit |accept#0@@8|)) (|#Buffers.BufferStack.BufferStack| (|Seq#Create| Tclass.Buffers.Buffer $Heap@@56 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@271)))) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#264| (Lit (Buffers.BufferStack.buffers (Lit this@@271))) (Lit |accept#0@@8|)) (|lambda#128| TInt 0 (|Seq#Length| (Lit (Buffers.BufferStack.buffers (Lit this@@271))))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))))
 :qid |Buffersidfy.53:14|
 :weight 3
 :skolemid |3919|
 :pattern ( (Buffers.BufferStack.ApplyFilter (Lit this@@271) (Lit |accept#0@@8|)) ($IsGoodHeap $Heap@@56))
))))
(assert  (=> true (forall ((this@@272 T@U) (|newBuffers#0| T@U) ) (!  (=> (and (and (= (type this@@272) DatatypeTypeType) (= (type |newBuffers#0|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| this@@272 |newBuffers#0|) (and ($Is this@@272 Tclass.Buffers.BufferStack) ($Is |newBuffers#0| Tclass.Buffers.BufferStack)))) ($Is (Buffers.BufferStack.PushBufferStack this@@272 |newBuffers#0|) Tclass.Buffers.BufferStack))
 :qid |Buffersidfy.58:14|
 :skolemid |3920|
 :pattern ( (Buffers.BufferStack.PushBufferStack this@@272 |newBuffers#0|))
))))
(assert (forall ((this@@273 T@U) (|newBuffers#0@@0| T@U) ) (!  (=> (and (and (= (type this@@273) DatatypeTypeType) (= (type |newBuffers#0@@0|) DatatypeTypeType)) (and ($Is this@@273 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@0| Tclass.Buffers.BufferStack))) (= (|Buffers.BufferStack.PushBufferStack#requires| this@@273 |newBuffers#0@@0|) true))
 :qid |Buffersidfy.58:14|
 :skolemid |3921|
 :pattern ( (|Buffers.BufferStack.PushBufferStack#requires| this@@273 |newBuffers#0@@0|))
)))
(assert  (=> true (forall ((this@@274 T@U) (|newBuffers#0@@1| T@U) ) (!  (=> (and (and (= (type this@@274) DatatypeTypeType) (= (type |newBuffers#0@@1|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| this@@274 |newBuffers#0@@1|) (and ($Is this@@274 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@1| Tclass.Buffers.BufferStack)))) (and (and (Buffers.BufferStack.BufferStack_q |newBuffers#0@@1|) (Buffers.BufferStack.BufferStack_q this@@274)) (= (Buffers.BufferStack.PushBufferStack this@@274 |newBuffers#0@@1|) (|#Buffers.BufferStack.BufferStack| (|Seq#Append| (Buffers.BufferStack.buffers |newBuffers#0@@1|) (Buffers.BufferStack.buffers this@@274))))))
 :qid |Buffersidfy.58:14|
 :skolemid |3922|
 :pattern ( (Buffers.BufferStack.PushBufferStack this@@274 |newBuffers#0@@1|))
))))
(assert  (=> true (forall ((this@@275 T@U) (|newBuffers#0@@2| T@U) ) (!  (=> (and (and (= (type this@@275) DatatypeTypeType) (= (type |newBuffers#0@@2|) DatatypeTypeType)) (or (|Buffers.BufferStack.PushBufferStack#canCall| (Lit this@@275) (Lit |newBuffers#0@@2|)) (and ($Is this@@275 Tclass.Buffers.BufferStack) ($Is |newBuffers#0@@2| Tclass.Buffers.BufferStack)))) (and (and (Buffers.BufferStack.BufferStack_q (Lit |newBuffers#0@@2|)) (Buffers.BufferStack.BufferStack_q (Lit this@@275))) (= (Buffers.BufferStack.PushBufferStack (Lit this@@275) (Lit |newBuffers#0@@2|)) (|#Buffers.BufferStack.BufferStack| (|Seq#Append| (Buffers.BufferStack.buffers (Lit |newBuffers#0@@2|)) (Buffers.BufferStack.buffers (Lit this@@275)))))))
 :qid |Buffersidfy.58:14|
 :weight 3
 :skolemid |3923|
 :pattern ( (Buffers.BufferStack.PushBufferStack (Lit this@@275) (Lit |newBuffers#0@@2|)))
))))
(assert  (=> true (forall ((this@@276 T@U) (|other#0@@7| T@U) ) (!  (=> (and (and (= (type this@@276) DatatypeTypeType) (= (type |other#0@@7|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| this@@276 |other#0@@7|) (and ($Is this@@276 Tclass.Buffers.BufferStack) ($Is |other#0@@7| Tclass.Buffers.BufferStack)))) true)
 :qid |Buffersidfy.63:15|
 :skolemid |3924|
 :pattern ( (Buffers.BufferStack.Equivalent this@@276 |other#0@@7|))
))))
(assert (forall ((this@@277 T@U) (|other#0@@8| T@U) ) (!  (=> (and (and (= (type this@@277) DatatypeTypeType) (= (type |other#0@@8|) DatatypeTypeType)) (and ($Is this@@277 Tclass.Buffers.BufferStack) ($Is |other#0@@8| Tclass.Buffers.BufferStack))) (= (|Buffers.BufferStack.Equivalent#requires| this@@277 |other#0@@8|) true))
 :qid |Buffersidfy.63:15|
 :skolemid |3925|
 :pattern ( (|Buffers.BufferStack.Equivalent#requires| this@@277 |other#0@@8|))
)))
(assert  (=> true (forall ((this@@278 T@U) (|other#0@@9| T@U) ) (!  (=> (and (and (= (type this@@278) DatatypeTypeType) (= (type |other#0@@9|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| this@@278 |other#0@@9|) (and ($Is this@@278 Tclass.Buffers.BufferStack) ($Is |other#0@@9| Tclass.Buffers.BufferStack)))) (and (forall ((|k#0@@72| T@U) ) (!  (=> (and (= (type |k#0@@72|) (SeqType BoxType)) ($Is |k#0@@72| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#0@@72|) (=> (Buffers.__default.AnyKey |k#0@@72|) (and (and (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query this@@278 |k#0@@72|)) (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query |other#0@@9| |k#0@@72|))) (and (|Buffers.BufferStack.Query#canCall| this@@278 |k#0@@72|) (|Buffers.BufferStack.Query#canCall| |other#0@@9| |k#0@@72|))))))
 :qid |Buffersidfy.65:14|
 :skolemid |3927|
 :pattern ( (Buffers.BufferStack.Query |other#0@@9| |k#0@@72|))
 :pattern ( (Buffers.BufferStack.Query this@@278 |k#0@@72|))
 :pattern ( (Buffers.__default.AnyKey |k#0@@72|))
)) (= (Buffers.BufferStack.Equivalent this@@278 |other#0@@9|) (forall ((|k#0@@73| T@U) ) (!  (=> (= (type |k#0@@73|) (SeqType BoxType)) (=> (and ($Is |k#0@@73| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0@@73|)) (|ValueMessage.Message#Equal| (Buffers.BufferStack.Query this@@278 |k#0@@73|) (Buffers.BufferStack.Query |other#0@@9| |k#0@@73|))))
 :qid |Buffersidfy.65:14|
 :skolemid |3926|
 :pattern ( (Buffers.BufferStack.Query |other#0@@9| |k#0@@73|))
 :pattern ( (Buffers.BufferStack.Query this@@278 |k#0@@73|))
 :pattern ( (Buffers.__default.AnyKey |k#0@@73|))
)))))
 :qid |Buffersidfy.63:15|
 :skolemid |3928|
 :pattern ( (Buffers.BufferStack.Equivalent this@@278 |other#0@@9|))
))))
(assert  (=> true (forall ((this@@279 T@U) (|other#0@@10| T@U) ) (!  (=> (and (and (= (type this@@279) DatatypeTypeType) (= (type |other#0@@10|) DatatypeTypeType)) (or (|Buffers.BufferStack.Equivalent#canCall| (Lit this@@279) (Lit |other#0@@10|)) (and ($Is this@@279 Tclass.Buffers.BufferStack) ($Is |other#0@@10| Tclass.Buffers.BufferStack)))) (and (forall ((|k#1@@10| T@U) ) (!  (=> (and (= (type |k#1@@10|) (SeqType BoxType)) ($Is |k#1@@10| Tclass.KeyType.Key)) (and (|Buffers.__default.AnyKey#canCall| |k#1@@10|) (=> (Buffers.__default.AnyKey |k#1@@10|) (and (and (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query (Lit this@@279) |k#1@@10|)) (|$IsA#ValueMessage.Message| (Buffers.BufferStack.Query (Lit |other#0@@10|) |k#1@@10|))) (and (|Buffers.BufferStack.Query#canCall| (Lit this@@279) |k#1@@10|) (|Buffers.BufferStack.Query#canCall| (Lit |other#0@@10|) |k#1@@10|))))))
 :qid |Buffersidfy.65:14|
 :skolemid |3930|
 :pattern ( (Buffers.BufferStack.Query |other#0@@10| |k#1@@10|))
 :pattern ( (Buffers.BufferStack.Query this@@279 |k#1@@10|))
 :pattern ( (Buffers.__default.AnyKey |k#1@@10|))
)) (= (Buffers.BufferStack.Equivalent (Lit this@@279) (Lit |other#0@@10|)) (forall ((|k#1@@11| T@U) ) (!  (=> (= (type |k#1@@11|) (SeqType BoxType)) (=> (and ($Is |k#1@@11| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#1@@11|)) (|ValueMessage.Message#Equal| (Buffers.BufferStack.Query (Lit this@@279) |k#1@@11|) (Buffers.BufferStack.Query (Lit |other#0@@10|) |k#1@@11|))))
 :qid |Buffersidfy.65:14|
 :skolemid |3929|
 :pattern ( (Buffers.BufferStack.Query |other#0@@10| |k#1@@11|))
 :pattern ( (Buffers.BufferStack.Query this@@279 |k#1@@11|))
 :pattern ( (Buffers.__default.AnyKey |k#1@@11|))
)))))
 :qid |Buffersidfy.63:15|
 :weight 3
 :skolemid |3931|
 :pattern ( (Buffers.BufferStack.Equivalent (Lit this@@279) (Lit |other#0@@10|)))
))))
(assert (= (type Tclass.Buffers.__default) TyType))
(assert (= (Tag Tclass.Buffers.__default) Tagclass.Buffers.__default))
(assert (= (TagFamily Tclass.Buffers.__default) tytagFamily$_default))
(assert (forall ((bx@@159 T@U) ) (!  (=> (and (= (type bx@@159) BoxType) ($IsBox bx@@159 Tclass.Buffers.__default)) (and (= ($Box ($Unbox refType bx@@159)) bx@@159) ($Is ($Unbox refType bx@@159) Tclass.Buffers.__default)))
 :qid |unknown.0:0|
 :skolemid |3932|
 :pattern ( ($IsBox bx@@159 Tclass.Buffers.__default))
)))
(assert (forall (($o@@47 T@U) ) (!  (=> (= (type $o@@47) refType) (= ($Is $o@@47 Tclass.Buffers.__default)  (or (= $o@@47 null) (= (dtype $o@@47) Tclass.Buffers.__default))))
 :qid |unknown.0:0|
 :skolemid |3933|
 :pattern ( ($Is $o@@47 Tclass.Buffers.__default))
)))
(assert (forall (($o@@48 T@U) ($h@@152 T@U) ) (!  (=> (and (= (type $o@@48) refType) (= (type $h@@152) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@48 Tclass.Buffers.__default $h@@152)  (or (= $o@@48 null) (U_2_bool (MapType1Select (MapType0Select $h@@152 $o@@48) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3934|
 :pattern ( ($IsAlloc $o@@48 Tclass.Buffers.__default $h@@152))
)))
(assert  (=> true (forall ((|key#0@@43| T@U) ) (!  (=> (and (= (type |key#0@@43|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| |key#0@@43|) ($Is |key#0@@43| Tclass.KeyType.Key))) true)
 :qid |Buffersidfy.15:20|
 :skolemid |3935|
 :pattern ( (Buffers.__default.AnyKey |key#0@@43|))
))))
(assert (forall ((|key#0@@44| T@U) ) (!  (=> (and (= (type |key#0@@44|) (SeqType BoxType)) ($Is |key#0@@44| Tclass.KeyType.Key)) (= (|Buffers.__default.AnyKey#requires| |key#0@@44|) true))
 :qid |Buffersidfy.15:20|
 :skolemid |3936|
 :pattern ( (|Buffers.__default.AnyKey#requires| |key#0@@44|))
)))
(assert  (=> true (forall ((|key#0@@45| T@U) ) (!  (=> (and (= (type |key#0@@45|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| |key#0@@45|) ($Is |key#0@@45| Tclass.KeyType.Key))) (= (Buffers.__default.AnyKey |key#0@@45|) (U_2_bool (Lit (bool_2_U true)))))
 :qid |Buffersidfy.15:20|
 :skolemid |3937|
 :pattern ( (Buffers.__default.AnyKey |key#0@@45|))
))))
(assert  (=> true (forall ((|key#0@@46| T@U) ) (!  (=> (and (= (type |key#0@@46|) (SeqType BoxType)) (or (|Buffers.__default.AnyKey#canCall| (Lit |key#0@@46|)) ($Is |key#0@@46| Tclass.KeyType.Key))) (= (Buffers.__default.AnyKey (Lit |key#0@@46|)) (U_2_bool (Lit (bool_2_U true)))))
 :qid |Buffersidfy.15:20|
 :weight 3
 :skolemid |3938|
 :pattern ( (Buffers.__default.AnyKey (Lit |key#0@@46|)))
))))
(assert  (=> true (forall ((|keys#0| T@U) ) (!  (=> (and (= (type |keys#0|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| |keys#0|) ($Is |keys#0| (TISet Tclass.KeyType.Key)))) true)
 :qid |Buffersidfy.16:19|
 :skolemid |3939|
 :pattern ( (Buffers.__default.Total |keys#0|))
))))
(assert (forall ((|keys#0@@0| T@U) ) (!  (=> (and (= (type |keys#0@@0|) (MapType0Type BoxType boolType)) ($Is |keys#0@@0| (TISet Tclass.KeyType.Key))) (= (|Buffers.__default.Total#requires| |keys#0@@0|) true))
 :qid |Buffersidfy.16:19|
 :skolemid |3940|
 :pattern ( (|Buffers.__default.Total#requires| |keys#0@@0|))
)))
(assert  (=> true (forall ((|keys#0@@1| T@U) ) (!  (=> (and (= (type |keys#0@@1|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| |keys#0@@1|) ($Is |keys#0@@1| (TISet Tclass.KeyType.Key)))) (and (forall ((|k#0@@74| T@U) ) (!  (=> (and (= (type |k#0@@74|) (SeqType BoxType)) ($Is |k#0@@74| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#0@@74|))
 :qid |Buffersidfy.17:12|
 :skolemid |3942|
 :pattern ( (MapType0Select |keys#0@@1| ($Box |k#0@@74|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@74|))
)) (= (Buffers.__default.Total |keys#0@@1|) (forall ((|k#0@@75| T@U) ) (!  (=> (= (type |k#0@@75|) (SeqType BoxType)) (=> (and ($Is |k#0@@75| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#0@@75|)) (U_2_bool (MapType0Select |keys#0@@1| ($Box |k#0@@75|)))))
 :qid |Buffersidfy.17:12|
 :skolemid |3941|
 :pattern ( (MapType0Select |keys#0@@1| ($Box |k#0@@75|)))
 :pattern ( (Buffers.__default.AnyKey |k#0@@75|))
)))))
 :qid |Buffersidfy.16:19|
 :skolemid |3943|
 :pattern ( (Buffers.__default.Total |keys#0@@1|))
))))
(assert  (=> true (forall ((|keys#0@@2| T@U) ) (!  (=> (and (= (type |keys#0@@2|) (MapType0Type BoxType boolType)) (or (|Buffers.__default.Total#canCall| (Lit |keys#0@@2|)) ($Is |keys#0@@2| (TISet Tclass.KeyType.Key)))) (and (forall ((|k#1@@12| T@U) ) (!  (=> (and (= (type |k#1@@12|) (SeqType BoxType)) ($Is |k#1@@12| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#1@@12|))
 :qid |Buffersidfy.17:12|
 :skolemid |3945|
 :pattern ( (MapType0Select |keys#0@@2| ($Box |k#1@@12|)))
 :pattern ( (Buffers.__default.AnyKey |k#1@@12|))
)) (= (Buffers.__default.Total (Lit |keys#0@@2|)) (forall ((|k#1@@13| T@U) ) (!  (=> (= (type |k#1@@13|) (SeqType BoxType)) (=> (and ($Is |k#1@@13| Tclass.KeyType.Key) (Buffers.__default.AnyKey |k#1@@13|)) (U_2_bool (MapType0Select (Lit |keys#0@@2|) ($Box |k#1@@13|)))))
 :qid |Buffersidfy.17:12|
 :skolemid |3944|
 :pattern ( (MapType0Select |keys#0@@2| ($Box |k#1@@13|)))
 :pattern ( (Buffers.__default.AnyKey |k#1@@13|))
)))))
 :qid |Buffersidfy.16:19|
 :weight 3
 :skolemid |3946|
 :pattern ( (Buffers.__default.Total (Lit |keys#0@@2|)))
))))
(assert  (=> true (=> true (and (Buffers.__default.Total Buffers.__default.AllKeys) ($Is Buffers.__default.AllKeys (TISet Tclass.KeyType.Key))))))
(assert (= |Buffers.__default.AllKeys#requires| true))
(assert (forall ((arg0@@593 T@U) ) (! (= (type (|lambda#279| arg0@@593)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#279|
 :pattern ( (|lambda#279| arg0@@593))
)))
(assert  (=> true (=> true (and (forall ((|k#0@@76| T@U) ) (!  (=> (and (= (type |k#0@@76|) (SeqType BoxType)) ($Is |k#0@@76| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#0@@76|))
 :qid |Buffersidfy.22:10|
 :skolemid |3947|
 :pattern ( (Buffers.__default.AnyKey |k#0@@76|))
)) (= Buffers.__default.AllKeys (|lambda#279| Tclass.KeyType.Key))))))
(assert  (=> true (=> true (and (forall ((|k#1@@14| T@U) ) (!  (=> (and (= (type |k#1@@14|) (SeqType BoxType)) ($Is |k#1@@14| Tclass.KeyType.Key)) (|Buffers.__default.AnyKey#canCall| |k#1@@14|))
 :qid |Buffersidfy.22:10|
 :skolemid |3948|
 :pattern ( (Buffers.__default.AnyKey |k#1@@14|))
)) (= Buffers.__default.AllKeys (|lambda#279| Tclass.KeyType.Key))))))
(assert (forall ((arg0@@594 T@U) (arg1@@299 Int) ) (! (= (type (|#MemtableMod.Memtable.Memtable| arg0@@594 arg1@@299)) DatatypeTypeType)
 :qid |funType:#MemtableMod.Memtable.Memtable|
 :pattern ( (|#MemtableMod.Memtable.Memtable| arg0@@594 arg1@@299))
)))
(assert (forall ((|a#0#0#0@@10| T@U) (|a#0#1#0@@6| Int) ) (!  (=> (= (type |a#0#0#0@@10|) (MapType BoxType BoxType)) (= (DatatypeCtorId (|#MemtableMod.Memtable.Memtable| |a#0#0#0@@10| |a#0#1#0@@6|)) |##MemtableMod.Memtable.Memtable|))
 :qid |Memtableidfy.15:32|
 :skolemid |3949|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#0#0#0@@10| |a#0#1#0@@6|))
)))
(assert (forall ((d@@148 T@U) ) (!  (=> (= (type d@@148) DatatypeTypeType) (= (MemtableMod.Memtable.Memtable_q d@@148) (= (DatatypeCtorId d@@148) |##MemtableMod.Memtable.Memtable|)))
 :qid |unknown.0:0|
 :skolemid |3950|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@148))
)))
(assert (forall ((d@@149 T@U) ) (!  (=> (and (= (type d@@149) DatatypeTypeType) (MemtableMod.Memtable.Memtable_q d@@149)) (exists ((|a#1#0#0@@10| T@U) (|a#1#1#0@@6| Int) ) (!  (and (= (type |a#1#0#0@@10|) (MapType BoxType BoxType)) (= d@@149 (|#MemtableMod.Memtable.Memtable| |a#1#0#0@@10| |a#1#1#0@@6|)))
 :qid |Memtableidfy.15:32|
 :skolemid |3951|
 :no-pattern (type |a#1#0#0@@10|)
 :no-pattern (U_2_int |a#1#0#0@@10|)
 :no-pattern (U_2_bool |a#1#0#0@@10|)
)))
 :qid |unknown.0:0|
 :skolemid |3952|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@149))
)))
(assert (forall ((|a#2#0#0@@10| T@U) (|a#2#1#0@@6| Int) ) (!  (=> (= (type |a#2#0#0@@10|) (MapType BoxType BoxType)) (= ($Is (|#MemtableMod.Memtable.Memtable| |a#2#0#0@@10| |a#2#1#0@@6|) Tclass.MemtableMod.Memtable)  (and ($Is |a#2#0#0@@10| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message)) ($Is (int_2_U |a#2#1#0@@6|) Tclass._System.nat))))
 :qid |Memtableidfy.15:32|
 :skolemid |3953|
 :pattern ( ($Is (|#MemtableMod.Memtable.Memtable| |a#2#0#0@@10| |a#2#1#0@@6|) Tclass.MemtableMod.Memtable))
)))
(assert (forall ((|a#3#0#0@@10| T@U) (|a#3#1#0@@6| Int) ($h@@153 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@10|) (MapType BoxType BoxType)) (= (type $h@@153) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@153)) (= ($IsAlloc (|#MemtableMod.Memtable.Memtable| |a#3#0#0@@10| |a#3#1#0@@6|) Tclass.MemtableMod.Memtable $h@@153)  (and ($IsAlloc |a#3#0#0@@10| (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@153) ($IsAlloc (int_2_U |a#3#1#0@@6|) Tclass._System.nat $h@@153))))
 :qid |Memtableidfy.15:32|
 :skolemid |3954|
 :pattern ( ($IsAlloc (|#MemtableMod.Memtable.Memtable| |a#3#0#0@@10| |a#3#1#0@@6|) Tclass.MemtableMod.Memtable $h@@153))
)))
(assert (forall ((d@@150 T@U) ($h@@154 T@U) ) (!  (=> (and (and (= (type d@@150) DatatypeTypeType) (= (type $h@@154) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@154) (and (MemtableMod.Memtable.Memtable_q d@@150) ($IsAlloc d@@150 Tclass.MemtableMod.Memtable $h@@154)))) ($IsAlloc (MemtableMod.Memtable.mapp d@@150) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@154))
 :qid |unknown.0:0|
 :skolemid |3955|
 :pattern ( ($IsAlloc (MemtableMod.Memtable.mapp d@@150) (TMap Tclass.KeyType.Key Tclass.ValueMessage.Message) $h@@154))
)))
(assert (forall ((d@@151 T@U) ($h@@155 T@U) ) (!  (=> (and (and (= (type d@@151) DatatypeTypeType) (= (type $h@@155) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@155) (and (MemtableMod.Memtable.Memtable_q d@@151) ($IsAlloc d@@151 Tclass.MemtableMod.Memtable $h@@155)))) ($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@151)) Tclass._System.nat $h@@155))
 :qid |unknown.0:0|
 :skolemid |3956|
 :pattern ( ($IsAlloc (int_2_U (MemtableMod.Memtable.seqEnd d@@151)) Tclass._System.nat $h@@155))
)))
(assert (forall ((|a#4#0#0@@10| T@U) (|a#4#1#0@@6| Int) ) (!  (=> (= (type |a#4#0#0@@10|) (MapType BoxType BoxType)) (= (|#MemtableMod.Memtable.Memtable| (Lit |a#4#0#0@@10|) (LitInt |a#4#1#0@@6|)) (Lit (|#MemtableMod.Memtable.Memtable| |a#4#0#0@@10| |a#4#1#0@@6|))))
 :qid |Memtableidfy.15:32|
 :skolemid |3957|
 :pattern ( (|#MemtableMod.Memtable.Memtable| (Lit |a#4#0#0@@10|) (LitInt |a#4#1#0@@6|)))
)))
(assert (forall ((|a#5#0#0@@11| T@U) (|a#5#1#0@@6| Int) ) (!  (=> (= (type |a#5#0#0@@11|) (MapType BoxType BoxType)) (= (MemtableMod.Memtable.mapp (|#MemtableMod.Memtable.Memtable| |a#5#0#0@@11| |a#5#1#0@@6|)) |a#5#0#0@@11|))
 :qid |Memtableidfy.15:32|
 :skolemid |3958|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#5#0#0@@11| |a#5#1#0@@6|))
)))
(assert (forall ((|a#6#0#0@@11| T@U) (|a#6#1#0@@6| Int) (d@@152 T@U) ) (!  (=> (and (and (= (type |a#6#0#0@@11|) (MapType BoxType BoxType)) (= (type d@@152) DatatypeTypeType)) (U_2_bool (MapType0Select (|Map#Domain| |a#6#0#0@@11|) ($Box d@@152)))) (< (DtRank d@@152) (DtRank (|#MemtableMod.Memtable.Memtable| |a#6#0#0@@11| |a#6#1#0@@6|))))
 :qid |Memtableidfy.15:32|
 :skolemid |3959|
 :pattern ( (MapType0Select (|Map#Domain| |a#6#0#0@@11|) ($Box d@@152)) (|#MemtableMod.Memtable.Memtable| |a#6#0#0@@11| |a#6#1#0@@6|))
)))
(assert (forall ((|a#7#0#0@@10| T@U) (|a#7#1#0@@6| Int) (bx@@160 T@U) ) (!  (=> (and (and (= (type |a#7#0#0@@10|) (MapType BoxType BoxType)) (= (type bx@@160) BoxType)) (U_2_bool (MapType0Select (|Map#Domain| |a#7#0#0@@10|) bx@@160))) (< (DtRank ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| |a#7#0#0@@10|) bx@@160))) (DtRank (|#MemtableMod.Memtable.Memtable| |a#7#0#0@@10| |a#7#1#0@@6|))))
 :qid |Memtableidfy.15:32|
 :skolemid |3960|
 :pattern ( (MapType0Select (|Map#Domain| |a#7#0#0@@10|) bx@@160) (|#MemtableMod.Memtable.Memtable| |a#7#0#0@@10| |a#7#1#0@@6|))
)))
(assert (forall ((|a#8#0#0@@7| T@U) (|a#8#1#0@@5| Int) ) (!  (=> (= (type |a#8#0#0@@7|) (MapType BoxType BoxType)) (= (MemtableMod.Memtable.seqEnd (|#MemtableMod.Memtable.Memtable| |a#8#0#0@@7| |a#8#1#0@@5|)) |a#8#1#0@@5|))
 :qid |Memtableidfy.15:32|
 :skolemid |3961|
 :pattern ( (|#MemtableMod.Memtable.Memtable| |a#8#0#0@@7| |a#8#1#0@@5|))
)))
(assert (forall ((d@@153 T@U) ) (!  (=> (and (= (type d@@153) DatatypeTypeType) (|$IsA#MemtableMod.Memtable| d@@153)) (MemtableMod.Memtable.Memtable_q d@@153))
 :qid |unknown.0:0|
 :skolemid |3962|
 :pattern ( (|$IsA#MemtableMod.Memtable| d@@153))
)))
(assert (forall ((d@@154 T@U) ) (!  (=> (and (= (type d@@154) DatatypeTypeType) ($Is d@@154 Tclass.MemtableMod.Memtable)) (MemtableMod.Memtable.Memtable_q d@@154))
 :qid |unknown.0:0|
 :skolemid |3963|
 :pattern ( (MemtableMod.Memtable.Memtable_q d@@154) ($Is d@@154 Tclass.MemtableMod.Memtable))
)))
(assert (forall ((a@@164 T@U) (b@@114 T@U) ) (!  (=> (and (and (= (type a@@164) DatatypeTypeType) (= (type b@@114) DatatypeTypeType)) true) (= (|MemtableMod.Memtable#Equal| a@@164 b@@114)  (and (|Map#Equal| (MemtableMod.Memtable.mapp a@@164) (MemtableMod.Memtable.mapp b@@114)) (= (MemtableMod.Memtable.seqEnd a@@164) (MemtableMod.Memtable.seqEnd b@@114)))))
 :qid |unknown.0:0|
 :skolemid |3964|
 :pattern ( (|MemtableMod.Memtable#Equal| a@@164 b@@114))
)))
(assert (forall ((a@@165 T@U) (b@@115 T@U) ) (!  (=> (and (= (type a@@165) DatatypeTypeType) (= (type b@@115) DatatypeTypeType)) (= (|MemtableMod.Memtable#Equal| a@@165 b@@115) (= a@@165 b@@115)))
 :qid |unknown.0:0|
 :skolemid |3965|
 :pattern ( (|MemtableMod.Memtable#Equal| a@@165 b@@115))
)))
(assert (forall ((arg0@@595 T@U) (arg1@@300 T@U) ) (! (= (type (MemtableMod.Memtable.Get arg0@@595 arg1@@300)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.Get|
 :pattern ( (MemtableMod.Memtable.Get arg0@@595 arg1@@300))
)))
(assert  (=> true (forall ((this@@280 T@U) (|key#0@@47| T@U) ) (!  (=> (and (and (= (type this@@280) DatatypeTypeType) (= (type |key#0@@47|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| this@@280 |key#0@@47|) (and ($Is this@@280 Tclass.MemtableMod.Memtable) ($Is |key#0@@47| Tclass.KeyType.Key)))) ($Is (MemtableMod.Memtable.Get this@@280 |key#0@@47|) Tclass.ValueMessage.Message))
 :qid |Memtableidfy.17:14|
 :skolemid |3966|
 :pattern ( (MemtableMod.Memtable.Get this@@280 |key#0@@47|))
))))
(assert (forall ((this@@281 T@U) (|key#0@@48| T@U) ) (!  (=> (and (and (= (type this@@281) DatatypeTypeType) (= (type |key#0@@48|) (SeqType BoxType))) (and ($Is this@@281 Tclass.MemtableMod.Memtable) ($Is |key#0@@48| Tclass.KeyType.Key))) (= (|MemtableMod.Memtable.Get#requires| this@@281 |key#0@@48|) true))
 :qid |Memtableidfy.17:14|
 :skolemid |3967|
 :pattern ( (|MemtableMod.Memtable.Get#requires| this@@281 |key#0@@48|))
)))
(assert  (=> true (forall ((this@@282 T@U) (|key#0@@49| T@U) ) (!  (=> (and (and (= (type this@@282) DatatypeTypeType) (= (type |key#0@@49|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| this@@282 |key#0@@49|) (and ($Is this@@282 Tclass.MemtableMod.Memtable) ($Is |key#0@@49| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q this@@282) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@282)) ($Box |key#0@@49|))) (MemtableMod.Memtable.Memtable_q this@@282))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@282)) ($Box |key#0@@49|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Get this@@282 |key#0@@49|) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@282)) ($Box |key#0@@49|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp this@@282)) ($Box |key#0@@49|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.17:14|
 :skolemid |3968|
 :pattern ( (MemtableMod.Memtable.Get this@@282 |key#0@@49|))
))))
(assert  (=> true (forall ((this@@283 T@U) (|key#0@@50| T@U) ) (!  (=> (and (and (= (type this@@283) DatatypeTypeType) (= (type |key#0@@50|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Get#canCall| (Lit this@@283) (Lit |key#0@@50|)) (and ($Is this@@283 Tclass.MemtableMod.Memtable) ($Is |key#0@@50| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@283)) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@283))) ($Box |key#0@@50|))) (MemtableMod.Memtable.Memtable_q (Lit this@@283)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@283))) ($Box |key#0@@50|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Get (Lit this@@283) (Lit |key#0@@50|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@283))) ($Box |key#0@@50|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MemtableMod.Memtable.mapp (Lit this@@283)))) ($Box (Lit |key#0@@50|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.17:14|
 :weight 3
 :skolemid |3969|
 :pattern ( (MemtableMod.Memtable.Get (Lit this@@283) (Lit |key#0@@50|)))
))))
(assert (forall ((arg0@@596 T@U) (arg1@@301 T@U) ) (! (= (type (MemtableMod.Memtable.ApplyPut arg0@@596 arg1@@301)) DatatypeTypeType)
 :qid |funType:MemtableMod.Memtable.ApplyPut|
 :pattern ( (MemtableMod.Memtable.ApplyPut arg0@@596 arg1@@301))
)))
(assert  (=> true (forall ((this@@284 T@U) (|km#0| T@U) ) (!  (=> (and (and (= (type this@@284) DatatypeTypeType) (= (type |km#0|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| this@@284 |km#0|) (and ($Is this@@284 Tclass.MemtableMod.Memtable) ($Is |km#0| Tclass.MsgHistoryMod.KeyedMessage)))) ($Is (MemtableMod.Memtable.ApplyPut this@@284 |km#0|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.22:14|
 :skolemid |3970|
 :pattern ( (MemtableMod.Memtable.ApplyPut this@@284 |km#0|))
))))
(assert (forall ((this@@285 T@U) (|km#0@@0| T@U) ) (!  (=> (and (and (= (type this@@285) DatatypeTypeType) (= (type |km#0@@0|) DatatypeTypeType)) (and ($Is this@@285 Tclass.MemtableMod.Memtable) ($Is |km#0@@0| Tclass.MsgHistoryMod.KeyedMessage))) (= (|MemtableMod.Memtable.ApplyPut#requires| this@@285 |km#0@@0|) true))
 :qid |Memtableidfy.22:14|
 :skolemid |3971|
 :pattern ( (|MemtableMod.Memtable.ApplyPut#requires| this@@285 |km#0@@0|))
)))
(assert  (=> true (forall ((this@@286 T@U) (|km#0@@1| T@U) ) (!  (=> (and (and (= (type this@@286) DatatypeTypeType) (= (type |km#0@@1|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| this@@286 |km#0@@1|) (and ($Is this@@286 Tclass.MemtableMod.Memtable) ($Is |km#0@@1| Tclass.MsgHistoryMod.KeyedMessage)))) (and (and (and (and (MemtableMod.Memtable.Memtable_q this@@286) (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|)) (and (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q |km#0@@1|) (|MemtableMod.Memtable.Get#canCall| this@@286 (MsgHistoryMod.KeyedMessage.key |km#0@@1|)))) (|ValueMessage.__default.Merge#canCall| (MsgHistoryMod.KeyedMessage.message |km#0@@1|) (MemtableMod.Memtable.Get this@@286 (MsgHistoryMod.KeyedMessage.key |km#0@@1|))))) (MemtableMod.Memtable.Memtable_q this@@286)) (= (MemtableMod.Memtable.ApplyPut this@@286 |km#0@@1|) (|#MemtableMod.Memtable.Memtable| (|Map#Build| (MemtableMod.Memtable.mapp this@@286) ($Box (MsgHistoryMod.KeyedMessage.key |km#0@@1|)) ($Box (ValueMessage.__default.Merge (MsgHistoryMod.KeyedMessage.message |km#0@@1|) (MemtableMod.Memtable.Get this@@286 (MsgHistoryMod.KeyedMessage.key |km#0@@1|))))) (INTERNAL_add_boogie (MemtableMod.Memtable.seqEnd this@@286) 1)))))
 :qid |Memtableidfy.22:14|
 :skolemid |3972|
 :pattern ( (MemtableMod.Memtable.ApplyPut this@@286 |km#0@@1|))
))))
(assert  (=> true (forall ((this@@287 T@U) (|km#0@@2| T@U) ) (!  (=> (and (and (= (type this@@287) DatatypeTypeType) (= (type |km#0@@2|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPut#canCall| (Lit this@@287) (Lit |km#0@@2|)) (and ($Is this@@287 Tclass.MemtableMod.Memtable) ($Is |km#0@@2| Tclass.MsgHistoryMod.KeyedMessage)))) (and (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@287)) (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|))) (and (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|)) (and (MsgHistoryMod.KeyedMessage.KeyedMessage_q (Lit |km#0@@2|)) (|MemtableMod.Memtable.Get#canCall| (Lit this@@287) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))) (|ValueMessage.__default.Merge#canCall| (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|))) (Lit (MemtableMod.Memtable.Get (Lit this@@287) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))))))) (MemtableMod.Memtable.Memtable_q (Lit this@@287))) (= (MemtableMod.Memtable.ApplyPut (Lit this@@287) (Lit |km#0@@2|)) (|#MemtableMod.Memtable.Memtable| (|Map#Build| (Lit (MemtableMod.Memtable.mapp (Lit this@@287))) ($Box (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|)))) ($Box (Lit (ValueMessage.__default.Merge (Lit (MsgHistoryMod.KeyedMessage.message (Lit |km#0@@2|))) (Lit (MemtableMod.Memtable.Get (Lit this@@287) (Lit (MsgHistoryMod.KeyedMessage.key (Lit |km#0@@2|))))))))) (LitInt (INTERNAL_add_boogie (MemtableMod.Memtable.seqEnd (Lit this@@287)) 1))))))
 :qid |Memtableidfy.22:14|
 :weight 3
 :skolemid |3973|
 :pattern ( (MemtableMod.Memtable.ApplyPut (Lit this@@287) (Lit |km#0@@2|)))
))))
(assert (forall (($ly@@341 T@U) (this@@288 T@U) (|puts#0| T@U) ) (!  (=> (and (and (= (type $ly@@341) LayerTypeType) (= (type this@@288) DatatypeTypeType)) (= (type |puts#0|) DatatypeTypeType)) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@341) this@@288 |puts#0|) (MemtableMod.Memtable.ApplyPuts $ly@@341 this@@288 |puts#0|)))
 :qid |Memtableidfy.27:14|
 :skolemid |3974|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@341) this@@288 |puts#0|))
)))
(assert (forall (($ly@@342 T@U) (this@@289 T@U) (|puts#0@@0| T@U) ) (!  (=> (and (and (= (type $ly@@342) LayerTypeType) (= (type this@@289) DatatypeTypeType)) (= (type |puts#0@@0|) DatatypeTypeType)) (= (MemtableMod.Memtable.ApplyPuts $ly@@342 this@@289 |puts#0@@0|) (MemtableMod.Memtable.ApplyPuts $LZ this@@289 |puts#0@@0|)))
 :qid |Memtableidfy.27:14|
 :skolemid |3975|
 :pattern ( (MemtableMod.Memtable.ApplyPuts (AsFuelBottom $ly@@342) this@@289 |puts#0@@0|))
)))
(assert  (=> true (forall (($ly@@343 T@U) (this@@290 T@U) (|puts#0@@1| T@U) ) (!  (=> (and (and (and (= (type $ly@@343) LayerTypeType) (= (type this@@290) DatatypeTypeType)) (= (type |puts#0@@1|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@290 |puts#0@@1|) (and (and ($Is this@@290 Tclass.MemtableMod.Memtable) ($Is |puts#0@@1| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |puts#0@@1|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@1|) (MemtableMod.Memtable.seqEnd this@@290)))))) ($Is (MemtableMod.Memtable.ApplyPuts $ly@@343 this@@290 |puts#0@@1|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.27:14|
 :skolemid |3976|
 :pattern ( (MemtableMod.Memtable.ApplyPuts $ly@@343 this@@290 |puts#0@@1|))
))))
(assert (forall (($ly@@344 T@U) (this@@291 T@U) (|puts#0@@2| T@U) ) (!  (=> (and (and (and (= (type $ly@@344) LayerTypeType) (= (type this@@291) DatatypeTypeType)) (= (type |puts#0@@2|) DatatypeTypeType)) (and ($Is this@@291 Tclass.MemtableMod.Memtable) ($Is |puts#0@@2| Tclass.MsgHistoryMod.MsgHistory))) (= (|MemtableMod.Memtable.ApplyPuts#requires| $ly@@344 this@@291 |puts#0@@2|)  (and (MsgHistoryMod.MsgHistory.WF |puts#0@@2|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@2|) (MemtableMod.Memtable.seqEnd this@@291)))))
 :qid |Memtableidfy.27:14|
 :skolemid |3977|
 :pattern ( (|MemtableMod.Memtable.ApplyPuts#requires| $ly@@344 this@@291 |puts#0@@2|))
)))
(assert  (=> true (forall (($ly@@345 T@U) (this@@292 T@U) (|puts#0@@3| T@U) ) (!  (=> (and (and (and (= (type $ly@@345) LayerTypeType) (= (type this@@292) DatatypeTypeType)) (= (type |puts#0@@3|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@292 |puts#0@@3|) (and (and ($Is this@@292 Tclass.MemtableMod.Memtable) ($Is |puts#0@@3| Tclass.MsgHistoryMod.MsgHistory)) (and (MsgHistoryMod.MsgHistory.WF |puts#0@@3|) (= (MsgHistoryMod.MsgHistory.seqStart |puts#0@@3|) (MemtableMod.Memtable.seqEnd this@@292)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| |puts#0@@3|) (=> (not (MsgHistoryMod.MsgHistory.IsEmpty |puts#0@@3|)) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@3|) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| |puts#0@@3| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1))) (|MemtableMod.Memtable.ApplyPuts#canCall| this@@292 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@3| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1)))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@3|) (MsgHistoryMod.MsgHistory.MsgHistory_q |puts#0@@3|))) (|MemtableMod.Memtable.ApplyPut#canCall| (MemtableMod.Memtable.ApplyPuts $ly@@345 this@@292 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@3| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |puts#0@@3|)) ($Box (int_2_U (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@345) this@@292 |puts#0@@3|) (ite (MsgHistoryMod.MsgHistory.IsEmpty |puts#0@@3|) this@@292 (MemtableMod.Memtable.ApplyPut (MemtableMod.Memtable.ApplyPuts $ly@@345 this@@292 (MsgHistoryMod.MsgHistory.DiscardRecent |puts#0@@3| (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MsgHistoryMod.MsgHistory.msgs |puts#0@@3|)) ($Box (int_2_U (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd |puts#0@@3|) 1))))))))))
 :qid |Memtableidfy.27:14|
 :skolemid |3978|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@345) this@@292 |puts#0@@3|))
))))
(assert  (=> true (forall (($ly@@346 T@U) (this@@293 T@U) (|puts#0@@4| T@U) ) (!  (=> (and (and (and (= (type $ly@@346) LayerTypeType) (= (type this@@293) DatatypeTypeType)) (= (type |puts#0@@4|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| this@@293 (Lit |puts#0@@4|)) (and (and ($Is this@@293 Tclass.MemtableMod.Memtable) ($Is |puts#0@@4| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |puts#0@@4|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit |puts#0@@4|))) (MemtableMod.Memtable.seqEnd this@@293)))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit |puts#0@@4|)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@4|)))))) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@4|)) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit |puts#0@@4|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1)))) (|MemtableMod.Memtable.ApplyPuts#canCall| this@@293 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@4|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@4|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@4|)))) (|MemtableMod.Memtable.ApplyPut#canCall| (MemtableMod.Memtable.ApplyPuts ($LS $ly@@346) this@@293 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@4|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@4|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1)))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@346) this@@293 (Lit |puts#0@@4|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@4|)) this@@293 (MemtableMod.Memtable.ApplyPut (MemtableMod.Memtable.ApplyPuts ($LS $ly@@346) this@@293 (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@4|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@4|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@4|)) 1)))))))))))
 :qid |Memtableidfy.27:14|
 :weight 3
 :skolemid |3979|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@346) this@@293 (Lit |puts#0@@4|)))
))))
(assert  (=> true (forall (($ly@@347 T@U) (this@@294 T@U) (|puts#0@@5| T@U) ) (!  (=> (and (and (and (= (type $ly@@347) LayerTypeType) (= (type this@@294) DatatypeTypeType)) (= (type |puts#0@@5|) DatatypeTypeType)) (or (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit this@@294) (Lit |puts#0@@5|)) (and (and ($Is this@@294 Tclass.MemtableMod.Memtable) ($Is |puts#0@@5| Tclass.MsgHistoryMod.MsgHistory)) (and (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.WF (Lit |puts#0@@5|))))) (= (LitInt (MsgHistoryMod.MsgHistory.seqStart (Lit |puts#0@@5|))) (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@294)))))))) (and (and (|MsgHistoryMod.MsgHistory.IsEmpty#canCall| (Lit |puts#0@@5|)) (=> (not (U_2_bool (Lit (bool_2_U (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@5|)))))) (and (and (and (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)) (|MsgHistoryMod.MsgHistory.DiscardRecent#canCall| (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))) (|MemtableMod.Memtable.ApplyPuts#canCall| (Lit this@@294) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))) (and (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)) (MsgHistoryMod.MsgHistory.MsgHistory_q (Lit |puts#0@@5|)))) (|MemtableMod.Memtable.ApplyPut#canCall| (Lit (MemtableMod.Memtable.ApplyPuts ($LS $ly@@347) (Lit this@@294) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@5|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))))))) (= (MemtableMod.Memtable.ApplyPuts ($LS $ly@@347) (Lit this@@294) (Lit |puts#0@@5|)) (ite (MsgHistoryMod.MsgHistory.IsEmpty (Lit |puts#0@@5|)) this@@294 (MemtableMod.Memtable.ApplyPut (Lit (MemtableMod.Memtable.ApplyPuts ($LS $ly@@347) (Lit this@@294) (Lit (MsgHistoryMod.MsgHistory.DiscardRecent (Lit |puts#0@@5|) (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MsgHistoryMod.MsgHistory.msgs (Lit |puts#0@@5|)))) ($Box (int_2_U (LitInt (INTERNAL_sub_boogie (MsgHistoryMod.MsgHistory.seqEnd (Lit |puts#0@@5|)) 1)))))))))))
 :qid |Memtableidfy.27:14|
 :weight 3
 :skolemid |3980|
 :pattern ( (MemtableMod.Memtable.ApplyPuts ($LS $ly@@347) (Lit this@@294) (Lit |puts#0@@5|)))
))))
(assert  (=> true (forall ((this@@295 T@U) (|key#0@@51| T@U) ) (!  (=> (and (and (= (type this@@295) DatatypeTypeType) (= (type |key#0@@51|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| this@@295 |key#0@@51|) (and ($Is this@@295 Tclass.MemtableMod.Memtable) ($Is |key#0@@51| Tclass.KeyType.Key)))) ($Is (MemtableMod.Memtable.Query this@@295 |key#0@@51|) Tclass.ValueMessage.Message))
 :qid |Memtableidfy.36:14|
 :skolemid |3981|
 :pattern ( (MemtableMod.Memtable.Query this@@295 |key#0@@51|))
))))
(assert (forall ((this@@296 T@U) (|key#0@@52| T@U) ) (!  (=> (and (and (= (type this@@296) DatatypeTypeType) (= (type |key#0@@52|) (SeqType BoxType))) (and ($Is this@@296 Tclass.MemtableMod.Memtable) ($Is |key#0@@52| Tclass.KeyType.Key))) (= (|MemtableMod.Memtable.Query#requires| this@@296 |key#0@@52|) true))
 :qid |Memtableidfy.36:14|
 :skolemid |3982|
 :pattern ( (|MemtableMod.Memtable.Query#requires| this@@296 |key#0@@52|))
)))
(assert  (=> true (forall ((this@@297 T@U) (|key#0@@53| T@U) ) (!  (=> (and (and (= (type this@@297) DatatypeTypeType) (= (type |key#0@@53|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| this@@297 |key#0@@53|) (and ($Is this@@297 Tclass.MemtableMod.Memtable) ($Is |key#0@@53| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q this@@297) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@297)) ($Box |key#0@@53|))) (MemtableMod.Memtable.Memtable_q this@@297))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@297)) ($Box |key#0@@53|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Query this@@297 |key#0@@53|) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp this@@297)) ($Box |key#0@@53|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (MemtableMod.Memtable.mapp this@@297)) ($Box |key#0@@53|))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.36:14|
 :skolemid |3983|
 :pattern ( (MemtableMod.Memtable.Query this@@297 |key#0@@53|))
))))
(assert  (=> true (forall ((this@@298 T@U) (|key#0@@54| T@U) ) (!  (=> (and (and (= (type this@@298) DatatypeTypeType) (= (type |key#0@@54|) (SeqType BoxType))) (or (|MemtableMod.Memtable.Query#canCall| (Lit this@@298) (Lit |key#0@@54|)) (and ($Is this@@298 Tclass.MemtableMod.Memtable) ($Is |key#0@@54| Tclass.KeyType.Key)))) (and (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@298)) (=> (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@298))) ($Box |key#0@@54|))) (MemtableMod.Memtable.Memtable_q (Lit this@@298)))) (=> (not (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@298))) ($Box |key#0@@54|)))) |ValueMessage.__default.NopDelta#canCall|)) (= (MemtableMod.Memtable.Query (Lit this@@298) (Lit |key#0@@54|)) (ite (U_2_bool (MapType0Select (|Map#Domain| (MemtableMod.Memtable.mapp (Lit this@@298))) ($Box |key#0@@54|))) ($Unbox DatatypeTypeType (MapType0Select (|Map#Elements| (Lit (MemtableMod.Memtable.mapp (Lit this@@298)))) ($Box (Lit |key#0@@54|)))) (|#ValueMessage.Message.Update| (Lit ValueMessage.__default.NopDelta))))))
 :qid |Memtableidfy.36:14|
 :weight 3
 :skolemid |3984|
 :pattern ( (MemtableMod.Memtable.Query (Lit this@@298) (Lit |key#0@@54|)))
))))
(assert  (=> true (forall ((this@@299 T@U) ) (!  (=> (and (= (type this@@299) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| this@@299) ($Is this@@299 Tclass.MemtableMod.Memtable))) ($Is (MemtableMod.Memtable.Drain this@@299) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.42:14|
 :skolemid |3985|
 :pattern ( (MemtableMod.Memtable.Drain this@@299))
))))
(assert (forall ((this@@300 T@U) ) (!  (=> (and (= (type this@@300) DatatypeTypeType) ($Is this@@300 Tclass.MemtableMod.Memtable)) (= (|MemtableMod.Memtable.Drain#requires| this@@300) true))
 :qid |Memtableidfy.42:14|
 :skolemid |3986|
 :pattern ( (|MemtableMod.Memtable.Drain#requires| this@@300))
)))
(assert  (=> true (forall ((this@@301 T@U) ) (!  (=> (and (= (type this@@301) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| this@@301) ($Is this@@301 Tclass.MemtableMod.Memtable))) (and (and (MemtableMod.Memtable.Memtable_q this@@301) (|MemtableMod.__default.EmptyMemtable#canCall| (MemtableMod.Memtable.seqEnd this@@301))) (= (MemtableMod.Memtable.Drain this@@301) (MemtableMod.__default.EmptyMemtable (MemtableMod.Memtable.seqEnd this@@301)))))
 :qid |Memtableidfy.42:14|
 :skolemid |3987|
 :pattern ( (MemtableMod.Memtable.Drain this@@301))
))))
(assert  (=> true (forall ((this@@302 T@U) ) (!  (=> (and (= (type this@@302) DatatypeTypeType) (or (|MemtableMod.Memtable.Drain#canCall| (Lit this@@302)) ($Is this@@302 Tclass.MemtableMod.Memtable))) (and (and (MemtableMod.Memtable.Memtable_q (Lit this@@302)) (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@302))))) (= (MemtableMod.Memtable.Drain (Lit this@@302)) (Lit (MemtableMod.__default.EmptyMemtable (LitInt (MemtableMod.Memtable.seqEnd (Lit this@@302))))))))
 :qid |Memtableidfy.42:14|
 :weight 3
 :skolemid |3988|
 :pattern ( (MemtableMod.Memtable.Drain (Lit this@@302)))
))))
(assert  (=> true (forall ((this@@303 T@U) ) (!  (=> (and (= (type this@@303) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| this@@303) ($Is this@@303 Tclass.MemtableMod.Memtable))) true)
 :qid |Memtableidfy.47:15|
 :skolemid |3989|
 :pattern ( (MemtableMod.Memtable.IsEmpty this@@303))
))))
(assert (forall ((this@@304 T@U) ) (!  (=> (and (= (type this@@304) DatatypeTypeType) ($Is this@@304 Tclass.MemtableMod.Memtable)) (= (|MemtableMod.Memtable.IsEmpty#requires| this@@304) true))
 :qid |Memtableidfy.47:15|
 :skolemid |3990|
 :pattern ( (|MemtableMod.Memtable.IsEmpty#requires| this@@304))
)))
(assert  (=> true (forall ((this@@305 T@U) ) (!  (=> (and (= (type this@@305) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| this@@305) ($Is this@@305 Tclass.MemtableMod.Memtable))) (and (MemtableMod.Memtable.Memtable_q this@@305) (= (MemtableMod.Memtable.IsEmpty this@@305) (|Set#Equal| (|Map#Domain| (MemtableMod.Memtable.mapp this@@305)) (|Set#Empty| BoxType)))))
 :qid |Memtableidfy.47:15|
 :skolemid |3991|
 :pattern ( (MemtableMod.Memtable.IsEmpty this@@305))
))))
(assert  (=> true (forall ((this@@306 T@U) ) (!  (=> (and (= (type this@@306) DatatypeTypeType) (or (|MemtableMod.Memtable.IsEmpty#canCall| (Lit this@@306)) ($Is this@@306 Tclass.MemtableMod.Memtable))) (and (MemtableMod.Memtable.Memtable_q (Lit this@@306)) (= (MemtableMod.Memtable.IsEmpty (Lit this@@306)) (|Set#Equal| (|Map#Domain| (Lit (MemtableMod.Memtable.mapp (Lit this@@306)))) (|Set#Empty| BoxType)))))
 :qid |Memtableidfy.47:15|
 :weight 3
 :skolemid |3992|
 :pattern ( (MemtableMod.Memtable.IsEmpty (Lit this@@306)))
))))
(assert (= (type Tclass.MemtableMod.__default) TyType))
(assert (= (Tag Tclass.MemtableMod.__default) Tagclass.MemtableMod.__default))
(assert (= (TagFamily Tclass.MemtableMod.__default) tytagFamily$_default))
(assert (forall ((bx@@161 T@U) ) (!  (=> (and (= (type bx@@161) BoxType) ($IsBox bx@@161 Tclass.MemtableMod.__default)) (and (= ($Box ($Unbox refType bx@@161)) bx@@161) ($Is ($Unbox refType bx@@161) Tclass.MemtableMod.__default)))
 :qid |unknown.0:0|
 :skolemid |3993|
 :pattern ( ($IsBox bx@@161 Tclass.MemtableMod.__default))
)))
(assert (forall (($o@@49 T@U) ) (!  (=> (= (type $o@@49) refType) (= ($Is $o@@49 Tclass.MemtableMod.__default)  (or (= $o@@49 null) (= (dtype $o@@49) Tclass.MemtableMod.__default))))
 :qid |unknown.0:0|
 :skolemid |3994|
 :pattern ( ($Is $o@@49 Tclass.MemtableMod.__default))
)))
(assert (forall (($o@@50 T@U) ($h@@156 T@U) ) (!  (=> (and (= (type $o@@50) refType) (= (type $h@@156) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@156)  (or (= $o@@50 null) (U_2_bool (MapType1Select (MapType0Select $h@@156 $o@@50) alloc)))))
 :qid |unknown.0:0|
 :skolemid |3995|
 :pattern ( ($IsAlloc $o@@50 Tclass.MemtableMod.__default $h@@156))
)))
(assert  (=> true (forall ((|lsn#0@@36| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| |lsn#0@@36|) (INTERNAL_le_boogie 0 |lsn#0@@36|)) ($Is (MemtableMod.__default.EmptyMemtable |lsn#0@@36|) Tclass.MemtableMod.Memtable))
 :qid |Memtableidfy.53:26|
 :skolemid |3996|
 :pattern ( (MemtableMod.__default.EmptyMemtable |lsn#0@@36|))
))))
(assert (forall ((|lsn#0@@37| Int) ) (!  (=> (INTERNAL_le_boogie 0 |lsn#0@@37|) (= (|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|) true))
 :qid |Memtableidfy.53:26|
 :skolemid |3997|
 :pattern ( (|MemtableMod.__default.EmptyMemtable#requires| |lsn#0@@37|))
)))
(assert  (=> true (forall ((|lsn#0@@38| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| |lsn#0@@38|) (INTERNAL_le_boogie 0 |lsn#0@@38|)) (= (MemtableMod.__default.EmptyMemtable |lsn#0@@38|) (|#MemtableMod.Memtable.Memtable| (Lit (|Map#Empty| BoxType BoxType)) |lsn#0@@38|)))
 :qid |Memtableidfy.53:26|
 :skolemid |3998|
 :pattern ( (MemtableMod.__default.EmptyMemtable |lsn#0@@38|))
))))
(assert  (=> true (forall ((|lsn#0@@39| Int) ) (!  (=> (or (|MemtableMod.__default.EmptyMemtable#canCall| (LitInt |lsn#0@@39|)) (INTERNAL_le_boogie 0 |lsn#0@@39|)) (= (MemtableMod.__default.EmptyMemtable (LitInt |lsn#0@@39|)) (Lit (|#MemtableMod.Memtable.Memtable| (Lit (|Map#Empty| BoxType BoxType)) (LitInt |lsn#0@@39|)))))
 :qid |Memtableidfy.53:26|
 :weight 3
 :skolemid |3999|
 :pattern ( (MemtableMod.__default.EmptyMemtable (LitInt |lsn#0@@39|)))
))))
(assert (= (type Tclass.Sets.__default) TyType))
(assert (= (Tag Tclass.Sets.__default) Tagclass.Sets.__default))
(assert (= (TagFamily Tclass.Sets.__default) tytagFamily$_default))
(assert (forall ((bx@@162 T@U) ) (!  (=> (and (= (type bx@@162) BoxType) ($IsBox bx@@162 Tclass.Sets.__default)) (and (= ($Box ($Unbox refType bx@@162)) bx@@162) ($Is ($Unbox refType bx@@162) Tclass.Sets.__default)))
 :qid |unknown.0:0|
 :skolemid |4000|
 :pattern ( ($IsBox bx@@162 Tclass.Sets.__default))
)))
(assert (forall (($o@@51 T@U) ) (!  (=> (= (type $o@@51) refType) (= ($Is $o@@51 Tclass.Sets.__default)  (or (= $o@@51 null) (= (dtype $o@@51) Tclass.Sets.__default))))
 :qid |unknown.0:0|
 :skolemid |4001|
 :pattern ( ($Is $o@@51 Tclass.Sets.__default))
)))
(assert (forall (($o@@52 T@U) ($h@@157 T@U) ) (!  (=> (and (= (type $o@@52) refType) (= (type $h@@157) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@52 Tclass.Sets.__default $h@@157)  (or (= $o@@52 null) (U_2_bool (MapType1Select (MapType0Select $h@@157 $o@@52) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4002|
 :pattern ( ($IsAlloc $o@@52 Tclass.Sets.__default $h@@157))
)))
(assert (forall ((arg0@@597 Int) ) (! (= (type (Sets.__default.SetRange arg0@@597)) (MapType0Type BoxType boolType))
 :qid |funType:Sets.__default.SetRange|
 :pattern ( (Sets.__default.SetRange arg0@@597))
)))
(assert  (=> true (forall ((|n#0@@12| Int) ) (!  (=> true ($Is (Sets.__default.SetRange |n#0@@12|) (TSet TInt)))
 :qid |Setsidfy.35:21|
 :skolemid |4003|
 :pattern ( (Sets.__default.SetRange |n#0@@12|))
))))
(assert (forall ((|n#0@@13| Int) ) (! (= (|Sets.__default.SetRange#requires| |n#0@@13|) true)
 :qid |Setsidfy.35:21|
 :skolemid |4004|
 :pattern ( (|Sets.__default.SetRange#requires| |n#0@@13|))
)))
(assert  (=> true (forall ((|n#0@@14| Int) ) (!  (=> true (= (Sets.__default.SetRange |n#0@@14|) (|lambda#248| TInt 0 |n#0@@14|)))
 :qid |Setsidfy.35:21|
 :skolemid |4005|
 :pattern ( (Sets.__default.SetRange |n#0@@14|))
))))
(assert  (=> true (forall ((|n#0@@15| Int) ) (!  (=> true (= (Sets.__default.SetRange (LitInt |n#0@@15|)) (|lambda#248| TInt 0 |n#0@@15|)))
 :qid |Setsidfy.35:21|
 :weight 3
 :skolemid |4006|
 :pattern ( (Sets.__default.SetRange (LitInt |n#0@@15|)))
))))
(assert (forall (($ly@@348 T@U) (|a#0@@86| T@U) ) (!  (=> (and (= (type $ly@@348) LayerTypeType) (= (type |a#0@@86|) (MapType0Type BoxType boolType))) (= (Sets.__default.SetMax ($LS $ly@@348) |a#0@@86|) (Sets.__default.SetMax $ly@@348 |a#0@@86|)))
 :qid |Setsidfy.59:12|
 :skolemid |4007|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@348) |a#0@@86|))
)))
(assert (forall (($ly@@349 T@U) (|a#0@@87| T@U) ) (!  (=> (and (= (type $ly@@349) LayerTypeType) (= (type |a#0@@87|) (MapType0Type BoxType boolType))) (= (Sets.__default.SetMax $ly@@349 |a#0@@87|) (Sets.__default.SetMax $LZ |a#0@@87|)))
 :qid |Setsidfy.59:12|
 :skolemid |4008|
 :pattern ( (Sets.__default.SetMax (AsFuelBottom $ly@@349) |a#0@@87|))
)))
(assert  (=> true (forall (($ly@@350 T@U) (|a#0@@88| T@U) ) (!  (=> (and (and (= (type $ly@@350) LayerTypeType) (= (type |a#0@@88|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| |a#0@@88|) (and ($Is |a#0@@88| (TSet TInt)) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@88|))))) (and (forall ((|e#0@@4| T@U) ) (!  (=> (and (= (type |e#0@@4|) intType) (U_2_bool (MapType0Select |a#0@@88| ($Box |e#0@@4|)))) (INTERNAL_le_boogie (U_2_int |e#0@@4|) (Sets.__default.SetMax $ly@@350 |a#0@@88|)))
 :qid |Setsidfy.61:20|
 :skolemid |4009|
 :pattern ( (MapType0Select |a#0@@88| ($Box |e#0@@4|)))
)) (U_2_bool (MapType0Select |a#0@@88| ($Box (int_2_U (Sets.__default.SetMax $ly@@350 |a#0@@88|)))))))
 :qid |Setsidfy.59:12|
 :skolemid |4010|
 :pattern ( (Sets.__default.SetMax $ly@@350 |a#0@@88|))
))))
(assert (forall (($ly@@351 T@U) ($Heap@@57 T@U) (|a#0@@89| T@U) ) (!  (=> (and (and (and (= (type $ly@@351) LayerTypeType) (= (type $Heap@@57) (MapType0Type refType MapType1Type))) (= (type |a#0@@89|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@57) ($Is |a#0@@89| (TSet TInt)))) (= (|Sets.__default.SetMax#requires| $ly@@351 |a#0@@89|) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@89|))))
 :qid |Setsidfy.59:12|
 :skolemid |4011|
 :pattern ( (|Sets.__default.SetMax#requires| $ly@@351 |a#0@@89|) ($IsGoodHeap $Heap@@57))
)))
(assert (forall ((a@@166 T@U) ) (!  (=> (and (= (type a@@166) (MapType0Type BoxType boolType)) (|$let#13$canCall| a@@166)) (U_2_bool (MapType0Select a@@166 ($Box (int_2_U (|$let#13_e| a@@166))))))
 :qid |Setsidfy.64:5|
 :skolemid |4012|
 :pattern ( (|$let#13_e| a@@166))
)))
(assert  (=> true (forall (($ly@@352 T@U) ($Heap@@58 T@U) (|a#0@@90| T@U) ) (!  (=> (and (and (and (= (type $ly@@352) LayerTypeType) (= (type $Heap@@58) (MapType0Type refType MapType1Type))) (= (type |a#0@@90|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| |a#0@@90|) (and (and ($IsGoodHeap $Heap@@58) ($Is |a#0@@90| (TSet TInt))) (INTERNAL_lt_boogie 0 (|Set#Card| |a#0@@90|))))) (and (and (|$let#13$canCall| |a#0@@90|) (=> (not (= (|Set#Card| |a#0@@90|) (LitInt 1))) (|Sets.__default.SetMax#canCall| (|Set#Difference| |a#0@@90| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#13_e| |a#0@@90|)))))))) (= (Sets.__default.SetMax ($LS $ly@@352) |a#0@@90|) (let ((|e#1| (|$let#13_e| |a#0@@90|)))
(ite (= (|Set#Card| |a#0@@90|) (LitInt 1)) |e#1| (let ((|rest#0| (Sets.__default.SetMax $ly@@352 (|Set#Difference| |a#0@@90| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#1|)))))))
(let ((|out#0@@1| (ite (INTERNAL_lt_boogie |e#1| |rest#0|) |rest#0| |e#1|)))
|out#0@@1|)))))))
 :qid |Setsidfy.59:12|
 :skolemid |4013|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@352) |a#0@@90|) ($IsGoodHeap $Heap@@58))
))))
(assert  (=> true (forall (($ly@@353 T@U) ($Heap@@59 T@U) (|a#0@@91| T@U) ) (!  (=> (and (and (and (= (type $ly@@353) LayerTypeType) (= (type $Heap@@59) (MapType0Type refType MapType1Type))) (= (type |a#0@@91|) (MapType0Type BoxType boolType))) (or (|Sets.__default.SetMax#canCall| (Lit |a#0@@91|)) (and (and ($IsGoodHeap $Heap@@59) ($Is |a#0@@91| (TSet TInt))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |a#0@@91|)))))) (and (and (|$let#13$canCall| (Lit |a#0@@91|)) (=> (not (= (|Set#Card| (Lit |a#0@@91|)) (LitInt 1))) (|Sets.__default.SetMax#canCall| (|Set#Difference| |a#0@@91| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#13_e| (Lit |a#0@@91|))))))))) (= (Sets.__default.SetMax ($LS $ly@@353) (Lit |a#0@@91|)) (let ((|e#2| (|$let#13_e| (Lit |a#0@@91|))))
(ite (= (|Set#Card| (Lit |a#0@@91|)) (LitInt 1)) |e#2| (let ((|rest#2| (Sets.__default.SetMax ($LS $ly@@353) (|Set#Difference| |a#0@@91| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#2|)))))))
(let ((|out#2| (ite (INTERNAL_lt_boogie |e#2| |rest#2|) |rest#2| |e#2|)))
|out#2|)))))))
 :qid |Setsidfy.59:12|
 :weight 3
 :skolemid |4014|
 :pattern ( (Sets.__default.SetMax ($LS $ly@@353) (Lit |a#0@@91|)) ($IsGoodHeap $Heap@@59))
))))
(assert (forall ((arg0@@598 T@U) (arg1@@302 T@U) (arg2@@163 T@U) ) (! (= (type (Sets.__default.UnionSeqOfSets arg0@@598 arg1@@302 arg2@@163)) (MapType0Type BoxType boolType))
 :qid |funType:Sets.__default.UnionSeqOfSets|
 :pattern ( (Sets.__default.UnionSeqOfSets arg0@@598 arg1@@302 arg2@@163))
)))
(assert (forall ((Sets._default.UnionSeqOfSets$T T@U) ($ly@@354 T@U) (|s#0@@107| T@U) ) (!  (=> (and (and (= (type Sets._default.UnionSeqOfSets$T) TyType) (= (type $ly@@354) LayerTypeType)) (= (type |s#0@@107|) (SeqType BoxType))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T ($LS $ly@@354) |s#0@@107|) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T $ly@@354 |s#0@@107|)))
 :qid |unknown.0:0|
 :skolemid |4015|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T ($LS $ly@@354) |s#0@@107|))
)))
(assert (forall ((Sets._default.UnionSeqOfSets$T@@0 T@U) ($ly@@355 T@U) (|s#0@@108| T@U) ) (!  (=> (and (and (= (type Sets._default.UnionSeqOfSets$T@@0) TyType) (= (type $ly@@355) LayerTypeType)) (= (type |s#0@@108|) (SeqType BoxType))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 $ly@@355 |s#0@@108|) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 $LZ |s#0@@108|)))
 :qid |unknown.0:0|
 :skolemid |4016|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@0 (AsFuelBottom $ly@@355) |s#0@@108|))
)))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@1 T@U) ($ly@@356 T@U) (|s#0@@109| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@1) TyType) (= (type $ly@@356) LayerTypeType)) (= (type |s#0@@109|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@1 |s#0@@109|) ($Is |s#0@@109| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@1))))) (and (forall ((|i#0@@136| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@136|) (INTERNAL_lt_boogie |i#0@@136| (|Seq#Length| |s#0@@109|))) (|Set#Subset| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@109| |i#0@@136|)) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@356 |s#0@@109|)))
 :qid |Setsidfy.93:20|
 :skolemid |4017|
 :pattern ( ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@109| |i#0@@136|)))
)) ($Is (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@356 |s#0@@109|) (TSet Sets._default.UnionSeqOfSets$T@@1))))
 :qid |unknown.0:0|
 :skolemid |4018|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@1 $ly@@356 |s#0@@109|))
))))
(assert (forall ((Sets._default.UnionSeqOfSets$T@@2 T@U) ($ly@@357 T@U) (|s#0@@110| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@2) TyType) (= (type $ly@@357) LayerTypeType)) (= (type |s#0@@110|) (SeqType BoxType))) ($Is |s#0@@110| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@2)))) (= (|Sets.__default.UnionSeqOfSets#requires| Sets._default.UnionSeqOfSets$T@@2 $ly@@357 |s#0@@110|) true))
 :qid |unknown.0:0|
 :skolemid |4019|
 :pattern ( (|Sets.__default.UnionSeqOfSets#requires| Sets._default.UnionSeqOfSets$T@@2 $ly@@357 |s#0@@110|))
)))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@3 T@U) ($ly@@358 T@U) (|s#0@@111| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@3) TyType) (= (type $ly@@358) LayerTypeType)) (= (type |s#0@@111|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@3 |s#0@@111|) ($Is |s#0@@111| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@3))))) (and (=> (not (= (|Seq#Length| |s#0@@111|) (LitInt 0))) (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@3 (|Seq#Drop| |s#0@@111| (LitInt 1)))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 ($LS $ly@@358) |s#0@@111|) (ite (= (|Seq#Length| |s#0@@111|) (LitInt 0)) (|Set#Empty| BoxType) (|Set#Union| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| |s#0@@111| (LitInt 0))) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 $ly@@358 (|Seq#Drop| |s#0@@111| (LitInt 1))))))))
 :qid |unknown.0:0|
 :skolemid |4020|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@3 ($LS $ly@@358) |s#0@@111|))
))))
(assert  (=> true (forall ((Sets._default.UnionSeqOfSets$T@@4 T@U) ($ly@@359 T@U) (|s#0@@112| T@U) ) (!  (=> (and (and (and (= (type Sets._default.UnionSeqOfSets$T@@4) TyType) (= (type $ly@@359) LayerTypeType)) (= (type |s#0@@112|) (SeqType BoxType))) (or (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@4 (Lit |s#0@@112|)) ($Is |s#0@@112| (TSeq (TSet Sets._default.UnionSeqOfSets$T@@4))))) (and (=> (not (= (|Seq#Length| (Lit |s#0@@112|)) (LitInt 0))) (|Sets.__default.UnionSeqOfSets#canCall| Sets._default.UnionSeqOfSets$T@@4 (Lit (|Seq#Drop| (Lit |s#0@@112|) (LitInt 1))))) (= (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@359) (Lit |s#0@@112|)) (ite (= (|Seq#Length| (Lit |s#0@@112|)) (LitInt 0)) (|Set#Empty| BoxType) (|Set#Union| ($Unbox (MapType0Type BoxType boolType) (|Seq#Index| (Lit |s#0@@112|) (LitInt 0))) (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@359) (Lit (|Seq#Drop| (Lit |s#0@@112|) (LitInt 1)))))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4021|
 :pattern ( (Sets.__default.UnionSeqOfSets Sets._default.UnionSeqOfSets$T@@4 ($LS $ly@@359) (Lit |s#0@@112|)))
))))
(assert (= (type Tclass.SeqComparison.__default) TyType))
(assert (= (Tag Tclass.SeqComparison.__default) Tagclass.SeqComparison.__default))
(assert (= (TagFamily Tclass.SeqComparison.__default) tytagFamily$_default))
(assert (forall ((bx@@163 T@U) ) (!  (=> (and (= (type bx@@163) BoxType) ($IsBox bx@@163 Tclass.SeqComparison.__default)) (and (= ($Box ($Unbox refType bx@@163)) bx@@163) ($Is ($Unbox refType bx@@163) Tclass.SeqComparison.__default)))
 :qid |unknown.0:0|
 :skolemid |4022|
 :pattern ( ($IsBox bx@@163 Tclass.SeqComparison.__default))
)))
(assert (forall (($o@@53 T@U) ) (!  (=> (= (type $o@@53) refType) (= ($Is $o@@53 Tclass.SeqComparison.__default)  (or (= $o@@53 null) (= (dtype $o@@53) Tclass.SeqComparison.__default))))
 :qid |unknown.0:0|
 :skolemid |4023|
 :pattern ( ($Is $o@@53 Tclass.SeqComparison.__default))
)))
(assert (forall (($o@@54 T@U) ($h@@158 T@U) ) (!  (=> (and (= (type $o@@54) refType) (= (type $h@@158) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@54 Tclass.SeqComparison.__default $h@@158)  (or (= $o@@54 null) (U_2_bool (MapType1Select (MapType0Select $h@@158 $o@@54) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4024|
 :pattern ( ($IsAlloc $o@@54 Tclass.SeqComparison.__default $h@@158))
)))
(assert (forall (($ly@@360 T@U) (|a#0@@92| T@U) (|b#0@@50| T@U) ) (!  (=> (and (and (= (type $ly@@360) LayerTypeType) (= (type |a#0@@92|) (SeqType BoxType))) (= (type |b#0@@50|) (SeqType BoxType))) (= (SeqComparison.__default.lte ($LS $ly@@360) |a#0@@92| |b#0@@50|) (SeqComparison.__default.lte $ly@@360 |a#0@@92| |b#0@@50|)))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |4025|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@360) |a#0@@92| |b#0@@50|))
)))
(assert (forall (($ly@@361 T@U) (|a#0@@93| T@U) (|b#0@@51| T@U) ) (!  (=> (and (and (= (type $ly@@361) LayerTypeType) (= (type |a#0@@93|) (SeqType BoxType))) (= (type |b#0@@51|) (SeqType BoxType))) (= (SeqComparison.__default.lte $ly@@361 |a#0@@93| |b#0@@51|) (SeqComparison.__default.lte $LZ |a#0@@93| |b#0@@51|)))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |4026|
 :pattern ( (SeqComparison.__default.lte (AsFuelBottom $ly@@361) |a#0@@93| |b#0@@51|))
)))
(assert  (=> true (forall (($ly@@362 T@U) (|a#0@@94| T@U) (|b#0@@52| T@U) ) (!  (=> (and (and (and (= (type $ly@@362) LayerTypeType) (= (type |a#0@@94|) (SeqType BoxType))) (= (type |b#0@@52|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| |a#0@@94| |b#0@@52|) (and ($Is |a#0@@94| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@52| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |4027|
 :pattern ( (SeqComparison.__default.lte $ly@@362 |a#0@@94| |b#0@@52|))
))))
(assert (forall (($ly@@363 T@U) (|a#0@@95| T@U) (|b#0@@53| T@U) ) (!  (=> (and (and (and (= (type $ly@@363) LayerTypeType) (= (type |a#0@@95|) (SeqType BoxType))) (= (type |b#0@@53|) (SeqType BoxType))) (and ($Is |a#0@@95| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@53| (TSeq Tclass.NativeTypes.byte)))) (= (|SeqComparison.__default.lte#requires| $ly@@363 |a#0@@95| |b#0@@53|) true))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |4028|
 :pattern ( (|SeqComparison.__default.lte#requires| $ly@@363 |a#0@@95| |b#0@@53|))
)))
(assert  (=> true (forall (($ly@@364 T@U) (|a#0@@96| T@U) (|b#0@@54| T@U) ) (!  (=> (and (and (and (= (type $ly@@364) LayerTypeType) (= (type |a#0@@96|) (SeqType BoxType))) (= (type |b#0@@54|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| |a#0@@96| |b#0@@54|) (and ($Is |a#0@@96| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@54| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| |a#0@@96|) (LitInt 0))) (=> (not (= (|Seq#Length| |b#0@@54|) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (|Seq#Drop| |a#0@@96| (LitInt 1)) (|Seq#Drop| |b#0@@54| (LitInt 1))))))) (= (SeqComparison.__default.lte ($LS $ly@@364) |a#0@@96| |b#0@@54|) (ite (= (|Seq#Length| |a#0@@96|) (LitInt 0)) true (ite (= (|Seq#Length| |b#0@@54|) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@54| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |a#0@@96| (LitInt 0))))) false (SeqComparison.__default.lte $ly@@364 (|Seq#Drop| |a#0@@96| (LitInt 1)) (|Seq#Drop| |b#0@@54| (LitInt 1))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :skolemid |4029|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@364) |a#0@@96| |b#0@@54|))
))))
(assert  (=> true (forall (($ly@@365 T@U) (|a#0@@97| T@U) (|b#0@@55| T@U) ) (!  (=> (and (and (and (= (type $ly@@365) LayerTypeType) (= (type |a#0@@97|) (SeqType BoxType))) (= (type |b#0@@55|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| (Lit |a#0@@97|) |b#0@@55|) (and ($Is |a#0@@97| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@55| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@97|)) (LitInt 0))) (=> (not (= (|Seq#Length| |b#0@@55|) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (Lit (|Seq#Drop| (Lit |a#0@@97|) (LitInt 1))) (|Seq#Drop| |b#0@@55| (LitInt 1))))))) (= (SeqComparison.__default.lte ($LS $ly@@365) (Lit |a#0@@97|) |b#0@@55|) (ite (= (|Seq#Length| (Lit |a#0@@97|)) (LitInt 0)) true (ite (= (|Seq#Length| |b#0@@55|) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| |b#0@@55| (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@97|) (LitInt 0))))) false (SeqComparison.__default.lte ($LS $ly@@365) (Lit (|Seq#Drop| (Lit |a#0@@97|) (LitInt 1))) (|Seq#Drop| |b#0@@55| (LitInt 1))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :weight 3
 :skolemid |4030|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@365) (Lit |a#0@@97|) |b#0@@55|))
))))
(assert  (=> true (forall (($ly@@366 T@U) (|a#0@@98| T@U) (|b#0@@56| T@U) ) (!  (=> (and (and (and (= (type $ly@@366) LayerTypeType) (= (type |a#0@@98|) (SeqType BoxType))) (= (type |b#0@@56|) (SeqType BoxType))) (or (|SeqComparison.__default.lte#canCall| (Lit |a#0@@98|) (Lit |b#0@@56|)) (and ($Is |a#0@@98| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@56| (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (= (|Seq#Length| (Lit |a#0@@98|)) (LitInt 0))) (=> (not (= (|Seq#Length| (Lit |b#0@@56|)) (LitInt 0))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))))) (=> (not (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))))) (|SeqComparison.__default.lte#canCall| (Lit (|Seq#Drop| (Lit |a#0@@98|) (LitInt 1))) (Lit (|Seq#Drop| (Lit |b#0@@56|) (LitInt 1)))))))) (= (SeqComparison.__default.lte ($LS $ly@@366) (Lit |a#0@@98|) (Lit |b#0@@56|)) (ite (= (|Seq#Length| (Lit |a#0@@98|)) (LitInt 0)) true (ite (= (|Seq#Length| (Lit |b#0@@56|)) (LitInt 0)) false (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0))))) true (ite (INTERNAL_lt_boogie (U_2_int ($Unbox intType (|Seq#Index| (Lit |b#0@@56|) (LitInt 0)))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |a#0@@98|) (LitInt 0))))) false (SeqComparison.__default.lte ($LS $ly@@366) (Lit (|Seq#Drop| (Lit |a#0@@98|) (LitInt 1))) (Lit (|Seq#Drop| (Lit |b#0@@56|) (LitInt 1)))))))))))
 :qid |SeqComparisonsdfy.14:23|
 :weight 3
 :skolemid |4031|
 :pattern ( (SeqComparison.__default.lte ($LS $ly@@366) (Lit |a#0@@98|) (Lit |b#0@@56|)))
))))
(assert  (=> true (forall ((|a#0@@99| T@U) (|b#0@@57| T@U) ) (!  (=> (and (and (= (type |a#0@@99|) (SeqType BoxType)) (= (type |b#0@@57|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| |a#0@@99| |b#0@@57|) (and ($Is |a#0@@99| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@57| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |4032|
 :pattern ( (SeqComparison.__default.lt |a#0@@99| |b#0@@57|))
))))
(assert (forall ((|a#0@@100| T@U) (|b#0@@58| T@U) ) (!  (=> (and (and (= (type |a#0@@100|) (SeqType BoxType)) (= (type |b#0@@58|) (SeqType BoxType))) (and ($Is |a#0@@100| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@58| (TSeq Tclass.NativeTypes.byte)))) (= (|SeqComparison.__default.lt#requires| |a#0@@100| |b#0@@58|) true))
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |4033|
 :pattern ( (|SeqComparison.__default.lt#requires| |a#0@@100| |b#0@@58|))
)))
(assert (= (type StartFuel_SeqComparison._default.lte) LayerTypeType))
(assert  (=> true (forall ((|a#0@@101| T@U) (|b#0@@59| T@U) ) (!  (=> (and (and (= (type |a#0@@101|) (SeqType BoxType)) (= (type |b#0@@59|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| |a#0@@101| |b#0@@59|) (and ($Is |a#0@@101| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@59| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@101| |b#0@@59|) (= (SeqComparison.__default.lt |a#0@@101| |b#0@@59|)  (and (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@101| |b#0@@59|) (not (|Seq#Equal| |a#0@@101| |b#0@@59|))))))
 :qid |SeqComparisonsdfy.30:16|
 :skolemid |4034|
 :pattern ( (SeqComparison.__default.lt |a#0@@101| |b#0@@59|))
))))
(assert  (=> true (forall ((|a#0@@102| T@U) (|b#0@@60| T@U) ) (!  (=> (and (and (= (type |a#0@@102|) (SeqType BoxType)) (= (type |b#0@@60|) (SeqType BoxType))) (or (|SeqComparison.__default.lt#canCall| (Lit |a#0@@102|) (Lit |b#0@@60|)) (and ($Is |a#0@@102| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@60| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@102|) (Lit |b#0@@60|)) (= (SeqComparison.__default.lt (Lit |a#0@@102|) (Lit |b#0@@60|))  (and (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@102|) (Lit |b#0@@60|)) (not (|Seq#Equal| |a#0@@102| |b#0@@60|))))))
 :qid |SeqComparisonsdfy.30:16|
 :weight 3
 :skolemid |4035|
 :pattern ( (SeqComparison.__default.lt (Lit |a#0@@102|) (Lit |b#0@@60|)))
))))
(assert (= (type Tclass.NativeArrays.__default) TyType))
(assert (= (Tag Tclass.NativeArrays.__default) Tagclass.NativeArrays.__default))
(assert (= (TagFamily Tclass.NativeArrays.__default) tytagFamily$_default))
(assert (forall ((bx@@164 T@U) ) (!  (=> (and (= (type bx@@164) BoxType) ($IsBox bx@@164 Tclass.NativeArrays.__default)) (and (= ($Box ($Unbox refType bx@@164)) bx@@164) ($Is ($Unbox refType bx@@164) Tclass.NativeArrays.__default)))
 :qid |unknown.0:0|
 :skolemid |4036|
 :pattern ( ($IsBox bx@@164 Tclass.NativeArrays.__default))
)))
(assert (forall (($o@@55 T@U) ) (!  (=> (= (type $o@@55) refType) (= ($Is $o@@55 Tclass.NativeArrays.__default)  (or (= $o@@55 null) (= (dtype $o@@55) Tclass.NativeArrays.__default))))
 :qid |unknown.0:0|
 :skolemid |4037|
 :pattern ( ($Is $o@@55 Tclass.NativeArrays.__default))
)))
(assert (forall (($o@@56 T@U) ($h@@159 T@U) ) (!  (=> (and (= (type $o@@56) refType) (= (type $h@@159) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@56 Tclass.NativeArrays.__default $h@@159)  (or (= $o@@56 null) (U_2_bool (MapType1Select (MapType0Select $h@@159 $o@@56) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4038|
 :pattern ( ($IsAlloc $o@@56 Tclass.NativeArrays.__default $h@@159))
)))
(assert (= (type Tclass.Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Byte__Order.__default) Tagclass.Byte__Order.__default))
(assert (= (TagFamily Tclass.Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@165 T@U) ) (!  (=> (and (= (type bx@@165) BoxType) ($IsBox bx@@165 Tclass.Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@165)) bx@@165) ($Is ($Unbox refType bx@@165) Tclass.Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |4039|
 :pattern ( ($IsBox bx@@165 Tclass.Byte__Order.__default))
)))
(assert (forall (($o@@57 T@U) ) (!  (=> (= (type $o@@57) refType) (= ($Is $o@@57 Tclass.Byte__Order.__default)  (or (= $o@@57 null) (= (dtype $o@@57) Tclass.Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |4040|
 :pattern ( ($Is $o@@57 Tclass.Byte__Order.__default))
)))
(assert (forall (($o@@58 T@U) ($h@@160 T@U) ) (!  (=> (and (= (type $o@@58) refType) (= (type $h@@160) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@58 Tclass.Byte__Order.__default $h@@160)  (or (= $o@@58 null) (U_2_bool (MapType1Select (MapType0Select $h@@160 $o@@58) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4041|
 :pattern ( ($IsAlloc $o@@58 Tclass.Byte__Order.__default $h@@160))
)))
(assert  (=> true (=> true (and (INTERNAL_le_boogie 0 Byte__Order.__default.SomeElement) (INTERNAL_lt_boogie Byte__Order.__default.SomeElement 256)))))
(assert (= |Byte__Order.__default.SomeElement#requires| true))
(assert  (=> true (=> true (= Byte__Order.__default.SomeElement (LitInt 0)))))
(assert  (=> true (=> true (= Byte__Order.__default.SomeElement (LitInt 0)))))
(assert (forall (($ly@@367 T@U) (|a#0@@103| Int) (|b#0@@61| Int) ) (!  (=> (= (type $ly@@367) LayerTypeType) (= (Byte__Order.__default.lte ($LS $ly@@367) |a#0@@103| |b#0@@61|) (Byte__Order.__default.lte $ly@@367 |a#0@@103| |b#0@@61|)))
 :qid |totalorderidfy.1087:30|
 :skolemid |4042|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@367) |a#0@@103| |b#0@@61|))
)))
(assert (forall (($ly@@368 T@U) (|a#0@@104| Int) (|b#0@@62| Int) ) (!  (=> (= (type $ly@@368) LayerTypeType) (= (Byte__Order.__default.lte $ly@@368 |a#0@@104| |b#0@@62|) (Byte__Order.__default.lte $LZ |a#0@@104| |b#0@@62|)))
 :qid |totalorderidfy.1087:30|
 :skolemid |4043|
 :pattern ( (Byte__Order.__default.lte (AsFuelBottom $ly@@368) |a#0@@104| |b#0@@62|))
)))
(assert (= (type StartFuel_Byte_Order._default.ltedef) LayerTypeType))
(assert  (=> true (forall (($ly@@369 T@U) (|a#0@@105| Int) (|b#0@@63| Int) ) (!  (=> (and (= (type $ly@@369) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| |a#0@@105| |b#0@@63|) (and (and (INTERNAL_le_boogie 0 |a#0@@105|) (INTERNAL_lt_boogie |a#0@@105| 256)) (and (INTERNAL_le_boogie 0 |b#0@@63|) (INTERNAL_lt_boogie |b#0@@63| 256))))) (and (and (and (and (= (Byte__Order.__default.lte $ly@@369 |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|)) (or (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|))) (= (Byte__Order.__default.lte $ly@@369 |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|))) (or (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|))) (=> (and (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |a#0@@105| |b#0@@63|) (Byte__Order.__default.ltedef StartFuel_Byte_Order._default.ltedef |b#0@@63| |a#0@@105|)) (= |a#0@@105| |b#0@@63|))))
 :qid |totalorderidfy.1087:30|
 :skolemid |4044|
 :pattern ( (Byte__Order.__default.lte $ly@@369 |a#0@@105| |b#0@@63|))
))))
(assert (forall (($ly@@370 T@U) (|a#0@@106| Int) (|b#0@@64| Int) ) (!  (=> (= (type $ly@@370) LayerTypeType) (=> (and (and (INTERNAL_le_boogie 0 |a#0@@106|) (INTERNAL_lt_boogie |a#0@@106| 256)) (and (INTERNAL_le_boogie 0 |b#0@@64|) (INTERNAL_lt_boogie |b#0@@64| 256))) (= (|Byte__Order.__default.lte#requires| $ly@@370 |a#0@@106| |b#0@@64|) true)))
 :qid |totalorderidfy.1087:30|
 :skolemid |4045|
 :pattern ( (|Byte__Order.__default.lte#requires| $ly@@370 |a#0@@106| |b#0@@64|))
)))
(assert  (and (= (type MoreFuel_Byte_Order._default.ltedef0) LayerTypeType) (= (type StartFuelAssert_Byte_Order._default.ltedef) LayerTypeType)))
(assert  (=> true (forall (($ly@@371 T@U) (|a#0@@107| Int) (|b#0@@65| Int) ) (!  (=> (and (= (type $ly@@371) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| |a#0@@107| |b#0@@65|) (and (and (INTERNAL_le_boogie 0 |a#0@@107|) (INTERNAL_lt_boogie |a#0@@107| 256)) (and (INTERNAL_le_boogie 0 |b#0@@65|) (INTERNAL_lt_boogie |b#0@@65| 256))))) (and (and (and (= StartFuel_Byte_Order._default.ltedef ($LS MoreFuel_Byte_Order._default.ltedef0)) (= StartFuelAssert_Byte_Order._default.ltedef ($LS ($LS MoreFuel_Byte_Order._default.ltedef0)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.ltedef0) MoreFuel_Byte_Order._default.ltedef0)) (= (Byte__Order.__default.lte ($LS $ly@@371) |a#0@@107| |b#0@@65|) (INTERNAL_le_boogie |a#0@@107| |b#0@@65|))))
 :qid |totalorderidfy.1087:30|
 :skolemid |4046|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@371) |a#0@@107| |b#0@@65|))
))))
(assert (= (type MoreFuel_Byte_Order._default.ltedef1) LayerTypeType))
(assert  (=> true (forall (($ly@@372 T@U) (|a#0@@108| Int) (|b#0@@66| Int) ) (!  (=> (and (= (type $ly@@372) LayerTypeType) (or (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@108|) (LitInt |b#0@@66|)) (and (and (INTERNAL_le_boogie 0 |a#0@@108|) (INTERNAL_lt_boogie |a#0@@108| 256)) (and (INTERNAL_le_boogie 0 |b#0@@66|) (INTERNAL_lt_boogie |b#0@@66| 256))))) (and (and (and (= StartFuel_Byte_Order._default.ltedef ($LS MoreFuel_Byte_Order._default.ltedef1)) (= StartFuelAssert_Byte_Order._default.ltedef ($LS ($LS MoreFuel_Byte_Order._default.ltedef1)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.ltedef1) MoreFuel_Byte_Order._default.ltedef1)) (= (Byte__Order.__default.lte ($LS $ly@@372) (LitInt |a#0@@108|) (LitInt |b#0@@66|)) (INTERNAL_le_boogie |a#0@@108| |b#0@@66|))))
 :qid |totalorderidfy.1087:30|
 :weight 3
 :skolemid |4047|
 :pattern ( (Byte__Order.__default.lte ($LS $ly@@372) (LitInt |a#0@@108|) (LitInt |b#0@@66|)))
))))
(assert (forall (($ly@@373 T@U) (|a#0@@109| Int) (|b#0@@67| Int) ) (!  (=> (= (type $ly@@373) LayerTypeType) (= (Byte__Order.__default.ltedef ($LS $ly@@373) |a#0@@109| |b#0@@67|) (Byte__Order.__default.ltedef $ly@@373 |a#0@@109| |b#0@@67|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |4048|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@373) |a#0@@109| |b#0@@67|))
)))
(assert (forall (($ly@@374 T@U) (|a#0@@110| Int) (|b#0@@68| Int) ) (!  (=> (= (type $ly@@374) LayerTypeType) (= (Byte__Order.__default.ltedef $ly@@374 |a#0@@110| |b#0@@68|) (Byte__Order.__default.ltedef $LZ |a#0@@110| |b#0@@68|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |4049|
 :pattern ( (Byte__Order.__default.ltedef (AsFuelBottom $ly@@374) |a#0@@110| |b#0@@68|))
)))
(assert  (=> true (forall (($ly@@375 T@U) (|a#0@@111| Int) (|b#0@@69| Int) ) (!  (=> (and (= (type $ly@@375) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| |a#0@@111| |b#0@@69|) (and (and (INTERNAL_le_boogie 0 |a#0@@111|) (INTERNAL_lt_boogie |a#0@@111| 256)) (and (INTERNAL_le_boogie 0 |b#0@@69|) (INTERNAL_lt_boogie |b#0@@69| 256))))) true)
 :qid |totalorderidfy.1092:30|
 :skolemid |4050|
 :pattern ( (Byte__Order.__default.ltedef $ly@@375 |a#0@@111| |b#0@@69|))
))))
(assert (forall (($ly@@376 T@U) (|a#0@@112| Int) (|b#0@@70| Int) ) (!  (=> (= (type $ly@@376) LayerTypeType) (=> (and (and (INTERNAL_le_boogie 0 |a#0@@112|) (INTERNAL_lt_boogie |a#0@@112| 256)) (and (INTERNAL_le_boogie 0 |b#0@@70|) (INTERNAL_lt_boogie |b#0@@70| 256))) (= (|Byte__Order.__default.ltedef#requires| $ly@@376 |a#0@@112| |b#0@@70|) true)))
 :qid |totalorderidfy.1092:30|
 :skolemid |4051|
 :pattern ( (|Byte__Order.__default.ltedef#requires| $ly@@376 |a#0@@112| |b#0@@70|))
)))
(assert  (=> true (forall (($ly@@377 T@U) (|a#0@@113| Int) (|b#0@@71| Int) ) (!  (=> (and (= (type $ly@@377) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| |a#0@@113| |b#0@@71|) (and (and (INTERNAL_le_boogie 0 |a#0@@113|) (INTERNAL_lt_boogie |a#0@@113| 256)) (and (INTERNAL_le_boogie 0 |b#0@@71|) (INTERNAL_lt_boogie |b#0@@71| 256))))) (= (Byte__Order.__default.ltedef ($LS $ly@@377) |a#0@@113| |b#0@@71|) (INTERNAL_le_boogie |a#0@@113| |b#0@@71|)))
 :qid |totalorderidfy.1092:30|
 :skolemid |4052|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@377) |a#0@@113| |b#0@@71|))
))))
(assert  (=> true (forall (($ly@@378 T@U) (|a#0@@114| Int) (|b#0@@72| Int) ) (!  (=> (and (= (type $ly@@378) LayerTypeType) (or (|Byte__Order.__default.ltedef#canCall| (LitInt |a#0@@114|) (LitInt |b#0@@72|)) (and (and (INTERNAL_le_boogie 0 |a#0@@114|) (INTERNAL_lt_boogie |a#0@@114| 256)) (and (INTERNAL_le_boogie 0 |b#0@@72|) (INTERNAL_lt_boogie |b#0@@72| 256))))) (= (Byte__Order.__default.ltedef ($LS $ly@@378) (LitInt |a#0@@114|) (LitInt |b#0@@72|)) (INTERNAL_le_boogie |a#0@@114| |b#0@@72|)))
 :qid |totalorderidfy.1092:30|
 :weight 3
 :skolemid |4053|
 :pattern ( (Byte__Order.__default.ltedef ($LS $ly@@378) (LitInt |a#0@@114|) (LitInt |b#0@@72|)))
))))
(assert (forall (($ly@@379 T@U) (|run#0@@85| T@U) (|needle#0@@13| Int) ) (!  (=> (and (= (type $ly@@379) LayerTypeType) (= (type |run#0@@85|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@379) |run#0@@85| |needle#0@@13|) (Byte__Order.__default.LargestLteDefn $ly@@379 |run#0@@85| |needle#0@@13|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |4054|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@379) |run#0@@85| |needle#0@@13|))
)))
(assert (forall (($ly@@380 T@U) (|run#0@@86| T@U) (|needle#0@@14| Int) ) (!  (=> (and (= (type $ly@@380) LayerTypeType) (= (type |run#0@@86|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLteDefn $ly@@380 |run#0@@86| |needle#0@@14|) (Byte__Order.__default.LargestLteDefn $LZ |run#0@@86| |needle#0@@14|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |4055|
 :pattern ( (Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@380) |run#0@@86| |needle#0@@14|))
)))
(assert (= (type StartFuel_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@381 T@U) (|run#0@@87| T@U) (|needle#0@@15| Int) ) (!  (=> (and (and (= (type $ly@@381) LayerTypeType) (= (type |run#0@@87|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@87| |needle#0@@15|) (and (and ($Is |run#0@@87| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@15|) (INTERNAL_lt_boogie |needle#0@@15| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@87|)))) true)
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |4056|
 :pattern ( (Byte__Order.__default.LargestLteDefn $ly@@381 |run#0@@87| |needle#0@@15|))
))))
(assert (forall (($ly@@382 T@U) (|run#0@@88| T@U) (|needle#0@@16| Int) ) (!  (=> (and (and (= (type $ly@@382) LayerTypeType) (= (type |run#0@@88|) (SeqType BoxType))) (and ($Is |run#0@@88| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@16|) (INTERNAL_lt_boogie |needle#0@@16| 256)))) (= (|Byte__Order.__default.LargestLteDefn#requires| $ly@@382 |run#0@@88| |needle#0@@16|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@88|)))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |4057|
 :pattern ( (|Byte__Order.__default.LargestLteDefn#requires| $ly@@382 |run#0@@88| |needle#0@@16|))
)))
(assert  (=> true (forall (($ly@@383 T@U) (|run#0@@89| T@U) (|needle#0@@17| Int) ) (!  (=> (and (and (= (type $ly@@383) LayerTypeType) (= (type |run#0@@89|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@89| |needle#0@@17|) (and (and ($Is |run#0@@89| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@17|) (INTERNAL_lt_boogie |needle#0@@17| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@89|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@89|) (LitInt 0))) (|Byte__Order.__default.lt#canCall| |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0)))))) (=> (not (or (= (|Seq#Length| |run#0@@89|) (LitInt 0)) (Byte__Order.__default.lt |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0))))))) (|Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@89| (LitInt 1)) |needle#0@@17|))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@383) |run#0@@89| |needle#0@@17|) (ite  (or (= (|Seq#Length| |run#0@@89|) (LitInt 0)) (Byte__Order.__default.lt |needle#0@@17| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@89| (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLteDefn $ly@@383 (|Seq#Drop| |run#0@@89| (LitInt 1)) |needle#0@@17|))))))
 :qid |totalorderidfyByteOrder.333:12|
 :skolemid |4058|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@383) |run#0@@89| |needle#0@@17|))
))))
(assert  (=> true (forall (($ly@@384 T@U) (|run#0@@90| T@U) (|needle#0@@18| Int) ) (!  (=> (and (and (= (type $ly@@384) LayerTypeType) (= (type |run#0@@90|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@90|) (LitInt |needle#0@@18|)) (and (and ($Is |run#0@@90| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@18|) (INTERNAL_lt_boogie |needle#0@@18| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@90|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0))) (|Byte__Order.__default.lt#canCall| (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0)))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0)) (Byte__Order.__default.lt (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0))))))) (|Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@90|) (LitInt 1))) (LitInt |needle#0@@18|)))) (= (Byte__Order.__default.LargestLteDefn ($LS $ly@@384) (Lit |run#0@@90|) (LitInt |needle#0@@18|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@90|)) (LitInt 0)) (Byte__Order.__default.lt (LitInt |needle#0@@18|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@90|) (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLteDefn ($LS $ly@@384) (Lit (|Seq#Drop| (Lit |run#0@@90|) (LitInt 1))) (LitInt |needle#0@@18|)))))))
 :qid |totalorderidfyByteOrder.333:12|
 :weight 3
 :skolemid |4059|
 :pattern ( (Byte__Order.__default.LargestLteDefn ($LS $ly@@384) (Lit |run#0@@90|) (LitInt |needle#0@@18|)))
))))
(assert (= (type StartFuel_Byte_Order._default.lte) LayerTypeType))
(assert  (=> true (forall ((|run#0@@91| T@U) (|needle#0@@19| Int) ) (!  (=> (and (= (type |run#0@@91|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| |run#0@@91| |needle#0@@19|) (and (and ($Is |run#0@@91| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@19|) (INTERNAL_lt_boogie |needle#0@@19| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@91|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)) (INTERNAL_lt_boogie (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|) (|Seq#Length| |run#0@@91|))) (forall ((|i#0@@137| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@137|) (INTERNAL_le_boogie |i#0@@137| (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| |i#0@@137|))) |needle#0@@19|)))
 :qid |totalorderidfyByteOrder.362:20|
 :skolemid |4060|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@91| |i#0@@137|)))
))) (forall ((|i#1@@34| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|) |i#1@@34|) (INTERNAL_lt_boogie |i#1@@34| (|Seq#Length| |run#0@@91|))) (Byte__Order.__default.lt |needle#0@@19| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| |i#1@@34|))))))
 :qid |totalorderidfyByteOrder.363:20|
 :skolemid |4061|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@91| |i#1@@34|)))
))) (=> (|Seq#Contains| |run#0@@91| ($Box (int_2_U |needle#0@@19|))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)) (= (U_2_int ($Unbox intType (|Seq#Index| |run#0@@91| (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|)))) |needle#0@@19|)))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |4062|
 :pattern ( (Byte__Order.__default.LargestLte |run#0@@91| |needle#0@@19|))
))))
(assert (forall ((|run#0@@92| T@U) (|needle#0@@20| Int) ) (!  (=> (= (type |run#0@@92|) (SeqType BoxType)) (=> (and ($Is |run#0@@92| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@20|) (INTERNAL_lt_boogie |needle#0@@20| 256))) (= (|Byte__Order.__default.LargestLte#requires| |run#0@@92| |needle#0@@20|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@92|))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |4063|
 :pattern ( (|Byte__Order.__default.LargestLte#requires| |run#0@@92| |needle#0@@20|))
)))
(assert  (=> true (forall ((|run#0@@93| T@U) (|needle#0@@21| Int) ) (!  (=> (and (= (type |run#0@@93|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| |run#0@@93| |needle#0@@21|) (and (and ($Is |run#0@@93| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@21|) (INTERNAL_lt_boogie |needle#0@@21| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@93|)))) (and (|Byte__Order.__default.LargestLteDefn#canCall| |run#0@@93| |needle#0@@21|) (= (Byte__Order.__default.LargestLte |run#0@@93| |needle#0@@21|) (let ((|out#0@@2| (Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@93| |needle#0@@21|)))
|out#0@@2|))))
 :qid |totalorderidfyByteOrder.359:23|
 :skolemid |4064|
 :pattern ( (Byte__Order.__default.LargestLte |run#0@@93| |needle#0@@21|))
))))
(assert  (=> true (forall ((|run#0@@94| T@U) (|needle#0@@22| Int) ) (!  (=> (and (= (type |run#0@@94|) (SeqType BoxType)) (or (|Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (and (and ($Is |run#0@@94| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@22|) (INTERNAL_lt_boogie |needle#0@@22| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@94|))))) (and (|Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (= (Byte__Order.__default.LargestLte (Lit |run#0@@94|) (LitInt |needle#0@@22|)) (let ((|out#1@@1| (LitInt (Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@94|) (LitInt |needle#0@@22|)))))
|out#1@@1|))))
 :qid |totalorderidfyByteOrder.359:23|
 :weight 3
 :skolemid |4065|
 :pattern ( (Byte__Order.__default.LargestLte (Lit |run#0@@94|) (LitInt |needle#0@@22|)))
))))
(assert (forall (($ly@@385 T@U) (|run#0@@95| T@U) (|needle#0@@23| Int) ) (!  (=> (and (= (type $ly@@385) LayerTypeType) (= (type |run#0@@95|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLt ($LS $ly@@385) |run#0@@95| |needle#0@@23|) (Byte__Order.__default.LargestLt $ly@@385 |run#0@@95| |needle#0@@23|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |4066|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@385) |run#0@@95| |needle#0@@23|))
)))
(assert (forall (($ly@@386 T@U) (|run#0@@96| T@U) (|needle#0@@24| Int) ) (!  (=> (and (= (type $ly@@386) LayerTypeType) (= (type |run#0@@96|) (SeqType BoxType))) (= (Byte__Order.__default.LargestLt $ly@@386 |run#0@@96| |needle#0@@24|) (Byte__Order.__default.LargestLt $LZ |run#0@@96| |needle#0@@24|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |4067|
 :pattern ( (Byte__Order.__default.LargestLt (AsFuelBottom $ly@@386) |run#0@@96| |needle#0@@24|))
)))
(assert  (=> true (forall (($ly@@387 T@U) (|run#0@@97| T@U) (|needle#0@@25| Int) ) (!  (=> (and (and (= (type $ly@@387) LayerTypeType) (= (type |run#0@@97|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| |run#0@@97| |needle#0@@25|) (and (and ($Is |run#0@@97| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@25|) (INTERNAL_lt_boogie |needle#0@@25| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@97|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|)) (INTERNAL_lt_boogie (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|) (|Seq#Length| |run#0@@97|))) (forall ((|i#0@@138| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@138|) (INTERNAL_le_boogie |i#0@@138| (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| |i#0@@138|))) |needle#0@@25|)))
 :qid |totalorderidfyByteOrder.461:20|
 :skolemid |4068|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@97| |i#0@@138|)))
))) (forall ((|i#1@@35| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|) |i#1@@35|) (INTERNAL_lt_boogie |i#1@@35| (|Seq#Length| |run#0@@97|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@25| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| |i#1@@35|))))))
 :qid |totalorderidfyByteOrder.462:20|
 :skolemid |4069|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@97| |i#1@@35|)))
))) (=> (|Seq#Contains| |run#0@@97| ($Box (int_2_U |needle#0@@25|))) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|) 1) (|Seq#Length| |run#0@@97|)) (= (U_2_int ($Unbox intType (|Seq#Index| |run#0@@97| (INTERNAL_add_boogie (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|) 1)))) |needle#0@@25|)))))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |4070|
 :pattern ( (Byte__Order.__default.LargestLt $ly@@387 |run#0@@97| |needle#0@@25|))
))))
(assert (forall (($ly@@388 T@U) (|run#0@@98| T@U) (|needle#0@@26| Int) ) (!  (=> (and (and (= (type $ly@@388) LayerTypeType) (= (type |run#0@@98|) (SeqType BoxType))) (and ($Is |run#0@@98| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@26|) (INTERNAL_lt_boogie |needle#0@@26| 256)))) (= (|Byte__Order.__default.LargestLt#requires| $ly@@388 |run#0@@98| |needle#0@@26|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@98|)))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |4071|
 :pattern ( (|Byte__Order.__default.LargestLt#requires| $ly@@388 |run#0@@98| |needle#0@@26|))
)))
(assert  (and (= (type MoreFuel_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@389 T@U) (|run#0@@99| T@U) (|needle#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@389) LayerTypeType) (= (type |run#0@@99|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| |run#0@@99| |needle#0@@27|) (and (and ($Is |run#0@@99| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@27|) (INTERNAL_lt_boogie |needle#0@@27| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@99|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@99|) (LitInt 0))) (|Byte__Order.__default.lte#canCall| |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0)))))) (=> (not (or (= (|Seq#Length| |run#0@@99|) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0))))))) (|Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@99| (LitInt 1)) |needle#0@@27|))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted0) MoreFuel_Byte_Order._default.IsSorted0)) (= (Byte__Order.__default.LargestLt ($LS $ly@@389) |run#0@@99| |needle#0@@27|) (ite  (or (= (|Seq#Length| |run#0@@99|) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@27| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@99| (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLt $ly@@389 (|Seq#Drop| |run#0@@99| (LitInt 1)) |needle#0@@27|)))))))
 :qid |totalorderidfyByteOrder.458:12|
 :skolemid |4072|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@389) |run#0@@99| |needle#0@@27|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@390 T@U) (|run#0@@100| T@U) (|needle#0@@28| Int) ) (!  (=> (and (and (= (type $ly@@390) LayerTypeType) (= (type |run#0@@100|) (SeqType BoxType))) (or (|Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@100|) (LitInt |needle#0@@28|)) (and (and ($Is |run#0@@100| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@28|) (INTERNAL_lt_boogie |needle#0@@28| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@100|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0))) (|Byte__Order.__default.lte#canCall| (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0)))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0))))))) (|Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@100|) (LitInt 1))) (LitInt |needle#0@@28|)))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted1) MoreFuel_Byte_Order._default.IsSorted1)) (= (Byte__Order.__default.LargestLt ($LS $ly@@390) (Lit |run#0@@100|) (LitInt |needle#0@@28|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@100|)) (LitInt 0)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |needle#0@@28|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@100|) (LitInt 0)))))) (- 0 1) (INTERNAL_add_boogie 1 (Byte__Order.__default.LargestLt ($LS $ly@@390) (Lit (|Seq#Drop| (Lit |run#0@@100|) (LitInt 1))) (LitInt |needle#0@@28|))))))))
 :qid |totalorderidfyByteOrder.458:12|
 :weight 3
 :skolemid |4073|
 :pattern ( (Byte__Order.__default.LargestLt ($LS $ly@@390) (Lit |run#0@@100|) (LitInt |needle#0@@28|)))
))))
(assert (forall (($ly@@391 T@U) (|run#0@@101| T@U) (|needle#0@@29| Int) ) (!  (=> (and (= (type $ly@@391) LayerTypeType) (= (type |run#0@@101|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@391) |run#0@@101| |needle#0@@29|) (Byte__Order.__default.IndexOfFirstGte $ly@@391 |run#0@@101| |needle#0@@29|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |4074|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@391) |run#0@@101| |needle#0@@29|))
)))
(assert (forall (($ly@@392 T@U) (|run#0@@102| T@U) (|needle#0@@30| Int) ) (!  (=> (and (= (type $ly@@392) LayerTypeType) (= (type |run#0@@102|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGte $ly@@392 |run#0@@102| |needle#0@@30|) (Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@102| |needle#0@@30|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |4075|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@392) |run#0@@102| |needle#0@@30|))
)))
(assert  (=> true (forall (($ly@@393 T@U) (|run#0@@103| T@U) (|needle#0@@31| Int) ) (!  (=> (and (and (= (type $ly@@393) LayerTypeType) (= (type |run#0@@103|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@103| |needle#0@@31|) (and (and ($Is |run#0@@103| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@31|) (INTERNAL_lt_boogie |needle#0@@31| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@103|)))) (and (and (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGte $ly@@393 |run#0@@103| |needle#0@@31|) (|Seq#Length| |run#0@@103|)) (forall ((|i#0@@139| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@139|) (INTERNAL_lt_boogie |i#0@@139| (Byte__Order.__default.IndexOfFirstGte $ly@@393 |run#0@@103| |needle#0@@31|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@103| |i#0@@139|))) |needle#0@@31|))
 :qid |totalorderidfyByteOrder.495:20|
 :skolemid |4076|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@103| |i#0@@139|)))
))) (forall ((|i#1@@36| Int) ) (!  (=> (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGte $ly@@393 |run#0@@103| |needle#0@@31|) |i#1@@36|) (INTERNAL_lt_boogie |i#1@@36| (|Seq#Length| |run#0@@103|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |needle#0@@31| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@103| |i#1@@36|)))))
 :qid |totalorderidfyByteOrder.496:20|
 :skolemid |4077|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@103| |i#1@@36|)))
))) (INTERNAL_le_boogie 0 (Byte__Order.__default.IndexOfFirstGte $ly@@393 |run#0@@103| |needle#0@@31|))))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |4078|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte $ly@@393 |run#0@@103| |needle#0@@31|))
))))
(assert (forall (($ly@@394 T@U) (|run#0@@104| T@U) (|needle#0@@32| Int) ) (!  (=> (and (and (= (type $ly@@394) LayerTypeType) (= (type |run#0@@104|) (SeqType BoxType))) (and ($Is |run#0@@104| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@32|) (INTERNAL_lt_boogie |needle#0@@32| 256)))) (= (|Byte__Order.__default.IndexOfFirstGte#requires| $ly@@394 |run#0@@104| |needle#0@@32|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@104|)))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |4079|
 :pattern ( (|Byte__Order.__default.IndexOfFirstGte#requires| $ly@@394 |run#0@@104| |needle#0@@32|))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@395 T@U) (|run#0@@105| T@U) (|needle#0@@33| Int) ) (!  (=> (and (and (= (type $ly@@395) LayerTypeType) (= (type |run#0@@105|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@105| |needle#0@@33|) (and (and ($Is |run#0@@105| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@33|) (INTERNAL_lt_boogie |needle#0@@33| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@105|)))) (and (=> (not (= (|Seq#Length| |run#0@@105|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte |run#0@@105|) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|)) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|)) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte |run#0@@105|) (|Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@105|) |needle#0@@33|))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted2) MoreFuel_Byte_Order._default.IsSorted2)) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@395) |run#0@@105| |needle#0@@33|) (ite (= (|Seq#Length| |run#0@@105|) (LitInt 0)) 0 (ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@105|))) |needle#0@@33|) (|Seq#Length| |run#0@@105|) (Byte__Order.__default.IndexOfFirstGte $ly@@395 (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@105|) |needle#0@@33|)))))))
 :qid |totalorderidfyByteOrder.492:12|
 :skolemid |4080|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@395) |run#0@@105| |needle#0@@33|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@396 T@U) (|run#0@@106| T@U) (|needle#0@@34| Int) ) (!  (=> (and (and (= (type $ly@@396) LayerTypeType) (= (type |run#0@@106|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@106|) (LitInt |needle#0@@34|)) (and (and ($Is |run#0@@106| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@34|) (INTERNAL_lt_boogie |needle#0@@34| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@106|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@106|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte (Lit |run#0@@106|)) (|Byte__Order.__default.lt#canCall| (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|))) (=> (not (U_2_bool (Lit (bool_2_U (Byte__Order.__default.lt (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte (Lit |run#0@@106|)) (|Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@106|))) (LitInt |needle#0@@34|)))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted3) MoreFuel_Byte_Order._default.IsSorted3)) (= (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@396) (Lit |run#0@@106|) (LitInt |needle#0@@34|)) (ite (= (|Seq#Length| (Lit |run#0@@106|)) (LitInt 0)) 0 (ite (Byte__Order.__default.lt (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@106|))))) (LitInt |needle#0@@34|)) (|Seq#Length| (Lit |run#0@@106|)) (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@396) (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@106|))) (LitInt |needle#0@@34|))))))))
 :qid |totalorderidfyByteOrder.492:12|
 :weight 3
 :skolemid |4081|
 :pattern ( (Byte__Order.__default.IndexOfFirstGte ($LS $ly@@396) (Lit |run#0@@106|) (LitInt |needle#0@@34|)))
))))
(assert (forall (($ly@@397 T@U) (|s#0@@113| T@U) (|key#0@@55| Int) (|lo#0| Int) (|hi#0| Int) ) (!  (=> (and (= (type $ly@@397) LayerTypeType) (= (type |s#0@@113|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@397) |s#0@@113| |key#0@@55| |lo#0| |hi#0|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@397 |s#0@@113| |key#0@@55| |lo#0| |hi#0|)))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |4082|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@397) |s#0@@113| |key#0@@55| |lo#0| |hi#0|))
)))
(assert (forall (($ly@@398 T@U) (|s#0@@114| T@U) (|key#0@@56| Int) (|lo#0@@0| Int) (|hi#0@@0| Int) ) (!  (=> (and (= (type $ly@@398) LayerTypeType) (= (type |s#0@@114|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@398 |s#0@@114| |key#0@@56| |lo#0@@0| |hi#0@@0|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@114| |key#0@@56| |lo#0@@0| |hi#0@@0|)))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |4083|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@398) |s#0@@114| |key#0@@56| |lo#0@@0| |hi#0@@0|))
)))
(assert  (=> true (forall (($ly@@399 T@U) (|s#0@@115| T@U) (|key#0@@57| Int) (|lo#0@@1| Int) (|hi#0@@1| Int) ) (!  (=> (and (and (= (type $ly@@399) LayerTypeType) (= (type |s#0@@115|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) (and (and ($Is |s#0@@115| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@57|) (INTERNAL_lt_boogie |key#0@@57| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@1|) (INTERNAL_lt_boogie |lo#0@@1| |hi#0@@1|)) (INTERNAL_le_boogie |hi#0@@1| (INTERNAL_add_boogie (|Seq#Length| |s#0@@115|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@1| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie |lo#0@@1| 1)))) |key#0@@57|))) (=> (INTERNAL_le_boogie |hi#0@@1| (|Seq#Length| |s#0@@115|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@57| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie |hi#0@@1| 1)))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) (|Seq#Length| |s#0@@115|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) 1)))) |key#0@@57|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) (|Seq#Length| |s#0@@115|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@57| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@115| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|))))))) (and (INTERNAL_le_boogie |lo#0@@1| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|)) (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|) |hi#0@@1|))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |4084|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@399 |s#0@@115| |key#0@@57| |lo#0@@1| |hi#0@@1|))
))))
(assert (forall (($ly@@400 T@U) (|s#0@@116| T@U) (|key#0@@58| Int) (|lo#0@@2| Int) (|hi#0@@2| Int) ) (!  (=> (and (and (= (type $ly@@400) LayerTypeType) (= (type |s#0@@116|) (SeqType BoxType))) (and ($Is |s#0@@116| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@58|) (INTERNAL_lt_boogie |key#0@@58| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@400 |s#0@@116| |key#0@@58| |lo#0@@2| |hi#0@@2|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@2|) (INTERNAL_lt_boogie |lo#0@@2| |hi#0@@2|)) (INTERNAL_le_boogie |hi#0@@2| (INTERNAL_add_boogie (|Seq#Length| |s#0@@116|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@2| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@116| (INTERNAL_sub_boogie |lo#0@@2| 1)))) |key#0@@58|))) (=> (INTERNAL_le_boogie |hi#0@@2| (|Seq#Length| |s#0@@116|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@58| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@116| (INTERNAL_sub_boogie |hi#0@@2| 1)))))))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |4085|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@400 |s#0@@116| |key#0@@58| |lo#0@@2| |hi#0@@2|))
)))
(assert  (=> true (forall (($ly@@401 T@U) (|s#0@@117| T@U) (|key#0@@59| Int) (|lo#0@@3| Int) (|hi#0@@3| Int) ) (!  (=> (and (and (= (type $ly@@401) LayerTypeType) (= (type |s#0@@117|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@59| |lo#0@@3| |hi#0@@3|) (and (and ($Is |s#0@@117| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@59|) (INTERNAL_lt_boogie |key#0@@59| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@3|) (INTERNAL_lt_boogie |lo#0@@3| |hi#0@@3|)) (INTERNAL_le_boogie |hi#0@@3| (INTERNAL_add_boogie (|Seq#Length| |s#0@@117|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@3| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |lo#0@@3| 1)))) |key#0@@59|))) (=> (INTERNAL_le_boogie |hi#0@@3| (|Seq#Length| |s#0@@117|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@59| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |hi#0@@3| 1)))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@3| 1) |hi#0@@3|) (let ((|mid#0| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@3| |hi#0@@3|) 2)))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@59|) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@59|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@59| |mid#0| |hi#0@@3|))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0| 1)))) |key#0@@59|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@117| |key#0@@59| |lo#0@@3| |mid#0|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@401) |s#0@@117| |key#0@@59| |lo#0@@3| |hi#0@@3|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@3| 1) |hi#0@@3|) (let ((|mid#0@@0| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@3| |hi#0@@3|) 2)))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@117| (INTERNAL_sub_boogie |mid#0@@0| 1)))) |key#0@@59|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@401 |s#0@@117| |key#0@@59| |mid#0@@0| |hi#0@@3|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@401 |s#0@@117| |key#0@@59| |lo#0@@3| |mid#0@@0|))) |lo#0@@3|))))
 :qid |totalorderidfyByteOrder.524:12|
 :skolemid |4086|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@401) |s#0@@117| |key#0@@59| |lo#0@@3| |hi#0@@3|))
))))
(assert  (=> true (forall (($ly@@402 T@U) (|s#0@@118| T@U) (|key#0@@60| Int) (|lo#0@@4| Int) (|hi#0@@4| Int) ) (!  (=> (and (and (= (type $ly@@402) LayerTypeType) (= (type |s#0@@118|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@60| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)) (and (and ($Is |s#0@@118| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@60|) (INTERNAL_lt_boogie |key#0@@60| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@4|) (INTERNAL_lt_boogie |lo#0@@4| |hi#0@@4|)) (INTERNAL_le_boogie |hi#0@@4| (INTERNAL_add_boogie (|Seq#Length| |s#0@@118|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@4| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |lo#0@@4| 1))))) |key#0@@60|))) (=> (INTERNAL_le_boogie |hi#0@@4| (|Seq#Length| |s#0@@118|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@60| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |hi#0@@4| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@4| 1) |hi#0@@4|)))) (let ((|mid#1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@4| |hi#0@@4|) 2))))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@60|) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@60|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@60| |mid#1| (LitInt |hi#0@@4|)))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (INTERNAL_sub_boogie |mid#1| 1)))) |key#0@@60|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@118| |key#0@@60| (LitInt |lo#0@@4|) |mid#1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@402) |s#0@@118| |key#0@@60| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@4| 1) |hi#0@@4|) (let ((|mid#1@@0| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@4| |hi#0@@4|) 2))))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@118| (LitInt (INTERNAL_sub_boogie |mid#1@@0| 1))))) |key#0@@60|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@402) |s#0@@118| |key#0@@60| |mid#1@@0| (LitInt |hi#0@@4|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@402) |s#0@@118| |key#0@@60| (LitInt |lo#0@@4|) |mid#1@@0|))) |lo#0@@4|))))
 :qid |totalorderidfyByteOrder.524:12|
 :weight 3
 :skolemid |4087|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@402) |s#0@@118| |key#0@@60| (LitInt |lo#0@@4|) (LitInt |hi#0@@4|)))
))))
(assert  (=> true (forall (($ly@@403 T@U) (|s#0@@119| T@U) (|key#0@@61| Int) (|lo#0@@5| Int) (|hi#0@@5| Int) ) (!  (=> (and (and (= (type $ly@@403) LayerTypeType) (= (type |s#0@@119|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@61|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)) (and (and ($Is |s#0@@119| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@61|) (INTERNAL_lt_boogie |key#0@@61| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@5|) (INTERNAL_lt_boogie |lo#0@@5| |hi#0@@5|)) (INTERNAL_le_boogie |hi#0@@5| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@119|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@5| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |lo#0@@5| 1))))) (LitInt |key#0@@61|)))) (=> (INTERNAL_le_boogie |hi#0@@5| (|Seq#Length| (Lit |s#0@@119|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |key#0@@61|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |hi#0@@5| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@5| 1) |hi#0@@5|)))) (let ((|mid#2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@5| |hi#0@@5|) 2))))
 (and (and (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@61|)) (=> (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@61|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@61|) |mid#2| (LitInt |hi#0@@5|)))) (=> (not (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (INTERNAL_sub_boogie |mid#2| 1)))) (LitInt |key#0@@61|))) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@119|) (LitInt |key#0@@61|) (LitInt |lo#0@@5|) |mid#2|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@403) (Lit |s#0@@119|) (LitInt |key#0@@61|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@5| 1) |hi#0@@5|) (let ((|mid#2@@0| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@5| |hi#0@@5|) 2))))
(ite (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@119|) (LitInt (INTERNAL_sub_boogie |mid#2@@0| 1))))) (LitInt |key#0@@61|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@403) (Lit |s#0@@119|) (LitInt |key#0@@61|) |mid#2@@0| (LitInt |hi#0@@5|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@403) (Lit |s#0@@119|) (LitInt |key#0@@61|) (LitInt |lo#0@@5|) |mid#2@@0|))) |lo#0@@5|))))
 :qid |totalorderidfyByteOrder.524:12|
 :weight 3
 :skolemid |4088|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@403) (Lit |s#0@@119|) (LitInt |key#0@@61|) (LitInt |lo#0@@5|) (LitInt |hi#0@@5|)))
))))
(assert (forall (($ly@@404 T@U) (|s#0@@120| T@U) (|key#0@@62| Int) ) (!  (=> (and (= (type $ly@@404) LayerTypeType) (= (type |s#0@@120|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@404) |s#0@@120| |key#0@@62|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@404 |s#0@@120| |key#0@@62|)))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |4089|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@404) |s#0@@120| |key#0@@62|))
)))
(assert (forall (($ly@@405 T@U) (|s#0@@121| T@U) (|key#0@@63| Int) ) (!  (=> (and (= (type $ly@@405) LayerTypeType) (= (type |s#0@@121|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@405 |s#0@@121| |key#0@@63|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@121| |key#0@@63|)))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |4090|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@405) |s#0@@121| |key#0@@63|))
)))
(assert  (=> true (forall (($ly@@406 T@U) (|s#0@@122| T@U) (|key#0@@64| Int) ) (!  (=> (and (and (= (type $ly@@406) LayerTypeType) (= (type |s#0@@122|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@122| |key#0@@64|) (and ($Is |s#0@@122| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@64|) (INTERNAL_lt_boogie |key#0@@64| 256))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|) (|Seq#Length| |s#0@@122|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@122| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|) 1)))) |key#0@@64|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|) (|Seq#Length| |s#0@@122|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@64| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@122| (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|))))))))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |4091|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@406 |s#0@@122| |key#0@@64|))
))))
(assert (forall (($ly@@407 T@U) (|s#0@@123| T@U) (|key#0@@65| Int) ) (!  (=> (and (and (= (type $ly@@407) LayerTypeType) (= (type |s#0@@123|) (SeqType BoxType))) (and ($Is |s#0@@123| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@65|) (INTERNAL_lt_boogie |key#0@@65| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@407 |s#0@@123| |key#0@@65|) true))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |4092|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@407 |s#0@@123| |key#0@@65|))
)))
(assert  (=> true (forall (($ly@@408 T@U) (|s#0@@124| T@U) (|key#0@@66| Int) ) (!  (=> (and (and (= (type $ly@@408) LayerTypeType) (= (type |s#0@@124|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@124| |key#0@@66|) (and ($Is |s#0@@124| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@66|) (INTERNAL_lt_boogie |key#0@@66| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@124| |key#0@@66| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@124|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@408) |s#0@@124| |key#0@@66|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@124| |key#0@@66| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@124|) 1)))))
 :qid |totalorderidfyByteOrder.574:22|
 :skolemid |4093|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@408) |s#0@@124| |key#0@@66|))
))))
(assert  (=> true (forall (($ly@@409 T@U) (|s#0@@125| T@U) (|key#0@@67| Int) ) (!  (=> (and (and (= (type $ly@@409) LayerTypeType) (= (type |s#0@@125|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@125|) (LitInt |key#0@@67|)) (and ($Is |s#0@@125| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@67|) (INTERNAL_lt_boogie |key#0@@67| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@125|) (LitInt |key#0@@67|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@125|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@409) (Lit |s#0@@125|) (LitInt |key#0@@67|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@125|) (LitInt |key#0@@67|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@125|)) 1)))))
 :qid |totalorderidfyByteOrder.574:22|
 :weight 3
 :skolemid |4094|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@409) (Lit |s#0@@125|) (LitInt |key#0@@67|)))
))))
(assert (forall (($ly@@410 T@U) (|s#0@@126| T@U) (|key#0@@68| Int) (|lo#0@@6| Int) ) (!  (=> (and (= (type $ly@@410) LayerTypeType) (= (type |s#0@@126|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@410) |s#0@@126| |key#0@@68| |lo#0@@6|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@410 |s#0@@126| |key#0@@68| |lo#0@@6|)))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |4095|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@410) |s#0@@126| |key#0@@68| |lo#0@@6|))
)))
(assert (forall (($ly@@411 T@U) (|s#0@@127| T@U) (|key#0@@69| Int) (|lo#0@@7| Int) ) (!  (=> (and (= (type $ly@@411) LayerTypeType) (= (type |s#0@@127|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@411 |s#0@@127| |key#0@@69| |lo#0@@7|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@127| |key#0@@69| |lo#0@@7|)))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |4096|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@411) |s#0@@127| |key#0@@69| |lo#0@@7|))
)))
(assert  (=> true (forall (($ly@@412 T@U) (|s#0@@128| T@U) (|key#0@@70| Int) (|lo#0@@8| Int) ) (!  (=> (and (and (= (type $ly@@412) LayerTypeType) (= (type |s#0@@128|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@128| |key#0@@70| |lo#0@@8|) (and (and ($Is |s#0@@128| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@70|) (INTERNAL_lt_boogie |key#0@@70| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@8|) (INTERNAL_le_boogie |lo#0@@8| (|Seq#Length| |s#0@@128|))) (=> (INTERNAL_gt_boogie |lo#0@@8| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (INTERNAL_sub_boogie |lo#0@@8| 1)))) |key#0@@70|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@8| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|) (|Seq#Length| |s#0@@128|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|) 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|) 1)))) |key#0@@70|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|) (|Seq#Length| |s#0@@128|)) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |key#0@@70| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@128| (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|))))))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |4097|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@412 |s#0@@128| |key#0@@70| |lo#0@@8|))
))))
(assert (forall (($ly@@413 T@U) (|s#0@@129| T@U) (|key#0@@71| Int) (|lo#0@@9| Int) ) (!  (=> (and (and (= (type $ly@@413) LayerTypeType) (= (type |s#0@@129|) (SeqType BoxType))) (and ($Is |s#0@@129| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@71|) (INTERNAL_lt_boogie |key#0@@71| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@413 |s#0@@129| |key#0@@71| |lo#0@@9|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@9|) (INTERNAL_le_boogie |lo#0@@9| (|Seq#Length| |s#0@@129|))) (=> (INTERNAL_gt_boogie |lo#0@@9| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@129| (INTERNAL_sub_boogie |lo#0@@9| 1)))) |key#0@@71|)))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |4098|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@413 |s#0@@129| |key#0@@71| |lo#0@@9|))
)))
(assert  (=> true (forall (($ly@@414 T@U) (|s#0@@130| T@U) (|key#0@@72| Int) (|lo#0@@10| Int) ) (!  (=> (and (and (= (type $ly@@414) LayerTypeType) (= (type |s#0@@130|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@130| |key#0@@72| |lo#0@@10|) (and (and ($Is |s#0@@130| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@72|) (INTERNAL_lt_boogie |key#0@@72| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@10|) (INTERNAL_le_boogie |lo#0@@10| (|Seq#Length| |s#0@@130|))) (=> (INTERNAL_gt_boogie |lo#0@@10| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |s#0@@130| (INTERNAL_sub_boogie |lo#0@@10| 1)))) |key#0@@72|)))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@130| |key#0@@72| |lo#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@130|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@414) |s#0@@130| |key#0@@72| |lo#0@@10|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@130| |key#0@@72| |lo#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@130|) 1)))))
 :qid |totalorderidfyByteOrder.582:22|
 :skolemid |4099|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@414) |s#0@@130| |key#0@@72| |lo#0@@10|))
))))
(assert  (=> true (forall (($ly@@415 T@U) (|s#0@@131| T@U) (|key#0@@73| Int) (|lo#0@@11| Int) ) (!  (=> (and (and (= (type $ly@@415) LayerTypeType) (= (type |s#0@@131|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@131|) (LitInt |key#0@@73|) (LitInt |lo#0@@11|)) (and (and ($Is |s#0@@131| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@73|) (INTERNAL_lt_boogie |key#0@@73| 256))) (and (and (INTERNAL_le_boogie 0 |lo#0@@11|) (INTERNAL_le_boogie |lo#0@@11| (|Seq#Length| (Lit |s#0@@131|)))) (=> (INTERNAL_gt_boogie |lo#0@@11| 0) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@131|) (LitInt (INTERNAL_sub_boogie |lo#0@@11| 1))))) (LitInt |key#0@@73|))))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@131|) (LitInt |key#0@@73|) (LitInt |lo#0@@11|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@131|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@415) (Lit |s#0@@131|) (LitInt |key#0@@73|) (LitInt |lo#0@@11|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@131|) (LitInt |key#0@@73|) (LitInt |lo#0@@11|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@131|)) 1)))))
 :qid |totalorderidfyByteOrder.582:22|
 :weight 3
 :skolemid |4100|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@415) (Lit |s#0@@131|) (LitInt |key#0@@73|) (LitInt |lo#0@@11|)))
))))
(assert (forall (($ly@@416 T@U) (|run#0@@107| T@U) (|needle#0@@35| Int) ) (!  (=> (and (= (type $ly@@416) LayerTypeType) (= (type |run#0@@107|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@416) |run#0@@107| |needle#0@@35|) (Byte__Order.__default.IndexOfFirstGt $ly@@416 |run#0@@107| |needle#0@@35|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |4101|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@416) |run#0@@107| |needle#0@@35|))
)))
(assert (forall (($ly@@417 T@U) (|run#0@@108| T@U) (|needle#0@@36| Int) ) (!  (=> (and (= (type $ly@@417) LayerTypeType) (= (type |run#0@@108|) (SeqType BoxType))) (= (Byte__Order.__default.IndexOfFirstGt $ly@@417 |run#0@@108| |needle#0@@36|) (Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@108| |needle#0@@36|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |4102|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@417) |run#0@@108| |needle#0@@36|))
)))
(assert  (=> true (forall (($ly@@418 T@U) (|run#0@@109| T@U) (|needle#0@@37| Int) ) (!  (=> (and (and (= (type $ly@@418) LayerTypeType) (= (type |run#0@@109|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@109| |needle#0@@37|) (and (and ($Is |run#0@@109| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@37|) (INTERNAL_lt_boogie |needle#0@@37| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@109|)))) (and (and (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGt $ly@@418 |run#0@@109| |needle#0@@37|) (|Seq#Length| |run#0@@109|)) (forall ((|i#0@@140| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@140|) (INTERNAL_lt_boogie |i#0@@140| (Byte__Order.__default.IndexOfFirstGt $ly@@418 |run#0@@109| |needle#0@@37|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@109| |i#0@@140|))) |needle#0@@37|))
 :qid |totalorderidfyByteOrder.595:20|
 :skolemid |4103|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@109| |i#0@@140|)))
))) (forall ((|i#1@@37| Int) ) (!  (=> (and (INTERNAL_le_boogie (Byte__Order.__default.IndexOfFirstGt $ly@@418 |run#0@@109| |needle#0@@37|) |i#1@@37|) (INTERNAL_lt_boogie |i#1@@37| (|Seq#Length| |run#0@@109|))) (Byte__Order.__default.lt |needle#0@@37| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@109| |i#1@@37|)))))
 :qid |totalorderidfyByteOrder.596:20|
 :skolemid |4104|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@109| |i#1@@37|)))
))) (INTERNAL_le_boogie 0 (Byte__Order.__default.IndexOfFirstGt $ly@@418 |run#0@@109| |needle#0@@37|))))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |4105|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt $ly@@418 |run#0@@109| |needle#0@@37|))
))))
(assert (forall (($ly@@419 T@U) (|run#0@@110| T@U) (|needle#0@@38| Int) ) (!  (=> (and (and (= (type $ly@@419) LayerTypeType) (= (type |run#0@@110|) (SeqType BoxType))) (and ($Is |run#0@@110| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@38|) (INTERNAL_lt_boogie |needle#0@@38| 256)))) (= (|Byte__Order.__default.IndexOfFirstGt#requires| $ly@@419 |run#0@@110| |needle#0@@38|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@110|)))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |4106|
 :pattern ( (|Byte__Order.__default.IndexOfFirstGt#requires| $ly@@419 |run#0@@110| |needle#0@@38|))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@420 T@U) (|run#0@@111| T@U) (|needle#0@@39| Int) ) (!  (=> (and (and (= (type $ly@@420) LayerTypeType) (= (type |run#0@@111|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@111| |needle#0@@39|) (and (and ($Is |run#0@@111| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@39|) (INTERNAL_lt_boogie |needle#0@@39| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@111|)))) (and (=> (not (= (|Seq#Length| |run#0@@111|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte |run#0@@111|) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|)) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|)) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte |run#0@@111|) (|Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@111|) |needle#0@@39|))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted4) MoreFuel_Byte_Order._default.IsSorted4)) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@420) |run#0@@111| |needle#0@@39|) (ite (= (|Seq#Length| |run#0@@111|) (LitInt 0)) 0 (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte |run#0@@111|))) |needle#0@@39|) (|Seq#Length| |run#0@@111|) (Byte__Order.__default.IndexOfFirstGt $ly@@420 (Sequences.__default.DropLast Tclass.NativeTypes.byte |run#0@@111|) |needle#0@@39|)))))))
 :qid |totalorderidfyByteOrder.592:12|
 :skolemid |4107|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@420) |run#0@@111| |needle#0@@39|))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@421 T@U) (|run#0@@112| T@U) (|needle#0@@40| Int) ) (!  (=> (and (and (= (type $ly@@421) LayerTypeType) (= (type |run#0@@112|) (SeqType BoxType))) (or (|Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@112|) (LitInt |needle#0@@40|)) (and (and ($Is |run#0@@112| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |needle#0@@40|) (INTERNAL_lt_boogie |needle#0@@40| 256))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Lit |run#0@@112|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@112|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.NativeTypes.byte (Lit |run#0@@112|)) (|Byte__Order.__default.lte#canCall| (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|))) (and (|Sequences.__default.DropLast#canCall| Tclass.NativeTypes.byte (Lit |run#0@@112|)) (|Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@112|))) (LitInt |needle#0@@40|)))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted5) MoreFuel_Byte_Order._default.IsSorted5)) (= (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@421) (Lit |run#0@@112|) (LitInt |needle#0@@40|)) (ite (= (|Seq#Length| (Lit |run#0@@112|)) (LitInt 0)) 0 (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt (U_2_int ($Unbox intType (Sequences.__default.Last Tclass.NativeTypes.byte (Lit |run#0@@112|))))) (LitInt |needle#0@@40|)) (|Seq#Length| (Lit |run#0@@112|)) (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@421) (Lit (Sequences.__default.DropLast Tclass.NativeTypes.byte (Lit |run#0@@112|))) (LitInt |needle#0@@40|))))))))
 :qid |totalorderidfyByteOrder.592:12|
 :weight 3
 :skolemid |4108|
 :pattern ( (Byte__Order.__default.IndexOfFirstGt ($LS $ly@@421) (Lit |run#0@@112|) (LitInt |needle#0@@40|)))
))))
(assert (forall (($ly@@422 T@U) (|s#0@@132| T@U) (|key#0@@74| Int) (|lo#0@@12| Int) (|hi#0@@6| Int) ) (!  (=> (and (= (type $ly@@422) LayerTypeType) (= (type |s#0@@132|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@422) |s#0@@132| |key#0@@74| |lo#0@@12| |hi#0@@6|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@422 |s#0@@132| |key#0@@74| |lo#0@@12| |hi#0@@6|)))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |4109|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@422) |s#0@@132| |key#0@@74| |lo#0@@12| |hi#0@@6|))
)))
(assert (forall (($ly@@423 T@U) (|s#0@@133| T@U) (|key#0@@75| Int) (|lo#0@@13| Int) (|hi#0@@7| Int) ) (!  (=> (and (= (type $ly@@423) LayerTypeType) (= (type |s#0@@133|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@423 |s#0@@133| |key#0@@75| |lo#0@@13| |hi#0@@7|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@133| |key#0@@75| |lo#0@@13| |hi#0@@7|)))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |4110|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@423) |s#0@@133| |key#0@@75| |lo#0@@13| |hi#0@@7|))
)))
(assert  (=> true (forall (($ly@@424 T@U) (|s#0@@134| T@U) (|key#0@@76| Int) (|lo#0@@14| Int) (|hi#0@@8| Int) ) (!  (=> (and (and (= (type $ly@@424) LayerTypeType) (= (type |s#0@@134|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|) (and (and ($Is |s#0@@134| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@76|) (INTERNAL_lt_boogie |key#0@@76| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@14|) (INTERNAL_lt_boogie |lo#0@@14| |hi#0@@8|)) (INTERNAL_le_boogie |hi#0@@8| (INTERNAL_add_boogie (|Seq#Length| |s#0@@134|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@14| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie |lo#0@@14| 1)))) |key#0@@76|))) (=> (INTERNAL_le_boogie |hi#0@@8| (|Seq#Length| |s#0@@134|)) (Byte__Order.__default.lt |key#0@@76| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie |hi#0@@8| 1)))))))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|) (|Seq#Length| |s#0@@134|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|) 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|) 1)))) |key#0@@76|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|) (|Seq#Length| |s#0@@134|)) (Byte__Order.__default.lt |key#0@@76| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@134| (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|))))))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |4111|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@424 |s#0@@134| |key#0@@76| |lo#0@@14| |hi#0@@8|))
))))
(assert (forall (($ly@@425 T@U) (|s#0@@135| T@U) (|key#0@@77| Int) (|lo#0@@15| Int) (|hi#0@@9| Int) ) (!  (=> (and (and (= (type $ly@@425) LayerTypeType) (= (type |s#0@@135|) (SeqType BoxType))) (and ($Is |s#0@@135| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@77|) (INTERNAL_lt_boogie |key#0@@77| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@425 |s#0@@135| |key#0@@77| |lo#0@@15| |hi#0@@9|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@15|) (INTERNAL_lt_boogie |lo#0@@15| |hi#0@@9|)) (INTERNAL_le_boogie |hi#0@@9| (INTERNAL_add_boogie (|Seq#Length| |s#0@@135|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@15| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@135| (INTERNAL_sub_boogie |lo#0@@15| 1)))) |key#0@@77|))) (=> (INTERNAL_le_boogie |hi#0@@9| (|Seq#Length| |s#0@@135|)) (Byte__Order.__default.lt |key#0@@77| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@135| (INTERNAL_sub_boogie |hi#0@@9| 1)))))))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |4112|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@425 |s#0@@135| |key#0@@77| |lo#0@@15| |hi#0@@9|))
)))
(assert  (=> true (forall (($ly@@426 T@U) (|s#0@@136| T@U) (|key#0@@78| Int) (|lo#0@@16| Int) (|hi#0@@10| Int) ) (!  (=> (and (and (= (type $ly@@426) LayerTypeType) (= (type |s#0@@136|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@78| |lo#0@@16| |hi#0@@10|) (and (and ($Is |s#0@@136| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@78|) (INTERNAL_lt_boogie |key#0@@78| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@16|) (INTERNAL_lt_boogie |lo#0@@16| |hi#0@@10|)) (INTERNAL_le_boogie |hi#0@@10| (INTERNAL_add_boogie (|Seq#Length| |s#0@@136|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@16| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |lo#0@@16| 1)))) |key#0@@78|))) (=> (INTERNAL_le_boogie |hi#0@@10| (|Seq#Length| |s#0@@136|)) (Byte__Order.__default.lt |key#0@@78| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |hi#0@@10| 1)))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@16| 1) |hi#0@@10|) (let ((|mid#0@@1| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@16| |hi#0@@10|) 2)))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@78|) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@78|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@78| |mid#0@@1| |hi#0@@10|))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@1| 1)))) |key#0@@78|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@136| |key#0@@78| |lo#0@@16| |mid#0@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@426) |s#0@@136| |key#0@@78| |lo#0@@16| |hi#0@@10|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@16| 1) |hi#0@@10|) (let ((|mid#0@@2| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@16| |hi#0@@10|) 2)))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@136| (INTERNAL_sub_boogie |mid#0@@2| 1)))) |key#0@@78|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@426 |s#0@@136| |key#0@@78| |mid#0@@2| |hi#0@@10|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@426 |s#0@@136| |key#0@@78| |lo#0@@16| |mid#0@@2|))) |lo#0@@16|))))
 :qid |totalorderidfyByteOrder.624:12|
 :skolemid |4113|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@426) |s#0@@136| |key#0@@78| |lo#0@@16| |hi#0@@10|))
))))
(assert  (=> true (forall (($ly@@427 T@U) (|s#0@@137| T@U) (|key#0@@79| Int) (|lo#0@@17| Int) (|hi#0@@11| Int) ) (!  (=> (and (and (= (type $ly@@427) LayerTypeType) (= (type |s#0@@137|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@79| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)) (and (and ($Is |s#0@@137| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@79|) (INTERNAL_lt_boogie |key#0@@79| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@17|) (INTERNAL_lt_boogie |lo#0@@17| |hi#0@@11|)) (INTERNAL_le_boogie |hi#0@@11| (INTERNAL_add_boogie (|Seq#Length| |s#0@@137|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@17| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |lo#0@@17| 1))))) |key#0@@79|))) (=> (INTERNAL_le_boogie |hi#0@@11| (|Seq#Length| |s#0@@137|)) (Byte__Order.__default.lt |key#0@@79| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |hi#0@@11| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@17| 1) |hi#0@@11|)))) (let ((|mid#1@@1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@17| |hi#0@@11|) 2))))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@79|) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@79|) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@79| |mid#1@@1| (LitInt |hi#0@@11|)))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (INTERNAL_sub_boogie |mid#1@@1| 1)))) |key#0@@79|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@137| |key#0@@79| (LitInt |lo#0@@17|) |mid#1@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@427) |s#0@@137| |key#0@@79| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@17| 1) |hi#0@@11|) (let ((|mid#1@@2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@17| |hi#0@@11|) 2))))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@137| (LitInt (INTERNAL_sub_boogie |mid#1@@2| 1))))) |key#0@@79|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@427) |s#0@@137| |key#0@@79| |mid#1@@2| (LitInt |hi#0@@11|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@427) |s#0@@137| |key#0@@79| (LitInt |lo#0@@17|) |mid#1@@2|))) |lo#0@@17|))))
 :qid |totalorderidfyByteOrder.624:12|
 :weight 3
 :skolemid |4114|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@427) |s#0@@137| |key#0@@79| (LitInt |lo#0@@17|) (LitInt |hi#0@@11|)))
))))
(assert  (=> true (forall (($ly@@428 T@U) (|s#0@@138| T@U) (|key#0@@80| Int) (|lo#0@@18| Int) (|hi#0@@12| Int) ) (!  (=> (and (and (= (type $ly@@428) LayerTypeType) (= (type |s#0@@138|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@80|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)) (and (and ($Is |s#0@@138| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@80|) (INTERNAL_lt_boogie |key#0@@80| 256))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@18|) (INTERNAL_lt_boogie |lo#0@@18| |hi#0@@12|)) (INTERNAL_le_boogie |hi#0@@12| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@138|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@18| 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |lo#0@@18| 1))))) (LitInt |key#0@@80|)))) (=> (INTERNAL_le_boogie |hi#0@@12| (|Seq#Length| (Lit |s#0@@138|))) (Byte__Order.__default.lt (LitInt |key#0@@80|) (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |hi#0@@12| 1))))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@18| 1) |hi#0@@12|)))) (let ((|mid#2@@1| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@18| |hi#0@@12|) 2))))
 (and (and (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@80|)) (=> (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@80|)) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@80|) |mid#2@@1| (LitInt |hi#0@@12|)))) (=> (not (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (INTERNAL_sub_boogie |mid#2@@1| 1)))) (LitInt |key#0@@80|))) (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@138|) (LitInt |key#0@@80|) (LitInt |lo#0@@18|) |mid#2@@1|))))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@428) (Lit |s#0@@138|) (LitInt |key#0@@80|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@18| 1) |hi#0@@12|) (let ((|mid#2@@2| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@18| |hi#0@@12|) 2))))
(ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |s#0@@138|) (LitInt (INTERNAL_sub_boogie |mid#2@@2| 1))))) (LitInt |key#0@@80|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@428) (Lit |s#0@@138|) (LitInt |key#0@@80|) |mid#2@@2| (LitInt |hi#0@@12|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@428) (Lit |s#0@@138|) (LitInt |key#0@@80|) (LitInt |lo#0@@18|) |mid#2@@2|))) |lo#0@@18|))))
 :qid |totalorderidfyByteOrder.624:12|
 :weight 3
 :skolemid |4115|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@428) (Lit |s#0@@138|) (LitInt |key#0@@80|) (LitInt |lo#0@@18|) (LitInt |hi#0@@12|)))
))))
(assert (forall (($ly@@429 T@U) (|s#0@@139| T@U) (|key#0@@81| Int) ) (!  (=> (and (= (type $ly@@429) LayerTypeType) (= (type |s#0@@139|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@429) |s#0@@139| |key#0@@81|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@429 |s#0@@139| |key#0@@81|)))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |4116|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@429) |s#0@@139| |key#0@@81|))
)))
(assert (forall (($ly@@430 T@U) (|s#0@@140| T@U) (|key#0@@82| Int) ) (!  (=> (and (= (type $ly@@430) LayerTypeType) (= (type |s#0@@140|) (SeqType BoxType))) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@430 |s#0@@140| |key#0@@82|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@140| |key#0@@82|)))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |4117|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@430) |s#0@@140| |key#0@@82|))
)))
(assert  (=> true (forall (($ly@@431 T@U) (|s#0@@141| T@U) (|key#0@@83| Int) ) (!  (=> (and (and (= (type $ly@@431) LayerTypeType) (= (type |s#0@@141|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@141| |key#0@@83|) (and ($Is |s#0@@141| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@83|) (INTERNAL_lt_boogie |key#0@@83| 256))))) (and (and (and (INTERNAL_le_boogie 0 (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|)) (INTERNAL_le_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|) (|Seq#Length| |s#0@@141|))) (=> (INTERNAL_gt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|) 0) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |s#0@@141| (INTERNAL_sub_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|) 1)))) |key#0@@83|))) (=> (INTERNAL_lt_boogie (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|) (|Seq#Length| |s#0@@141|)) (Byte__Order.__default.lt |key#0@@83| (U_2_int ($Unbox intType (|Seq#Index| |s#0@@141| (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|))))))))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |4118|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@431 |s#0@@141| |key#0@@83|))
))))
(assert (forall (($ly@@432 T@U) (|s#0@@142| T@U) (|key#0@@84| Int) ) (!  (=> (and (and (= (type $ly@@432) LayerTypeType) (= (type |s#0@@142|) (SeqType BoxType))) (and ($Is |s#0@@142| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@84|) (INTERNAL_lt_boogie |key#0@@84| 256)))) (= (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@432 |s#0@@142| |key#0@@84|) true))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |4119|
 :pattern ( (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@432 |s#0@@142| |key#0@@84|))
)))
(assert  (=> true (forall (($ly@@433 T@U) (|s#0@@143| T@U) (|key#0@@85| Int) ) (!  (=> (and (and (= (type $ly@@433) LayerTypeType) (= (type |s#0@@143|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@143| |key#0@@85|) (and ($Is |s#0@@143| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@85|) (INTERNAL_lt_boogie |key#0@@85| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@143| |key#0@@85| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@143|) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@433) |s#0@@143| |key#0@@85|) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@143| |key#0@@85| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@143|) 1)))))
 :qid |totalorderidfyByteOrder.644:22|
 :skolemid |4120|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@433) |s#0@@143| |key#0@@85|))
))))
(assert  (=> true (forall (($ly@@434 T@U) (|s#0@@144| T@U) (|key#0@@86| Int) ) (!  (=> (and (and (= (type $ly@@434) LayerTypeType) (= (type |s#0@@144|) (SeqType BoxType))) (or (|Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@144|) (LitInt |key#0@@86|)) (and ($Is |s#0@@144| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@86|) (INTERNAL_lt_boogie |key#0@@86| 256))))) (and (|Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@144|) (LitInt |key#0@@86|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@144|)) 1)) (= (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@434) (Lit |s#0@@144|) (LitInt |key#0@@86|)) (Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@144|) (LitInt |key#0@@86|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@144|)) 1)))))
 :qid |totalorderidfyByteOrder.644:22|
 :weight 3
 :skolemid |4121|
 :pattern ( (Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@434) (Lit |s#0@@144|) (LitInt |key#0@@86|)))
))))
(assert  (=> true (forall ((|a#0@@115| T@U) (|b#0@@73| T@U) ) (!  (=> (and (and (= (type |a#0@@115|) (MapType0Type BoxType boolType)) (= (type |b#0@@73|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| |a#0@@115| |b#0@@73|) (and ($Is |a#0@@115| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@73| (TSet Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |4122|
 :pattern ( (Byte__Order.__default.SetAllLte |a#0@@115| |b#0@@73|))
))))
(assert (forall ((|a#0@@116| T@U) (|b#0@@74| T@U) ) (!  (=> (and (and (= (type |a#0@@116|) (MapType0Type BoxType boolType)) (= (type |b#0@@74|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@116| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@74| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SetAllLte#requires| |a#0@@116| |b#0@@74|) true))
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |4123|
 :pattern ( (|Byte__Order.__default.SetAllLte#requires| |a#0@@116| |b#0@@74|))
)))
(assert  (=> true (forall ((|a#0@@117| T@U) (|b#0@@75| T@U) ) (!  (=> (and (and (= (type |a#0@@117|) (MapType0Type BoxType boolType)) (= (type |b#0@@75|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| |a#0@@117| |b#0@@75|) (and ($Is |a#0@@117| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@75| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#0@@2| Int) (|y#0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@2|) (INTERNAL_lt_boogie |x#0@@2| 256)) (and (INTERNAL_le_boogie 0 |y#0|) (INTERNAL_lt_boogie |y#0| 256))) (=> (U_2_bool (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@2|)))) (=> (U_2_bool (MapType0Select |b#0@@75| ($Box (int_2_U |y#0|)))) (|Byte__Order.__default.lte#canCall| |x#0@@2| |y#0|))))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |4125|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@2| |y#0|))
 :pattern ( (MapType0Select |b#0@@75| ($Box (int_2_U |y#0|))) (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@2|))))
)) (= (Byte__Order.__default.SetAllLte |a#0@@117| |b#0@@75|) (forall ((|x#0@@3| Int) (|y#0@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@3|) (INTERNAL_lt_boogie |x#0@@3| 256)) (and (INTERNAL_le_boogie 0 |y#0@@0|) (INTERNAL_lt_boogie |y#0@@0| 256))) (=> (and (U_2_bool (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@3|)))) (U_2_bool (MapType0Select |b#0@@75| ($Box (int_2_U |y#0@@0|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@3| |y#0@@0|)))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |4124|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#0@@3| |y#0@@0|))
 :pattern ( (MapType0Select |b#0@@75| ($Box (int_2_U |y#0@@0|))) (MapType0Select |a#0@@117| ($Box (int_2_U |x#0@@3|))))
)))))
 :qid |totalorderidfyByteOrder.803:23|
 :skolemid |4126|
 :pattern ( (Byte__Order.__default.SetAllLte |a#0@@117| |b#0@@75|))
))))
(assert  (=> true (forall ((|a#0@@118| T@U) (|b#0@@76| T@U) ) (!  (=> (and (and (= (type |a#0@@118|) (MapType0Type BoxType boolType)) (= (type |b#0@@76|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@118|) (Lit |b#0@@76|)) (and ($Is |a#0@@118| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@76| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#1| Int) (|y#1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1|) (INTERNAL_lt_boogie |x#1| 256)) (and (INTERNAL_le_boogie 0 |y#1|) (INTERNAL_lt_boogie |y#1| 256))) (=> (U_2_bool (MapType0Select (Lit |a#0@@118|) ($Box (int_2_U |x#1|)))) (=> (U_2_bool (MapType0Select (Lit |b#0@@76|) ($Box (int_2_U |y#1|)))) (|Byte__Order.__default.lte#canCall| |x#1| |y#1|))))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |4128|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1| |y#1|))
 :pattern ( (MapType0Select |b#0@@76| ($Box (int_2_U |y#1|))) (MapType0Select |a#0@@118| ($Box (int_2_U |x#1|))))
)) (= (Byte__Order.__default.SetAllLte (Lit |a#0@@118|) (Lit |b#0@@76|)) (forall ((|x#1@@0| Int) (|y#1@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@0|) (INTERNAL_lt_boogie |x#1@@0| 256)) (and (INTERNAL_le_boogie 0 |y#1@@0|) (INTERNAL_lt_boogie |y#1@@0| 256))) (=> (and (U_2_bool (MapType0Select (Lit |a#0@@118|) ($Box (int_2_U |x#1@@0|)))) (U_2_bool (MapType0Select (Lit |b#0@@76|) ($Box (int_2_U |y#1@@0|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1@@0| |y#1@@0|)))
 :qid |totalorderidfyByteOrder.804:12|
 :skolemid |4127|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |x#1@@0| |y#1@@0|))
 :pattern ( (MapType0Select |b#0@@76| ($Box (int_2_U |y#1@@0|))) (MapType0Select |a#0@@118| ($Box (int_2_U |x#1@@0|))))
)))))
 :qid |totalorderidfyByteOrder.803:23|
 :weight 3
 :skolemid |4129|
 :pattern ( (Byte__Order.__default.SetAllLte (Lit |a#0@@118|) (Lit |b#0@@76|)))
))))
(assert  (=> true (forall ((|a#0@@119| T@U) (|b#0@@77| T@U) ) (!  (=> (and (and (= (type |a#0@@119|) (MapType0Type BoxType boolType)) (= (type |b#0@@77|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| |a#0@@119| |b#0@@77|) (and ($Is |a#0@@119| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@77| (TSet Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |4130|
 :pattern ( (Byte__Order.__default.SetAllLt |a#0@@119| |b#0@@77|))
))))
(assert (forall ((|a#0@@120| T@U) (|b#0@@78| T@U) ) (!  (=> (and (and (= (type |a#0@@120|) (MapType0Type BoxType boolType)) (= (type |b#0@@78|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@120| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@78| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SetAllLt#requires| |a#0@@120| |b#0@@78|) true))
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |4131|
 :pattern ( (|Byte__Order.__default.SetAllLt#requires| |a#0@@120| |b#0@@78|))
)))
(assert  (=> true (forall ((|a#0@@121| T@U) (|b#0@@79| T@U) ) (!  (=> (and (and (= (type |a#0@@121|) (MapType0Type BoxType boolType)) (= (type |b#0@@79|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| |a#0@@121| |b#0@@79|) (and ($Is |a#0@@121| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@79| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#0@@4| Int) (|y#0@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@4|) (INTERNAL_lt_boogie |x#0@@4| 256)) (and (INTERNAL_le_boogie 0 |y#0@@1|) (INTERNAL_lt_boogie |y#0@@1| 256))) (=> (U_2_bool (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@4|)))) (=> (U_2_bool (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@1|)))) (|Byte__Order.__default.lt#canCall| |x#0@@4| |y#0@@1|))))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |4133|
 :pattern ( (Byte__Order.__default.lt |x#0@@4| |y#0@@1|))
 :pattern ( (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@1|))) (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@4|))))
)) (= (Byte__Order.__default.SetAllLt |a#0@@121| |b#0@@79|) (forall ((|x#0@@5| Int) (|y#0@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#0@@5|) (INTERNAL_lt_boogie |x#0@@5| 256)) (and (INTERNAL_le_boogie 0 |y#0@@2|) (INTERNAL_lt_boogie |y#0@@2| 256))) (=> (and (U_2_bool (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@5|)))) (U_2_bool (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@2|))))) (Byte__Order.__default.lt |x#0@@5| |y#0@@2|)))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |4132|
 :pattern ( (Byte__Order.__default.lt |x#0@@5| |y#0@@2|))
 :pattern ( (MapType0Select |b#0@@79| ($Box (int_2_U |y#0@@2|))) (MapType0Select |a#0@@121| ($Box (int_2_U |x#0@@5|))))
)))))
 :qid |totalorderidfyByteOrder.807:22|
 :skolemid |4134|
 :pattern ( (Byte__Order.__default.SetAllLt |a#0@@121| |b#0@@79|))
))))
(assert  (=> true (forall ((|a#0@@122| T@U) (|b#0@@80| T@U) ) (!  (=> (and (and (= (type |a#0@@122|) (MapType0Type BoxType boolType)) (= (type |b#0@@80|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@122|) (Lit |b#0@@80|)) (and ($Is |a#0@@122| (TSet Tclass.NativeTypes.byte)) ($Is |b#0@@80| (TSet Tclass.NativeTypes.byte))))) (and (forall ((|x#1@@1| Int) (|y#1@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@1|) (INTERNAL_lt_boogie |x#1@@1| 256)) (and (INTERNAL_le_boogie 0 |y#1@@1|) (INTERNAL_lt_boogie |y#1@@1| 256))) (=> (U_2_bool (MapType0Select (Lit |a#0@@122|) ($Box (int_2_U |x#1@@1|)))) (=> (U_2_bool (MapType0Select (Lit |b#0@@80|) ($Box (int_2_U |y#1@@1|)))) (|Byte__Order.__default.lt#canCall| |x#1@@1| |y#1@@1|))))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |4136|
 :pattern ( (Byte__Order.__default.lt |x#1@@1| |y#1@@1|))
 :pattern ( (MapType0Select |b#0@@80| ($Box (int_2_U |y#1@@1|))) (MapType0Select |a#0@@122| ($Box (int_2_U |x#1@@1|))))
)) (= (Byte__Order.__default.SetAllLt (Lit |a#0@@122|) (Lit |b#0@@80|)) (forall ((|x#1@@2| Int) (|y#1@@2| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |x#1@@2|) (INTERNAL_lt_boogie |x#1@@2| 256)) (and (INTERNAL_le_boogie 0 |y#1@@2|) (INTERNAL_lt_boogie |y#1@@2| 256))) (=> (and (U_2_bool (MapType0Select (Lit |a#0@@122|) ($Box (int_2_U |x#1@@2|)))) (U_2_bool (MapType0Select (Lit |b#0@@80|) ($Box (int_2_U |y#1@@2|))))) (Byte__Order.__default.lt |x#1@@2| |y#1@@2|)))
 :qid |totalorderidfyByteOrder.808:12|
 :skolemid |4135|
 :pattern ( (Byte__Order.__default.lt |x#1@@2| |y#1@@2|))
 :pattern ( (MapType0Select |b#0@@80| ($Box (int_2_U |y#1@@2|))) (MapType0Select |a#0@@122| ($Box (int_2_U |x#1@@2|))))
)))))
 :qid |totalorderidfyByteOrder.807:22|
 :weight 3
 :skolemid |4137|
 :pattern ( (Byte__Order.__default.SetAllLt (Lit |a#0@@122|) (Lit |b#0@@80|)))
))))
(assert (forall (($ly@@435 T@U) (|a#0@@123| Int) ) (!  (=> (= (type $ly@@435) LayerTypeType) (= (Byte__Order.__default.NotMinimum ($LS $ly@@435) |a#0@@123|) (Byte__Order.__default.NotMinimum $ly@@435 |a#0@@123|)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |4138|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@435) |a#0@@123|))
)))
(assert (forall (($ly@@436 T@U) (|a#0@@124| Int) ) (!  (=> (= (type $ly@@436) LayerTypeType) (= (Byte__Order.__default.NotMinimum $ly@@436 |a#0@@124|) (Byte__Order.__default.NotMinimum $LZ |a#0@@124|)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |4139|
 :pattern ( (Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@436) |a#0@@124|))
)))
(assert  (=> true (forall (($ly@@437 T@U) (|a#0@@125| Int) ) (!  (=> (and (= (type $ly@@437) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| |a#0@@125|) (and (INTERNAL_le_boogie 0 |a#0@@125|) (INTERNAL_lt_boogie |a#0@@125| 256)))) true)
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |4140|
 :pattern ( (Byte__Order.__default.NotMinimum $ly@@437 |a#0@@125|))
))))
(assert (forall (($ly@@438 T@U) (|a#0@@126| Int) ) (!  (=> (= (type $ly@@438) LayerTypeType) (=> (and (INTERNAL_le_boogie 0 |a#0@@126|) (INTERNAL_lt_boogie |a#0@@126| 256)) (= (|Byte__Order.__default.NotMinimum#requires| $ly@@438 |a#0@@126|) true)))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |4141|
 :pattern ( (|Byte__Order.__default.NotMinimum#requires| $ly@@438 |a#0@@126|))
)))
(assert  (=> true (forall (($ly@@439 T@U) (|a#0@@127| Int) ) (!  (=> (and (= (type $ly@@439) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| |a#0@@127|) (and (INTERNAL_le_boogie 0 |a#0@@127|) (INTERNAL_lt_boogie |a#0@@127| 256)))) (and (forall ((|b#0@@81| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |b#0@@81|) (INTERNAL_lt_boogie |b#0@@81| 256)) (|Byte__Order.__default.lt#canCall| |b#0@@81| |a#0@@127|))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |4143|
 :pattern ( (Byte__Order.__default.lt |b#0@@81| |a#0@@127|))
)) (= (Byte__Order.__default.NotMinimum ($LS $ly@@439) |a#0@@127|) (exists ((|b#0@@82| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |b#0@@82|) (INTERNAL_lt_boogie |b#0@@82| 256)) (Byte__Order.__default.lt |b#0@@82| |a#0@@127|))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |4142|
 :pattern ( (Byte__Order.__default.lt |b#0@@82| |a#0@@127|))
)))))
 :qid |totalorderidfyByteOrder.820:23|
 :skolemid |4144|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@439) |a#0@@127|))
))))
(assert  (=> true (forall (($ly@@440 T@U) (|a#0@@128| Int) ) (!  (=> (and (= (type $ly@@440) LayerTypeType) (or (|Byte__Order.__default.NotMinimum#canCall| (LitInt |a#0@@128|)) (and (INTERNAL_le_boogie 0 |a#0@@128|) (INTERNAL_lt_boogie |a#0@@128| 256)))) (and (forall ((|b#1@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |b#1@@0|) (INTERNAL_lt_boogie |b#1@@0| 256)) (|Byte__Order.__default.lt#canCall| |b#1@@0| (LitInt |a#0@@128|)))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |4146|
 :pattern ( (Byte__Order.__default.lt |b#1@@0| |a#0@@128|))
)) (= (Byte__Order.__default.NotMinimum ($LS $ly@@440) (LitInt |a#0@@128|)) (exists ((|b#1@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |b#1@@1|) (INTERNAL_lt_boogie |b#1@@1| 256)) (Byte__Order.__default.lt |b#1@@1| (LitInt |a#0@@128|)))
 :qid |totalorderidfyByteOrder.821:12|
 :skolemid |4145|
 :pattern ( (Byte__Order.__default.lt |b#1@@1| |a#0@@128|))
)))))
 :qid |totalorderidfyByteOrder.820:23|
 :weight 3
 :skolemid |4147|
 :pattern ( (Byte__Order.__default.NotMinimum ($LS $ly@@440) (LitInt |a#0@@128|)))
))))
(assert (forall ((arg0@@599 T@U) (arg1@@303 T@U) (arg2@@164 Int) (arg3@@96 T@U) ) (! (= (type (Byte__Order.__default.MapPivotedUnion arg0@@599 arg1@@303 arg2@@164 arg3@@96)) (MapType BoxType BoxType))
 :qid |funType:Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Byte__Order.__default.MapPivotedUnion arg0@@599 arg1@@303 arg2@@164 arg3@@96))
)))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0| T@U) (|pivot#0| Int) (|right#0| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0|) (MapType BoxType BoxType))) (= (type |right#0|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|) (and (and ($Is |left#0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value)) (and (INTERNAL_le_boogie 0 |pivot#0|) (INTERNAL_lt_boogie |pivot#0| 256))) ($Is |right#0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|) (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |4148|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value |left#0| |pivot#0| |right#0|))
))))
(assert (forall ((Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@0| T@U) (|pivot#0@@0| Int) (|right#0@@0| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@0|) (MapType BoxType BoxType))) (= (type |right#0@@0|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@0)) (and (INTERNAL_le_boogie 0 |pivot#0@@0|) (INTERNAL_lt_boogie |pivot#0@@0| 256))) ($Is |right#0@@0| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Byte__Order.__default.MapPivotedUnion#requires| Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@0| |pivot#0@@0| |right#0@@0|) true))
 :qid |unknown.0:0|
 :skolemid |4149|
 :pattern ( (|Byte__Order.__default.MapPivotedUnion#requires| Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@0| |pivot#0@@0| |right#0@@0|))
)))
(assert  (and (forall ((arg0@@600 T@U) (arg1@@304 Int) ) (! (= (type (|lambda#283| arg0@@600 arg1@@304)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#283|
 :pattern ( (|lambda#283| arg0@@600 arg1@@304))
)) (forall ((arg0@@601 T@U) (arg1@@305 T@U) (arg2@@165 Int) ) (! (= (type (|lambda#285| arg0@@601 arg1@@305 arg2@@165)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#285|
 :pattern ( (|lambda#285| arg0@@601 arg1@@305 arg2@@165))
))))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@1| T@U) (|pivot#0@@1| Int) (|right#0@@1| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@1|) (MapType BoxType BoxType))) (= (type |right#0@@1|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|) (and (and ($Is |left#0@@1| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1)) (and (INTERNAL_le_boogie 0 |pivot#0@@1|) (INTERNAL_lt_boogie |pivot#0@@1| 256))) ($Is |right#0@@1| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@77| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#0@@77|) (INTERNAL_lt_boogie |k#0@@77| 256)) (|Byte__Order.__default.lt#canCall| |k#0@@77| |pivot#0@@1|))
 :qid |totalorderidfyByteOrder.840:57|
 :skolemid |4150|
 :pattern ( (Byte__Order.__default.lt |k#0@@77| |pivot#0@@1|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#283| Tclass.NativeTypes.byte |pivot#0@@1|))) (let ((|restricted_left#0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#283| Tclass.NativeTypes.byte |pivot#0@@1|))))
 (and (and (forall ((|k#1@@15| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#1@@15|) (INTERNAL_lt_boogie |k#1@@15| 256)) (|Byte__Order.__default.lte#canCall| |pivot#0@@1| |k#1@@15|))
 :qid |totalorderidfyByteOrder.841:59|
 :skolemid |4151|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |pivot#0@@1| |k#1@@15|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))) (let ((|restricted_right#0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0| |restricted_right#0|))))) (= (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|) (let ((|restricted_left#0@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| (|lambda#283| Tclass.NativeTypes.byte |pivot#0@@1|))))
(let ((|restricted_right#0@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@1| (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte |pivot#0@@1|))))
(Maps.__default.MapDisjointUnion Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@0| |restricted_right#0@@0|))))))
 :qid |unknown.0:0|
 :skolemid |4152|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@1| |pivot#0@@1| |right#0@@1|))
))))
(assert  (=> true (forall ((Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@2| T@U) (|pivot#0@@2| Int) (|right#0@@2| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@2|) (MapType BoxType BoxType))) (= (type |right#0@@2|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapPivotedUnion#canCall| Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)) (and (and ($Is |left#0@@2| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2)) (and (INTERNAL_le_boogie 0 |pivot#0@@2|) (INTERNAL_lt_boogie |pivot#0@@2| 256))) ($Is |right#0@@2| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@6| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#2@@6|) (INTERNAL_lt_boogie |k#2@@6| 256)) (|Byte__Order.__default.lt#canCall| |k#2@@6| (LitInt |pivot#0@@2|)))
 :qid |totalorderidfyByteOrder.840:57|
 :skolemid |4153|
 :pattern ( (Byte__Order.__default.lt |k#2@@6| |pivot#0@@2|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#283| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))) (let ((|restricted_left#1| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#283| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))))
 (and (and (forall ((|k#3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |k#3|) (INTERNAL_lt_boogie |k#3| 256)) (|Byte__Order.__default.lte#canCall| (LitInt |pivot#0@@2|) |k#3|))
 :qid |totalorderidfyByteOrder.841:59|
 :skolemid |4154|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |pivot#0@@2| |k#3|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))) (let ((|restricted_right#1| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1| |restricted_right#1|))))) (= (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)) (let ((|restricted_left#1@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (|lambda#283| Tclass.NativeTypes.byte (LitInt |pivot#0@@2|)))))
(let ((|restricted_right#1@@0| (Maps.__default.MapIRestrict Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@2|) (|lambda#285| Tclass.NativeTypes.byte StartFuel_Byte_Order._default.lte (LitInt |pivot#0@@2|)))))
(Maps.__default.MapDisjointUnion Tclass.NativeTypes.byte Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@0| |restricted_right#1@@0|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4155|
 :pattern ( (Byte__Order.__default.MapPivotedUnion Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@2|) (LitInt |pivot#0@@2|) (Lit |right#0@@2|)))
))))
(assert (forall ((arg0@@602 T@U) (arg1@@306 Int) ) (! (= (type (Byte__Order.__default.SetSuccessor arg0@@602 arg1@@306)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.SetSuccessor|
 :pattern ( (Byte__Order.__default.SetSuccessor arg0@@602 arg1@@306))
)))
(assert  (=> true (forall ((|m#0@@110| T@U) (|key#0@@87| Int) ) (!  (=> (and (= (type |m#0@@110|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.SetSuccessor#canCall| |m#0@@110| |key#0@@87|) (and ($Is |m#0@@110| (TSet Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@87|) (INTERNAL_lt_boogie |key#0@@87| 256))))) ($Is (Byte__Order.__default.SetSuccessor |m#0@@110| |key#0@@87|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |totalorderidfyByteOrder.845:25|
 :skolemid |4156|
 :pattern ( (Byte__Order.__default.SetSuccessor |m#0@@110| |key#0@@87|))
))))
(assert (forall (($Heap@@60 T@U) (|m#0@@111| T@U) (|key#0@@88| Int) ) (!  (=> (and (= (type $Heap@@60) (MapType0Type refType MapType1Type)) (= (type |m#0@@111|) (MapType0Type BoxType boolType))) (=> (and (and ($IsGoodHeap $Heap@@60) ($Is |m#0@@111| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@88|) (INTERNAL_lt_boogie |key#0@@88| 256))) (= (|Byte__Order.__default.SetSuccessor#requires| |m#0@@111| |key#0@@88|) true)))
 :qid |totalorderidfyByteOrder.845:12|
 :skolemid |4157|
 :pattern ( (|Byte__Order.__default.SetSuccessor#requires| |m#0@@111| |key#0@@88|) ($IsGoodHeap $Heap@@60))
)))
(assert (forall ((m@@68 T@U) (key Int) ) (!  (=> (and (= (type m@@68) (MapType0Type BoxType boolType)) (|$let#16$canCall| m@@68 key)) (and (and (INTERNAL_le_boogie 0 (|$let#16_next| m@@68 key)) (INTERNAL_lt_boogie (|$let#16_next| m@@68 key) 256)) (and (and (U_2_bool (MapType0Select m@@68 ($Box (int_2_U (|$let#16_next| m@@68 key))))) (Byte__Order.__default.lt key (|$let#16_next| m@@68 key))) (forall ((|other#1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#1|) (INTERNAL_lt_boogie |other#1| 256)) (=> (and (and (U_2_bool (MapType0Select m@@68 ($Box (int_2_U |other#1|)))) (not (= |other#1| (|$let#16_next| m@@68 key)))) (Byte__Order.__default.lt key |other#1|)) (Byte__Order.__default.lt (|$let#16_next| m@@68 key) |other#1|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4160|
 :pattern ( (Byte__Order.__default.lt (|$let#16_next| m@@68 key) |other#1|))
 :pattern ( (Byte__Order.__default.lt key |other#1|))
 :pattern ( (MapType0Select m@@68 ($Box (int_2_U |other#1|))))
)))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4161|
 :pattern ( (|$let#16_next| m@@68 key))
)))
(assert  (=> true (forall (($Heap@@61 T@U) (|m#0@@112| T@U) (|key#0@@89| Int) ) (!  (=> (and (and (= (type $Heap@@61) (MapType0Type refType MapType1Type)) (= (type |m#0@@112|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetSuccessor#canCall| |m#0@@112| |key#0@@89|) (and (and ($IsGoodHeap $Heap@@61) ($Is |m#0@@112| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@89|) (INTERNAL_lt_boogie |key#0@@89| 256))))) (and (and (forall ((|next#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |next#0|) (INTERNAL_lt_boogie |next#0| 256)) (=> (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0|)))) (and (|Byte__Order.__default.lt#canCall| |key#0@@89| |next#0|) (=> (Byte__Order.__default.lt |key#0@@89| |next#0|) (forall ((|other#0@@11| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@11|) (INTERNAL_lt_boogie |other#0@@11| 256)) (=> (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@11|)))) (=> (not (= |other#0@@11| |next#0|)) (and (|Byte__Order.__default.lt#canCall| |key#0@@89| |other#0@@11|) (=> (Byte__Order.__default.lt |key#0@@89| |other#0@@11|) (|Byte__Order.__default.lt#canCall| |next#0| |other#0@@11|))))))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4162|
 :pattern ( (Byte__Order.__default.lt |next#0| |other#0@@11|))
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |other#0@@11|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@11|))))
))))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4163|
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |next#0|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0|))))
)) (=> (exists ((|next#0@@0| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#0@@0|) (INTERNAL_lt_boogie |next#0@@0| 256)) (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@0|)))) (Byte__Order.__default.lt |key#0@@89| |next#0@@0|)) (forall ((|other#0@@12| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@12|) (INTERNAL_lt_boogie |other#0@@12| 256)) (=> (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@12|)))) (not (= |other#0@@12| |next#0@@0|))) (Byte__Order.__default.lt |key#0@@89| |other#0@@12|)) (Byte__Order.__default.lt |next#0@@0| |other#0@@12|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4164|
 :pattern ( (Byte__Order.__default.lt |next#0@@0| |other#0@@12|))
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |other#0@@12|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@12|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4165|
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |next#0@@0|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@0|))))
)) (|$let#16$canCall| |m#0@@112| |key#0@@89|))) (= (Byte__Order.__default.SetSuccessor |m#0@@112| |key#0@@89|) (ite (exists ((|next#0@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#0@@1|) (INTERNAL_lt_boogie |next#0@@1| 256)) (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@1|)))) (Byte__Order.__default.lt |key#0@@89| |next#0@@1|)) (forall ((|other#0@@13| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#0@@13|) (INTERNAL_lt_boogie |other#0@@13| 256)) (=> (and (and (U_2_bool (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@13|)))) (not (= |other#0@@13| |next#0@@1|))) (Byte__Order.__default.lt |key#0@@89| |other#0@@13|)) (Byte__Order.__default.lt |next#0@@1| |other#0@@13|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4158|
 :pattern ( (Byte__Order.__default.lt |next#0@@1| |other#0@@13|))
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |other#0@@13|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |other#0@@13|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4159|
 :pattern ( (Byte__Order.__default.lt |key#0@@89| |next#0@@1|))
 :pattern ( (MapType0Select |m#0@@112| ($Box (int_2_U |next#0@@1|))))
)) (let ((|next#1| (|$let#16_next| |m#0@@112| |key#0@@89|)))
(|#Options.Option.Some| ($Box (int_2_U |next#1|)))) |#Options.Option.None|))))
 :qid |totalorderidfyByteOrder.845:12|
 :skolemid |4166|
 :pattern ( (Byte__Order.__default.SetSuccessor |m#0@@112| |key#0@@89|) ($IsGoodHeap $Heap@@61))
))))
(assert  (=> true (forall (($Heap@@62 T@U) (|m#0@@113| T@U) (|key#0@@90| Int) ) (!  (=> (and (and (= (type $Heap@@62) (MapType0Type refType MapType1Type)) (= (type |m#0@@113|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@113|) (LitInt |key#0@@90|)) (and (and ($IsGoodHeap $Heap@@62) ($Is |m#0@@113| (TSet Tclass.NativeTypes.byte))) (and (INTERNAL_le_boogie 0 |key#0@@90|) (INTERNAL_lt_boogie |key#0@@90| 256))))) (and (and (forall ((|next#2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |next#2|) (INTERNAL_lt_boogie |next#2| 256)) (=> (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2|)))) (and (|Byte__Order.__default.lt#canCall| (LitInt |key#0@@90|) |next#2|) (=> (Byte__Order.__default.lt (LitInt |key#0@@90|) |next#2|) (forall ((|other#2| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2|) (INTERNAL_lt_boogie |other#2| 256)) (=> (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2|)))) (=> (not (= |other#2| |next#2|)) (and (|Byte__Order.__default.lt#canCall| (LitInt |key#0@@90|) |other#2|) (=> (Byte__Order.__default.lt (LitInt |key#0@@90|) |other#2|) (|Byte__Order.__default.lt#canCall| |next#2| |other#2|))))))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4169|
 :pattern ( (Byte__Order.__default.lt |next#2| |other#2|))
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |other#2|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2|))))
))))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4170|
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |next#2|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2|))))
)) (=> (exists ((|next#2@@0| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#2@@0|) (INTERNAL_lt_boogie |next#2@@0| 256)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2@@0|)))) (Byte__Order.__default.lt (LitInt |key#0@@90|) |next#2@@0|)) (forall ((|other#2@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2@@0|) (INTERNAL_lt_boogie |other#2@@0| 256)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2@@0|)))) (not (= |other#2@@0| |next#2@@0|))) (Byte__Order.__default.lt (LitInt |key#0@@90|) |other#2@@0|)) (Byte__Order.__default.lt |next#2@@0| |other#2@@0|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4171|
 :pattern ( (Byte__Order.__default.lt |next#2@@0| |other#2@@0|))
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |other#2@@0|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2@@0|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4172|
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |next#2@@0|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2@@0|))))
)) (|$let#16$canCall| (Lit |m#0@@113|) (LitInt |key#0@@90|)))) (= (Byte__Order.__default.SetSuccessor (Lit |m#0@@113|) (LitInt |key#0@@90|)) (ite (exists ((|next#2@@1| Int) ) (!  (and (and (INTERNAL_le_boogie 0 |next#2@@1|) (INTERNAL_lt_boogie |next#2@@1| 256)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |next#2@@1|)))) (Byte__Order.__default.lt (LitInt |key#0@@90|) |next#2@@1|)) (forall ((|other#2@@1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |other#2@@1|) (INTERNAL_lt_boogie |other#2@@1| 256)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@113|) ($Box (int_2_U |other#2@@1|)))) (not (= |other#2@@1| |next#2@@1|))) (Byte__Order.__default.lt (LitInt |key#0@@90|) |other#2@@1|)) (Byte__Order.__default.lt |next#2@@1| |other#2@@1|)))
 :qid |totalorderidfyByteOrder.850:18|
 :skolemid |4167|
 :pattern ( (Byte__Order.__default.lt |next#2@@1| |other#2@@1|))
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |other#2@@1|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |other#2@@1|))))
))))
 :qid |totalorderidfyByteOrder.847:8|
 :skolemid |4168|
 :pattern ( (Byte__Order.__default.lt |key#0@@90| |next#2@@1|))
 :pattern ( (MapType0Select |m#0@@113| ($Box (int_2_U |next#2@@1|))))
)) (let ((|next#3| (|$let#16_next| (Lit |m#0@@113|) (LitInt |key#0@@90|))))
(|#Options.Option.Some| ($Box (int_2_U |next#3|)))) |#Options.Option.None|))))
 :qid |totalorderidfyByteOrder.845:12|
 :weight 3
 :skolemid |4173|
 :pattern ( (Byte__Order.__default.SetSuccessor (Lit |m#0@@113|) (LitInt |key#0@@90|)) ($IsGoodHeap $Heap@@62))
))))
(assert (forall ((arg0@@603 T@U) (arg1@@307 T@U) (arg2@@166 Int) ) (! (= (type (Byte__Order.__default.MapSuccessor arg0@@603 arg1@@307 arg2@@166)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.MapSuccessor|
 :pattern ( (Byte__Order.__default.MapSuccessor arg0@@603 arg1@@307 arg2@@166))
)))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V T@U) (|m#0@@114| T@U) (|key#0@@91| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@114|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@91|) (and ($Is |m#0@@114| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V)) (and (INTERNAL_le_boogie 0 |key#0@@91|) (INTERNAL_lt_boogie |key#0@@91| 256))))) ($Is (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@91|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |unknown.0:0|
 :skolemid |4174|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V |m#0@@114| |key#0@@91|))
))))
(assert (forall ((Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@115| T@U) (|key#0@@92| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@115|) (MapType BoxType BoxType))) (and ($Is |m#0@@115| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@0)) (and (INTERNAL_le_boogie 0 |key#0@@92|) (INTERNAL_lt_boogie |key#0@@92| 256)))) (= (|Byte__Order.__default.MapSuccessor#requires| Byte_Order._default.MapSuccessor$V@@0 |m#0@@115| |key#0@@92|) true))
 :qid |unknown.0:0|
 :skolemid |4175|
 :pattern ( (|Byte__Order.__default.MapSuccessor#requires| Byte_Order._default.MapSuccessor$V@@0 |m#0@@115| |key#0@@92|))
)))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@116| T@U) (|key#0@@93| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@116|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@93|) (and ($Is |m#0@@116| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@1)) (and (INTERNAL_le_boogie 0 |key#0@@93|) (INTERNAL_lt_boogie |key#0@@93| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@116|) |key#0@@93|) (= (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@93|) (Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@116|) |key#0@@93|))))
 :qid |unknown.0:0|
 :skolemid |4176|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@1 |m#0@@116| |key#0@@93|))
))))
(assert  (=> true (forall ((Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@117| T@U) (|key#0@@94| Int) ) (!  (=> (and (and (= (type Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@117|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.MapSuccessor#canCall| Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@94|)) (and ($Is |m#0@@117| (TMap Tclass.NativeTypes.byte Byte_Order._default.MapSuccessor$V@@2)) (and (INTERNAL_le_boogie 0 |key#0@@94|) (INTERNAL_lt_boogie |key#0@@94| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@117|))) (LitInt |key#0@@94|)) (= (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@94|)) (Lit (Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@117|))) (LitInt |key#0@@94|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4177|
 :pattern ( (Byte__Order.__default.MapSuccessor Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@117|) (LitInt |key#0@@94|)))
))))
(assert (forall ((arg0@@604 T@U) (arg1@@308 Int) ) (! (= (type (Byte__Order.__default.SeqSuccessor arg0@@604 arg1@@308)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.SeqSuccessor|
 :pattern ( (Byte__Order.__default.SeqSuccessor arg0@@604 arg1@@308))
)))
(assert  (=> true (forall ((|m#0@@118| T@U) (|key#0@@95| Int) ) (!  (=> (and (= (type |m#0@@118|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| |m#0@@118| |key#0@@95|) (and ($Is |m#0@@118| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@95|) (INTERNAL_lt_boogie |key#0@@95| 256))))) ($Is (Byte__Order.__default.SeqSuccessor |m#0@@118| |key#0@@95|) (Tclass.Options.Option Tclass.NativeTypes.byte)))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |4178|
 :pattern ( (Byte__Order.__default.SeqSuccessor |m#0@@118| |key#0@@95|))
))))
(assert (forall ((|m#0@@119| T@U) (|key#0@@96| Int) ) (!  (=> (= (type |m#0@@119|) (SeqType BoxType)) (=> (and ($Is |m#0@@119| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@96|) (INTERNAL_lt_boogie |key#0@@96| 256))) (= (|Byte__Order.__default.SeqSuccessor#requires| |m#0@@119| |key#0@@96|) true)))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |4179|
 :pattern ( (|Byte__Order.__default.SeqSuccessor#requires| |m#0@@119| |key#0@@96|))
)))
(assert (forall ((arg0@@605 T@U) (arg1@@309 T@U) ) (! (= (type (|lambda#295| arg0@@605 arg1@@309)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#295|
 :pattern ( (|lambda#295| arg0@@605 arg1@@309))
)))
(assert  (=> true (forall ((|m#0@@120| T@U) (|key#0@@97| Int) ) (!  (=> (and (= (type |m#0@@120|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| |m#0@@120| |key#0@@97|) (and ($Is |m#0@@120| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@97|) (INTERNAL_lt_boogie |key#0@@97| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| Tclass.NativeTypes.byte |m#0@@120|) |key#0@@97|) (= (Byte__Order.__default.SeqSuccessor |m#0@@120| |key#0@@97|) (Byte__Order.__default.SetSuccessor (|lambda#295| Tclass.NativeTypes.byte |m#0@@120|) |key#0@@97|))))
 :qid |totalorderidfyByteOrder.861:25|
 :skolemid |4180|
 :pattern ( (Byte__Order.__default.SeqSuccessor |m#0@@120| |key#0@@97|))
))))
(assert  (=> true (forall ((|m#0@@121| T@U) (|key#0@@98| Int) ) (!  (=> (and (= (type |m#0@@121|) (SeqType BoxType)) (or (|Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@121|) (LitInt |key#0@@98|)) (and ($Is |m#0@@121| (TSeq Tclass.NativeTypes.byte)) (and (INTERNAL_le_boogie 0 |key#0@@98|) (INTERNAL_lt_boogie |key#0@@98| 256))))) (and (|Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| Tclass.NativeTypes.byte |m#0@@121|) (LitInt |key#0@@98|)) (= (Byte__Order.__default.SeqSuccessor (Lit |m#0@@121|) (LitInt |key#0@@98|)) (Byte__Order.__default.SetSuccessor (|lambda#295| Tclass.NativeTypes.byte |m#0@@121|) (LitInt |key#0@@98|)))))
 :qid |totalorderidfyByteOrder.861:25|
 :weight 3
 :skolemid |4181|
 :pattern ( (Byte__Order.__default.SeqSuccessor (Lit |m#0@@121|) (LitInt |key#0@@98|)))
))))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@441 T@U) (|s#0@@145| T@U) (|m#0@@122| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@441) LayerTypeType)) (= (type |s#0@@145|) (SeqType BoxType))) (= (type |m#0@@122|) (MapType BoxType BoxType))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V ($LS $ly@@441) |s#0@@145| |m#0@@122|) (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V $ly@@441 |s#0@@145| |m#0@@122|)))
 :qid |unknown.0:0|
 :skolemid |4182|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V ($LS $ly@@441) |s#0@@145| |m#0@@122|))
)))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@442 T@U) (|s#0@@146| T@U) (|m#0@@123| T@U) ) (!  (=> (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@442) LayerTypeType)) (= (type |s#0@@146|) (SeqType BoxType))) (= (type |m#0@@123|) (MapType BoxType BoxType))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 $ly@@442 |s#0@@146| |m#0@@123|) (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@146| |m#0@@123|)))
 :qid |unknown.0:0|
 :skolemid |4183|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@442) |s#0@@146| |m#0@@123|))
)))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@443 T@U) (|s#0@@147| T@U) (|m#0@@124| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@443) LayerTypeType)) (= (type |s#0@@147|) (SeqType BoxType))) (= (type |m#0@@124|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@147| |m#0@@124|) (and ($Is |s#0@@147| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@124| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |4184|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@1 $ly@@443 |s#0@@147| |m#0@@124|))
))))
(assert (forall ((Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@444 T@U) (|s#0@@148| T@U) (|m#0@@125| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@444) LayerTypeType)) (= (type |s#0@@148|) (SeqType BoxType))) (= (type |m#0@@125|) (MapType BoxType BoxType))) (and ($Is |s#0@@148| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@125| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Byte__Order.__default.SortedSeqForMap#requires| Byte_Order._default.SortedSeqForMap$V@@2 $ly@@444 |s#0@@148| |m#0@@125|) true))
 :qid |unknown.0:0|
 :skolemid |4185|
 :pattern ( (|Byte__Order.__default.SortedSeqForMap#requires| Byte_Order._default.SortedSeqForMap$V@@2 $ly@@444 |s#0@@148| |m#0@@125|))
)))
(assert  (and (= (type StartFuel_Sequences._default.Unzip) LayerTypeType) (= (type StartFuel_Byte_Order._default.IsStrictlySorted) LayerTypeType)))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@445 T@U) (|s#0@@149| T@U) (|m#0@@126| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@445) LayerTypeType)) (= (type |s#0@@149|) (SeqType BoxType))) (= (type |m#0@@126|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@149| |m#0@@126|) (and ($Is |s#0@@149| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@126| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@149|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|))) (|Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|))))) (=> (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|)))) (and (forall ((|i#0@@141| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@141|) (=> (INTERNAL_lt_boogie |i#0@@141| (|Seq#Length| |s#0@@149|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@141|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@141|) (INTERNAL_lt_boogie |i#0@@141| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@141|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@141|) (=> (INTERNAL_lt_boogie |i#0@@141| (|Seq#Length| |s#0@@149|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@141|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@141|))))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4189|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@141|)))
)) (=> (forall ((|i#0@@142| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@142|) (INTERNAL_lt_boogie |i#0@@142| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@142|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@142|) (INTERNAL_lt_boogie |i#0@@142| (|Seq#Length| |s#0@@149|))) (= (MapType0Select (|Map#Elements| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@142|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@142|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4192|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@142|)))
)) (forall ((|key#0@@99| T@U) ) (!  (=> (= (type |key#0@@99|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |key#0@@99|)) (INTERNAL_lt_boogie (U_2_int |key#0@@99|) 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) ($Box |key#0@@99|))) (forall ((|i#1@@38| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@38|) (=> (INTERNAL_lt_boogie |i#1@@38| (|Seq#Length| |s#0@@149|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@38|))) (=> (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@38|))))) (U_2_int |key#0@@99|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@38|)))))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |4190|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@38|)))
)))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |4191|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@126|) ($Box |key#0@@99|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@126|) ($Box |key#0@@99|)))
)))))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@445) |s#0@@149| |m#0@@126|)  (and (and (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@149|)))) (forall ((|i#0@@143| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@143|) (INTERNAL_lt_boogie |i#0@@143| (|Seq#Length| |s#0@@149|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@143|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@143|) (INTERNAL_lt_boogie |i#0@@143| (|Seq#Length| |s#0@@149|))) (= (MapType0Select (|Map#Elements| |m#0@@126|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@143|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@143|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4186|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#0@@143|)))
))) (forall ((|key#0@@100| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |key#0@@100|) (INTERNAL_lt_boogie |key#0@@100| 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@126|) ($Box (int_2_U |key#0@@100|)))) (exists ((|i#1@@39| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@39|) (INTERNAL_lt_boogie |i#1@@39| (|Seq#Length| |s#0@@149|))) (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@39|))))) |key#0@@100|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@39|))) (MapType0Select (|Map#Elements| |m#0@@126|) ($Box (int_2_U |key#0@@100|)))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |4187|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@149| |i#1@@39|)))
))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |4188|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@126|) ($Box (int_2_U |key#0@@100|))))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@126|) ($Box (int_2_U |key#0@@100|))))
))))))
 :qid |unknown.0:0|
 :skolemid |4193|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@445) |s#0@@149| |m#0@@126|))
))))
(assert  (=> true (forall ((Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@446 T@U) (|s#0@@150| T@U) (|m#0@@127| T@U) ) (!  (=> (and (and (and (and (= (type Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@446) LayerTypeType)) (= (type |s#0@@150|) (SeqType BoxType))) (= (type |m#0@@127|) (MapType BoxType BoxType))) (or (|Byte__Order.__default.SortedSeqForMap#canCall| Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@150|) (Lit |m#0@@127|)) (and ($Is |s#0@@150| (TSeq (Tclass._System.Tuple2 Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@127| (TMap Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@150|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|)))) (|Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|)))))) (=> (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|))))) (and (forall ((|i#2@@12| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@12|) (=> (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@150|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@12|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@12|) (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@12|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@12|) (=> (INTERNAL_lt_boogie |i#2@@12| (|Seq#Length| (Lit |s#0@@150|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@12|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@12|))))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4197|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@12|)))
)) (=> (forall ((|i#2@@13| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@13|) (INTERNAL_lt_boogie |i#2@@13| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@13|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@13|) (INTERNAL_lt_boogie |i#2@@13| (|Seq#Length| (Lit |s#0@@150|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@13|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@13|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4200|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@13|)))
)) (forall ((|key#1@@8| T@U) ) (!  (=> (= (type |key#1@@8|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |key#1@@8|)) (INTERNAL_lt_boogie (U_2_int |key#1@@8|) 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) ($Box |key#1@@8|))) (forall ((|i#3@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@5|) (=> (INTERNAL_lt_boogie |i#3@@5| (|Seq#Length| (Lit |s#0@@150|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@5|))) (=> (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@5|))))) (U_2_int |key#1@@8|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@5|)))))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |4198|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#3@@5|)))
)))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |4199|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@127|) ($Box |key#1@@8|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@127|) ($Box |key#1@@8|)))
)))))) (= (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@446) (Lit |s#0@@150|) (Lit |m#0@@127|))  (and (and (Byte__Order.__default.IsStrictlySorted StartFuel_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.NativeTypes.byte Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@150|))))) (forall ((|i#2@@14| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@14|) (INTERNAL_lt_boogie |i#2@@14| (|Seq#Length| (Lit |s#0@@150|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@14|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@14|) (INTERNAL_lt_boogie |i#2@@14| (|Seq#Length| (Lit |s#0@@150|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@14|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#2@@14|)))))))
 :qid |totalorderidfyByteOrder.869:16|
 :skolemid |4194|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#2@@14|)))
))) (forall ((|key#1@@9| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |key#1@@9|) (INTERNAL_lt_boogie |key#1@@9| 256)) (=> (U_2_bool (MapType0Select (|Map#Domain| |m#0@@127|) ($Box (int_2_U |key#1@@9|)))) (exists ((|i#3@@6| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@6|) (INTERNAL_lt_boogie |i#3@@6| (|Seq#Length| (Lit |s#0@@150|)))) (= (U_2_int ($Unbox intType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@6|))))) |key#1@@9|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@150|) |i#3@@6|))) (MapType0Select (|Map#Elements| (Lit |m#0@@127|)) ($Box (int_2_U |key#1@@9|)))))
 :qid |totalorderidfyByteOrder.870:44|
 :skolemid |4195|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@150| |i#3@@6|)))
))))
 :qid |totalorderidfyByteOrder.870:16|
 :skolemid |4196|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@127|) ($Box (int_2_U |key#1@@9|))))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@127|) ($Box (int_2_U |key#1@@9|))))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4201|
 :pattern ( (Byte__Order.__default.SortedSeqForMap Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@446) (Lit |s#0@@150|) (Lit |m#0@@127|)))
))))
(assert (forall (($ly@@447 T@U) (|s#0@@151| T@U) ) (!  (=> (and (= (type $ly@@447) LayerTypeType) (= (type |s#0@@151|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimum ($LS $ly@@447) |s#0@@151|) (Byte__Order.__default.minimum $ly@@447 |s#0@@151|)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |4202|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@447) |s#0@@151|))
)))
(assert (forall (($ly@@448 T@U) (|s#0@@152| T@U) ) (!  (=> (and (= (type $ly@@448) LayerTypeType) (= (type |s#0@@152|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimum $ly@@448 |s#0@@152|) (Byte__Order.__default.minimum $LZ |s#0@@152|)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |4203|
 :pattern ( (Byte__Order.__default.minimum (AsFuelBottom $ly@@448) |s#0@@152|))
)))
(assert  (=> true (forall (($ly@@449 T@U) (|s#0@@153| T@U) ) (!  (=> (and (and (= (type $ly@@449) LayerTypeType) (= (type |s#0@@153|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| |s#0@@153|) (and ($Is |s#0@@153| (TSet Tclass.NativeTypes.byte)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@153|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@153| ($Box (int_2_U (Byte__Order.__default.minimum $ly@@449 |s#0@@153|))))) (forall ((|y#0@@3| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@3|) (INTERNAL_lt_boogie |y#0@@3| 256)) (U_2_bool (MapType0Select |s#0@@153| ($Box (int_2_U |y#0@@3|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (Byte__Order.__default.minimum $ly@@449 |s#0@@153|) |y#0@@3|))
 :qid |totalorderidfyByteOrder.876:18|
 :skolemid |4204|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (Byte__Order.__default.minimum $ly@@449 |s#0@@153|) |y#0@@3|))
 :pattern ( (MapType0Select |s#0@@153| ($Box (int_2_U |y#0@@3|))))
))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.minimum $ly@@449 |s#0@@153|)) (INTERNAL_lt_boogie (Byte__Order.__default.minimum $ly@@449 |s#0@@153|) 256))))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |4205|
 :pattern ( (Byte__Order.__default.minimum $ly@@449 |s#0@@153|))
))))
(assert (forall (($ly@@450 T@U) ($Heap@@63 T@U) (|s#0@@154| T@U) ) (!  (=> (and (and (and (= (type $ly@@450) LayerTypeType) (= (type $Heap@@63) (MapType0Type refType MapType1Type))) (= (type |s#0@@154|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@63) ($Is |s#0@@154| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.minimum#requires| $ly@@450 |s#0@@154|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@154|) 1)))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |4206|
 :pattern ( (|Byte__Order.__default.minimum#requires| $ly@@450 |s#0@@154|) ($IsGoodHeap $Heap@@63))
)))
(assert (forall ((s@@51 T@U) ) (!  (=> (and (= (type s@@51) (MapType0Type BoxType boolType)) (|$let#19$canCall| s@@51)) (and (and (INTERNAL_le_boogie 0 (|$let#19_a| s@@51)) (INTERNAL_lt_boogie (|$let#19_a| s@@51) 256)) (U_2_bool (MapType0Select s@@51 ($Box (int_2_U (|$let#19_a| s@@51)))))))
 :qid |totalorderidfyByteOrder.881:5|
 :skolemid |4207|
 :pattern ( (|$let#19_a| s@@51))
)))
(assert  (=> true (forall (($ly@@451 T@U) ($Heap@@64 T@U) (|s#0@@155| T@U) ) (!  (=> (and (and (and (= (type $ly@@451) LayerTypeType) (= (type $Heap@@64) (MapType0Type refType MapType1Type))) (= (type |s#0@@155|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| |s#0@@155|) (and (and ($IsGoodHeap $Heap@@64) ($Is |s#0@@155| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@155|) 1)))) (and (and (|$let#19$canCall| |s#0@@155|) (let ((|s'#1| (|Set#Difference| |s#0@@155| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#19_a| |s#0@@155|)))))))
 (=> (not (|Set#Equal| |s'#1| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.minimum#canCall| |s'#1|) (let ((|m'#1@@1| (Byte__Order.__default.minimum $ly@@451 |s'#1|)))
(|Byte__Order.__default.lt#canCall| (|$let#19_a| |s#0@@155|) |m'#1@@1|)))))) (= (Byte__Order.__default.minimum ($LS $ly@@451) |s#0@@155|) (let ((|a#0@@129| (|$let#19_a| |s#0@@155|)))
(let ((|s'#0| (|Set#Difference| |s#0@@155| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#0@@129|))))))
(ite (|Set#Equal| |s'#0| (|Set#Empty| BoxType)) |a#0@@129| (let ((|m'#0@@10| (Byte__Order.__default.minimum $ly@@451 |s'#0|)))
(ite (Byte__Order.__default.lt |a#0@@129| |m'#0@@10|) |a#0@@129| |m'#0@@10|))))))))
 :qid |totalorderidfyByteOrder.873:22|
 :skolemid |4208|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@451) |s#0@@155|) ($IsGoodHeap $Heap@@64))
))))
(assert  (=> true (forall (($ly@@452 T@U) ($Heap@@65 T@U) (|s#0@@156| T@U) ) (!  (=> (and (and (and (= (type $ly@@452) LayerTypeType) (= (type $Heap@@65) (MapType0Type refType MapType1Type))) (= (type |s#0@@156|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimum#canCall| (Lit |s#0@@156|)) (and (and ($IsGoodHeap $Heap@@65) ($Is |s#0@@156| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@156|)) 1)))) (and (and (|$let#19$canCall| (Lit |s#0@@156|)) (let ((|s'#3| (|Set#Difference| |s#0@@156| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#19_a| (Lit |s#0@@156|))))))))
 (=> (not (|Set#Equal| |s'#3| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.minimum#canCall| |s'#3|) (let ((|m'#3| (Byte__Order.__default.minimum ($LS $ly@@452) |s'#3|)))
(|Byte__Order.__default.lt#canCall| (|$let#19_a| (Lit |s#0@@156|)) |m'#3|)))))) (= (Byte__Order.__default.minimum ($LS $ly@@452) (Lit |s#0@@156|)) (let ((|a#1@@0| (|$let#19_a| (Lit |s#0@@156|))))
(let ((|s'#2| (|Set#Difference| |s#0@@156| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#1@@0|))))))
(ite (|Set#Equal| |s'#2| (|Set#Empty| BoxType)) |a#1@@0| (let ((|m'#2@@0| (Byte__Order.__default.minimum ($LS $ly@@452) |s'#2|)))
(ite (Byte__Order.__default.lt |a#1@@0| |m'#2@@0|) |a#1@@0| |m'#2@@0|))))))))
 :qid |totalorderidfyByteOrder.873:22|
 :weight 3
 :skolemid |4209|
 :pattern ( (Byte__Order.__default.minimum ($LS $ly@@452) (Lit |s#0@@156|)) ($IsGoodHeap $Heap@@65))
))))
(assert (forall ((arg0@@606 T@U) (arg1@@310 T@U) ) (! (= (type (Byte__Order.__default.minimumOpt arg0@@606 arg1@@310)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.minimumOpt|
 :pattern ( (Byte__Order.__default.minimumOpt arg0@@606 arg1@@310))
)))
(assert (forall (($ly@@453 T@U) (|s#0@@157| T@U) ) (!  (=> (and (= (type $ly@@453) LayerTypeType) (= (type |s#0@@157|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimumOpt ($LS $ly@@453) |s#0@@157|) (Byte__Order.__default.minimumOpt $ly@@453 |s#0@@157|)))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |4210|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@453) |s#0@@157|))
)))
(assert (forall (($ly@@454 T@U) (|s#0@@158| T@U) ) (!  (=> (and (= (type $ly@@454) LayerTypeType) (= (type |s#0@@158|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.minimumOpt $ly@@454 |s#0@@158|) (Byte__Order.__default.minimumOpt $LZ |s#0@@158|)))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |4211|
 :pattern ( (Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@454) |s#0@@158|))
)))
(assert  (=> true (forall (($ly@@455 T@U) (|s#0@@159| T@U) ) (!  (=> (and (and (= (type $ly@@455) LayerTypeType) (= (type |s#0@@159|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| |s#0@@159|) ($Is |s#0@@159| (TSet Tclass.NativeTypes.byte)))) (and (and (and (=> (Options.Option.Some_q (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|)) (U_2_bool (MapType0Select |s#0@@159| (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|))))) (=> (Options.Option.Some_q (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|)) (forall ((|y#0@@4| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@4|) (INTERNAL_lt_boogie |y#0@@4| 256)) (U_2_bool (MapType0Select |s#0@@159| ($Box (int_2_U |y#0@@4|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|)))) |y#0@@4|))
 :qid |totalorderidfyByteOrder.899:30|
 :skolemid |4212|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|)))) |y#0@@4|))
 :pattern ( (MapType0Select |s#0@@159| ($Box (int_2_U |y#0@@4|))))
)))) (=> (Options.Option.None_q (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|)) (|Set#Equal| |s#0@@159| (|Set#Empty| BoxType)))) ($Is (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|) (Tclass.Options.Option Tclass.NativeTypes.byte))))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |4213|
 :pattern ( (Byte__Order.__default.minimumOpt $ly@@455 |s#0@@159|))
))))
(assert (forall (($ly@@456 T@U) (|s#0@@160| T@U) ) (!  (=> (and (and (= (type $ly@@456) LayerTypeType) (= (type |s#0@@160|) (MapType0Type BoxType boolType))) ($Is |s#0@@160| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.minimumOpt#requires| $ly@@456 |s#0@@160|) true))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |4214|
 :pattern ( (|Byte__Order.__default.minimumOpt#requires| $ly@@456 |s#0@@160|))
)))
(assert (= (type StartFuel_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@457 T@U) (|s#0@@161| T@U) ) (!  (=> (and (and (= (type $ly@@457) LayerTypeType) (= (type |s#0@@161|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| |s#0@@161|) ($Is |s#0@@161| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@161| (|Set#Empty| BoxType))) (|Byte__Order.__default.minimum#canCall| |s#0@@161|)) (= (Byte__Order.__default.minimumOpt ($LS $ly@@457) |s#0@@161|) (ite (|Set#Equal| |s#0@@161| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.minimum StartFuel_Byte_Order._default.minimum |s#0@@161|))))))))
 :qid |totalorderidfyByteOrder.897:22|
 :skolemid |4215|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@457) |s#0@@161|))
))))
(assert  (=> true (forall (($ly@@458 T@U) (|s#0@@162| T@U) ) (!  (=> (and (and (= (type $ly@@458) LayerTypeType) (= (type |s#0@@162|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@162|)) ($Is |s#0@@162| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@162| (|Set#Empty| BoxType))) (|Byte__Order.__default.minimum#canCall| (Lit |s#0@@162|))) (= (Byte__Order.__default.minimumOpt ($LS $ly@@458) (Lit |s#0@@162|)) (ite (|Set#Equal| |s#0@@162| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.minimum StartFuel_Byte_Order._default.minimum (Lit |s#0@@162|)))))))))
 :qid |totalorderidfyByteOrder.897:22|
 :weight 3
 :skolemid |4216|
 :pattern ( (Byte__Order.__default.minimumOpt ($LS $ly@@458) (Lit |s#0@@162|)))
))))
(assert (forall (($ly@@459 T@U) (|s#0@@163| T@U) ) (!  (=> (and (= (type $ly@@459) LayerTypeType) (= (type |s#0@@163|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximum ($LS $ly@@459) |s#0@@163|) (Byte__Order.__default.maximum $ly@@459 |s#0@@163|)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |4217|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@459) |s#0@@163|))
)))
(assert (forall (($ly@@460 T@U) (|s#0@@164| T@U) ) (!  (=> (and (= (type $ly@@460) LayerTypeType) (= (type |s#0@@164|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximum $ly@@460 |s#0@@164|) (Byte__Order.__default.maximum $LZ |s#0@@164|)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |4218|
 :pattern ( (Byte__Order.__default.maximum (AsFuelBottom $ly@@460) |s#0@@164|))
)))
(assert  (=> true (forall (($ly@@461 T@U) (|s#0@@165| T@U) ) (!  (=> (and (and (= (type $ly@@461) LayerTypeType) (= (type |s#0@@165|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| |s#0@@165|) (and ($Is |s#0@@165| (TSet Tclass.NativeTypes.byte)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@165|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@165| ($Box (int_2_U (Byte__Order.__default.maximum $ly@@461 |s#0@@165|))))) (forall ((|y#0@@5| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@5|) (INTERNAL_lt_boogie |y#0@@5| 256)) (U_2_bool (MapType0Select |s#0@@165| ($Box (int_2_U |y#0@@5|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@5| (Byte__Order.__default.maximum $ly@@461 |s#0@@165|)))
 :qid |totalorderidfyByteOrder.908:18|
 :skolemid |4219|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@5| (Byte__Order.__default.maximum $ly@@461 |s#0@@165|)))
 :pattern ( (MapType0Select |s#0@@165| ($Box (int_2_U |y#0@@5|))))
))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.maximum $ly@@461 |s#0@@165|)) (INTERNAL_lt_boogie (Byte__Order.__default.maximum $ly@@461 |s#0@@165|) 256))))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |4220|
 :pattern ( (Byte__Order.__default.maximum $ly@@461 |s#0@@165|))
))))
(assert (forall (($ly@@462 T@U) ($Heap@@66 T@U) (|s#0@@166| T@U) ) (!  (=> (and (and (and (= (type $ly@@462) LayerTypeType) (= (type $Heap@@66) (MapType0Type refType MapType1Type))) (= (type |s#0@@166|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@66) ($Is |s#0@@166| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.maximum#requires| $ly@@462 |s#0@@166|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@166|) 1)))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |4221|
 :pattern ( (|Byte__Order.__default.maximum#requires| $ly@@462 |s#0@@166|) ($IsGoodHeap $Heap@@66))
)))
(assert (forall ((s@@52 T@U) ) (!  (=> (and (= (type s@@52) (MapType0Type BoxType boolType)) (|$let#22$canCall| s@@52)) (and (and (INTERNAL_le_boogie 0 (|$let#22_a| s@@52)) (INTERNAL_lt_boogie (|$let#22_a| s@@52) 256)) (U_2_bool (MapType0Select s@@52 ($Box (int_2_U (|$let#22_a| s@@52)))))))
 :qid |totalorderidfyByteOrder.911:5|
 :skolemid |4222|
 :pattern ( (|$let#22_a| s@@52))
)))
(assert  (=> true (forall (($ly@@463 T@U) ($Heap@@67 T@U) (|s#0@@167| T@U) ) (!  (=> (and (and (and (= (type $ly@@463) LayerTypeType) (= (type $Heap@@67) (MapType0Type refType MapType1Type))) (= (type |s#0@@167|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| |s#0@@167|) (and (and ($IsGoodHeap $Heap@@67) ($Is |s#0@@167| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@167|) 1)))) (and (and (|$let#22$canCall| |s#0@@167|) (let ((|s'#1@@0| (|Set#Difference| |s#0@@167| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#22_a| |s#0@@167|)))))))
 (=> (not (|Set#Equal| |s'#1@@0| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.maximum#canCall| |s'#1@@0|) (let ((|m'#1@@2| (Byte__Order.__default.maximum $ly@@463 |s'#1@@0|)))
(|Byte__Order.__default.lt#canCall| |m'#1@@2| (|$let#22_a| |s#0@@167|))))))) (= (Byte__Order.__default.maximum ($LS $ly@@463) |s#0@@167|) (let ((|a#0@@130| (|$let#22_a| |s#0@@167|)))
(let ((|s'#0@@0| (|Set#Difference| |s#0@@167| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#0@@130|))))))
(ite (|Set#Equal| |s'#0@@0| (|Set#Empty| BoxType)) |a#0@@130| (let ((|m'#0@@11| (Byte__Order.__default.maximum $ly@@463 |s'#0@@0|)))
(ite (Byte__Order.__default.lt |m'#0@@11| |a#0@@130|) |a#0@@130| |m'#0@@11|))))))))
 :qid |totalorderidfyByteOrder.905:22|
 :skolemid |4223|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@463) |s#0@@167|) ($IsGoodHeap $Heap@@67))
))))
(assert  (=> true (forall (($ly@@464 T@U) ($Heap@@68 T@U) (|s#0@@168| T@U) ) (!  (=> (and (and (and (= (type $ly@@464) LayerTypeType) (= (type $Heap@@68) (MapType0Type refType MapType1Type))) (= (type |s#0@@168|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximum#canCall| (Lit |s#0@@168|)) (and (and ($IsGoodHeap $Heap@@68) ($Is |s#0@@168| (TSet Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@168|)) 1)))) (and (and (|$let#22$canCall| (Lit |s#0@@168|)) (let ((|s'#3@@0| (|Set#Difference| |s#0@@168| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#22_a| (Lit |s#0@@168|))))))))
 (=> (not (|Set#Equal| |s'#3@@0| (|Set#Empty| BoxType))) (and (|Byte__Order.__default.maximum#canCall| |s'#3@@0|) (let ((|m'#3@@0| (Byte__Order.__default.maximum ($LS $ly@@464) |s'#3@@0|)))
(|Byte__Order.__default.lt#canCall| |m'#3@@0| (|$let#22_a| (Lit |s#0@@168|)))))))) (= (Byte__Order.__default.maximum ($LS $ly@@464) (Lit |s#0@@168|)) (let ((|a#1@@1| (|$let#22_a| (Lit |s#0@@168|))))
(let ((|s'#2@@0| (|Set#Difference| |s#0@@168| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |a#1@@1|))))))
(ite (|Set#Equal| |s'#2@@0| (|Set#Empty| BoxType)) |a#1@@1| (let ((|m'#2@@1| (Byte__Order.__default.maximum ($LS $ly@@464) |s'#2@@0|)))
(ite (Byte__Order.__default.lt |m'#2@@1| |a#1@@1|) |a#1@@1| |m'#2@@1|))))))))
 :qid |totalorderidfyByteOrder.905:22|
 :weight 3
 :skolemid |4224|
 :pattern ( (Byte__Order.__default.maximum ($LS $ly@@464) (Lit |s#0@@168|)) ($IsGoodHeap $Heap@@68))
))))
(assert (forall ((arg0@@607 T@U) (arg1@@311 T@U) ) (! (= (type (Byte__Order.__default.maximumOpt arg0@@607 arg1@@311)) DatatypeTypeType)
 :qid |funType:Byte__Order.__default.maximumOpt|
 :pattern ( (Byte__Order.__default.maximumOpt arg0@@607 arg1@@311))
)))
(assert (forall (($ly@@465 T@U) (|s#0@@169| T@U) ) (!  (=> (and (= (type $ly@@465) LayerTypeType) (= (type |s#0@@169|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximumOpt ($LS $ly@@465) |s#0@@169|) (Byte__Order.__default.maximumOpt $ly@@465 |s#0@@169|)))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |4225|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@465) |s#0@@169|))
)))
(assert (forall (($ly@@466 T@U) (|s#0@@170| T@U) ) (!  (=> (and (= (type $ly@@466) LayerTypeType) (= (type |s#0@@170|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.maximumOpt $ly@@466 |s#0@@170|) (Byte__Order.__default.maximumOpt $LZ |s#0@@170|)))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |4226|
 :pattern ( (Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@466) |s#0@@170|))
)))
(assert  (=> true (forall (($ly@@467 T@U) (|s#0@@171| T@U) ) (!  (=> (and (and (= (type $ly@@467) LayerTypeType) (= (type |s#0@@171|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| |s#0@@171|) ($Is |s#0@@171| (TSet Tclass.NativeTypes.byte)))) (and (and (and (=> (Options.Option.Some_q (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|)) (U_2_bool (MapType0Select |s#0@@171| (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|))))) (=> (Options.Option.Some_q (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|)) (forall ((|y#0@@6| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |y#0@@6|) (INTERNAL_lt_boogie |y#0@@6| 256)) (U_2_bool (MapType0Select |s#0@@171| ($Box (int_2_U |y#0@@6|))))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@6| (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|))))))
 :qid |totalorderidfyByteOrder.929:30|
 :skolemid |4227|
 :pattern ( (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |y#0@@6| (U_2_int ($Unbox intType (Options.Option.value (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|))))))
 :pattern ( (MapType0Select |s#0@@171| ($Box (int_2_U |y#0@@6|))))
)))) (=> (Options.Option.None_q (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|)) (|Set#Equal| |s#0@@171| (|Set#Empty| BoxType)))) ($Is (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|) (Tclass.Options.Option Tclass.NativeTypes.byte))))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |4228|
 :pattern ( (Byte__Order.__default.maximumOpt $ly@@467 |s#0@@171|))
))))
(assert (forall (($ly@@468 T@U) (|s#0@@172| T@U) ) (!  (=> (and (and (= (type $ly@@468) LayerTypeType) (= (type |s#0@@172|) (MapType0Type BoxType boolType))) ($Is |s#0@@172| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.maximumOpt#requires| $ly@@468 |s#0@@172|) true))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |4229|
 :pattern ( (|Byte__Order.__default.maximumOpt#requires| $ly@@468 |s#0@@172|))
)))
(assert (= (type StartFuel_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@469 T@U) (|s#0@@173| T@U) ) (!  (=> (and (and (= (type $ly@@469) LayerTypeType) (= (type |s#0@@173|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| |s#0@@173|) ($Is |s#0@@173| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@173| (|Set#Empty| BoxType))) (|Byte__Order.__default.maximum#canCall| |s#0@@173|)) (= (Byte__Order.__default.maximumOpt ($LS $ly@@469) |s#0@@173|) (ite (|Set#Equal| |s#0@@173| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.maximum StartFuel_Byte_Order._default.maximum |s#0@@173|))))))))
 :qid |totalorderidfyByteOrder.927:22|
 :skolemid |4230|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@469) |s#0@@173|))
))))
(assert  (=> true (forall (($ly@@470 T@U) (|s#0@@174| T@U) ) (!  (=> (and (and (= (type $ly@@470) LayerTypeType) (= (type |s#0@@174|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@174|)) ($Is |s#0@@174| (TSet Tclass.NativeTypes.byte)))) (and (=> (not (|Set#Equal| |s#0@@174| (|Set#Empty| BoxType))) (|Byte__Order.__default.maximum#canCall| (Lit |s#0@@174|))) (= (Byte__Order.__default.maximumOpt ($LS $ly@@470) (Lit |s#0@@174|)) (ite (|Set#Equal| |s#0@@174| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (int_2_U (Byte__Order.__default.maximum StartFuel_Byte_Order._default.maximum (Lit |s#0@@174|)))))))))
 :qid |totalorderidfyByteOrder.927:22|
 :weight 3
 :skolemid |4231|
 :pattern ( (Byte__Order.__default.maximumOpt ($LS $ly@@470) (Lit |s#0@@174|)))
))))
(assert  (=> true (forall ((|a#0@@131| Int) (|b#0@@83| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| |a#0@@131| |b#0@@83|) (and (and (INTERNAL_le_boogie 0 |a#0@@131|) (INTERNAL_lt_boogie |a#0@@131| 256)) (and (INTERNAL_le_boogie 0 |b#0@@83|) (INTERNAL_lt_boogie |b#0@@83| 256)))) true)
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |4232|
 :pattern ( (Byte__Order.__default.lt |a#0@@131| |b#0@@83|))
))))
(assert (forall ((|a#0@@132| Int) (|b#0@@84| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@132|) (INTERNAL_lt_boogie |a#0@@132| 256)) (and (INTERNAL_le_boogie 0 |b#0@@84|) (INTERNAL_lt_boogie |b#0@@84| 256))) (= (|Byte__Order.__default.lt#requires| |a#0@@132| |b#0@@84|) true))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |4233|
 :pattern ( (|Byte__Order.__default.lt#requires| |a#0@@132| |b#0@@84|))
)))
(assert  (=> true (forall ((|a#0@@133| Int) (|b#0@@85| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| |a#0@@133| |b#0@@85|) (and (and (INTERNAL_le_boogie 0 |a#0@@133|) (INTERNAL_lt_boogie |a#0@@133| 256)) (and (INTERNAL_le_boogie 0 |b#0@@85|) (INTERNAL_lt_boogie |b#0@@85| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@133| |b#0@@85|) (= (Byte__Order.__default.lt |a#0@@133| |b#0@@85|)  (and (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@133| |b#0@@85|) (not (= |a#0@@133| |b#0@@85|))))))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :skolemid |4234|
 :pattern ( (Byte__Order.__default.lt |a#0@@133| |b#0@@85|))
))))
(assert  (=> true (forall ((|a#0@@134| Int) (|b#0@@86| Int) ) (!  (=> (or (|Byte__Order.__default.lt#canCall| (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (and (and (INTERNAL_le_boogie 0 |a#0@@134|) (INTERNAL_lt_boogie |a#0@@134| 256)) (and (INTERNAL_le_boogie 0 |b#0@@86|) (INTERNAL_lt_boogie |b#0@@86| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (= (Byte__Order.__default.lt (LitInt |a#0@@134|) (LitInt |b#0@@86|))  (and (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@134|) (LitInt |b#0@@86|)) (not (= |a#0@@134| |b#0@@86|))))))
 :qid |totalorderidfyTotalOrderByteOrder.17:16|
 :weight 3
 :skolemid |4235|
 :pattern ( (Byte__Order.__default.lt (LitInt |a#0@@134|) (LitInt |b#0@@86|)))
))))
(assert  (=> true (forall ((|a#0@@135| Int) (|b#0@@87| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| |a#0@@135| |b#0@@87|) (and (and (INTERNAL_le_boogie 0 |a#0@@135|) (INTERNAL_lt_boogie |a#0@@135| 256)) (and (INTERNAL_le_boogie 0 |b#0@@87|) (INTERNAL_lt_boogie |b#0@@87| 256)))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.Min |a#0@@135| |b#0@@87|)) (INTERNAL_lt_boogie (Byte__Order.__default.Min |a#0@@135| |b#0@@87|) 256)))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |4236|
 :pattern ( (Byte__Order.__default.Min |a#0@@135| |b#0@@87|))
))))
(assert (forall ((|a#0@@136| Int) (|b#0@@88| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@136|) (INTERNAL_lt_boogie |a#0@@136| 256)) (and (INTERNAL_le_boogie 0 |b#0@@88|) (INTERNAL_lt_boogie |b#0@@88| 256))) (= (|Byte__Order.__default.Min#requires| |a#0@@136| |b#0@@88|) true))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |4237|
 :pattern ( (|Byte__Order.__default.Min#requires| |a#0@@136| |b#0@@88|))
)))
(assert  (=> true (forall ((|a#0@@137| Int) (|b#0@@89| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| |a#0@@137| |b#0@@89|) (and (and (INTERNAL_le_boogie 0 |a#0@@137|) (INTERNAL_lt_boogie |a#0@@137| 256)) (and (INTERNAL_le_boogie 0 |b#0@@89|) (INTERNAL_lt_boogie |b#0@@89| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@137| |b#0@@89|) (= (Byte__Order.__default.Min |a#0@@137| |b#0@@89|) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@137| |b#0@@89|) |a#0@@137| |b#0@@89|))))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :skolemid |4238|
 :pattern ( (Byte__Order.__default.Min |a#0@@137| |b#0@@89|))
))))
(assert  (=> true (forall ((|a#0@@138| Int) (|b#0@@90| Int) ) (!  (=> (or (|Byte__Order.__default.Min#canCall| (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (and (and (INTERNAL_le_boogie 0 |a#0@@138|) (INTERNAL_lt_boogie |a#0@@138| 256)) (and (INTERNAL_le_boogie 0 |b#0@@90|) (INTERNAL_lt_boogie |b#0@@90| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (= (Byte__Order.__default.Min (LitInt |a#0@@138|) (LitInt |b#0@@90|)) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@138|) (LitInt |b#0@@90|)) |a#0@@138| |b#0@@90|))))
 :qid |totalorderidfyTotalOrderByteOrder.44:16|
 :weight 3
 :skolemid |4239|
 :pattern ( (Byte__Order.__default.Min (LitInt |a#0@@138|) (LitInt |b#0@@90|)))
))))
(assert  (=> true (forall ((|a#0@@139| Int) (|b#0@@91| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| |a#0@@139| |b#0@@91|) (and (and (INTERNAL_le_boogie 0 |a#0@@139|) (INTERNAL_lt_boogie |a#0@@139| 256)) (and (INTERNAL_le_boogie 0 |b#0@@91|) (INTERNAL_lt_boogie |b#0@@91| 256)))) (and (INTERNAL_le_boogie 0 (Byte__Order.__default.Max |a#0@@139| |b#0@@91|)) (INTERNAL_lt_boogie (Byte__Order.__default.Max |a#0@@139| |b#0@@91|) 256)))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |4240|
 :pattern ( (Byte__Order.__default.Max |a#0@@139| |b#0@@91|))
))))
(assert (forall ((|a#0@@140| Int) (|b#0@@92| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |a#0@@140|) (INTERNAL_lt_boogie |a#0@@140| 256)) (and (INTERNAL_le_boogie 0 |b#0@@92|) (INTERNAL_lt_boogie |b#0@@92| 256))) (= (|Byte__Order.__default.Max#requires| |a#0@@140| |b#0@@92|) true))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |4241|
 :pattern ( (|Byte__Order.__default.Max#requires| |a#0@@140| |b#0@@92|))
)))
(assert  (=> true (forall ((|a#0@@141| Int) (|b#0@@93| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| |a#0@@141| |b#0@@93|) (and (and (INTERNAL_le_boogie 0 |a#0@@141|) (INTERNAL_lt_boogie |a#0@@141| 256)) (and (INTERNAL_le_boogie 0 |b#0@@93|) (INTERNAL_lt_boogie |b#0@@93| 256)))) (and (|Byte__Order.__default.lte#canCall| |a#0@@141| |b#0@@93|) (= (Byte__Order.__default.Max |a#0@@141| |b#0@@93|) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte |a#0@@141| |b#0@@93|) |b#0@@93| |a#0@@141|))))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :skolemid |4242|
 :pattern ( (Byte__Order.__default.Max |a#0@@141| |b#0@@93|))
))))
(assert  (=> true (forall ((|a#0@@142| Int) (|b#0@@94| Int) ) (!  (=> (or (|Byte__Order.__default.Max#canCall| (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (and (and (INTERNAL_le_boogie 0 |a#0@@142|) (INTERNAL_lt_boogie |a#0@@142| 256)) (and (INTERNAL_le_boogie 0 |b#0@@94|) (INTERNAL_lt_boogie |b#0@@94| 256)))) (and (|Byte__Order.__default.lte#canCall| (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (= (Byte__Order.__default.Max (LitInt |a#0@@142|) (LitInt |b#0@@94|)) (ite (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (LitInt |a#0@@142|) (LitInt |b#0@@94|)) |b#0@@94| |a#0@@142|))))
 :qid |totalorderidfyTotalOrderByteOrder.49:16|
 :weight 3
 :skolemid |4243|
 :pattern ( (Byte__Order.__default.Max (LitInt |a#0@@142|) (LitInt |b#0@@94|)))
))))
(assert (forall (($ly@@471 T@U) (|run#0@@113| T@U) ) (!  (=> (and (= (type $ly@@471) LayerTypeType) (= (type |run#0@@113|) (SeqType BoxType))) (= (Byte__Order.__default.IsSorted ($LS $ly@@471) |run#0@@113|) (Byte__Order.__default.IsSorted $ly@@471 |run#0@@113|)))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |4244|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@471) |run#0@@113|))
)))
(assert (forall (($ly@@472 T@U) (|run#0@@114| T@U) ) (!  (=> (and (= (type $ly@@472) LayerTypeType) (= (type |run#0@@114|) (SeqType BoxType))) (= (Byte__Order.__default.IsSorted $ly@@472 |run#0@@114|) (Byte__Order.__default.IsSorted $LZ |run#0@@114|)))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |4245|
 :pattern ( (Byte__Order.__default.IsSorted (AsFuelBottom $ly@@472) |run#0@@114|))
)))
(assert  (=> true (forall (($ly@@473 T@U) (|run#0@@115| T@U) ) (!  (=> (and (and (= (type $ly@@473) LayerTypeType) (= (type |run#0@@115|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| |run#0@@115|) ($Is |run#0@@115| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| |run#0@@115|) (LitInt 0)) (Byte__Order.__default.IsSorted $ly@@473 |run#0@@115|)) (=> (= (|Seq#Length| |run#0@@115|) (LitInt 1)) (Byte__Order.__default.IsSorted $ly@@473 |run#0@@115|))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |4246|
 :pattern ( (Byte__Order.__default.IsSorted $ly@@473 |run#0@@115|))
))))
(assert (forall (($ly@@474 T@U) (|run#0@@116| T@U) ) (!  (=> (and (and (= (type $ly@@474) LayerTypeType) (= (type |run#0@@116|) (SeqType BoxType))) ($Is |run#0@@116| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsSorted#requires| $ly@@474 |run#0@@116|) true))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |4247|
 :pattern ( (|Byte__Order.__default.IsSorted#requires| $ly@@474 |run#0@@116|))
)))
(assert  (=> true (forall (($ly@@475 T@U) (|run#0@@117| T@U) ) (!  (=> (and (and (= (type $ly@@475) LayerTypeType) (= (type |run#0@@117|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| |run#0@@117|) ($Is |run#0@@117| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#0@@144| Int) (|j#0@@14| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@144|) (=> (INTERNAL_le_boogie |i#0@@144| |j#0@@14|) (=> (INTERNAL_lt_boogie |j#0@@14| (|Seq#Length| |run#0@@117|)) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@144|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@14|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |4249|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@14|)) ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@144|)))
)) (= (Byte__Order.__default.IsSorted ($LS $ly@@475) |run#0@@117|) (forall ((|i#0@@145| Int) (|j#0@@15| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@145|) (INTERNAL_le_boogie |i#0@@145| |j#0@@15|)) (INTERNAL_lt_boogie |j#0@@15| (|Seq#Length| |run#0@@117|))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@145|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@15|))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |4248|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@117| |j#0@@15|)) ($Unbox intType (|Seq#Index| |run#0@@117| |i#0@@145|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :skolemid |4250|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@475) |run#0@@117|))
))))
(assert  (=> true (forall (($ly@@476 T@U) (|run#0@@118| T@U) ) (!  (=> (and (and (= (type $ly@@476) LayerTypeType) (= (type |run#0@@118|) (SeqType BoxType))) (or (|Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@118|)) ($Is |run#0@@118| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#1@@40| Int) (|j#1@@3| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@40|) (=> (INTERNAL_le_boogie |i#1@@40| |j#1@@3|) (=> (INTERNAL_lt_boogie |j#1@@3| (|Seq#Length| (Lit |run#0@@118|))) (|Byte__Order.__default.lte#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |i#1@@40|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |j#1@@3|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |4252|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@118| |j#1@@3|)) ($Unbox intType (|Seq#Index| |run#0@@118| |i#1@@40|)))
)) (= (Byte__Order.__default.IsSorted ($LS $ly@@476) (Lit |run#0@@118|)) (forall ((|i#1@@41| Int) (|j#1@@4| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@41|) (INTERNAL_le_boogie |i#1@@41| |j#1@@4|)) (INTERNAL_lt_boogie |j#1@@4| (|Seq#Length| (Lit |run#0@@118|)))) (Byte__Order.__default.lte StartFuel_Byte_Order._default.lte (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |i#1@@41|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@118|) |j#1@@4|))))))
 :qid |totalorderidfyTotalOrderByteOrder.66:12|
 :skolemid |4251|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@118| |j#1@@4|)) ($Unbox intType (|Seq#Index| |run#0@@118| |i#1@@41|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.62:23|
 :weight 3
 :skolemid |4253|
 :pattern ( (Byte__Order.__default.IsSorted ($LS $ly@@476) (Lit |run#0@@118|)))
))))
(assert  (=> true (forall ((|run#0@@119| T@U) ) (!  (=> (and (= (type |run#0@@119|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@119|) ($Is |run#0@@119| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |4254|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal |run#0@@119|))
))))
(assert (forall ((|run#0@@120| T@U) ) (!  (=> (and (= (type |run#0@@120|) (SeqType BoxType)) ($Is |run#0@@120| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@120|) true))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |4255|
 :pattern ( (|Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@120|))
)))
(assert  (=> true (forall ((|run#0@@121| T@U) ) (!  (=> (and (= (type |run#0@@121|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@121|) ($Is |run#0@@121| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#0@@146| Int) (|j#0@@16| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@146|) (=> (INTERNAL_lt_boogie |i#0@@146| |j#0@@16|) (=> (INTERNAL_lt_boogie |j#0@@16| (|Seq#Length| |run#0@@121|)) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@146|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@16|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |4257|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@16|)) ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@146|)))
)) (= (Byte__Order.__default.IsStrictlySortedInternal |run#0@@121|) (forall ((|i#0@@147| Int) (|j#0@@17| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@147|) (INTERNAL_lt_boogie |i#0@@147| |j#0@@17|)) (INTERNAL_lt_boogie |j#0@@17| (|Seq#Length| |run#0@@121|))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@147|))) (U_2_int ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@17|))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |4256|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@121| |j#0@@17|)) ($Unbox intType (|Seq#Index| |run#0@@121| |i#0@@147|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :skolemid |4258|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal |run#0@@121|))
))))
(assert  (=> true (forall ((|run#0@@122| T@U) ) (!  (=> (and (= (type |run#0@@122|) (SeqType BoxType)) (or (|Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@122|)) ($Is |run#0@@122| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|i#1@@42| Int) (|j#1@@5| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@42|) (=> (INTERNAL_lt_boogie |i#1@@42| |j#1@@5|) (=> (INTERNAL_lt_boogie |j#1@@5| (|Seq#Length| (Lit |run#0@@122|))) (|Byte__Order.__default.lt#canCall| (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |i#1@@42|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |j#1@@5|)))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |4260|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@122| |j#1@@5|)) ($Unbox intType (|Seq#Index| |run#0@@122| |i#1@@42|)))
)) (= (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@122|)) (forall ((|i#1@@43| Int) (|j#1@@6| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@43|) (INTERNAL_lt_boogie |i#1@@43| |j#1@@6|)) (INTERNAL_lt_boogie |j#1@@6| (|Seq#Length| (Lit |run#0@@122|)))) (Byte__Order.__default.lt (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |i#1@@43|))) (U_2_int ($Unbox intType (|Seq#Index| (Lit |run#0@@122|) |j#1@@6|))))))
 :qid |totalorderidfyTotalOrderByteOrder.71:12|
 :skolemid |4259|
 :pattern ( ($Unbox intType (|Seq#Index| |run#0@@122| |j#1@@6|)) ($Unbox intType (|Seq#Index| |run#0@@122| |i#1@@43|)))
)))))
 :qid |totalorderidfyTotalOrderByteOrder.69:38|
 :weight 3
 :skolemid |4261|
 :pattern ( (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@122|)))
))))
(assert (forall (($ly@@477 T@U) (|run#0@@123| T@U) ) (!  (=> (and (= (type $ly@@477) LayerTypeType) (= (type |run#0@@123|) (SeqType BoxType))) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@477) |run#0@@123|) (Byte__Order.__default.IsStrictlySorted $ly@@477 |run#0@@123|)))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |4262|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@477) |run#0@@123|))
)))
(assert (forall (($ly@@478 T@U) (|run#0@@124| T@U) ) (!  (=> (and (= (type $ly@@478) LayerTypeType) (= (type |run#0@@124|) (SeqType BoxType))) (= (Byte__Order.__default.IsStrictlySorted $ly@@478 |run#0@@124|) (Byte__Order.__default.IsStrictlySorted $LZ |run#0@@124|)))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |4263|
 :pattern ( (Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@478) |run#0@@124|))
)))
(assert  (=> true (forall (($ly@@479 T@U) (|run#0@@125| T@U) ) (!  (=> (and (and (= (type $ly@@479) LayerTypeType) (= (type |run#0@@125|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@125|) ($Is |run#0@@125| (TSeq Tclass.NativeTypes.byte)))) (and (and (=> (= (|Seq#Length| |run#0@@125|) (LitInt 0)) (Byte__Order.__default.IsStrictlySorted $ly@@479 |run#0@@125|)) (=> (= (|Seq#Length| |run#0@@125|) (LitInt 1)) (Byte__Order.__default.IsStrictlySorted $ly@@479 |run#0@@125|))) (=> (Byte__Order.__default.IsStrictlySorted $ly@@479 |run#0@@125|) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted |run#0@@125|))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |4264|
 :pattern ( (Byte__Order.__default.IsStrictlySorted $ly@@479 |run#0@@125|))
))))
(assert (forall (($ly@@480 T@U) (|run#0@@126| T@U) ) (!  (=> (and (and (= (type $ly@@480) LayerTypeType) (= (type |run#0@@126|) (SeqType BoxType))) ($Is |run#0@@126| (TSeq Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.IsStrictlySorted#requires| $ly@@480 |run#0@@126|) true))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |4265|
 :pattern ( (|Byte__Order.__default.IsStrictlySorted#requires| $ly@@480 |run#0@@126|))
)))
(assert  (=> true (forall (($ly@@481 T@U) (|run#0@@127| T@U) ) (!  (=> (and (and (= (type $ly@@481) LayerTypeType) (= (type |run#0@@127|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@127|) ($Is |run#0@@127| (TSeq Tclass.NativeTypes.byte)))) (and (|Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@127|) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@481) |run#0@@127|) (let ((|b#0@@95| (Byte__Order.__default.IsStrictlySortedInternal |run#0@@127|)))
(ite |b#0@@95| |b#0@@95| |b#0@@95|)))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :skolemid |4266|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@481) |run#0@@127|))
))))
(assert  (=> true (forall (($ly@@482 T@U) (|run#0@@128| T@U) ) (!  (=> (and (and (= (type $ly@@482) LayerTypeType) (= (type |run#0@@128|) (SeqType BoxType))) (or (|Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@128|)) ($Is |run#0@@128| (TSeq Tclass.NativeTypes.byte)))) (and (|Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@128|)) (= (Byte__Order.__default.IsStrictlySorted ($LS $ly@@482) (Lit |run#0@@128|)) (let ((|b#1@@2| (U_2_bool (Lit (bool_2_U (Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@128|)))))))
(ite |b#1@@2| |b#1@@2| |b#1@@2|)))))
 :qid |totalorderidfyTotalOrderByteOrder.85:23|
 :weight 3
 :skolemid |4267|
 :pattern ( (Byte__Order.__default.IsStrictlySorted ($LS $ly@@482) (Lit |run#0@@128|)))
))))
(assert  (=> true (forall ((|e#0@@5| Int) (|s#0@@175| T@U) ) (!  (=> (and (= (type |s#0@@175|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| |e#0@@5| |s#0@@175|) (and (and (and (INTERNAL_le_boogie 0 |e#0@@5|) (INTERNAL_lt_boogie |e#0@@5| 256)) ($Is |s#0@@175| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@175|))))) true)
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |4268|
 :pattern ( (Byte__Order.__default.BiggestInSet |e#0@@5| |s#0@@175|))
))))
(assert (forall ((|e#0@@6| Int) (|s#0@@176| T@U) ) (!  (=> (= (type |s#0@@176|) (MapType0Type BoxType boolType)) (=> (and (and (INTERNAL_le_boogie 0 |e#0@@6|) (INTERNAL_lt_boogie |e#0@@6| 256)) ($Is |s#0@@176| (TSet Tclass.NativeTypes.byte))) (= (|Byte__Order.__default.BiggestInSet#requires| |e#0@@6| |s#0@@176|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@176|)))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |4269|
 :pattern ( (|Byte__Order.__default.BiggestInSet#requires| |e#0@@6| |s#0@@176|))
)))
(assert  (=> true (forall ((|e#0@@7| Int) (|s#0@@177| T@U) ) (!  (=> (and (= (type |s#0@@177|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| |e#0@@7| |s#0@@177|) (and (and (and (INTERNAL_le_boogie 0 |e#0@@7|) (INTERNAL_lt_boogie |e#0@@7| 256)) ($Is |s#0@@177| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@177|))))) (and (=> (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e#0@@7|)))) (forall ((|e2#0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |e2#0|) (INTERNAL_lt_boogie |e2#0| 256)) (=> (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0|)))) (not (= |e2#0| |e#0@@7|))) (|Byte__Order.__default.lt#canCall| |e2#0| |e#0@@7|)))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |4271|
 :pattern ( (Byte__Order.__default.lt |e2#0| |e#0@@7|))
 :pattern ( (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0|))))
))) (= (Byte__Order.__default.BiggestInSet |e#0@@7| |s#0@@177|)  (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e#0@@7|)))) (forall ((|e2#0@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |e2#0@@0|) (INTERNAL_lt_boogie |e2#0@@0| 256)) (and (U_2_bool (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0@@0|)))) (not (= |e2#0@@0| |e#0@@7|)))) (Byte__Order.__default.lt |e2#0@@0| |e#0@@7|))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |4270|
 :pattern ( (Byte__Order.__default.lt |e2#0@@0| |e#0@@7|))
 :pattern ( (MapType0Select |s#0@@177| ($Box (int_2_U |e2#0@@0|))))
))))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :skolemid |4272|
 :pattern ( (Byte__Order.__default.BiggestInSet |e#0@@7| |s#0@@177|))
))))
(assert  (=> true (forall ((|e#0@@8| Int) (|s#0@@178| T@U) ) (!  (=> (and (= (type |s#0@@178|) (MapType0Type BoxType boolType)) (or (|Byte__Order.__default.BiggestInSet#canCall| (LitInt |e#0@@8|) (Lit |s#0@@178|)) (and (and (and (INTERNAL_le_boogie 0 |e#0@@8|) (INTERNAL_lt_boogie |e#0@@8| 256)) ($Is |s#0@@178| (TSet Tclass.NativeTypes.byte))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@178|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U (LitInt |e#0@@8|))))) (forall ((|e2#1| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |e2#1|) (INTERNAL_lt_boogie |e2#1| 256)) (=> (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U |e2#1|)))) (not (= |e2#1| |e#0@@8|))) (|Byte__Order.__default.lt#canCall| |e2#1| (LitInt |e#0@@8|))))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |4274|
 :pattern ( (Byte__Order.__default.lt |e2#1| |e#0@@8|))
 :pattern ( (MapType0Select |s#0@@178| ($Box (int_2_U |e2#1|))))
))) (= (Byte__Order.__default.BiggestInSet (LitInt |e#0@@8|) (Lit |s#0@@178|))  (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U (LitInt |e#0@@8|))))) (forall ((|e2#1@@0| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |e2#1@@0|) (INTERNAL_lt_boogie |e2#1@@0| 256)) (and (U_2_bool (MapType0Select (Lit |s#0@@178|) ($Box (int_2_U |e2#1@@0|)))) (not (= |e2#1@@0| |e#0@@8|)))) (Byte__Order.__default.lt |e2#1@@0| (LitInt |e#0@@8|)))
 :qid |totalorderidfyTotalOrderByteOrder.208:22|
 :skolemid |4273|
 :pattern ( (Byte__Order.__default.lt |e2#1@@0| |e#0@@8|))
 :pattern ( (MapType0Select |s#0@@178| ($Box (int_2_U |e2#1@@0|))))
))))))
 :qid |totalorderidfyTotalOrderByteOrder.205:26|
 :weight 3
 :skolemid |4275|
 :pattern ( (Byte__Order.__default.BiggestInSet (LitInt |e#0@@8|) (Lit |s#0@@178|)))
))))
(assert (forall ((arg0@@608 T@U) (arg1@@312 T@U) ) (! (= (type (Byte__Order.__default.SortSet arg0@@608 arg1@@312)) (SeqType BoxType))
 :qid |funType:Byte__Order.__default.SortSet|
 :pattern ( (Byte__Order.__default.SortSet arg0@@608 arg1@@312))
)))
(assert (forall (($ly@@483 T@U) (|s#0@@179| T@U) ) (!  (=> (and (= (type $ly@@483) LayerTypeType) (= (type |s#0@@179|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.SortSet ($LS $ly@@483) |s#0@@179|) (Byte__Order.__default.SortSet $ly@@483 |s#0@@179|)))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |4276|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@483) |s#0@@179|))
)))
(assert (forall (($ly@@484 T@U) (|s#0@@180| T@U) ) (!  (=> (and (= (type $ly@@484) LayerTypeType) (= (type |s#0@@180|) (MapType0Type BoxType boolType))) (= (Byte__Order.__default.SortSet $ly@@484 |s#0@@180|) (Byte__Order.__default.SortSet $LZ |s#0@@180|)))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |4277|
 :pattern ( (Byte__Order.__default.SortSet (AsFuelBottom $ly@@484) |s#0@@180|))
)))
(assert  (=> true (forall (($ly@@485 T@U) (|s#0@@181| T@U) ) (!  (=> (and (and (= (type $ly@@485) LayerTypeType) (= (type |s#0@@181|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| |s#0@@181|) ($Is |s#0@@181| (TSet Tclass.NativeTypes.byte)))) (and (and (and (= (|Set#Card| |s#0@@181|) (|Seq#Length| (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|))) (forall ((|t#0@@13| T@U) ) (!  (=> (= (type |t#0@@13|) intType) (=> (and (INTERNAL_le_boogie 0 (U_2_int |t#0@@13|)) (INTERNAL_lt_boogie (U_2_int |t#0@@13|) 256)) (= (U_2_bool (MapType0Select |s#0@@181| ($Box |t#0@@13|))) (|Seq#Contains| (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|) ($Box |t#0@@13|)))))
 :qid |totalorderidfyTotalOrderByteOrder.239:20|
 :skolemid |4278|
 :pattern ( (|Seq#Contains| (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|) ($Box |t#0@@13|)))
 :pattern ( (MapType0Select |s#0@@181| ($Box |t#0@@13|)))
))) (Byte__Order.__default.IsSorted StartFuel_Byte_Order._default.IsSorted (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|))) ($Is (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |4279|
 :pattern ( (Byte__Order.__default.SortSet $ly@@485 |s#0@@181|))
))))
(assert (forall (($ly@@486 T@U) ($Heap@@69 T@U) (|s#0@@182| T@U) ) (!  (=> (and (and (and (= (type $ly@@486) LayerTypeType) (= (type $Heap@@69) (MapType0Type refType MapType1Type))) (= (type |s#0@@182|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@69) ($Is |s#0@@182| (TSet Tclass.NativeTypes.byte)))) (= (|Byte__Order.__default.SortSet#requires| $ly@@486 |s#0@@182|) true))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |4280|
 :pattern ( (|Byte__Order.__default.SortSet#requires| $ly@@486 |s#0@@182|) ($IsGoodHeap $Heap@@69))
)))
(assert (forall ((s@@53 T@U) ) (!  (=> (and (= (type s@@53) (MapType0Type BoxType boolType)) (|$let#25$canCall| s@@53)) (and (and (INTERNAL_le_boogie 0 (|$let#25_e| s@@53)) (INTERNAL_lt_boogie (|$let#25_e| s@@53) 256)) (Byte__Order.__default.BiggestInSet (|$let#25_e| s@@53) s@@53)))
 :qid |totalorderidfyTotalOrderByteOrder.249:7|
 :skolemid |4281|
 :pattern ( (|$let#25_e| s@@53))
)))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@487 T@U) ($Heap@@70 T@U) (|s#0@@183| T@U) ) (!  (=> (and (and (and (= (type $ly@@487) LayerTypeType) (= (type $Heap@@70) (MapType0Type refType MapType1Type))) (= (type |s#0@@183|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| |s#0@@183|) (and ($IsGoodHeap $Heap@@70) ($Is |s#0@@183| (TSet Tclass.NativeTypes.byte))))) (and (=> (not (= (|Set#Card| |s#0@@183|) (LitInt 0))) (and (|$let#25$canCall| |s#0@@183|) (|Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@183| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#25_e| |s#0@@183|)))))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted6) MoreFuel_Byte_Order._default.IsSorted6)) (= (Byte__Order.__default.SortSet ($LS $ly@@487) |s#0@@183|) (ite (= (|Set#Card| |s#0@@183|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@9| (|$let#25_e| |s#0@@183|)))
(|Seq#Append| (Byte__Order.__default.SortSet $ly@@487 (|Set#Difference| |s#0@@183| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#0@@9|))))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U |e#0@@9|))))))))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :skolemid |4282|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@487) |s#0@@183|) ($IsGoodHeap $Heap@@70))
))))
(assert (= (type MoreFuel_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@488 T@U) ($Heap@@71 T@U) (|s#0@@184| T@U) ) (!  (=> (and (and (and (= (type $ly@@488) LayerTypeType) (= (type $Heap@@71) (MapType0Type refType MapType1Type))) (= (type |s#0@@184|) (MapType0Type BoxType boolType))) (or (|Byte__Order.__default.SortSet#canCall| (Lit |s#0@@184|)) (and ($IsGoodHeap $Heap@@71) ($Is |s#0@@184| (TSet Tclass.NativeTypes.byte))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@184|)) (LitInt 0))) (and (|$let#25$canCall| (Lit |s#0@@184|)) (|Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@184| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U (|$let#25_e| (Lit |s#0@@184|))))))))) (and (and (and (= StartFuel_Byte_Order._default.IsSorted ($LS MoreFuel_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Byte_Order._default.IsSorted7) MoreFuel_Byte_Order._default.IsSorted7)) (= (Byte__Order.__default.SortSet ($LS $ly@@488) (Lit |s#0@@184|)) (ite (= (|Set#Card| (Lit |s#0@@184|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@0| (|$let#25_e| (Lit |s#0@@184|))))
(|Seq#Append| (Byte__Order.__default.SortSet ($LS $ly@@488) (|Set#Difference| |s#0@@184| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (int_2_U |e#1@@0|))))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (int_2_U |e#1@@0|))))))))))
 :qid |totalorderidfyTotalOrderByteOrder.237:12|
 :weight 3
 :skolemid |4283|
 :pattern ( (Byte__Order.__default.SortSet ($LS $ly@@488) (Lit |s#0@@184|)) ($IsGoodHeap $Heap@@71))
))))
(assert (= (type Tclass.Lexicographic__Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Lexicographic__Byte__Order.__default) Tagclass.Lexicographic__Byte__Order.__default))
(assert (= (TagFamily Tclass.Lexicographic__Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@166 T@U) ) (!  (=> (and (= (type bx@@166) BoxType) ($IsBox bx@@166 Tclass.Lexicographic__Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@166)) bx@@166) ($Is ($Unbox refType bx@@166) Tclass.Lexicographic__Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |4284|
 :pattern ( ($IsBox bx@@166 Tclass.Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@59 T@U) ) (!  (=> (= (type $o@@59) refType) (= ($Is $o@@59 Tclass.Lexicographic__Byte__Order.__default)  (or (= $o@@59 null) (= (dtype $o@@59) Tclass.Lexicographic__Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |4285|
 :pattern ( ($Is $o@@59 Tclass.Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@60 T@U) ($h@@161 T@U) ) (!  (=> (and (= (type $o@@60) refType) (= (type $h@@161) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@60 Tclass.Lexicographic__Byte__Order.__default $h@@161)  (or (= $o@@60 null) (U_2_bool (MapType1Select (MapType0Select $h@@161 $o@@60) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4286|
 :pattern ( ($IsAlloc $o@@60 Tclass.Lexicographic__Byte__Order.__default $h@@161))
)))
(assert (= (type Lexicographic__Byte__Order.__default.SomeElement) (SeqType BoxType)))
(assert  (=> true (=> true ($Is Lexicographic__Byte__Order.__default.SomeElement (TSeq Tclass.NativeTypes.byte)))))
(assert (= |Lexicographic__Byte__Order.__default.SomeElement#requires| true))
(assert  (=> true (=> true (= Lexicographic__Byte__Order.__default.SomeElement (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (=> true (= Lexicographic__Byte__Order.__default.SomeElement (Lit (|Seq#Empty| BoxType))))))
(assert  (=> true (forall ((|a#0@@143| T@U) (|b#0@@96| T@U) ) (!  (=> (and (and (= (type |a#0@@143|) (SeqType BoxType)) (= (type |b#0@@96|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@143| |b#0@@96|) (and ($Is |a#0@@143| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@96| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (and (= (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|)) (or (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|))) (= (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|))) (or (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|))) (=> (and (Lexicographic__Byte__Order.__default.ltedef |a#0@@143| |b#0@@96|) (Lexicographic__Byte__Order.__default.ltedef |b#0@@96| |a#0@@143|)) (|Seq#Equal| |a#0@@143| |b#0@@96|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |4287|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |a#0@@143| |b#0@@96|))
))))
(assert (forall ((|a#0@@144| T@U) (|b#0@@97| T@U) ) (!  (=> (and (and (= (type |a#0@@144|) (SeqType BoxType)) (= (type |b#0@@97|) (SeqType BoxType))) (and ($Is |a#0@@144| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@97| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.lte#requires| |a#0@@144| |b#0@@97|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |4288|
 :pattern ( (|Lexicographic__Byte__Order.__default.lte#requires| |a#0@@144| |b#0@@97|))
)))
(assert  (=> true (forall ((|a#0@@145| T@U) (|b#0@@98| T@U) ) (!  (=> (and (and (= (type |a#0@@145|) (SeqType BoxType)) (= (type |b#0@@98|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@145| |b#0@@98|) (and ($Is |a#0@@145| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@98| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@145| |b#0@@98|) (= (Lexicographic__Byte__Order.__default.lte |a#0@@145| |b#0@@98|) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@145| |b#0@@98|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :skolemid |4289|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |a#0@@145| |b#0@@98|))
))))
(assert  (=> true (forall ((|a#0@@146| T@U) (|b#0@@99| T@U) ) (!  (=> (and (and (= (type |a#0@@146|) (SeqType BoxType)) (= (type |b#0@@99|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@146|) (Lit |b#0@@99|)) (and ($Is |a#0@@146| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@99| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@146|) (Lit |b#0@@99|)) (= (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.25:17|
 :weight 3
 :skolemid |4290|
 :pattern ( (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@146|) (Lit |b#0@@99|)))
))))
(assert  (=> true (forall ((|a#0@@147| T@U) (|b#0@@100| T@U) ) (!  (=> (and (and (= (type |a#0@@147|) (SeqType BoxType)) (= (type |b#0@@100|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@147| |b#0@@100|) (and ($Is |a#0@@147| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@100| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |4291|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef |a#0@@147| |b#0@@100|))
))))
(assert (forall ((|a#0@@148| T@U) (|b#0@@101| T@U) ) (!  (=> (and (and (= (type |a#0@@148|) (SeqType BoxType)) (= (type |b#0@@101|) (SeqType BoxType))) (and ($Is |a#0@@148| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@101| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@148| |b#0@@101|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |4292|
 :pattern ( (|Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@148| |b#0@@101|))
)))
(assert  (=> true (forall ((|a#0@@149| T@U) (|b#0@@102| T@U) ) (!  (=> (and (and (= (type |a#0@@149|) (SeqType BoxType)) (= (type |b#0@@102|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@149| |b#0@@102|) (and ($Is |a#0@@149| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@102| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| |a#0@@149| |b#0@@102|) (= (Lexicographic__Byte__Order.__default.ltedef |a#0@@149| |b#0@@102|) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte |a#0@@149| |b#0@@102|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :skolemid |4293|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef |a#0@@149| |b#0@@102|))
))))
(assert  (=> true (forall ((|a#0@@150| T@U) (|b#0@@103| T@U) ) (!  (=> (and (and (= (type |a#0@@150|) (SeqType BoxType)) (= (type |b#0@@103|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.ltedef#canCall| (Lit |a#0@@150|) (Lit |b#0@@103|)) (and ($Is |a#0@@150| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@103| (TSeq Tclass.NativeTypes.byte))))) (and (|SeqComparison.__default.lte#canCall| (Lit |a#0@@150|) (Lit |b#0@@103|)) (= (Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@150|) (Lit |b#0@@103|)) (SeqComparison.__default.lte StartFuel_SeqComparison._default.lte (Lit |a#0@@150|) (Lit |b#0@@103|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.23:20|
 :weight 3
 :skolemid |4294|
 :pattern ( (Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@150|) (Lit |b#0@@103|)))
))))
(assert  (=> true (forall ((|b#0@@104| T@U) ) (!  (=> (and (= (type |b#0@@104|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@104|) ($Is |b#0@@104| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfy.1174:31|
 :skolemid |4295|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@104|))
))))
(assert (forall ((|b#0@@105| T@U) ) (!  (=> (and (= (type |b#0@@105|) (SeqType BoxType)) ($Is |b#0@@105| (TSeq Tclass.NativeTypes.byte))) (= (|Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@105|) true))
 :qid |totalorderidfy.1174:31|
 :skolemid |4296|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@105|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType))
(assert  (=> true (forall ((|b#0@@106| T@U) ) (!  (=> (and (= (type |b#0@@106|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@106|) ($Is |b#0@@106| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| |b#0@@106|) (LitInt 0)) (forall ((|a#0@@151| T@U) ) (!  (=> (and (= (type |a#0@@151|) (SeqType BoxType)) ($Is |a#0@@151| (TSeq Tclass.NativeTypes.byte))) (and (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@151|) (=> (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@151|) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@106| |a#0@@151|))))
 :qid |totalorderidfy.1177:16|
 :skolemid |4298|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@151|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@151|))
))) (= (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@106|)  (and (= (|Seq#Length| |b#0@@106|) (LitInt 0)) (forall ((|a#0@@152| T@U) ) (!  (=> (= (type |a#0@@152|) (SeqType BoxType)) (=> (and ($Is |a#0@@152| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@152|)) (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@152|)))
 :qid |totalorderidfy.1177:16|
 :skolemid |4297|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@106| |a#0@@152|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#0@@152|))
))))))
 :qid |totalorderidfy.1174:31|
 :skolemid |4299|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@106|))
))))
(assert  (=> true (forall ((|b#0@@107| T@U) ) (!  (=> (and (= (type |b#0@@107|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (Lit |b#0@@107|)) ($Is |b#0@@107| (TSeq Tclass.NativeTypes.byte)))) (and (=> (= (|Seq#Length| (Lit |b#0@@107|)) (LitInt 0)) (forall ((|a#1@@2| T@U) ) (!  (=> (and (= (type |a#1@@2|) (SeqType BoxType)) ($Is |a#1@@2| (TSeq Tclass.NativeTypes.byte))) (and (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#1@@2|) (=> (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@2|) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |b#0@@107|) |a#1@@2|))))
 :qid |totalorderidfy.1177:16|
 :skolemid |4301|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@107| |a#1@@2|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@2|))
))) (= (Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@107|))  (and (= (|Seq#Length| (Lit |b#0@@107|)) (LitInt 0)) (forall ((|a#1@@3| T@U) ) (!  (=> (= (type |a#1@@3|) (SeqType BoxType)) (=> (and ($Is |a#1@@3| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@3|)) (Lexicographic__Byte__Order.__default.lt (Lit |b#0@@107|) |a#1@@3|)))
 :qid |totalorderidfy.1177:16|
 :skolemid |4300|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@107| |a#1@@3|))
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Lexicographic_Byte_Order._default.NotMinimum |a#1@@3|))
))))))
 :qid |totalorderidfy.1174:31|
 :weight 3
 :skolemid |4302|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@107|)))
))))
(assert (= (type Lexicographic__Byte__Order.__default.GetSmallestElement) (SeqType BoxType)))
(assert  (=> true (=> true (and (Lexicographic__Byte__Order.__default.IsSmallestElement Lexicographic__Byte__Order.__default.GetSmallestElement) ($Is Lexicographic__Byte__Order.__default.GetSmallestElement (TSeq Tclass.NativeTypes.byte))))))
(assert (forall (($Heap@@72 T@U) ) (!  (=> (and (= (type $Heap@@72) (MapType0Type refType MapType1Type)) ($IsGoodHeap $Heap@@72)) (= |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| true))
 :qid |totalorderidfy.1198:12|
 :skolemid |4303|
 :pattern ( |Lexicographic__Byte__Order.__default.GetSmallestElement#requires| ($IsGoodHeap $Heap@@72))
)))
(assert (= (type |$let#28_b|) (SeqType BoxType)))
(assert  (=> |$let#28$canCall| (and ($Is |$let#28_b| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.IsSmallestElement |$let#28_b|))))
(assert  (=> true (forall (($Heap@@73 T@U) ) (!  (=> (and (= (type $Heap@@73) (MapType0Type refType MapType1Type)) (or |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@73))) (and |$let#28$canCall| (= Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#0@@108| |$let#28_b|))
|b#0@@108|))))
 :qid |totalorderidfy.1198:12|
 :skolemid |4304|
 :pattern ( Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@73))
))))
(assert  (=> true (forall (($Heap@@74 T@U) ) (!  (=> (and (= (type $Heap@@74) (MapType0Type refType MapType1Type)) (or |Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@74))) (and |$let#28$canCall| (= Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#1@@3| |$let#28_b|))
|b#1@@3|))))
 :qid |totalorderidfy.1198:12|
 :weight 3
 :skolemid |4305|
 :pattern ( Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@74))
))))
(assert (forall (($ly@@489 T@U) (|run#0@@129| T@U) (|needle#0@@41| T@U) ) (!  (=> (and (and (= (type $ly@@489) LayerTypeType) (= (type |run#0@@129|) (SeqType BoxType))) (= (type |needle#0@@41|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@489) |run#0@@129| |needle#0@@41|) (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@489 |run#0@@129| |needle#0@@41|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |4306|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@489) |run#0@@129| |needle#0@@41|))
)))
(assert (forall (($ly@@490 T@U) (|run#0@@130| T@U) (|needle#0@@42| T@U) ) (!  (=> (and (and (= (type $ly@@490) LayerTypeType) (= (type |run#0@@130|) (SeqType BoxType))) (= (type |needle#0@@42|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@490 |run#0@@130| |needle#0@@42|) (Lexicographic__Byte__Order.__default.LargestLteDefn $LZ |run#0@@130| |needle#0@@42|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |4307|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@490) |run#0@@130| |needle#0@@42|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@491 T@U) (|run#0@@131| T@U) (|needle#0@@43| T@U) ) (!  (=> (and (and (and (= (type $ly@@491) LayerTypeType) (= (type |run#0@@131|) (SeqType BoxType))) (= (type |needle#0@@43|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@131| |needle#0@@43|) (and (and ($Is |run#0@@131| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@43| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@131|)))) true)
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |4308|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@491 |run#0@@131| |needle#0@@43|))
))))
(assert (forall (($ly@@492 T@U) (|run#0@@132| T@U) (|needle#0@@44| T@U) ) (!  (=> (and (and (and (= (type $ly@@492) LayerTypeType) (= (type |run#0@@132|) (SeqType BoxType))) (= (type |needle#0@@44|) (SeqType BoxType))) (and ($Is |run#0@@132| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@44| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@492 |run#0@@132| |needle#0@@44|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@132|)))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |4309|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@492 |run#0@@132| |needle#0@@44|))
)))
(assert  (=> true (forall (($ly@@493 T@U) (|run#0@@133| T@U) (|needle#0@@45| T@U) ) (!  (=> (and (and (and (= (type $ly@@493) LayerTypeType) (= (type |run#0@@133|) (SeqType BoxType))) (= (type |needle#0@@45|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@133| |needle#0@@45|) (and (and ($Is |run#0@@133| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@45| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@133|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@133|) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lt#canCall| |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@133|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@133| (LitInt 1)) |needle#0@@45|))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@493) |run#0@@133| |needle#0@@45|) (ite  (or (= (|Seq#Length| |run#0@@133|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt |needle#0@@45| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@133| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@493 (|Seq#Drop| |run#0@@133| (LitInt 1)) |needle#0@@45|))))))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :skolemid |4310|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@493) |run#0@@133| |needle#0@@45|))
))))
(assert  (=> true (forall (($ly@@494 T@U) (|run#0@@134| T@U) (|needle#0@@46| T@U) ) (!  (=> (and (and (and (= (type $ly@@494) LayerTypeType) (= (type |run#0@@134|) (SeqType BoxType))) (= (type |needle#0@@46|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@134|) (Lit |needle#0@@46|)) (and (and ($Is |run#0@@134| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@46| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@134|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@134|) (LitInt 1))) (Lit |needle#0@@46|)))) (= (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@494) (Lit |run#0@@134|) (Lit |needle#0@@46|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@134|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@46|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@134|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@494) (Lit (|Seq#Drop| (Lit |run#0@@134|) (LitInt 1))) (Lit |needle#0@@46|)))))))
 :qid |totalorderidfyLexicographicByteOrder.333:12|
 :weight 3
 :skolemid |4311|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@494) (Lit |run#0@@134|) (Lit |needle#0@@46|)))
))))
(assert  (=> true (forall ((|run#0@@135| T@U) (|needle#0@@47| T@U) ) (!  (=> (and (and (= (type |run#0@@135|) (SeqType BoxType)) (= (type |needle#0@@47|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@135| |needle#0@@47|) (and (and ($Is |run#0@@135| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@47| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@135|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|) (|Seq#Length| |run#0@@135|))) (forall ((|i#0@@148| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@148|) (INTERNAL_le_boogie |i#0@@148| (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#0@@148|)) |needle#0@@47|)))
 :qid |totalorderidfyLexicographicByteOrder.362:20|
 :skolemid |4312|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#0@@148|)))
))) (forall ((|i#1@@44| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|) |i#1@@44|) (INTERNAL_lt_boogie |i#1@@44| (|Seq#Length| |run#0@@135|))) (Lexicographic__Byte__Order.__default.lt |needle#0@@47| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#1@@44|)))))
 :qid |totalorderidfyLexicographicByteOrder.363:20|
 :skolemid |4313|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| |i#1@@44|)))
))) (=> (|Seq#Contains| |run#0@@135| ($Box |needle#0@@47|)) (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|)) (|Seq#Equal| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@135| (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))) |needle#0@@47|)))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |4314|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte |run#0@@135| |needle#0@@47|))
))))
(assert (forall ((|run#0@@136| T@U) (|needle#0@@48| T@U) ) (!  (=> (and (and (= (type |run#0@@136|) (SeqType BoxType)) (= (type |needle#0@@48|) (SeqType BoxType))) (and ($Is |run#0@@136| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@48| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@136| |needle#0@@48|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@136|)))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |4315|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@136| |needle#0@@48|))
)))
(assert  (=> true (forall ((|run#0@@137| T@U) (|needle#0@@49| T@U) ) (!  (=> (and (and (= (type |run#0@@137|) (SeqType BoxType)) (= (type |needle#0@@49|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@137| |needle#0@@49|) (and (and ($Is |run#0@@137| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@49| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@137|)))) (and (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@137| |needle#0@@49|) (= (Lexicographic__Byte__Order.__default.LargestLte |run#0@@137| |needle#0@@49|) (let ((|out#0@@3| (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@137| |needle#0@@49|)))
|out#0@@3|))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :skolemid |4316|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte |run#0@@137| |needle#0@@49|))
))))
(assert  (=> true (forall ((|run#0@@138| T@U) (|needle#0@@50| T@U) ) (!  (=> (and (and (= (type |run#0@@138|) (SeqType BoxType)) (= (type |needle#0@@50|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@138|) (Lit |needle#0@@50|)) (and (and ($Is |run#0@@138| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@50| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@138|))))) (and (|Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@138|) (Lit |needle#0@@50|)) (= (Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@138|) (Lit |needle#0@@50|)) (let ((|out#1@@2| (LitInt (Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@138|) (Lit |needle#0@@50|)))))
|out#1@@2|))))
 :qid |totalorderidfyLexicographicByteOrder.359:23|
 :weight 3
 :skolemid |4317|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@138|) (Lit |needle#0@@50|)))
))))
(assert (forall (($ly@@495 T@U) (|run#0@@139| T@U) (|needle#0@@51| T@U) ) (!  (=> (and (and (= (type $ly@@495) LayerTypeType) (= (type |run#0@@139|) (SeqType BoxType))) (= (type |needle#0@@51|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@495) |run#0@@139| |needle#0@@51|) (Lexicographic__Byte__Order.__default.LargestLt $ly@@495 |run#0@@139| |needle#0@@51|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |4318|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@495) |run#0@@139| |needle#0@@51|))
)))
(assert (forall (($ly@@496 T@U) (|run#0@@140| T@U) (|needle#0@@52| T@U) ) (!  (=> (and (and (= (type $ly@@496) LayerTypeType) (= (type |run#0@@140|) (SeqType BoxType))) (= (type |needle#0@@52|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.LargestLt $ly@@496 |run#0@@140| |needle#0@@52|) (Lexicographic__Byte__Order.__default.LargestLt $LZ |run#0@@140| |needle#0@@52|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |4319|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt (AsFuelBottom $ly@@496) |run#0@@140| |needle#0@@52|))
)))
(assert  (=> true (forall (($ly@@497 T@U) (|run#0@@141| T@U) (|needle#0@@53| T@U) ) (!  (=> (and (and (and (= (type $ly@@497) LayerTypeType) (= (type |run#0@@141|) (SeqType BoxType))) (= (type |needle#0@@53|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@141| |needle#0@@53|) (and (and ($Is |run#0@@141| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@53| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@141|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|) (|Seq#Length| |run#0@@141|))) (forall ((|i#0@@149| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@149|) (INTERNAL_le_boogie |i#0@@149| (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#0@@149|)) |needle#0@@53|)))
 :qid |totalorderidfyLexicographicByteOrder.461:20|
 :skolemid |4320|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#0@@149|)))
))) (forall ((|i#1@@45| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|) |i#1@@45|) (INTERNAL_lt_boogie |i#1@@45| (|Seq#Length| |run#0@@141|))) (Lexicographic__Byte__Order.__default.lte |needle#0@@53| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#1@@45|)))))
 :qid |totalorderidfyLexicographicByteOrder.462:20|
 :skolemid |4321|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| |i#1@@45|)))
))) (=> (|Seq#Contains| |run#0@@141| ($Box |needle#0@@53|)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|) 1) (|Seq#Length| |run#0@@141|)) (|Seq#Equal| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@141| (INTERNAL_add_boogie (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|) 1))) |needle#0@@53|)))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |4322|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt $ly@@497 |run#0@@141| |needle#0@@53|))
))))
(assert (forall (($ly@@498 T@U) (|run#0@@142| T@U) (|needle#0@@54| T@U) ) (!  (=> (and (and (and (= (type $ly@@498) LayerTypeType) (= (type |run#0@@142|) (SeqType BoxType))) (= (type |needle#0@@54|) (SeqType BoxType))) (and ($Is |run#0@@142| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@54| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@498 |run#0@@142| |needle#0@@54|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@142|)))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |4323|
 :pattern ( (|Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@498 |run#0@@142| |needle#0@@54|))
)))
(assert  (and (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@499 T@U) (|run#0@@143| T@U) (|needle#0@@55| T@U) ) (!  (=> (and (and (and (= (type $ly@@499) LayerTypeType) (= (type |run#0@@143|) (SeqType BoxType))) (= (type |needle#0@@55|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@143| |needle#0@@55|) (and (and ($Is |run#0@@143| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@55| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@143|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@143|) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lte#canCall| |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@143|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@143| (LitInt 1)) |needle#0@@55|))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted0) MoreFuel_Lexicographic_Byte_Order._default.IsSorted0)) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@499) |run#0@@143| |needle#0@@55|) (ite  (or (= (|Seq#Length| |run#0@@143|) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte |needle#0@@55| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@143| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLt $ly@@499 (|Seq#Drop| |run#0@@143| (LitInt 1)) |needle#0@@55|)))))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :skolemid |4324|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@499) |run#0@@143| |needle#0@@55|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@500 T@U) (|run#0@@144| T@U) (|needle#0@@56| T@U) ) (!  (=> (and (and (and (= (type $ly@@500) LayerTypeType) (= (type |run#0@@144|) (SeqType BoxType))) (= (type |needle#0@@56|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@144|) (Lit |needle#0@@56|)) (and (and ($Is |run#0@@144| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@56| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@144|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0)))))) (|Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@144|) (LitInt 1))) (Lit |needle#0@@56|)))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted1) MoreFuel_Lexicographic_Byte_Order._default.IsSorted1)) (= (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@500) (Lit |run#0@@144|) (Lit |needle#0@@56|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@144|)) (LitInt 0)) (Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@56|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@144|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@500) (Lit (|Seq#Drop| (Lit |run#0@@144|) (LitInt 1))) (Lit |needle#0@@56|))))))))
 :qid |totalorderidfyLexicographicByteOrder.458:12|
 :weight 3
 :skolemid |4325|
 :pattern ( (Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@500) (Lit |run#0@@144|) (Lit |needle#0@@56|)))
))))
(assert (forall (($ly@@501 T@U) (|run#0@@145| T@U) (|needle#0@@57| T@U) ) (!  (=> (and (and (= (type $ly@@501) LayerTypeType) (= (type |run#0@@145|) (SeqType BoxType))) (= (type |needle#0@@57|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@501) |run#0@@145| |needle#0@@57|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@501 |run#0@@145| |needle#0@@57|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |4326|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@501) |run#0@@145| |needle#0@@57|))
)))
(assert (forall (($ly@@502 T@U) (|run#0@@146| T@U) (|needle#0@@58| T@U) ) (!  (=> (and (and (= (type $ly@@502) LayerTypeType) (= (type |run#0@@146|) (SeqType BoxType))) (= (type |needle#0@@58|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@502 |run#0@@146| |needle#0@@58|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@146| |needle#0@@58|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |4327|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@502) |run#0@@146| |needle#0@@58|))
)))
(assert  (=> true (forall (($ly@@503 T@U) (|run#0@@147| T@U) (|needle#0@@59| T@U) ) (!  (=> (and (and (and (= (type $ly@@503) LayerTypeType) (= (type |run#0@@147|) (SeqType BoxType))) (= (type |needle#0@@59|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@147| |needle#0@@59|) (and (and ($Is |run#0@@147| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@59| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@147|)))) (and (and (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@503 |run#0@@147| |needle#0@@59|) (|Seq#Length| |run#0@@147|)) (forall ((|i#0@@150| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@150|) (INTERNAL_lt_boogie |i#0@@150| (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@503 |run#0@@147| |needle#0@@59|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#0@@150|)) |needle#0@@59|))
 :qid |totalorderidfyLexicographicByteOrder.495:20|
 :skolemid |4328|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#0@@150|)))
))) (forall ((|i#1@@46| Int) ) (!  (=> (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@503 |run#0@@147| |needle#0@@59|) |i#1@@46|) (INTERNAL_lt_boogie |i#1@@46| (|Seq#Length| |run#0@@147|))) (Lexicographic__Byte__Order.__default.lte |needle#0@@59| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#1@@46|))))
 :qid |totalorderidfyLexicographicByteOrder.496:20|
 :skolemid |4329|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@147| |i#1@@46|)))
))) (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@503 |run#0@@147| |needle#0@@59|))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |4330|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@503 |run#0@@147| |needle#0@@59|))
))))
(assert (forall (($ly@@504 T@U) (|run#0@@148| T@U) (|needle#0@@60| T@U) ) (!  (=> (and (and (and (= (type $ly@@504) LayerTypeType) (= (type |run#0@@148|) (SeqType BoxType))) (= (type |needle#0@@60|) (SeqType BoxType))) (and ($Is |run#0@@148| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@60| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@504 |run#0@@148| |needle#0@@60|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@148|)))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |4331|
 :pattern ( (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@504 |run#0@@148| |needle#0@@60|))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@505 T@U) (|run#0@@149| T@U) (|needle#0@@61| T@U) ) (!  (=> (and (and (and (= (type $ly@@505) LayerTypeType) (= (type |run#0@@149|) (SeqType BoxType))) (= (type |needle#0@@61|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@149| |needle#0@@61|) (and (and ($Is |run#0@@149| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@61| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@149|)))) (and (=> (not (= (|Seq#Length| |run#0@@149|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@149|) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|)) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|)) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@149|) (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@149|) |needle#0@@61|))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted2) MoreFuel_Lexicographic_Byte_Order._default.IsSorted2)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@505) |run#0@@149| |needle#0@@61|) (ite (= (|Seq#Length| |run#0@@149|) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@149|)) |needle#0@@61|) (|Seq#Length| |run#0@@149|) (Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@505 (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@149|) |needle#0@@61|)))))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :skolemid |4332|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@505) |run#0@@149| |needle#0@@61|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@506 T@U) (|run#0@@150| T@U) (|needle#0@@62| T@U) ) (!  (=> (and (and (and (= (type $ly@@506) LayerTypeType) (= (type |run#0@@150|) (SeqType BoxType))) (= (type |needle#0@@62|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@150|) (Lit |needle#0@@62|)) (and (and ($Is |run#0@@150| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@62| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@150|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@150|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)) (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|))) (=> (not (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.lt (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|)))))) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)) (|Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|))) (Lit |needle#0@@62|)))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted3) MoreFuel_Lexicographic_Byte_Order._default.IsSorted3)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@506) (Lit |run#0@@150|) (Lit |needle#0@@62|)) (ite (= (|Seq#Length| (Lit |run#0@@150|)) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lt (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|)))) (Lit |needle#0@@62|)) (|Seq#Length| (Lit |run#0@@150|)) (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@506) (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@150|))) (Lit |needle#0@@62|))))))))
 :qid |totalorderidfyLexicographicByteOrder.492:12|
 :weight 3
 :skolemid |4333|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@506) (Lit |run#0@@150|) (Lit |needle#0@@62|)))
))))
(assert (forall (($ly@@507 T@U) (|s#0@@185| T@U) (|key#0@@101| T@U) (|lo#0@@19| Int) (|hi#0@@13| Int) ) (!  (=> (and (and (= (type $ly@@507) LayerTypeType) (= (type |s#0@@185|) (SeqType BoxType))) (= (type |key#0@@101|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@507) |s#0@@185| |key#0@@101| |lo#0@@19| |hi#0@@13|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@507 |s#0@@185| |key#0@@101| |lo#0@@19| |hi#0@@13|)))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |4334|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@507) |s#0@@185| |key#0@@101| |lo#0@@19| |hi#0@@13|))
)))
(assert (forall (($ly@@508 T@U) (|s#0@@186| T@U) (|key#0@@102| T@U) (|lo#0@@20| Int) (|hi#0@@14| Int) ) (!  (=> (and (and (= (type $ly@@508) LayerTypeType) (= (type |s#0@@186|) (SeqType BoxType))) (= (type |key#0@@102|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@508 |s#0@@186| |key#0@@102| |lo#0@@20| |hi#0@@14|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@186| |key#0@@102| |lo#0@@20| |hi#0@@14|)))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |4335|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@508) |s#0@@186| |key#0@@102| |lo#0@@20| |hi#0@@14|))
)))
(assert  (=> true (forall (($ly@@509 T@U) (|s#0@@187| T@U) (|key#0@@103| T@U) (|lo#0@@21| Int) (|hi#0@@15| Int) ) (!  (=> (and (and (and (= (type $ly@@509) LayerTypeType) (= (type |s#0@@187|) (SeqType BoxType))) (= (type |key#0@@103|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) (and (and ($Is |s#0@@187| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@103| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@21|) (INTERNAL_lt_boogie |lo#0@@21| |hi#0@@15|)) (INTERNAL_le_boogie |hi#0@@15| (INTERNAL_add_boogie (|Seq#Length| |s#0@@187|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@21| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie |lo#0@@21| 1))) |key#0@@103|))) (=> (INTERNAL_le_boogie |hi#0@@15| (|Seq#Length| |s#0@@187|)) (Lexicographic__Byte__Order.__default.lte |key#0@@103| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie |hi#0@@15| 1))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) (|Seq#Length| |s#0@@187|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) 1))) |key#0@@103|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) (|Seq#Length| |s#0@@187|)) (Lexicographic__Byte__Order.__default.lte |key#0@@103| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@187| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|)))))) (and (INTERNAL_le_boogie |lo#0@@21| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|)) (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|) |hi#0@@15|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |4336|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@509 |s#0@@187| |key#0@@103| |lo#0@@21| |hi#0@@15|))
))))
(assert (forall (($ly@@510 T@U) (|s#0@@188| T@U) (|key#0@@104| T@U) (|lo#0@@22| Int) (|hi#0@@16| Int) ) (!  (=> (and (and (and (= (type $ly@@510) LayerTypeType) (= (type |s#0@@188|) (SeqType BoxType))) (= (type |key#0@@104|) (SeqType BoxType))) (and ($Is |s#0@@188| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@104| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@510 |s#0@@188| |key#0@@104| |lo#0@@22| |hi#0@@16|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@22|) (INTERNAL_lt_boogie |lo#0@@22| |hi#0@@16|)) (INTERNAL_le_boogie |hi#0@@16| (INTERNAL_add_boogie (|Seq#Length| |s#0@@188|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@22| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@188| (INTERNAL_sub_boogie |lo#0@@22| 1))) |key#0@@104|))) (=> (INTERNAL_le_boogie |hi#0@@16| (|Seq#Length| |s#0@@188|)) (Lexicographic__Byte__Order.__default.lte |key#0@@104| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@188| (INTERNAL_sub_boogie |hi#0@@16| 1))))))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |4337|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@510 |s#0@@188| |key#0@@104| |lo#0@@22| |hi#0@@16|))
)))
(assert  (=> true (forall (($ly@@511 T@U) (|s#0@@189| T@U) (|key#0@@105| T@U) (|lo#0@@23| Int) (|hi#0@@17| Int) ) (!  (=> (and (and (and (= (type $ly@@511) LayerTypeType) (= (type |s#0@@189|) (SeqType BoxType))) (= (type |key#0@@105|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@105| |lo#0@@23| |hi#0@@17|) (and (and ($Is |s#0@@189| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@105| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@23|) (INTERNAL_lt_boogie |lo#0@@23| |hi#0@@17|)) (INTERNAL_le_boogie |hi#0@@17| (INTERNAL_add_boogie (|Seq#Length| |s#0@@189|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@23| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |lo#0@@23| 1))) |key#0@@105|))) (=> (INTERNAL_le_boogie |hi#0@@17| (|Seq#Length| |s#0@@189|)) (Lexicographic__Byte__Order.__default.lte |key#0@@105| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |hi#0@@17| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@23| 1) |hi#0@@17|) (let ((|mid#0@@3| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@23| |hi#0@@17|) 2)))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@105|) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@105|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@105| |mid#0@@3| |hi#0@@17|))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@3| 1))) |key#0@@105|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@189| |key#0@@105| |lo#0@@23| |mid#0@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@511) |s#0@@189| |key#0@@105| |lo#0@@23| |hi#0@@17|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@23| 1) |hi#0@@17|) (let ((|mid#0@@4| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@23| |hi#0@@17|) 2)))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@189| (INTERNAL_sub_boogie |mid#0@@4| 1))) |key#0@@105|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@511 |s#0@@189| |key#0@@105| |mid#0@@4| |hi#0@@17|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@511 |s#0@@189| |key#0@@105| |lo#0@@23| |mid#0@@4|))) |lo#0@@23|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :skolemid |4338|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@511) |s#0@@189| |key#0@@105| |lo#0@@23| |hi#0@@17|))
))))
(assert  (=> true (forall (($ly@@512 T@U) (|s#0@@190| T@U) (|key#0@@106| T@U) (|lo#0@@24| Int) (|hi#0@@18| Int) ) (!  (=> (and (and (and (= (type $ly@@512) LayerTypeType) (= (type |s#0@@190|) (SeqType BoxType))) (= (type |key#0@@106|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@106| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)) (and (and ($Is |s#0@@190| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@106| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@24|) (INTERNAL_lt_boogie |lo#0@@24| |hi#0@@18|)) (INTERNAL_le_boogie |hi#0@@18| (INTERNAL_add_boogie (|Seq#Length| |s#0@@190|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@24| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |lo#0@@24| 1)))) |key#0@@106|))) (=> (INTERNAL_le_boogie |hi#0@@18| (|Seq#Length| |s#0@@190|)) (Lexicographic__Byte__Order.__default.lte |key#0@@106| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |hi#0@@18| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@24| 1) |hi#0@@18|)))) (let ((|mid#1@@3| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@24| |hi#0@@18|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@106|) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@106|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@106| |mid#1@@3| (LitInt |hi#0@@18|)))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (INTERNAL_sub_boogie |mid#1@@3| 1))) |key#0@@106|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@190| |key#0@@106| (LitInt |lo#0@@24|) |mid#1@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@512) |s#0@@190| |key#0@@106| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@24| 1) |hi#0@@18|) (let ((|mid#1@@4| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@24| |hi#0@@18|) 2))))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@190| (LitInt (INTERNAL_sub_boogie |mid#1@@4| 1)))) |key#0@@106|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@512) |s#0@@190| |key#0@@106| |mid#1@@4| (LitInt |hi#0@@18|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@512) |s#0@@190| |key#0@@106| (LitInt |lo#0@@24|) |mid#1@@4|))) |lo#0@@24|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |4339|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@512) |s#0@@190| |key#0@@106| (LitInt |lo#0@@24|) (LitInt |hi#0@@18|)))
))))
(assert  (=> true (forall (($ly@@513 T@U) (|s#0@@191| T@U) (|key#0@@107| T@U) (|lo#0@@25| Int) (|hi#0@@19| Int) ) (!  (=> (and (and (and (= (type $ly@@513) LayerTypeType) (= (type |s#0@@191|) (SeqType BoxType))) (= (type |key#0@@107|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@107|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)) (and (and ($Is |s#0@@191| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@107| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@25|) (INTERNAL_lt_boogie |lo#0@@25| |hi#0@@19|)) (INTERNAL_le_boogie |hi#0@@19| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@191|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@25| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |lo#0@@25| 1)))) (Lit |key#0@@107|)))) (=> (INTERNAL_le_boogie |hi#0@@19| (|Seq#Length| (Lit |s#0@@191|))) (Lexicographic__Byte__Order.__default.lte (Lit |key#0@@107|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |hi#0@@19| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@25| 1) |hi#0@@19|)))) (let ((|mid#2@@3| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@25| |hi#0@@19|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@107|)) (=> (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@107|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@107|) |mid#2@@3| (LitInt |hi#0@@19|)))) (=> (not (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (INTERNAL_sub_boogie |mid#2@@3| 1))) (Lit |key#0@@107|))) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@191|) (Lit |key#0@@107|) (LitInt |lo#0@@25|) |mid#2@@3|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@513) (Lit |s#0@@191|) (Lit |key#0@@107|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@25| 1) |hi#0@@19|) (let ((|mid#2@@4| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@25| |hi#0@@19|) 2))))
(ite (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@191|) (LitInt (INTERNAL_sub_boogie |mid#2@@4| 1)))) (Lit |key#0@@107|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@513) (Lit |s#0@@191|) (Lit |key#0@@107|) |mid#2@@4| (LitInt |hi#0@@19|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@513) (Lit |s#0@@191|) (Lit |key#0@@107|) (LitInt |lo#0@@25|) |mid#2@@4|))) |lo#0@@25|))))
 :qid |totalorderidfyLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |4340|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@513) (Lit |s#0@@191|) (Lit |key#0@@107|) (LitInt |lo#0@@25|) (LitInt |hi#0@@19|)))
))))
(assert (forall (($ly@@514 T@U) (|s#0@@192| T@U) (|key#0@@108| T@U) ) (!  (=> (and (and (= (type $ly@@514) LayerTypeType) (= (type |s#0@@192|) (SeqType BoxType))) (= (type |key#0@@108|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@514) |s#0@@192| |key#0@@108|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@514 |s#0@@192| |key#0@@108|)))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |4341|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@514) |s#0@@192| |key#0@@108|))
)))
(assert (forall (($ly@@515 T@U) (|s#0@@193| T@U) (|key#0@@109| T@U) ) (!  (=> (and (and (= (type $ly@@515) LayerTypeType) (= (type |s#0@@193|) (SeqType BoxType))) (= (type |key#0@@109|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@515 |s#0@@193| |key#0@@109|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@193| |key#0@@109|)))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |4342|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@515) |s#0@@193| |key#0@@109|))
)))
(assert  (=> true (forall (($ly@@516 T@U) (|s#0@@194| T@U) (|key#0@@110| T@U) ) (!  (=> (and (and (and (= (type $ly@@516) LayerTypeType) (= (type |s#0@@194|) (SeqType BoxType))) (= (type |key#0@@110|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@194| |key#0@@110|) (and ($Is |s#0@@194| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@110| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|) (|Seq#Length| |s#0@@194|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@194| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|) 1))) |key#0@@110|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|) (|Seq#Length| |s#0@@194|)) (Lexicographic__Byte__Order.__default.lte |key#0@@110| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@194| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|)))))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |4343|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@516 |s#0@@194| |key#0@@110|))
))))
(assert (forall (($ly@@517 T@U) (|s#0@@195| T@U) (|key#0@@111| T@U) ) (!  (=> (and (and (and (= (type $ly@@517) LayerTypeType) (= (type |s#0@@195|) (SeqType BoxType))) (= (type |key#0@@111|) (SeqType BoxType))) (and ($Is |s#0@@195| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@111| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@517 |s#0@@195| |key#0@@111|) true))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |4344|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@517 |s#0@@195| |key#0@@111|))
)))
(assert  (=> true (forall (($ly@@518 T@U) (|s#0@@196| T@U) (|key#0@@112| T@U) ) (!  (=> (and (and (and (= (type $ly@@518) LayerTypeType) (= (type |s#0@@196|) (SeqType BoxType))) (= (type |key#0@@112|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@196| |key#0@@112|) (and ($Is |s#0@@196| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@112| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@196| |key#0@@112| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@196|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@518) |s#0@@196| |key#0@@112|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@196| |key#0@@112| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@196|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :skolemid |4345|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@518) |s#0@@196| |key#0@@112|))
))))
(assert  (=> true (forall (($ly@@519 T@U) (|s#0@@197| T@U) (|key#0@@113| T@U) ) (!  (=> (and (and (and (= (type $ly@@519) LayerTypeType) (= (type |s#0@@197|) (SeqType BoxType))) (= (type |key#0@@113|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@197|) (Lit |key#0@@113|)) (and ($Is |s#0@@197| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@113| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@197|) (Lit |key#0@@113|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@197|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@519) (Lit |s#0@@197|) (Lit |key#0@@113|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@197|) (Lit |key#0@@113|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@197|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.574:22|
 :weight 3
 :skolemid |4346|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@519) (Lit |s#0@@197|) (Lit |key#0@@113|)))
))))
(assert (forall (($ly@@520 T@U) (|s#0@@198| T@U) (|key#0@@114| T@U) (|lo#0@@26| Int) ) (!  (=> (and (and (= (type $ly@@520) LayerTypeType) (= (type |s#0@@198|) (SeqType BoxType))) (= (type |key#0@@114|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@520) |s#0@@198| |key#0@@114| |lo#0@@26|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@520 |s#0@@198| |key#0@@114| |lo#0@@26|)))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |4347|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@520) |s#0@@198| |key#0@@114| |lo#0@@26|))
)))
(assert (forall (($ly@@521 T@U) (|s#0@@199| T@U) (|key#0@@115| T@U) (|lo#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@521) LayerTypeType) (= (type |s#0@@199|) (SeqType BoxType))) (= (type |key#0@@115|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@521 |s#0@@199| |key#0@@115| |lo#0@@27|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@199| |key#0@@115| |lo#0@@27|)))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |4348|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@521) |s#0@@199| |key#0@@115| |lo#0@@27|))
)))
(assert  (=> true (forall (($ly@@522 T@U) (|s#0@@200| T@U) (|key#0@@116| T@U) (|lo#0@@28| Int) ) (!  (=> (and (and (and (= (type $ly@@522) LayerTypeType) (= (type |s#0@@200|) (SeqType BoxType))) (= (type |key#0@@116|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@200| |key#0@@116| |lo#0@@28|) (and (and ($Is |s#0@@200| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@116| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@28|) (INTERNAL_le_boogie |lo#0@@28| (|Seq#Length| |s#0@@200|))) (=> (INTERNAL_gt_boogie |lo#0@@28| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (INTERNAL_sub_boogie |lo#0@@28| 1))) |key#0@@116|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@28| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|) (|Seq#Length| |s#0@@200|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|) 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|) 1))) |key#0@@116|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|) (|Seq#Length| |s#0@@200|)) (Lexicographic__Byte__Order.__default.lte |key#0@@116| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@200| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|)))))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |4349|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@522 |s#0@@200| |key#0@@116| |lo#0@@28|))
))))
(assert (forall (($ly@@523 T@U) (|s#0@@201| T@U) (|key#0@@117| T@U) (|lo#0@@29| Int) ) (!  (=> (and (and (and (= (type $ly@@523) LayerTypeType) (= (type |s#0@@201|) (SeqType BoxType))) (= (type |key#0@@117|) (SeqType BoxType))) (and ($Is |s#0@@201| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@117| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@523 |s#0@@201| |key#0@@117| |lo#0@@29|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@29|) (INTERNAL_le_boogie |lo#0@@29| (|Seq#Length| |s#0@@201|))) (=> (INTERNAL_gt_boogie |lo#0@@29| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@201| (INTERNAL_sub_boogie |lo#0@@29| 1))) |key#0@@117|)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |4350|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@523 |s#0@@201| |key#0@@117| |lo#0@@29|))
)))
(assert  (=> true (forall (($ly@@524 T@U) (|s#0@@202| T@U) (|key#0@@118| T@U) (|lo#0@@30| Int) ) (!  (=> (and (and (and (= (type $ly@@524) LayerTypeType) (= (type |s#0@@202|) (SeqType BoxType))) (= (type |key#0@@118|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@202| |key#0@@118| |lo#0@@30|) (and (and ($Is |s#0@@202| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@118| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@30|) (INTERNAL_le_boogie |lo#0@@30| (|Seq#Length| |s#0@@202|))) (=> (INTERNAL_gt_boogie |lo#0@@30| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@202| (INTERNAL_sub_boogie |lo#0@@30| 1))) |key#0@@118|)))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@202| |key#0@@118| |lo#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@202|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@524) |s#0@@202| |key#0@@118| |lo#0@@30|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@202| |key#0@@118| |lo#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@202|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :skolemid |4351|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@524) |s#0@@202| |key#0@@118| |lo#0@@30|))
))))
(assert  (=> true (forall (($ly@@525 T@U) (|s#0@@203| T@U) (|key#0@@119| T@U) (|lo#0@@31| Int) ) (!  (=> (and (and (and (= (type $ly@@525) LayerTypeType) (= (type |s#0@@203|) (SeqType BoxType))) (= (type |key#0@@119|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@203|) (Lit |key#0@@119|) (LitInt |lo#0@@31|)) (and (and ($Is |s#0@@203| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@119| (TSeq Tclass.NativeTypes.byte))) (and (and (INTERNAL_le_boogie 0 |lo#0@@31|) (INTERNAL_le_boogie |lo#0@@31| (|Seq#Length| (Lit |s#0@@203|)))) (=> (INTERNAL_gt_boogie |lo#0@@31| 0) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@203|) (LitInt (INTERNAL_sub_boogie |lo#0@@31| 1)))) (Lit |key#0@@119|))))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@203|) (Lit |key#0@@119|) (LitInt |lo#0@@31|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@203|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@525) (Lit |s#0@@203|) (Lit |key#0@@119|) (LitInt |lo#0@@31|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@203|) (Lit |key#0@@119|) (LitInt |lo#0@@31|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@203|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.582:22|
 :weight 3
 :skolemid |4352|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@525) (Lit |s#0@@203|) (Lit |key#0@@119|) (LitInt |lo#0@@31|)))
))))
(assert (forall (($ly@@526 T@U) (|run#0@@151| T@U) (|needle#0@@63| T@U) ) (!  (=> (and (and (= (type $ly@@526) LayerTypeType) (= (type |run#0@@151|) (SeqType BoxType))) (= (type |needle#0@@63|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@526) |run#0@@151| |needle#0@@63|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@526 |run#0@@151| |needle#0@@63|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |4353|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@526) |run#0@@151| |needle#0@@63|))
)))
(assert (forall (($ly@@527 T@U) (|run#0@@152| T@U) (|needle#0@@64| T@U) ) (!  (=> (and (and (= (type $ly@@527) LayerTypeType) (= (type |run#0@@152|) (SeqType BoxType))) (= (type |needle#0@@64|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@527 |run#0@@152| |needle#0@@64|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@152| |needle#0@@64|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |4354|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@527) |run#0@@152| |needle#0@@64|))
)))
(assert  (=> true (forall (($ly@@528 T@U) (|run#0@@153| T@U) (|needle#0@@65| T@U) ) (!  (=> (and (and (and (= (type $ly@@528) LayerTypeType) (= (type |run#0@@153|) (SeqType BoxType))) (= (type |needle#0@@65|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@153| |needle#0@@65|) (and (and ($Is |run#0@@153| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@65| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@153|)))) (and (and (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@528 |run#0@@153| |needle#0@@65|) (|Seq#Length| |run#0@@153|)) (forall ((|i#0@@151| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@151|) (INTERNAL_lt_boogie |i#0@@151| (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@528 |run#0@@153| |needle#0@@65|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#0@@151|)) |needle#0@@65|))
 :qid |totalorderidfyLexicographicByteOrder.595:20|
 :skolemid |4355|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#0@@151|)))
))) (forall ((|i#1@@47| Int) ) (!  (=> (and (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@528 |run#0@@153| |needle#0@@65|) |i#1@@47|) (INTERNAL_lt_boogie |i#1@@47| (|Seq#Length| |run#0@@153|))) (Lexicographic__Byte__Order.__default.lt |needle#0@@65| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#1@@47|))))
 :qid |totalorderidfyLexicographicByteOrder.596:20|
 :skolemid |4356|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@153| |i#1@@47|)))
))) (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@528 |run#0@@153| |needle#0@@65|))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |4357|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@528 |run#0@@153| |needle#0@@65|))
))))
(assert (forall (($ly@@529 T@U) (|run#0@@154| T@U) (|needle#0@@66| T@U) ) (!  (=> (and (and (and (= (type $ly@@529) LayerTypeType) (= (type |run#0@@154|) (SeqType BoxType))) (= (type |needle#0@@66|) (SeqType BoxType))) (and ($Is |run#0@@154| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@66| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@529 |run#0@@154| |needle#0@@66|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@154|)))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |4358|
 :pattern ( (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@529 |run#0@@154| |needle#0@@66|))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@530 T@U) (|run#0@@155| T@U) (|needle#0@@67| T@U) ) (!  (=> (and (and (and (= (type $ly@@530) LayerTypeType) (= (type |run#0@@155|) (SeqType BoxType))) (= (type |needle#0@@67|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@155| |needle#0@@67|) (and (and ($Is |run#0@@155| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@67| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@155|)))) (and (=> (not (= (|Seq#Length| |run#0@@155|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@155|) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|)) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|)) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) |run#0@@155|) (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@155|) |needle#0@@67|))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted4) MoreFuel_Lexicographic_Byte_Order._default.IsSorted4)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@530) |run#0@@155| |needle#0@@67|) (ite (= (|Seq#Length| |run#0@@155|) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) |run#0@@155|)) |needle#0@@67|) (|Seq#Length| |run#0@@155|) (Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@530 (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) |run#0@@155|) |needle#0@@67|)))))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :skolemid |4359|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@530) |run#0@@155| |needle#0@@67|))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@531 T@U) (|run#0@@156| T@U) (|needle#0@@68| T@U) ) (!  (=> (and (and (and (= (type $ly@@531) LayerTypeType) (= (type |run#0@@156|) (SeqType BoxType))) (= (type |needle#0@@68|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@156|) (Lit |needle#0@@68|)) (and (and ($Is |run#0@@156| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |needle#0@@68| (TSeq Tclass.NativeTypes.byte))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@156|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@156|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|))) (=> (not (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.lte (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|)))))) (and (|Sequences.__default.DropLast#canCall| (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)) (|Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|))) (Lit |needle#0@@68|)))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted5) MoreFuel_Lexicographic_Byte_Order._default.IsSorted5)) (= (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@531) (Lit |run#0@@156|) (Lit |needle#0@@68|)) (ite (= (|Seq#Length| (Lit |run#0@@156|)) (LitInt 0)) 0 (ite (Lexicographic__Byte__Order.__default.lte (Lit ($Unbox (SeqType BoxType) (Sequences.__default.Last (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|)))) (Lit |needle#0@@68|)) (|Seq#Length| (Lit |run#0@@156|)) (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@531) (Lit (Sequences.__default.DropLast (TSeq Tclass.NativeTypes.byte) (Lit |run#0@@156|))) (Lit |needle#0@@68|))))))))
 :qid |totalorderidfyLexicographicByteOrder.592:12|
 :weight 3
 :skolemid |4360|
 :pattern ( (Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@531) (Lit |run#0@@156|) (Lit |needle#0@@68|)))
))))
(assert (forall (($ly@@532 T@U) (|s#0@@204| T@U) (|key#0@@120| T@U) (|lo#0@@32| Int) (|hi#0@@20| Int) ) (!  (=> (and (and (= (type $ly@@532) LayerTypeType) (= (type |s#0@@204|) (SeqType BoxType))) (= (type |key#0@@120|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@532) |s#0@@204| |key#0@@120| |lo#0@@32| |hi#0@@20|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@532 |s#0@@204| |key#0@@120| |lo#0@@32| |hi#0@@20|)))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |4361|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@532) |s#0@@204| |key#0@@120| |lo#0@@32| |hi#0@@20|))
)))
(assert (forall (($ly@@533 T@U) (|s#0@@205| T@U) (|key#0@@121| T@U) (|lo#0@@33| Int) (|hi#0@@21| Int) ) (!  (=> (and (and (= (type $ly@@533) LayerTypeType) (= (type |s#0@@205|) (SeqType BoxType))) (= (type |key#0@@121|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@533 |s#0@@205| |key#0@@121| |lo#0@@33| |hi#0@@21|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@205| |key#0@@121| |lo#0@@33| |hi#0@@21|)))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |4362|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@533) |s#0@@205| |key#0@@121| |lo#0@@33| |hi#0@@21|))
)))
(assert  (=> true (forall (($ly@@534 T@U) (|s#0@@206| T@U) (|key#0@@122| T@U) (|lo#0@@34| Int) (|hi#0@@22| Int) ) (!  (=> (and (and (and (= (type $ly@@534) LayerTypeType) (= (type |s#0@@206|) (SeqType BoxType))) (= (type |key#0@@122|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|) (and (and ($Is |s#0@@206| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@122| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@34|) (INTERNAL_lt_boogie |lo#0@@34| |hi#0@@22|)) (INTERNAL_le_boogie |hi#0@@22| (INTERNAL_add_boogie (|Seq#Length| |s#0@@206|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@34| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie |lo#0@@34| 1))) |key#0@@122|))) (=> (INTERNAL_le_boogie |hi#0@@22| (|Seq#Length| |s#0@@206|)) (Lexicographic__Byte__Order.__default.lt |key#0@@122| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie |hi#0@@22| 1))))))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|) (|Seq#Length| |s#0@@206|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|) 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|) 1))) |key#0@@122|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|) (|Seq#Length| |s#0@@206|)) (Lexicographic__Byte__Order.__default.lt |key#0@@122| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@206| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|)))))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |4363|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@534 |s#0@@206| |key#0@@122| |lo#0@@34| |hi#0@@22|))
))))
(assert (forall (($ly@@535 T@U) (|s#0@@207| T@U) (|key#0@@123| T@U) (|lo#0@@35| Int) (|hi#0@@23| Int) ) (!  (=> (and (and (and (= (type $ly@@535) LayerTypeType) (= (type |s#0@@207|) (SeqType BoxType))) (= (type |key#0@@123|) (SeqType BoxType))) (and ($Is |s#0@@207| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@123| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@535 |s#0@@207| |key#0@@123| |lo#0@@35| |hi#0@@23|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@35|) (INTERNAL_lt_boogie |lo#0@@35| |hi#0@@23|)) (INTERNAL_le_boogie |hi#0@@23| (INTERNAL_add_boogie (|Seq#Length| |s#0@@207|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@35| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@207| (INTERNAL_sub_boogie |lo#0@@35| 1))) |key#0@@123|))) (=> (INTERNAL_le_boogie |hi#0@@23| (|Seq#Length| |s#0@@207|)) (Lexicographic__Byte__Order.__default.lt |key#0@@123| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@207| (INTERNAL_sub_boogie |hi#0@@23| 1))))))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |4364|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@535 |s#0@@207| |key#0@@123| |lo#0@@35| |hi#0@@23|))
)))
(assert  (=> true (forall (($ly@@536 T@U) (|s#0@@208| T@U) (|key#0@@124| T@U) (|lo#0@@36| Int) (|hi#0@@24| Int) ) (!  (=> (and (and (and (= (type $ly@@536) LayerTypeType) (= (type |s#0@@208|) (SeqType BoxType))) (= (type |key#0@@124|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@124| |lo#0@@36| |hi#0@@24|) (and (and ($Is |s#0@@208| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@124| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@36|) (INTERNAL_lt_boogie |lo#0@@36| |hi#0@@24|)) (INTERNAL_le_boogie |hi#0@@24| (INTERNAL_add_boogie (|Seq#Length| |s#0@@208|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@36| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |lo#0@@36| 1))) |key#0@@124|))) (=> (INTERNAL_le_boogie |hi#0@@24| (|Seq#Length| |s#0@@208|)) (Lexicographic__Byte__Order.__default.lt |key#0@@124| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |hi#0@@24| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@36| 1) |hi#0@@24|) (let ((|mid#0@@5| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@36| |hi#0@@24|) 2)))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@124|) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@124|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@124| |mid#0@@5| |hi#0@@24|))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@5| 1))) |key#0@@124|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@208| |key#0@@124| |lo#0@@36| |mid#0@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@536) |s#0@@208| |key#0@@124| |lo#0@@36| |hi#0@@24|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@36| 1) |hi#0@@24|) (let ((|mid#0@@6| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@36| |hi#0@@24|) 2)))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@208| (INTERNAL_sub_boogie |mid#0@@6| 1))) |key#0@@124|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@536 |s#0@@208| |key#0@@124| |mid#0@@6| |hi#0@@24|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@536 |s#0@@208| |key#0@@124| |lo#0@@36| |mid#0@@6|))) |lo#0@@36|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :skolemid |4365|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@536) |s#0@@208| |key#0@@124| |lo#0@@36| |hi#0@@24|))
))))
(assert  (=> true (forall (($ly@@537 T@U) (|s#0@@209| T@U) (|key#0@@125| T@U) (|lo#0@@37| Int) (|hi#0@@25| Int) ) (!  (=> (and (and (and (= (type $ly@@537) LayerTypeType) (= (type |s#0@@209|) (SeqType BoxType))) (= (type |key#0@@125|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@125| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)) (and (and ($Is |s#0@@209| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@125| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@37|) (INTERNAL_lt_boogie |lo#0@@37| |hi#0@@25|)) (INTERNAL_le_boogie |hi#0@@25| (INTERNAL_add_boogie (|Seq#Length| |s#0@@209|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@37| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |lo#0@@37| 1)))) |key#0@@125|))) (=> (INTERNAL_le_boogie |hi#0@@25| (|Seq#Length| |s#0@@209|)) (Lexicographic__Byte__Order.__default.lt |key#0@@125| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |hi#0@@25| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@37| 1) |hi#0@@25|)))) (let ((|mid#1@@5| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@37| |hi#0@@25|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@125|) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@125|) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@125| |mid#1@@5| (LitInt |hi#0@@25|)))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (INTERNAL_sub_boogie |mid#1@@5| 1))) |key#0@@125|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@209| |key#0@@125| (LitInt |lo#0@@37|) |mid#1@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@537) |s#0@@209| |key#0@@125| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@37| 1) |hi#0@@25|) (let ((|mid#1@@6| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@37| |hi#0@@25|) 2))))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@209| (LitInt (INTERNAL_sub_boogie |mid#1@@6| 1)))) |key#0@@125|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@537) |s#0@@209| |key#0@@125| |mid#1@@6| (LitInt |hi#0@@25|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@537) |s#0@@209| |key#0@@125| (LitInt |lo#0@@37|) |mid#1@@6|))) |lo#0@@37|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |4366|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@537) |s#0@@209| |key#0@@125| (LitInt |lo#0@@37|) (LitInt |hi#0@@25|)))
))))
(assert  (=> true (forall (($ly@@538 T@U) (|s#0@@210| T@U) (|key#0@@126| T@U) (|lo#0@@38| Int) (|hi#0@@26| Int) ) (!  (=> (and (and (and (= (type $ly@@538) LayerTypeType) (= (type |s#0@@210|) (SeqType BoxType))) (= (type |key#0@@126|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@126|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)) (and (and ($Is |s#0@@210| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@126| (TSeq Tclass.NativeTypes.byte))) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@38|) (INTERNAL_lt_boogie |lo#0@@38| |hi#0@@26|)) (INTERNAL_le_boogie |hi#0@@26| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@210|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@38| 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |lo#0@@38| 1)))) (Lit |key#0@@126|)))) (=> (INTERNAL_le_boogie |hi#0@@26| (|Seq#Length| (Lit |s#0@@210|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@126|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |hi#0@@26| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@38| 1) |hi#0@@26|)))) (let ((|mid#2@@5| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@38| |hi#0@@26|) 2))))
 (and (and (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@126|)) (=> (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@126|)) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@126|) |mid#2@@5| (LitInt |hi#0@@26|)))) (=> (not (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (INTERNAL_sub_boogie |mid#2@@5| 1))) (Lit |key#0@@126|))) (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@210|) (Lit |key#0@@126|) (LitInt |lo#0@@38|) |mid#2@@5|))))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@538) (Lit |s#0@@210|) (Lit |key#0@@126|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@38| 1) |hi#0@@26|) (let ((|mid#2@@6| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@38| |hi#0@@26|) 2))))
(ite (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |s#0@@210|) (LitInt (INTERNAL_sub_boogie |mid#2@@6| 1)))) (Lit |key#0@@126|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@538) (Lit |s#0@@210|) (Lit |key#0@@126|) |mid#2@@6| (LitInt |hi#0@@26|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@538) (Lit |s#0@@210|) (Lit |key#0@@126|) (LitInt |lo#0@@38|) |mid#2@@6|))) |lo#0@@38|))))
 :qid |totalorderidfyLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |4367|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@538) (Lit |s#0@@210|) (Lit |key#0@@126|) (LitInt |lo#0@@38|) (LitInt |hi#0@@26|)))
))))
(assert (forall (($ly@@539 T@U) (|s#0@@211| T@U) (|key#0@@127| T@U) ) (!  (=> (and (and (= (type $ly@@539) LayerTypeType) (= (type |s#0@@211|) (SeqType BoxType))) (= (type |key#0@@127|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@539) |s#0@@211| |key#0@@127|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@539 |s#0@@211| |key#0@@127|)))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |4368|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@539) |s#0@@211| |key#0@@127|))
)))
(assert (forall (($ly@@540 T@U) (|s#0@@212| T@U) (|key#0@@128| T@U) ) (!  (=> (and (and (= (type $ly@@540) LayerTypeType) (= (type |s#0@@212|) (SeqType BoxType))) (= (type |key#0@@128|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@540 |s#0@@212| |key#0@@128|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@212| |key#0@@128|)))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |4369|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@540) |s#0@@212| |key#0@@128|))
)))
(assert  (=> true (forall (($ly@@541 T@U) (|s#0@@213| T@U) (|key#0@@129| T@U) ) (!  (=> (and (and (and (= (type $ly@@541) LayerTypeType) (= (type |s#0@@213|) (SeqType BoxType))) (= (type |key#0@@129|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@213| |key#0@@129|) (and ($Is |s#0@@213| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@129| (TSeq Tclass.NativeTypes.byte))))) (and (and (and (INTERNAL_le_boogie 0 (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|)) (INTERNAL_le_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|) (|Seq#Length| |s#0@@213|))) (=> (INTERNAL_gt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|) 0) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@213| (INTERNAL_sub_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|) 1))) |key#0@@129|))) (=> (INTERNAL_lt_boogie (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|) (|Seq#Length| |s#0@@213|)) (Lexicographic__Byte__Order.__default.lt |key#0@@129| ($Unbox (SeqType BoxType) (|Seq#Index| |s#0@@213| (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|)))))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |4370|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@541 |s#0@@213| |key#0@@129|))
))))
(assert (forall (($ly@@542 T@U) (|s#0@@214| T@U) (|key#0@@130| T@U) ) (!  (=> (and (and (and (= (type $ly@@542) LayerTypeType) (= (type |s#0@@214|) (SeqType BoxType))) (= (type |key#0@@130|) (SeqType BoxType))) (and ($Is |s#0@@214| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@130| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@542 |s#0@@214| |key#0@@130|) true))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |4371|
 :pattern ( (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@542 |s#0@@214| |key#0@@130|))
)))
(assert  (=> true (forall (($ly@@543 T@U) (|s#0@@215| T@U) (|key#0@@131| T@U) ) (!  (=> (and (and (and (= (type $ly@@543) LayerTypeType) (= (type |s#0@@215|) (SeqType BoxType))) (= (type |key#0@@131|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@215| |key#0@@131|) (and ($Is |s#0@@215| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@131| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@215| |key#0@@131| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@215|) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@543) |s#0@@215| |key#0@@131|) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@215| |key#0@@131| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@215|) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :skolemid |4372|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@543) |s#0@@215| |key#0@@131|))
))))
(assert  (=> true (forall (($ly@@544 T@U) (|s#0@@216| T@U) (|key#0@@132| T@U) ) (!  (=> (and (and (and (= (type $ly@@544) LayerTypeType) (= (type |s#0@@216|) (SeqType BoxType))) (= (type |key#0@@132|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@216|) (Lit |key#0@@132|)) (and ($Is |s#0@@216| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@132| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@216|) (Lit |key#0@@132|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@216|)) 1)) (= (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@544) (Lit |s#0@@216|) (Lit |key#0@@132|)) (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@216|) (Lit |key#0@@132|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@216|)) 1)))))
 :qid |totalorderidfyLexicographicByteOrder.644:22|
 :weight 3
 :skolemid |4373|
 :pattern ( (Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@544) (Lit |s#0@@216|) (Lit |key#0@@132|)))
))))
(assert  (=> true (forall ((|a#0@@153| T@U) (|b#0@@109| T@U) ) (!  (=> (and (and (= (type |a#0@@153|) (MapType0Type BoxType boolType)) (= (type |b#0@@109|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@153| |b#0@@109|) (and ($Is |a#0@@153| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@109| (TSet (TSeq Tclass.NativeTypes.byte)))))) true)
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |4374|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@153| |b#0@@109|))
))))
(assert (forall ((|a#0@@154| T@U) (|b#0@@110| T@U) ) (!  (=> (and (and (= (type |a#0@@154|) (MapType0Type BoxType boolType)) (= (type |b#0@@110|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@154| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@110| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@154| |b#0@@110|) true))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |4375|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@154| |b#0@@110|))
)))
(assert  (=> true (forall ((|a#0@@155| T@U) (|b#0@@111| T@U) ) (!  (=> (and (and (= (type |a#0@@155|) (MapType0Type BoxType boolType)) (= (type |b#0@@111|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@155| |b#0@@111|) (and ($Is |a#0@@155| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@111| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#0@@6| T@U) (|y#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@6|) (SeqType BoxType)) (= (type |y#0@@7|) (SeqType BoxType))) (and ($Is |x#0@@6| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@7| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select |a#0@@155| ($Box |x#0@@6|)))) (U_2_bool (MapType0Select |b#0@@111| ($Box |y#0@@7|)))) (|Lexicographic__Byte__Order.__default.lte#canCall| |x#0@@6| |y#0@@7|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |4377|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#0@@6| |y#0@@7|))
 :pattern ( (MapType0Select |b#0@@111| ($Box |y#0@@7|)) (MapType0Select |a#0@@155| ($Box |x#0@@6|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@155| |b#0@@111|) (forall ((|x#0@@7| T@U) (|y#0@@8| T@U) ) (!  (=> (and (and (and (= (type |x#0@@7|) (SeqType BoxType)) (= (type |y#0@@8|) (SeqType BoxType))) (and ($Is |x#0@@7| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@8| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select |a#0@@155| ($Box |x#0@@7|))) (U_2_bool (MapType0Select |b#0@@111| ($Box |y#0@@8|))))) (Lexicographic__Byte__Order.__default.lte |x#0@@7| |y#0@@8|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |4376|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#0@@7| |y#0@@8|))
 :pattern ( (MapType0Select |b#0@@111| ($Box |y#0@@8|)) (MapType0Select |a#0@@155| ($Box |x#0@@7|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :skolemid |4378|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte |a#0@@155| |b#0@@111|))
))))
(assert  (=> true (forall ((|a#0@@156| T@U) (|b#0@@112| T@U) ) (!  (=> (and (and (= (type |a#0@@156|) (MapType0Type BoxType boolType)) (= (type |b#0@@112|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@156|) (Lit |b#0@@112|)) (and ($Is |a#0@@156| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@112| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#1@@3| T@U) (|y#1@@3| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@3|) (SeqType BoxType)) (= (type |y#1@@3|) (SeqType BoxType))) (and ($Is |x#1@@3| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@3| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select (Lit |a#0@@156|) ($Box |x#1@@3|)))) (U_2_bool (MapType0Select (Lit |b#0@@112|) ($Box |y#1@@3|)))) (|Lexicographic__Byte__Order.__default.lte#canCall| |x#1@@3| |y#1@@3|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |4380|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#1@@3| |y#1@@3|))
 :pattern ( (MapType0Select |b#0@@112| ($Box |y#1@@3|)) (MapType0Select |a#0@@156| ($Box |x#1@@3|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@156|) (Lit |b#0@@112|)) (forall ((|x#1@@4| T@U) (|y#1@@4| T@U) ) (!  (=> (and (and (and (= (type |x#1@@4|) (SeqType BoxType)) (= (type |y#1@@4|) (SeqType BoxType))) (and ($Is |x#1@@4| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@4| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select (Lit |a#0@@156|) ($Box |x#1@@4|))) (U_2_bool (MapType0Select (Lit |b#0@@112|) ($Box |y#1@@4|))))) (Lexicographic__Byte__Order.__default.lte |x#1@@4| |y#1@@4|))
 :qid |totalorderidfyLexicographicByteOrder.804:12|
 :skolemid |4379|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |x#1@@4| |y#1@@4|))
 :pattern ( (MapType0Select |b#0@@112| ($Box |y#1@@4|)) (MapType0Select |a#0@@156| ($Box |x#1@@4|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.803:23|
 :weight 3
 :skolemid |4381|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@156|) (Lit |b#0@@112|)))
))))
(assert  (=> true (forall ((|a#0@@157| T@U) (|b#0@@113| T@U) ) (!  (=> (and (and (= (type |a#0@@157|) (MapType0Type BoxType boolType)) (= (type |b#0@@113|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@157| |b#0@@113|) (and ($Is |a#0@@157| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@113| (TSet (TSeq Tclass.NativeTypes.byte)))))) true)
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |4382|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@157| |b#0@@113|))
))))
(assert (forall ((|a#0@@158| T@U) (|b#0@@114| T@U) ) (!  (=> (and (and (= (type |a#0@@158|) (MapType0Type BoxType boolType)) (= (type |b#0@@114|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@158| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@114| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@158| |b#0@@114|) true))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |4383|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@158| |b#0@@114|))
)))
(assert  (=> true (forall ((|a#0@@159| T@U) (|b#0@@115| T@U) ) (!  (=> (and (and (= (type |a#0@@159|) (MapType0Type BoxType boolType)) (= (type |b#0@@115|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@159| |b#0@@115|) (and ($Is |a#0@@159| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@115| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#0@@8| T@U) (|y#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@8|) (SeqType BoxType)) (= (type |y#0@@9|) (SeqType BoxType))) (and ($Is |x#0@@8| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@9| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select |a#0@@159| ($Box |x#0@@8|)))) (U_2_bool (MapType0Select |b#0@@115| ($Box |y#0@@9|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |x#0@@8| |y#0@@9|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |4385|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#0@@8| |y#0@@9|))
 :pattern ( (MapType0Select |b#0@@115| ($Box |y#0@@9|)) (MapType0Select |a#0@@159| ($Box |x#0@@8|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@159| |b#0@@115|) (forall ((|x#0@@9| T@U) (|y#0@@10| T@U) ) (!  (=> (and (and (and (= (type |x#0@@9|) (SeqType BoxType)) (= (type |y#0@@10|) (SeqType BoxType))) (and ($Is |x#0@@9| (TSeq Tclass.NativeTypes.byte)) ($Is |y#0@@10| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select |a#0@@159| ($Box |x#0@@9|))) (U_2_bool (MapType0Select |b#0@@115| ($Box |y#0@@10|))))) (Lexicographic__Byte__Order.__default.lt |x#0@@9| |y#0@@10|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |4384|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#0@@9| |y#0@@10|))
 :pattern ( (MapType0Select |b#0@@115| ($Box |y#0@@10|)) (MapType0Select |a#0@@159| ($Box |x#0@@9|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :skolemid |4386|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt |a#0@@159| |b#0@@115|))
))))
(assert  (=> true (forall ((|a#0@@160| T@U) (|b#0@@116| T@U) ) (!  (=> (and (and (= (type |a#0@@160|) (MapType0Type BoxType boolType)) (= (type |b#0@@116|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@160|) (Lit |b#0@@116|)) (and ($Is |a#0@@160| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |b#0@@116| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (forall ((|x#1@@5| T@U) (|y#1@@5| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@5|) (SeqType BoxType)) (= (type |y#1@@5|) (SeqType BoxType))) (and ($Is |x#1@@5| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@5| (TSeq Tclass.NativeTypes.byte)))) (U_2_bool (MapType0Select (Lit |a#0@@160|) ($Box |x#1@@5|)))) (U_2_bool (MapType0Select (Lit |b#0@@116|) ($Box |y#1@@5|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |x#1@@5| |y#1@@5|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |4388|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#1@@5| |y#1@@5|))
 :pattern ( (MapType0Select |b#0@@116| ($Box |y#1@@5|)) (MapType0Select |a#0@@160| ($Box |x#1@@5|)))
)) (= (Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@160|) (Lit |b#0@@116|)) (forall ((|x#1@@6| T@U) (|y#1@@6| T@U) ) (!  (=> (and (and (and (= (type |x#1@@6|) (SeqType BoxType)) (= (type |y#1@@6|) (SeqType BoxType))) (and ($Is |x#1@@6| (TSeq Tclass.NativeTypes.byte)) ($Is |y#1@@6| (TSeq Tclass.NativeTypes.byte)))) (and (U_2_bool (MapType0Select (Lit |a#0@@160|) ($Box |x#1@@6|))) (U_2_bool (MapType0Select (Lit |b#0@@116|) ($Box |y#1@@6|))))) (Lexicographic__Byte__Order.__default.lt |x#1@@6| |y#1@@6|))
 :qid |totalorderidfyLexicographicByteOrder.808:12|
 :skolemid |4387|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |x#1@@6| |y#1@@6|))
 :pattern ( (MapType0Select |b#0@@116| ($Box |y#1@@6|)) (MapType0Select |a#0@@160| ($Box |x#1@@6|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.807:22|
 :weight 3
 :skolemid |4389|
 :pattern ( (Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@160|) (Lit |b#0@@116|)))
))))
(assert (forall (($ly@@545 T@U) (|a#0@@161| T@U) ) (!  (=> (and (= (type $ly@@545) LayerTypeType) (= (type |a#0@@161|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@545) |a#0@@161|) (Lexicographic__Byte__Order.__default.NotMinimum $ly@@545 |a#0@@161|)))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |4390|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@545) |a#0@@161|))
)))
(assert (forall (($ly@@546 T@U) (|a#0@@162| T@U) ) (!  (=> (and (= (type $ly@@546) LayerTypeType) (= (type |a#0@@162|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.NotMinimum $ly@@546 |a#0@@162|) (Lexicographic__Byte__Order.__default.NotMinimum $LZ |a#0@@162|)))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |4391|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@546) |a#0@@162|))
)))
(assert  (=> true (forall (($ly@@547 T@U) (|a#0@@163| T@U) ) (!  (=> (and (and (= (type $ly@@547) LayerTypeType) (= (type |a#0@@163|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@163|) ($Is |a#0@@163| (TSeq Tclass.NativeTypes.byte)))) true)
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |4392|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum $ly@@547 |a#0@@163|))
))))
(assert (forall (($ly@@548 T@U) (|a#0@@164| T@U) ) (!  (=> (and (and (= (type $ly@@548) LayerTypeType) (= (type |a#0@@164|) (SeqType BoxType))) ($Is |a#0@@164| (TSeq Tclass.NativeTypes.byte))) (= (|Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@548 |a#0@@164|) true))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |4393|
 :pattern ( (|Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@548 |a#0@@164|))
)))
(assert  (=> true (forall (($ly@@549 T@U) (|a#0@@165| T@U) ) (!  (=> (and (and (= (type $ly@@549) LayerTypeType) (= (type |a#0@@165|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@165|) ($Is |a#0@@165| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|b#0@@117| T@U) ) (!  (=> (and (= (type |b#0@@117|) (SeqType BoxType)) ($Is |b#0@@117| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@117| |a#0@@165|))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |4395|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@117| |a#0@@165|))
)) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@549) |a#0@@165|) (exists ((|b#0@@118| T@U) ) (!  (and (= (type |b#0@@118|) (SeqType BoxType)) (and ($Is |b#0@@118| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.lt |b#0@@118| |a#0@@165|)))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |4394|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#0@@118| |a#0@@165|))
)))))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :skolemid |4396|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@549) |a#0@@165|))
))))
(assert  (=> true (forall (($ly@@550 T@U) (|a#0@@166| T@U) ) (!  (=> (and (and (= (type $ly@@550) LayerTypeType) (= (type |a#0@@166|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.NotMinimum#canCall| (Lit |a#0@@166|)) ($Is |a#0@@166| (TSeq Tclass.NativeTypes.byte)))) (and (forall ((|b#1@@4| T@U) ) (!  (=> (and (= (type |b#1@@4|) (SeqType BoxType)) ($Is |b#1@@4| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |b#1@@4| (Lit |a#0@@166|)))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |4398|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#1@@4| |a#0@@166|))
)) (= (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@550) (Lit |a#0@@166|)) (exists ((|b#1@@5| T@U) ) (!  (and (= (type |b#1@@5|) (SeqType BoxType)) (and ($Is |b#1@@5| (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.lt |b#1@@5| (Lit |a#0@@166|))))
 :qid |totalorderidfyLexicographicByteOrder.821:12|
 :skolemid |4397|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |b#1@@5| |a#0@@166|))
)))))
 :qid |totalorderidfyLexicographicByteOrder.820:23|
 :weight 3
 :skolemid |4399|
 :pattern ( (Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@550) (Lit |a#0@@166|)))
))))
(assert (forall ((arg0@@609 T@U) (arg1@@313 T@U) (arg2@@167 T@U) (arg3@@97 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@609 arg1@@313 arg2@@167 arg3@@97)) (MapType BoxType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@609 arg1@@313 arg2@@167 arg3@@97))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0@@3| T@U) (|pivot#0@@3| T@U) (|right#0@@3| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0@@3|) (MapType BoxType BoxType))) (= (type |pivot#0@@3|) (SeqType BoxType))) (= (type |right#0@@3|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|) (and (and ($Is |left#0@@3| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value)) ($Is |pivot#0@@3| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@3| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|) (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |4400|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@3| |pivot#0@@3| |right#0@@3|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@4| T@U) (|pivot#0@@4| T@U) (|right#0@@4| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@4|) (MapType BoxType BoxType))) (= (type |pivot#0@@4|) (SeqType BoxType))) (= (type |right#0@@4|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@4| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)) ($Is |pivot#0@@4| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@4| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@4| |pivot#0@@4| |right#0@@4|) true))
 :qid |unknown.0:0|
 :skolemid |4401|
 :pattern ( (|Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@4| |pivot#0@@4| |right#0@@4|))
)))
(assert  (and (forall ((arg0@@610 T@U) (arg1@@314 T@U) ) (! (= (type (|lambda#299| arg0@@610 arg1@@314)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#299|
 :pattern ( (|lambda#299| arg0@@610 arg1@@314))
)) (forall ((arg0@@611 T@U) (arg1@@315 T@U) ) (! (= (type (|lambda#301| arg0@@611 arg1@@315)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#301|
 :pattern ( (|lambda#301| arg0@@611 arg1@@315))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@5| T@U) (|pivot#0@@5| T@U) (|right#0@@5| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@5|) (MapType BoxType BoxType))) (= (type |pivot#0@@5|) (SeqType BoxType))) (= (type |right#0@@5|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|) (and (and ($Is |left#0@@5| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1)) ($Is |pivot#0@@5| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@5| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@78| T@U) ) (!  (=> (and (= (type |k#0@@78|) (SeqType BoxType)) ($Is |k#0@@78| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |k#0@@78| |pivot#0@@5|))
 :qid |totalorderidfyLexicographicByteOrder.840:57|
 :skolemid |4402|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |k#0@@78| |pivot#0@@5|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#299| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))) (let ((|restricted_left#0@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#299| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
 (and (and (forall ((|k#1@@16| T@U) ) (!  (=> (and (= (type |k#1@@16|) (SeqType BoxType)) ($Is |k#1@@16| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lte#canCall| |pivot#0@@5| |k#1@@16|))
 :qid |totalorderidfyLexicographicByteOrder.841:59|
 :skolemid |4403|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |pivot#0@@5| |k#1@@16|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#301| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))) (let ((|restricted_right#0@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#301| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(|Maps.__default.MapDisjointUnion#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0@@1| |restricted_right#0@@1|))))) (= (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|) (let ((|restricted_left#0@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| (|lambda#299| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(let ((|restricted_right#0@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@5| (|lambda#301| (TSeq Tclass.NativeTypes.byte) |pivot#0@@5|))))
(Maps.__default.MapDisjointUnion (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@2| |restricted_right#0@@2|))))))
 :qid |unknown.0:0|
 :skolemid |4404|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@5| |pivot#0@@5| |right#0@@5|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@6| T@U) (|pivot#0@@6| T@U) (|right#0@@6| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@6|) (MapType BoxType BoxType))) (= (type |pivot#0@@6|) (SeqType BoxType))) (= (type |right#0@@6|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)) (and (and ($Is |left#0@@6| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2)) ($Is |pivot#0@@6| (TSeq Tclass.NativeTypes.byte))) ($Is |right#0@@6| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@7| T@U) ) (!  (=> (and (= (type |k#2@@7|) (SeqType BoxType)) ($Is |k#2@@7| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lt#canCall| |k#2@@7| (Lit |pivot#0@@6|)))
 :qid |totalorderidfyLexicographicByteOrder.840:57|
 :skolemid |4405|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |k#2@@7| |pivot#0@@6|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#299| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))) (let ((|restricted_left#1@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#299| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
 (and (and (forall ((|k#3@@0| T@U) ) (!  (=> (and (= (type |k#3@@0|) (SeqType BoxType)) ($Is |k#3@@0| (TSeq Tclass.NativeTypes.byte))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |pivot#0@@6|) |k#3@@0|))
 :qid |totalorderidfyLexicographicByteOrder.841:59|
 :skolemid |4406|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |pivot#0@@6| |k#3@@0|))
)) (|Maps.__default.MapIRestrict#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#301| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))) (let ((|restricted_right#1@@1| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#301| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(|Maps.__default.MapDisjointUnion#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1@@1| |restricted_right#1@@1|))))) (= (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)) (let ((|restricted_left#1@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (|lambda#299| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(let ((|restricted_right#1@@2| (Maps.__default.MapIRestrict (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@6|) (|lambda#301| (TSeq Tclass.NativeTypes.byte) (Lit |pivot#0@@6|)))))
(Maps.__default.MapDisjointUnion (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@2| |restricted_right#1@@2|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4407|
 :pattern ( (Lexicographic__Byte__Order.__default.MapPivotedUnion Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@6|) (Lit |pivot#0@@6|) (Lit |right#0@@6|)))
))))
(assert (forall ((arg0@@612 T@U) (arg1@@316 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SetSuccessor arg0@@612 arg1@@316)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.SetSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor arg0@@612 arg1@@316))
)))
(assert  (=> true (forall ((|m#0@@128| T@U) (|key#0@@133| T@U) ) (!  (=> (and (and (= (type |m#0@@128|) (MapType0Type BoxType boolType)) (= (type |key#0@@133|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@128| |key#0@@133|) (and ($Is |m#0@@128| (TSet (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@133| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@128| |key#0@@133|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.845:25|
 :skolemid |4408|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@128| |key#0@@133|))
))))
(assert (forall (($Heap@@75 T@U) (|m#0@@129| T@U) (|key#0@@134| T@U) ) (!  (=> (and (and (and (= (type $Heap@@75) (MapType0Type refType MapType1Type)) (= (type |m#0@@129|) (MapType0Type BoxType boolType))) (= (type |key#0@@134|) (SeqType BoxType))) (and (and ($IsGoodHeap $Heap@@75) ($Is |m#0@@129| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@134| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@129| |key#0@@134|) true))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :skolemid |4409|
 :pattern ( (|Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@129| |key#0@@134|) ($IsGoodHeap $Heap@@75))
)))
(assert (forall ((arg0@@613 T@U) (arg1@@317 T@U) ) (! (= (type (|$let#31_next| arg0@@613 arg1@@317)) (SeqType BoxType))
 :qid |funType:$let#31_next|
 :pattern ( (|$let#31_next| arg0@@613 arg1@@317))
)))
(assert (forall ((m@@69 T@U) (key@@0 T@U) ) (!  (=> (and (and (= (type m@@69) (MapType0Type BoxType boolType)) (= (type key@@0) (SeqType BoxType))) (|$let#31$canCall| m@@69 key@@0)) (and ($Is (|$let#31_next| m@@69 key@@0) (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select m@@69 ($Box (|$let#31_next| m@@69 key@@0)))) (Lexicographic__Byte__Order.__default.lt key@@0 (|$let#31_next| m@@69 key@@0))) (forall ((|other#1@@0| T@U) ) (!  (=> (and (= (type |other#1@@0|) (SeqType BoxType)) ($Is |other#1@@0| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select m@@69 ($Box |other#1@@0|))) (not (|Seq#Equal| |other#1@@0| (|$let#31_next| m@@69 key@@0)))) (Lexicographic__Byte__Order.__default.lt key@@0 |other#1@@0|)) (Lexicographic__Byte__Order.__default.lt (|$let#31_next| m@@69 key@@0) |other#1@@0|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4412|
 :pattern ( (Lexicographic__Byte__Order.__default.lt (|$let#31_next| m@@69 key@@0) |other#1@@0|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt key@@0 |other#1@@0|))
 :pattern ( (MapType0Select m@@69 ($Box |other#1@@0|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4413|
 :pattern ( (|$let#31_next| m@@69 key@@0))
)))
(assert  (=> true (forall (($Heap@@76 T@U) (|m#0@@130| T@U) (|key#0@@135| T@U) ) (!  (=> (and (and (and (= (type $Heap@@76) (MapType0Type refType MapType1Type)) (= (type |m#0@@130|) (MapType0Type BoxType boolType))) (= (type |key#0@@135|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@130| |key#0@@135|) (and (and ($IsGoodHeap $Heap@@76) ($Is |m#0@@130| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@135| (TSeq Tclass.NativeTypes.byte))))) (and (and (forall ((|next#0@@2| T@U) ) (!  (=> (and (and (= (type |next#0@@2|) (SeqType BoxType)) ($Is |next#0@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@2|)))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@135| |next#0@@2|) (=> (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@2|) (forall ((|other#0@@14| T@U) ) (!  (=> (and (and (and (= (type |other#0@@14|) (SeqType BoxType)) ($Is |other#0@@14| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@14|)))) (not (|Seq#Equal| |other#0@@14| |next#0@@2|))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@135| |other#0@@14|) (=> (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@14|) (|Lexicographic__Byte__Order.__default.lt#canCall| |next#0@@2| |other#0@@14|))))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4414|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@2| |other#0@@14|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@14|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@14|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4415|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@2|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@2|)))
)) (=> (exists ((|next#0@@3| T@U) ) (!  (and (= (type |next#0@@3|) (SeqType BoxType)) (and ($Is |next#0@@3| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@3|))) (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@3|)) (forall ((|other#0@@15| T@U) ) (!  (=> (and (= (type |other#0@@15|) (SeqType BoxType)) ($Is |other#0@@15| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@15|))) (not (|Seq#Equal| |other#0@@15| |next#0@@3|))) (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@15|)) (Lexicographic__Byte__Order.__default.lt |next#0@@3| |other#0@@15|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4416|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@3| |other#0@@15|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@15|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@15|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4417|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@3|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@3|)))
)) (|$let#31$canCall| |m#0@@130| |key#0@@135|))) (= (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@130| |key#0@@135|) (ite (exists ((|next#0@@4| T@U) ) (!  (and (= (type |next#0@@4|) (SeqType BoxType)) (and ($Is |next#0@@4| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |next#0@@4|))) (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@4|)) (forall ((|other#0@@16| T@U) ) (!  (=> (and (= (type |other#0@@16|) (SeqType BoxType)) ($Is |other#0@@16| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select |m#0@@130| ($Box |other#0@@16|))) (not (|Seq#Equal| |other#0@@16| |next#0@@4|))) (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@16|)) (Lexicographic__Byte__Order.__default.lt |next#0@@4| |other#0@@16|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4410|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#0@@4| |other#0@@16|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |other#0@@16|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |other#0@@16|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4411|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@135| |next#0@@4|))
 :pattern ( (MapType0Select |m#0@@130| ($Box |next#0@@4|)))
)) (let ((|next#1@@0| (|$let#31_next| |m#0@@130| |key#0@@135|)))
(|#Options.Option.Some| ($Box |next#1@@0|))) |#Options.Option.None|))))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :skolemid |4418|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@130| |key#0@@135|) ($IsGoodHeap $Heap@@76))
))))
(assert  (=> true (forall (($Heap@@77 T@U) (|m#0@@131| T@U) (|key#0@@136| T@U) ) (!  (=> (and (and (and (= (type $Heap@@77) (MapType0Type refType MapType1Type)) (= (type |m#0@@131|) (MapType0Type BoxType boolType))) (= (type |key#0@@136|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@131|) (Lit |key#0@@136|)) (and (and ($IsGoodHeap $Heap@@77) ($Is |m#0@@131| (TSet (TSeq Tclass.NativeTypes.byte)))) ($Is |key#0@@136| (TSeq Tclass.NativeTypes.byte))))) (and (and (forall ((|next#2@@2| T@U) ) (!  (=> (and (and (= (type |next#2@@2|) (SeqType BoxType)) ($Is |next#2@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@2|)))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@136|) |next#2@@2|) (=> (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |next#2@@2|) (forall ((|other#2@@2| T@U) ) (!  (=> (and (and (and (= (type |other#2@@2|) (SeqType BoxType)) ($Is |other#2@@2| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@2|)))) (not (|Seq#Equal| |other#2@@2| |next#2@@2|))) (and (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@136|) |other#2@@2|) (=> (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |other#2@@2|) (|Lexicographic__Byte__Order.__default.lt#canCall| |next#2@@2| |other#2@@2|))))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4421|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@2| |other#2@@2|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |other#2@@2|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@2|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4422|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |next#2@@2|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@2|)))
)) (=> (exists ((|next#2@@3| T@U) ) (!  (and (= (type |next#2@@3|) (SeqType BoxType)) (and ($Is |next#2@@3| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@3|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |next#2@@3|)) (forall ((|other#2@@3| T@U) ) (!  (=> (and (= (type |other#2@@3|) (SeqType BoxType)) ($Is |other#2@@3| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@3|))) (not (|Seq#Equal| |other#2@@3| |next#2@@3|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |other#2@@3|)) (Lexicographic__Byte__Order.__default.lt |next#2@@3| |other#2@@3|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4423|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@3| |other#2@@3|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |other#2@@3|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@3|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4424|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |next#2@@3|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@3|)))
)) (|$let#31$canCall| (Lit |m#0@@131|) (Lit |key#0@@136|)))) (= (Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@131|) (Lit |key#0@@136|)) (ite (exists ((|next#2@@4| T@U) ) (!  (and (= (type |next#2@@4|) (SeqType BoxType)) (and ($Is |next#2@@4| (TSeq Tclass.NativeTypes.byte)) (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |next#2@@4|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |next#2@@4|)) (forall ((|other#2@@4| T@U) ) (!  (=> (and (= (type |other#2@@4|) (SeqType BoxType)) ($Is |other#2@@4| (TSeq Tclass.NativeTypes.byte))) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@131|) ($Box |other#2@@4|))) (not (|Seq#Equal| |other#2@@4| |next#2@@4|))) (Lexicographic__Byte__Order.__default.lt (Lit |key#0@@136|) |other#2@@4|)) (Lexicographic__Byte__Order.__default.lt |next#2@@4| |other#2@@4|)))
 :qid |totalorderidfyLexicographicByteOrder.850:18|
 :skolemid |4419|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |next#2@@4| |other#2@@4|))
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |other#2@@4|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |other#2@@4|)))
)))))
 :qid |totalorderidfyLexicographicByteOrder.847:8|
 :skolemid |4420|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |key#0@@136| |next#2@@4|))
 :pattern ( (MapType0Select |m#0@@131| ($Box |next#2@@4|)))
)) (let ((|next#3@@0| (|$let#31_next| (Lit |m#0@@131|) (Lit |key#0@@136|))))
(|#Options.Option.Some| ($Box |next#3@@0|))) |#Options.Option.None|))))
 :qid |totalorderidfyLexicographicByteOrder.845:12|
 :weight 3
 :skolemid |4425|
 :pattern ( (Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@131|) (Lit |key#0@@136|)) ($IsGoodHeap $Heap@@77))
))))
(assert (forall ((arg0@@614 T@U) (arg1@@318 T@U) (arg2@@168 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.MapSuccessor arg0@@614 arg1@@318 arg2@@168)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.MapSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor arg0@@614 arg1@@318 arg2@@168))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V T@U) (|m#0@@132| T@U) (|key#0@@137| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@132|) (MapType BoxType BoxType))) (= (type |key#0@@137|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@137|) (and ($Is |m#0@@132| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V)) ($Is |key#0@@137| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@137|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |unknown.0:0|
 :skolemid |4426|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@132| |key#0@@137|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@133| T@U) (|key#0@@138| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@133|) (MapType BoxType BoxType))) (= (type |key#0@@138|) (SeqType BoxType))) (and ($Is |m#0@@133| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@0)) ($Is |key#0@@138| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.MapSuccessor#requires| Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@133| |key#0@@138|) true))
 :qid |unknown.0:0|
 :skolemid |4427|
 :pattern ( (|Lexicographic__Byte__Order.__default.MapSuccessor#requires| Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@133| |key#0@@138|))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@134| T@U) (|key#0@@139| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@134|) (MapType BoxType BoxType))) (= (type |key#0@@139|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@139|) (and ($Is |m#0@@134| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@1)) ($Is |key#0@@139| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@134|) |key#0@@139|) (= (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@139|) (Lexicographic__Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@134|) |key#0@@139|))))
 :qid |unknown.0:0|
 :skolemid |4428|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@134| |key#0@@139|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@135| T@U) (|key#0@@140| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@135|) (MapType BoxType BoxType))) (= (type |key#0@@140|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@140|)) (and ($Is |m#0@@135| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.MapSuccessor$V@@2)) ($Is |key#0@@140| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@135|))) (Lit |key#0@@140|)) (= (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@140|)) (Lit (Lexicographic__Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@135|))) (Lit |key#0@@140|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4429|
 :pattern ( (Lexicographic__Byte__Order.__default.MapSuccessor Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@135|) (Lit |key#0@@140|)))
))))
(assert (forall ((arg0@@615 T@U) (arg1@@319 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@615 arg1@@319)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.SeqSuccessor|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@615 arg1@@319))
)))
(assert  (=> true (forall ((|m#0@@136| T@U) (|key#0@@141| T@U) ) (!  (=> (and (and (= (type |m#0@@136|) (SeqType BoxType)) (= (type |key#0@@141|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@136| |key#0@@141|) (and ($Is |m#0@@136| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@141| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@136| |key#0@@141|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |4430|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@136| |key#0@@141|))
))))
(assert (forall ((|m#0@@137| T@U) (|key#0@@142| T@U) ) (!  (=> (and (and (= (type |m#0@@137|) (SeqType BoxType)) (= (type |key#0@@142|) (SeqType BoxType))) (and ($Is |m#0@@137| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@142| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@137| |key#0@@142|) true))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |4431|
 :pattern ( (|Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@137| |key#0@@142|))
)))
(assert  (=> true (forall ((|m#0@@138| T@U) (|key#0@@143| T@U) ) (!  (=> (and (and (= (type |m#0@@138|) (SeqType BoxType)) (= (type |key#0@@143|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@138| |key#0@@143|) (and ($Is |m#0@@138| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@143| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| (TSeq Tclass.NativeTypes.byte) |m#0@@138|) |key#0@@143|) (= (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@138| |key#0@@143|) (Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#295| (TSeq Tclass.NativeTypes.byte) |m#0@@138|) |key#0@@143|))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :skolemid |4432|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@138| |key#0@@143|))
))))
(assert  (=> true (forall ((|m#0@@139| T@U) (|key#0@@144| T@U) ) (!  (=> (and (and (= (type |m#0@@139|) (SeqType BoxType)) (= (type |key#0@@144|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@139|) (Lit |key#0@@144|)) (and ($Is |m#0@@139| (TSeq (TSeq Tclass.NativeTypes.byte))) ($Is |key#0@@144| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| (TSeq Tclass.NativeTypes.byte) |m#0@@139|) (Lit |key#0@@144|)) (= (Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@139|) (Lit |key#0@@144|)) (Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#295| (TSeq Tclass.NativeTypes.byte) |m#0@@139|) (Lit |key#0@@144|)))))
 :qid |totalorderidfyLexicographicByteOrder.861:25|
 :weight 3
 :skolemid |4433|
 :pattern ( (Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@139|) (Lit |key#0@@144|)))
))))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@551 T@U) (|s#0@@217| T@U) (|m#0@@140| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@551) LayerTypeType)) (= (type |s#0@@217|) (SeqType BoxType))) (= (type |m#0@@140|) (MapType BoxType BoxType))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@551) |s#0@@217| |m#0@@140|) (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V $ly@@551 |s#0@@217| |m#0@@140|)))
 :qid |unknown.0:0|
 :skolemid |4434|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@551) |s#0@@217| |m#0@@140|))
)))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@552 T@U) (|s#0@@218| T@U) (|m#0@@141| T@U) ) (!  (=> (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@552) LayerTypeType)) (= (type |s#0@@218|) (SeqType BoxType))) (= (type |m#0@@141|) (MapType BoxType BoxType))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $ly@@552 |s#0@@218| |m#0@@141|) (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@218| |m#0@@141|)))
 :qid |unknown.0:0|
 :skolemid |4435|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@552) |s#0@@218| |m#0@@141|))
)))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@553 T@U) (|s#0@@219| T@U) (|m#0@@142| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@553) LayerTypeType)) (= (type |s#0@@219|) (SeqType BoxType))) (= (type |m#0@@142|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@219| |m#0@@142|) (and ($Is |s#0@@219| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@142| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |4436|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 $ly@@553 |s#0@@219| |m#0@@142|))
))))
(assert (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@554 T@U) (|s#0@@220| T@U) (|m#0@@143| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@554) LayerTypeType)) (= (type |s#0@@220|) (SeqType BoxType))) (= (type |m#0@@143|) (MapType BoxType BoxType))) (and ($Is |s#0@@220| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@143| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@554 |s#0@@220| |m#0@@143|) true))
 :qid |unknown.0:0|
 :skolemid |4437|
 :pattern ( (|Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@554 |s#0@@220| |m#0@@143|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@555 T@U) (|s#0@@221| T@U) (|m#0@@144| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@555) LayerTypeType)) (= (type |s#0@@221|) (SeqType BoxType))) (= (type |m#0@@144|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@221| |m#0@@144|) (and ($Is |s#0@@221| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@144| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@221|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|))) (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|))))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|)))) (and (forall ((|i#0@@152| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@152|) (=> (INTERNAL_lt_boogie |i#0@@152| (|Seq#Length| |s#0@@221|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@152|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@152|) (INTERNAL_lt_boogie |i#0@@152| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@152|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@152|) (=> (INTERNAL_lt_boogie |i#0@@152| (|Seq#Length| |s#0@@221|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@152|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@152|))))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4441|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@152|)))
)) (=> (forall ((|i#0@@153| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@153|) (INTERNAL_lt_boogie |i#0@@153| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@153|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@153|) (INTERNAL_lt_boogie |i#0@@153| (|Seq#Length| |s#0@@221|))) (= (MapType0Select (|Map#Elements| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@153|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@153|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4444|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@153|)))
)) (forall ((|key#0@@145| T@U) ) (!  (=> (and (and (= (type |key#0@@145|) (SeqType BoxType)) ($Is |key#0@@145| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@145|)))) (forall ((|i#1@@48| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@48|) (=> (INTERNAL_lt_boogie |i#1@@48| (|Seq#Length| |s#0@@221|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@48|))) (=> (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@48|)))) |key#0@@145|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@48|)))))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |4442|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@48|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |4443|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@145|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@145|)))
)))))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@555) |s#0@@221| |m#0@@144|)  (and (and (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@221|)))) (forall ((|i#0@@154| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@154|) (INTERNAL_lt_boogie |i#0@@154| (|Seq#Length| |s#0@@221|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@154|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@154|) (INTERNAL_lt_boogie |i#0@@154| (|Seq#Length| |s#0@@221|))) (= (MapType0Select (|Map#Elements| |m#0@@144|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@154|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@154|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4438|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#0@@154|)))
))) (forall ((|key#0@@146| T@U) ) (!  (=> (and (and (= (type |key#0@@146|) (SeqType BoxType)) ($Is |key#0@@146| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@146|)))) (exists ((|i#1@@49| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@49|) (INTERNAL_lt_boogie |i#1@@49| (|Seq#Length| |s#0@@221|))) (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@49|)))) |key#0@@146|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@49|))) (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@146|))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |4439|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@221| |i#1@@49|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |4440|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@144|) ($Box |key#0@@146|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@144|) ($Box |key#0@@146|)))
))))))
 :qid |unknown.0:0|
 :skolemid |4445|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@555) |s#0@@221| |m#0@@144|))
))))
(assert  (=> true (forall ((Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@556 T@U) (|s#0@@222| T@U) (|m#0@@145| T@U) ) (!  (=> (and (and (and (and (= (type Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@556) LayerTypeType)) (= (type |s#0@@222|) (SeqType BoxType))) (= (type |m#0@@145|) (MapType BoxType BoxType))) (or (|Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@222|) (Lit |m#0@@145|)) (and ($Is |s#0@@222| (TSeq (Tclass._System.Tuple2 (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@145| (TMap (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@222|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|)))) (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|)))))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|))))) (and (forall ((|i#2@@15| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@15|) (=> (INTERNAL_lt_boogie |i#2@@15| (|Seq#Length| (Lit |s#0@@222|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@15|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@15|) (INTERNAL_lt_boogie |i#2@@15| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@15|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@15|) (=> (INTERNAL_lt_boogie |i#2@@15| (|Seq#Length| (Lit |s#0@@222|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@15|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@15|))))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4449|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@15|)))
)) (=> (forall ((|i#2@@16| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@16|) (INTERNAL_lt_boogie |i#2@@16| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@16|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@16|) (INTERNAL_lt_boogie |i#2@@16| (|Seq#Length| (Lit |s#0@@222|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@16|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@16|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4452|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@16|)))
)) (forall ((|key#1@@10| T@U) ) (!  (=> (and (and (= (type |key#1@@10|) (SeqType BoxType)) ($Is |key#1@@10| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@10|)))) (forall ((|i#3@@7| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@7|) (=> (INTERNAL_lt_boogie |i#3@@7| (|Seq#Length| (Lit |s#0@@222|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@7|))) (=> (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@7|)))) |key#1@@10|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@7|)))))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |4450|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#3@@7|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |4451|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@145|) ($Box |key#1@@10|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@10|)))
)))))) (= (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@556) (Lit |s#0@@222|) (Lit |m#0@@145|))  (and (and (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip (TSeq Tclass.NativeTypes.byte) Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@222|))))) (forall ((|i#2@@17| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@17|) (INTERNAL_lt_boogie |i#2@@17| (|Seq#Length| (Lit |s#0@@222|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@17|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@17|) (INTERNAL_lt_boogie |i#2@@17| (|Seq#Length| (Lit |s#0@@222|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@17|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#2@@17|)))))))
 :qid |totalorderidfyLexicographicByteOrder.869:16|
 :skolemid |4446|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#2@@17|)))
))) (forall ((|key#1@@11| T@U) ) (!  (=> (and (and (= (type |key#1@@11|) (SeqType BoxType)) ($Is |key#1@@11| (TSeq Tclass.NativeTypes.byte))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@11|)))) (exists ((|i#3@@8| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@8|) (INTERNAL_lt_boogie |i#3@@8| (|Seq#Length| (Lit |s#0@@222|)))) (|Seq#Equal| ($Unbox (SeqType BoxType) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@8|)))) |key#1@@11|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@222|) |i#3@@8|))) (MapType0Select (|Map#Elements| (Lit |m#0@@145|)) ($Box |key#1@@11|))))
 :qid |totalorderidfyLexicographicByteOrder.870:44|
 :skolemid |4447|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@222| |i#3@@8|)))
)))
 :qid |totalorderidfyLexicographicByteOrder.870:16|
 :skolemid |4448|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@145|) ($Box |key#1@@11|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@145|) ($Box |key#1@@11|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4453|
 :pattern ( (Lexicographic__Byte__Order.__default.SortedSeqForMap Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@556) (Lit |s#0@@222|) (Lit |m#0@@145|)))
))))
(assert (forall ((arg0@@616 T@U) (arg1@@320 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.minimum arg0@@616 arg1@@320)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.minimum|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum arg0@@616 arg1@@320))
)))
(assert (forall (($ly@@557 T@U) (|s#0@@223| T@U) ) (!  (=> (and (= (type $ly@@557) LayerTypeType) (= (type |s#0@@223|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@557) |s#0@@223|) (Lexicographic__Byte__Order.__default.minimum $ly@@557 |s#0@@223|)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |4454|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@557) |s#0@@223|))
)))
(assert (forall (($ly@@558 T@U) (|s#0@@224| T@U) ) (!  (=> (and (= (type $ly@@558) LayerTypeType) (= (type |s#0@@224|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimum $ly@@558 |s#0@@224|) (Lexicographic__Byte__Order.__default.minimum $LZ |s#0@@224|)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |4455|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum (AsFuelBottom $ly@@558) |s#0@@224|))
)))
(assert  (=> true (forall (($ly@@559 T@U) (|s#0@@225| T@U) ) (!  (=> (and (and (= (type $ly@@559) LayerTypeType) (= (type |s#0@@225|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@225|) (and ($Is |s#0@@225| (TSet (TSeq Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@225|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@225| ($Box (Lexicographic__Byte__Order.__default.minimum $ly@@559 |s#0@@225|)))) (forall ((|y#0@@11| T@U) ) (!  (=> (= (type |y#0@@11|) (SeqType BoxType)) (=> (and ($Is |y#0@@11| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@225| ($Box |y#0@@11|)))) (Lexicographic__Byte__Order.__default.lte (Lexicographic__Byte__Order.__default.minimum $ly@@559 |s#0@@225|) |y#0@@11|)))
 :qid |totalorderidfyLexicographicByteOrder.876:18|
 :skolemid |4456|
 :pattern ( (Lexicographic__Byte__Order.__default.lte (Lexicographic__Byte__Order.__default.minimum $ly@@559 |s#0@@225|) |y#0@@11|))
 :pattern ( (MapType0Select |s#0@@225| ($Box |y#0@@11|)))
))) ($Is (Lexicographic__Byte__Order.__default.minimum $ly@@559 |s#0@@225|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |4457|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum $ly@@559 |s#0@@225|))
))))
(assert (forall (($ly@@560 T@U) ($Heap@@78 T@U) (|s#0@@226| T@U) ) (!  (=> (and (and (and (= (type $ly@@560) LayerTypeType) (= (type $Heap@@78) (MapType0Type refType MapType1Type))) (= (type |s#0@@226|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@78) ($Is |s#0@@226| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.minimum#requires| $ly@@560 |s#0@@226|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@226|) 1)))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |4458|
 :pattern ( (|Lexicographic__Byte__Order.__default.minimum#requires| $ly@@560 |s#0@@226|) ($IsGoodHeap $Heap@@78))
)))
(assert (forall ((arg0@@617 T@U) ) (! (= (type (|$let#34_a| arg0@@617)) (SeqType BoxType))
 :qid |funType:$let#34_a|
 :pattern ( (|$let#34_a| arg0@@617))
)))
(assert (forall ((s@@54 T@U) ) (!  (=> (and (= (type s@@54) (MapType0Type BoxType boolType)) (|$let#34$canCall| s@@54)) (and ($Is (|$let#34_a| s@@54) (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select s@@54 ($Box (|$let#34_a| s@@54))))))
 :qid |totalorderidfyLexicographicByteOrder.881:5|
 :skolemid |4459|
 :pattern ( (|$let#34_a| s@@54))
)))
(assert  (=> true (forall (($ly@@561 T@U) ($Heap@@79 T@U) (|s#0@@227| T@U) ) (!  (=> (and (and (and (= (type $ly@@561) LayerTypeType) (= (type $Heap@@79) (MapType0Type refType MapType1Type))) (= (type |s#0@@227|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@227|) (and (and ($IsGoodHeap $Heap@@79) ($Is |s#0@@227| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@227|) 1)))) (and (and (|$let#34$canCall| |s#0@@227|) (let ((|s'#1@@1| (|Set#Difference| |s#0@@227| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#34_a| |s#0@@227|))))))
 (=> (not (|Set#Equal| |s'#1@@1| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.minimum#canCall| |s'#1@@1|) (let ((|m'#1@@3| (Lexicographic__Byte__Order.__default.minimum $ly@@561 |s'#1@@1|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| (|$let#34_a| |s#0@@227|) |m'#1@@3|)))))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@561) |s#0@@227|) (let ((|a#0@@167| (|$let#34_a| |s#0@@227|)))
(let ((|s'#0@@1| (|Set#Difference| |s#0@@227| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@167|)))))
(ite (|Set#Equal| |s'#0@@1| (|Set#Empty| BoxType)) |a#0@@167| (let ((|m'#0@@12| (Lexicographic__Byte__Order.__default.minimum $ly@@561 |s'#0@@1|)))
(ite (Lexicographic__Byte__Order.__default.lt |a#0@@167| |m'#0@@12|) |a#0@@167| |m'#0@@12|))))))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :skolemid |4460|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@561) |s#0@@227|) ($IsGoodHeap $Heap@@79))
))))
(assert  (=> true (forall (($ly@@562 T@U) ($Heap@@80 T@U) (|s#0@@228| T@U) ) (!  (=> (and (and (and (= (type $ly@@562) LayerTypeType) (= (type $Heap@@80) (MapType0Type refType MapType1Type))) (= (type |s#0@@228|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@228|)) (and (and ($IsGoodHeap $Heap@@80) ($Is |s#0@@228| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@228|)) 1)))) (and (and (|$let#34$canCall| (Lit |s#0@@228|)) (let ((|s'#3@@1| (|Set#Difference| |s#0@@228| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#34_a| (Lit |s#0@@228|)))))))
 (=> (not (|Set#Equal| |s'#3@@1| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.minimum#canCall| |s'#3@@1|) (let ((|m'#3@@1| (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@562) |s'#3@@1|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| (|$let#34_a| (Lit |s#0@@228|)) |m'#3@@1|)))))) (= (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@562) (Lit |s#0@@228|)) (let ((|a#1@@4| (|$let#34_a| (Lit |s#0@@228|))))
(let ((|s'#2@@1| (|Set#Difference| |s#0@@228| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@4|)))))
(ite (|Set#Equal| |s'#2@@1| (|Set#Empty| BoxType)) |a#1@@4| (let ((|m'#2@@2| (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@562) |s'#2@@1|)))
(ite (Lexicographic__Byte__Order.__default.lt |a#1@@4| |m'#2@@2|) |a#1@@4| |m'#2@@2|))))))))
 :qid |totalorderidfyLexicographicByteOrder.873:22|
 :weight 3
 :skolemid |4461|
 :pattern ( (Lexicographic__Byte__Order.__default.minimum ($LS $ly@@562) (Lit |s#0@@228|)) ($IsGoodHeap $Heap@@80))
))))
(assert (forall ((arg0@@618 T@U) (arg1@@321 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.minimumOpt arg0@@618 arg1@@321)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.minimumOpt|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt arg0@@618 arg1@@321))
)))
(assert (forall (($ly@@563 T@U) (|s#0@@229| T@U) ) (!  (=> (and (= (type $ly@@563) LayerTypeType) (= (type |s#0@@229|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@563) |s#0@@229|) (Lexicographic__Byte__Order.__default.minimumOpt $ly@@563 |s#0@@229|)))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |4462|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@563) |s#0@@229|))
)))
(assert (forall (($ly@@564 T@U) (|s#0@@230| T@U) ) (!  (=> (and (= (type $ly@@564) LayerTypeType) (= (type |s#0@@230|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.minimumOpt $ly@@564 |s#0@@230|) (Lexicographic__Byte__Order.__default.minimumOpt $LZ |s#0@@230|)))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |4463|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@564) |s#0@@230|))
)))
(assert  (=> true (forall (($ly@@565 T@U) (|s#0@@231| T@U) ) (!  (=> (and (and (= (type $ly@@565) LayerTypeType) (= (type |s#0@@231|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@231|) ($Is |s#0@@231| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|)) (U_2_bool (MapType0Select |s#0@@231| (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|))))) (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|)) (forall ((|y#0@@12| T@U) ) (!  (=> (= (type |y#0@@12|) (SeqType BoxType)) (=> (and ($Is |y#0@@12| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@231| ($Box |y#0@@12|)))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|))) |y#0@@12|)))
 :qid |totalorderidfyLexicographicByteOrder.899:30|
 :skolemid |4464|
 :pattern ( (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|))) |y#0@@12|))
 :pattern ( (MapType0Select |s#0@@231| ($Box |y#0@@12|)))
)))) (=> (Options.Option.None_q (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|)) (|Set#Equal| |s#0@@231| (|Set#Empty| BoxType)))) ($Is (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |4465|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt $ly@@565 |s#0@@231|))
))))
(assert (forall (($ly@@566 T@U) (|s#0@@232| T@U) ) (!  (=> (and (and (= (type $ly@@566) LayerTypeType) (= (type |s#0@@232|) (MapType0Type BoxType boolType))) ($Is |s#0@@232| (TSet (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@566 |s#0@@232|) true))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |4466|
 :pattern ( (|Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@566 |s#0@@232|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@567 T@U) (|s#0@@233| T@U) ) (!  (=> (and (and (= (type $ly@@567) LayerTypeType) (= (type |s#0@@233|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@233|) ($Is |s#0@@233| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@233| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@233|)) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@567) |s#0@@233|) (ite (|Set#Equal| |s#0@@233| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.minimum StartFuel_Lexicographic_Byte_Order._default.minimum |s#0@@233|)))))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :skolemid |4467|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@567) |s#0@@233|))
))))
(assert  (=> true (forall (($ly@@568 T@U) (|s#0@@234| T@U) ) (!  (=> (and (and (= (type $ly@@568) LayerTypeType) (= (type |s#0@@234|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@234|)) ($Is |s#0@@234| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@234| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@234|))) (= (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@568) (Lit |s#0@@234|)) (ite (|Set#Equal| |s#0@@234| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.minimum StartFuel_Lexicographic_Byte_Order._default.minimum (Lit |s#0@@234|))))))))
 :qid |totalorderidfyLexicographicByteOrder.897:22|
 :weight 3
 :skolemid |4468|
 :pattern ( (Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@568) (Lit |s#0@@234|)))
))))
(assert (forall ((arg0@@619 T@U) (arg1@@322 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.maximum arg0@@619 arg1@@322)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.maximum|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum arg0@@619 arg1@@322))
)))
(assert (forall (($ly@@569 T@U) (|s#0@@235| T@U) ) (!  (=> (and (= (type $ly@@569) LayerTypeType) (= (type |s#0@@235|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@569) |s#0@@235|) (Lexicographic__Byte__Order.__default.maximum $ly@@569 |s#0@@235|)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |4469|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@569) |s#0@@235|))
)))
(assert (forall (($ly@@570 T@U) (|s#0@@236| T@U) ) (!  (=> (and (= (type $ly@@570) LayerTypeType) (= (type |s#0@@236|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximum $ly@@570 |s#0@@236|) (Lexicographic__Byte__Order.__default.maximum $LZ |s#0@@236|)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |4470|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum (AsFuelBottom $ly@@570) |s#0@@236|))
)))
(assert  (=> true (forall (($ly@@571 T@U) (|s#0@@237| T@U) ) (!  (=> (and (and (= (type $ly@@571) LayerTypeType) (= (type |s#0@@237|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@237|) (and ($Is |s#0@@237| (TSet (TSeq Tclass.NativeTypes.byte))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@237|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@237| ($Box (Lexicographic__Byte__Order.__default.maximum $ly@@571 |s#0@@237|)))) (forall ((|y#0@@13| T@U) ) (!  (=> (= (type |y#0@@13|) (SeqType BoxType)) (=> (and ($Is |y#0@@13| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@237| ($Box |y#0@@13|)))) (Lexicographic__Byte__Order.__default.lte |y#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@571 |s#0@@237|))))
 :qid |totalorderidfyLexicographicByteOrder.908:18|
 :skolemid |4471|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |y#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@571 |s#0@@237|)))
 :pattern ( (MapType0Select |s#0@@237| ($Box |y#0@@13|)))
))) ($Is (Lexicographic__Byte__Order.__default.maximum $ly@@571 |s#0@@237|) (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |4472|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum $ly@@571 |s#0@@237|))
))))
(assert (forall (($ly@@572 T@U) ($Heap@@81 T@U) (|s#0@@238| T@U) ) (!  (=> (and (and (and (= (type $ly@@572) LayerTypeType) (= (type $Heap@@81) (MapType0Type refType MapType1Type))) (= (type |s#0@@238|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@81) ($Is |s#0@@238| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.maximum#requires| $ly@@572 |s#0@@238|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@238|) 1)))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |4473|
 :pattern ( (|Lexicographic__Byte__Order.__default.maximum#requires| $ly@@572 |s#0@@238|) ($IsGoodHeap $Heap@@81))
)))
(assert (forall ((arg0@@620 T@U) ) (! (= (type (|$let#37_a| arg0@@620)) (SeqType BoxType))
 :qid |funType:$let#37_a|
 :pattern ( (|$let#37_a| arg0@@620))
)))
(assert (forall ((s@@55 T@U) ) (!  (=> (and (= (type s@@55) (MapType0Type BoxType boolType)) (|$let#37$canCall| s@@55)) (and ($Is (|$let#37_a| s@@55) (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select s@@55 ($Box (|$let#37_a| s@@55))))))
 :qid |totalorderidfyLexicographicByteOrder.911:5|
 :skolemid |4474|
 :pattern ( (|$let#37_a| s@@55))
)))
(assert  (=> true (forall (($ly@@573 T@U) ($Heap@@82 T@U) (|s#0@@239| T@U) ) (!  (=> (and (and (and (= (type $ly@@573) LayerTypeType) (= (type $Heap@@82) (MapType0Type refType MapType1Type))) (= (type |s#0@@239|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@239|) (and (and ($IsGoodHeap $Heap@@82) ($Is |s#0@@239| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@239|) 1)))) (and (and (|$let#37$canCall| |s#0@@239|) (let ((|s'#1@@2| (|Set#Difference| |s#0@@239| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#37_a| |s#0@@239|))))))
 (=> (not (|Set#Equal| |s'#1@@2| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.maximum#canCall| |s'#1@@2|) (let ((|m'#1@@4| (Lexicographic__Byte__Order.__default.maximum $ly@@573 |s'#1@@2|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| |m'#1@@4| (|$let#37_a| |s#0@@239|))))))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@573) |s#0@@239|) (let ((|a#0@@168| (|$let#37_a| |s#0@@239|)))
(let ((|s'#0@@2| (|Set#Difference| |s#0@@239| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@168|)))))
(ite (|Set#Equal| |s'#0@@2| (|Set#Empty| BoxType)) |a#0@@168| (let ((|m'#0@@13| (Lexicographic__Byte__Order.__default.maximum $ly@@573 |s'#0@@2|)))
(ite (Lexicographic__Byte__Order.__default.lt |m'#0@@13| |a#0@@168|) |a#0@@168| |m'#0@@13|))))))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :skolemid |4475|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@573) |s#0@@239|) ($IsGoodHeap $Heap@@82))
))))
(assert  (=> true (forall (($ly@@574 T@U) ($Heap@@83 T@U) (|s#0@@240| T@U) ) (!  (=> (and (and (and (= (type $ly@@574) LayerTypeType) (= (type $Heap@@83) (MapType0Type refType MapType1Type))) (= (type |s#0@@240|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@240|)) (and (and ($IsGoodHeap $Heap@@83) ($Is |s#0@@240| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@240|)) 1)))) (and (and (|$let#37$canCall| (Lit |s#0@@240|)) (let ((|s'#3@@2| (|Set#Difference| |s#0@@240| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#37_a| (Lit |s#0@@240|)))))))
 (=> (not (|Set#Equal| |s'#3@@2| (|Set#Empty| BoxType))) (and (|Lexicographic__Byte__Order.__default.maximum#canCall| |s'#3@@2|) (let ((|m'#3@@2| (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@574) |s'#3@@2|)))
(|Lexicographic__Byte__Order.__default.lt#canCall| |m'#3@@2| (|$let#37_a| (Lit |s#0@@240|)))))))) (= (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@574) (Lit |s#0@@240|)) (let ((|a#1@@5| (|$let#37_a| (Lit |s#0@@240|))))
(let ((|s'#2@@2| (|Set#Difference| |s#0@@240| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@5|)))))
(ite (|Set#Equal| |s'#2@@2| (|Set#Empty| BoxType)) |a#1@@5| (let ((|m'#2@@3| (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@574) |s'#2@@2|)))
(ite (Lexicographic__Byte__Order.__default.lt |m'#2@@3| |a#1@@5|) |a#1@@5| |m'#2@@3|))))))))
 :qid |totalorderidfyLexicographicByteOrder.905:22|
 :weight 3
 :skolemid |4476|
 :pattern ( (Lexicographic__Byte__Order.__default.maximum ($LS $ly@@574) (Lit |s#0@@240|)) ($IsGoodHeap $Heap@@83))
))))
(assert (forall ((arg0@@621 T@U) (arg1@@323 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.maximumOpt arg0@@621 arg1@@323)) DatatypeTypeType)
 :qid |funType:Lexicographic__Byte__Order.__default.maximumOpt|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt arg0@@621 arg1@@323))
)))
(assert (forall (($ly@@575 T@U) (|s#0@@241| T@U) ) (!  (=> (and (= (type $ly@@575) LayerTypeType) (= (type |s#0@@241|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@575) |s#0@@241|) (Lexicographic__Byte__Order.__default.maximumOpt $ly@@575 |s#0@@241|)))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |4477|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@575) |s#0@@241|))
)))
(assert (forall (($ly@@576 T@U) (|s#0@@242| T@U) ) (!  (=> (and (= (type $ly@@576) LayerTypeType) (= (type |s#0@@242|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.maximumOpt $ly@@576 |s#0@@242|) (Lexicographic__Byte__Order.__default.maximumOpt $LZ |s#0@@242|)))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |4478|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@576) |s#0@@242|))
)))
(assert  (=> true (forall (($ly@@577 T@U) (|s#0@@243| T@U) ) (!  (=> (and (and (= (type $ly@@577) LayerTypeType) (= (type |s#0@@243|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@243|) ($Is |s#0@@243| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|)) (U_2_bool (MapType0Select |s#0@@243| (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|))))) (=> (Options.Option.Some_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|)) (forall ((|y#0@@14| T@U) ) (!  (=> (= (type |y#0@@14|) (SeqType BoxType)) (=> (and ($Is |y#0@@14| (TSeq Tclass.NativeTypes.byte)) (U_2_bool (MapType0Select |s#0@@243| ($Box |y#0@@14|)))) (Lexicographic__Byte__Order.__default.lte |y#0@@14| ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|))))))
 :qid |totalorderidfyLexicographicByteOrder.929:30|
 :skolemid |4479|
 :pattern ( (Lexicographic__Byte__Order.__default.lte |y#0@@14| ($Unbox (SeqType BoxType) (Options.Option.value (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|)))))
 :pattern ( (MapType0Select |s#0@@243| ($Box |y#0@@14|)))
)))) (=> (Options.Option.None_q (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|)) (|Set#Equal| |s#0@@243| (|Set#Empty| BoxType)))) ($Is (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|) (Tclass.Options.Option (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |4480|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt $ly@@577 |s#0@@243|))
))))
(assert (forall (($ly@@578 T@U) (|s#0@@244| T@U) ) (!  (=> (and (and (= (type $ly@@578) LayerTypeType) (= (type |s#0@@244|) (MapType0Type BoxType boolType))) ($Is |s#0@@244| (TSet (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@578 |s#0@@244|) true))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |4481|
 :pattern ( (|Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@578 |s#0@@244|))
)))
(assert (= (type StartFuel_Lexicographic_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@579 T@U) (|s#0@@245| T@U) ) (!  (=> (and (and (= (type $ly@@579) LayerTypeType) (= (type |s#0@@245|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@245|) ($Is |s#0@@245| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@245| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@245|)) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@579) |s#0@@245|) (ite (|Set#Equal| |s#0@@245| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.maximum StartFuel_Lexicographic_Byte_Order._default.maximum |s#0@@245|)))))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :skolemid |4482|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@579) |s#0@@245|))
))))
(assert  (=> true (forall (($ly@@580 T@U) (|s#0@@246| T@U) ) (!  (=> (and (and (= (type $ly@@580) LayerTypeType) (= (type |s#0@@246|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@246|)) ($Is |s#0@@246| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (=> (not (|Set#Equal| |s#0@@246| (|Set#Empty| BoxType))) (|Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@246|))) (= (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@580) (Lit |s#0@@246|)) (ite (|Set#Equal| |s#0@@246| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Lexicographic__Byte__Order.__default.maximum StartFuel_Lexicographic_Byte_Order._default.maximum (Lit |s#0@@246|))))))))
 :qid |totalorderidfyLexicographicByteOrder.927:22|
 :weight 3
 :skolemid |4483|
 :pattern ( (Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@580) (Lit |s#0@@246|)))
))))
(assert  (=> true (forall ((|a#0@@169| T@U) (|b#0@@119| T@U) ) (!  (=> (and (and (= (type |a#0@@169|) (SeqType BoxType)) (= (type |b#0@@119|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@169| |b#0@@119|) (and ($Is |a#0@@169| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@119| (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |4484|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |a#0@@169| |b#0@@119|))
))))
(assert (forall ((|a#0@@170| T@U) (|b#0@@120| T@U) ) (!  (=> (and (and (= (type |a#0@@170|) (SeqType BoxType)) (= (type |b#0@@120|) (SeqType BoxType))) (and ($Is |a#0@@170| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@120| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.lt#requires| |a#0@@170| |b#0@@120|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |4485|
 :pattern ( (|Lexicographic__Byte__Order.__default.lt#requires| |a#0@@170| |b#0@@120|))
)))
(assert  (=> true (forall ((|a#0@@171| T@U) (|b#0@@121| T@U) ) (!  (=> (and (and (= (type |a#0@@171|) (SeqType BoxType)) (= (type |b#0@@121|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@171| |b#0@@121|) (and ($Is |a#0@@171| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@121| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@171| |b#0@@121|) (= (Lexicographic__Byte__Order.__default.lt |a#0@@171| |b#0@@121|)  (and (Lexicographic__Byte__Order.__default.lte |a#0@@171| |b#0@@121|) (not (|Seq#Equal| |a#0@@171| |b#0@@121|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :skolemid |4486|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |a#0@@171| |b#0@@121|))
))))
(assert  (=> true (forall ((|a#0@@172| T@U) (|b#0@@122| T@U) ) (!  (=> (and (and (= (type |a#0@@172|) (SeqType BoxType)) (= (type |b#0@@122|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.lt#canCall| (Lit |a#0@@172|) (Lit |b#0@@122|)) (and ($Is |a#0@@172| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@122| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@172|) (Lit |b#0@@122|)) (= (Lexicographic__Byte__Order.__default.lt (Lit |a#0@@172|) (Lit |b#0@@122|))  (and (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@172|) (Lit |b#0@@122|)) (not (|Seq#Equal| |a#0@@172| |b#0@@122|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.17:16|
 :weight 3
 :skolemid |4487|
 :pattern ( (Lexicographic__Byte__Order.__default.lt (Lit |a#0@@172|) (Lit |b#0@@122|)))
))))
(assert (forall ((arg0@@622 T@U) (arg1@@324 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.Min arg0@@622 arg1@@324)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.Min|
 :pattern ( (Lexicographic__Byte__Order.__default.Min arg0@@622 arg1@@324))
)))
(assert  (=> true (forall ((|a#0@@173| T@U) (|b#0@@123| T@U) ) (!  (=> (and (and (= (type |a#0@@173|) (SeqType BoxType)) (= (type |b#0@@123|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@173| |b#0@@123|) (and ($Is |a#0@@173| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@123| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.Min |a#0@@173| |b#0@@123|) (TSeq Tclass.NativeTypes.byte)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |4488|
 :pattern ( (Lexicographic__Byte__Order.__default.Min |a#0@@173| |b#0@@123|))
))))
(assert (forall ((|a#0@@174| T@U) (|b#0@@124| T@U) ) (!  (=> (and (and (= (type |a#0@@174|) (SeqType BoxType)) (= (type |b#0@@124|) (SeqType BoxType))) (and ($Is |a#0@@174| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@124| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.Min#requires| |a#0@@174| |b#0@@124|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |4489|
 :pattern ( (|Lexicographic__Byte__Order.__default.Min#requires| |a#0@@174| |b#0@@124|))
)))
(assert  (=> true (forall ((|a#0@@175| T@U) (|b#0@@125| T@U) ) (!  (=> (and (and (= (type |a#0@@175|) (SeqType BoxType)) (= (type |b#0@@125|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@175| |b#0@@125|) (and ($Is |a#0@@175| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@125| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@175| |b#0@@125|) (= (Lexicographic__Byte__Order.__default.Min |a#0@@175| |b#0@@125|) (ite (Lexicographic__Byte__Order.__default.lte |a#0@@175| |b#0@@125|) |a#0@@175| |b#0@@125|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :skolemid |4490|
 :pattern ( (Lexicographic__Byte__Order.__default.Min |a#0@@175| |b#0@@125|))
))))
(assert  (=> true (forall ((|a#0@@176| T@U) (|b#0@@126| T@U) ) (!  (=> (and (and (= (type |a#0@@176|) (SeqType BoxType)) (= (type |b#0@@126|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Min#canCall| (Lit |a#0@@176|) (Lit |b#0@@126|)) (and ($Is |a#0@@176| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@126| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@176|) (Lit |b#0@@126|)) (= (Lexicographic__Byte__Order.__default.Min (Lit |a#0@@176|) (Lit |b#0@@126|)) (ite (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@176|) (Lit |b#0@@126|)) |a#0@@176| |b#0@@126|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.44:16|
 :weight 3
 :skolemid |4491|
 :pattern ( (Lexicographic__Byte__Order.__default.Min (Lit |a#0@@176|) (Lit |b#0@@126|)))
))))
(assert (forall ((arg0@@623 T@U) (arg1@@325 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.Max arg0@@623 arg1@@325)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.Max|
 :pattern ( (Lexicographic__Byte__Order.__default.Max arg0@@623 arg1@@325))
)))
(assert  (=> true (forall ((|a#0@@177| T@U) (|b#0@@127| T@U) ) (!  (=> (and (and (= (type |a#0@@177|) (SeqType BoxType)) (= (type |b#0@@127|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@177| |b#0@@127|) (and ($Is |a#0@@177| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@127| (TSeq Tclass.NativeTypes.byte))))) ($Is (Lexicographic__Byte__Order.__default.Max |a#0@@177| |b#0@@127|) (TSeq Tclass.NativeTypes.byte)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |4492|
 :pattern ( (Lexicographic__Byte__Order.__default.Max |a#0@@177| |b#0@@127|))
))))
(assert (forall ((|a#0@@178| T@U) (|b#0@@128| T@U) ) (!  (=> (and (and (= (type |a#0@@178|) (SeqType BoxType)) (= (type |b#0@@128|) (SeqType BoxType))) (and ($Is |a#0@@178| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@128| (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.Max#requires| |a#0@@178| |b#0@@128|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |4493|
 :pattern ( (|Lexicographic__Byte__Order.__default.Max#requires| |a#0@@178| |b#0@@128|))
)))
(assert  (=> true (forall ((|a#0@@179| T@U) (|b#0@@129| T@U) ) (!  (=> (and (and (= (type |a#0@@179|) (SeqType BoxType)) (= (type |b#0@@129|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@179| |b#0@@129|) (and ($Is |a#0@@179| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@129| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@179| |b#0@@129|) (= (Lexicographic__Byte__Order.__default.Max |a#0@@179| |b#0@@129|) (ite (Lexicographic__Byte__Order.__default.lte |a#0@@179| |b#0@@129|) |b#0@@129| |a#0@@179|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :skolemid |4494|
 :pattern ( (Lexicographic__Byte__Order.__default.Max |a#0@@179| |b#0@@129|))
))))
(assert  (=> true (forall ((|a#0@@180| T@U) (|b#0@@130| T@U) ) (!  (=> (and (and (= (type |a#0@@180|) (SeqType BoxType)) (= (type |b#0@@130|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.Max#canCall| (Lit |a#0@@180|) (Lit |b#0@@130|)) (and ($Is |a#0@@180| (TSeq Tclass.NativeTypes.byte)) ($Is |b#0@@130| (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@180|) (Lit |b#0@@130|)) (= (Lexicographic__Byte__Order.__default.Max (Lit |a#0@@180|) (Lit |b#0@@130|)) (ite (Lexicographic__Byte__Order.__default.lte (Lit |a#0@@180|) (Lit |b#0@@130|)) |b#0@@130| |a#0@@180|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.49:16|
 :weight 3
 :skolemid |4495|
 :pattern ( (Lexicographic__Byte__Order.__default.Max (Lit |a#0@@180|) (Lit |b#0@@130|)))
))))
(assert (forall (($ly@@581 T@U) (|run#0@@157| T@U) ) (!  (=> (and (= (type $ly@@581) LayerTypeType) (= (type |run#0@@157|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@581) |run#0@@157|) (Lexicographic__Byte__Order.__default.IsSorted $ly@@581 |run#0@@157|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |4496|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@581) |run#0@@157|))
)))
(assert (forall (($ly@@582 T@U) (|run#0@@158| T@U) ) (!  (=> (and (= (type $ly@@582) LayerTypeType) (= (type |run#0@@158|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsSorted $ly@@582 |run#0@@158|) (Lexicographic__Byte__Order.__default.IsSorted $LZ |run#0@@158|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |4497|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted (AsFuelBottom $ly@@582) |run#0@@158|))
)))
(assert  (=> true (forall (($ly@@583 T@U) (|run#0@@159| T@U) ) (!  (=> (and (and (= (type $ly@@583) LayerTypeType) (= (type |run#0@@159|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@159|) ($Is |run#0@@159| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (=> (= (|Seq#Length| |run#0@@159|) (LitInt 0)) (Lexicographic__Byte__Order.__default.IsSorted $ly@@583 |run#0@@159|)) (=> (= (|Seq#Length| |run#0@@159|) (LitInt 1)) (Lexicographic__Byte__Order.__default.IsSorted $ly@@583 |run#0@@159|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |4498|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted $ly@@583 |run#0@@159|))
))))
(assert (forall (($ly@@584 T@U) (|run#0@@160| T@U) ) (!  (=> (and (and (= (type $ly@@584) LayerTypeType) (= (type |run#0@@160|) (SeqType BoxType))) ($Is |run#0@@160| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@584 |run#0@@160|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |4499|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@584 |run#0@@160|))
)))
(assert  (=> true (forall (($ly@@585 T@U) (|run#0@@161| T@U) ) (!  (=> (and (and (= (type $ly@@585) LayerTypeType) (= (type |run#0@@161|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@161|) ($Is |run#0@@161| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@155| Int) (|j#0@@18| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@155|) (=> (INTERNAL_le_boogie |i#0@@155| |j#0@@18|) (=> (INTERNAL_lt_boogie |j#0@@18| (|Seq#Length| |run#0@@161|)) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@155|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@18|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |4501|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@18|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@155|)))
)) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@585) |run#0@@161|) (forall ((|i#0@@156| Int) (|j#0@@19| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@156|) (INTERNAL_le_boogie |i#0@@156| |j#0@@19|)) (INTERNAL_lt_boogie |j#0@@19| (|Seq#Length| |run#0@@161|))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@156|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@19|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |4500|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |j#0@@19|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@161| |i#0@@156|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :skolemid |4502|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@585) |run#0@@161|))
))))
(assert  (=> true (forall (($ly@@586 T@U) (|run#0@@162| T@U) ) (!  (=> (and (and (= (type $ly@@586) LayerTypeType) (= (type |run#0@@162|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@162|)) ($Is |run#0@@162| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1@@50| Int) (|j#1@@7| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@50|) (=> (INTERNAL_le_boogie |i#1@@50| |j#1@@7|) (=> (INTERNAL_lt_boogie |j#1@@7| (|Seq#Length| (Lit |run#0@@162|))) (|Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |i#1@@50|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |j#1@@7|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |4504|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |j#1@@7|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |i#1@@50|)))
)) (= (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@586) (Lit |run#0@@162|)) (forall ((|i#1@@51| Int) (|j#1@@8| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@51|) (INTERNAL_le_boogie |i#1@@51| |j#1@@8|)) (INTERNAL_lt_boogie |j#1@@8| (|Seq#Length| (Lit |run#0@@162|)))) (Lexicographic__Byte__Order.__default.lte ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |i#1@@51|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@162|) |j#1@@8|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.66:12|
 :skolemid |4503|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |j#1@@8|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@162| |i#1@@51|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.62:23|
 :weight 3
 :skolemid |4505|
 :pattern ( (Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@586) (Lit |run#0@@162|)))
))))
(assert  (=> true (forall ((|run#0@@163| T@U) ) (!  (=> (and (= (type |run#0@@163|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@163|) ($Is |run#0@@163| (TSeq (TSeq Tclass.NativeTypes.byte))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |4506|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@163|))
))))
(assert (forall ((|run#0@@164| T@U) ) (!  (=> (and (= (type |run#0@@164|) (SeqType BoxType)) ($Is |run#0@@164| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@164|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |4507|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@164|))
)))
(assert  (=> true (forall ((|run#0@@165| T@U) ) (!  (=> (and (= (type |run#0@@165|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@165|) ($Is |run#0@@165| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#0@@157| Int) (|j#0@@20| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@157|) (=> (INTERNAL_lt_boogie |i#0@@157| |j#0@@20|) (=> (INTERNAL_lt_boogie |j#0@@20| (|Seq#Length| |run#0@@165|)) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@157|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@20|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |4509|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@20|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@157|)))
)) (= (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@165|) (forall ((|i#0@@158| Int) (|j#0@@21| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@158|) (INTERNAL_lt_boogie |i#0@@158| |j#0@@21|)) (INTERNAL_lt_boogie |j#0@@21| (|Seq#Length| |run#0@@165|))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@158|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@21|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |4508|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |j#0@@21|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@165| |i#0@@158|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :skolemid |4510|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@165|))
))))
(assert  (=> true (forall ((|run#0@@166| T@U) ) (!  (=> (and (= (type |run#0@@166|) (SeqType BoxType)) (or (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@166|)) ($Is |run#0@@166| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (forall ((|i#1@@52| Int) (|j#1@@9| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@52|) (=> (INTERNAL_lt_boogie |i#1@@52| |j#1@@9|) (=> (INTERNAL_lt_boogie |j#1@@9| (|Seq#Length| (Lit |run#0@@166|))) (|Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |i#1@@52|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |j#1@@9|))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |4512|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |j#1@@9|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |i#1@@52|)))
)) (= (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@166|)) (forall ((|i#1@@53| Int) (|j#1@@10| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@53|) (INTERNAL_lt_boogie |i#1@@53| |j#1@@10|)) (INTERNAL_lt_boogie |j#1@@10| (|Seq#Length| (Lit |run#0@@166|)))) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |i#1@@53|)) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |run#0@@166|) |j#1@@10|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.71:12|
 :skolemid |4511|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |j#1@@10|)) ($Unbox (SeqType BoxType) (|Seq#Index| |run#0@@166| |i#1@@53|)))
)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.69:38|
 :weight 3
 :skolemid |4513|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@166|)))
))))
(assert (forall (($ly@@587 T@U) (|run#0@@167| T@U) ) (!  (=> (and (= (type $ly@@587) LayerTypeType) (= (type |run#0@@167|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@587) |run#0@@167|) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@587 |run#0@@167|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |4514|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@587) |run#0@@167|))
)))
(assert (forall (($ly@@588 T@U) (|run#0@@168| T@U) ) (!  (=> (and (= (type $ly@@588) LayerTypeType) (= (type |run#0@@168|) (SeqType BoxType))) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@588 |run#0@@168|) (Lexicographic__Byte__Order.__default.IsStrictlySorted $LZ |run#0@@168|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |4515|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@588) |run#0@@168|))
)))
(assert  (=> true (forall (($ly@@589 T@U) (|run#0@@169| T@U) ) (!  (=> (and (and (= (type $ly@@589) LayerTypeType) (= (type |run#0@@169|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@169|) ($Is |run#0@@169| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (and (=> (= (|Seq#Length| |run#0@@169|) (LitInt 0)) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@589 |run#0@@169|)) (=> (= (|Seq#Length| |run#0@@169|) (LitInt 1)) (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@589 |run#0@@169|))) (=> (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@589 |run#0@@169|) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted |run#0@@169|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |4516|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@589 |run#0@@169|))
))))
(assert (forall (($ly@@590 T@U) (|run#0@@170| T@U) ) (!  (=> (and (and (= (type $ly@@590) LayerTypeType) (= (type |run#0@@170|) (SeqType BoxType))) ($Is |run#0@@170| (TSeq (TSeq Tclass.NativeTypes.byte)))) (= (|Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@590 |run#0@@170|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |4517|
 :pattern ( (|Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@590 |run#0@@170|))
)))
(assert  (=> true (forall (($ly@@591 T@U) (|run#0@@171| T@U) ) (!  (=> (and (and (= (type $ly@@591) LayerTypeType) (= (type |run#0@@171|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@171|) ($Is |run#0@@171| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@171|) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@591) |run#0@@171|) (let ((|b#0@@131| (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@171|)))
(ite |b#0@@131| |b#0@@131| |b#0@@131|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :skolemid |4518|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@591) |run#0@@171|))
))))
(assert  (=> true (forall (($ly@@592 T@U) (|run#0@@172| T@U) ) (!  (=> (and (and (= (type $ly@@592) LayerTypeType) (= (type |run#0@@172|) (SeqType BoxType))) (or (|Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@172|)) ($Is |run#0@@172| (TSeq (TSeq Tclass.NativeTypes.byte))))) (and (|Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@172|)) (= (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@592) (Lit |run#0@@172|)) (let ((|b#1@@6| (U_2_bool (Lit (bool_2_U (Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@172|)))))))
(ite |b#1@@6| |b#1@@6| |b#1@@6|)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.85:23|
 :weight 3
 :skolemid |4519|
 :pattern ( (Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@592) (Lit |run#0@@172|)))
))))
(assert  (=> true (forall ((|e#0@@10| T@U) (|s#0@@247| T@U) ) (!  (=> (and (and (= (type |e#0@@10|) (SeqType BoxType)) (= (type |s#0@@247|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@10| |s#0@@247|) (and (and ($Is |e#0@@10| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@247| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@247|))))) true)
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |4520|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@10| |s#0@@247|))
))))
(assert (forall ((|e#0@@11| T@U) (|s#0@@248| T@U) ) (!  (=> (and (and (= (type |e#0@@11|) (SeqType BoxType)) (= (type |s#0@@248|) (MapType0Type BoxType boolType))) (and ($Is |e#0@@11| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@248| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@11| |s#0@@248|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@248|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |4521|
 :pattern ( (|Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@11| |s#0@@248|))
)))
(assert  (=> true (forall ((|e#0@@12| T@U) (|s#0@@249| T@U) ) (!  (=> (and (and (= (type |e#0@@12|) (SeqType BoxType)) (= (type |s#0@@249|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@12| |s#0@@249|) (and (and ($Is |e#0@@12| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@249| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@249|))))) (and (=> (U_2_bool (MapType0Select |s#0@@249| ($Box |e#0@@12|))) (forall ((|e2#0@@1| T@U) ) (!  (=> (and (and (= (type |e2#0@@1|) (SeqType BoxType)) ($Is |e2#0@@1| (TSeq Tclass.NativeTypes.byte))) (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e2#0@@1|))) (not (|Seq#Equal| |e2#0@@1| |e#0@@12|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |e2#0@@1| |e#0@@12|))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |4523|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#0@@1| |e#0@@12|))
 :pattern ( (MapType0Select |s#0@@249| ($Box |e2#0@@1|)))
))) (= (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@12| |s#0@@249|)  (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e#0@@12|))) (forall ((|e2#0@@2| T@U) ) (!  (=> (= (type |e2#0@@2|) (SeqType BoxType)) (=> (and ($Is |e2#0@@2| (TSeq Tclass.NativeTypes.byte)) (and (U_2_bool (MapType0Select |s#0@@249| ($Box |e2#0@@2|))) (not (|Seq#Equal| |e2#0@@2| |e#0@@12|)))) (Lexicographic__Byte__Order.__default.lt |e2#0@@2| |e#0@@12|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |4522|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#0@@2| |e#0@@12|))
 :pattern ( (MapType0Select |s#0@@249| ($Box |e2#0@@2|)))
))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :skolemid |4524|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@12| |s#0@@249|))
))))
(assert  (=> true (forall ((|e#0@@13| T@U) (|s#0@@250| T@U) ) (!  (=> (and (and (= (type |e#0@@13|) (SeqType BoxType)) (= (type |s#0@@250|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (Lit |e#0@@13|) (Lit |s#0@@250|)) (and (and ($Is |e#0@@13| (TSeq Tclass.NativeTypes.byte)) ($Is |s#0@@250| (TSet (TSeq Tclass.NativeTypes.byte)))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@250|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box (Lit |e#0@@13|)))) (forall ((|e2#1@@1| T@U) ) (!  (=> (and (and (= (type |e2#1@@1|) (SeqType BoxType)) ($Is |e2#1@@1| (TSeq Tclass.NativeTypes.byte))) (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box |e2#1@@1|))) (not (|Seq#Equal| |e2#1@@1| |e#0@@13|)))) (|Lexicographic__Byte__Order.__default.lt#canCall| |e2#1@@1| (Lit |e#0@@13|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |4526|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#1@@1| |e#0@@13|))
 :pattern ( (MapType0Select |s#0@@250| ($Box |e2#1@@1|)))
))) (= (Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@13|) (Lit |s#0@@250|))  (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box (Lit |e#0@@13|)))) (forall ((|e2#1@@2| T@U) ) (!  (=> (= (type |e2#1@@2|) (SeqType BoxType)) (=> (and ($Is |e2#1@@2| (TSeq Tclass.NativeTypes.byte)) (and (U_2_bool (MapType0Select (Lit |s#0@@250|) ($Box |e2#1@@2|))) (not (|Seq#Equal| |e2#1@@2| |e#0@@13|)))) (Lexicographic__Byte__Order.__default.lt |e2#1@@2| (Lit |e#0@@13|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.208:22|
 :skolemid |4525|
 :pattern ( (Lexicographic__Byte__Order.__default.lt |e2#1@@2| |e#0@@13|))
 :pattern ( (MapType0Select |s#0@@250| ($Box |e2#1@@2|)))
))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.205:26|
 :weight 3
 :skolemid |4527|
 :pattern ( (Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@13|) (Lit |s#0@@250|)))
))))
(assert (forall ((arg0@@624 T@U) (arg1@@326 T@U) ) (! (= (type (Lexicographic__Byte__Order.__default.SortSet arg0@@624 arg1@@326)) (SeqType BoxType))
 :qid |funType:Lexicographic__Byte__Order.__default.SortSet|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet arg0@@624 arg1@@326))
)))
(assert (forall (($ly@@593 T@U) (|s#0@@251| T@U) ) (!  (=> (and (= (type $ly@@593) LayerTypeType) (= (type |s#0@@251|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@593) |s#0@@251|) (Lexicographic__Byte__Order.__default.SortSet $ly@@593 |s#0@@251|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |4528|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@593) |s#0@@251|))
)))
(assert (forall (($ly@@594 T@U) (|s#0@@252| T@U) ) (!  (=> (and (= (type $ly@@594) LayerTypeType) (= (type |s#0@@252|) (MapType0Type BoxType boolType))) (= (Lexicographic__Byte__Order.__default.SortSet $ly@@594 |s#0@@252|) (Lexicographic__Byte__Order.__default.SortSet $LZ |s#0@@252|)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |4529|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet (AsFuelBottom $ly@@594) |s#0@@252|))
)))
(assert  (=> true (forall (($ly@@595 T@U) (|s#0@@253| T@U) ) (!  (=> (and (and (= (type $ly@@595) LayerTypeType) (= (type |s#0@@253|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@253|) ($Is |s#0@@253| (TSet (TSeq Tclass.NativeTypes.byte))))) (and (and (and (= (|Set#Card| |s#0@@253|) (|Seq#Length| (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|))) (forall ((|t#0@@14| T@U) ) (!  (=> (and (= (type |t#0@@14|) (SeqType BoxType)) ($Is |t#0@@14| (TSeq Tclass.NativeTypes.byte))) (= (U_2_bool (MapType0Select |s#0@@253| ($Box |t#0@@14|))) (|Seq#Contains| (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|) ($Box |t#0@@14|))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.239:20|
 :skolemid |4530|
 :pattern ( (|Seq#Contains| (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|) ($Box |t#0@@14|)))
 :pattern ( (MapType0Select |s#0@@253| ($Box |t#0@@14|)))
))) (Lexicographic__Byte__Order.__default.IsSorted StartFuel_Lexicographic_Byte_Order._default.IsSorted (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|))) ($Is (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|) (TSeq (TSeq Tclass.NativeTypes.byte)))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |4531|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet $ly@@595 |s#0@@253|))
))))
(assert (forall (($ly@@596 T@U) ($Heap@@84 T@U) (|s#0@@254| T@U) ) (!  (=> (and (and (and (= (type $ly@@596) LayerTypeType) (= (type $Heap@@84) (MapType0Type refType MapType1Type))) (= (type |s#0@@254|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@84) ($Is |s#0@@254| (TSet (TSeq Tclass.NativeTypes.byte))))) (= (|Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@596 |s#0@@254|) true))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |4532|
 :pattern ( (|Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@596 |s#0@@254|) ($IsGoodHeap $Heap@@84))
)))
(assert (forall ((arg0@@625 T@U) ) (! (= (type (|$let#40_e| arg0@@625)) (SeqType BoxType))
 :qid |funType:$let#40_e|
 :pattern ( (|$let#40_e| arg0@@625))
)))
(assert (forall ((s@@56 T@U) ) (!  (=> (and (= (type s@@56) (MapType0Type BoxType boolType)) (|$let#40$canCall| s@@56)) (and ($Is (|$let#40_e| s@@56) (TSeq Tclass.NativeTypes.byte)) (Lexicographic__Byte__Order.__default.BiggestInSet (|$let#40_e| s@@56) s@@56)))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.249:7|
 :skolemid |4533|
 :pattern ( (|$let#40_e| s@@56))
)))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@597 T@U) ($Heap@@85 T@U) (|s#0@@255| T@U) ) (!  (=> (and (and (and (= (type $ly@@597) LayerTypeType) (= (type $Heap@@85) (MapType0Type refType MapType1Type))) (= (type |s#0@@255|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@255|) (and ($IsGoodHeap $Heap@@85) ($Is |s#0@@255| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (=> (not (= (|Set#Card| |s#0@@255|) (LitInt 0))) (and (|$let#40$canCall| |s#0@@255|) (|Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@255| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#40_e| |s#0@@255|))))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted6) MoreFuel_Lexicographic_Byte_Order._default.IsSorted6)) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@597) |s#0@@255|) (ite (= (|Set#Card| |s#0@@255|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@14| (|$let#40_e| |s#0@@255|)))
(|Seq#Append| (Lexicographic__Byte__Order.__default.SortSet $ly@@597 (|Set#Difference| |s#0@@255| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#0@@14|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#0@@14|)))))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :skolemid |4534|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@597) |s#0@@255|) ($IsGoodHeap $Heap@@85))
))))
(assert (= (type MoreFuel_Lexicographic_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@598 T@U) ($Heap@@86 T@U) (|s#0@@256| T@U) ) (!  (=> (and (and (and (= (type $ly@@598) LayerTypeType) (= (type $Heap@@86) (MapType0Type refType MapType1Type))) (= (type |s#0@@256|) (MapType0Type BoxType boolType))) (or (|Lexicographic__Byte__Order.__default.SortSet#canCall| (Lit |s#0@@256|)) (and ($IsGoodHeap $Heap@@86) ($Is |s#0@@256| (TSet (TSeq Tclass.NativeTypes.byte)))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@256|)) (LitInt 0))) (and (|$let#40$canCall| (Lit |s#0@@256|)) (|Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@256| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#40_e| (Lit |s#0@@256|)))))))) (and (and (and (= StartFuel_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Lexicographic_Byte_Order._default.IsSorted7) MoreFuel_Lexicographic_Byte_Order._default.IsSorted7)) (= (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@598) (Lit |s#0@@256|)) (ite (= (|Set#Card| (Lit |s#0@@256|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@1| (|$let#40_e| (Lit |s#0@@256|))))
(|Seq#Append| (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@598) (|Set#Difference| |s#0@@256| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#1@@1|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#1@@1|)))))))))
 :qid |totalorderidfyTotalOrderLexicographicByteOrder.237:12|
 :weight 3
 :skolemid |4535|
 :pattern ( (Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@598) (Lit |s#0@@256|)) ($IsGoodHeap $Heap@@86))
))))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order.__default) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order.__default) Tagclass.Upperbounded__Lexicographic__Byte__Order.__default))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order.__default) tytagFamily$_default))
(assert (forall ((bx@@167 T@U) ) (!  (=> (and (= (type bx@@167) BoxType) ($IsBox bx@@167 Tclass.Upperbounded__Lexicographic__Byte__Order.__default)) (and (= ($Box ($Unbox refType bx@@167)) bx@@167) ($Is ($Unbox refType bx@@167) Tclass.Upperbounded__Lexicographic__Byte__Order.__default)))
 :qid |unknown.0:0|
 :skolemid |4536|
 :pattern ( ($IsBox bx@@167 Tclass.Upperbounded__Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@61 T@U) ) (!  (=> (= (type $o@@61) refType) (= ($Is $o@@61 Tclass.Upperbounded__Lexicographic__Byte__Order.__default)  (or (= $o@@61 null) (= (dtype $o@@61) Tclass.Upperbounded__Lexicographic__Byte__Order.__default))))
 :qid |unknown.0:0|
 :skolemid |4537|
 :pattern ( ($Is $o@@61 Tclass.Upperbounded__Lexicographic__Byte__Order.__default))
)))
(assert (forall (($o@@62 T@U) ($h@@162 T@U) ) (!  (=> (and (= (type $o@@62) refType) (= (type $h@@162) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@62 Tclass.Upperbounded__Lexicographic__Byte__Order.__default $h@@162)  (or (= $o@@62 null) (U_2_bool (MapType1Select (MapType0Select $h@@162 $o@@62) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4538|
 :pattern ( ($IsAlloc $o@@62 Tclass.Upperbounded__Lexicographic__Byte__Order.__default $h@@162))
)))
(assert  (=> true (forall ((|b#0@@132| T@U) ) (!  (=> (and (= (type |b#0@@132|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@132|) ($Is |b#0@@132| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |totalorderidfy.1212:31|
 :skolemid |4539|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@132|))
))))
(assert (forall ((|b#0@@133| T@U) ) (!  (=> (and (= (type |b#0@@133|) DatatypeTypeType) ($Is |b#0@@133| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@133|) true))
 :qid |totalorderidfy.1212:31|
 :skolemid |4540|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#requires| |b#0@@133|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType))
(assert  (=> true (forall ((|b#0@@134| T@U) ) (!  (=> (and (= (type |b#0@@134|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| |b#0@@134|) ($Is |b#0@@134| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@134|) (=> (= (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@134|)) (LitInt 0)) (forall ((|a#0@@181| T@U) ) (!  (=> (and (= (type |a#0@@181|) DatatypeTypeType) ($Is |a#0@@181| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@181|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@181|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@134| |a#0@@181|))))
 :qid |totalorderidfy.1216:16|
 :skolemid |4542|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@181|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@181|))
)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@134|)  (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@134|) (= (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@134|)) (LitInt 0))) (forall ((|a#0@@182| T@U) ) (!  (=> (= (type |a#0@@182|) DatatypeTypeType) (=> (and ($Is |a#0@@182| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@182|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@182|)))
 :qid |totalorderidfy.1216:16|
 :skolemid |4541|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@134| |a#0@@182|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#0@@182|))
))))))
 :qid |totalorderidfy.1212:31|
 :skolemid |4543|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |b#0@@134|))
))))
(assert  (=> true (forall ((|b#0@@135| T@U) ) (!  (=> (and (= (type |b#0@@135|) DatatypeTypeType) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement#canCall| (Lit |b#0@@135|)) ($Is |b#0@@135| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@135|))))) (=> (= (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@135|)))) (LitInt 0)) (forall ((|a#1@@6| T@U) ) (!  (=> (and (= (type |a#1@@6|) DatatypeTypeType) ($Is |a#1@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#1@@6|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@6|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |b#0@@135|) |a#1@@6|))))
 :qid |totalorderidfy.1216:16|
 :skolemid |4545|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@135| |a#1@@6|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@6|))
)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@135|))  (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@135|)) (= (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@135|)))) (LitInt 0))) (forall ((|a#1@@7| T@U) ) (!  (=> (= (type |a#1@@7|) DatatypeTypeType) (=> (and ($Is |a#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@7|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |b#0@@135|) |a#1@@7|)))
 :qid |totalorderidfy.1216:16|
 :skolemid |4544|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@135| |a#1@@7|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum |a#1@@7|))
))))))
 :qid |totalorderidfy.1212:31|
 :weight 3
 :skolemid |4546|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement (Lit |b#0@@135|)))
))))
(assert (= (type Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) DatatypeTypeType))
(assert  (=> true (=> true (and (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) ($Is Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))))
(assert (forall (($Heap@@87 T@U) ) (!  (=> (and (= (type $Heap@@87) (MapType0Type refType MapType1Type)) ($IsGoodHeap $Heap@@87)) (= |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| true))
 :qid |totalorderidfy.1247:12|
 :skolemid |4547|
 :pattern ( |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#requires| ($IsGoodHeap $Heap@@87))
)))
(assert (= (type |$let#43_b|) DatatypeTypeType))
(assert  (=> |$let#43$canCall| (and ($Is |$let#43_b| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.IsSmallestElement |$let#43_b|))))
(assert  (=> true (forall (($Heap@@88 T@U) ) (!  (=> (and (= (type $Heap@@88) (MapType0Type refType MapType1Type)) (or |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@88))) (and |$let#43$canCall| (= Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#0@@136| |$let#43_b|))
|b#0@@136|))))
 :qid |totalorderidfy.1247:12|
 :skolemid |4548|
 :pattern ( Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@88))
))))
(assert  (=> true (forall (($Heap@@89 T@U) ) (!  (=> (and (= (type $Heap@@89) (MapType0Type refType MapType1Type)) (or |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| ($IsGoodHeap $Heap@@89))) (and |$let#43$canCall| (= Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement (let ((|b#1@@7| |$let#43_b|))
|b#1@@7|))))
 :qid |totalorderidfy.1247:12|
 :weight 3
 :skolemid |4549|
 :pattern ( Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement ($IsGoodHeap $Heap@@89))
))))
(assert (= (type Upperbounded__Lexicographic__Byte__Order.__default.SomeElement) DatatypeTypeType))
(assert  (=> true (=> true ($Is Upperbounded__Lexicographic__Byte__Order.__default.SomeElement Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
(assert (= |Upperbounded__Lexicographic__Byte__Order.__default.SomeElement#requires| true))
(assert (= (type |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) DatatypeTypeType))
(assert  (=> true (=> true (= Upperbounded__Lexicographic__Byte__Order.__default.SomeElement (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
(assert  (=> true (=> true (= Upperbounded__Lexicographic__Byte__Order.__default.SomeElement (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
(assert (forall ((arg0@@626 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.ToElements arg0@@626)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.ToElements|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements arg0@@626))
)))
(assert  (=> true (forall ((|es#0| T@U) ) (!  (=> (and (= (type |es#0|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| |es#0|) ($Is |es#0| (TSeq (TSeq Tclass.NativeTypes.byte))))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:23|
 :skolemid |4550|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0|))
))))
(assert (forall (($Heap@@90 T@U) (|es#0@@0| T@U) ) (!  (=> (and (and (= (type $Heap@@90) (MapType0Type refType MapType1Type)) (= (type |es#0@@0|) (SeqType BoxType))) (and ($IsGoodHeap $Heap@@90) ($Is |es#0@@0| (TSeq (TSeq Tclass.NativeTypes.byte))))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| |es#0@@0|) true))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :skolemid |4551|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#requires| |es#0@@0|) ($IsGoodHeap $Heap@@90))
)))
(assert (forall ((arg0@@627 T@U) ) (! (= (type (|lambda#315| arg0@@627)) (MapType2Type (MapType0Type refType MapType1Type) BoxType BoxType))
 :qid |funType:lambda#315|
 :pattern ( (|lambda#315| arg0@@627))
)))
(assert  (=> true (forall (($Heap@@91 T@U) (|es#0@@1| T@U) ) (!  (=> (and (and (= (type $Heap@@91) (MapType0Type refType MapType1Type)) (= (type |es#0@@1|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| |es#0@@1|) (and ($IsGoodHeap $Heap@@91) ($Is |es#0@@1| (TSeq (TSeq Tclass.NativeTypes.byte)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0@@1|) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@91 (|Seq#Length| |es#0@@1|) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#315| |es#0@@1|) (|lambda#128| TInt 0 (|Seq#Length| |es#0@@1|)) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :skolemid |4552|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements |es#0@@1|) ($IsGoodHeap $Heap@@91))
))))
(assert  (=> true (forall (($Heap@@92 T@U) (|es#0@@2| T@U) ) (!  (=> (and (and (= (type $Heap@@92) (MapType0Type refType MapType1Type)) (= (type |es#0@@2|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ToElements#canCall| (Lit |es#0@@2|)) (and ($IsGoodHeap $Heap@@92) ($Is |es#0@@2| (TSeq (TSeq Tclass.NativeTypes.byte)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ToElements (Lit |es#0@@2|)) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@92 (|Seq#Length| (Lit |es#0@@2|)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#315| (Lit |es#0@@2|)) (|lambda#128| TInt 0 (|Seq#Length| (Lit |es#0@@2|))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:12|
 :weight 3
 :skolemid |4553|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ToElements (Lit |es#0@@2|)) ($IsGoodHeap $Heap@@92))
))))
(assert  (=> true (forall ((|a#0@@183| T@U) (|b#0@@137| T@U) ) (!  (=> (and (and (= (type |a#0@@183|) DatatypeTypeType) (= (type |b#0@@137|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@183| |b#0@@137|) (and ($Is |a#0@@183| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@137| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (and (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|)) (or (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|))) (or (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|))) (=> (and (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@183| |b#0@@137|) (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |b#0@@137| |a#0@@183|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@183| |b#0@@137|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |4554|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@183| |b#0@@137|))
))))
(assert (forall ((|a#0@@184| T@U) (|b#0@@138| T@U) ) (!  (=> (and (and (= (type |a#0@@184|) DatatypeTypeType) (= (type |b#0@@138|) DatatypeTypeType)) (and ($Is |a#0@@184| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@138| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| |a#0@@184| |b#0@@138|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |4555|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.lte#requires| |a#0@@184| |b#0@@138|))
)))
(assert  (=> true (forall ((|a#0@@185| T@U) (|b#0@@139| T@U) ) (!  (=> (and (and (= (type |a#0@@185|) DatatypeTypeType) (= (type |b#0@@139|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@185| |b#0@@139|) (and ($Is |a#0@@185| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@139| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@139|)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@185|) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@139|) (|Lexicographic__Byte__Order.__default.lte#canCall| (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@139|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@185| |b#0@@139|)  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@139|) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@139|)) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@185|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@139|)))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :skolemid |4556|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@185| |b#0@@139|))
))))
(assert  (=> true (forall ((|a#0@@186| T@U) (|b#0@@140| T@U) ) (!  (=> (and (and (= (type |a#0@@186|) DatatypeTypeType) (= (type |b#0@@140|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@186|) (Lit |b#0@@140|)) (and ($Is |a#0@@186| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@140| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@140|)))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@186|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@140|))))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@186|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@140|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@186|) (Lit |b#0@@140|)) (U_2_bool (Lit (bool_2_U  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@140|)) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@186|)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@140|))) (Lexicographic__Byte__Order.__default.lte (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@186|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@140|))))))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.25:17|
 :weight 3
 :skolemid |4557|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@186|) (Lit |b#0@@140|)))
))))
(assert  (=> true (forall ((|a#0@@187| T@U) (|b#0@@141| T@U) ) (!  (=> (and (and (= (type |a#0@@187|) DatatypeTypeType) (= (type |b#0@@141|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@187| |b#0@@141|) (and ($Is |a#0@@187| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@141| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |4558|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@187| |b#0@@141|))
))))
(assert (forall ((|a#0@@188| T@U) (|b#0@@142| T@U) ) (!  (=> (and (and (= (type |a#0@@188|) DatatypeTypeType) (= (type |b#0@@142|) DatatypeTypeType)) (and ($Is |a#0@@188| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@142| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@188| |b#0@@142|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |4559|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#requires| |a#0@@188| |b#0@@142|))
)))
(assert  (=> true (forall ((|a#0@@189| T@U) (|b#0@@143| T@U) ) (!  (=> (and (and (= (type |a#0@@189|) DatatypeTypeType) (= (type |b#0@@143|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| |a#0@@189| |b#0@@143|) (and ($Is |a#0@@189| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@143| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@143|)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@189|) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@143|) (|Lexicographic__Byte__Order.__default.lte#canCall| (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@143|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@189| |b#0@@143|)  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q |b#0@@143|) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |b#0@@143|)) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e |a#0@@189|) (Upperbounded__Lexicographic__Byte__Order.Element.e |b#0@@143|)))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :skolemid |4560|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef |a#0@@189| |b#0@@143|))
))))
(assert  (=> true (forall ((|a#0@@190| T@U) (|b#0@@144| T@U) ) (!  (=> (and (and (= (type |a#0@@190|) DatatypeTypeType) (= (type |b#0@@144|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.ltedef#canCall| (Lit |a#0@@190|) (Lit |b#0@@144|)) (and ($Is |a#0@@190| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@144| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@144|)))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@190|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@144|))))) (|Lexicographic__Byte__Order.__default.lte#canCall| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@190|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@144|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@190|) (Lit |b#0@@144|)) (U_2_bool (Lit (bool_2_U  (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (Lit |b#0@@144|)) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |a#0@@190|)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |b#0@@144|))) (Lexicographic__Byte__Order.__default.lte (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |a#0@@190|))) (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |b#0@@144|))))))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.23:20|
 :weight 3
 :skolemid |4561|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.ltedef (Lit |a#0@@190|) (Lit |b#0@@144|)))
))))
(assert (forall (($ly@@599 T@U) (|run#0@@173| T@U) (|needle#0@@69| T@U) ) (!  (=> (and (and (= (type $ly@@599) LayerTypeType) (= (type |run#0@@173|) (SeqType BoxType))) (= (type |needle#0@@69|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@599) |run#0@@173| |needle#0@@69|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@599 |run#0@@173| |needle#0@@69|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |4562|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@599) |run#0@@173| |needle#0@@69|))
)))
(assert (forall (($ly@@600 T@U) (|run#0@@174| T@U) (|needle#0@@70| T@U) ) (!  (=> (and (and (= (type $ly@@600) LayerTypeType) (= (type |run#0@@174|) (SeqType BoxType))) (= (type |needle#0@@70|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@600 |run#0@@174| |needle#0@@70|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $LZ |run#0@@174| |needle#0@@70|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |4563|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn (AsFuelBottom $ly@@600) |run#0@@174| |needle#0@@70|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType))
(assert  (=> true (forall (($ly@@601 T@U) (|run#0@@175| T@U) (|needle#0@@71| T@U) ) (!  (=> (and (and (and (= (type $ly@@601) LayerTypeType) (= (type |run#0@@175|) (SeqType BoxType))) (= (type |needle#0@@71|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@175| |needle#0@@71|) (and (and ($Is |run#0@@175| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@71| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@175|)))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |4564|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@601 |run#0@@175| |needle#0@@71|))
))))
(assert (forall (($ly@@602 T@U) (|run#0@@176| T@U) (|needle#0@@72| T@U) ) (!  (=> (and (and (and (= (type $ly@@602) LayerTypeType) (= (type |run#0@@176|) (SeqType BoxType))) (= (type |needle#0@@72|) DatatypeTypeType)) (and ($Is |run#0@@176| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@72| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@602 |run#0@@176| |needle#0@@72|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@176|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |4565|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#requires| $ly@@602 |run#0@@176| |needle#0@@72|))
)))
(assert  (=> true (forall (($ly@@603 T@U) (|run#0@@177| T@U) (|needle#0@@73| T@U) ) (!  (=> (and (and (and (= (type $ly@@603) LayerTypeType) (= (type |run#0@@177|) (SeqType BoxType))) (= (type |needle#0@@73|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@177| |needle#0@@73|) (and (and ($Is |run#0@@177| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@73| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@177|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@177|) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@177|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (|Seq#Drop| |run#0@@177| (LitInt 1)) |needle#0@@73|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@603) |run#0@@177| |needle#0@@73|) (ite  (or (= (|Seq#Length| |run#0@@177|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@73| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@177| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn $ly@@603 (|Seq#Drop| |run#0@@177| (LitInt 1)) |needle#0@@73|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :skolemid |4566|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@603) |run#0@@177| |needle#0@@73|))
))))
(assert  (=> true (forall (($ly@@604 T@U) (|run#0@@178| T@U) (|needle#0@@74| T@U) ) (!  (=> (and (and (and (= (type $ly@@604) LayerTypeType) (= (type |run#0@@178|) (SeqType BoxType))) (= (type |needle#0@@74|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@178|) (Lit |needle#0@@74|)) (and (and ($Is |run#0@@178| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@74| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@178|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit (|Seq#Drop| (Lit |run#0@@178|) (LitInt 1))) (Lit |needle#0@@74|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@604) (Lit |run#0@@178|) (Lit |needle#0@@74|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@178|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |needle#0@@74|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@178|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@604) (Lit (|Seq#Drop| (Lit |run#0@@178|) (LitInt 1))) (Lit |needle#0@@74|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.333:12|
 :weight 3
 :skolemid |4567|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $ly@@604) (Lit |run#0@@178|) (Lit |needle#0@@74|)))
))))
(assert  (=> true (forall ((|run#0@@179| T@U) (|needle#0@@75| T@U) ) (!  (=> (and (and (= (type |run#0@@179|) (SeqType BoxType)) (= (type |needle#0@@75|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@179| |needle#0@@75|) (and (and ($Is |run#0@@179| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@75| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@179|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|) (|Seq#Length| |run#0@@179|))) (forall ((|i#0@@159| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@159|) (INTERNAL_le_boogie |i#0@@159| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#0@@159|)) |needle#0@@75|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.362:20|
 :skolemid |4568|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#0@@159|)))
))) (forall ((|i#1@@54| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|) |i#1@@54|) (INTERNAL_lt_boogie |i#1@@54| (|Seq#Length| |run#0@@179|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@75| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#1@@54|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.363:20|
 :skolemid |4569|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| |i#1@@54|)))
))) (=> (|Seq#Contains| |run#0@@179| ($Box |needle#0@@75|)) (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@179| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))) |needle#0@@75|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |4570|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@179| |needle#0@@75|))
))))
(assert (forall ((|run#0@@180| T@U) (|needle#0@@76| T@U) ) (!  (=> (and (and (= (type |run#0@@180|) (SeqType BoxType)) (= (type |needle#0@@76|) DatatypeTypeType)) (and ($Is |run#0@@180| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@76| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@180| |needle#0@@76|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@180|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |4571|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#requires| |run#0@@180| |needle#0@@76|))
)))
(assert  (=> true (forall ((|run#0@@181| T@U) (|needle#0@@77| T@U) ) (!  (=> (and (and (= (type |run#0@@181|) (SeqType BoxType)) (= (type |needle#0@@77|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |run#0@@181| |needle#0@@77|) (and (and ($Is |run#0@@181| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@77| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@181|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| |run#0@@181| |needle#0@@77|) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@181| |needle#0@@77|) (let ((|out#0@@4| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) |run#0@@181| |needle#0@@77|)))
|out#0@@4|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :skolemid |4572|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |run#0@@181| |needle#0@@77|))
))))
(assert  (=> true (forall ((|run#0@@182| T@U) (|needle#0@@78| T@U) ) (!  (=> (and (and (= (type |run#0@@182|) (SeqType BoxType)) (= (type |needle#0@@78|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |run#0@@182|) (Lit |needle#0@@78|)) (and (and ($Is |run#0@@182| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@78| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@182|))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn#canCall| (Lit |run#0@@182|) (Lit |needle#0@@78|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@182|) (Lit |needle#0@@78|)) (let ((|out#1@@3| (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLteDefn ($LS $LZ) (Lit |run#0@@182|) (Lit |needle#0@@78|)))))
|out#1@@3|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.359:23|
 :weight 3
 :skolemid |4573|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |run#0@@182|) (Lit |needle#0@@78|)))
))))
(assert (forall (($ly@@605 T@U) (|run#0@@183| T@U) (|needle#0@@79| T@U) ) (!  (=> (and (and (= (type $ly@@605) LayerTypeType) (= (type |run#0@@183|) (SeqType BoxType))) (= (type |needle#0@@79|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@605) |run#0@@183| |needle#0@@79|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@605 |run#0@@183| |needle#0@@79|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |4574|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@605) |run#0@@183| |needle#0@@79|))
)))
(assert (forall (($ly@@606 T@U) (|run#0@@184| T@U) (|needle#0@@80| T@U) ) (!  (=> (and (and (= (type $ly@@606) LayerTypeType) (= (type |run#0@@184|) (SeqType BoxType))) (= (type |needle#0@@80|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@606 |run#0@@184| |needle#0@@80|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $LZ |run#0@@184| |needle#0@@80|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |4575|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt (AsFuelBottom $ly@@606) |run#0@@184| |needle#0@@80|))
)))
(assert  (=> true (forall (($ly@@607 T@U) (|run#0@@185| T@U) (|needle#0@@81| T@U) ) (!  (=> (and (and (and (= (type $ly@@607) LayerTypeType) (= (type |run#0@@185|) (SeqType BoxType))) (= (type |needle#0@@81|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@185| |needle#0@@81|) (and (and ($Is |run#0@@185| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@81| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@185|)))) (and (and (and (and (INTERNAL_le_boogie (- 0 1) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|) (|Seq#Length| |run#0@@185|))) (forall ((|i#0@@160| Int) ) (!  (=> true (=> (and (INTERNAL_le_boogie 0 |i#0@@160|) (INTERNAL_le_boogie |i#0@@160| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#0@@160|)) |needle#0@@81|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.461:20|
 :skolemid |4576|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#0@@160|)))
))) (forall ((|i#1@@55| Int) ) (!  (=> true (=> (and (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|) |i#1@@55|) (INTERNAL_lt_boogie |i#1@@55| (|Seq#Length| |run#0@@185|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@81| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#1@@55|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.462:20|
 :skolemid |4577|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| |i#1@@55|)))
))) (=> (|Seq#Contains| |run#0@@185| ($Box |needle#0@@81|)) (and (INTERNAL_lt_boogie (INTERNAL_add_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|) 1) (|Seq#Length| |run#0@@185|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@185| (INTERNAL_add_boogie (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|) 1))) |needle#0@@81|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |4578|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@607 |run#0@@185| |needle#0@@81|))
))))
(assert (forall (($ly@@608 T@U) (|run#0@@186| T@U) (|needle#0@@82| T@U) ) (!  (=> (and (and (and (= (type $ly@@608) LayerTypeType) (= (type |run#0@@186|) (SeqType BoxType))) (= (type |needle#0@@82|) DatatypeTypeType)) (and ($Is |run#0@@186| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@82| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@608 |run#0@@186| |needle#0@@82|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@186|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |4579|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#requires| $ly@@608 |run#0@@186| |needle#0@@82|))
)))
(assert  (and (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0) LayerTypeType) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) LayerTypeType)))
(assert  (=> true (forall (($ly@@609 T@U) (|run#0@@187| T@U) (|needle#0@@83| T@U) ) (!  (=> (and (and (and (= (type $ly@@609) LayerTypeType) (= (type |run#0@@187|) (SeqType BoxType))) (= (type |needle#0@@83|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |run#0@@187| |needle#0@@83|) (and (and ($Is |run#0@@187| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@83| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@187|)))) (and (and (=> (not (= (|Seq#Length| |run#0@@187|) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0))))) (=> (not (or (= (|Seq#Length| |run#0@@187|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (|Seq#Drop| |run#0@@187| (LitInt 1)) |needle#0@@83|))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted0)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@609) |run#0@@187| |needle#0@@83|) (ite  (or (= (|Seq#Length| |run#0@@187|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@83| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@187| (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt $ly@@609 (|Seq#Drop| |run#0@@187| (LitInt 1)) |needle#0@@83|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :skolemid |4580|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@609) |run#0@@187| |needle#0@@83|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1) LayerTypeType))
(assert  (=> true (forall (($ly@@610 T@U) (|run#0@@188| T@U) (|needle#0@@84| T@U) ) (!  (=> (and (and (and (= (type $ly@@610) LayerTypeType) (= (type |run#0@@188|) (SeqType BoxType))) (= (type |needle#0@@84|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |run#0@@188|) (Lit |needle#0@@84|)) (and (and ($Is |run#0@@188| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@84| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@188|))))) (and (and (=> (not (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0))))) (=> (not (or (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0)))))) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit (|Seq#Drop| (Lit |run#0@@188|) (LitInt 1))) (Lit |needle#0@@84|)))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@610) (Lit |run#0@@188|) (Lit |needle#0@@84|)) (ite  (or (= (|Seq#Length| (Lit |run#0@@188|)) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |needle#0@@84|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@188|) (LitInt 0))))) (- 0 1) (INTERNAL_add_boogie 1 (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@610) (Lit (|Seq#Drop| (Lit |run#0@@188|) (LitInt 1))) (Lit |needle#0@@84|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.458:12|
 :weight 3
 :skolemid |4581|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $ly@@610) (Lit |run#0@@188|) (Lit |needle#0@@84|)))
))))
(assert (forall (($ly@@611 T@U) (|run#0@@189| T@U) (|needle#0@@85| T@U) ) (!  (=> (and (and (= (type $ly@@611) LayerTypeType) (= (type |run#0@@189|) (SeqType BoxType))) (= (type |needle#0@@85|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@611) |run#0@@189| |needle#0@@85|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@611 |run#0@@189| |needle#0@@85|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |4582|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@611) |run#0@@189| |needle#0@@85|))
)))
(assert (forall (($ly@@612 T@U) (|run#0@@190| T@U) (|needle#0@@86| T@U) ) (!  (=> (and (and (= (type $ly@@612) LayerTypeType) (= (type |run#0@@190|) (SeqType BoxType))) (= (type |needle#0@@86|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@612 |run#0@@190| |needle#0@@86|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $LZ |run#0@@190| |needle#0@@86|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |4583|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte (AsFuelBottom $ly@@612) |run#0@@190| |needle#0@@86|))
)))
(assert  (=> true (forall (($ly@@613 T@U) (|run#0@@191| T@U) (|needle#0@@87| T@U) ) (!  (=> (and (and (and (= (type $ly@@613) LayerTypeType) (= (type |run#0@@191|) (SeqType BoxType))) (= (type |needle#0@@87|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@191| |needle#0@@87|) (and (and ($Is |run#0@@191| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@87| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@191|)))) (and (and (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@613 |run#0@@191| |needle#0@@87|) (|Seq#Length| |run#0@@191|)) (forall ((|i#0@@161| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@161|) (INTERNAL_lt_boogie |i#0@@161| (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@613 |run#0@@191| |needle#0@@87|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#0@@161|)) |needle#0@@87|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.495:20|
 :skolemid |4584|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#0@@161|)))
))) (forall ((|i#1@@56| Int) ) (!  (=> (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@613 |run#0@@191| |needle#0@@87|) |i#1@@56|) (INTERNAL_lt_boogie |i#1@@56| (|Seq#Length| |run#0@@191|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |needle#0@@87| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#1@@56|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.496:20|
 :skolemid |4585|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@191| |i#1@@56|)))
))) (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@613 |run#0@@191| |needle#0@@87|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |4586|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@613 |run#0@@191| |needle#0@@87|))
))))
(assert (forall (($ly@@614 T@U) (|run#0@@192| T@U) (|needle#0@@88| T@U) ) (!  (=> (and (and (and (= (type $ly@@614) LayerTypeType) (= (type |run#0@@192|) (SeqType BoxType))) (= (type |needle#0@@88|) DatatypeTypeType)) (and ($Is |run#0@@192| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@88| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@614 |run#0@@192| |needle#0@@88|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@192|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |4587|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#requires| $ly@@614 |run#0@@192| |needle#0@@88|))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2) LayerTypeType))
(assert  (=> true (forall (($ly@@615 T@U) (|run#0@@193| T@U) (|needle#0@@89| T@U) ) (!  (=> (and (and (and (= (type $ly@@615) LayerTypeType) (= (type |run#0@@193|) (SeqType BoxType))) (= (type |needle#0@@89|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| |run#0@@193| |needle#0@@89|) (and (and ($Is |run#0@@193| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@89| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@193|)))) (and (=> (not (= (|Seq#Length| |run#0@@193|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|)) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|)) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) |needle#0@@89|))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted2)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@615) |run#0@@193| |needle#0@@89|) (ite (= (|Seq#Length| |run#0@@193|) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|)) |needle#0@@89|) (|Seq#Length| |run#0@@193|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte $ly@@615 (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@193|) |needle#0@@89|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :skolemid |4588|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@615) |run#0@@193| |needle#0@@89|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3) LayerTypeType))
(assert  (=> true (forall (($ly@@616 T@U) (|run#0@@194| T@U) (|needle#0@@90| T@U) ) (!  (=> (and (and (and (= (type $ly@@616) LayerTypeType) (= (type |run#0@@194|) (SeqType BoxType))) (= (type |needle#0@@90|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit |run#0@@194|) (Lit |needle#0@@90|)) (and (and ($Is |run#0@@194| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@90| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@194|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@194|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|))) (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte#canCall| (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|))) (Lit |needle#0@@90|)))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted3)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@616) (Lit |run#0@@194|) (Lit |needle#0@@90|)) (ite (= (|Seq#Length| (Lit |run#0@@194|)) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|)))) (Lit |needle#0@@90|)) (|Seq#Length| (Lit |run#0@@194|)) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@616) (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@194|))) (Lit |needle#0@@90|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.492:12|
 :weight 3
 :skolemid |4589|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGte ($LS $ly@@616) (Lit |run#0@@194|) (Lit |needle#0@@90|)))
))))
(assert (forall (($ly@@617 T@U) (|s#0@@257| T@U) (|key#0@@147| T@U) (|lo#0@@39| Int) (|hi#0@@27| Int) ) (!  (=> (and (and (= (type $ly@@617) LayerTypeType) (= (type |s#0@@257|) (SeqType BoxType))) (= (type |key#0@@147|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@617) |s#0@@257| |key#0@@147| |lo#0@@39| |hi#0@@27|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@617 |s#0@@257| |key#0@@147| |lo#0@@39| |hi#0@@27|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |4590|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@617) |s#0@@257| |key#0@@147| |lo#0@@39| |hi#0@@27|))
)))
(assert (forall (($ly@@618 T@U) (|s#0@@258| T@U) (|key#0@@148| T@U) (|lo#0@@40| Int) (|hi#0@@28| Int) ) (!  (=> (and (and (= (type $ly@@618) LayerTypeType) (= (type |s#0@@258|) (SeqType BoxType))) (= (type |key#0@@148|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@618 |s#0@@258| |key#0@@148| |lo#0@@40| |hi#0@@28|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $LZ |s#0@@258| |key#0@@148| |lo#0@@40| |hi#0@@28|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |4591|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter (AsFuelBottom $ly@@618) |s#0@@258| |key#0@@148| |lo#0@@40| |hi#0@@28|))
)))
(assert  (=> true (forall (($ly@@619 T@U) (|s#0@@259| T@U) (|key#0@@149| T@U) (|lo#0@@41| Int) (|hi#0@@29| Int) ) (!  (=> (and (and (and (= (type $ly@@619) LayerTypeType) (= (type |s#0@@259|) (SeqType BoxType))) (= (type |key#0@@149|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) (and (and ($Is |s#0@@259| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@149| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@41|) (INTERNAL_lt_boogie |lo#0@@41| |hi#0@@29|)) (INTERNAL_le_boogie |hi#0@@29| (INTERNAL_add_boogie (|Seq#Length| |s#0@@259|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@41| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie |lo#0@@41| 1))) |key#0@@149|))) (=> (INTERNAL_le_boogie |hi#0@@29| (|Seq#Length| |s#0@@259|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@149| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie |hi#0@@29| 1))))))))) (and (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) (|Seq#Length| |s#0@@259|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) 1))) |key#0@@149|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) (|Seq#Length| |s#0@@259|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@149| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@259| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|)))))) (and (INTERNAL_le_boogie |lo#0@@41| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|)) (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|) |hi#0@@29|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |4592|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@619 |s#0@@259| |key#0@@149| |lo#0@@41| |hi#0@@29|))
))))
(assert (forall (($ly@@620 T@U) (|s#0@@260| T@U) (|key#0@@150| T@U) (|lo#0@@42| Int) (|hi#0@@30| Int) ) (!  (=> (and (and (and (= (type $ly@@620) LayerTypeType) (= (type |s#0@@260|) (SeqType BoxType))) (= (type |key#0@@150|) DatatypeTypeType)) (and ($Is |s#0@@260| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@150| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@620 |s#0@@260| |key#0@@150| |lo#0@@42| |hi#0@@30|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@42|) (INTERNAL_lt_boogie |lo#0@@42| |hi#0@@30|)) (INTERNAL_le_boogie |hi#0@@30| (INTERNAL_add_boogie (|Seq#Length| |s#0@@260|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@42| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@260| (INTERNAL_sub_boogie |lo#0@@42| 1))) |key#0@@150|))) (=> (INTERNAL_le_boogie |hi#0@@30| (|Seq#Length| |s#0@@260|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@150| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@260| (INTERNAL_sub_boogie |hi#0@@30| 1))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |4593|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#requires| $ly@@620 |s#0@@260| |key#0@@150| |lo#0@@42| |hi#0@@30|))
)))
(assert  (=> true (forall (($ly@@621 T@U) (|s#0@@261| T@U) (|key#0@@151| T@U) (|lo#0@@43| Int) (|hi#0@@31| Int) ) (!  (=> (and (and (and (= (type $ly@@621) LayerTypeType) (= (type |s#0@@261|) (SeqType BoxType))) (= (type |key#0@@151|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@151| |lo#0@@43| |hi#0@@31|) (and (and ($Is |s#0@@261| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@151| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@43|) (INTERNAL_lt_boogie |lo#0@@43| |hi#0@@31|)) (INTERNAL_le_boogie |hi#0@@31| (INTERNAL_add_boogie (|Seq#Length| |s#0@@261|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@43| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |lo#0@@43| 1))) |key#0@@151|))) (=> (INTERNAL_le_boogie |hi#0@@31| (|Seq#Length| |s#0@@261|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@151| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |hi#0@@31| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@43| 1) |hi#0@@31|) (let ((|mid#0@@7| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@43| |hi#0@@31|) 2)))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@151|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@151|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@151| |mid#0@@7| |hi#0@@31|))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@7| 1))) |key#0@@151|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@261| |key#0@@151| |lo#0@@43| |mid#0@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@621) |s#0@@261| |key#0@@151| |lo#0@@43| |hi#0@@31|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@43| 1) |hi#0@@31|) (let ((|mid#0@@8| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@43| |hi#0@@31|) 2)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@261| (INTERNAL_sub_boogie |mid#0@@8| 1))) |key#0@@151|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@621 |s#0@@261| |key#0@@151| |mid#0@@8| |hi#0@@31|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter $ly@@621 |s#0@@261| |key#0@@151| |lo#0@@43| |mid#0@@8|))) |lo#0@@43|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :skolemid |4594|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@621) |s#0@@261| |key#0@@151| |lo#0@@43| |hi#0@@31|))
))))
(assert  (=> true (forall (($ly@@622 T@U) (|s#0@@262| T@U) (|key#0@@152| T@U) (|lo#0@@44| Int) (|hi#0@@32| Int) ) (!  (=> (and (and (and (= (type $ly@@622) LayerTypeType) (= (type |s#0@@262|) (SeqType BoxType))) (= (type |key#0@@152|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@152| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)) (and (and ($Is |s#0@@262| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@152| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@44|) (INTERNAL_lt_boogie |lo#0@@44| |hi#0@@32|)) (INTERNAL_le_boogie |hi#0@@32| (INTERNAL_add_boogie (|Seq#Length| |s#0@@262|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@44| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |lo#0@@44| 1)))) |key#0@@152|))) (=> (INTERNAL_le_boogie |hi#0@@32| (|Seq#Length| |s#0@@262|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@152| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |hi#0@@32| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@44| 1) |hi#0@@32|)))) (let ((|mid#1@@7| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@44| |hi#0@@32|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@152|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@152|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@152| |mid#1@@7| (LitInt |hi#0@@32|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (INTERNAL_sub_boogie |mid#1@@7| 1))) |key#0@@152|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@262| |key#0@@152| (LitInt |lo#0@@44|) |mid#1@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@622) |s#0@@262| |key#0@@152| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@44| 1) |hi#0@@32|) (let ((|mid#1@@8| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@44| |hi#0@@32|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@262| (LitInt (INTERNAL_sub_boogie |mid#1@@8| 1)))) |key#0@@152|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@622) |s#0@@262| |key#0@@152| |mid#1@@8| (LitInt |hi#0@@32|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@622) |s#0@@262| |key#0@@152| (LitInt |lo#0@@44|) |mid#1@@8|))) |lo#0@@44|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |4595|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@622) |s#0@@262| |key#0@@152| (LitInt |lo#0@@44|) (LitInt |hi#0@@32|)))
))))
(assert  (=> true (forall (($ly@@623 T@U) (|s#0@@263| T@U) (|key#0@@153| T@U) (|lo#0@@45| Int) (|hi#0@@33| Int) ) (!  (=> (and (and (and (= (type $ly@@623) LayerTypeType) (= (type |s#0@@263|) (SeqType BoxType))) (= (type |key#0@@153|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@153|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)) (and (and ($Is |s#0@@263| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@153| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@45|) (INTERNAL_lt_boogie |lo#0@@45| |hi#0@@33|)) (INTERNAL_le_boogie |hi#0@@33| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@263|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@45| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |lo#0@@45| 1)))) (Lit |key#0@@153|)))) (=> (INTERNAL_le_boogie |hi#0@@33| (|Seq#Length| (Lit |s#0@@263|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |key#0@@153|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |hi#0@@33| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@45| 1) |hi#0@@33|)))) (let ((|mid#2@@7| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@45| |hi#0@@33|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@153|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@153|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@153|) |mid#2@@7| (LitInt |hi#0@@33|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (INTERNAL_sub_boogie |mid#2@@7| 1))) (Lit |key#0@@153|))) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@263|) (Lit |key#0@@153|) (LitInt |lo#0@@45|) |mid#2@@7|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@623) (Lit |s#0@@263|) (Lit |key#0@@153|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@45| 1) |hi#0@@33|) (let ((|mid#2@@8| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@45| |hi#0@@33|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@263|) (LitInt (INTERNAL_sub_boogie |mid#2@@8| 1)))) (Lit |key#0@@153|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@623) (Lit |s#0@@263|) (Lit |key#0@@153|) |mid#2@@8| (LitInt |hi#0@@33|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@623) (Lit |s#0@@263|) (Lit |key#0@@153|) (LitInt |lo#0@@45|) |mid#2@@8|))) |lo#0@@45|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.524:12|
 :weight 3
 :skolemid |4596|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $ly@@623) (Lit |s#0@@263|) (Lit |key#0@@153|) (LitInt |lo#0@@45|) (LitInt |hi#0@@33|)))
))))
(assert (forall (($ly@@624 T@U) (|s#0@@264| T@U) (|key#0@@154| T@U) ) (!  (=> (and (and (= (type $ly@@624) LayerTypeType) (= (type |s#0@@264|) (SeqType BoxType))) (= (type |key#0@@154|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@624) |s#0@@264| |key#0@@154|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@624 |s#0@@264| |key#0@@154|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |4597|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@624) |s#0@@264| |key#0@@154|))
)))
(assert (forall (($ly@@625 T@U) (|s#0@@265| T@U) (|key#0@@155| T@U) ) (!  (=> (and (and (= (type $ly@@625) LayerTypeType) (= (type |s#0@@265|) (SeqType BoxType))) (= (type |key#0@@155|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@625 |s#0@@265| |key#0@@155|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $LZ |s#0@@265| |key#0@@155|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |4598|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte (AsFuelBottom $ly@@625) |s#0@@265| |key#0@@155|))
)))
(assert  (=> true (forall (($ly@@626 T@U) (|s#0@@266| T@U) (|key#0@@156| T@U) ) (!  (=> (and (and (and (= (type $ly@@626) LayerTypeType) (= (type |s#0@@266|) (SeqType BoxType))) (= (type |key#0@@156|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@266| |key#0@@156|) (and ($Is |s#0@@266| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@156| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|) (|Seq#Length| |s#0@@266|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@266| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|) 1))) |key#0@@156|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|) (|Seq#Length| |s#0@@266|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@156| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@266| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |4599|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte $ly@@626 |s#0@@266| |key#0@@156|))
))))
(assert (forall (($ly@@627 T@U) (|s#0@@267| T@U) (|key#0@@157| T@U) ) (!  (=> (and (and (and (= (type $ly@@627) LayerTypeType) (= (type |s#0@@267|) (SeqType BoxType))) (= (type |key#0@@157|) DatatypeTypeType)) (and ($Is |s#0@@267| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@157| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@627 |s#0@@267| |key#0@@157|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |4600|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#requires| $ly@@627 |s#0@@267| |key#0@@157|))
)))
(assert  (=> true (forall (($ly@@628 T@U) (|s#0@@268| T@U) (|key#0@@158| T@U) ) (!  (=> (and (and (and (= (type $ly@@628) LayerTypeType) (= (type |s#0@@268|) (SeqType BoxType))) (= (type |key#0@@158|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| |s#0@@268| |key#0@@158|) (and ($Is |s#0@@268| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@158| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@268| |key#0@@158| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@268|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@628) |s#0@@268| |key#0@@158|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@268| |key#0@@158| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@268|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :skolemid |4601|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@628) |s#0@@268| |key#0@@158|))
))))
(assert  (=> true (forall (($ly@@629 T@U) (|s#0@@269| T@U) (|key#0@@159| T@U) ) (!  (=> (and (and (and (= (type $ly@@629) LayerTypeType) (= (type |s#0@@269|) (SeqType BoxType))) (= (type |key#0@@159|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte#canCall| (Lit |s#0@@269|) (Lit |key#0@@159|)) (and ($Is |s#0@@269| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@159| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@269|) (Lit |key#0@@159|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@269|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@629) (Lit |s#0@@269|) (Lit |key#0@@159|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@269|) (Lit |key#0@@159|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@269|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.574:22|
 :weight 3
 :skolemid |4602|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGte ($LS $ly@@629) (Lit |s#0@@269|) (Lit |key#0@@159|)))
))))
(assert (forall (($ly@@630 T@U) (|s#0@@270| T@U) (|key#0@@160| T@U) (|lo#0@@46| Int) ) (!  (=> (and (and (= (type $ly@@630) LayerTypeType) (= (type |s#0@@270|) (SeqType BoxType))) (= (type |key#0@@160|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@630) |s#0@@270| |key#0@@160| |lo#0@@46|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@630 |s#0@@270| |key#0@@160| |lo#0@@46|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |4603|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@630) |s#0@@270| |key#0@@160| |lo#0@@46|))
)))
(assert (forall (($ly@@631 T@U) (|s#0@@271| T@U) (|key#0@@161| T@U) (|lo#0@@47| Int) ) (!  (=> (and (and (= (type $ly@@631) LayerTypeType) (= (type |s#0@@271|) (SeqType BoxType))) (= (type |key#0@@161|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@631 |s#0@@271| |key#0@@161| |lo#0@@47|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $LZ |s#0@@271| |key#0@@161| |lo#0@@47|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |4604|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound (AsFuelBottom $ly@@631) |s#0@@271| |key#0@@161| |lo#0@@47|))
)))
(assert  (=> true (forall (($ly@@632 T@U) (|s#0@@272| T@U) (|key#0@@162| T@U) (|lo#0@@48| Int) ) (!  (=> (and (and (and (= (type $ly@@632) LayerTypeType) (= (type |s#0@@272|) (SeqType BoxType))) (= (type |key#0@@162|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@272| |key#0@@162| |lo#0@@48|) (and (and ($Is |s#0@@272| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@162| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@48|) (INTERNAL_le_boogie |lo#0@@48| (|Seq#Length| |s#0@@272|))) (=> (INTERNAL_gt_boogie |lo#0@@48| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (INTERNAL_sub_boogie |lo#0@@48| 1))) |key#0@@162|)))))) (and (and (and (INTERNAL_le_boogie |lo#0@@48| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|) (|Seq#Length| |s#0@@272|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|) 1))) |key#0@@162|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|) (|Seq#Length| |s#0@@272|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte |key#0@@162| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@272| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |4605|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound $ly@@632 |s#0@@272| |key#0@@162| |lo#0@@48|))
))))
(assert (forall (($ly@@633 T@U) (|s#0@@273| T@U) (|key#0@@163| T@U) (|lo#0@@49| Int) ) (!  (=> (and (and (and (= (type $ly@@633) LayerTypeType) (= (type |s#0@@273|) (SeqType BoxType))) (= (type |key#0@@163|) DatatypeTypeType)) (and ($Is |s#0@@273| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@163| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@633 |s#0@@273| |key#0@@163| |lo#0@@49|)  (and (and (INTERNAL_le_boogie 0 |lo#0@@49|) (INTERNAL_le_boogie |lo#0@@49| (|Seq#Length| |s#0@@273|))) (=> (INTERNAL_gt_boogie |lo#0@@49| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@273| (INTERNAL_sub_boogie |lo#0@@49| 1))) |key#0@@163|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |4606|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#requires| $ly@@633 |s#0@@273| |key#0@@163| |lo#0@@49|))
)))
(assert  (=> true (forall (($ly@@634 T@U) (|s#0@@274| T@U) (|key#0@@164| T@U) (|lo#0@@50| Int) ) (!  (=> (and (and (and (= (type $ly@@634) LayerTypeType) (= (type |s#0@@274|) (SeqType BoxType))) (= (type |key#0@@164|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| |s#0@@274| |key#0@@164| |lo#0@@50|) (and (and ($Is |s#0@@274| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@164| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@50|) (INTERNAL_le_boogie |lo#0@@50| (|Seq#Length| |s#0@@274|))) (=> (INTERNAL_gt_boogie |lo#0@@50| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@274| (INTERNAL_sub_boogie |lo#0@@50| 1))) |key#0@@164|)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| |s#0@@274| |key#0@@164| |lo#0@@50| (INTERNAL_add_boogie (|Seq#Length| |s#0@@274|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@634) |s#0@@274| |key#0@@164| |lo#0@@50|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) |s#0@@274| |key#0@@164| |lo#0@@50| (INTERNAL_add_boogie (|Seq#Length| |s#0@@274|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :skolemid |4607|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@634) |s#0@@274| |key#0@@164| |lo#0@@50|))
))))
(assert  (=> true (forall (($ly@@635 T@U) (|s#0@@275| T@U) (|key#0@@165| T@U) (|lo#0@@51| Int) ) (!  (=> (and (and (and (= (type $ly@@635) LayerTypeType) (= (type |s#0@@275|) (SeqType BoxType))) (= (type |key#0@@165|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound#canCall| (Lit |s#0@@275|) (Lit |key#0@@165|) (LitInt |lo#0@@51|)) (and (and ($Is |s#0@@275| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@165| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (INTERNAL_le_boogie 0 |lo#0@@51|) (INTERNAL_le_boogie |lo#0@@51| (|Seq#Length| (Lit |s#0@@275|)))) (=> (INTERNAL_gt_boogie |lo#0@@51| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@275|) (LitInt (INTERNAL_sub_boogie |lo#0@@51| 1)))) (Lit |key#0@@165|))))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter#canCall| (Lit |s#0@@275|) (Lit |key#0@@165|) (LitInt |lo#0@@51|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@275|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@635) (Lit |s#0@@275|) (Lit |key#0@@165|) (LitInt |lo#0@@51|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteIter ($LS $LZ) (Lit |s#0@@275|) (Lit |key#0@@165|) (LitInt |lo#0@@51|) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@275|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.582:22|
 :weight 3
 :skolemid |4608|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGteWithLowerBound ($LS $ly@@635) (Lit |s#0@@275|) (Lit |key#0@@165|) (LitInt |lo#0@@51|)))
))))
(assert (forall (($ly@@636 T@U) (|run#0@@195| T@U) (|needle#0@@91| T@U) ) (!  (=> (and (and (= (type $ly@@636) LayerTypeType) (= (type |run#0@@195|) (SeqType BoxType))) (= (type |needle#0@@91|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@636) |run#0@@195| |needle#0@@91|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@636 |run#0@@195| |needle#0@@91|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |4609|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@636) |run#0@@195| |needle#0@@91|))
)))
(assert (forall (($ly@@637 T@U) (|run#0@@196| T@U) (|needle#0@@92| T@U) ) (!  (=> (and (and (= (type $ly@@637) LayerTypeType) (= (type |run#0@@196|) (SeqType BoxType))) (= (type |needle#0@@92|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@637 |run#0@@196| |needle#0@@92|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $LZ |run#0@@196| |needle#0@@92|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |4610|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt (AsFuelBottom $ly@@637) |run#0@@196| |needle#0@@92|))
)))
(assert  (=> true (forall (($ly@@638 T@U) (|run#0@@197| T@U) (|needle#0@@93| T@U) ) (!  (=> (and (and (and (= (type $ly@@638) LayerTypeType) (= (type |run#0@@197|) (SeqType BoxType))) (= (type |needle#0@@93|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@197| |needle#0@@93|) (and (and ($Is |run#0@@197| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@93| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@197|)))) (and (and (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@638 |run#0@@197| |needle#0@@93|) (|Seq#Length| |run#0@@197|)) (forall ((|i#0@@162| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@162|) (INTERNAL_lt_boogie |i#0@@162| (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@638 |run#0@@197| |needle#0@@93|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#0@@162|)) |needle#0@@93|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.595:20|
 :skolemid |4611|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#0@@162|)))
))) (forall ((|i#1@@57| Int) ) (!  (=> (and (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@638 |run#0@@197| |needle#0@@93|) |i#1@@57|) (INTERNAL_lt_boogie |i#1@@57| (|Seq#Length| |run#0@@197|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |needle#0@@93| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#1@@57|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.596:20|
 :skolemid |4612|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@197| |i#1@@57|)))
))) (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@638 |run#0@@197| |needle#0@@93|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |4613|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@638 |run#0@@197| |needle#0@@93|))
))))
(assert (forall (($ly@@639 T@U) (|run#0@@198| T@U) (|needle#0@@94| T@U) ) (!  (=> (and (and (and (= (type $ly@@639) LayerTypeType) (= (type |run#0@@198|) (SeqType BoxType))) (= (type |needle#0@@94|) DatatypeTypeType)) (and ($Is |run#0@@198| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@94| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@639 |run#0@@198| |needle#0@@94|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@198|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |4614|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#requires| $ly@@639 |run#0@@198| |needle#0@@94|))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4) LayerTypeType))
(assert  (=> true (forall (($ly@@640 T@U) (|run#0@@199| T@U) (|needle#0@@95| T@U) ) (!  (=> (and (and (and (= (type $ly@@640) LayerTypeType) (= (type |run#0@@199|) (SeqType BoxType))) (= (type |needle#0@@95|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| |run#0@@199| |needle#0@@95|) (and (and ($Is |run#0@@199| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@95| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@199|)))) (and (=> (not (= (|Seq#Length| |run#0@@199|) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|)) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|)) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) |needle#0@@95|))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted4)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@640) |run#0@@199| |needle#0@@95|) (ite (= (|Seq#Length| |run#0@@199|) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|)) |needle#0@@95|) (|Seq#Length| |run#0@@199|) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt $ly@@640 (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element |run#0@@199|) |needle#0@@95|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :skolemid |4615|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@640) |run#0@@199| |needle#0@@95|))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5) LayerTypeType))
(assert  (=> true (forall (($ly@@641 T@U) (|run#0@@200| T@U) (|needle#0@@96| T@U) ) (!  (=> (and (and (and (= (type $ly@@641) LayerTypeType) (= (type |run#0@@200|) (SeqType BoxType))) (= (type |needle#0@@96|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit |run#0@@200|) (Lit |needle#0@@96|)) (and (and ($Is |run#0@@200| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |needle#0@@96| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Lit |run#0@@200|))))) (and (=> (not (= (|Seq#Length| (Lit |run#0@@200|)) (LitInt 0))) (and (and (|Sequences.__default.Last#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|))) (=> (not (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|)))))) (and (|Sequences.__default.DropLast#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt#canCall| (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|))) (Lit |needle#0@@96|)))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted5)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@641) (Lit |run#0@@200|) (Lit |needle#0@@96|)) (ite (= (|Seq#Length| (Lit |run#0@@200|)) (LitInt 0)) 0 (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit ($Unbox DatatypeTypeType (Sequences.__default.Last Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|)))) (Lit |needle#0@@96|)) (|Seq#Length| (Lit |run#0@@200|)) (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@641) (Lit (Sequences.__default.DropLast Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |run#0@@200|))) (Lit |needle#0@@96|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.592:12|
 :weight 3
 :skolemid |4616|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IndexOfFirstGt ($LS $ly@@641) (Lit |run#0@@200|) (Lit |needle#0@@96|)))
))))
(assert (forall (($ly@@642 T@U) (|s#0@@276| T@U) (|key#0@@166| T@U) (|lo#0@@52| Int) (|hi#0@@34| Int) ) (!  (=> (and (and (= (type $ly@@642) LayerTypeType) (= (type |s#0@@276|) (SeqType BoxType))) (= (type |key#0@@166|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@642) |s#0@@276| |key#0@@166| |lo#0@@52| |hi#0@@34|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@642 |s#0@@276| |key#0@@166| |lo#0@@52| |hi#0@@34|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |4617|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@642) |s#0@@276| |key#0@@166| |lo#0@@52| |hi#0@@34|))
)))
(assert (forall (($ly@@643 T@U) (|s#0@@277| T@U) (|key#0@@167| T@U) (|lo#0@@53| Int) (|hi#0@@35| Int) ) (!  (=> (and (and (= (type $ly@@643) LayerTypeType) (= (type |s#0@@277|) (SeqType BoxType))) (= (type |key#0@@167|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@643 |s#0@@277| |key#0@@167| |lo#0@@53| |hi#0@@35|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $LZ |s#0@@277| |key#0@@167| |lo#0@@53| |hi#0@@35|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |4618|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter (AsFuelBottom $ly@@643) |s#0@@277| |key#0@@167| |lo#0@@53| |hi#0@@35|))
)))
(assert  (=> true (forall (($ly@@644 T@U) (|s#0@@278| T@U) (|key#0@@168| T@U) (|lo#0@@54| Int) (|hi#0@@36| Int) ) (!  (=> (and (and (and (= (type $ly@@644) LayerTypeType) (= (type |s#0@@278|) (SeqType BoxType))) (= (type |key#0@@168|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|) (and (and ($Is |s#0@@278| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@168| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@54|) (INTERNAL_lt_boogie |lo#0@@54| |hi#0@@36|)) (INTERNAL_le_boogie |hi#0@@36| (INTERNAL_add_boogie (|Seq#Length| |s#0@@278|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@54| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie |lo#0@@54| 1))) |key#0@@168|))) (=> (INTERNAL_le_boogie |hi#0@@36| (|Seq#Length| |s#0@@278|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@168| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie |hi#0@@36| 1))))))))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|) (|Seq#Length| |s#0@@278|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|) 1))) |key#0@@168|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|) (|Seq#Length| |s#0@@278|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@168| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@278| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |4619|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@644 |s#0@@278| |key#0@@168| |lo#0@@54| |hi#0@@36|))
))))
(assert (forall (($ly@@645 T@U) (|s#0@@279| T@U) (|key#0@@169| T@U) (|lo#0@@55| Int) (|hi#0@@37| Int) ) (!  (=> (and (and (and (= (type $ly@@645) LayerTypeType) (= (type |s#0@@279|) (SeqType BoxType))) (= (type |key#0@@169|) DatatypeTypeType)) (and ($Is |s#0@@279| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@169| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@645 |s#0@@279| |key#0@@169| |lo#0@@55| |hi#0@@37|)  (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@55|) (INTERNAL_lt_boogie |lo#0@@55| |hi#0@@37|)) (INTERNAL_le_boogie |hi#0@@37| (INTERNAL_add_boogie (|Seq#Length| |s#0@@279|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@55| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@279| (INTERNAL_sub_boogie |lo#0@@55| 1))) |key#0@@169|))) (=> (INTERNAL_le_boogie |hi#0@@37| (|Seq#Length| |s#0@@279|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@169| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@279| (INTERNAL_sub_boogie |hi#0@@37| 1))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |4620|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#requires| $ly@@645 |s#0@@279| |key#0@@169| |lo#0@@55| |hi#0@@37|))
)))
(assert  (=> true (forall (($ly@@646 T@U) (|s#0@@280| T@U) (|key#0@@170| T@U) (|lo#0@@56| Int) (|hi#0@@38| Int) ) (!  (=> (and (and (and (= (type $ly@@646) LayerTypeType) (= (type |s#0@@280|) (SeqType BoxType))) (= (type |key#0@@170|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@170| |lo#0@@56| |hi#0@@38|) (and (and ($Is |s#0@@280| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@170| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@56|) (INTERNAL_lt_boogie |lo#0@@56| |hi#0@@38|)) (INTERNAL_le_boogie |hi#0@@38| (INTERNAL_add_boogie (|Seq#Length| |s#0@@280|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@56| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |lo#0@@56| 1))) |key#0@@170|))) (=> (INTERNAL_le_boogie |hi#0@@38| (|Seq#Length| |s#0@@280|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@170| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |hi#0@@38| 1))))))))) (and (=> (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@56| 1) |hi#0@@38|) (let ((|mid#0@@9| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@56| |hi#0@@38|) 2)))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@170|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@170|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@170| |mid#0@@9| |hi#0@@38|))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@9| 1))) |key#0@@170|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@280| |key#0@@170| |lo#0@@56| |mid#0@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@646) |s#0@@280| |key#0@@170| |lo#0@@56| |hi#0@@38|) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@56| 1) |hi#0@@38|) (let ((|mid#0@@10| (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@56| |hi#0@@38|) 2)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@280| (INTERNAL_sub_boogie |mid#0@@10| 1))) |key#0@@170|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@646 |s#0@@280| |key#0@@170| |mid#0@@10| |hi#0@@38|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter $ly@@646 |s#0@@280| |key#0@@170| |lo#0@@56| |mid#0@@10|))) |lo#0@@56|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :skolemid |4621|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@646) |s#0@@280| |key#0@@170| |lo#0@@56| |hi#0@@38|))
))))
(assert  (=> true (forall (($ly@@647 T@U) (|s#0@@281| T@U) (|key#0@@171| T@U) (|lo#0@@57| Int) (|hi#0@@39| Int) ) (!  (=> (and (and (and (= (type $ly@@647) LayerTypeType) (= (type |s#0@@281|) (SeqType BoxType))) (= (type |key#0@@171|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@171| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)) (and (and ($Is |s#0@@281| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@171| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@57|) (INTERNAL_lt_boogie |lo#0@@57| |hi#0@@39|)) (INTERNAL_le_boogie |hi#0@@39| (INTERNAL_add_boogie (|Seq#Length| |s#0@@281|) 1))) (=> (INTERNAL_gt_boogie |lo#0@@57| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |lo#0@@57| 1)))) |key#0@@171|))) (=> (INTERNAL_le_boogie |hi#0@@39| (|Seq#Length| |s#0@@281|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@171| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |hi#0@@39| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@57| 1) |hi#0@@39|)))) (let ((|mid#1@@9| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@57| |hi#0@@39|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@171|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@171|) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@171| |mid#1@@9| (LitInt |hi#0@@39|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (INTERNAL_sub_boogie |mid#1@@9| 1))) |key#0@@171|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@281| |key#0@@171| (LitInt |lo#0@@57|) |mid#1@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@647) |s#0@@281| |key#0@@171| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@57| 1) |hi#0@@39|) (let ((|mid#1@@10| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@57| |hi#0@@39|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@281| (LitInt (INTERNAL_sub_boogie |mid#1@@10| 1)))) |key#0@@171|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@647) |s#0@@281| |key#0@@171| |mid#1@@10| (LitInt |hi#0@@39|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@647) |s#0@@281| |key#0@@171| (LitInt |lo#0@@57|) |mid#1@@10|))) |lo#0@@57|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |4622|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@647) |s#0@@281| |key#0@@171| (LitInt |lo#0@@57|) (LitInt |hi#0@@39|)))
))))
(assert  (=> true (forall (($ly@@648 T@U) (|s#0@@282| T@U) (|key#0@@172| T@U) (|lo#0@@58| Int) (|hi#0@@40| Int) ) (!  (=> (and (and (and (= (type $ly@@648) LayerTypeType) (= (type |s#0@@282|) (SeqType BoxType))) (= (type |key#0@@172|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@172|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)) (and (and ($Is |s#0@@282| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@172| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (and (and (INTERNAL_le_boogie 0 |lo#0@@58|) (INTERNAL_lt_boogie |lo#0@@58| |hi#0@@40|)) (INTERNAL_le_boogie |hi#0@@40| (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@282|)) 1))) (=> (INTERNAL_gt_boogie |lo#0@@58| 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |lo#0@@58| 1)))) (Lit |key#0@@172|)))) (=> (INTERNAL_le_boogie |hi#0@@40| (|Seq#Length| (Lit |s#0@@282|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@172|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |hi#0@@40| 1)))))))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@58| 1) |hi#0@@40|)))) (let ((|mid#2@@9| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@58| |hi#0@@40|) 2))))
 (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@172|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@172|)) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@172|) |mid#2@@9| (LitInt |hi#0@@40|)))) (=> (not (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (INTERNAL_sub_boogie |mid#2@@9| 1))) (Lit |key#0@@172|))) (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@282|) (Lit |key#0@@172|) (LitInt |lo#0@@58|) |mid#2@@9|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@648) (Lit |s#0@@282|) (Lit |key#0@@172|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)) (ite (INTERNAL_lt_boogie (INTERNAL_add_boogie |lo#0@@58| 1) |hi#0@@40|) (let ((|mid#2@@10| (LitInt (INTERNAL_div_boogie (INTERNAL_add_boogie |lo#0@@58| |hi#0@@40|) 2))))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@282|) (LitInt (INTERNAL_sub_boogie |mid#2@@10| 1)))) (Lit |key#0@@172|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@648) (Lit |s#0@@282|) (Lit |key#0@@172|) |mid#2@@10| (LitInt |hi#0@@40|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@648) (Lit |s#0@@282|) (Lit |key#0@@172|) (LitInt |lo#0@@58|) |mid#2@@10|))) |lo#0@@58|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.624:12|
 :weight 3
 :skolemid |4623|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $ly@@648) (Lit |s#0@@282|) (Lit |key#0@@172|) (LitInt |lo#0@@58|) (LitInt |hi#0@@40|)))
))))
(assert (forall (($ly@@649 T@U) (|s#0@@283| T@U) (|key#0@@173| T@U) ) (!  (=> (and (and (= (type $ly@@649) LayerTypeType) (= (type |s#0@@283|) (SeqType BoxType))) (= (type |key#0@@173|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@649) |s#0@@283| |key#0@@173|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@649 |s#0@@283| |key#0@@173|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |4624|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@649) |s#0@@283| |key#0@@173|))
)))
(assert (forall (($ly@@650 T@U) (|s#0@@284| T@U) (|key#0@@174| T@U) ) (!  (=> (and (and (= (type $ly@@650) LayerTypeType) (= (type |s#0@@284|) (SeqType BoxType))) (= (type |key#0@@174|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@650 |s#0@@284| |key#0@@174|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $LZ |s#0@@284| |key#0@@174|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |4625|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt (AsFuelBottom $ly@@650) |s#0@@284| |key#0@@174|))
)))
(assert  (=> true (forall (($ly@@651 T@U) (|s#0@@285| T@U) (|key#0@@175| T@U) ) (!  (=> (and (and (and (= (type $ly@@651) LayerTypeType) (= (type |s#0@@285|) (SeqType BoxType))) (= (type |key#0@@175|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@285| |key#0@@175|) (and ($Is |s#0@@285| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@175| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (INTERNAL_le_boogie 0 (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|)) (INTERNAL_le_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|) (|Seq#Length| |s#0@@285|))) (=> (INTERNAL_gt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|) 0) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@285| (INTERNAL_sub_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|) 1))) |key#0@@175|))) (=> (INTERNAL_lt_boogie (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|) (|Seq#Length| |s#0@@285|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@175| ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@285| (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |4626|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt $ly@@651 |s#0@@285| |key#0@@175|))
))))
(assert (forall (($ly@@652 T@U) (|s#0@@286| T@U) (|key#0@@176| T@U) ) (!  (=> (and (and (and (= (type $ly@@652) LayerTypeType) (= (type |s#0@@286|) (SeqType BoxType))) (= (type |key#0@@176|) DatatypeTypeType)) (and ($Is |s#0@@286| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@176| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@652 |s#0@@286| |key#0@@176|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |4627|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#requires| $ly@@652 |s#0@@286| |key#0@@176|))
)))
(assert  (=> true (forall (($ly@@653 T@U) (|s#0@@287| T@U) (|key#0@@177| T@U) ) (!  (=> (and (and (and (= (type $ly@@653) LayerTypeType) (= (type |s#0@@287|) (SeqType BoxType))) (= (type |key#0@@177|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| |s#0@@287| |key#0@@177|) (and ($Is |s#0@@287| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@177| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| |s#0@@287| |key#0@@177| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@287|) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@653) |s#0@@287| |key#0@@177|) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) |s#0@@287| |key#0@@177| (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| |s#0@@287|) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :skolemid |4628|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@653) |s#0@@287| |key#0@@177|))
))))
(assert  (=> true (forall (($ly@@654 T@U) (|s#0@@288| T@U) (|key#0@@178| T@U) ) (!  (=> (and (and (and (= (type $ly@@654) LayerTypeType) (= (type |s#0@@288|) (SeqType BoxType))) (= (type |key#0@@178|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt#canCall| (Lit |s#0@@288|) (Lit |key#0@@178|)) (and ($Is |s#0@@288| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@178| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter#canCall| (Lit |s#0@@288|) (Lit |key#0@@178|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@288|)) 1)) (= (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@654) (Lit |s#0@@288|) (Lit |key#0@@178|)) (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGtIter ($LS $LZ) (Lit |s#0@@288|) (Lit |key#0@@178|) (LitInt 0) (INTERNAL_add_boogie (|Seq#Length| (Lit |s#0@@288|)) 1)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.644:22|
 :weight 3
 :skolemid |4629|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.binarySearchIndexOfFirstKeyGt ($LS $ly@@654) (Lit |s#0@@288|) (Lit |key#0@@178|)))
))))
(assert  (=> true (forall ((|a#0@@191| T@U) (|b#0@@145| T@U) ) (!  (=> (and (and (= (type |a#0@@191|) (MapType0Type BoxType boolType)) (= (type |b#0@@145|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@191| |b#0@@145|) (and ($Is |a#0@@191| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@145| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |4630|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@191| |b#0@@145|))
))))
(assert (forall ((|a#0@@192| T@U) (|b#0@@146| T@U) ) (!  (=> (and (and (= (type |a#0@@192|) (MapType0Type BoxType boolType)) (= (type |b#0@@146|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@192| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@146| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@192| |b#0@@146|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |4631|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#requires| |a#0@@192| |b#0@@146|))
)))
(assert  (=> true (forall ((|a#0@@193| T@U) (|b#0@@147| T@U) ) (!  (=> (and (and (= (type |a#0@@193|) (MapType0Type BoxType boolType)) (= (type |b#0@@147|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| |a#0@@193| |b#0@@147|) (and ($Is |a#0@@193| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@147| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#0@@10| T@U) (|y#0@@15| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@10|) DatatypeTypeType) (= (type |y#0@@15|) DatatypeTypeType)) (and ($Is |x#0@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select |a#0@@193| ($Box |x#0@@10|)))) (U_2_bool (MapType0Select |b#0@@147| ($Box |y#0@@15|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |x#0@@10| |y#0@@15|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |4633|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@10| |y#0@@15|))
 :pattern ( (MapType0Select |b#0@@147| ($Box |y#0@@15|)) (MapType0Select |a#0@@193| ($Box |x#0@@10|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@193| |b#0@@147|) (forall ((|x#0@@11| T@U) (|y#0@@16| T@U) ) (!  (=> (and (and (and (= (type |x#0@@11|) DatatypeTypeType) (= (type |y#0@@16|) DatatypeTypeType)) (and ($Is |x#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select |a#0@@193| ($Box |x#0@@11|))) (U_2_bool (MapType0Select |b#0@@147| ($Box |y#0@@16|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@11| |y#0@@16|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |4632|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#0@@11| |y#0@@16|))
 :pattern ( (MapType0Select |b#0@@147| ($Box |y#0@@16|)) (MapType0Select |a#0@@193| ($Box |x#0@@11|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :skolemid |4634|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte |a#0@@193| |b#0@@147|))
))))
(assert  (=> true (forall ((|a#0@@194| T@U) (|b#0@@148| T@U) ) (!  (=> (and (and (= (type |a#0@@194|) (MapType0Type BoxType boolType)) (= (type |b#0@@148|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte#canCall| (Lit |a#0@@194|) (Lit |b#0@@148|)) (and ($Is |a#0@@194| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@148| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#1@@7| T@U) (|y#1@@7| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@7|) DatatypeTypeType) (= (type |y#1@@7|) DatatypeTypeType)) (and ($Is |x#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select (Lit |a#0@@194|) ($Box |x#1@@7|)))) (U_2_bool (MapType0Select (Lit |b#0@@148|) ($Box |y#1@@7|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |x#1@@7| |y#1@@7|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |4636|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@7| |y#1@@7|))
 :pattern ( (MapType0Select |b#0@@148| ($Box |y#1@@7|)) (MapType0Select |a#0@@194| ($Box |x#1@@7|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@194|) (Lit |b#0@@148|)) (forall ((|x#1@@8| T@U) (|y#1@@8| T@U) ) (!  (=> (and (and (and (= (type |x#1@@8|) DatatypeTypeType) (= (type |y#1@@8|) DatatypeTypeType)) (and ($Is |x#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select (Lit |a#0@@194|) ($Box |x#1@@8|))) (U_2_bool (MapType0Select (Lit |b#0@@148|) ($Box |y#1@@8|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@8| |y#1@@8|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.804:12|
 :skolemid |4635|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |x#1@@8| |y#1@@8|))
 :pattern ( (MapType0Select |b#0@@148| ($Box |y#1@@8|)) (MapType0Select |a#0@@194| ($Box |x#1@@8|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.803:23|
 :weight 3
 :skolemid |4637|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLte (Lit |a#0@@194|) (Lit |b#0@@148|)))
))))
(assert  (=> true (forall ((|a#0@@195| T@U) (|b#0@@149| T@U) ) (!  (=> (and (and (= (type |a#0@@195|) (MapType0Type BoxType boolType)) (= (type |b#0@@149|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@195| |b#0@@149|) (and ($Is |a#0@@195| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@149| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |4638|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@195| |b#0@@149|))
))))
(assert (forall ((|a#0@@196| T@U) (|b#0@@150| T@U) ) (!  (=> (and (and (= (type |a#0@@196|) (MapType0Type BoxType boolType)) (= (type |b#0@@150|) (MapType0Type BoxType boolType))) (and ($Is |a#0@@196| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@150| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@196| |b#0@@150|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |4639|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#requires| |a#0@@196| |b#0@@150|))
)))
(assert  (=> true (forall ((|a#0@@197| T@U) (|b#0@@151| T@U) ) (!  (=> (and (and (= (type |a#0@@197|) (MapType0Type BoxType boolType)) (= (type |b#0@@151|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| |a#0@@197| |b#0@@151|) (and ($Is |a#0@@197| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@151| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#0@@12| T@U) (|y#0@@17| T@U) ) (!  (=> (and (and (and (and (= (type |x#0@@12|) DatatypeTypeType) (= (type |y#0@@17|) DatatypeTypeType)) (and ($Is |x#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select |a#0@@197| ($Box |x#0@@12|)))) (U_2_bool (MapType0Select |b#0@@151| ($Box |y#0@@17|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |x#0@@12| |y#0@@17|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |4641|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@12| |y#0@@17|))
 :pattern ( (MapType0Select |b#0@@151| ($Box |y#0@@17|)) (MapType0Select |a#0@@197| ($Box |x#0@@12|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@197| |b#0@@151|) (forall ((|x#0@@13| T@U) (|y#0@@18| T@U) ) (!  (=> (and (and (and (= (type |x#0@@13|) DatatypeTypeType) (= (type |y#0@@18|) DatatypeTypeType)) (and ($Is |x#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select |a#0@@197| ($Box |x#0@@13|))) (U_2_bool (MapType0Select |b#0@@151| ($Box |y#0@@18|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@13| |y#0@@18|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |4640|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#0@@13| |y#0@@18|))
 :pattern ( (MapType0Select |b#0@@151| ($Box |y#0@@18|)) (MapType0Select |a#0@@197| ($Box |x#0@@13|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :skolemid |4642|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt |a#0@@197| |b#0@@151|))
))))
(assert  (=> true (forall ((|a#0@@198| T@U) (|b#0@@152| T@U) ) (!  (=> (and (and (= (type |a#0@@198|) (MapType0Type BoxType boolType)) (= (type |b#0@@152|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt#canCall| (Lit |a#0@@198|) (Lit |b#0@@152|)) (and ($Is |a#0@@198| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |b#0@@152| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (forall ((|x#1@@9| T@U) (|y#1@@9| T@U) ) (!  (=> (and (and (and (and (= (type |x#1@@9|) DatatypeTypeType) (= (type |y#1@@9|) DatatypeTypeType)) (and ($Is |x#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (U_2_bool (MapType0Select (Lit |a#0@@198|) ($Box |x#1@@9|)))) (U_2_bool (MapType0Select (Lit |b#0@@152|) ($Box |y#1@@9|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |x#1@@9| |y#1@@9|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |4644|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@9| |y#1@@9|))
 :pattern ( (MapType0Select |b#0@@152| ($Box |y#1@@9|)) (MapType0Select |a#0@@198| ($Box |x#1@@9|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@198|) (Lit |b#0@@152|)) (forall ((|x#1@@10| T@U) (|y#1@@10| T@U) ) (!  (=> (and (and (and (= (type |x#1@@10|) DatatypeTypeType) (= (type |y#1@@10|) DatatypeTypeType)) (and ($Is |x#1@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |y#1@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (U_2_bool (MapType0Select (Lit |a#0@@198|) ($Box |x#1@@10|))) (U_2_bool (MapType0Select (Lit |b#0@@152|) ($Box |y#1@@10|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@10| |y#1@@10|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.808:12|
 :skolemid |4643|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |x#1@@10| |y#1@@10|))
 :pattern ( (MapType0Select |b#0@@152| ($Box |y#1@@10|)) (MapType0Select |a#0@@198| ($Box |x#1@@10|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.807:22|
 :weight 3
 :skolemid |4645|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetAllLt (Lit |a#0@@198|) (Lit |b#0@@152|)))
))))
(assert (forall (($ly@@655 T@U) (|a#0@@199| T@U) ) (!  (=> (and (= (type $ly@@655) LayerTypeType) (= (type |a#0@@199|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@655) |a#0@@199|) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@655 |a#0@@199|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |4646|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@655) |a#0@@199|))
)))
(assert (forall (($ly@@656 T@U) (|a#0@@200| T@U) ) (!  (=> (and (= (type $ly@@656) LayerTypeType) (= (type |a#0@@200|) DatatypeTypeType)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@656 |a#0@@200|) (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $LZ |a#0@@200|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |4647|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum (AsFuelBottom $ly@@656) |a#0@@200|))
)))
(assert  (=> true (forall (($ly@@657 T@U) (|a#0@@201| T@U) ) (!  (=> (and (and (= (type $ly@@657) LayerTypeType) (= (type |a#0@@201|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@201|) ($Is |a#0@@201| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |4648|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum $ly@@657 |a#0@@201|))
))))
(assert (forall (($ly@@658 T@U) (|a#0@@202| T@U) ) (!  (=> (and (and (= (type $ly@@658) LayerTypeType) (= (type |a#0@@202|) DatatypeTypeType)) ($Is |a#0@@202| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@658 |a#0@@202|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |4649|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#requires| $ly@@658 |a#0@@202|))
)))
(assert  (=> true (forall (($ly@@659 T@U) (|a#0@@203| T@U) ) (!  (=> (and (and (= (type $ly@@659) LayerTypeType) (= (type |a#0@@203|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| |a#0@@203|) ($Is |a#0@@203| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (forall ((|b#0@@153| T@U) ) (!  (=> (and (= (type |b#0@@153|) DatatypeTypeType) ($Is |b#0@@153| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#0@@153| |a#0@@203|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |4651|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@153| |a#0@@203|))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@659) |a#0@@203|) (exists ((|b#0@@154| T@U) ) (!  (and (= (type |b#0@@154|) DatatypeTypeType) (and ($Is |b#0@@154| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@154| |a#0@@203|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |4650|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#0@@154| |a#0@@203|))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :skolemid |4652|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@659) |a#0@@203|))
))))
(assert  (=> true (forall (($ly@@660 T@U) (|a#0@@204| T@U) ) (!  (=> (and (and (= (type $ly@@660) LayerTypeType) (= (type |a#0@@204|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum#canCall| (Lit |a#0@@204|)) ($Is |a#0@@204| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (forall ((|b#1@@8| T@U) ) (!  (=> (and (= (type |b#1@@8|) DatatypeTypeType) ($Is |b#1@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |b#1@@8| (Lit |a#0@@204|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |4654|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@8| |a#0@@204|))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@660) (Lit |a#0@@204|)) (exists ((|b#1@@9| T@U) ) (!  (and (= (type |b#1@@9|) DatatypeTypeType) (and ($Is |b#1@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@9| (Lit |a#0@@204|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.821:12|
 :skolemid |4653|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |b#1@@9| |a#0@@204|))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.820:23|
 :weight 3
 :skolemid |4655|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.NotMinimum ($LS $ly@@660) (Lit |a#0@@204|)))
))))
(assert (forall ((arg0@@628 T@U) (arg1@@327 T@U) (arg2@@169 T@U) (arg3@@98 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@628 arg1@@327 arg2@@169 arg3@@98)) (MapType BoxType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion arg0@@628 arg1@@327 arg2@@169 arg3@@98))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value T@U) (|left#0@@7| T@U) (|pivot#0@@7| T@U) (|right#0@@7| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value) TyType) (= (type |left#0@@7|) (MapType BoxType BoxType))) (= (type |pivot#0@@7|) DatatypeTypeType)) (= (type |right#0@@7|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|) (and (and ($Is |left#0@@7| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value)) ($Is |pivot#0@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@7| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value))))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|) (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value)))
 :qid |unknown.0:0|
 :skolemid |4656|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value |left#0@@7| |pivot#0@@7| |right#0@@7|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 T@U) (|left#0@@8| T@U) (|pivot#0@@8| T@U) (|right#0@@8| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0) TyType) (= (type |left#0@@8|) (MapType BoxType BoxType))) (= (type |pivot#0@@8|) DatatypeTypeType)) (= (type |right#0@@8|) (MapType BoxType BoxType))) (and (and ($Is |left#0@@8| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)) ($Is |pivot#0@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@8| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@8| |pivot#0@@8| |right#0@@8|) true))
 :qid |unknown.0:0|
 :skolemid |4657|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#requires| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@0 |left#0@@8| |pivot#0@@8| |right#0@@8|))
)))
(assert  (and (forall ((arg0@@629 T@U) (arg1@@328 T@U) ) (! (= (type (|lambda#325| arg0@@629 arg1@@328)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#325|
 :pattern ( (|lambda#325| arg0@@629 arg1@@328))
)) (forall ((arg0@@630 T@U) (arg1@@329 T@U) ) (! (= (type (|lambda#327| arg0@@630 arg1@@329)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#327|
 :pattern ( (|lambda#327| arg0@@630 arg1@@329))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 T@U) (|left#0@@9| T@U) (|pivot#0@@9| T@U) (|right#0@@9| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1) TyType) (= (type |left#0@@9|) (MapType BoxType BoxType))) (= (type |pivot#0@@9|) DatatypeTypeType)) (= (type |right#0@@9|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|) (and (and ($Is |left#0@@9| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1)) ($Is |pivot#0@@9| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@9| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1))))) (and (and (and (forall ((|k#0@@79| T@U) ) (!  (=> (and (= (type |k#0@@79|) DatatypeTypeType) ($Is |k#0@@79| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |k#0@@79| |pivot#0@@9|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.840:57|
 :skolemid |4658|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |k#0@@79| |pivot#0@@9|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))) (let ((|restricted_left#0@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
 (and (and (forall ((|k#1@@17| T@U) ) (!  (=> (and (= (type |k#1@@17|) DatatypeTypeType) ($Is |k#1@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |pivot#0@@9| |k#1@@17|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.841:59|
 :skolemid |4659|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |pivot#0@@9| |k#1@@17|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))) (let ((|restricted_right#0@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |restricted_left#0@@3| |restricted_right#0@@3|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|) (let ((|restricted_left#0@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(let ((|restricted_right#0@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |right#0@@9| (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pivot#0@@9|))))
(Maps.__default.MapDisjointUnion Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 StartFuel_Maps._default.MapDisjointUnion |restricted_left#0@@4| |restricted_right#0@@4|))))))
 :qid |unknown.0:0|
 :skolemid |4660|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@1 |left#0@@9| |pivot#0@@9| |right#0@@9|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 T@U) (|left#0@@10| T@U) (|pivot#0@@10| T@U) (|right#0@@10| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2) TyType) (= (type |left#0@@10|) (MapType BoxType BoxType))) (= (type |pivot#0@@10|) DatatypeTypeType)) (= (type |right#0@@10|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)) (and (and ($Is |left#0@@10| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2)) ($Is |pivot#0@@10| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@10| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2))))) (and (and (and (forall ((|k#2@@8| T@U) ) (!  (=> (and (= (type |k#2@@8|) DatatypeTypeType) ($Is |k#2@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |k#2@@8| (Lit |pivot#0@@10|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.840:57|
 :skolemid |4661|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |k#2@@8| |pivot#0@@10|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))) (let ((|restricted_left#1@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
 (and (and (forall ((|k#3@@1| T@U) ) (!  (=> (and (= (type |k#3@@1|) DatatypeTypeType) ($Is |k#3@@1| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |pivot#0@@10|) |k#3@@1|))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.841:59|
 :skolemid |4662|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |pivot#0@@10| |k#3@@1|))
)) (|Maps.__default.MapIRestrict#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))) (let ((|restricted_right#1@@3| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(|Maps.__default.MapDisjointUnion#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 |restricted_left#1@@3| |restricted_right#1@@3|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)) (let ((|restricted_left#1@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (|lambda#325| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(let ((|restricted_right#1@@4| (Maps.__default.MapIRestrict Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |right#0@@10|) (|lambda#327| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pivot#0@@10|)))))
(Maps.__default.MapDisjointUnion Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 StartFuel_Maps._default.MapDisjointUnion |restricted_left#1@@4| |restricted_right#1@@4|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4663|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapPivotedUnion Upperbounded_Lexicographic_Byte_Order._default.MapPivotedUnion$Value@@2 (Lit |left#0@@10|) (Lit |pivot#0@@10|) (Lit |right#0@@10|)))
))))
(assert (forall ((arg0@@631 T@U) (arg1@@330 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor arg0@@631 arg1@@330)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor arg0@@631 arg1@@330))
)))
(assert  (=> true (forall ((|m#0@@146| T@U) (|key#0@@179| T@U) ) (!  (=> (and (and (= (type |m#0@@146|) (MapType0Type BoxType boolType)) (= (type |key#0@@179|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@146| |key#0@@179|) (and ($Is |m#0@@146| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@179| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@146| |key#0@@179|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:25|
 :skolemid |4664|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@146| |key#0@@179|))
))))
(assert (forall (($Heap@@93 T@U) (|m#0@@147| T@U) (|key#0@@180| T@U) ) (!  (=> (and (and (and (= (type $Heap@@93) (MapType0Type refType MapType1Type)) (= (type |m#0@@147|) (MapType0Type BoxType boolType))) (= (type |key#0@@180|) DatatypeTypeType)) (and (and ($IsGoodHeap $Heap@@93) ($Is |m#0@@147| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@180| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@147| |key#0@@180|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :skolemid |4665|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#requires| |m#0@@147| |key#0@@180|) ($IsGoodHeap $Heap@@93))
)))
(assert (forall ((arg0@@632 T@U) (arg1@@331 T@U) ) (! (= (type (|$let#46_next| arg0@@632 arg1@@331)) DatatypeTypeType)
 :qid |funType:$let#46_next|
 :pattern ( (|$let#46_next| arg0@@632 arg1@@331))
)))
(assert (forall ((m@@70 T@U) (key@@1 T@U) ) (!  (=> (and (and (= (type m@@70) (MapType0Type BoxType boolType)) (= (type key@@1) DatatypeTypeType)) (|$let#46$canCall| m@@70 key@@1)) (and ($Is (|$let#46_next| m@@70 key@@1) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select m@@70 ($Box (|$let#46_next| m@@70 key@@1)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 (|$let#46_next| m@@70 key@@1))) (forall ((|other#1@@1| T@U) ) (!  (=> (and (= (type |other#1@@1|) DatatypeTypeType) ($Is |other#1@@1| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select m@@70 ($Box |other#1@@1|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#1@@1| (|$let#46_next| m@@70 key@@1)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 |other#1@@1|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (|$let#46_next| m@@70 key@@1) |other#1@@1|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4668|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt (|$let#46_next| m@@70 key@@1) |other#1@@1|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt key@@1 |other#1@@1|))
 :pattern ( (MapType0Select m@@70 ($Box |other#1@@1|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4669|
 :pattern ( (|$let#46_next| m@@70 key@@1))
)))
(assert  (=> true (forall (($Heap@@94 T@U) (|m#0@@148| T@U) (|key#0@@181| T@U) ) (!  (=> (and (and (and (= (type $Heap@@94) (MapType0Type refType MapType1Type)) (= (type |m#0@@148|) (MapType0Type BoxType boolType))) (= (type |key#0@@181|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| |m#0@@148| |key#0@@181|) (and (and ($IsGoodHeap $Heap@@94) ($Is |m#0@@148| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@181| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (forall ((|next#0@@5| T@U) ) (!  (=> (and (and (= (type |next#0@@5|) DatatypeTypeType) ($Is |next#0@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@5|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@181| |next#0@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@5|) (forall ((|other#0@@17| T@U) ) (!  (=> (and (and (= (type |other#0@@17|) DatatypeTypeType) ($Is |other#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@17|)))) (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |other#0@@17|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |next#0@@5|)) (=> (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@17| |next#0@@5|)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |key#0@@181| |other#0@@17|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@17|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |next#0@@5| |other#0@@17|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4670|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@5| |other#0@@17|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@17|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@17|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4671|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@5|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@5|)))
)) (=> (exists ((|next#0@@6| T@U) ) (!  (and (= (type |next#0@@6|) DatatypeTypeType) (and ($Is |next#0@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@6|)) (forall ((|other#0@@18| T@U) ) (!  (=> (and (= (type |other#0@@18|) DatatypeTypeType) ($Is |other#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@18|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@18| |next#0@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@18|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@6| |other#0@@18|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4672|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@6| |other#0@@18|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@18|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@18|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4673|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@6|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@6|)))
)) (|$let#46$canCall| |m#0@@148| |key#0@@181|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@148| |key#0@@181|) (ite (exists ((|next#0@@7| T@U) ) (!  (and (= (type |next#0@@7|) DatatypeTypeType) (and ($Is |next#0@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |next#0@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@7|)) (forall ((|other#0@@19| T@U) ) (!  (=> (and (= (type |other#0@@19|) DatatypeTypeType) ($Is |other#0@@19| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select |m#0@@148| ($Box |other#0@@19|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#0@@19| |next#0@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@19|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@7| |other#0@@19|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4666|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#0@@7| |other#0@@19|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |other#0@@19|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |other#0@@19|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4667|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@181| |next#0@@7|))
 :pattern ( (MapType0Select |m#0@@148| ($Box |next#0@@7|)))
)) (let ((|next#1@@1| (|$let#46_next| |m#0@@148| |key#0@@181|)))
(|#Options.Option.Some| ($Box |next#1@@1|))) |#Options.Option.None|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :skolemid |4674|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor |m#0@@148| |key#0@@181|) ($IsGoodHeap $Heap@@94))
))))
(assert  (=> true (forall (($Heap@@95 T@U) (|m#0@@149| T@U) (|key#0@@182| T@U) ) (!  (=> (and (and (and (= (type $Heap@@95) (MapType0Type refType MapType1Type)) (= (type |m#0@@149|) (MapType0Type BoxType boolType))) (= (type |key#0@@182|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit |m#0@@149|) (Lit |key#0@@182|)) (and (and ($IsGoodHeap $Heap@@95) ($Is |m#0@@149| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) ($Is |key#0@@182| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (forall ((|next#2@@5| T@U) ) (!  (=> (and (and (= (type |next#2@@5|) DatatypeTypeType) ($Is |next#2@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@5|)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@182|) |next#2@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |next#2@@5|) (forall ((|other#2@@5| T@U) ) (!  (=> (and (and (= (type |other#2@@5|) DatatypeTypeType) ($Is |other#2@@5| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@5|)))) (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |other#2@@5|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |next#2@@5|)) (=> (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@5| |next#2@@5|)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |key#0@@182|) |other#2@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |other#2@@5|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |next#2@@5| |other#2@@5|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4677|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@5| |other#2@@5|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |other#2@@5|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@5|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4678|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |next#2@@5|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@5|)))
)) (=> (exists ((|next#2@@6| T@U) ) (!  (and (= (type |next#2@@6|) DatatypeTypeType) (and ($Is |next#2@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |next#2@@6|)) (forall ((|other#2@@6| T@U) ) (!  (=> (and (= (type |other#2@@6|) DatatypeTypeType) ($Is |other#2@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@6|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@6| |next#2@@6|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |other#2@@6|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@6| |other#2@@6|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4679|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@6| |other#2@@6|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |other#2@@6|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@6|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4680|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |next#2@@6|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@6|)))
)) (|$let#46$canCall| (Lit |m#0@@149|) (Lit |key#0@@182|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@149|) (Lit |key#0@@182|)) (ite (exists ((|next#2@@7| T@U) ) (!  (and (= (type |next#2@@7|) DatatypeTypeType) (and ($Is |next#2@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |next#2@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |next#2@@7|)) (forall ((|other#2@@7| T@U) ) (!  (=> (and (= (type |other#2@@7|) DatatypeTypeType) ($Is |other#2@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (=> (and (and (U_2_bool (MapType0Select (Lit |m#0@@149|) ($Box |other#2@@7|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |other#2@@7| |next#2@@7|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |key#0@@182|) |other#2@@7|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@7| |other#2@@7|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.850:18|
 :skolemid |4675|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |next#2@@7| |other#2@@7|))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |other#2@@7|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |other#2@@7|)))
)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.847:8|
 :skolemid |4676|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |key#0@@182| |next#2@@7|))
 :pattern ( (MapType0Select |m#0@@149| ($Box |next#2@@7|)))
)) (let ((|next#3@@1| (|$let#46_next| (Lit |m#0@@149|) (Lit |key#0@@182|))))
(|#Options.Option.Some| ($Box |next#3@@1|))) |#Options.Option.None|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.845:12|
 :weight 3
 :skolemid |4681|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit |m#0@@149|) (Lit |key#0@@182|)) ($IsGoodHeap $Heap@@95))
))))
(assert (forall ((arg0@@633 T@U) (arg1@@332 T@U) (arg2@@170 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor arg0@@633 arg1@@332 arg2@@170)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor arg0@@633 arg1@@332 arg2@@170))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V T@U) (|m#0@@150| T@U) (|key#0@@183| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V) TyType) (= (type |m#0@@150|) (MapType BoxType BoxType))) (= (type |key#0@@183|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@183|) (and ($Is |m#0@@150| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V)) ($Is |key#0@@183| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@183|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |unknown.0:0|
 :skolemid |4682|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V |m#0@@150| |key#0@@183|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 T@U) (|m#0@@151| T@U) (|key#0@@184| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0) TyType) (= (type |m#0@@151|) (MapType BoxType BoxType))) (= (type |key#0@@184|) DatatypeTypeType)) (and ($Is |m#0@@151| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0)) ($Is |key#0@@184| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@151| |key#0@@184|) true))
 :qid |unknown.0:0|
 :skolemid |4683|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#requires| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@0 |m#0@@151| |key#0@@184|))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 T@U) (|m#0@@152| T@U) (|key#0@@185| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1) TyType) (= (type |m#0@@152|) (MapType BoxType BoxType))) (= (type |key#0@@185|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@185|) (and ($Is |m#0@@152| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1)) ($Is |key#0@@185| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|Map#Domain| |m#0@@152|) |key#0@@185|) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@185|) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|Map#Domain| |m#0@@152|) |key#0@@185|))))
 :qid |unknown.0:0|
 :skolemid |4684|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@1 |m#0@@152| |key#0@@185|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 T@U) (|m#0@@153| T@U) (|key#0@@186| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2) TyType) (= (type |m#0@@153|) (MapType BoxType BoxType))) (= (type |key#0@@186|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor#canCall| Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@186|)) (and ($Is |m#0@@153| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2)) ($Is |key#0@@186| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (Lit (|Map#Domain| (Lit |m#0@@153|))) (Lit |key#0@@186|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@186|)) (Lit (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (Lit (|Map#Domain| (Lit |m#0@@153|))) (Lit |key#0@@186|))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4685|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.MapSuccessor Upperbounded_Lexicographic_Byte_Order._default.MapSuccessor$V@@2 (Lit |m#0@@153|) (Lit |key#0@@186|)))
))))
(assert (forall ((arg0@@634 T@U) (arg1@@333 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@634 arg1@@333)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor arg0@@634 arg1@@333))
)))
(assert  (=> true (forall ((|m#0@@154| T@U) (|key#0@@187| T@U) ) (!  (=> (and (and (= (type |m#0@@154|) (SeqType BoxType)) (= (type |key#0@@187|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@154| |key#0@@187|) (and ($Is |m#0@@154| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@187| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@154| |key#0@@187|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |4686|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@154| |key#0@@187|))
))))
(assert (forall ((|m#0@@155| T@U) (|key#0@@188| T@U) ) (!  (=> (and (and (= (type |m#0@@155|) (SeqType BoxType)) (= (type |key#0@@188|) DatatypeTypeType)) (and ($Is |m#0@@155| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@188| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@155| |key#0@@188|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |4687|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#requires| |m#0@@155| |key#0@@188|))
)))
(assert  (=> true (forall ((|m#0@@156| T@U) (|key#0@@189| T@U) ) (!  (=> (and (and (= (type |m#0@@156|) (SeqType BoxType)) (= (type |key#0@@189|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| |m#0@@156| |key#0@@189|) (and ($Is |m#0@@156| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@189| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@156|) |key#0@@189|) (= (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@156| |key#0@@189|) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#295| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@156|) |key#0@@189|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :skolemid |4688|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor |m#0@@156| |key#0@@189|))
))))
(assert  (=> true (forall ((|m#0@@157| T@U) (|key#0@@190| T@U) ) (!  (=> (and (and (= (type |m#0@@157|) (SeqType BoxType)) (= (type |key#0@@190|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor#canCall| (Lit |m#0@@157|) (Lit |key#0@@190|)) (and ($Is |m#0@@157| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@190| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor#canCall| (|lambda#295| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@157|) (Lit |key#0@@190|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@157|) (Lit |key#0@@190|)) (Upperbounded__Lexicographic__Byte__Order.__default.SetSuccessor (|lambda#295| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |m#0@@157|) (Lit |key#0@@190|)))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.861:25|
 :weight 3
 :skolemid |4689|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SeqSuccessor (Lit |m#0@@157|) (Lit |key#0@@190|)))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V T@U) ($ly@@661 T@U) (|s#0@@289| T@U) (|m#0@@158| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V) TyType) (= (type $ly@@661) LayerTypeType)) (= (type |s#0@@289|) (SeqType BoxType))) (= (type |m#0@@158|) (MapType BoxType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@661) |s#0@@289| |m#0@@158|) (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V $ly@@661 |s#0@@289| |m#0@@158|)))
 :qid |unknown.0:0|
 :skolemid |4690|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V ($LS $ly@@661) |s#0@@289| |m#0@@158|))
)))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 T@U) ($ly@@662 T@U) (|s#0@@290| T@U) (|m#0@@159| T@U) ) (!  (=> (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0) TyType) (= (type $ly@@662) LayerTypeType)) (= (type |s#0@@290|) (SeqType BoxType))) (= (type |m#0@@159|) (MapType BoxType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $ly@@662 |s#0@@290| |m#0@@159|) (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 $LZ |s#0@@290| |m#0@@159|)))
 :qid |unknown.0:0|
 :skolemid |4691|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@0 (AsFuelBottom $ly@@662) |s#0@@290| |m#0@@159|))
)))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 T@U) ($ly@@663 T@U) (|s#0@@291| T@U) (|m#0@@160| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1) TyType) (= (type $ly@@663) LayerTypeType)) (= (type |s#0@@291|) (SeqType BoxType))) (= (type |m#0@@160|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 |s#0@@291| |m#0@@160|) (and ($Is |s#0@@291| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))) ($Is |m#0@@160| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1))))) true)
 :qid |unknown.0:0|
 :skolemid |4692|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@1 $ly@@663 |s#0@@291| |m#0@@160|))
))))
(assert (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 T@U) ($ly@@664 T@U) (|s#0@@292| T@U) (|m#0@@161| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2) TyType) (= (type $ly@@664) LayerTypeType)) (= (type |s#0@@292|) (SeqType BoxType))) (= (type |m#0@@161|) (MapType BoxType BoxType))) (and ($Is |s#0@@292| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2))) ($Is |m#0@@161| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@664 |s#0@@292| |m#0@@161|) true))
 :qid |unknown.0:0|
 :skolemid |4693|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#requires| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@2 $ly@@664 |s#0@@292| |m#0@@161|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 T@U) ($ly@@665 T@U) (|s#0@@293| T@U) (|m#0@@162| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3) TyType) (= (type $ly@@665) LayerTypeType)) (= (type |s#0@@293|) (SeqType BoxType))) (= (type |m#0@@162|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@293| |m#0@@162|) (and ($Is |s#0@@293| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))) ($Is |m#0@@162| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 |s#0@@293|) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|))) (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|)))) (and (forall ((|i#0@@163| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#0@@163|) (=> (INTERNAL_lt_boogie |i#0@@163| (|Seq#Length| |s#0@@293|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@163|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#0@@163|) (INTERNAL_lt_boogie |i#0@@163| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@163|)))))) (=> (INTERNAL_le_boogie 0 |i#0@@163|) (=> (INTERNAL_lt_boogie |i#0@@163| (|Seq#Length| |s#0@@293|)) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@163|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@163|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4697|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@163|)))
)) (=> (forall ((|i#0@@164| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@164|) (INTERNAL_lt_boogie |i#0@@164| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@164|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@164|) (INTERNAL_lt_boogie |i#0@@164| (|Seq#Length| |s#0@@293|))) (= (MapType0Select (|Map#Elements| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@164|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@164|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4700|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@164|)))
)) (forall ((|key#0@@191| T@U) ) (!  (=> (and (and (= (type |key#0@@191|) DatatypeTypeType) ($Is |key#0@@191| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@191|)))) (forall ((|i#1@@58| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@58|) (=> (INTERNAL_lt_boogie |i#1@@58| (|Seq#Length| |s#0@@293|)) (and (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@58|))))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |key#0@@191|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@58|)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@58|)))) |key#0@@191|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@58|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |4698|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@58|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |4699|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@191|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@191|)))
)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@665) |s#0@@293| |m#0@@162|)  (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 StartFuel_Sequences._default.Unzip |s#0@@293|)))) (forall ((|i#0@@165| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#0@@165|) (INTERNAL_lt_boogie |i#0@@165| (|Seq#Length| |s#0@@293|))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@165|)))))) (=> (and (INTERNAL_le_boogie 0 |i#0@@165|) (INTERNAL_lt_boogie |i#0@@165| (|Seq#Length| |s#0@@293|))) (= (MapType0Select (|Map#Elements| |m#0@@162|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@165|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@165|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4694|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#0@@165|)))
))) (forall ((|key#0@@192| T@U) ) (!  (=> (and (and (= (type |key#0@@192|) DatatypeTypeType) ($Is |key#0@@192| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@192|)))) (exists ((|i#1@@59| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#1@@59|) (INTERNAL_lt_boogie |i#1@@59| (|Seq#Length| |s#0@@293|))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@59|)))) |key#0@@192|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@59|))) (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@192|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |4695|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@293| |i#1@@59|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |4696|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@162|) ($Box |key#0@@192|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@162|) ($Box |key#0@@192|)))
))))))
 :qid |unknown.0:0|
 :skolemid |4701|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@3 ($LS $ly@@665) |s#0@@293| |m#0@@162|))
))))
(assert  (=> true (forall ((Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 T@U) ($ly@@666 T@U) (|s#0@@294| T@U) (|m#0@@163| T@U) ) (!  (=> (and (and (and (and (= (type Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4) TyType) (= (type $ly@@666) LayerTypeType)) (= (type |s#0@@294|) (SeqType BoxType))) (= (type |m#0@@163|) (MapType BoxType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap#canCall| Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@294|) (Lit |m#0@@163|)) (and ($Is |s#0@@294| (TSeq (Tclass._System.Tuple2 Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))) ($Is |m#0@@163| (TMap Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4))))) (and (and (and (and (|Sequences.__default.Unzip#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 (Lit |s#0@@294|)) (_System.Tuple2.___hMake2_q (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|)))) (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|)))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|))))) (and (forall ((|i#2@@18| Int) ) (!  (and (=> (INTERNAL_le_boogie 0 |i#2@@18|) (=> (INTERNAL_lt_boogie |i#2@@18| (|Seq#Length| (Lit |s#0@@294|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@18|))))) (=> (=> (and (INTERNAL_le_boogie 0 |i#2@@18|) (INTERNAL_lt_boogie |i#2@@18| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@18|)))))) (=> (INTERNAL_le_boogie 0 |i#2@@18|) (=> (INTERNAL_lt_boogie |i#2@@18| (|Seq#Length| (Lit |s#0@@294|))) (and (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@18|))) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@18|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4705|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@18|)))
)) (=> (forall ((|i#2@@19| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@19|) (INTERNAL_lt_boogie |i#2@@19| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@19|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@19|) (INTERNAL_lt_boogie |i#2@@19| (|Seq#Length| (Lit |s#0@@294|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@19|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@19|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4708|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@19|)))
)) (forall ((|key#1@@12| T@U) ) (!  (=> (and (and (= (type |key#1@@12|) DatatypeTypeType) ($Is |key#1@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@12|)))) (forall ((|i#3@@9| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#3@@9|) (=> (INTERNAL_lt_boogie |i#3@@9| (|Seq#Length| (Lit |s#0@@294|))) (and (and (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@9|))))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |key#1@@12|)) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@9|)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@9|)))) |key#1@@12|) (_System.Tuple2.___hMake2_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@9|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |4706|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#3@@9|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |4707|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@163|) ($Box |key#1@@12|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@12|)))
)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@666) (Lit |s#0@@294|) (Lit |m#0@@163|))  (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted ($Unbox (SeqType BoxType) (_System.Tuple2._0 (Sequences.__default.Unzip Tclass.Upperbounded__Lexicographic__Byte__Order.Element Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 StartFuel_Sequences._default.Unzip (Lit |s#0@@294|))))) (forall ((|i#2@@20| Int) ) (!  (=> true (and (=> (and (INTERNAL_le_boogie 0 |i#2@@20|) (INTERNAL_lt_boogie |i#2@@20| (|Seq#Length| (Lit |s#0@@294|)))) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@20|)))))) (=> (and (INTERNAL_le_boogie 0 |i#2@@20|) (INTERNAL_lt_boogie |i#2@@20| (|Seq#Length| (Lit |s#0@@294|)))) (= (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@20|)))) (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#2@@20|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.869:16|
 :skolemid |4702|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#2@@20|)))
))) (forall ((|key#1@@13| T@U) ) (!  (=> (and (and (= (type |key#1@@13|) DatatypeTypeType) ($Is |key#1@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (U_2_bool (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@13|)))) (exists ((|i#3@@10| Int) ) (!  (and (and (and (INTERNAL_le_boogie 0 |i#3@@10|) (INTERNAL_lt_boogie |i#3@@10| (|Seq#Length| (Lit |s#0@@294|)))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (_System.Tuple2._0 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@10|)))) |key#1@@13|)) (= (_System.Tuple2._1 ($Unbox DatatypeTypeType (|Seq#Index| (Lit |s#0@@294|) |i#3@@10|))) (MapType0Select (|Map#Elements| (Lit |m#0@@163|)) ($Box |key#1@@13|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:44|
 :skolemid |4703|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |s#0@@294| |i#3@@10|)))
)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.870:16|
 :skolemid |4704|
 :pattern ( (MapType0Select (|Map#Elements| |m#0@@163|) ($Box |key#1@@13|)))
 :pattern ( (MapType0Select (|Map#Domain| |m#0@@163|) ($Box |key#1@@13|)))
))))))
 :qid |unknown.0:0|
 :weight 3
 :skolemid |4709|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortedSeqForMap Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap$V@@4 ($LS $ly@@666) (Lit |s#0@@294|) (Lit |m#0@@163|)))
))))
(assert (forall ((arg0@@635 T@U) (arg1@@334 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.minimum arg0@@635 arg1@@334)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.minimum|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum arg0@@635 arg1@@334))
)))
(assert (forall (($ly@@667 T@U) (|s#0@@295| T@U) ) (!  (=> (and (= (type $ly@@667) LayerTypeType) (= (type |s#0@@295|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@667) |s#0@@295|) (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@667 |s#0@@295|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |4710|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@667) |s#0@@295|))
)))
(assert (forall (($ly@@668 T@U) (|s#0@@296| T@U) ) (!  (=> (and (= (type $ly@@668) LayerTypeType) (= (type |s#0@@296|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@668 |s#0@@296|) (Upperbounded__Lexicographic__Byte__Order.__default.minimum $LZ |s#0@@296|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |4711|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum (AsFuelBottom $ly@@668) |s#0@@296|))
)))
(assert  (=> true (forall (($ly@@669 T@U) (|s#0@@297| T@U) ) (!  (=> (and (and (= (type $ly@@669) LayerTypeType) (= (type |s#0@@297|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@297|) (and ($Is |s#0@@297| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@297|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@297| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@669 |s#0@@297|)))) (forall ((|y#0@@19| T@U) ) (!  (=> (= (type |y#0@@19|) DatatypeTypeType) (=> (and ($Is |y#0@@19| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@297| ($Box |y#0@@19|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@669 |s#0@@297|) |y#0@@19|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.876:18|
 :skolemid |4712|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@669 |s#0@@297|) |y#0@@19|))
 :pattern ( (MapType0Select |s#0@@297| ($Box |y#0@@19|)))
))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@669 |s#0@@297|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |4713|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@669 |s#0@@297|))
))))
(assert (forall (($ly@@670 T@U) ($Heap@@96 T@U) (|s#0@@298| T@U) ) (!  (=> (and (and (and (= (type $ly@@670) LayerTypeType) (= (type $Heap@@96) (MapType0Type refType MapType1Type))) (= (type |s#0@@298|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@96) ($Is |s#0@@298| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| $ly@@670 |s#0@@298|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@298|) 1)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |4714|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#requires| $ly@@670 |s#0@@298|) ($IsGoodHeap $Heap@@96))
)))
(assert (forall ((arg0@@636 T@U) ) (! (= (type (|$let#49_a| arg0@@636)) DatatypeTypeType)
 :qid |funType:$let#49_a|
 :pattern ( (|$let#49_a| arg0@@636))
)))
(assert (forall ((s@@57 T@U) ) (!  (=> (and (= (type s@@57) (MapType0Type BoxType boolType)) (|$let#49$canCall| s@@57)) (and ($Is (|$let#49_a| s@@57) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select s@@57 ($Box (|$let#49_a| s@@57))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.881:5|
 :skolemid |4715|
 :pattern ( (|$let#49_a| s@@57))
)))
(assert  (=> true (forall (($ly@@671 T@U) ($Heap@@97 T@U) (|s#0@@299| T@U) ) (!  (=> (and (and (and (= (type $ly@@671) LayerTypeType) (= (type $Heap@@97) (MapType0Type refType MapType1Type))) (= (type |s#0@@299|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@299|) (and (and ($IsGoodHeap $Heap@@97) ($Is |s#0@@299| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@299|) 1)))) (and (and (|$let#49$canCall| |s#0@@299|) (let ((|s'#1@@3| (|Set#Difference| |s#0@@299| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#49_a| |s#0@@299|))))))
 (=> (not (|Set#Equal| |s'#1@@3| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s'#1@@3|) (let ((|m'#1@@5| (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@671 |s'#1@@3|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|$let#49_a| |s#0@@299|) |m'#1@@5|)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@671) |s#0@@299|) (let ((|a#0@@205| (|$let#49_a| |s#0@@299|)))
(let ((|s'#0@@3| (|Set#Difference| |s#0@@299| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@205|)))))
(ite (|Set#Equal| |s'#0@@3| (|Set#Empty| BoxType)) |a#0@@205| (let ((|m'#0@@14| (Upperbounded__Lexicographic__Byte__Order.__default.minimum $ly@@671 |s'#0@@3|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@205| |m'#0@@14|) |a#0@@205| |m'#0@@14|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :skolemid |4716|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@671) |s#0@@299|) ($IsGoodHeap $Heap@@97))
))))
(assert  (=> true (forall (($ly@@672 T@U) ($Heap@@98 T@U) (|s#0@@300| T@U) ) (!  (=> (and (and (and (= (type $ly@@672) LayerTypeType) (= (type $Heap@@98) (MapType0Type refType MapType1Type))) (= (type |s#0@@300|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@300|)) (and (and ($IsGoodHeap $Heap@@98) ($Is |s#0@@300| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@300|)) 1)))) (and (and (|$let#49$canCall| (Lit |s#0@@300|)) (let ((|s'#3@@3| (|Set#Difference| |s#0@@300| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#49_a| (Lit |s#0@@300|)))))))
 (=> (not (|Set#Equal| |s'#3@@3| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s'#3@@3|) (let ((|m'#3@@3| (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@672) |s'#3@@3|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|$let#49_a| (Lit |s#0@@300|)) |m'#3@@3|)))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@672) (Lit |s#0@@300|)) (let ((|a#1@@8| (|$let#49_a| (Lit |s#0@@300|))))
(let ((|s'#2@@3| (|Set#Difference| |s#0@@300| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@8|)))))
(ite (|Set#Equal| |s'#2@@3| (|Set#Empty| BoxType)) |a#1@@8| (let ((|m'#2@@4| (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@672) |s'#2@@3|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#1@@8| |m'#2@@4|) |a#1@@8| |m'#2@@4|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.873:22|
 :weight 3
 :skolemid |4717|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimum ($LS $ly@@672) (Lit |s#0@@300|)) ($IsGoodHeap $Heap@@98))
))))
(assert (forall ((arg0@@637 T@U) (arg1@@335 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt arg0@@637 arg1@@335)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt arg0@@637 arg1@@335))
)))
(assert (forall (($ly@@673 T@U) (|s#0@@301| T@U) ) (!  (=> (and (= (type $ly@@673) LayerTypeType) (= (type |s#0@@301|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@673) |s#0@@301|) (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@673 |s#0@@301|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |4718|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@673) |s#0@@301|))
)))
(assert (forall (($ly@@674 T@U) (|s#0@@302| T@U) ) (!  (=> (and (= (type $ly@@674) LayerTypeType) (= (type |s#0@@302|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@674 |s#0@@302|) (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $LZ |s#0@@302|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |4719|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt (AsFuelBottom $ly@@674) |s#0@@302|))
)))
(assert  (=> true (forall (($ly@@675 T@U) (|s#0@@303| T@U) ) (!  (=> (and (and (= (type $ly@@675) LayerTypeType) (= (type |s#0@@303|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@303|) ($Is |s#0@@303| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|)) (U_2_bool (MapType0Select |s#0@@303| (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|))))) (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|)) (forall ((|y#0@@20| T@U) ) (!  (=> (= (type |y#0@@20|) DatatypeTypeType) (=> (and ($Is |y#0@@20| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@303| ($Box |y#0@@20|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|))) |y#0@@20|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.899:30|
 :skolemid |4720|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|))) |y#0@@20|))
 :pattern ( (MapType0Select |s#0@@303| ($Box |y#0@@20|)))
)))) (=> (Options.Option.None_q (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|)) (|Set#Equal| |s#0@@303| (|Set#Empty| BoxType)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |4721|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt $ly@@675 |s#0@@303|))
))))
(assert (forall (($ly@@676 T@U) (|s#0@@304| T@U) ) (!  (=> (and (and (= (type $ly@@676) LayerTypeType) (= (type |s#0@@304|) (MapType0Type BoxType boolType))) ($Is |s#0@@304| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@676 |s#0@@304|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |4722|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#requires| $ly@@676 |s#0@@304|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum) LayerTypeType))
(assert  (=> true (forall (($ly@@677 T@U) (|s#0@@305| T@U) ) (!  (=> (and (and (= (type $ly@@677) LayerTypeType) (= (type |s#0@@305|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| |s#0@@305|) ($Is |s#0@@305| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@305| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| |s#0@@305|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@677) |s#0@@305|) (ite (|Set#Equal| |s#0@@305| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum |s#0@@305|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :skolemid |4723|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@677) |s#0@@305|))
))))
(assert  (=> true (forall (($ly@@678 T@U) (|s#0@@306| T@U) ) (!  (=> (and (and (= (type $ly@@678) LayerTypeType) (= (type |s#0@@306|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt#canCall| (Lit |s#0@@306|)) ($Is |s#0@@306| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@306| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.minimum#canCall| (Lit |s#0@@306|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@678) (Lit |s#0@@306|)) (ite (|Set#Equal| |s#0@@306| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.minimum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum (Lit |s#0@@306|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.897:22|
 :weight 3
 :skolemid |4724|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.minimumOpt ($LS $ly@@678) (Lit |s#0@@306|)))
))))
(assert (forall ((arg0@@638 T@U) (arg1@@336 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.maximum arg0@@638 arg1@@336)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.maximum|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum arg0@@638 arg1@@336))
)))
(assert (forall (($ly@@679 T@U) (|s#0@@307| T@U) ) (!  (=> (and (= (type $ly@@679) LayerTypeType) (= (type |s#0@@307|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@679) |s#0@@307|) (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@679 |s#0@@307|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |4725|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@679) |s#0@@307|))
)))
(assert (forall (($ly@@680 T@U) (|s#0@@308| T@U) ) (!  (=> (and (= (type $ly@@680) LayerTypeType) (= (type |s#0@@308|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@680 |s#0@@308|) (Upperbounded__Lexicographic__Byte__Order.__default.maximum $LZ |s#0@@308|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |4726|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum (AsFuelBottom $ly@@680) |s#0@@308|))
)))
(assert  (=> true (forall (($ly@@681 T@U) (|s#0@@309| T@U) ) (!  (=> (and (and (= (type $ly@@681) LayerTypeType) (= (type |s#0@@309|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@309|) (and ($Is |s#0@@309| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (INTERNAL_ge_boogie (|Set#Card| |s#0@@309|) 1)))) (and (and (U_2_bool (MapType0Select |s#0@@309| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@681 |s#0@@309|)))) (forall ((|y#0@@21| T@U) ) (!  (=> (= (type |y#0@@21|) DatatypeTypeType) (=> (and ($Is |y#0@@21| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@309| ($Box |y#0@@21|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@21| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@681 |s#0@@309|))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.908:18|
 :skolemid |4727|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@21| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@681 |s#0@@309|)))
 :pattern ( (MapType0Select |s#0@@309| ($Box |y#0@@21|)))
))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@681 |s#0@@309|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |4728|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@681 |s#0@@309|))
))))
(assert (forall (($ly@@682 T@U) ($Heap@@99 T@U) (|s#0@@310| T@U) ) (!  (=> (and (and (and (= (type $ly@@682) LayerTypeType) (= (type $Heap@@99) (MapType0Type refType MapType1Type))) (= (type |s#0@@310|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@99) ($Is |s#0@@310| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| $ly@@682 |s#0@@310|) (INTERNAL_ge_boogie (|Set#Card| |s#0@@310|) 1)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |4729|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#requires| $ly@@682 |s#0@@310|) ($IsGoodHeap $Heap@@99))
)))
(assert (forall ((arg0@@639 T@U) ) (! (= (type (|$let#52_a| arg0@@639)) DatatypeTypeType)
 :qid |funType:$let#52_a|
 :pattern ( (|$let#52_a| arg0@@639))
)))
(assert (forall ((s@@58 T@U) ) (!  (=> (and (= (type s@@58) (MapType0Type BoxType boolType)) (|$let#52$canCall| s@@58)) (and ($Is (|$let#52_a| s@@58) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select s@@58 ($Box (|$let#52_a| s@@58))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.911:5|
 :skolemid |4730|
 :pattern ( (|$let#52_a| s@@58))
)))
(assert  (=> true (forall (($ly@@683 T@U) ($Heap@@100 T@U) (|s#0@@311| T@U) ) (!  (=> (and (and (and (= (type $ly@@683) LayerTypeType) (= (type $Heap@@100) (MapType0Type refType MapType1Type))) (= (type |s#0@@311|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@311|) (and (and ($IsGoodHeap $Heap@@100) ($Is |s#0@@311| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| |s#0@@311|) 1)))) (and (and (|$let#52$canCall| |s#0@@311|) (let ((|s'#1@@4| (|Set#Difference| |s#0@@311| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#52_a| |s#0@@311|))))))
 (=> (not (|Set#Equal| |s'#1@@4| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s'#1@@4|) (let ((|m'#1@@6| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@683 |s'#1@@4|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |m'#1@@6| (|$let#52_a| |s#0@@311|))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@683) |s#0@@311|) (let ((|a#0@@206| (|$let#52_a| |s#0@@311|)))
(let ((|s'#0@@4| (|Set#Difference| |s#0@@311| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#0@@206|)))))
(ite (|Set#Equal| |s'#0@@4| (|Set#Empty| BoxType)) |a#0@@206| (let ((|m'#0@@15| (Upperbounded__Lexicographic__Byte__Order.__default.maximum $ly@@683 |s'#0@@4|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |m'#0@@15| |a#0@@206|) |a#0@@206| |m'#0@@15|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :skolemid |4731|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@683) |s#0@@311|) ($IsGoodHeap $Heap@@100))
))))
(assert  (=> true (forall (($ly@@684 T@U) ($Heap@@101 T@U) (|s#0@@312| T@U) ) (!  (=> (and (and (and (= (type $ly@@684) LayerTypeType) (= (type $Heap@@101) (MapType0Type refType MapType1Type))) (= (type |s#0@@312|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@312|)) (and (and ($IsGoodHeap $Heap@@101) ($Is |s#0@@312| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_ge_boogie (|Set#Card| (Lit |s#0@@312|)) 1)))) (and (and (|$let#52$canCall| (Lit |s#0@@312|)) (let ((|s'#3@@4| (|Set#Difference| |s#0@@312| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#52_a| (Lit |s#0@@312|)))))))
 (=> (not (|Set#Equal| |s'#3@@4| (|Set#Empty| BoxType))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s'#3@@4|) (let ((|m'#3@@4| (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@684) |s'#3@@4|)))
(|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |m'#3@@4| (|$let#52_a| (Lit |s#0@@312|)))))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@684) (Lit |s#0@@312|)) (let ((|a#1@@9| (|$let#52_a| (Lit |s#0@@312|))))
(let ((|s'#2@@4| (|Set#Difference| |s#0@@312| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |a#1@@9|)))))
(ite (|Set#Equal| |s'#2@@4| (|Set#Empty| BoxType)) |a#1@@9| (let ((|m'#2@@5| (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@684) |s'#2@@4|)))
(ite (Upperbounded__Lexicographic__Byte__Order.__default.lt |m'#2@@5| |a#1@@9|) |a#1@@9| |m'#2@@5|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.905:22|
 :weight 3
 :skolemid |4732|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximum ($LS $ly@@684) (Lit |s#0@@312|)) ($IsGoodHeap $Heap@@101))
))))
(assert (forall ((arg0@@640 T@U) (arg1@@337 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt arg0@@640 arg1@@337)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt arg0@@640 arg1@@337))
)))
(assert (forall (($ly@@685 T@U) (|s#0@@313| T@U) ) (!  (=> (and (= (type $ly@@685) LayerTypeType) (= (type |s#0@@313|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@685) |s#0@@313|) (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@685 |s#0@@313|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |4733|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@685) |s#0@@313|))
)))
(assert (forall (($ly@@686 T@U) (|s#0@@314| T@U) ) (!  (=> (and (= (type $ly@@686) LayerTypeType) (= (type |s#0@@314|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@686 |s#0@@314|) (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $LZ |s#0@@314|)))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |4734|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt (AsFuelBottom $ly@@686) |s#0@@314|))
)))
(assert  (=> true (forall (($ly@@687 T@U) (|s#0@@315| T@U) ) (!  (=> (and (and (= (type $ly@@687) LayerTypeType) (= (type |s#0@@315|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@315|) ($Is |s#0@@315| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|)) (U_2_bool (MapType0Select |s#0@@315| (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|))))) (=> (Options.Option.Some_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|)) (forall ((|y#0@@22| T@U) ) (!  (=> (= (type |y#0@@22|) DatatypeTypeType) (=> (and ($Is |y#0@@22| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (MapType0Select |s#0@@315| ($Box |y#0@@22|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@22| ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.929:30|
 :skolemid |4735|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lte |y#0@@22| ($Unbox DatatypeTypeType (Options.Option.value (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|)))))
 :pattern ( (MapType0Select |s#0@@315| ($Box |y#0@@22|)))
)))) (=> (Options.Option.None_q (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|)) (|Set#Equal| |s#0@@315| (|Set#Empty| BoxType)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|) (Tclass.Options.Option Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |4736|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt $ly@@687 |s#0@@315|))
))))
(assert (forall (($ly@@688 T@U) (|s#0@@316| T@U) ) (!  (=> (and (and (= (type $ly@@688) LayerTypeType) (= (type |s#0@@316|) (MapType0Type BoxType boolType))) ($Is |s#0@@316| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@688 |s#0@@316|) true))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |4737|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#requires| $ly@@688 |s#0@@316|))
)))
(assert (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum) LayerTypeType))
(assert  (=> true (forall (($ly@@689 T@U) (|s#0@@317| T@U) ) (!  (=> (and (and (= (type $ly@@689) LayerTypeType) (= (type |s#0@@317|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| |s#0@@317|) ($Is |s#0@@317| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@317| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| |s#0@@317|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@689) |s#0@@317|) (ite (|Set#Equal| |s#0@@317| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum |s#0@@317|)))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :skolemid |4738|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@689) |s#0@@317|))
))))
(assert  (=> true (forall (($ly@@690 T@U) (|s#0@@318| T@U) ) (!  (=> (and (and (= (type $ly@@690) LayerTypeType) (= (type |s#0@@318|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt#canCall| (Lit |s#0@@318|)) ($Is |s#0@@318| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (not (|Set#Equal| |s#0@@318| (|Set#Empty| BoxType))) (|Upperbounded__Lexicographic__Byte__Order.__default.maximum#canCall| (Lit |s#0@@318|))) (= (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@690) (Lit |s#0@@318|)) (ite (|Set#Equal| |s#0@@318| (|Set#Empty| BoxType)) |#Options.Option.None| (|#Options.Option.Some| ($Box (Upperbounded__Lexicographic__Byte__Order.__default.maximum StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum (Lit |s#0@@318|))))))))
 :qid |totalorderidfyUpperboundedTotalOrderUpperboundedLexicographicByteOrder.927:22|
 :weight 3
 :skolemid |4739|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.maximumOpt ($LS $ly@@690) (Lit |s#0@@318|)))
))))
(assert  (=> true (forall ((|a#0@@207| T@U) (|b#0@@155| T@U) ) (!  (=> (and (and (= (type |a#0@@207|) DatatypeTypeType) (= (type |b#0@@155|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@207| |b#0@@155|) (and ($Is |a#0@@207| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@155| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |4740|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@207| |b#0@@155|))
))))
(assert (forall ((|a#0@@208| T@U) (|b#0@@156| T@U) ) (!  (=> (and (and (= (type |a#0@@208|) DatatypeTypeType) (= (type |b#0@@156|) DatatypeTypeType)) (and ($Is |a#0@@208| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@156| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| |a#0@@208| |b#0@@156|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |4741|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.lt#requires| |a#0@@208| |b#0@@156|))
)))
(assert  (=> true (forall ((|a#0@@209| T@U) (|b#0@@157| T@U) ) (!  (=> (and (and (= (type |a#0@@209|) DatatypeTypeType) (= (type |b#0@@157|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |a#0@@209| |b#0@@157|) (and ($Is |a#0@@209| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@157| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@209| |b#0@@157|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@209| |b#0@@157|) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |a#0@@209|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |b#0@@157|)))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@209| |b#0@@157|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@209| |b#0@@157|) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@209| |b#0@@157|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :skolemid |4742|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |a#0@@209| |b#0@@157|))
))))
(assert  (=> true (forall ((|a#0@@210| T@U) (|b#0@@158| T@U) ) (!  (=> (and (and (= (type |a#0@@210|) DatatypeTypeType) (= (type |b#0@@158|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit |a#0@@210|) (Lit |b#0@@158|)) (and ($Is |a#0@@210| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@158| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@210|) (Lit |b#0@@158|)) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@210|) (Lit |b#0@@158|))))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |a#0@@210|)) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |b#0@@158|))))) (= (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |a#0@@210|) (Lit |b#0@@158|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@210|) (Lit |b#0@@158|)) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |a#0@@210| |b#0@@158|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.17:16|
 :weight 3
 :skolemid |4743|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |a#0@@210|) (Lit |b#0@@158|)))
))))
(assert (forall ((arg0@@641 T@U) (arg1@@338 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.Min arg0@@641 arg1@@338)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.Min|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min arg0@@641 arg1@@338))
)))
(assert  (=> true (forall ((|a#0@@211| T@U) (|b#0@@159| T@U) ) (!  (=> (and (and (= (type |a#0@@211|) DatatypeTypeType) (= (type |b#0@@159|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@211| |b#0@@159|) (and ($Is |a#0@@211| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@159| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@211| |b#0@@159|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |4744|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@211| |b#0@@159|))
))))
(assert (forall ((|a#0@@212| T@U) (|b#0@@160| T@U) ) (!  (=> (and (and (= (type |a#0@@212|) DatatypeTypeType) (= (type |b#0@@160|) DatatypeTypeType)) (and ($Is |a#0@@212| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@160| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| |a#0@@212| |b#0@@160|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |4745|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.Min#requires| |a#0@@212| |b#0@@160|))
)))
(assert  (=> true (forall ((|a#0@@213| T@U) (|b#0@@161| T@U) ) (!  (=> (and (and (= (type |a#0@@213|) DatatypeTypeType) (= (type |b#0@@161|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| |a#0@@213| |b#0@@161|) (and ($Is |a#0@@213| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@161| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@213| |b#0@@161|) (= (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@213| |b#0@@161|) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@213| |b#0@@161|) |a#0@@213| |b#0@@161|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :skolemid |4746|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min |a#0@@213| |b#0@@161|))
))))
(assert  (=> true (forall ((|a#0@@214| T@U) (|b#0@@162| T@U) ) (!  (=> (and (and (= (type |a#0@@214|) DatatypeTypeType) (= (type |b#0@@162|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Min#canCall| (Lit |a#0@@214|) (Lit |b#0@@162|)) (and ($Is |a#0@@214| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@162| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@214|) (Lit |b#0@@162|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.Min (Lit |a#0@@214|) (Lit |b#0@@162|)) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@214|) (Lit |b#0@@162|)) |a#0@@214| |b#0@@162|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.44:16|
 :weight 3
 :skolemid |4747|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Min (Lit |a#0@@214|) (Lit |b#0@@162|)))
))))
(assert (forall ((arg0@@642 T@U) (arg1@@339 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.Max arg0@@642 arg1@@339)) DatatypeTypeType)
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.Max|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max arg0@@642 arg1@@339))
)))
(assert  (=> true (forall ((|a#0@@215| T@U) (|b#0@@163| T@U) ) (!  (=> (and (and (= (type |a#0@@215|) DatatypeTypeType) (= (type |b#0@@163|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@215| |b#0@@163|) (and ($Is |a#0@@215| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@163| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@215| |b#0@@163|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |4748|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@215| |b#0@@163|))
))))
(assert (forall ((|a#0@@216| T@U) (|b#0@@164| T@U) ) (!  (=> (and (and (= (type |a#0@@216|) DatatypeTypeType) (= (type |b#0@@164|) DatatypeTypeType)) (and ($Is |a#0@@216| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@164| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| |a#0@@216| |b#0@@164|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |4749|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.Max#requires| |a#0@@216| |b#0@@164|))
)))
(assert  (=> true (forall ((|a#0@@217| T@U) (|b#0@@165| T@U) ) (!  (=> (and (and (= (type |a#0@@217|) DatatypeTypeType) (= (type |b#0@@165|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| |a#0@@217| |b#0@@165|) (and ($Is |a#0@@217| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@165| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |a#0@@217| |b#0@@165|) (= (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@217| |b#0@@165|) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte |a#0@@217| |b#0@@165|) |b#0@@165| |a#0@@217|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :skolemid |4750|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max |a#0@@217| |b#0@@165|))
))))
(assert  (=> true (forall ((|a#0@@218| T@U) (|b#0@@166| T@U) ) (!  (=> (and (and (= (type |a#0@@218|) DatatypeTypeType) (= (type |b#0@@166|) DatatypeTypeType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.Max#canCall| (Lit |a#0@@218|) (Lit |b#0@@166|)) (and ($Is |a#0@@218| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |b#0@@166| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |a#0@@218|) (Lit |b#0@@166|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.Max (Lit |a#0@@218|) (Lit |b#0@@166|)) (ite (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |a#0@@218|) (Lit |b#0@@166|)) |b#0@@166| |a#0@@218|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.49:16|
 :weight 3
 :skolemid |4751|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.Max (Lit |a#0@@218|) (Lit |b#0@@166|)))
))))
(assert (forall (($ly@@691 T@U) (|run#0@@201| T@U) ) (!  (=> (and (= (type $ly@@691) LayerTypeType) (= (type |run#0@@201|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@691) |run#0@@201|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@691 |run#0@@201|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |4752|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@691) |run#0@@201|))
)))
(assert (forall (($ly@@692 T@U) (|run#0@@202| T@U) ) (!  (=> (and (= (type $ly@@692) LayerTypeType) (= (type |run#0@@202|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@692 |run#0@@202|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $LZ |run#0@@202|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |4753|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted (AsFuelBottom $ly@@692) |run#0@@202|))
)))
(assert  (=> true (forall (($ly@@693 T@U) (|run#0@@203| T@U) ) (!  (=> (and (and (= (type $ly@@693) LayerTypeType) (= (type |run#0@@203|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@203|) ($Is |run#0@@203| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (= (|Seq#Length| |run#0@@203|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@693 |run#0@@203|)) (=> (= (|Seq#Length| |run#0@@203|) (LitInt 1)) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@693 |run#0@@203|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |4754|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted $ly@@693 |run#0@@203|))
))))
(assert (forall (($ly@@694 T@U) (|run#0@@204| T@U) ) (!  (=> (and (and (= (type $ly@@694) LayerTypeType) (= (type |run#0@@204|) (SeqType BoxType))) ($Is |run#0@@204| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@694 |run#0@@204|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |4755|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#requires| $ly@@694 |run#0@@204|))
)))
(assert  (=> true (forall (($ly@@695 T@U) (|run#0@@205| T@U) ) (!  (=> (and (and (= (type $ly@@695) LayerTypeType) (= (type |run#0@@205|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| |run#0@@205|) ($Is |run#0@@205| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#0@@166| Int) (|j#0@@22| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@166|) (=> (INTERNAL_le_boogie |i#0@@166| |j#0@@22|) (=> (INTERNAL_lt_boogie |j#0@@22| (|Seq#Length| |run#0@@205|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@166|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@22|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |4757|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@22|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@166|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@695) |run#0@@205|) (forall ((|i#0@@167| Int) (|j#0@@23| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@167|) (INTERNAL_le_boogie |i#0@@167| |j#0@@23|)) (INTERNAL_lt_boogie |j#0@@23| (|Seq#Length| |run#0@@205|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@167|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@23|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |4756|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |j#0@@23|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@205| |i#0@@167|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :skolemid |4758|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@695) |run#0@@205|))
))))
(assert  (=> true (forall (($ly@@696 T@U) (|run#0@@206| T@U) ) (!  (=> (and (and (= (type $ly@@696) LayerTypeType) (= (type |run#0@@206|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsSorted#canCall| (Lit |run#0@@206|)) ($Is |run#0@@206| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#1@@60| Int) (|j#1@@11| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@60|) (=> (INTERNAL_le_boogie |i#1@@60| |j#1@@11|) (=> (INTERNAL_lt_boogie |j#1@@11| (|Seq#Length| (Lit |run#0@@206|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |i#1@@60|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |j#1@@11|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |4760|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |j#1@@11|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |i#1@@60|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@696) (Lit |run#0@@206|)) (forall ((|i#1@@61| Int) (|j#1@@12| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@61|) (INTERNAL_le_boogie |i#1@@61| |j#1@@12|)) (INTERNAL_lt_boogie |j#1@@12| (|Seq#Length| (Lit |run#0@@206|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |i#1@@61|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@206|) |j#1@@12|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.66:12|
 :skolemid |4759|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |j#1@@12|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@206| |i#1@@61|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.62:23|
 :weight 3
 :skolemid |4761|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted ($LS $ly@@696) (Lit |run#0@@206|)))
))))
(assert  (=> true (forall ((|run#0@@207| T@U) ) (!  (=> (and (= (type |run#0@@207|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@207|) ($Is |run#0@@207| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |4762|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@207|))
))))
(assert (forall ((|run#0@@208| T@U) ) (!  (=> (and (= (type |run#0@@208|) (SeqType BoxType)) ($Is |run#0@@208| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@208|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |4763|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#requires| |run#0@@208|))
)))
(assert  (=> true (forall ((|run#0@@209| T@U) ) (!  (=> (and (= (type |run#0@@209|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@209|) ($Is |run#0@@209| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#0@@168| Int) (|j#0@@24| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@168|) (=> (INTERNAL_lt_boogie |i#0@@168| |j#0@@24|) (=> (INTERNAL_lt_boogie |j#0@@24| (|Seq#Length| |run#0@@209|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@168|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@24|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |4765|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@24|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@168|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@209|) (forall ((|i#0@@169| Int) (|j#0@@25| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#0@@169|) (INTERNAL_lt_boogie |i#0@@169| |j#0@@25|)) (INTERNAL_lt_boogie |j#0@@25| (|Seq#Length| |run#0@@209|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@169|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@25|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |4764|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |j#0@@25|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@209| |i#0@@169|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :skolemid |4766|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@209|))
))))
(assert  (=> true (forall ((|run#0@@210| T@U) ) (!  (=> (and (= (type |run#0@@210|) (SeqType BoxType)) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@210|)) ($Is |run#0@@210| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (forall ((|i#1@@62| Int) (|j#1@@13| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@62|) (=> (INTERNAL_lt_boogie |i#1@@62| |j#1@@13|) (=> (INTERNAL_lt_boogie |j#1@@13| (|Seq#Length| (Lit |run#0@@210|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |i#1@@62|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |j#1@@13|))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |4768|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |j#1@@13|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |i#1@@62|)))
)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@210|)) (forall ((|i#1@@63| Int) (|j#1@@14| Int) ) (!  (=> true (=> (and (and (INTERNAL_le_boogie 0 |i#1@@63|) (INTERNAL_lt_boogie |i#1@@63| |j#1@@14|)) (INTERNAL_lt_boogie |j#1@@14| (|Seq#Length| (Lit |run#0@@210|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |i#1@@63|)) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |run#0@@210|) |j#1@@14|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.71:12|
 :skolemid |4767|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |j#1@@14|)) ($Unbox DatatypeTypeType (|Seq#Index| |run#0@@210| |i#1@@63|)))
)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.69:38|
 :weight 3
 :skolemid |4769|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@210|)))
))))
(assert (forall (($ly@@697 T@U) (|run#0@@211| T@U) ) (!  (=> (and (= (type $ly@@697) LayerTypeType) (= (type |run#0@@211|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@697) |run#0@@211|) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@697 |run#0@@211|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |4770|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@697) |run#0@@211|))
)))
(assert (forall (($ly@@698 T@U) (|run#0@@212| T@U) ) (!  (=> (and (= (type $ly@@698) LayerTypeType) (= (type |run#0@@212|) (SeqType BoxType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@698 |run#0@@212|) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $LZ |run#0@@212|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |4771|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted (AsFuelBottom $ly@@698) |run#0@@212|))
)))
(assert  (=> true (forall (($ly@@699 T@U) (|run#0@@213| T@U) ) (!  (=> (and (and (= (type $ly@@699) LayerTypeType) (= (type |run#0@@213|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@213|) ($Is |run#0@@213| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (=> (= (|Seq#Length| |run#0@@213|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@699 |run#0@@213|)) (=> (= (|Seq#Length| |run#0@@213|) (LitInt 1)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@699 |run#0@@213|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@699 |run#0@@213|) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted |run#0@@213|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |4772|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted $ly@@699 |run#0@@213|))
))))
(assert (forall (($ly@@700 T@U) (|run#0@@214| T@U) ) (!  (=> (and (and (= (type $ly@@700) LayerTypeType) (= (type |run#0@@214|) (SeqType BoxType))) ($Is |run#0@@214| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@700 |run#0@@214|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |4773|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#requires| $ly@@700 |run#0@@214|))
)))
(assert  (=> true (forall (($ly@@701 T@U) (|run#0@@215| T@U) ) (!  (=> (and (and (= (type $ly@@701) LayerTypeType) (= (type |run#0@@215|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |run#0@@215|) ($Is |run#0@@215| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| |run#0@@215|) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@701) |run#0@@215|) (let ((|b#0@@167| (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal |run#0@@215|)))
(ite |b#0@@167| |b#0@@167| |b#0@@167|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :skolemid |4774|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@701) |run#0@@215|))
))))
(assert  (=> true (forall (($ly@@702 T@U) (|run#0@@216| T@U) ) (!  (=> (and (and (= (type $ly@@702) LayerTypeType) (= (type |run#0@@216|) (SeqType BoxType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |run#0@@216|)) ($Is |run#0@@216| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal#canCall| (Lit |run#0@@216|)) (= (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@702) (Lit |run#0@@216|)) (let ((|b#1@@10| (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySortedInternal (Lit |run#0@@216|)))))))
(ite |b#1@@10| |b#1@@10| |b#1@@10|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.85:23|
 :weight 3
 :skolemid |4775|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted ($LS $ly@@702) (Lit |run#0@@216|)))
))))
(assert  (=> true (forall ((|e#0@@15| T@U) (|s#0@@319| T@U) ) (!  (=> (and (and (= (type |e#0@@15|) DatatypeTypeType) (= (type |s#0@@319|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@15| |s#0@@319|) (and (and ($Is |e#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@319| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@319|))))) true)
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |4776|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@15| |s#0@@319|))
))))
(assert (forall ((|e#0@@16| T@U) (|s#0@@320| T@U) ) (!  (=> (and (and (= (type |e#0@@16|) DatatypeTypeType) (= (type |s#0@@320|) (MapType0Type BoxType boolType))) (and ($Is |e#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@320| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@16| |s#0@@320|) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@320|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |4777|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#requires| |e#0@@16| |s#0@@320|))
)))
(assert  (=> true (forall ((|e#0@@17| T@U) (|s#0@@321| T@U) ) (!  (=> (and (and (= (type |e#0@@17|) DatatypeTypeType) (= (type |s#0@@321|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| |e#0@@17| |s#0@@321|) (and (and ($Is |e#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@321| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| |s#0@@321|))))) (and (=> (U_2_bool (MapType0Select |s#0@@321| ($Box |e#0@@17|))) (forall ((|e2#0@@3| T@U) ) (!  (=> (and (= (type |e2#0@@3|) DatatypeTypeType) ($Is |e2#0@@3| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (=> (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@3|))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e2#0@@3|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e#0@@17|))) (=> (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@3|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#0@@3| |e#0@@17|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |e2#0@@3| |e#0@@17|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |4779|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@3| |e#0@@17|))
 :pattern ( (MapType0Select |s#0@@321| ($Box |e2#0@@3|)))
))) (= (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@17| |s#0@@321|)  (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e#0@@17|))) (forall ((|e2#0@@4| T@U) ) (!  (=> (= (type |e2#0@@4|) DatatypeTypeType) (=> (and ($Is |e2#0@@4| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (U_2_bool (MapType0Select |s#0@@321| ($Box |e2#0@@4|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#0@@4| |e#0@@17|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@4| |e#0@@17|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |4778|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#0@@4| |e#0@@17|))
 :pattern ( (MapType0Select |s#0@@321| ($Box |e2#0@@4|)))
))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :skolemid |4780|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet |e#0@@17| |s#0@@321|))
))))
(assert  (=> true (forall ((|e#0@@18| T@U) (|s#0@@322| T@U) ) (!  (=> (and (and (= (type |e#0@@18|) DatatypeTypeType) (= (type |s#0@@322|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet#canCall| (Lit |e#0@@18|) (Lit |s#0@@322|)) (and (and ($Is |e#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |s#0@@322| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (INTERNAL_lt_boogie 0 (|Set#Card| (Lit |s#0@@322|)))))) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box (Lit |e#0@@18|)))) (forall ((|e2#1@@3| T@U) ) (!  (=> (and (= (type |e2#1@@3|) DatatypeTypeType) ($Is |e2#1@@3| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (=> (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@3|))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| |e2#1@@3|) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| (Lit |e#0@@18|)))) (=> (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@3|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#1@@3| |e#0@@18|))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| |e2#1@@3| (Lit |e#0@@18|)))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |4782|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@3| |e#0@@18|))
 :pattern ( (MapType0Select |s#0@@322| ($Box |e2#1@@3|)))
))) (= (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@18|) (Lit |s#0@@322|))  (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box (Lit |e#0@@18|)))) (forall ((|e2#1@@4| T@U) ) (!  (=> (= (type |e2#1@@4|) DatatypeTypeType) (=> (and ($Is |e2#1@@4| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (and (U_2_bool (MapType0Select (Lit |s#0@@322|) ($Box |e2#1@@4|))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| |e2#1@@4| |e#0@@18|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@4| (Lit |e#0@@18|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.208:22|
 :skolemid |4781|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.lt |e2#1@@4| |e#0@@18|))
 :pattern ( (MapType0Select |s#0@@322| ($Box |e2#1@@4|)))
))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.205:26|
 :weight 3
 :skolemid |4783|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (Lit |e#0@@18|) (Lit |s#0@@322|)))
))))
(assert (forall ((arg0@@643 T@U) (arg1@@340 T@U) ) (! (= (type (Upperbounded__Lexicographic__Byte__Order.__default.SortSet arg0@@643 arg1@@340)) (SeqType BoxType))
 :qid |funType:Upperbounded__Lexicographic__Byte__Order.__default.SortSet|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet arg0@@643 arg1@@340))
)))
(assert (forall (($ly@@703 T@U) (|s#0@@323| T@U) ) (!  (=> (and (= (type $ly@@703) LayerTypeType) (= (type |s#0@@323|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@703) |s#0@@323|) (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@703 |s#0@@323|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |4784|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@703) |s#0@@323|))
)))
(assert (forall (($ly@@704 T@U) (|s#0@@324| T@U) ) (!  (=> (and (= (type $ly@@704) LayerTypeType) (= (type |s#0@@324|) (MapType0Type BoxType boolType))) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@704 |s#0@@324|) (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $LZ |s#0@@324|)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |4785|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet (AsFuelBottom $ly@@704) |s#0@@324|))
)))
(assert  (=> true (forall (($ly@@705 T@U) (|s#0@@325| T@U) ) (!  (=> (and (and (= (type $ly@@705) LayerTypeType) (= (type |s#0@@325|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@325|) ($Is |s#0@@325| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (and (= (|Set#Card| |s#0@@325|) (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|))) (forall ((|t#0@@15| T@U) ) (!  (=> (and (= (type |t#0@@15|) DatatypeTypeType) ($Is |t#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (U_2_bool (MapType0Select |s#0@@325| ($Box |t#0@@15|))) (|Seq#Contains| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|) ($Box |t#0@@15|))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.239:20|
 :skolemid |4786|
 :pattern ( (|Seq#Contains| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|) ($Box |t#0@@15|)))
 :pattern ( (MapType0Select |s#0@@325| ($Box |t#0@@15|)))
))) (Upperbounded__Lexicographic__Byte__Order.__default.IsSorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|))) ($Is (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |4787|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@705 |s#0@@325|))
))))
(assert (forall (($ly@@706 T@U) ($Heap@@102 T@U) (|s#0@@326| T@U) ) (!  (=> (and (and (and (= (type $ly@@706) LayerTypeType) (= (type $Heap@@102) (MapType0Type refType MapType1Type))) (= (type |s#0@@326|) (MapType0Type BoxType boolType))) (and ($IsGoodHeap $Heap@@102) ($Is |s#0@@326| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@706 |s#0@@326|) true))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |4788|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#requires| $ly@@706 |s#0@@326|) ($IsGoodHeap $Heap@@102))
)))
(assert (forall ((arg0@@644 T@U) ) (! (= (type (|$let#55_e| arg0@@644)) DatatypeTypeType)
 :qid |funType:$let#55_e|
 :pattern ( (|$let#55_e| arg0@@644))
)))
(assert (forall ((s@@59 T@U) ) (!  (=> (and (= (type s@@59) (MapType0Type BoxType boolType)) (|$let#55$canCall| s@@59)) (and ($Is (|$let#55_e| s@@59) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (Upperbounded__Lexicographic__Byte__Order.__default.BiggestInSet (|$let#55_e| s@@59) s@@59)))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.249:7|
 :skolemid |4789|
 :pattern ( (|$let#55_e| s@@59))
)))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6) LayerTypeType))
(assert  (=> true (forall (($ly@@707 T@U) ($Heap@@103 T@U) (|s#0@@327| T@U) ) (!  (=> (and (and (and (= (type $ly@@707) LayerTypeType) (= (type $Heap@@103) (MapType0Type refType MapType1Type))) (= (type |s#0@@327|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| |s#0@@327|) (and ($IsGoodHeap $Heap@@103) ($Is |s#0@@327| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (=> (not (= (|Set#Card| |s#0@@327|) (LitInt 0))) (and (|$let#55$canCall| |s#0@@327|) (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@327| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#55_e| |s#0@@327|))))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted6)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@707) |s#0@@327|) (ite (= (|Set#Card| |s#0@@327|) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#0@@19| (|$let#55_e| |s#0@@327|)))
(|Seq#Append| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet $ly@@707 (|Set#Difference| |s#0@@327| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#0@@19|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#0@@19|)))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :skolemid |4790|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@707) |s#0@@327|) ($IsGoodHeap $Heap@@103))
))))
(assert (= (type MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7) LayerTypeType))
(assert  (=> true (forall (($ly@@708 T@U) ($Heap@@104 T@U) (|s#0@@328| T@U) ) (!  (=> (and (and (and (= (type $ly@@708) LayerTypeType) (= (type $Heap@@104) (MapType0Type refType MapType1Type))) (= (type |s#0@@328|) (MapType0Type BoxType boolType))) (or (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (Lit |s#0@@328|)) (and ($IsGoodHeap $Heap@@104) ($Is |s#0@@328| (TSet Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))) (and (=> (not (= (|Set#Card| (Lit |s#0@@328|)) (LitInt 0))) (and (|$let#55$canCall| (Lit |s#0@@328|)) (|Upperbounded__Lexicographic__Byte__Order.__default.SortSet#canCall| (|Set#Difference| |s#0@@328| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box (|$let#55_e| (Lit |s#0@@328|)))))))) (and (and (and (= StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)) (= StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted ($LS ($LS MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)))) (= (AsFuelBottom MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7) MoreFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted7)) (= (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@708) (Lit |s#0@@328|)) (ite (= (|Set#Card| (Lit |s#0@@328|)) (LitInt 0)) (|Seq#Empty| BoxType) (let ((|e#1@@2| (|$let#55_e| (Lit |s#0@@328|))))
(|Seq#Append| (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@708) (|Set#Difference| |s#0@@328| (|Set#UnionOne| (|Set#Empty| BoxType) ($Box |e#1@@2|)))) (|Seq#Build| (|Seq#Empty| BoxType) ($Box |e#1@@2|)))))))))
 :qid |totalorderidfyTotalOrderUpperboundedTotalOrderUpperboundedLexicographicByteOrder.237:12|
 :weight 3
 :skolemid |4791|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.__default.SortSet ($LS $ly@@708) (Lit |s#0@@328|)) ($IsGoodHeap $Heap@@104))
))))
(assert (forall ((|a#0#0#0@@11| T@U) ) (!  (=> (= (type |a#0#0#0@@11|) (SeqType BoxType)) (= (DatatypeCtorId (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#0#0#0@@11|)) |##Upperbounded_Lexicographic_Byte_Order.Element.Element|))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4792|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#0#0#0@@11|))
)))
(assert (forall ((d@@155 T@U) ) (!  (=> (= (type d@@155) DatatypeTypeType) (= (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@155) (= (DatatypeCtorId d@@155) |##Upperbounded_Lexicographic_Byte_Order.Element.Element|)))
 :qid |unknown.0:0|
 :skolemid |4793|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@155))
)))
(assert (forall ((d@@156 T@U) ) (!  (=> (and (= (type d@@156) DatatypeTypeType) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@156)) (exists ((|a#1#0#0@@11| T@U) ) (!  (and (= (type |a#1#0#0@@11|) (SeqType BoxType)) (= d@@156 (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#1#0#0@@11|)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4794|
 :no-pattern (type |a#1#0#0@@11|)
 :no-pattern (U_2_int |a#1#0#0@@11|)
 :no-pattern (U_2_bool |a#1#0#0@@11|)
)))
 :qid |unknown.0:0|
 :skolemid |4795|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@156))
)))
(assert (forall ((|a#2#0#0@@11| T@U) ) (!  (=> (= (type |a#2#0#0@@11|) (SeqType BoxType)) (= ($Is (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#2#0#0@@11|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |a#2#0#0@@11| (TSeq Tclass.NativeTypes.byte))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4796|
 :pattern ( ($Is (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#2#0#0@@11|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (forall ((|a#3#0#0@@11| T@U) ($h@@163 T@U) ) (!  (=> (and (and (= (type |a#3#0#0@@11|) (SeqType BoxType)) (= (type $h@@163) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@163)) (= ($IsAlloc (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#3#0#0@@11|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@163) ($IsAlloc |a#3#0#0@@11| (TSeq Tclass.NativeTypes.byte) $h@@163)))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4797|
 :pattern ( ($IsAlloc (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#3#0#0@@11|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@163))
)))
(assert (forall ((d@@157 T@U) ($h@@164 T@U) ) (!  (=> (and (and (= (type d@@157) DatatypeTypeType) (= (type $h@@164) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@164) (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@157) ($IsAlloc d@@157 Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@164)))) ($IsAlloc (Upperbounded__Lexicographic__Byte__Order.Element.e d@@157) (TSeq Tclass.NativeTypes.byte) $h@@164))
 :qid |unknown.0:0|
 :skolemid |4798|
 :pattern ( ($IsAlloc (Upperbounded__Lexicographic__Byte__Order.Element.e d@@157) (TSeq Tclass.NativeTypes.byte) $h@@164))
)))
(assert (forall ((|a#4#0#0@@11| T@U) ) (!  (=> (= (type |a#4#0#0@@11|) (SeqType BoxType)) (= (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |a#4#0#0@@11|)) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#4#0#0@@11|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4799|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |a#4#0#0@@11|)))
)))
(assert (forall ((|a#5#0#0@@12| T@U) ) (!  (=> (= (type |a#5#0#0@@12|) (SeqType BoxType)) (= (Upperbounded__Lexicographic__Byte__Order.Element.e (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#5#0#0@@12|)) |a#5#0#0@@12|))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4800|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#5#0#0@@12|))
)))
(assert (forall ((|a#6#0#0@@12| T@U) (i@@29 Int) ) (!  (=> (= (type |a#6#0#0@@12|) (SeqType BoxType)) (=> (and (<= 0 i@@29) (< i@@29 (|Seq#Length| |a#6#0#0@@12|))) (< (DtRank ($Unbox DatatypeTypeType (|Seq#Index| |a#6#0#0@@12| i@@29))) (DtRank (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#6#0#0@@12|)))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4801|
 :pattern ( (|Seq#Index| |a#6#0#0@@12| i@@29) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#6#0#0@@12|))
)))
(assert (forall ((|a#7#0#0@@11| T@U) ) (!  (=> (= (type |a#7#0#0@@11|) (SeqType BoxType)) (< (|Seq#Rank| |a#7#0#0@@11|) (DtRank (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#7#0#0@@11|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:30|
 :skolemid |4802|
 :pattern ( (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |a#7#0#0@@11|))
)))
(assert (= (DatatypeCtorId |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|) |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))
(assert (forall ((d@@158 T@U) ) (!  (=> (= (type d@@158) DatatypeTypeType) (= (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@158) (= (DatatypeCtorId d@@158) |##Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))
 :qid |unknown.0:0|
 :skolemid |4803|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@158))
)))
(assert (forall ((d@@159 T@U) ) (!  (=> (and (= (type d@@159) DatatypeTypeType) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@159)) (= d@@159 |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))
 :qid |unknown.0:0|
 :skolemid |4804|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@159))
)))
(assert ($Is |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
(assert (forall (($h@@165 T@U) ) (!  (=> (and (= (type $h@@165) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@165)) ($IsAlloc |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@165))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |4805|
 :pattern ( ($IsAlloc |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@165))
)))
(assert (= |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element| (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))
(assert (forall ((d@@160 T@U) ) (!  (=> (and (= (type d@@160) DatatypeTypeType) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| d@@160)) (or (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@160) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@160)))
 :qid |unknown.0:0|
 :skolemid |4806|
 :pattern ( (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| d@@160))
)))
(assert (forall ((d@@161 T@U) ) (!  (=> (and (= (type d@@161) DatatypeTypeType) ($Is d@@161 Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (or (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@161) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@161)))
 :qid |unknown.0:0|
 :skolemid |4807|
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q d@@161) ($Is d@@161 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :pattern ( (Upperbounded__Lexicographic__Byte__Order.Element.Element_q d@@161) ($Is d@@161 Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
)))
(assert (forall ((a@@167 T@U) (b@@116 T@U) ) (!  (=> (and (and (= (type a@@167) DatatypeTypeType) (= (type b@@116) DatatypeTypeType)) (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q a@@167) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q b@@116))) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@167 b@@116) (|Seq#Equal| (Upperbounded__Lexicographic__Byte__Order.Element.e a@@167) (Upperbounded__Lexicographic__Byte__Order.Element.e b@@116))))
 :qid |unknown.0:0|
 :skolemid |4808|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@167 b@@116) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q a@@167))
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@167 b@@116) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q b@@116))
)))
(assert (forall ((a@@168 T@U) (b@@117 T@U) ) (!  (=> (and (and (= (type a@@168) DatatypeTypeType) (= (type b@@117) DatatypeTypeType)) (and (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q a@@168) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q b@@117))) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@168 b@@117) true))
 :qid |unknown.0:0|
 :skolemid |4809|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@168 b@@117) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q a@@168))
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@168 b@@117) (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q b@@117))
)))
(assert (forall ((a@@169 T@U) (b@@118 T@U) ) (!  (=> (and (= (type a@@169) DatatypeTypeType) (= (type b@@118) DatatypeTypeType)) (= (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@169 b@@118) (= a@@169 b@@118)))
 :qid |unknown.0:0|
 :skolemid |4810|
 :pattern ( (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| a@@169 b@@118))
)))
(assert (= (type Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) TyType))
(assert (= (Tag Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) Tagclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
(assert (= (TagFamily Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default) tytagFamily$_default))
(assert (forall ((bx@@168 T@U) ) (!  (=> (and (= (type bx@@168) BoxType) ($IsBox bx@@168 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)) (and (= ($Box ($Unbox refType bx@@168)) bx@@168) ($Is ($Unbox refType bx@@168) Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)))
 :qid |unknown.0:0|
 :skolemid |4811|
 :pattern ( ($IsBox bx@@168 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
)))
(assert (forall (($o@@63 T@U) ) (!  (=> (= (type $o@@63) refType) (= ($Is $o@@63 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default)  (or (= $o@@63 null) (= (dtype $o@@63) Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))))
 :qid |unknown.0:0|
 :skolemid |4812|
 :pattern ( ($Is $o@@63 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default))
)))
(assert (forall (($o@@64 T@U) ($h@@166 T@U) ) (!  (=> (and (= (type $o@@64) refType) (= (type $h@@166) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@64 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default $h@@166)  (or (= $o@@64 null) (U_2_bool (MapType1Select (MapType0Select $h@@166 $o@@64) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4813|
 :pattern ( ($IsAlloc $o@@64 Tclass.Upperbounded__Lexicographic__Byte__Order__Impl.__default $h@@166))
)))
(assert (= (type Tclass.BoundedPivotsLib.__default) TyType))
(assert (= (Tag Tclass.BoundedPivotsLib.__default) Tagclass.BoundedPivotsLib.__default))
(assert (= (TagFamily Tclass.BoundedPivotsLib.__default) tytagFamily$_default))
(assert (forall ((bx@@169 T@U) ) (!  (=> (and (= (type bx@@169) BoxType) ($IsBox bx@@169 Tclass.BoundedPivotsLib.__default)) (and (= ($Box ($Unbox refType bx@@169)) bx@@169) ($Is ($Unbox refType bx@@169) Tclass.BoundedPivotsLib.__default)))
 :qid |unknown.0:0|
 :skolemid |4814|
 :pattern ( ($IsBox bx@@169 Tclass.BoundedPivotsLib.__default))
)))
(assert (forall (($o@@65 T@U) ) (!  (=> (= (type $o@@65) refType) (= ($Is $o@@65 Tclass.BoundedPivotsLib.__default)  (or (= $o@@65 null) (= (dtype $o@@65) Tclass.BoundedPivotsLib.__default))))
 :qid |unknown.0:0|
 :skolemid |4815|
 :pattern ( ($Is $o@@65 Tclass.BoundedPivotsLib.__default))
)))
(assert (forall (($o@@66 T@U) ($h@@167 T@U) ) (!  (=> (and (= (type $o@@66) refType) (= (type $h@@167) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@66 Tclass.BoundedPivotsLib.__default $h@@167)  (or (= $o@@66 null) (U_2_bool (MapType1Select (MapType0Select $h@@167 $o@@66) alloc)))))
 :qid |unknown.0:0|
 :skolemid |4816|
 :pattern ( ($IsAlloc $o@@66 Tclass.BoundedPivotsLib.__default $h@@167))
)))
(assert  (=> true (forall ((|e#0@@20| T@U) ) (!  (=> (and (= (type |e#0@@20|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| |e#0@@20|) ($Is |e#0@@20| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) true)
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |4817|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey |e#0@@20|))
))))
(assert (forall ((|e#0@@21| T@U) ) (!  (=> (and (= (type |e#0@@21|) DatatypeTypeType) ($Is |e#0@@21| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|BoundedPivotsLib.__default.ElementIsKey#requires| |e#0@@21|) true))
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |4818|
 :pattern ( (|BoundedPivotsLib.__default.ElementIsKey#requires| |e#0@@21|))
)))
(assert  (=> true (forall ((|e#0@@22| T@U) ) (!  (=> (and (= (type |e#0@@22|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| |e#0@@22|) ($Is |e#0@@22| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@22|) |KeyType.__default.MaxLen#canCall|) (= (BoundedPivotsLib.__default.ElementIsKey |e#0@@22|)  (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@22|) (INTERNAL_le_boogie (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |e#0@@22|)) KeyType.__default.MaxLen)))))
 :qid |BoundedPivotsLibidfy.30:26|
 :skolemid |4819|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey |e#0@@22|))
))))
(assert  (=> true (forall ((|e#0@@23| T@U) ) (!  (=> (and (= (type |e#0@@23|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit |e#0@@23|)) ($Is |e#0@@23| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (and (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@23|))))) |KeyType.__default.MaxLen#canCall|) (= (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@23|))  (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@23|)) (INTERNAL_le_boogie (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |e#0@@23|)))) KeyType.__default.MaxLen)))))
 :qid |BoundedPivotsLibidfy.30:26|
 :weight 3
 :skolemid |4820|
 :pattern ( (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@23|)))
))))
(assert  (=> true (forall ((|pt#0| T@U) ) (!  (=> (and (= (type |pt#0|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0|) ($Is |pt#0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |4821|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys |pt#0|))
))))
(assert (forall ((|pt#0@@0| T@U) ) (!  (=> (and (= (type |pt#0@@0|) (SeqType BoxType)) ($Is |pt#0@@0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ElementsAreKeys#requires| |pt#0@@0|) true))
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |4822|
 :pattern ( (|BoundedPivotsLib.__default.ElementsAreKeys#requires| |pt#0@@0|))
)))
(assert  (=> true (forall ((|pt#0@@1| T@U) ) (!  (=> (and (= (type |pt#0@@1|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0@@1|) ($Is |pt#0@@1| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@170| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0@@170|) (INTERNAL_lt_boogie |i#0@@170| (|Seq#Length| |pt#0@@1|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@170|)))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@170|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |4824|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@170|)))
))) (= (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@1|)  (and true (forall ((|i#0@@171| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#0@@171|) (INTERNAL_lt_boogie |i#0@@171| (|Seq#Length| |pt#0@@1|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@171|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@171|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |4823|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@1| |i#0@@171|)))
))))))
 :qid |BoundedPivotsLibidfy.37:29|
 :skolemid |4825|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@1|))
))))
(assert  (=> true (forall ((|pt#0@@2| T@U) ) (!  (=> (and (= (type |pt#0@@2|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (Lit |pt#0@@2|)) ($Is |pt#0@@2| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@64| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#1@@64|) (INTERNAL_lt_boogie |i#1@@64| (|Seq#Length| (Lit |pt#0@@2|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@64|)))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@64|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |4827|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@2| |i#1@@64|)))
))) (= (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@2|))  (and true (forall ((|i#1@@65| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#1@@65|) (INTERNAL_lt_boogie |i#1@@65| (|Seq#Length| (Lit |pt#0@@2|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@65|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@2|) |i#1@@65|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |4826|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@2| |i#1@@65|)))
))))))
 :qid |BoundedPivotsLibidfy.37:29|
 :weight 3
 :skolemid |4828|
 :pattern ( (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@2|)))
))))
(assert (forall ((arg0@@645 T@U) ) (! (= (type (BoundedPivotsLib.__default.KeyToElement arg0@@645)) DatatypeTypeType)
 :qid |funType:BoundedPivotsLib.__default.KeyToElement|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement arg0@@645))
)))
(assert  (=> true (forall ((|key#0@@193| T@U) ) (!  (=> (and (= (type |key#0@@193|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@193|) ($Is |key#0@@193| Tclass.KeyType.Key))) ($Is (BoundedPivotsLib.__default.KeyToElement |key#0@@193|) Tclass.Upperbounded__Lexicographic__Byte__Order.Element))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |4829|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement |key#0@@193|))
))))
(assert (forall ((|key#0@@194| T@U) ) (!  (=> (and (= (type |key#0@@194|) (SeqType BoxType)) ($Is |key#0@@194| Tclass.KeyType.Key)) (= (|BoundedPivotsLib.__default.KeyToElement#requires| |key#0@@194|) true))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |4830|
 :pattern ( (|BoundedPivotsLib.__default.KeyToElement#requires| |key#0@@194|))
)))
(assert  (=> true (forall ((|key#0@@195| T@U) ) (!  (=> (and (= (type |key#0@@195|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@195|) ($Is |key#0@@195| Tclass.KeyType.Key))) (= (BoundedPivotsLib.__default.KeyToElement |key#0@@195|) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@195|)))
 :qid |BoundedPivotsLibidfy.42:25|
 :skolemid |4831|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement |key#0@@195|))
))))
(assert  (=> true (forall ((|key#0@@196| T@U) ) (!  (=> (and (= (type |key#0@@196|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@196|)) ($Is |key#0@@196| Tclass.KeyType.Key))) (= (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@196|)) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@196|)))))
 :qid |BoundedPivotsLibidfy.42:25|
 :weight 3
 :skolemid |4832|
 :pattern ( (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@196|)))
))))
(assert (forall ((arg0@@646 T@U) ) (! (= (type (BoundedPivotsLib.__default.KeysToElements arg0@@646)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.KeysToElements|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements arg0@@646))
)))
(assert  (=> true (forall ((|keys#0@@3| T@U) ) (!  (=> (and (= (type |keys#0@@3|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| |keys#0@@3|) ($Is |keys#0@@3| (TSeq Tclass.KeyType.Key)))) (and (= (|Seq#Length| |keys#0@@3|) (|Seq#Length| (BoundedPivotsLib.__default.KeysToElements |keys#0@@3|))) ($Is (BoundedPivotsLib.__default.KeysToElements |keys#0@@3|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.47:27|
 :skolemid |4833|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements |keys#0@@3|))
))))
(assert (forall (($Heap@@105 T@U) (|keys#0@@4| T@U) ) (!  (=> (and (and (= (type $Heap@@105) (MapType0Type refType MapType1Type)) (= (type |keys#0@@4|) (SeqType BoxType))) (and ($IsGoodHeap $Heap@@105) ($Is |keys#0@@4| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.KeysToElements#requires| |keys#0@@4|) true))
 :qid |BoundedPivotsLibidfy.47:12|
 :skolemid |4834|
 :pattern ( (|BoundedPivotsLib.__default.KeysToElements#requires| |keys#0@@4|) ($IsGoodHeap $Heap@@105))
)))
(assert  (=> true (forall (($Heap@@106 T@U) (|keys#0@@5| T@U) ) (!  (=> (and (and (= (type $Heap@@106) (MapType0Type refType MapType1Type)) (= (type |keys#0@@5|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| |keys#0@@5|) (and ($IsGoodHeap $Heap@@106) ($Is |keys#0@@5| (TSeq Tclass.KeyType.Key))))) (= (BoundedPivotsLib.__default.KeysToElements |keys#0@@5|) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@106 (|Seq#Length| |keys#0@@5|) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#315| |keys#0@@5|) (|lambda#128| TInt 0 (|Seq#Length| |keys#0@@5|)) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))
 :qid |BoundedPivotsLibidfy.47:12|
 :skolemid |4835|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements |keys#0@@5|) ($IsGoodHeap $Heap@@106))
))))
(assert  (=> true (forall (($Heap@@107 T@U) (|keys#0@@6| T@U) ) (!  (=> (and (and (= (type $Heap@@107) (MapType0Type refType MapType1Type)) (= (type |keys#0@@6|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.KeysToElements#canCall| (Lit |keys#0@@6|)) (and ($IsGoodHeap $Heap@@107) ($Is |keys#0@@6| (TSeq Tclass.KeyType.Key))))) (= (BoundedPivotsLib.__default.KeysToElements (Lit |keys#0@@6|)) (|Seq#Create| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $Heap@@107 (|Seq#Length| (Lit |keys#0@@6|)) (Lit (AtLayer (|lambda#131| (Handle1 (|lambda#315| (Lit |keys#0@@6|)) (|lambda#128| TInt 0 (|Seq#Length| (Lit |keys#0@@6|))) (|lambda#130| (SetRef_to_SetBox (|lambda#129| false))))) ($LS $LZ))))))
 :qid |BoundedPivotsLibidfy.47:12|
 :weight 3
 :skolemid |4836|
 :pattern ( (BoundedPivotsLib.__default.KeysToElements (Lit |keys#0@@6|)) ($IsGoodHeap $Heap@@107))
))))
(assert  (=> true (forall ((|pt#0@@3| T@U) ) (!  (=> (and (= (type |pt#0@@3|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@3|) ($Is |pt#0@@3| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |4837|
 :pattern ( (BoundedPivotsLib.__default.WFPivots |pt#0@@3|))
))))
(assert (forall ((|pt#0@@4| T@U) ) (!  (=> (and (= (type |pt#0@@4|) (SeqType BoxType)) ($Is |pt#0@@4| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.WFPivots#requires| |pt#0@@4|) true))
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |4838|
 :pattern ( (|BoundedPivotsLib.__default.WFPivots#requires| |pt#0@@4|))
)))
(assert  (=> true (forall ((|pt#0@@5| T@U) ) (!  (=> (and (= (type |pt#0@@5|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@5|) ($Is |pt#0@@5| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| |pt#0@@5|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted |pt#0@@5|) (and (forall ((|i#0@@172| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#0@@172|) (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@5|))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4840|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@172|)))
)) (=> (forall ((|i#0@@173| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@173|) (INTERNAL_lt_boogie |i#0@@173| (BoundedPivotsLib.__default.NumBuckets |pt#0@@5|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@173|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4841|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@173|)))
)) (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |pt#0@@5|))))) (= (BoundedPivotsLib.__default.WFPivots |pt#0@@5|)  (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted |pt#0@@5|) (forall ((|i#0@@174| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@174|) (INTERNAL_lt_boogie |i#0@@174| (BoundedPivotsLib.__default.NumBuckets |pt#0@@5|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@174|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4839|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@5| |i#0@@174|)))
))) (BoundedPivotsLib.__default.ElementsAreKeys |pt#0@@5|)) (INTERNAL_ge_boogie (|Seq#Length| |pt#0@@5|) 2)))))
 :qid |BoundedPivotsLibidfy.53:22|
 :skolemid |4842|
 :pattern ( (BoundedPivotsLib.__default.WFPivots |pt#0@@5|))
))))
(assert  (=> true (forall ((|pt#0@@6| T@U) ) (!  (=> (and (= (type |pt#0@@6|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit |pt#0@@6|)) ($Is |pt#0@@6| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted#canCall| (Lit |pt#0@@6|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |pt#0@@6|)) (and (forall ((|i#1@@66| Int) ) (!  (=> (INTERNAL_le_boogie 0 |i#1@@66|) (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit |pt#0@@6|)))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4844|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@66|)))
)) (=> (forall ((|i#1@@67| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@67|) (INTERNAL_lt_boogie |i#1@@67| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@6|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@6|) |i#1@@67|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4845|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@67|)))
)) (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (Lit |pt#0@@6|)))))) (= (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@6|))  (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |pt#0@@6|)) (forall ((|i#1@@68| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@68|) (INTERNAL_lt_boogie |i#1@@68| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@6|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@6|) |i#1@@68|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |4843|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@6| |i#1@@68|)))
))) (BoundedPivotsLib.__default.ElementsAreKeys (Lit |pt#0@@6|))) (INTERNAL_ge_boogie (|Seq#Length| (Lit |pt#0@@6|)) 2)))))
 :qid |BoundedPivotsLibidfy.53:22|
 :weight 3
 :skolemid |4846|
 :pattern ( (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@6|)))
))))
(assert  (=> true (forall ((|pt#0@@7| T@U) ) (!  (=> (and (= (type |pt#0@@7|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| |pt#0@@7|) ($Is |pt#0@@7| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |4847|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@7|))
))))
(assert (forall ((|pt#0@@8| T@U) ) (!  (=> (and (= (type |pt#0@@8|) (SeqType BoxType)) ($Is |pt#0@@8| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ContainsAllKeys#requires| |pt#0@@8|) true))
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |4848|
 :pattern ( (|BoundedPivotsLib.__default.ContainsAllKeys#requires| |pt#0@@8|))
)))
(assert  (=> true (forall ((|pt#0@@9| T@U) ) (!  (=> (and (= (type |pt#0@@9|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| |pt#0@@9|) ($Is |pt#0@@9| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|BoundedPivotsLib.__default.WFPivots#canCall| |pt#0@@9|) (=> (BoundedPivotsLib.__default.WFPivots |pt#0@@9|) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@9|) 1)))))))) (= (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@9|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@9|) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType))))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@9| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@9|) 1))) |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
 :qid |BoundedPivotsLibidfy.61:29|
 :skolemid |4849|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys |pt#0@@9|))
))))
(assert  (=> true (forall ((|pt#0@@10| T@U) ) (!  (=> (and (= (type |pt#0@@10|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.ContainsAllKeys#canCall| (Lit |pt#0@@10|)) ($Is |pt#0@@10| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (and (and (|BoundedPivotsLib.__default.WFPivots#canCall| (Lit |pt#0@@10|)) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@10|))))) (and (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0)))) (=> (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))) (|$IsA#Upperbounded__Lexicographic__Byte__Order.Element| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@10|)) 1)))))))) (= (BoundedPivotsLib.__default.ContainsAllKeys (Lit |pt#0@@10|))  (and (and (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@10|)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (LitInt 0))) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType))))) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@10|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@10|)) 1))) |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
 :qid |BoundedPivotsLibidfy.61:29|
 :weight 3
 :skolemid |4850|
 :pattern ( (BoundedPivotsLib.__default.ContainsAllKeys (Lit |pt#0@@10|)))
))))
(assert  (=> true (forall ((|pt#0@@11| T@U) (|left#0@@11| T@U) (|right#0@@11| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@11|) (SeqType BoxType)) (= (type |left#0@@11|) DatatypeTypeType)) (= (type |right#0@@11|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| |pt#0@@11| |left#0@@11| |right#0@@11|) (and (and (and ($Is |pt#0@@11| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@11| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@11|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@11|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@11| |right#0@@11|))))) true)
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |4851|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange |pt#0@@11| |left#0@@11| |right#0@@11|))
))))
(assert (forall ((|pt#0@@12| T@U) (|left#0@@12| T@U) (|right#0@@12| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@12|) (SeqType BoxType)) (= (type |left#0@@12|) DatatypeTypeType)) (= (type |right#0@@12|) DatatypeTypeType)) (and (and ($Is |pt#0@@12| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.ContainsRange#requires| |pt#0@@12| |left#0@@12| |right#0@@12|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@12|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@12|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@12| |right#0@@12|))))
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |4852|
 :pattern ( (|BoundedPivotsLib.__default.ContainsRange#requires| |pt#0@@12| |left#0@@12| |right#0@@12|))
)))
(assert  (=> true (forall ((|pt#0@@13| T@U) (|left#0@@13| T@U) (|right#0@@13| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@13|) (SeqType BoxType)) (= (type |left#0@@13|) DatatypeTypeType)) (= (type |right#0@@13|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| |pt#0@@13| |left#0@@13| |right#0@@13|) (and (and (and ($Is |pt#0@@13| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@13| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@13|) (BoundedPivotsLib.__default.ElementIsKey |left#0@@13|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@13| |right#0@@13|))))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |right#0@@13| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@13|) 1)))))) (= (BoundedPivotsLib.__default.ContainsRange |pt#0@@13| |left#0@@13| |right#0@@13|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (LitInt 0))) |left#0@@13|) (Upperbounded__Lexicographic__Byte__Order.__default.lte |right#0@@13| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@13|) 1))))))))
 :qid |BoundedPivotsLibidfy.88:27|
 :skolemid |4853|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange |pt#0@@13| |left#0@@13| |right#0@@13|))
))))
(assert  (=> true (forall ((|pt#0@@14| T@U) (|left#0@@14| T@U) (|right#0@@14| T@U) ) (!  (=> (and (and (and (= (type |pt#0@@14|) (SeqType BoxType)) (= (type |left#0@@14|) DatatypeTypeType)) (= (type |right#0@@14|) DatatypeTypeType)) (or (|BoundedPivotsLib.__default.ContainsRange#canCall| (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|)) (and (and (and ($Is |pt#0@@14| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |left#0@@14| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |right#0@@14| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@14|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ElementIsKey (Lit |left#0@@14|)))))) (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |left#0@@14|) (Lit |right#0@@14|))))))))) (and (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |right#0@@14|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@14|)) 1)))))) (= (BoundedPivotsLib.__default.ContainsRange (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (LitInt 0))) (Lit |left#0@@14|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |right#0@@14|) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@14|)) 1))))))))
 :qid |BoundedPivotsLibidfy.88:27|
 :weight 3
 :skolemid |4854|
 :pattern ( (BoundedPivotsLib.__default.ContainsRange (Lit |pt#0@@14|) (Lit |left#0@@14|) (Lit |right#0@@14|)))
))))
(assert  (=> true (forall ((|pt#0@@15| T@U) (|key#0@@197| T@U) ) (!  (=> (and (and (= (type |pt#0@@15|) (SeqType BoxType)) (= (type |key#0@@197|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@15| |key#0@@197|) (and (and ($Is |pt#0@@15| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@197| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@15|)))) true)
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |4855|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@15| |key#0@@197|))
))))
(assert (forall ((|pt#0@@16| T@U) (|key#0@@198| T@U) ) (!  (=> (and (and (= (type |pt#0@@16|) (SeqType BoxType)) (= (type |key#0@@198|) (SeqType BoxType))) (and ($Is |pt#0@@16| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@198| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.BoundedKey#requires| |pt#0@@16| |key#0@@198|) (BoundedPivotsLib.__default.WFPivots |pt#0@@16|)))
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |4856|
 :pattern ( (|BoundedPivotsLib.__default.BoundedKey#requires| |pt#0@@16| |key#0@@198|))
)))
(assert  (=> true (forall ((|pt#0@@17| T@U) (|key#0@@199| T@U) ) (!  (=> (and (and (= (type |pt#0@@17|) (SeqType BoxType)) (= (type |key#0@@199|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@17| |key#0@@199|) (and (and ($Is |pt#0@@17| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@199| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@17|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@199|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@199|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@199|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@199|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@17|) 1))))))) (= (BoundedPivotsLib.__default.BoundedKey |pt#0@@17| |key#0@@199|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@199|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@199|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@17| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@17|) 1))))))))
 :qid |BoundedPivotsLibidfy.124:24|
 :skolemid |4857|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@17| |key#0@@199|))
))))
(assert  (=> true (forall ((|pt#0@@18| T@U) (|key#0@@200| T@U) ) (!  (=> (and (and (= (type |pt#0@@18|) (SeqType BoxType)) (= (type |key#0@@200|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@18|) (Lit |key#0@@200|)) (and (and ($Is |pt#0@@18| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@200| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@18|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@200|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@200|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@200|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@200|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@18|)) 1))))))) (= (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@18|) (Lit |key#0@@200|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@200|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@200|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@18|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@18|)) 1))))))))
 :qid |BoundedPivotsLibidfy.124:24|
 :weight 3
 :skolemid |4858|
 :pattern ( (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@18|) (Lit |key#0@@200|)))
))))
(assert  (=> true (forall ((|pt#0@@19| T@U) (|keys#0@@7| T@U) ) (!  (=> (and (and (= (type |pt#0@@19|) (SeqType BoxType)) (= (type |keys#0@@7|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| |pt#0@@19| |keys#0@@7|) (and (and ($Is |pt#0@@19| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@7| (TSeq Tclass.KeyType.Key))) (BoundedPivotsLib.__default.WFPivots |pt#0@@19|)))) true)
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |4859|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@19| |keys#0@@7|))
))))
(assert (forall ((|pt#0@@20| T@U) (|keys#0@@8| T@U) ) (!  (=> (and (and (= (type |pt#0@@20|) (SeqType BoxType)) (= (type |keys#0@@8|) (SeqType BoxType))) (and ($Is |pt#0@@20| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@8| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.BoundedKeySeq#requires| |pt#0@@20| |keys#0@@8|) (BoundedPivotsLib.__default.WFPivots |pt#0@@20|)))
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |4860|
 :pattern ( (|BoundedPivotsLib.__default.BoundedKeySeq#requires| |pt#0@@20| |keys#0@@8|))
)))
(assert  (=> true (forall ((|pt#0@@21| T@U) (|keys#0@@9| T@U) ) (!  (=> (and (and (= (type |pt#0@@21|) (SeqType BoxType)) (= (type |keys#0@@9|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| |pt#0@@21| |keys#0@@9|) (and (and ($Is |pt#0@@21| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@9| (TSeq Tclass.KeyType.Key))) (BoundedPivotsLib.__default.WFPivots |pt#0@@21|)))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#0@@175| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@175|) (INTERNAL_lt_boogie |i#0@@175| (|Seq#Length| |keys#0@@9|))) (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@21| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@9| |i#0@@175|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |4862|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@9| |i#0@@175|)))
))) (= (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@21| |keys#0@@9|)  (and true (forall ((|i#0@@176| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@176|) (INTERNAL_lt_boogie |i#0@@176| (|Seq#Length| |keys#0@@9|))) (BoundedPivotsLib.__default.BoundedKey |pt#0@@21| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@9| |i#0@@176|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |4861|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@9| |i#0@@176|)))
))))))
 :qid |BoundedPivotsLibidfy.131:27|
 :skolemid |4863|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq |pt#0@@21| |keys#0@@9|))
))))
(assert  (=> true (forall ((|pt#0@@22| T@U) (|keys#0@@10| T@U) ) (!  (=> (and (and (= (type |pt#0@@22|) (SeqType BoxType)) (= (type |keys#0@@10|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedKeySeq#canCall| (Lit |pt#0@@22|) (Lit |keys#0@@10|)) (and (and ($Is |pt#0@@22| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@10| (TSeq Tclass.KeyType.Key))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@22|)))))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (forall ((|i#1@@69| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@69|) (INTERNAL_lt_boogie |i#1@@69| (|Seq#Length| (Lit |keys#0@@10|)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@22|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@10|) |i#1@@69|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |4865|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#1@@69|)))
))) (= (BoundedPivotsLib.__default.BoundedKeySeq (Lit |pt#0@@22|) (Lit |keys#0@@10|))  (and true (forall ((|i#1@@70| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@70|) (INTERNAL_lt_boogie |i#1@@70| (|Seq#Length| (Lit |keys#0@@10|)))) (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@22|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@10|) |i#1@@70|))))
 :qid |BoundedPivotsLibidfy.134:15|
 :skolemid |4864|
 :pattern ( ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@10| |i#1@@70|)))
))))))
 :qid |BoundedPivotsLibidfy.131:27|
 :weight 3
 :skolemid |4866|
 :pattern ( (BoundedPivotsLib.__default.BoundedKeySeq (Lit |pt#0@@22|) (Lit |keys#0@@10|)))
))))
(assert  (=> true (forall ((|pt#0@@23| T@U) (|keys#0@@11| T@U) ) (!  (=> (and (and (= (type |pt#0@@23|) (SeqType BoxType)) (= (type |keys#0@@11|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| |pt#0@@23| |keys#0@@11|) (and (and ($Is |pt#0@@23| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@11| (TSeq Tclass.KeyType.Key))) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@23|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@11|))))) true)
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |4867|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@23| |keys#0@@11|))
))))
(assert (forall ((|pt#0@@24| T@U) (|keys#0@@12| T@U) ) (!  (=> (and (and (= (type |pt#0@@24|) (SeqType BoxType)) (= (type |keys#0@@12|) (SeqType BoxType))) (and ($Is |pt#0@@24| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@12| (TSeq Tclass.KeyType.Key)))) (= (|BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| |pt#0@@24| |keys#0@@12|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@24|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@12|))))
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |4868|
 :pattern ( (|BoundedPivotsLib.__default.BoundedSortedKeySeq#requires| |pt#0@@24| |keys#0@@12|))
)))
(assert  (=> true (forall ((|pt#0@@25| T@U) (|keys#0@@13| T@U) ) (!  (=> (and (and (= (type |pt#0@@25|) (SeqType BoxType)) (= (type |keys#0@@13|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| |pt#0@@25| |keys#0@@13|) (and (and ($Is |pt#0@@25| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@13| (TSeq Tclass.KeyType.Key))) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@25|) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted |keys#0@@13|))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (INTERNAL_gt_boogie (|Seq#Length| |keys#0@@13|) 0) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@13| (LitInt 0)))) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@13| (LitInt 0)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |keys#0@@13|) 1)))))))) (= (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@25| |keys#0@@13|)  (and true (=> (INTERNAL_gt_boogie (|Seq#Length| |keys#0@@13|) 0) (and (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@13| (LitInt 0)))) (BoundedPivotsLib.__default.BoundedKey |pt#0@@25| ($Unbox (SeqType BoxType) (|Seq#Index| |keys#0@@13| (INTERNAL_sub_boogie (|Seq#Length| |keys#0@@13|) 1))))))))))
 :qid |BoundedPivotsLibidfy.137:33|
 :skolemid |4869|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq |pt#0@@25| |keys#0@@13|))
))))
(assert  (=> true (forall ((|pt#0@@26| T@U) (|keys#0@@14| T@U) ) (!  (=> (and (and (= (type |pt#0@@26|) (SeqType BoxType)) (= (type |keys#0@@14|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.BoundedSortedKeySeq#canCall| (Lit |pt#0@@26|) (Lit |keys#0@@14|)) (and (and ($Is |pt#0@@26| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |keys#0@@14| (TSeq Tclass.KeyType.Key))) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@26|))))) (Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted (Lit |keys#0@@14|)))))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (INTERNAL_gt_boogie (|Seq#Length| (Lit |keys#0@@14|)) 0) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@14|) (LitInt 0)))) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@14|) (LitInt 0)))) (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |keys#0@@14|)) 1)))))))) (= (BoundedPivotsLib.__default.BoundedSortedKeySeq (Lit |pt#0@@26|) (Lit |keys#0@@14|))  (and true (=> (INTERNAL_gt_boogie (|Seq#Length| (Lit |keys#0@@14|)) 0) (and (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@14|) (LitInt 0)))) (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@26|) ($Unbox (SeqType BoxType) (|Seq#Index| (Lit |keys#0@@14|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |keys#0@@14|)) 1))))))))))
 :qid |BoundedPivotsLibidfy.137:33|
 :weight 3
 :skolemid |4870|
 :pattern ( (BoundedPivotsLib.__default.BoundedSortedKeySeq (Lit |pt#0@@26|) (Lit |keys#0@@14|)))
))))
(assert  (=> true (forall ((|pt#0@@27| T@U) (|key#0@@201| T@U) ) (!  (=> (and (and (= (type |pt#0@@27|) (SeqType BoxType)) (= (type |key#0@@201|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| |pt#0@@27| |key#0@@201|) (and (and ($Is |pt#0@@27| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@201| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@27|)))) true)
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |4871|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@27| |key#0@@201|))
))))
(assert (forall ((|pt#0@@28| T@U) (|key#0@@202| T@U) ) (!  (=> (and (and (= (type |pt#0@@28|) (SeqType BoxType)) (= (type |key#0@@202|) (SeqType BoxType))) (and ($Is |pt#0@@28| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@202| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| |pt#0@@28| |key#0@@202|) (BoundedPivotsLib.__default.WFPivots |pt#0@@28|)))
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |4872|
 :pattern ( (|BoundedPivotsLib.__default.ValidLeftCutOffKey#requires| |pt#0@@28| |key#0@@202|))
)))
(assert  (=> true (forall ((|pt#0@@29| T@U) (|key#0@@203| T@U) ) (!  (=> (and (and (= (type |pt#0@@29|) (SeqType BoxType)) (= (type |key#0@@203|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| |pt#0@@29| |key#0@@203|) (and (and ($Is |pt#0@@29| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@203| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@29|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@203|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@203|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@203|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@203|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@203|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@29|) 1))))))) (= (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@29| |key#0@@203|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |key#0@@203|)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement |key#0@@203|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@29| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@29|) 1))))))))
 :qid |BoundedPivotsLibidfy.168:32|
 :skolemid |4873|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@29| |key#0@@203|))
))))
(assert  (=> true (forall ((|pt#0@@30| T@U) (|key#0@@204| T@U) ) (!  (=> (and (and (= (type |pt#0@@30|) (SeqType BoxType)) (= (type |key#0@@204|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.ValidLeftCutOffKey#canCall| (Lit |pt#0@@30|) (Lit |key#0@@204|)) (and (and ($Is |pt#0@@30| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@204| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@30|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@204|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@204|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@204|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@204|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@204|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@30|)) 1))))))) (= (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@30|) (Lit |key#0@@204|))  (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (LitInt 0))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@204|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@204|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@30|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@30|)) 1))))))))
 :qid |BoundedPivotsLibidfy.168:32|
 :weight 3
 :skolemid |4874|
 :pattern ( (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@30|) (Lit |key#0@@204|)))
))))
(assert  (=> true (forall ((|pt#0@@31| T@U) ) (!  (=> (and (= (type |pt#0@@31|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@31|) ($Is |pt#0@@31| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) true)
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |4875|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets |pt#0@@31|))
))))
(assert (forall ((|pt#0@@32| T@U) ) (!  (=> (and (= (type |pt#0@@32|) (SeqType BoxType)) ($Is |pt#0@@32| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.NumBuckets#requires| |pt#0@@32|) true))
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |4876|
 :pattern ( (|BoundedPivotsLib.__default.NumBuckets#requires| |pt#0@@32|))
)))
(assert  (=> true (forall ((|pt#0@@33| T@U) ) (!  (=> (and (= (type |pt#0@@33|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| |pt#0@@33|) ($Is |pt#0@@33| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (BoundedPivotsLib.__default.NumBuckets |pt#0@@33|) (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@33|) 1)))
 :qid |BoundedPivotsLibidfy.199:23|
 :skolemid |4877|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets |pt#0@@33|))
))))
(assert  (=> true (forall ((|pt#0@@34| T@U) ) (!  (=> (and (= (type |pt#0@@34|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.NumBuckets#canCall| (Lit |pt#0@@34|)) ($Is |pt#0@@34| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))) (= (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@34|)) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@34|)) 1)))
 :qid |BoundedPivotsLibidfy.199:23|
 :weight 3
 :skolemid |4878|
 :pattern ( (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@34|)))
))))
(assert  (=> true (forall ((|e#0@@24| T@U) ) (!  (=> (and (= (type |e#0@@24|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| |e#0@@24|) (and ($Is |e#0@@24| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@24|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@24|))))) (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.PivotSize |e#0@@24|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.PivotSize |e#0@@24|) 18446744073709551616)))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |4879|
 :pattern ( (BoundedPivotsLib.__default.PivotSize |e#0@@24|))
))))
(assert (forall ((|e#0@@25| T@U) ) (!  (=> (and (= (type |e#0@@25|) DatatypeTypeType) ($Is |e#0@@25| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (= (|BoundedPivotsLib.__default.PivotSize#requires| |e#0@@25|)  (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@25|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@25|))))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |4880|
 :pattern ( (|BoundedPivotsLib.__default.PivotSize#requires| |e#0@@25|))
)))
(assert  (=> true (forall ((|e#0@@26| T@U) ) (!  (=> (and (= (type |e#0@@26|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| |e#0@@26|) (and ($Is |e#0@@26| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@26|) (BoundedPivotsLib.__default.ElementIsKey |e#0@@26|))))) (= (BoundedPivotsLib.__default.PivotSize |e#0@@26|) (ite (Upperbounded__Lexicographic__Byte__Order.Element.Element_q |e#0@@26|) (|Seq#Length| (Upperbounded__Lexicographic__Byte__Order.Element.e |e#0@@26|)) 0)))
 :qid |BoundedPivotsLibidfy.204:29|
 :skolemid |4881|
 :pattern ( (BoundedPivotsLib.__default.PivotSize |e#0@@26|))
))))
(assert  (=> true (forall ((|e#0@@27| T@U) ) (!  (=> (and (= (type |e#0@@27|) DatatypeTypeType) (or (|BoundedPivotsLib.__default.PivotSize#canCall| (Lit |e#0@@27|)) (and ($Is |e#0@@27| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) (U_2_bool (Lit (bool_2_U  (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@27|)) (BoundedPivotsLib.__default.ElementIsKey (Lit |e#0@@27|))))))))) (= (BoundedPivotsLib.__default.PivotSize (Lit |e#0@@27|)) (ite (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit |e#0@@27|)) (|Seq#Length| (Lit (Upperbounded__Lexicographic__Byte__Order.Element.e (Lit |e#0@@27|)))) 0)))
 :qid |BoundedPivotsLibidfy.204:29|
 :weight 3
 :skolemid |4882|
 :pattern ( (BoundedPivotsLib.__default.PivotSize (Lit |e#0@@27|)))
))))
(assert  (=> true (forall ((|left#0@@15| T@U) (|right#0@@15| T@U) (|key#0@@205| T@U) ) (!  (=> (and (and (and (= (type |left#0@@15|) DatatypeTypeType) (= (type |right#0@@15|) DatatypeTypeType)) (= (type |key#0@@205|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| |left#0@@15| |right#0@@15| |key#0@@205|) (and (and (and ($Is |left#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@15| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@205| Tclass.KeyType.Key)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@15| |right#0@@15|)))) true)
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |4883|
 :pattern ( (BoundedPivotsLib.__default.InBetween |left#0@@15| |right#0@@15| |key#0@@205|))
))))
(assert (forall ((|left#0@@16| T@U) (|right#0@@16| T@U) (|key#0@@206| T@U) ) (!  (=> (and (and (and (= (type |left#0@@16|) DatatypeTypeType) (= (type |right#0@@16|) DatatypeTypeType)) (= (type |key#0@@206|) (SeqType BoxType))) (and (and ($Is |left#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@16| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@206| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.InBetween#requires| |left#0@@16| |right#0@@16| |key#0@@206|) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@16| |right#0@@16|)))
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |4884|
 :pattern ( (|BoundedPivotsLib.__default.InBetween#requires| |left#0@@16| |right#0@@16| |key#0@@206|))
)))
(assert  (=> true (forall ((|left#0@@17| T@U) (|right#0@@17| T@U) (|key#0@@207| T@U) ) (!  (=> (and (and (and (= (type |left#0@@17|) DatatypeTypeType) (= (type |right#0@@17|) DatatypeTypeType)) (= (type |key#0@@207|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| |left#0@@17| |right#0@@17| |key#0@@207|) (and (and (and ($Is |left#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@17| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@207| Tclass.KeyType.Key)) (Upperbounded__Lexicographic__Byte__Order.__default.lt |left#0@@17| |right#0@@17|)))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@207|) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@207|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@207|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@207|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@207|) |right#0@@17|)))) (= (BoundedPivotsLib.__default.InBetween |left#0@@17| |right#0@@17| |key#0@@207|)  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte |left#0@@17| (BoundedPivotsLib.__default.KeyToElement |key#0@@207|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@207|) |right#0@@17|)))))
 :qid |BoundedPivotsLibidfy.212:23|
 :skolemid |4885|
 :pattern ( (BoundedPivotsLib.__default.InBetween |left#0@@17| |right#0@@17| |key#0@@207|))
))))
(assert  (=> true (forall ((|left#0@@18| T@U) (|right#0@@18| T@U) (|key#0@@208| T@U) ) (!  (=> (and (and (and (= (type |left#0@@18|) DatatypeTypeType) (= (type |right#0@@18|) DatatypeTypeType)) (= (type |key#0@@208|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InBetween#canCall| (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@208|)) (and (and (and ($Is |left#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |right#0@@18| Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@208| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit |left#0@@18|) (Lit |right#0@@18|)))))))) (and (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@208|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@208|))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@208|))))))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@208|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@208|))) (Lit |right#0@@18|))))) (= (BoundedPivotsLib.__default.InBetween (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@208|)) (U_2_bool (Lit (bool_2_U  (and (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit |left#0@@18|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@208|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@208|))) (Lit |right#0@@18|)))))))))
 :qid |BoundedPivotsLibidfy.212:23|
 :weight 3
 :skolemid |4886|
 :pattern ( (BoundedPivotsLib.__default.InBetween (Lit |left#0@@18|) (Lit |right#0@@18|) (Lit |key#0@@208|)))
))))
(assert  (=> true (forall ((|pt#0@@35| T@U) (|key#0@@209| T@U) ) (!  (=> (and (and (= (type |pt#0@@35|) (SeqType BoxType)) (= (type |key#0@@209|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@35| |key#0@@209|) (and (and ($Is |pt#0@@35| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@209| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@35|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@35| |key#0@@209|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|) (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@35|) 1))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|))) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|) 1))))) (BoundedPivotsLib.__default.InBetween ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|))) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@35| (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|) 1))) |key#0@@209|)))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |4887|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@35| |key#0@@209|))
))))
(assert (forall ((|pt#0@@36| T@U) (|key#0@@210| T@U) ) (!  (=> (and (and (= (type |pt#0@@36|) (SeqType BoxType)) (= (type |key#0@@210|) (SeqType BoxType))) (and ($Is |pt#0@@36| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@210| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.Route#requires| |pt#0@@36| |key#0@@210|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@36|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@36| |key#0@@210|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |4888|
 :pattern ( (|BoundedPivotsLib.__default.Route#requires| |pt#0@@36| |key#0@@210|))
)))
(assert  (=> true (forall ((|pt#0@@37| T@U) (|key#0@@211| T@U) ) (!  (=> (and (and (= (type |pt#0@@37|) (SeqType BoxType)) (= (type |key#0@@211|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@37| |key#0@@211|) (and (and ($Is |pt#0@@37| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@211| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@37|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@37| |key#0@@211|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@211|) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| |pt#0@@37| (BoundedPivotsLib.__default.KeyToElement |key#0@@211|))) (= (BoundedPivotsLib.__default.Route |pt#0@@37| |key#0@@211|) (let ((|i#0@@177| (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte |pt#0@@37| (BoundedPivotsLib.__default.KeyToElement |key#0@@211|))))
|i#0@@177|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :skolemid |4889|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@37| |key#0@@211|))
))))
(assert  (=> true (forall ((|pt#0@@38| T@U) (|key#0@@212| T@U) ) (!  (=> (and (and (= (type |pt#0@@38|) (SeqType BoxType)) (= (type |key#0@@212|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@38|) (Lit |key#0@@212|)) (and (and ($Is |pt#0@@38| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@212| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@38|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@38|) (Lit |key#0@@212|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@212|)) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLte#canCall| (Lit |pt#0@@38|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@212|))))) (= (BoundedPivotsLib.__default.Route (Lit |pt#0@@38|) (Lit |key#0@@212|)) (let ((|i#1@@71| (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLte (Lit |pt#0@@38|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@212|)))))))
|i#1@@71|))))
 :qid |BoundedPivotsLibidfy.231:18|
 :weight 3
 :skolemid |4890|
 :pattern ( (BoundedPivotsLib.__default.Route (Lit |pt#0@@38|) (Lit |key#0@@212|)))
))))
(assert (= (type BoundedPivotsLib.__default.InitPivotTable) (SeqType BoxType)))
(assert  (=> true (=> true (and (BoundedPivotsLib.__default.WFPivots BoundedPivotsLib.__default.InitPivotTable) ($Is BoundedPivotsLib.__default.InitPivotTable (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))))
(assert (= |BoundedPivotsLib.__default.InitPivotTable#requires| true))
(assert  (=> true (=> true (= BoundedPivotsLib.__default.InitPivotTable (let ((|pt#0@@39| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))))) ($Box (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))))))
|pt#0@@39|)))))
(assert  (=> true (=> true (= BoundedPivotsLib.__default.InitPivotTable (let ((|pt#1| (Lit (|Seq#Build| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit (|Seq#Empty| BoxType)))))) ($Box (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|))))))
|pt#1|)))))
(assert (forall ((arg0@@647 T@U) (arg1@@341 Int) ) (! (= (type (BoundedPivotsLib.__default.GetKey arg0@@647 arg1@@341)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.GetKey|
 :pattern ( (BoundedPivotsLib.__default.GetKey arg0@@647 arg1@@341))
)))
(assert  (=> true (forall ((|pt#0@@40| T@U) (|idx#0| Int) ) (!  (=> (and (= (type |pt#0@@40|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| |pt#0@@40| |idx#0|) (and ($Is |pt#0@@40| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@40|) (and (INTERNAL_le_boogie 0 |idx#0|) (INTERNAL_lt_boogie |idx#0| (|Seq#Length| |pt#0@@40|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@40| |idx#0|))))))) (and (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|)) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@40| |idx#0|))) ($Is (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|) Tclass.KeyType.Key)))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |4891|
 :pattern ( (BoundedPivotsLib.__default.GetKey |pt#0@@40| |idx#0|))
))))
(assert (forall ((|pt#0@@41| T@U) (|idx#0@@0| Int) ) (!  (=> (and (= (type |pt#0@@41|) (SeqType BoxType)) ($Is |pt#0@@41| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.GetKey#requires| |pt#0@@41| |idx#0@@0|)  (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@41|) (and (INTERNAL_le_boogie 0 |idx#0@@0|) (INTERNAL_lt_boogie |idx#0@@0| (|Seq#Length| |pt#0@@41|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@41| |idx#0@@0|))))))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |4892|
 :pattern ( (|BoundedPivotsLib.__default.GetKey#requires| |pt#0@@41| |idx#0@@0|))
)))
(assert  (=> true (forall ((|pt#0@@42| T@U) (|idx#0@@1| Int) ) (!  (=> (and (= (type |pt#0@@42|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| |pt#0@@42| |idx#0@@1|) (and ($Is |pt#0@@42| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (BoundedPivotsLib.__default.WFPivots |pt#0@@42|) (and (INTERNAL_le_boogie 0 |idx#0@@1|) (INTERNAL_lt_boogie |idx#0@@1| (|Seq#Length| |pt#0@@42|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@42| |idx#0@@1|))))))) (= (BoundedPivotsLib.__default.GetKey |pt#0@@42| |idx#0@@1|) (let ((|k#0@@80| (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@42| |idx#0@@1|)))))
|k#0@@80|)))
 :qid |BoundedPivotsLibidfy.274:19|
 :skolemid |4893|
 :pattern ( (BoundedPivotsLib.__default.GetKey |pt#0@@42| |idx#0@@1|))
))))
(assert  (=> true (forall ((|pt#0@@43| T@U) (|idx#0@@2| Int) ) (!  (=> (and (= (type |pt#0@@43|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.GetKey#canCall| (Lit |pt#0@@43|) (LitInt |idx#0@@2|)) (and ($Is |pt#0@@43| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@43|))))) (and (INTERNAL_le_boogie 0 |idx#0@@2|) (INTERNAL_lt_boogie |idx#0@@2| (|Seq#Length| (Lit |pt#0@@43|))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@43|) (LitInt |idx#0@@2|)))))))) (= (BoundedPivotsLib.__default.GetKey (Lit |pt#0@@43|) (LitInt |idx#0@@2|)) (let ((|k#1@@18| (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@43|) (LitInt |idx#0@@2|))))))
|k#1@@18|)))
 :qid |BoundedPivotsLibidfy.274:19|
 :weight 3
 :skolemid |4894|
 :pattern ( (BoundedPivotsLib.__default.GetKey (Lit |pt#0@@43|) (LitInt |idx#0@@2|)))
))))
(assert  (=> true (forall ((|pt#0@@44| T@U) (|idx#0@@3| Int) (|key#0@@213| T@U) ) (!  (=> (and (and (= (type |pt#0@@44|) (SeqType BoxType)) (= (type |key#0@@213|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| |pt#0@@44| |idx#0@@3| |key#0@@213|) (and (and ($Is |pt#0@@44| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@213| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@44|)))) true)
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |4895|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable |pt#0@@44| |idx#0@@3| |key#0@@213|))
))))
(assert (forall ((|pt#0@@45| T@U) (|idx#0@@4| Int) (|key#0@@214| T@U) ) (!  (=> (and (and (= (type |pt#0@@45|) (SeqType BoxType)) (= (type |key#0@@214|) (SeqType BoxType))) (and ($Is |pt#0@@45| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@214| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.PivotInsertable#requires| |pt#0@@45| |idx#0@@4| |key#0@@214|) (BoundedPivotsLib.__default.WFPivots |pt#0@@45|)))
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |4896|
 :pattern ( (|BoundedPivotsLib.__default.PivotInsertable#requires| |pt#0@@45| |idx#0@@4| |key#0@@214|))
)))
(assert  (=> true (forall ((|pt#0@@46| T@U) (|idx#0@@5| Int) (|key#0@@215| T@U) ) (!  (=> (and (and (= (type |pt#0@@46|) (SeqType BoxType)) (= (type |key#0@@215|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| |pt#0@@46| |idx#0@@5| |key#0@@215|) (and (and ($Is |pt#0@@46| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@215| Tclass.KeyType.Key)) (BoundedPivotsLib.__default.WFPivots |pt#0@@46|)))) (and (=> (INTERNAL_le_boogie 0 |idx#0@@5|) (=> (INTERNAL_le_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (=> (= |idx#0@@5| (LitInt 0)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@215|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0)))))) (=> (=> (= |idx#0@@5| (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0))))) (and (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@215|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|)))) (=> (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|))) (and (=> (INTERNAL_gt_boogie |idx#0@@5| 0) (=> (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@215|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@215|) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|)))))))) (=> (=> (and (INTERNAL_gt_boogie |idx#0@@5| 0) (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|))))) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@46| |key#0@@215|) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@46| |key#0@@215|) (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@46| |key#0@@215|))))))))))) (= (BoundedPivotsLib.__default.PivotInsertable |pt#0@@46| |idx#0@@5| |key#0@@215|)  (and (and (and (and (and (INTERNAL_le_boogie 0 |idx#0@@5|) (INTERNAL_le_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (=> (= |idx#0@@5| (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (LitInt 0)))))) (=> (= |idx#0@@5| (|Seq#Length| |pt#0@@46|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie (|Seq#Length| |pt#0@@46|) 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|)))) (=> (and (INTERNAL_gt_boogie |idx#0@@5| 0) (INTERNAL_lt_boogie |idx#0@@5| (|Seq#Length| |pt#0@@46|))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| (INTERNAL_sub_boogie |idx#0@@5| 1))) (BoundedPivotsLib.__default.KeyToElement |key#0@@215|)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |key#0@@215|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@46| |idx#0@@5|)))))) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@46| |key#0@@215|) (= (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route |pt#0@@46| |key#0@@215|) 1) |idx#0@@5|))))))
 :qid |BoundedPivotsLibidfy.330:29|
 :skolemid |4897|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable |pt#0@@46| |idx#0@@5| |key#0@@215|))
))))
(assert  (=> true (forall ((|pt#0@@47| T@U) (|idx#0@@6| Int) (|key#0@@216| T@U) ) (!  (=> (and (and (= (type |pt#0@@47|) (SeqType BoxType)) (= (type |key#0@@216|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.PivotInsertable#canCall| (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@216|)) (and (and ($Is |pt#0@@47| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@216| Tclass.KeyType.Key)) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@47|)))))))) (and (=> (INTERNAL_le_boogie 0 |idx#0@@6|) (=> (INTERNAL_le_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|))) (and (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@216|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0)))))) (=> (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0))))) (and (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@216|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|)))))) (=> (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))))) (and (=> (U_2_bool (Lit (bool_2_U (INTERNAL_gt_boogie |idx#0@@6| 0)))) (=> (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@216|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))))) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|)))) (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@216|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|))))))))) (=> (=> (and (INTERNAL_gt_boogie |idx#0@@6| 0) (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|)))))) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@47|) (Lit |key#0@@216|)) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@47|) (Lit |key#0@@216|))))) (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@47|) (Lit |key#0@@216|)))))))))))) (= (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@216|))  (and (and (and (and (and (INTERNAL_le_boogie 0 |idx#0@@6|) (INTERNAL_le_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (=> (= (LitInt |idx#0@@6|) (LitInt 0)) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt 0)))))) (=> (= (LitInt |idx#0@@6|) (|Seq#Length| (Lit |pt#0@@47|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (INTERNAL_sub_boogie (|Seq#Length| (Lit |pt#0@@47|)) 1))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|)))))) (=> (and (INTERNAL_gt_boogie |idx#0@@6| 0) (INTERNAL_lt_boogie |idx#0@@6| (|Seq#Length| (Lit |pt#0@@47|)))) (and (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt (INTERNAL_sub_boogie |idx#0@@6| 1)))) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|)))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@216|))) ($Unbox DatatypeTypeType (|Seq#Index| (Lit |pt#0@@47|) (LitInt |idx#0@@6|))))))) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@47|) (Lit |key#0@@216|)) (= (LitInt (INTERNAL_add_boogie (BoundedPivotsLib.__default.Route (Lit |pt#0@@47|) (Lit |key#0@@216|)) 1)) (LitInt |idx#0@@6|)))))))
 :qid |BoundedPivotsLibidfy.330:29|
 :weight 3
 :skolemid |4898|
 :pattern ( (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@47|) (LitInt |idx#0@@6|) (Lit |key#0@@216|)))
))))
(assert  (=> true (forall ((|pt#0@@48| T@U) (|idx#0@@7| Int) (|key#0@@217| T@U) ) (!  (=> (and (and (= (type |pt#0@@48|) (SeqType BoxType)) (= (type |key#0@@217|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| |pt#0@@48| |idx#0@@7| |key#0@@217|) (and (and ($Is |pt#0@@48| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@217| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@48|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@48| |idx#0@@7| |key#0@@217|))))) ($Is (BoundedPivotsLib.__default.InsertPivot |pt#0@@48| |idx#0@@7| |key#0@@217|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |4899|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot |pt#0@@48| |idx#0@@7| |key#0@@217|))
))))
(assert (forall ((|pt#0@@49| T@U) (|idx#0@@8| Int) (|key#0@@218| T@U) ) (!  (=> (and (and (= (type |pt#0@@49|) (SeqType BoxType)) (= (type |key#0@@218|) (SeqType BoxType))) (and ($Is |pt#0@@49| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@218| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.InsertPivot#requires| |pt#0@@49| |idx#0@@8| |key#0@@218|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@49|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@49| |idx#0@@8| |key#0@@218|))))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |4900|
 :pattern ( (|BoundedPivotsLib.__default.InsertPivot#requires| |pt#0@@49| |idx#0@@8| |key#0@@218|))
)))
(assert (= (type StartFuel_Sequences._default.insert) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@50| T@U) (|idx#0@@9| Int) (|key#0@@219| T@U) ) (!  (=> (and (and (= (type |pt#0@@50|) (SeqType BoxType)) (= (type |key#0@@219|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| |pt#0@@50| |idx#0@@9| |key#0@@219|) (and (and ($Is |pt#0@@50| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@219| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@50|) (BoundedPivotsLib.__default.PivotInsertable |pt#0@@50| |idx#0@@9| |key#0@@219|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |key#0@@219|) (|Sequences.__default.insert#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element |pt#0@@50| ($Box (BoundedPivotsLib.__default.KeyToElement |key#0@@219|)) |idx#0@@9|)) (= (BoundedPivotsLib.__default.InsertPivot |pt#0@@50| |idx#0@@9| |key#0@@219|) (Sequences.__default.insert Tclass.Upperbounded__Lexicographic__Byte__Order.Element StartFuel_Sequences._default.insert |pt#0@@50| ($Box (BoundedPivotsLib.__default.KeyToElement |key#0@@219|)) |idx#0@@9|))))
 :qid |BoundedPivotsLibidfy.380:24|
 :skolemid |4901|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot |pt#0@@50| |idx#0@@9| |key#0@@219|))
))))
(assert  (=> true (forall ((|pt#0@@51| T@U) (|idx#0@@10| Int) (|key#0@@220| T@U) ) (!  (=> (and (and (= (type |pt#0@@51|) (SeqType BoxType)) (= (type |key#0@@220|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.InsertPivot#canCall| (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@220|)) (and (and ($Is |pt#0@@51| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |key#0@@220| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@51|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.PivotInsertable (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@220|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |key#0@@220|)) (|Sequences.__default.insert#canCall| Tclass.Upperbounded__Lexicographic__Byte__Order.Element (Lit |pt#0@@51|) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@220|)))) (LitInt |idx#0@@10|))) (= (BoundedPivotsLib.__default.InsertPivot (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@220|)) (Sequences.__default.insert Tclass.Upperbounded__Lexicographic__Byte__Order.Element StartFuel_Sequences._default.insert (Lit |pt#0@@51|) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |key#0@@220|)))) (LitInt |idx#0@@10|)))))
 :qid |BoundedPivotsLibidfy.380:24|
 :weight 3
 :skolemid |4902|
 :pattern ( (BoundedPivotsLib.__default.InsertPivot (Lit |pt#0@@51|) (LitInt |idx#0@@10|) (Lit |key#0@@220|)))
))))
(assert (forall (($ly@@709 T@U) (|pt#0@@52| T@U) (|pivot#0@@11| T@U) ) (!  (=> (and (and (= (type $ly@@709) LayerTypeType) (= (type |pt#0@@52|) (SeqType BoxType))) (= (type |pivot#0@@11|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@709) |pt#0@@52| |pivot#0@@11|) (BoundedPivotsLib.__default.CutoffForLeft $ly@@709 |pt#0@@52| |pivot#0@@11|)))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |4927|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@709) |pt#0@@52| |pivot#0@@11|))
)))
(assert (forall (($ly@@710 T@U) (|pt#0@@53| T@U) (|pivot#0@@12| T@U) ) (!  (=> (and (and (= (type $ly@@710) LayerTypeType) (= (type |pt#0@@53|) (SeqType BoxType))) (= (type |pivot#0@@12|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForLeft $ly@@710 |pt#0@@53| |pivot#0@@12|) (BoundedPivotsLib.__default.CutoffForLeft $LZ |pt#0@@53| |pivot#0@@12|)))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |4928|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft (AsFuelBottom $ly@@710) |pt#0@@53| |pivot#0@@12|))
)))
(assert  (=> true (forall (($ly@@711 T@U) (|pt#0@@54| T@U) (|pivot#0@@13| T@U) ) (!  (=> (and (and (and (= (type $ly@@711) LayerTypeType) (= (type |pt#0@@54|) (SeqType BoxType))) (= (type |pivot#0@@13|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@54| |pivot#0@@13|) (and (and ($Is |pt#0@@54| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@13| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@54|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@54| |pivot#0@@13|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.CutoffForLeft $ly@@711 |pt#0@@54| |pivot#0@@13|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForLeft $ly@@711 |pt#0@@54| |pivot#0@@13|) (BoundedPivotsLib.__default.NumBuckets |pt#0@@54|))) (forall ((|i#0@@178| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@178|) (INTERNAL_le_boogie |i#0@@178| (BoundedPivotsLib.__default.CutoffForLeft $ly@@711 |pt#0@@54| |pivot#0@@13|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#0@@178|)) (BoundedPivotsLib.__default.KeyToElement |pivot#0@@13|)))
 :qid |BoundedPivotsLibidfy.439:18|
 :skolemid |4929|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#0@@178|)))
))) (forall ((|i#1@@72| Int) ) (!  (=> (and (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForLeft $ly@@711 |pt#0@@54| |pivot#0@@13|) |i#1@@72|) (INTERNAL_lt_boogie |i#1@@72| (|Seq#Length| |pt#0@@54|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement |pivot#0@@13|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#1@@72|))))
 :qid |BoundedPivotsLibidfy.440:18|
 :skolemid |4930|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@54| |i#1@@72|)))
))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |4931|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft $ly@@711 |pt#0@@54| |pivot#0@@13|))
))))
(assert (forall (($ly@@712 T@U) (|pt#0@@55| T@U) (|pivot#0@@14| T@U) ) (!  (=> (and (and (and (= (type $ly@@712) LayerTypeType) (= (type |pt#0@@55|) (SeqType BoxType))) (= (type |pivot#0@@14|) (SeqType BoxType))) (and ($Is |pt#0@@55| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@14| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.CutoffForLeft#requires| $ly@@712 |pt#0@@55| |pivot#0@@14|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@55|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@55| |pivot#0@@14|))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |4932|
 :pattern ( (|BoundedPivotsLib.__default.CutoffForLeft#requires| $ly@@712 |pt#0@@55| |pivot#0@@14|))
)))
(assert  (=> true (forall (($ly@@713 T@U) (|pt#0@@56| T@U) (|pivot#0@@15| T@U) ) (!  (=> (and (and (and (= (type $ly@@713) LayerTypeType) (= (type |pt#0@@56|) (SeqType BoxType))) (= (type |pivot#0@@15|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@56| |pivot#0@@15|) (and (and ($Is |pt#0@@56| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@15| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@56|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@56| |pivot#0@@15|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@15|) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| |pt#0@@56| (BoundedPivotsLib.__default.KeyToElement |pivot#0@@15|))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@713) |pt#0@@56| |pivot#0@@15|) (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $LZ) |pt#0@@56| (BoundedPivotsLib.__default.KeyToElement |pivot#0@@15|)))))
 :qid |BoundedPivotsLibidfy.435:22|
 :skolemid |4933|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@713) |pt#0@@56| |pivot#0@@15|))
))))
(assert  (=> true (forall (($ly@@714 T@U) (|pt#0@@57| T@U) (|pivot#0@@16| T@U) ) (!  (=> (and (and (and (= (type $ly@@714) LayerTypeType) (= (type |pt#0@@57|) (SeqType BoxType))) (= (type |pivot#0@@16|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForLeft#canCall| (Lit |pt#0@@57|) (Lit |pivot#0@@16|)) (and (and ($Is |pt#0@@57| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@16| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@57|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@57|) (Lit |pivot#0@@16|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@16|)) (|Upperbounded__Lexicographic__Byte__Order.__default.LargestLt#canCall| (Lit |pt#0@@57|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@16|))))) (= (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@714) (Lit |pt#0@@57|) (Lit |pivot#0@@16|)) (LitInt (Upperbounded__Lexicographic__Byte__Order.__default.LargestLt ($LS $LZ) (Lit |pt#0@@57|) (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@16|))))))))
 :qid |BoundedPivotsLibidfy.435:22|
 :weight 3
 :skolemid |4934|
 :pattern ( (BoundedPivotsLib.__default.CutoffForLeft ($LS $ly@@714) (Lit |pt#0@@57|) (Lit |pivot#0@@16|)))
))))
(assert (forall ((arg0@@648 T@U) (arg1@@342 T@U) ) (! (= (type (BoundedPivotsLib.__default.SplitLeft arg0@@648 arg1@@342)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.SplitLeft|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft arg0@@648 arg1@@342))
)))
(assert  (=> true (forall ((|pt#0@@58| T@U) (|pivot#0@@17| T@U) ) (!  (=> (and (and (= (type |pt#0@@58|) (SeqType BoxType)) (= (type |pivot#0@@17|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| |pt#0@@58| |pivot#0@@17|) (and (and ($Is |pt#0@@58| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@17| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@58|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@58| |pivot#0@@17|))))) (and (BoundedPivotsLib.__default.WFPivots (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|)) ($Is (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |4935|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft |pt#0@@58| |pivot#0@@17|))
))))
(assert (forall ((|pt#0@@59| T@U) (|pivot#0@@18| T@U) ) (!  (=> (and (and (= (type |pt#0@@59|) (SeqType BoxType)) (= (type |pivot#0@@18|) (SeqType BoxType))) (and ($Is |pt#0@@59| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@18| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.SplitLeft#requires| |pt#0@@59| |pivot#0@@18|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@59|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@59| |pivot#0@@18|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |4936|
 :pattern ( (|BoundedPivotsLib.__default.SplitLeft#requires| |pt#0@@59| |pivot#0@@18|))
)))
(assert (= (type StartFuel_BoundedPivotsLib._default.CutoffForLeft) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@60| T@U) (|pivot#0@@19| T@U) ) (!  (=> (and (and (= (type |pt#0@@60|) (SeqType BoxType)) (= (type |pivot#0@@19|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| |pt#0@@60| |pivot#0@@19|) (and (and ($Is |pt#0@@60| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@19| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@60|) (BoundedPivotsLib.__default.ValidLeftCutOffKey |pt#0@@60| |pivot#0@@19|))))) (and (and (|BoundedPivotsLib.__default.CutoffForLeft#canCall| |pt#0@@60| |pivot#0@@19|) (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@19|)) (= (BoundedPivotsLib.__default.SplitLeft |pt#0@@60| |pivot#0@@19|) (let ((|ret#0| (|Seq#Append| (|Seq#Take| |pt#0@@60| (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForLeft StartFuel_BoundedPivotsLib._default.CutoffForLeft |pt#0@@60| |pivot#0@@19|) 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (BoundedPivotsLib.__default.KeyToElement |pivot#0@@19|))))))
|ret#0|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :skolemid |4937|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft |pt#0@@60| |pivot#0@@19|))
))))
(assert  (=> true (forall ((|pt#0@@61| T@U) (|pivot#0@@20| T@U) ) (!  (=> (and (and (= (type |pt#0@@61|) (SeqType BoxType)) (= (type |pivot#0@@20|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitLeft#canCall| (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (and (and ($Is |pt#0@@61| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@20| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@61|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ValidLeftCutOffKey (Lit |pt#0@@61|) (Lit |pivot#0@@20|))))))))) (and (and (|BoundedPivotsLib.__default.CutoffForLeft#canCall| (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@20|))) (= (BoundedPivotsLib.__default.SplitLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) (let ((|ret#1| (|Seq#Append| (|Seq#Take| (Lit |pt#0@@61|) (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForLeft StartFuel_BoundedPivotsLib._default.CutoffForLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)) 1)) (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@20|))))))))
|ret#1|))))
 :qid |BoundedPivotsLibidfy.456:22|
 :weight 3
 :skolemid |4938|
 :pattern ( (BoundedPivotsLib.__default.SplitLeft (Lit |pt#0@@61|) (Lit |pivot#0@@20|)))
))))
(assert (forall (($ly@@715 T@U) (|pt#0@@62| T@U) (|pivot#0@@21| T@U) ) (!  (=> (and (and (= (type $ly@@715) LayerTypeType) (= (type |pt#0@@62|) (SeqType BoxType))) (= (type |pivot#0@@21|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@715) |pt#0@@62| |pivot#0@@21|) (BoundedPivotsLib.__default.CutoffForRight $ly@@715 |pt#0@@62| |pivot#0@@21|)))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |4939|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@715) |pt#0@@62| |pivot#0@@21|))
)))
(assert (forall (($ly@@716 T@U) (|pt#0@@63| T@U) (|pivot#0@@22| T@U) ) (!  (=> (and (and (= (type $ly@@716) LayerTypeType) (= (type |pt#0@@63|) (SeqType BoxType))) (= (type |pivot#0@@22|) (SeqType BoxType))) (= (BoundedPivotsLib.__default.CutoffForRight $ly@@716 |pt#0@@63| |pivot#0@@22|) (BoundedPivotsLib.__default.CutoffForRight $LZ |pt#0@@63| |pivot#0@@22|)))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |4940|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight (AsFuelBottom $ly@@716) |pt#0@@63| |pivot#0@@22|))
)))
(assert  (=> true (forall (($ly@@717 T@U) (|pt#0@@64| T@U) (|pivot#0@@23| T@U) ) (!  (=> (and (and (and (= (type $ly@@717) LayerTypeType) (= (type |pt#0@@64|) (SeqType BoxType))) (= (type |pivot#0@@23|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@64| |pivot#0@@23|) (and (and ($Is |pt#0@@64| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@23| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@64|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@64| |pivot#0@@23|))))) (and (and (and (INTERNAL_le_boogie 0 (BoundedPivotsLib.__default.CutoffForRight $ly@@717 |pt#0@@64| |pivot#0@@23|)) (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForRight $ly@@717 |pt#0@@64| |pivot#0@@23|) (BoundedPivotsLib.__default.NumBuckets |pt#0@@64|))) (forall ((|i#0@@179| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@179|) (INTERNAL_le_boogie |i#0@@179| (BoundedPivotsLib.__default.CutoffForRight $ly@@717 |pt#0@@64| |pivot#0@@23|))) (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#0@@179|)) (BoundedPivotsLib.__default.KeyToElement |pivot#0@@23|)))
 :qid |BoundedPivotsLibidfy.481:18|
 :skolemid |4941|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#0@@179|)))
))) (forall ((|i#1@@73| Int) ) (!  (=> (and (INTERNAL_lt_boogie (BoundedPivotsLib.__default.CutoffForRight $ly@@717 |pt#0@@64| |pivot#0@@23|) |i#1@@73|) (INTERNAL_lt_boogie |i#1@@73| (|Seq#Length| |pt#0@@64|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |pivot#0@@23|) ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#1@@73|))))
 :qid |BoundedPivotsLibidfy.482:18|
 :skolemid |4942|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |pt#0@@64| |i#1@@73|)))
))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |4943|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight $ly@@717 |pt#0@@64| |pivot#0@@23|))
))))
(assert (forall (($ly@@718 T@U) (|pt#0@@65| T@U) (|pivot#0@@24| T@U) ) (!  (=> (and (and (and (= (type $ly@@718) LayerTypeType) (= (type |pt#0@@65|) (SeqType BoxType))) (= (type |pivot#0@@24|) (SeqType BoxType))) (and ($Is |pt#0@@65| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@24| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.CutoffForRight#requires| $ly@@718 |pt#0@@65| |pivot#0@@24|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@65|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@65| |pivot#0@@24|))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |4944|
 :pattern ( (|BoundedPivotsLib.__default.CutoffForRight#requires| $ly@@718 |pt#0@@65| |pivot#0@@24|))
)))
(assert  (=> true (forall (($ly@@719 T@U) (|pt#0@@66| T@U) (|pivot#0@@25| T@U) ) (!  (=> (and (and (and (= (type $ly@@719) LayerTypeType) (= (type |pt#0@@66|) (SeqType BoxType))) (= (type |pivot#0@@25|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@66| |pivot#0@@25|) (and (and ($Is |pt#0@@66| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@25| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@66|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@66| |pivot#0@@25|))))) (and (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@66| |pivot#0@@25|) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@719) |pt#0@@66| |pivot#0@@25|) (BoundedPivotsLib.__default.Route |pt#0@@66| |pivot#0@@25|))))
 :qid |BoundedPivotsLibidfy.477:22|
 :skolemid |4945|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@719) |pt#0@@66| |pivot#0@@25|))
))))
(assert  (=> true (forall (($ly@@720 T@U) (|pt#0@@67| T@U) (|pivot#0@@26| T@U) ) (!  (=> (and (and (and (= (type $ly@@720) LayerTypeType) (= (type |pt#0@@67|) (SeqType BoxType))) (= (type |pivot#0@@26|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.CutoffForRight#canCall| (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (and (and ($Is |pt#0@@67| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@26| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@67|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@67|) (Lit |pivot#0@@26|))))))))) (and (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (= (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@720) (Lit |pt#0@@67|) (Lit |pivot#0@@26|)) (LitInt (BoundedPivotsLib.__default.Route (Lit |pt#0@@67|) (Lit |pivot#0@@26|))))))
 :qid |BoundedPivotsLibidfy.477:22|
 :weight 3
 :skolemid |4946|
 :pattern ( (BoundedPivotsLib.__default.CutoffForRight ($LS $ly@@720) (Lit |pt#0@@67|) (Lit |pivot#0@@26|)))
))))
(assert (forall ((arg0@@649 T@U) (arg1@@343 T@U) ) (! (= (type (BoundedPivotsLib.__default.SplitRight arg0@@649 arg1@@343)) (SeqType BoxType))
 :qid |funType:BoundedPivotsLib.__default.SplitRight|
 :pattern ( (BoundedPivotsLib.__default.SplitRight arg0@@649 arg1@@343))
)))
(assert  (=> true (forall ((|pt#0@@68| T@U) (|pivot#0@@27| T@U) ) (!  (=> (and (and (= (type |pt#0@@68|) (SeqType BoxType)) (= (type |pivot#0@@27|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| |pt#0@@68| |pivot#0@@27|) (and (and ($Is |pt#0@@68| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@27| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@68|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@68| |pivot#0@@27|))))) (and (BoundedPivotsLib.__default.WFPivots (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|)) ($Is (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|) (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |4947|
 :pattern ( (BoundedPivotsLib.__default.SplitRight |pt#0@@68| |pivot#0@@27|))
))))
(assert (forall ((|pt#0@@69| T@U) (|pivot#0@@28| T@U) ) (!  (=> (and (and (= (type |pt#0@@69|) (SeqType BoxType)) (= (type |pivot#0@@28|) (SeqType BoxType))) (and ($Is |pt#0@@69| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@28| Tclass.KeyType.Key))) (= (|BoundedPivotsLib.__default.SplitRight#requires| |pt#0@@69| |pivot#0@@28|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@69|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@69| |pivot#0@@28|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |4948|
 :pattern ( (|BoundedPivotsLib.__default.SplitRight#requires| |pt#0@@69| |pivot#0@@28|))
)))
(assert (= (type StartFuel_BoundedPivotsLib._default.CutoffForRight) LayerTypeType))
(assert  (=> true (forall ((|pt#0@@70| T@U) (|pivot#0@@29| T@U) ) (!  (=> (and (and (= (type |pt#0@@70|) (SeqType BoxType)) (= (type |pivot#0@@29|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| |pt#0@@70| |pivot#0@@29|) (and (and ($Is |pt#0@@70| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@29| Tclass.KeyType.Key)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@70|) (BoundedPivotsLib.__default.BoundedKey |pt#0@@70| |pivot#0@@29|))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| |pivot#0@@29|) (|BoundedPivotsLib.__default.CutoffForRight#canCall| |pt#0@@70| |pivot#0@@29|)) (= (BoundedPivotsLib.__default.SplitRight |pt#0@@70| |pivot#0@@29|) (let ((|ret#0@@0| (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (BoundedPivotsLib.__default.KeyToElement |pivot#0@@29|))) (|Seq#Drop| |pt#0@@70| (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForRight StartFuel_BoundedPivotsLib._default.CutoffForRight |pt#0@@70| |pivot#0@@29|) 1)))))
|ret#0@@0|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :skolemid |4949|
 :pattern ( (BoundedPivotsLib.__default.SplitRight |pt#0@@70| |pivot#0@@29|))
))))
(assert  (=> true (forall ((|pt#0@@71| T@U) (|pivot#0@@30| T@U) ) (!  (=> (and (and (= (type |pt#0@@71|) (SeqType BoxType)) (= (type |pivot#0@@30|) (SeqType BoxType))) (or (|BoundedPivotsLib.__default.SplitRight#canCall| (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) (and (and ($Is |pt#0@@71| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) ($Is |pivot#0@@30| Tclass.KeyType.Key)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@71|))))) (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@71|) (Lit |pivot#0@@30|))))))))) (and (and (|BoundedPivotsLib.__default.KeyToElement#canCall| (Lit |pivot#0@@30|)) (|BoundedPivotsLib.__default.CutoffForRight#canCall| (Lit |pt#0@@71|) (Lit |pivot#0@@30|))) (= (BoundedPivotsLib.__default.SplitRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) (let ((|ret#1@@0| (|Seq#Append| (|Seq#Build| (|Seq#Empty| BoxType) ($Box (Lit (BoundedPivotsLib.__default.KeyToElement (Lit |pivot#0@@30|))))) (|Seq#Drop| (Lit |pt#0@@71|) (INTERNAL_add_boogie (BoundedPivotsLib.__default.CutoffForRight StartFuel_BoundedPivotsLib._default.CutoffForRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)) 1)))))
|ret#1@@0|))))
 :qid |BoundedPivotsLibidfy.498:23|
 :weight 3
 :skolemid |4950|
 :pattern ( (BoundedPivotsLib.__default.SplitRight (Lit |pt#0@@71|) (Lit |pivot#0@@30|)))
))))
(assert (forall ((arg0@@650 T@U) (arg1@@344 Int) ) (! (= (type (BoundedPivotsLib.__default.PivotTableBucketKeySet arg0@@650 arg1@@344)) (MapType0Type BoxType boolType))
 :qid |funType:BoundedPivotsLib.__default.PivotTableBucketKeySet|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet arg0@@650 arg1@@344))
)))
(assert  (=> true (forall ((|pt#0@@72| T@U) (|i#0@@180| Int) ) (!  (=> (and (= (type |pt#0@@72|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| |pt#0@@72| |i#0@@180|) (and ($Is |pt#0@@72| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@72|) (and (INTERNAL_le_boogie 0 |i#0@@180|) (INTERNAL_lt_boogie |i#0@@180| (BoundedPivotsLib.__default.NumBuckets |pt#0@@72|))))))) ($Is (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@72| |i#0@@180|) (TISet Tclass.KeyType.Key)))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |4951|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@72| |i#0@@180|))
))))
(assert (forall ((|pt#0@@73| T@U) (|i#0@@181| Int) ) (!  (=> (and (= (type |pt#0@@73|) (SeqType BoxType)) ($Is |pt#0@@73| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element))) (= (|BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| |pt#0@@73| |i#0@@181|)  (and (BoundedPivotsLib.__default.WFPivots |pt#0@@73|) (and (INTERNAL_le_boogie 0 |i#0@@181|) (INTERNAL_lt_boogie |i#0@@181| (BoundedPivotsLib.__default.NumBuckets |pt#0@@73|))))))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |4952|
 :pattern ( (|BoundedPivotsLib.__default.PivotTableBucketKeySet#requires| |pt#0@@73| |i#0@@181|))
)))
(assert (forall ((arg0@@651 T@U) (arg1@@345 T@U) (arg2@@171 T@U) (arg3@@99 Int) ) (! (= (type (|lambda#351| arg0@@651 arg1@@345 arg2@@171 arg3@@99)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#351|
 :pattern ( (|lambda#351| arg0@@651 arg1@@345 arg2@@171 arg3@@99))
)))
(assert  (=> true (forall ((|pt#0@@74| T@U) (|i#0@@182| Int) ) (!  (=> (and (= (type |pt#0@@74|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| |pt#0@@74| |i#0@@182|) (and ($Is |pt#0@@74| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (BoundedPivotsLib.__default.WFPivots |pt#0@@74|) (and (INTERNAL_le_boogie 0 |i#0@@182|) (INTERNAL_lt_boogie |i#0@@182| (BoundedPivotsLib.__default.NumBuckets |pt#0@@74|))))))) (and (forall ((|key#0@@221| T@U) ) (!  (=> (and (= (type |key#0@@221|) (SeqType BoxType)) ($Is |key#0@@221| Tclass.KeyType.Key)) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| |pt#0@@74| |key#0@@221|) (=> (BoundedPivotsLib.__default.BoundedKey |pt#0@@74| |key#0@@221|) (|BoundedPivotsLib.__default.Route#canCall| |pt#0@@74| |key#0@@221|))))
 :qid |BoundedPivotsLibidfy.523:10|
 :skolemid |4953|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@74| |key#0@@221|))
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@74| |key#0@@221|))
)) (= (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@74| |i#0@@182|) (|lambda#351| Tclass.KeyType.Key |pt#0@@74| |pt#0@@74| |i#0@@182|))))
 :qid |BoundedPivotsLibidfy.519:35|
 :skolemid |4954|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet |pt#0@@74| |i#0@@182|))
))))
(assert  (=> true (forall ((|pt#0@@75| T@U) (|i#0@@183| Int) ) (!  (=> (and (= (type |pt#0@@75|) (SeqType BoxType)) (or (|BoundedPivotsLib.__default.PivotTableBucketKeySet#canCall| (Lit |pt#0@@75|) (LitInt |i#0@@183|)) (and ($Is |pt#0@@75| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element)) (and (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.WFPivots (Lit |pt#0@@75|))))) (and (INTERNAL_le_boogie 0 |i#0@@183|) (INTERNAL_lt_boogie |i#0@@183| (BoundedPivotsLib.__default.NumBuckets (Lit |pt#0@@75|)))))))) (and (forall ((|key#1@@14| T@U) ) (!  (=> (and (= (type |key#1@@14|) (SeqType BoxType)) ($Is |key#1@@14| Tclass.KeyType.Key)) (and (|BoundedPivotsLib.__default.BoundedKey#canCall| (Lit |pt#0@@75|) |key#1@@14|) (=> (BoundedPivotsLib.__default.BoundedKey (Lit |pt#0@@75|) |key#1@@14|) (|BoundedPivotsLib.__default.Route#canCall| (Lit |pt#0@@75|) |key#1@@14|))))
 :qid |BoundedPivotsLibidfy.523:10|
 :skolemid |4955|
 :pattern ( (BoundedPivotsLib.__default.Route |pt#0@@75| |key#1@@14|))
 :pattern ( (BoundedPivotsLib.__default.BoundedKey |pt#0@@75| |key#1@@14|))
)) (= (BoundedPivotsLib.__default.PivotTableBucketKeySet (Lit |pt#0@@75|) (LitInt |i#0@@183|)) (|lambda#351| Tclass.KeyType.Key (Lit |pt#0@@75|) (Lit |pt#0@@75|) (LitInt |i#0@@183|)))))
 :qid |BoundedPivotsLibidfy.519:35|
 :weight 3
 :skolemid |4956|
 :pattern ( (BoundedPivotsLib.__default.PivotTableBucketKeySet (Lit |pt#0@@75|) (LitInt |i#0@@183|)))
))))
(assert (= (type |#DomainMod.Domain.EmptyDomain|) DatatypeTypeType))
(assert (= (DatatypeCtorId |#DomainMod.Domain.EmptyDomain|) |##DomainMod.Domain.EmptyDomain|))
(assert (forall ((d@@162 T@U) ) (!  (=> (= (type d@@162) DatatypeTypeType) (= (DomainMod.Domain.EmptyDomain_q d@@162) (= (DatatypeCtorId d@@162) |##DomainMod.Domain.EmptyDomain|)))
 :qid |unknown.0:0|
 :skolemid |4957|
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@162))
)))
(assert (forall ((d@@163 T@U) ) (!  (=> (and (= (type d@@163) DatatypeTypeType) (DomainMod.Domain.EmptyDomain_q d@@163)) (= d@@163 |#DomainMod.Domain.EmptyDomain|))
 :qid |unknown.0:0|
 :skolemid |4958|
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@163))
)))
(assert ($Is |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain))
(assert (forall (($h@@168 T@U) ) (!  (=> (and (= (type $h@@168) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@168)) ($IsAlloc |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain $h@@168))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |4959|
 :pattern ( ($IsAlloc |#DomainMod.Domain.EmptyDomain| Tclass.DomainMod.Domain $h@@168))
)))
(assert (= |#DomainMod.Domain.EmptyDomain| (Lit |#DomainMod.Domain.EmptyDomain|)))
(assert (forall ((|a#5#0#0@@13| T@U) (|a#5#1#0@@7| T@U) ) (!  (=> (and (= (type |a#5#0#0@@13|) DatatypeTypeType) (= (type |a#5#1#0@@7|) DatatypeTypeType)) (= (DatatypeCtorId (|#DomainMod.Domain.Domain| |a#5#0#0@@13| |a#5#1#0@@7|)) |##DomainMod.Domain.Domain|))
 :qid |Domainidfy.17:42|
 :skolemid |4960|
 :pattern ( (|#DomainMod.Domain.Domain| |a#5#0#0@@13| |a#5#1#0@@7|))
)))
(assert (forall ((d@@164 T@U) ) (!  (=> (= (type d@@164) DatatypeTypeType) (= (DomainMod.Domain.Domain_q d@@164) (= (DatatypeCtorId d@@164) |##DomainMod.Domain.Domain|)))
 :qid |unknown.0:0|
 :skolemid |4961|
 :pattern ( (DomainMod.Domain.Domain_q d@@164))
)))
(assert (forall ((d@@165 T@U) ) (!  (=> (and (= (type d@@165) DatatypeTypeType) (DomainMod.Domain.Domain_q d@@165)) (exists ((|a#6#0#0@@13| T@U) (|a#6#1#0@@7| T@U) ) (!  (and (and (= (type |a#6#0#0@@13|) DatatypeTypeType) (= (type |a#6#1#0@@7|) DatatypeTypeType)) (= d@@165 (|#DomainMod.Domain.Domain| |a#6#0#0@@13| |a#6#1#0@@7|)))
 :qid |Domainidfy.17:42|
 :skolemid |4962|
 :no-pattern (type |a#6#0#0@@13|)
 :no-pattern (type |a#6#1#0@@7|)
 :no-pattern (U_2_int |a#6#0#0@@13|)
 :no-pattern (U_2_bool |a#6#0#0@@13|)
 :no-pattern (U_2_int |a#6#1#0@@7|)
 :no-pattern (U_2_bool |a#6#1#0@@7|)
)))
 :qid |unknown.0:0|
 :skolemid |4963|
 :pattern ( (DomainMod.Domain.Domain_q d@@165))
)))
(assert (forall ((|a#7#0#0@@12| T@U) (|a#7#1#0@@7| T@U) ) (!  (=> (and (= (type |a#7#0#0@@12|) DatatypeTypeType) (= (type |a#7#1#0@@7|) DatatypeTypeType)) (= ($Is (|#DomainMod.Domain.Domain| |a#7#0#0@@12| |a#7#1#0@@7|) Tclass.DomainMod.Domain)  (and ($Is |a#7#0#0@@12| Tclass.Upperbounded__Lexicographic__Byte__Order.Element) ($Is |a#7#1#0@@7| Tclass.Upperbounded__Lexicographic__Byte__Order.Element))))
 :qid |Domainidfy.17:42|
 :skolemid |4964|
 :pattern ( ($Is (|#DomainMod.Domain.Domain| |a#7#0#0@@12| |a#7#1#0@@7|) Tclass.DomainMod.Domain))
)))
(assert (forall ((|a#8#0#0@@8| T@U) (|a#8#1#0@@6| T@U) ($h@@169 T@U) ) (!  (=> (and (and (and (= (type |a#8#0#0@@8|) DatatypeTypeType) (= (type |a#8#1#0@@6|) DatatypeTypeType)) (= (type $h@@169) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@169)) (= ($IsAlloc (|#DomainMod.Domain.Domain| |a#8#0#0@@8| |a#8#1#0@@6|) Tclass.DomainMod.Domain $h@@169)  (and ($IsAlloc |a#8#0#0@@8| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@169) ($IsAlloc |a#8#1#0@@6| Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@169))))
 :qid |Domainidfy.17:42|
 :skolemid |4965|
 :pattern ( ($IsAlloc (|#DomainMod.Domain.Domain| |a#8#0#0@@8| |a#8#1#0@@6|) Tclass.DomainMod.Domain $h@@169))
)))
(assert (forall ((d@@166 T@U) ($h@@170 T@U) ) (!  (=> (and (and (= (type d@@166) DatatypeTypeType) (= (type $h@@170) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@170) (and (DomainMod.Domain.Domain_q d@@166) ($IsAlloc d@@166 Tclass.DomainMod.Domain $h@@170)))) ($IsAlloc (DomainMod.Domain.start d@@166) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@170))
 :qid |unknown.0:0|
 :skolemid |4966|
 :pattern ( ($IsAlloc (DomainMod.Domain.start d@@166) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@170))
)))
(assert (forall ((d@@167 T@U) ($h@@171 T@U) ) (!  (=> (and (and (= (type d@@167) DatatypeTypeType) (= (type $h@@171) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@171) (and (DomainMod.Domain.Domain_q d@@167) ($IsAlloc d@@167 Tclass.DomainMod.Domain $h@@171)))) ($IsAlloc (DomainMod.Domain.end d@@167) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@171))
 :qid |unknown.0:0|
 :skolemid |4967|
 :pattern ( ($IsAlloc (DomainMod.Domain.end d@@167) Tclass.Upperbounded__Lexicographic__Byte__Order.Element $h@@171))
)))
(assert (forall ((|a#9#0#0@@3| T@U) (|a#9#1#0@@1| T@U) ) (!  (=> (and (= (type |a#9#0#0@@3|) DatatypeTypeType) (= (type |a#9#1#0@@1|) DatatypeTypeType)) (= (|#DomainMod.Domain.Domain| (Lit |a#9#0#0@@3|) (Lit |a#9#1#0@@1|)) (Lit (|#DomainMod.Domain.Domain| |a#9#0#0@@3| |a#9#1#0@@1|))))
 :qid |Domainidfy.17:42|
 :skolemid |4968|
 :pattern ( (|#DomainMod.Domain.Domain| (Lit |a#9#0#0@@3|) (Lit |a#9#1#0@@1|)))
)))
(assert (forall ((|a#10#0#0@@3| T@U) (|a#10#1#0@@1| T@U) ) (!  (=> (and (= (type |a#10#0#0@@3|) DatatypeTypeType) (= (type |a#10#1#0@@1|) DatatypeTypeType)) (= (DomainMod.Domain.start (|#DomainMod.Domain.Domain| |a#10#0#0@@3| |a#10#1#0@@1|)) |a#10#0#0@@3|))
 :qid |Domainidfy.17:42|
 :skolemid |4969|
 :pattern ( (|#DomainMod.Domain.Domain| |a#10#0#0@@3| |a#10#1#0@@1|))
)))
(assert (forall ((|a#11#0#0@@2| T@U) (|a#11#1#0@@0| T@U) ) (!  (=> (and (= (type |a#11#0#0@@2|) DatatypeTypeType) (= (type |a#11#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#11#0#0@@2|) (DtRank (|#DomainMod.Domain.Domain| |a#11#0#0@@2| |a#11#1#0@@0|))))
 :qid |Domainidfy.17:42|
 :skolemid |4970|
 :pattern ( (|#DomainMod.Domain.Domain| |a#11#0#0@@2| |a#11#1#0@@0|))
)))
(assert (forall ((|a#12#0#0@@1| T@U) (|a#12#1#0@@0| T@U) ) (!  (=> (and (= (type |a#12#0#0@@1|) DatatypeTypeType) (= (type |a#12#1#0@@0|) DatatypeTypeType)) (= (DomainMod.Domain.end (|#DomainMod.Domain.Domain| |a#12#0#0@@1| |a#12#1#0@@0|)) |a#12#1#0@@0|))
 :qid |Domainidfy.17:42|
 :skolemid |4971|
 :pattern ( (|#DomainMod.Domain.Domain| |a#12#0#0@@1| |a#12#1#0@@0|))
)))
(assert (forall ((|a#13#0#0@@0| T@U) (|a#13#1#0@@0| T@U) ) (!  (=> (and (= (type |a#13#0#0@@0|) DatatypeTypeType) (= (type |a#13#1#0@@0|) DatatypeTypeType)) (< (DtRank |a#13#1#0@@0|) (DtRank (|#DomainMod.Domain.Domain| |a#13#0#0@@0| |a#13#1#0@@0|))))
 :qid |Domainidfy.17:42|
 :skolemid |4972|
 :pattern ( (|#DomainMod.Domain.Domain| |a#13#0#0@@0| |a#13#1#0@@0|))
)))
(assert (forall ((d@@168 T@U) ) (!  (=> (and (= (type d@@168) DatatypeTypeType) (|$IsA#DomainMod.Domain| d@@168)) (or (DomainMod.Domain.EmptyDomain_q d@@168) (DomainMod.Domain.Domain_q d@@168)))
 :qid |unknown.0:0|
 :skolemid |4973|
 :pattern ( (|$IsA#DomainMod.Domain| d@@168))
)))
(assert (forall ((d@@169 T@U) ) (!  (=> (and (= (type d@@169) DatatypeTypeType) ($Is d@@169 Tclass.DomainMod.Domain)) (or (DomainMod.Domain.EmptyDomain_q d@@169) (DomainMod.Domain.Domain_q d@@169)))
 :qid |unknown.0:0|
 :skolemid |4974|
 :pattern ( (DomainMod.Domain.Domain_q d@@169) ($Is d@@169 Tclass.DomainMod.Domain))
 :pattern ( (DomainMod.Domain.EmptyDomain_q d@@169) ($Is d@@169 Tclass.DomainMod.Domain))
)))
(assert (forall ((a@@170 T@U) (b@@119 T@U) ) (!  (=> (and (and (= (type a@@170) DatatypeTypeType) (= (type b@@119) DatatypeTypeType)) (and (DomainMod.Domain.EmptyDomain_q a@@170) (DomainMod.Domain.EmptyDomain_q b@@119))) (= (|DomainMod.Domain#Equal| a@@170 b@@119) true))
 :qid |unknown.0:0|
 :skolemid |4975|
 :pattern ( (|DomainMod.Domain#Equal| a@@170 b@@119) (DomainMod.Domain.EmptyDomain_q a@@170))
 :pattern ( (|DomainMod.Domain#Equal| a@@170 b@@119) (DomainMod.Domain.EmptyDomain_q b@@119))
)))
(assert (forall ((a@@171 T@U) (b@@120 T@U) ) (!  (=> (and (and (= (type a@@171) DatatypeTypeType) (= (type b@@120) DatatypeTypeType)) (and (DomainMod.Domain.Domain_q a@@171) (DomainMod.Domain.Domain_q b@@120))) (= (|DomainMod.Domain#Equal| a@@171 b@@120)  (and (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (DomainMod.Domain.start a@@171) (DomainMod.Domain.start b@@120)) (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (DomainMod.Domain.end a@@171) (DomainMod.Domain.end b@@120)))))
 :qid |unknown.0:0|
 :skolemid |4976|
 :pattern ( (|DomainMod.Domain#Equal| a@@171 b@@120) (DomainMod.Domain.Domain_q a@@171))
 :pattern ( (|DomainMod.Domain#Equal| a@@171 b@@120) (DomainMod.Domain.Domain_q b@@120))
)))
(assert (forall ((a@@172 T@U) (b@@121 T@U) ) (!  (=> (and (= (type a@@172) DatatypeTypeType) (= (type b@@121) DatatypeTypeType)) (= (|DomainMod.Domain#Equal| a@@172 b@@121) (= a@@172 b@@121)))
 :qid |unknown.0:0|
 :skolemid |4977|
 :pattern ( (|DomainMod.Domain#Equal| a@@172 b@@121))
)))
(assert (forall (($ly@@721 T@U) (this@@307 T@U) ) (!  (=> (and (= (type $ly@@721) LayerTypeType) (= (type this@@307) DatatypeTypeType)) (= (DomainMod.Domain.SaneKeys ($LS $ly@@721) this@@307) (DomainMod.Domain.SaneKeys $ly@@721 this@@307)))
 :qid |Domainidfy.21:25|
 :skolemid |4978|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@721) this@@307))
)))
(assert (forall (($ly@@722 T@U) (this@@308 T@U) ) (!  (=> (and (= (type $ly@@722) LayerTypeType) (= (type this@@308) DatatypeTypeType)) (= (DomainMod.Domain.SaneKeys $ly@@722 this@@308) (DomainMod.Domain.SaneKeys $LZ this@@308)))
 :qid |Domainidfy.21:25|
 :skolemid |4979|
 :pattern ( (DomainMod.Domain.SaneKeys (AsFuelBottom $ly@@722) this@@308))
)))
(assert  (=> true (forall (($ly@@723 T@U) (this@@309 T@U) ) (!  (=> (and (and (= (type $ly@@723) LayerTypeType) (= (type this@@309) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| this@@309) ($Is this@@309 Tclass.DomainMod.Domain))) true)
 :qid |Domainidfy.21:25|
 :skolemid |4980|
 :pattern ( (DomainMod.Domain.SaneKeys $ly@@723 this@@309))
))))
(assert (forall (($ly@@724 T@U) (this@@310 T@U) ) (!  (=> (and (and (= (type $ly@@724) LayerTypeType) (= (type this@@310) DatatypeTypeType)) ($Is this@@310 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.SaneKeys#requires| $ly@@724 this@@310) true))
 :qid |Domainidfy.21:25|
 :skolemid |4981|
 :pattern ( (|DomainMod.Domain.SaneKeys#requires| $ly@@724 this@@310))
)))
(assert  (=> true (forall (($ly@@725 T@U) (this@@311 T@U) ) (!  (=> (and (and (= (type $ly@@725) LayerTypeType) (= (type this@@311) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| this@@311) ($Is this@@311 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (not (DomainMod.Domain.EmptyDomain_q this@@311)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (DomainMod.Domain.start this@@311) (DomainMod.Domain.end this@@311)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lt (DomainMod.Domain.start this@@311) (DomainMod.Domain.end this@@311)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.start this@@311)) (and (|BoundedPivotsLib.__default.ElementIsKey#canCall| (DomainMod.Domain.start this@@311)) (=> (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.start this@@311)) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.end this@@311)) (|BoundedPivotsLib.__default.ElementIsKey#canCall| (DomainMod.Domain.end this@@311)))))))))) (= (DomainMod.Domain.SaneKeys ($LS $ly@@725) this@@311)  (and true (=> (not (DomainMod.Domain.EmptyDomain_q this@@311)) (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.lt (DomainMod.Domain.start this@@311) (DomainMod.Domain.end this@@311)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.start this@@311))) (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.start this@@311))) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (DomainMod.Domain.end this@@311)) (BoundedPivotsLib.__default.ElementIsKey (DomainMod.Domain.end this@@311)))))))))
 :qid |Domainidfy.21:25|
 :skolemid |4982|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@725) this@@311))
))))
(assert  (=> true (forall (($ly@@726 T@U) (this@@312 T@U) ) (!  (=> (and (and (= (type $ly@@726) LayerTypeType) (= (type this@@312) DatatypeTypeType)) (or (|DomainMod.Domain.SaneKeys#canCall| (Lit this@@312)) ($Is this@@312 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@312)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (DomainMod.Domain.start (Lit this@@312))) (Lit (DomainMod.Domain.end (Lit this@@312)))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (DomainMod.Domain.start (Lit this@@312))) (Lit (DomainMod.Domain.end (Lit this@@312))))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.start (Lit this@@312))))))) (and (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit (DomainMod.Domain.start (Lit this@@312)))) (=> (U_2_bool (Lit (bool_2_U (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.start (Lit this@@312))))))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.end (Lit this@@312))))))) (|BoundedPivotsLib.__default.ElementIsKey#canCall| (Lit (DomainMod.Domain.end (Lit this@@312)))))))))))) (= (DomainMod.Domain.SaneKeys ($LS $ly@@726) (Lit this@@312))  (and true (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@312)))))) (and (and (and (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (DomainMod.Domain.start (Lit this@@312))) (Lit (DomainMod.Domain.end (Lit this@@312)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.start (Lit this@@312))))) (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.start (Lit this@@312))))) (=> (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (Lit (DomainMod.Domain.end (Lit this@@312)))) (BoundedPivotsLib.__default.ElementIsKey (Lit (DomainMod.Domain.end (Lit this@@312)))))))))))
 :qid |Domainidfy.21:25|
 :weight 3
 :skolemid |4983|
 :pattern ( (DomainMod.Domain.SaneKeys ($LS $ly@@726) (Lit this@@312)))
))))
(assert  (=> true (forall ((this@@313 T@U) ) (!  (=> (and (= (type this@@313) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| this@@313) ($Is this@@313 Tclass.DomainMod.Domain))) true)
 :qid |Domainidfy.31:15|
 :skolemid |4984|
 :pattern ( (DomainMod.Domain.WF this@@313))
))))
(assert (forall ((this@@314 T@U) ) (!  (=> (and (= (type this@@314) DatatypeTypeType) ($Is this@@314 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.WF#requires| this@@314) true))
 :qid |Domainidfy.31:15|
 :skolemid |4985|
 :pattern ( (|DomainMod.Domain.WF#requires| this@@314))
)))
(assert (= (type StartFuel_DomainMod.Domain.SaneKeys) LayerTypeType))
(assert  (=> true (forall ((this@@315 T@U) ) (!  (=> (and (= (type this@@315) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| this@@315) ($Is this@@315 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|DomainMod.Domain.SaneKeys#canCall| this@@315)) (= (DomainMod.Domain.WF this@@315)  (and true (DomainMod.Domain.SaneKeys StartFuel_DomainMod.Domain.SaneKeys this@@315)))))
 :qid |Domainidfy.31:15|
 :skolemid |4986|
 :pattern ( (DomainMod.Domain.WF this@@315))
))))
(assert  (=> true (forall ((this@@316 T@U) ) (!  (=> (and (= (type this@@316) DatatypeTypeType) (or (|DomainMod.Domain.WF#canCall| (Lit this@@316)) ($Is this@@316 Tclass.DomainMod.Domain))) (and (=> (U_2_bool (Lit (bool_2_U true))) (|DomainMod.Domain.SaneKeys#canCall| (Lit this@@316))) (= (DomainMod.Domain.WF (Lit this@@316))  (and true (DomainMod.Domain.SaneKeys StartFuel_DomainMod.Domain.SaneKeys (Lit this@@316))))))
 :qid |Domainidfy.31:15|
 :weight 3
 :skolemid |4987|
 :pattern ( (DomainMod.Domain.WF (Lit this@@316)))
))))
(assert  (=> true (forall ((this@@317 T@U) (|key#0@@222| T@U) ) (!  (=> (and (and (= (type this@@317) DatatypeTypeType) (= (type |key#0@@222|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| this@@317 |key#0@@222|) (and ($Is this@@317 Tclass.DomainMod.Domain) ($Is |key#0@@222| Tclass.KeyType.Key)))) true)
 :qid |Domainidfy.35:15|
 :skolemid |4988|
 :pattern ( (DomainMod.Domain.Contains this@@317 |key#0@@222|))
))))
(assert (forall ((this@@318 T@U) (|key#0@@223| T@U) ) (!  (=> (and (and (= (type this@@318) DatatypeTypeType) (= (type |key#0@@223|) (SeqType BoxType))) (and ($Is this@@318 Tclass.DomainMod.Domain) ($Is |key#0@@223| Tclass.KeyType.Key))) (= (|DomainMod.Domain.Contains#requires| this@@318 |key#0@@223|) true))
 :qid |Domainidfy.35:15|
 :skolemid |4989|
 :pattern ( (|DomainMod.Domain.Contains#requires| this@@318 |key#0@@223|))
)))
(assert  (=> true (forall ((this@@319 T@U) (|key#0@@224| T@U) ) (!  (=> (and (and (= (type this@@319) DatatypeTypeType) (= (type |key#0@@224|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| this@@319 |key#0@@224|) (and ($Is this@@319 Tclass.DomainMod.Domain) ($Is |key#0@@224| Tclass.KeyType.Key)))) (and (=> (not (DomainMod.Domain.EmptyDomain_q this@@319)) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (DomainMod.Domain.start this@@319) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@224|)) (=> (Upperbounded__Lexicographic__Byte__Order.__default.lte (DomainMod.Domain.start this@@319) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@224|)) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@224|) (DomainMod.Domain.end this@@319))))) (= (DomainMod.Domain.Contains this@@319 |key#0@@224|)  (and (and (not (DomainMod.Domain.EmptyDomain_q this@@319)) (Upperbounded__Lexicographic__Byte__Order.__default.lte (DomainMod.Domain.start this@@319) (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@224|))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| |key#0@@224|) (DomainMod.Domain.end this@@319))))))
 :qid |Domainidfy.35:15|
 :skolemid |4990|
 :pattern ( (DomainMod.Domain.Contains this@@319 |key#0@@224|))
))))
(assert  (=> true (forall ((this@@320 T@U) (|key#0@@225| T@U) ) (!  (=> (and (and (= (type this@@320) DatatypeTypeType) (= (type |key#0@@225|) (SeqType BoxType))) (or (|DomainMod.Domain.Contains#canCall| (Lit this@@320) (Lit |key#0@@225|)) (and ($Is this@@320 Tclass.DomainMod.Domain) ($Is |key#0@@225| Tclass.KeyType.Key)))) (and (=> (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@320)))))) (and (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (Lit (DomainMod.Domain.start (Lit this@@320))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@225|)))) (=> (U_2_bool (Lit (bool_2_U (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (DomainMod.Domain.start (Lit this@@320))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@225|))))))) (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@225|))) (Lit (DomainMod.Domain.end (Lit this@@320))))))) (= (DomainMod.Domain.Contains (Lit this@@320) (Lit |key#0@@225|))  (and (and (not (U_2_bool (Lit (bool_2_U (DomainMod.Domain.EmptyDomain_q (Lit this@@320)))))) (Upperbounded__Lexicographic__Byte__Order.__default.lte (Lit (DomainMod.Domain.start (Lit this@@320))) (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@225|))))) (Upperbounded__Lexicographic__Byte__Order.__default.lt (Lit (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| (Lit |key#0@@225|))) (Lit (DomainMod.Domain.end (Lit this@@320))))))))
 :qid |Domainidfy.35:15|
 :weight 3
 :skolemid |4991|
 :pattern ( (DomainMod.Domain.Contains (Lit this@@320) (Lit |key#0@@225|)))
))))
(assert  (=> true (forall ((this@@321 T@U) ) (!  (=> (and (= (type this@@321) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| this@@321) ($Is this@@321 Tclass.DomainMod.Domain))) ($Is (DomainMod.Domain.KeySet this@@321) (TISet Tclass.KeyType.Key)))
 :qid |Domainidfy.64:14|
 :skolemid |4992|
 :pattern ( (DomainMod.Domain.KeySet this@@321))
))))
(assert (forall ((this@@322 T@U) ) (!  (=> (and (= (type this@@322) DatatypeTypeType) ($Is this@@322 Tclass.DomainMod.Domain)) (= (|DomainMod.Domain.KeySet#requires| this@@322) true))
 :qid |Domainidfy.64:14|
 :skolemid |4993|
 :pattern ( (|DomainMod.Domain.KeySet#requires| this@@322))
)))
(assert (forall ((arg0@@652 T@U) (arg1@@346 T@U) ) (! (= (type (|lambda#353| arg0@@652 arg1@@346)) (MapType0Type BoxType boolType))
 :qid |funType:lambda#353|
 :pattern ( (|lambda#353| arg0@@652 arg1@@346))
)))
(assert  (=> true (forall ((this@@323 T@U) ) (!  (=> (and (= (type this@@323) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| this@@323) ($Is this@@323 Tclass.DomainMod.Domain))) (and (forall ((|key#0@@226| T@U) ) (!  (=> (and (= (type |key#0@@226|) (SeqType BoxType)) ($Is |key#0@@226| Tclass.KeyType.Key)) (|DomainMod.Domain.Contains#canCall| this@@323 |key#0@@226|))
 :qid |Domainidfy.66:12|
 :skolemid |4994|
 :pattern ( (DomainMod.Domain.Contains this@@323 |key#0@@226|))
)) (= (DomainMod.Domain.KeySet this@@323) (|lambda#353| Tclass.KeyType.Key this@@323))))
 :qid |Domainidfy.64:14|
 :skolemid |4995|
 :pattern ( (DomainMod.Domain.KeySet this@@323))
))))
(assert  (=> true (forall ((this@@324 T@U) ) (!  (=> (and (= (type this@@324) DatatypeTypeType) (or (|DomainMod.Domain.KeySet#canCall| (Lit this@@324)) ($Is this@@324 Tclass.DomainMod.Domain))) (and (forall ((|key#1@@15| T@U) ) (!  (=> (and (= (type |key#1@@15|) (SeqType BoxType)) ($Is |key#1@@15| Tclass.KeyType.Key)) (|DomainMod.Domain.Contains#canCall| (Lit this@@324) |key#1@@15|))
 :qid |Domainidfy.66:12|
 :skolemid |4996|
 :pattern ( (DomainMod.Domain.Contains this@@324 |key#1@@15|))
)) (= (DomainMod.Domain.KeySet (Lit this@@324)) (|lambda#353| Tclass.KeyType.Key (Lit this@@324)))))
 :qid |Domainidfy.64:14|
 :weight 3
 :skolemid |4997|
 :pattern ( (DomainMod.Domain.KeySet (Lit this@@324)))
))))
(assert (= (type Tclass.DomainMod.__default) TyType))
(assert (= (Tag Tclass.DomainMod.__default) Tagclass.DomainMod.__default))
(assert (= (TagFamily Tclass.DomainMod.__default) tytagFamily$_default))
(assert (forall ((bx@@170 T@U) ) (!  (=> (and (= (type bx@@170) BoxType) ($IsBox bx@@170 Tclass.DomainMod.__default)) (and (= ($Box ($Unbox refType bx@@170)) bx@@170) ($Is ($Unbox refType bx@@170) Tclass.DomainMod.__default)))
 :qid |unknown.0:0|
 :skolemid |4998|
 :pattern ( ($IsBox bx@@170 Tclass.DomainMod.__default))
)))
(assert (forall (($o@@67 T@U) ) (!  (=> (= (type $o@@67) refType) (= ($Is $o@@67 Tclass.DomainMod.__default)  (or (= $o@@67 null) (= (dtype $o@@67) Tclass.DomainMod.__default))))
 :qid |unknown.0:0|
 :skolemid |4999|
 :pattern ( ($Is $o@@67 Tclass.DomainMod.__default))
)))
(assert (forall (($o@@68 T@U) ($h@@172 T@U) ) (!  (=> (and (= (type $o@@68) refType) (= (type $h@@172) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@68 Tclass.DomainMod.__default $h@@172)  (or (= $o@@68 null) (U_2_bool (MapType1Select (MapType0Select $h@@172 $o@@68) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5000|
 :pattern ( ($IsAlloc $o@@68 Tclass.DomainMod.__default $h@@172))
)))
(assert  (=> true (=> true (and (and (DomainMod.Domain.WF DomainMod.__default.TotalDomain) (DomainMod.Domain.Domain_q DomainMod.__default.TotalDomain)) ($Is DomainMod.__default.TotalDomain Tclass.DomainMod.Domain)))))
(assert (= |DomainMod.__default.TotalDomain#requires| true))
(assert  (=> true (=> true (and |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| (= DomainMod.__default.TotalDomain (let ((|out#0@@5| (Lit (|#DomainMod.Domain.Domain| (Lit Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
|out#0@@5|))))))
(assert  (=> true (=> true (and |Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement#canCall| (= DomainMod.__default.TotalDomain (let ((|out#1@@4| (Lit (|#DomainMod.Domain.Domain| (Lit Upperbounded__Lexicographic__Byte__Order.__default.GetSmallestElement) (Lit |#Upperbounded_Lexicographic_Byte_Order.Element.Max_Element|)))))
|out#1@@4|))))))
(assert (forall ((arg0@@653 Int) (arg1@@347 T@U) ) (! (= (type (|#SplitRequestMod.SplitRequest.SplitLeaf| arg0@@653 arg1@@347)) DatatypeTypeType)
 :qid |funType:#SplitRequestMod.SplitRequest.SplitLeaf|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| arg0@@653 arg1@@347))
)))
(assert (forall ((|a#0#0#0@@12| Int) (|a#0#1#0@@7| T@U) ) (!  (=> (= (type |a#0#1#0@@7|) (SeqType BoxType)) (= (DatatypeCtorId (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#0#0#0@@12| |a#0#1#0@@7|)) |##SplitRequestMod.SplitRequest.SplitLeaf|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5001|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#0#0#0@@12| |a#0#1#0@@7|))
)))
(assert (forall ((d@@170 T@U) ) (!  (=> (= (type d@@170) DatatypeTypeType) (= (SplitRequestMod.SplitRequest.SplitLeaf_q d@@170) (= (DatatypeCtorId d@@170) |##SplitRequestMod.SplitRequest.SplitLeaf|)))
 :qid |unknown.0:0|
 :skolemid |5002|
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@170))
)))
(assert (forall ((d@@171 T@U) ) (!  (=> (and (= (type d@@171) DatatypeTypeType) (SplitRequestMod.SplitRequest.SplitLeaf_q d@@171)) (exists ((|a#1#0#0@@12| Int) (|a#1#1#0@@7| T@U) ) (!  (and (= (type |a#1#1#0@@7|) (SeqType BoxType)) (= d@@171 (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#1#0#0@@12| |a#1#1#0@@7|)))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5003|
 :no-pattern (type |a#1#1#0@@7|)
 :no-pattern (U_2_int |a#1#1#0@@7|)
 :no-pattern (U_2_bool |a#1#1#0@@7|)
)))
 :qid |unknown.0:0|
 :skolemid |5004|
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@171))
)))
(assert (forall ((|a#2#0#0@@12| Int) (|a#2#1#0@@7| T@U) ) (!  (=> (= (type |a#2#1#0@@7|) (SeqType BoxType)) (= ($Is (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#2#0#0@@12| |a#2#1#0@@7|) Tclass.SplitRequestMod.SplitRequest)  (and ($Is (int_2_U |a#2#0#0@@12|) Tclass._System.nat) ($Is |a#2#1#0@@7| Tclass.KeyType.Key))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5005|
 :pattern ( ($Is (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#2#0#0@@12| |a#2#1#0@@7|) Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((|a#3#0#0@@12| Int) (|a#3#1#0@@7| T@U) ($h@@173 T@U) ) (!  (=> (and (and (= (type |a#3#1#0@@7|) (SeqType BoxType)) (= (type $h@@173) (MapType0Type refType MapType1Type))) ($IsGoodHeap $h@@173)) (= ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#3#0#0@@12| |a#3#1#0@@7|) Tclass.SplitRequestMod.SplitRequest $h@@173)  (and ($IsAlloc (int_2_U |a#3#0#0@@12|) Tclass._System.nat $h@@173) ($IsAlloc |a#3#1#0@@7| Tclass.KeyType.Key $h@@173))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5006|
 :pattern ( ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#3#0#0@@12| |a#3#1#0@@7|) Tclass.SplitRequestMod.SplitRequest $h@@173))
)))
(assert (forall ((d@@172 T@U) ($h@@174 T@U) ) (!  (=> (and (and (= (type d@@172) DatatypeTypeType) (= (type $h@@174) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@174) (and (SplitRequestMod.SplitRequest.SplitLeaf_q d@@172) ($IsAlloc d@@172 Tclass.SplitRequestMod.SplitRequest $h@@174)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@172)) Tclass._System.nat $h@@174))
 :qid |unknown.0:0|
 :skolemid |5007|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@172)) Tclass._System.nat $h@@174))
)))
(assert (forall ((d@@173 T@U) ($h@@175 T@U) ) (!  (=> (and (and (= (type d@@173) DatatypeTypeType) (= (type $h@@175) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@175) (and (SplitRequestMod.SplitRequest.SplitLeaf_q d@@173) ($IsAlloc d@@173 Tclass.SplitRequestMod.SplitRequest $h@@175)))) ($IsAlloc (SplitRequestMod.SplitRequest.splitKey d@@173) Tclass.KeyType.Key $h@@175))
 :qid |unknown.0:0|
 :skolemid |5008|
 :pattern ( ($IsAlloc (SplitRequestMod.SplitRequest.splitKey d@@173) Tclass.KeyType.Key $h@@175))
)))
(assert (forall ((|a#4#0#0@@12| Int) (|a#4#1#0@@7| T@U) ) (!  (=> (= (type |a#4#1#0@@7|) (SeqType BoxType)) (= (|#SplitRequestMod.SplitRequest.SplitLeaf| (LitInt |a#4#0#0@@12|) (Lit |a#4#1#0@@7|)) (Lit (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#4#0#0@@12| |a#4#1#0@@7|))))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5009|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| (LitInt |a#4#0#0@@12|) (Lit |a#4#1#0@@7|)))
)))
(assert (forall ((|a#5#0#0@@14| Int) (|a#5#1#0@@8| T@U) ) (!  (=> (= (type |a#5#1#0@@8|) (SeqType BoxType)) (= (SplitRequestMod.SplitRequest.childIdx (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#5#0#0@@14| |a#5#1#0@@8|)) |a#5#0#0@@14|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5010|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#5#0#0@@14| |a#5#1#0@@8|))
)))
(assert (forall ((|a#6#0#0@@14| Int) (|a#6#1#0@@8| T@U) ) (!  (=> (= (type |a#6#1#0@@8|) (SeqType BoxType)) (= (SplitRequestMod.SplitRequest.splitKey (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#6#0#0@@14| |a#6#1#0@@8|)) |a#6#1#0@@8|))
 :qid |SplitRequestidfy.10:17|
 :skolemid |5011|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitLeaf| |a#6#0#0@@14| |a#6#1#0@@8|))
)))
(assert (forall ((arg0@@654 Int) (arg1@@348 Int) ) (! (= (type (|#SplitRequestMod.SplitRequest.SplitIndex| arg0@@654 arg1@@348)) DatatypeTypeType)
 :qid |funType:#SplitRequestMod.SplitRequest.SplitIndex|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| arg0@@654 arg1@@348))
)))
(assert (forall ((|a#7#0#0@@13| Int) (|a#7#1#0@@8| Int) ) (! (= (DatatypeCtorId (|#SplitRequestMod.SplitRequest.SplitIndex| |a#7#0#0@@13| |a#7#1#0@@8|)) |##SplitRequestMod.SplitRequest.SplitIndex|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |5012|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#7#0#0@@13| |a#7#1#0@@8|))
)))
(assert (forall ((d@@174 T@U) ) (!  (=> (= (type d@@174) DatatypeTypeType) (= (SplitRequestMod.SplitRequest.SplitIndex_q d@@174) (= (DatatypeCtorId d@@174) |##SplitRequestMod.SplitRequest.SplitIndex|)))
 :qid |unknown.0:0|
 :skolemid |5013|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@174))
)))
(assert (forall ((d@@175 T@U) ) (!  (=> (and (= (type d@@175) DatatypeTypeType) (SplitRequestMod.SplitRequest.SplitIndex_q d@@175)) (exists ((|a#8#0#0@@9| Int) (|a#8#1#0@@7| Int) ) (! (= d@@175 (|#SplitRequestMod.SplitRequest.SplitIndex| |a#8#0#0@@9| |a#8#1#0@@7|))
 :qid |SplitRequestidfy.11:18|
 :skolemid |5014|
)))
 :qid |unknown.0:0|
 :skolemid |5015|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@175))
)))
(assert (forall ((|a#9#0#0@@4| Int) (|a#9#1#0@@2| Int) ) (! (= ($Is (|#SplitRequestMod.SplitRequest.SplitIndex| |a#9#0#0@@4| |a#9#1#0@@2|) Tclass.SplitRequestMod.SplitRequest)  (and ($Is (int_2_U |a#9#0#0@@4|) Tclass._System.nat) ($Is (int_2_U |a#9#1#0@@2|) Tclass._System.nat)))
 :qid |SplitRequestidfy.11:18|
 :skolemid |5016|
 :pattern ( ($Is (|#SplitRequestMod.SplitRequest.SplitIndex| |a#9#0#0@@4| |a#9#1#0@@2|) Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((|a#10#0#0@@4| Int) (|a#10#1#0@@2| Int) ($h@@176 T@U) ) (!  (=> (and (= (type $h@@176) (MapType0Type refType MapType1Type)) ($IsGoodHeap $h@@176)) (= ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitIndex| |a#10#0#0@@4| |a#10#1#0@@2|) Tclass.SplitRequestMod.SplitRequest $h@@176)  (and ($IsAlloc (int_2_U |a#10#0#0@@4|) Tclass._System.nat $h@@176) ($IsAlloc (int_2_U |a#10#1#0@@2|) Tclass._System.nat $h@@176))))
 :qid |SplitRequestidfy.11:18|
 :skolemid |5017|
 :pattern ( ($IsAlloc (|#SplitRequestMod.SplitRequest.SplitIndex| |a#10#0#0@@4| |a#10#1#0@@2|) Tclass.SplitRequestMod.SplitRequest $h@@176))
)))
(assert (forall ((d@@176 T@U) ($h@@177 T@U) ) (!  (=> (and (and (= (type d@@176) DatatypeTypeType) (= (type $h@@177) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@177) (and (SplitRequestMod.SplitRequest.SplitIndex_q d@@176) ($IsAlloc d@@176 Tclass.SplitRequestMod.SplitRequest $h@@177)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@176)) Tclass._System.nat $h@@177))
 :qid |unknown.0:0|
 :skolemid |5018|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childIdx d@@176)) Tclass._System.nat $h@@177))
)))
(assert (forall ((d@@177 T@U) ($h@@178 T@U) ) (!  (=> (and (and (= (type d@@177) DatatypeTypeType) (= (type $h@@178) (MapType0Type refType MapType1Type))) (and ($IsGoodHeap $h@@178) (and (SplitRequestMod.SplitRequest.SplitIndex_q d@@177) ($IsAlloc d@@177 Tclass.SplitRequestMod.SplitRequest $h@@178)))) ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childPivotIdx d@@177)) Tclass._System.nat $h@@178))
 :qid |unknown.0:0|
 :skolemid |5019|
 :pattern ( ($IsAlloc (int_2_U (SplitRequestMod.SplitRequest.childPivotIdx d@@177)) Tclass._System.nat $h@@178))
)))
(assert (forall ((|a#11#0#0@@3| Int) (|a#11#1#0@@1| Int) ) (! (= (|#SplitRequestMod.SplitRequest.SplitIndex| (LitInt |a#11#0#0@@3|) (LitInt |a#11#1#0@@1|)) (Lit (|#SplitRequestMod.SplitRequest.SplitIndex| |a#11#0#0@@3| |a#11#1#0@@1|)))
 :qid |SplitRequestidfy.11:18|
 :skolemid |5020|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| (LitInt |a#11#0#0@@3|) (LitInt |a#11#1#0@@1|)))
)))
(assert (forall ((|a#12#0#0@@2| Int) (|a#12#1#0@@1| Int) ) (! (= (SplitRequestMod.SplitRequest.childIdx (|#SplitRequestMod.SplitRequest.SplitIndex| |a#12#0#0@@2| |a#12#1#0@@1|)) |a#12#0#0@@2|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |5021|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#12#0#0@@2| |a#12#1#0@@1|))
)))
(assert (forall ((|a#13#0#0@@1| Int) (|a#13#1#0@@1| Int) ) (! (= (SplitRequestMod.SplitRequest.childPivotIdx (|#SplitRequestMod.SplitRequest.SplitIndex| |a#13#0#0@@1| |a#13#1#0@@1|)) |a#13#1#0@@1|)
 :qid |SplitRequestidfy.11:18|
 :skolemid |5022|
 :pattern ( (|#SplitRequestMod.SplitRequest.SplitIndex| |a#13#0#0@@1| |a#13#1#0@@1|))
)))
(assert (forall ((d@@178 T@U) ) (!  (=> (and (= (type d@@178) DatatypeTypeType) (|$IsA#SplitRequestMod.SplitRequest| d@@178)) (or (SplitRequestMod.SplitRequest.SplitLeaf_q d@@178) (SplitRequestMod.SplitRequest.SplitIndex_q d@@178)))
 :qid |unknown.0:0|
 :skolemid |5023|
 :pattern ( (|$IsA#SplitRequestMod.SplitRequest| d@@178))
)))
(assert (forall ((d@@179 T@U) ) (!  (=> (and (= (type d@@179) DatatypeTypeType) ($Is d@@179 Tclass.SplitRequestMod.SplitRequest)) (or (SplitRequestMod.SplitRequest.SplitLeaf_q d@@179) (SplitRequestMod.SplitRequest.SplitIndex_q d@@179)))
 :qid |unknown.0:0|
 :skolemid |5024|
 :pattern ( (SplitRequestMod.SplitRequest.SplitIndex_q d@@179) ($Is d@@179 Tclass.SplitRequestMod.SplitRequest))
 :pattern ( (SplitRequestMod.SplitRequest.SplitLeaf_q d@@179) ($Is d@@179 Tclass.SplitRequestMod.SplitRequest))
)))
(assert (forall ((a@@173 T@U) (b@@122 T@U) ) (!  (=> (and (and (= (type a@@173) DatatypeTypeType) (= (type b@@122) DatatypeTypeType)) (and (SplitRequestMod.SplitRequest.SplitLeaf_q a@@173) (SplitRequestMod.SplitRequest.SplitLeaf_q b@@122))) (= (|SplitRequestMod.SplitRequest#Equal| a@@173 b@@122)  (and (= (SplitRequestMod.SplitRequest.childIdx a@@173) (SplitRequestMod.SplitRequest.childIdx b@@122)) (|Seq#Equal| (SplitRequestMod.SplitRequest.splitKey a@@173) (SplitRequestMod.SplitRequest.splitKey b@@122)))))
 :qid |unknown.0:0|
 :skolemid |5025|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@173 b@@122) (SplitRequestMod.SplitRequest.SplitLeaf_q a@@173))
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@173 b@@122) (SplitRequestMod.SplitRequest.SplitLeaf_q b@@122))
)))
(assert (forall ((a@@174 T@U) (b@@123 T@U) ) (!  (=> (and (and (= (type a@@174) DatatypeTypeType) (= (type b@@123) DatatypeTypeType)) (and (SplitRequestMod.SplitRequest.SplitIndex_q a@@174) (SplitRequestMod.SplitRequest.SplitIndex_q b@@123))) (= (|SplitRequestMod.SplitRequest#Equal| a@@174 b@@123)  (and (= (SplitRequestMod.SplitRequest.childIdx a@@174) (SplitRequestMod.SplitRequest.childIdx b@@123)) (= (SplitRequestMod.SplitRequest.childPivotIdx a@@174) (SplitRequestMod.SplitRequest.childPivotIdx b@@123)))))
 :qid |unknown.0:0|
 :skolemid |5026|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@174 b@@123) (SplitRequestMod.SplitRequest.SplitIndex_q a@@174))
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@174 b@@123) (SplitRequestMod.SplitRequest.SplitIndex_q b@@123))
)))
(assert (forall ((a@@175 T@U) (b@@124 T@U) ) (!  (=> (and (= (type a@@175) DatatypeTypeType) (= (type b@@124) DatatypeTypeType)) (= (|SplitRequestMod.SplitRequest#Equal| a@@175 b@@124) (= a@@175 b@@124)))
 :qid |unknown.0:0|
 :skolemid |5027|
 :pattern ( (|SplitRequestMod.SplitRequest#Equal| a@@175 b@@124))
)))
(assert (= (type Tclass.SplitRequestMod.__default) TyType))
(assert (= (Tag Tclass.SplitRequestMod.__default) Tagclass.SplitRequestMod.__default))
(assert (= (TagFamily Tclass.SplitRequestMod.__default) tytagFamily$_default))
(assert (forall ((bx@@171 T@U) ) (!  (=> (and (= (type bx@@171) BoxType) ($IsBox bx@@171 Tclass.SplitRequestMod.__default)) (and (= ($Box ($Unbox refType bx@@171)) bx@@171) ($Is ($Unbox refType bx@@171) Tclass.SplitRequestMod.__default)))
 :qid |unknown.0:0|
 :skolemid |5028|
 :pattern ( ($IsBox bx@@171 Tclass.SplitRequestMod.__default))
)))
(assert (forall (($o@@69 T@U) ) (!  (=> (= (type $o@@69) refType) (= ($Is $o@@69 Tclass.SplitRequestMod.__default)  (or (= $o@@69 null) (= (dtype $o@@69) Tclass.SplitRequestMod.__default))))
 :qid |unknown.0:0|
 :skolemid |5029|
 :pattern ( ($Is $o@@69 Tclass.SplitRequestMod.__default))
)))
(assert (forall (($o@@70 T@U) ($h@@179 T@U) ) (!  (=> (and (= (type $o@@70) refType) (= (type $h@@179) (MapType0Type refType MapType1Type))) (= ($IsAlloc $o@@70 Tclass.SplitRequestMod.__default $h@@179)  (or (= $o@@70 null) (U_2_bool (MapType1Select (MapType0Select $h@@179 $o@@70) alloc)))))
 :qid |unknown.0:0|
 :skolemid |5030|
 :pattern ( ($IsAlloc $o@@70 Tclass.SplitRequestMod.__default $h@@179))
)))
(assert  (and (and (and (and (and (and (and (forall ((arg0@@655 T@T) (arg1@@349 T@T) ) (! (= (Ctor (MapType6Type arg0@@655 arg1@@349)) 28)
 :qid |ctor:MapType6Type|
)) (forall ((arg0@@656 T@T) (arg1@@350 T@T) ) (! (= (MapType6TypeInv0 (MapType6Type arg0@@656 arg1@@350)) arg0@@656)
 :qid |typeInv:MapType6TypeInv0|
 :pattern ( (MapType6Type arg0@@656 arg1@@350))
))) (forall ((arg0@@657 T@T) (arg1@@351 T@T) ) (! (= (MapType6TypeInv1 (MapType6Type arg0@@657 arg1@@351)) arg1@@351)
 :qid |typeInv:MapType6TypeInv1|
 :pattern ( (MapType6Type arg0@@657 arg1@@351))
))) (forall ((arg0@@658 T@U) (arg1@@352 T@U) (arg2@@172 T@U) ) (! (let ((aVar1@@6 (MapType6TypeInv1 (type arg0@@658))))
(= (type (MapType6Select arg0@@658 arg1@@352 arg2@@172)) aVar1@@6))
 :qid |funType:MapType6Select|
 :pattern ( (MapType6Select arg0@@658 arg1@@352 arg2@@172))
))) (forall ((arg0@@659 T@U) (arg1@@353 T@U) (arg2@@173 T@U) (arg3@@100 T@U) ) (! (let ((aVar1@@7 (type arg3@@100)))
(let ((aVar0@@4 (type arg1@@353)))
(= (type (MapType6Store arg0@@659 arg1@@353 arg2@@173 arg3@@100)) (MapType6Type aVar0@@4 aVar1@@7))))
 :qid |funType:MapType6Store|
 :pattern ( (MapType6Store arg0@@659 arg1@@353 arg2@@173 arg3@@100))
))) (forall ((m@@71 T@U) (x0@@27 T@U) (x1@@21 T@U) (val@@28 T@U) ) (! (let ((aVar1@@8 (MapType6TypeInv1 (type m@@71))))
 (=> (= (type val@@28) aVar1@@8) (= (MapType6Select (MapType6Store m@@71 x0@@27 x1@@21 val@@28) x0@@27 x1@@21) val@@28)))
 :qid |mapAx0:MapType6Select|
 :weight 0
))) (and (and (forall ((val@@29 T@U) (m@@72 T@U) (x0@@28 T@U) (x1@@22 T@U) (y0@@21 T@U) (y1@@17 T@U) ) (!  (or (= x0@@28 y0@@21) (= (MapType6Select (MapType6Store m@@72 x0@@28 x1@@22 val@@29) y0@@21 y1@@17) (MapType6Select m@@72 y0@@21 y1@@17)))
 :qid |mapAx1:MapType6Select:0|
 :weight 0
)) (forall ((val@@30 T@U) (m@@73 T@U) (x0@@29 T@U) (x1@@23 T@U) (y0@@22 T@U) (y1@@18 T@U) ) (!  (or (= x1@@23 y1@@18) (= (MapType6Select (MapType6Store m@@73 x0@@29 x1@@23 val@@30) y0@@22 y1@@18) (MapType6Select m@@73 y0@@22 y1@@18)))
 :qid |mapAx1:MapType6Select:1|
 :weight 0
))) (forall ((val@@31 T@U) (m@@74 T@U) (x0@@30 T@U) (x1@@24 T@U) (y0@@23 T@U) (y1@@19 T@U) ) (!  (or true (= (MapType6Select (MapType6Store m@@74 x0@@30 x1@@24 val@@31) y0@@23 y1@@19) (MapType6Select m@@74 y0@@23 y1@@19)))
 :qid |mapAx2:MapType6Select|
 :weight 0
)))) (forall ((arg0@@660 T@U) (arg1@@354 T@U) (arg2@@174 T@U) (arg3@@101 Bool) ) (! (= (type (|lambda#0| arg0@@660 arg1@@354 arg2@@174 arg3@@101)) (MapType6Type refType boolType))
 :qid |funType:lambda#0|
 :pattern ( (|lambda#0| arg0@@660 arg1@@354 arg2@@174 arg3@@101))
))))
(assert (forall ((|l#0@@21| T@U) (|l#1| T@U) (|l#2| T@U) (|l#3| Bool) ($o@@71 T@U) ($f@@1 T@U) ) (! (let ((alpha@@8 (FieldTypeInv0 (type $f@@1))))
 (=> (and (and (and (and (= (type |l#0@@21|) refType) (= (type |l#1|) (MapType0Type refType MapType1Type))) (= (type |l#2|) (FieldType boolType))) (= (type $o@@71) refType)) (= (type $f@@1) (FieldType alpha@@8))) (= (U_2_bool (MapType6Select (|lambda#0| |l#0@@21| |l#1| |l#2| |l#3|) $o@@71 $f@@1))  (=> (and (not (= $o@@71 |l#0@@21|)) (U_2_bool (MapType1Select (MapType0Select |l#1| $o@@71) |l#2|))) |l#3|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5031|
 :pattern ( (MapType6Select (|lambda#0| |l#0@@21| |l#1| |l#2| |l#3|) $o@@71 $f@@1))
)))
(assert (forall ((arg0@@661 T@U) (arg1@@355 T@U) (arg2@@175 T@U) (arg3@@102 Bool) ) (! (= (type (|lambda#1| arg0@@661 arg1@@355 arg2@@175 arg3@@102)) (MapType6Type refType boolType))
 :qid |funType:lambda#1|
 :pattern ( (|lambda#1| arg0@@661 arg1@@355 arg2@@175 arg3@@102))
)))
(assert (forall ((|l#0@@22| T@U) (|l#1@@0| T@U) (|l#2@@0| T@U) (|l#3@@0| Bool) ($o@@72 T@U) ($f@@2 T@U) ) (! (let ((alpha@@9 (FieldTypeInv0 (type $f@@2))))
 (=> (and (and (and (and (= (type |l#0@@22|) refType) (= (type |l#1@@0|) (MapType0Type refType MapType1Type))) (= (type |l#2@@0|) (FieldType boolType))) (= (type $o@@72) refType)) (= (type $f@@2) (FieldType alpha@@9))) (= (U_2_bool (MapType6Select (|lambda#1| |l#0@@22| |l#1@@0| |l#2@@0| |l#3@@0|) $o@@72 $f@@2))  (=> (and (not (= $o@@72 |l#0@@22|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@0| $o@@72) |l#2@@0|))) |l#3@@0|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5032|
 :pattern ( (MapType6Select (|lambda#1| |l#0@@22| |l#1@@0| |l#2@@0| |l#3@@0|) $o@@72 $f@@2))
)))
(assert (forall ((arg0@@662 T@U) (arg1@@356 T@U) (arg2@@176 T@U) (arg3@@103 Bool) ) (! (= (type (|lambda#2| arg0@@662 arg1@@356 arg2@@176 arg3@@103)) (MapType6Type refType boolType))
 :qid |funType:lambda#2|
 :pattern ( (|lambda#2| arg0@@662 arg1@@356 arg2@@176 arg3@@103))
)))
(assert (forall ((|l#0@@23| T@U) (|l#1@@1| T@U) (|l#2@@1| T@U) (|l#3@@1| Bool) ($o@@73 T@U) ($f@@3 T@U) ) (! (let ((alpha@@10 (FieldTypeInv0 (type $f@@3))))
 (=> (and (and (and (and (= (type |l#0@@23|) refType) (= (type |l#1@@1|) (MapType0Type refType MapType1Type))) (= (type |l#2@@1|) (FieldType boolType))) (= (type $o@@73) refType)) (= (type $f@@3) (FieldType alpha@@10))) (= (U_2_bool (MapType6Select (|lambda#2| |l#0@@23| |l#1@@1| |l#2@@1| |l#3@@1|) $o@@73 $f@@3))  (=> (and (not (= $o@@73 |l#0@@23|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@1| $o@@73) |l#2@@1|))) |l#3@@1|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5033|
 :pattern ( (MapType6Select (|lambda#2| |l#0@@23| |l#1@@1| |l#2@@1| |l#3@@1|) $o@@73 $f@@3))
)))
(assert (forall ((arg0@@663 T@U) (arg1@@357 T@U) (arg2@@177 T@U) (arg3@@104 Bool) ) (! (= (type (|lambda#3| arg0@@663 arg1@@357 arg2@@177 arg3@@104)) (MapType6Type refType boolType))
 :qid |funType:lambda#3|
 :pattern ( (|lambda#3| arg0@@663 arg1@@357 arg2@@177 arg3@@104))
)))
(assert (forall ((|l#0@@24| T@U) (|l#1@@2| T@U) (|l#2@@2| T@U) (|l#3@@2| Bool) ($o@@74 T@U) ($f@@4 T@U) ) (! (let ((alpha@@11 (FieldTypeInv0 (type $f@@4))))
 (=> (and (and (and (and (= (type |l#0@@24|) refType) (= (type |l#1@@2|) (MapType0Type refType MapType1Type))) (= (type |l#2@@2|) (FieldType boolType))) (= (type $o@@74) refType)) (= (type $f@@4) (FieldType alpha@@11))) (= (U_2_bool (MapType6Select (|lambda#3| |l#0@@24| |l#1@@2| |l#2@@2| |l#3@@2|) $o@@74 $f@@4))  (=> (and (not (= $o@@74 |l#0@@24|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@2| $o@@74) |l#2@@2|))) |l#3@@2|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5034|
 :pattern ( (MapType6Select (|lambda#3| |l#0@@24| |l#1@@2| |l#2@@2| |l#3@@2|) $o@@74 $f@@4))
)))
(assert (forall ((arg0@@664 T@U) (arg1@@358 T@U) (arg2@@178 T@U) (arg3@@105 Bool) ) (! (= (type (|lambda#4| arg0@@664 arg1@@358 arg2@@178 arg3@@105)) (MapType6Type refType boolType))
 :qid |funType:lambda#4|
 :pattern ( (|lambda#4| arg0@@664 arg1@@358 arg2@@178 arg3@@105))
)))
(assert (forall ((|l#0@@25| T@U) (|l#1@@3| T@U) (|l#2@@3| T@U) (|l#3@@3| Bool) ($o@@75 T@U) ($f@@5 T@U) ) (! (let ((alpha@@12 (FieldTypeInv0 (type $f@@5))))
 (=> (and (and (and (and (= (type |l#0@@25|) refType) (= (type |l#1@@3|) (MapType0Type refType MapType1Type))) (= (type |l#2@@3|) (FieldType boolType))) (= (type $o@@75) refType)) (= (type $f@@5) (FieldType alpha@@12))) (= (U_2_bool (MapType6Select (|lambda#4| |l#0@@25| |l#1@@3| |l#2@@3| |l#3@@3|) $o@@75 $f@@5))  (=> (and (not (= $o@@75 |l#0@@25|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@3| $o@@75) |l#2@@3|))) |l#3@@3|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5035|
 :pattern ( (MapType6Select (|lambda#4| |l#0@@25| |l#1@@3| |l#2@@3| |l#3@@3|) $o@@75 $f@@5))
)))
(assert (forall ((arg0@@665 T@U) (arg1@@359 T@U) (arg2@@179 T@U) (arg3@@106 Bool) ) (! (= (type (|lambda#5| arg0@@665 arg1@@359 arg2@@179 arg3@@106)) (MapType6Type refType boolType))
 :qid |funType:lambda#5|
 :pattern ( (|lambda#5| arg0@@665 arg1@@359 arg2@@179 arg3@@106))
)))
(assert (forall ((|l#0@@26| T@U) (|l#1@@4| T@U) (|l#2@@4| T@U) (|l#3@@4| Bool) ($o@@76 T@U) ($f@@6 T@U) ) (! (let ((alpha@@13 (FieldTypeInv0 (type $f@@6))))
 (=> (and (and (and (and (= (type |l#0@@26|) refType) (= (type |l#1@@4|) (MapType0Type refType MapType1Type))) (= (type |l#2@@4|) (FieldType boolType))) (= (type $o@@76) refType)) (= (type $f@@6) (FieldType alpha@@13))) (= (U_2_bool (MapType6Select (|lambda#5| |l#0@@26| |l#1@@4| |l#2@@4| |l#3@@4|) $o@@76 $f@@6))  (=> (and (not (= $o@@76 |l#0@@26|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@4| $o@@76) |l#2@@4|))) |l#3@@4|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5036|
 :pattern ( (MapType6Select (|lambda#5| |l#0@@26| |l#1@@4| |l#2@@4| |l#3@@4|) $o@@76 $f@@6))
)))
(assert (forall ((arg0@@666 T@U) (arg1@@360 T@U) (arg2@@180 T@U) (arg3@@107 Bool) ) (! (= (type (|lambda#6| arg0@@666 arg1@@360 arg2@@180 arg3@@107)) (MapType6Type refType boolType))
 :qid |funType:lambda#6|
 :pattern ( (|lambda#6| arg0@@666 arg1@@360 arg2@@180 arg3@@107))
)))
(assert (forall ((|l#0@@27| T@U) (|l#1@@5| T@U) (|l#2@@5| T@U) (|l#3@@5| Bool) ($o@@77 T@U) ($f@@7 T@U) ) (! (let ((alpha@@14 (FieldTypeInv0 (type $f@@7))))
 (=> (and (and (and (and (= (type |l#0@@27|) refType) (= (type |l#1@@5|) (MapType0Type refType MapType1Type))) (= (type |l#2@@5|) (FieldType boolType))) (= (type $o@@77) refType)) (= (type $f@@7) (FieldType alpha@@14))) (= (U_2_bool (MapType6Select (|lambda#6| |l#0@@27| |l#1@@5| |l#2@@5| |l#3@@5|) $o@@77 $f@@7))  (=> (and (not (= $o@@77 |l#0@@27|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@5| $o@@77) |l#2@@5|))) |l#3@@5|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5037|
 :pattern ( (MapType6Select (|lambda#6| |l#0@@27| |l#1@@5| |l#2@@5| |l#3@@5|) $o@@77 $f@@7))
)))
(assert (forall ((arg0@@667 T@U) (arg1@@361 T@U) (arg2@@181 T@U) (arg3@@108 Bool) ) (! (= (type (|lambda#7| arg0@@667 arg1@@361 arg2@@181 arg3@@108)) (MapType6Type refType boolType))
 :qid |funType:lambda#7|
 :pattern ( (|lambda#7| arg0@@667 arg1@@361 arg2@@181 arg3@@108))
)))
(assert (forall ((|l#0@@28| T@U) (|l#1@@6| T@U) (|l#2@@6| T@U) (|l#3@@6| Bool) ($o@@78 T@U) ($f@@8 T@U) ) (! (let ((alpha@@15 (FieldTypeInv0 (type $f@@8))))
 (=> (and (and (and (and (= (type |l#0@@28|) refType) (= (type |l#1@@6|) (MapType0Type refType MapType1Type))) (= (type |l#2@@6|) (FieldType boolType))) (= (type $o@@78) refType)) (= (type $f@@8) (FieldType alpha@@15))) (= (U_2_bool (MapType6Select (|lambda#7| |l#0@@28| |l#1@@6| |l#2@@6| |l#3@@6|) $o@@78 $f@@8))  (=> (and (not (= $o@@78 |l#0@@28|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@6| $o@@78) |l#2@@6|))) |l#3@@6|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5038|
 :pattern ( (MapType6Select (|lambda#7| |l#0@@28| |l#1@@6| |l#2@@6| |l#3@@6|) $o@@78 $f@@8))
)))
(assert (forall ((arg0@@668 T@U) (arg1@@362 T@U) (arg2@@182 T@U) (arg3@@109 Bool) ) (! (= (type (|lambda#8| arg0@@668 arg1@@362 arg2@@182 arg3@@109)) (MapType6Type refType boolType))
 :qid |funType:lambda#8|
 :pattern ( (|lambda#8| arg0@@668 arg1@@362 arg2@@182 arg3@@109))
)))
(assert (forall ((|l#0@@29| T@U) (|l#1@@7| T@U) (|l#2@@7| T@U) (|l#3@@7| Bool) ($o@@79 T@U) ($f@@9 T@U) ) (! (let ((alpha@@16 (FieldTypeInv0 (type $f@@9))))
 (=> (and (and (and (and (= (type |l#0@@29|) refType) (= (type |l#1@@7|) (MapType0Type refType MapType1Type))) (= (type |l#2@@7|) (FieldType boolType))) (= (type $o@@79) refType)) (= (type $f@@9) (FieldType alpha@@16))) (= (U_2_bool (MapType6Select (|lambda#8| |l#0@@29| |l#1@@7| |l#2@@7| |l#3@@7|) $o@@79 $f@@9))  (=> (and (not (= $o@@79 |l#0@@29|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@7| $o@@79) |l#2@@7|))) |l#3@@7|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5039|
 :pattern ( (MapType6Select (|lambda#8| |l#0@@29| |l#1@@7| |l#2@@7| |l#3@@7|) $o@@79 $f@@9))
)))
(assert (forall ((arg0@@669 T@U) (arg1@@363 T@U) (arg2@@183 T@U) (arg3@@110 Bool) ) (! (= (type (|lambda#9| arg0@@669 arg1@@363 arg2@@183 arg3@@110)) (MapType6Type refType boolType))
 :qid |funType:lambda#9|
 :pattern ( (|lambda#9| arg0@@669 arg1@@363 arg2@@183 arg3@@110))
)))
(assert (forall ((|l#0@@30| T@U) (|l#1@@8| T@U) (|l#2@@8| T@U) (|l#3@@8| Bool) ($o@@80 T@U) ($f@@10 T@U) ) (! (let ((alpha@@17 (FieldTypeInv0 (type $f@@10))))
 (=> (and (and (and (and (= (type |l#0@@30|) refType) (= (type |l#1@@8|) (MapType0Type refType MapType1Type))) (= (type |l#2@@8|) (FieldType boolType))) (= (type $o@@80) refType)) (= (type $f@@10) (FieldType alpha@@17))) (= (U_2_bool (MapType6Select (|lambda#9| |l#0@@30| |l#1@@8| |l#2@@8| |l#3@@8|) $o@@80 $f@@10))  (=> (and (not (= $o@@80 |l#0@@30|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@8| $o@@80) |l#2@@8|))) |l#3@@8|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5040|
 :pattern ( (MapType6Select (|lambda#9| |l#0@@30| |l#1@@8| |l#2@@8| |l#3@@8|) $o@@80 $f@@10))
)))
(assert (forall ((arg0@@670 T@U) (arg1@@364 T@U) (arg2@@184 T@U) (arg3@@111 Bool) ) (! (= (type (|lambda#10| arg0@@670 arg1@@364 arg2@@184 arg3@@111)) (MapType6Type refType boolType))
 :qid |funType:lambda#10|
 :pattern ( (|lambda#10| arg0@@670 arg1@@364 arg2@@184 arg3@@111))
)))
(assert (forall ((|l#0@@31| T@U) (|l#1@@9| T@U) (|l#2@@9| T@U) (|l#3@@9| Bool) ($o@@81 T@U) ($f@@11 T@U) ) (! (let ((alpha@@18 (FieldTypeInv0 (type $f@@11))))
 (=> (and (and (and (and (= (type |l#0@@31|) refType) (= (type |l#1@@9|) (MapType0Type refType MapType1Type))) (= (type |l#2@@9|) (FieldType boolType))) (= (type $o@@81) refType)) (= (type $f@@11) (FieldType alpha@@18))) (= (U_2_bool (MapType6Select (|lambda#10| |l#0@@31| |l#1@@9| |l#2@@9| |l#3@@9|) $o@@81 $f@@11))  (=> (and (not (= $o@@81 |l#0@@31|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@9| $o@@81) |l#2@@9|))) |l#3@@9|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5041|
 :pattern ( (MapType6Select (|lambda#10| |l#0@@31| |l#1@@9| |l#2@@9| |l#3@@9|) $o@@81 $f@@11))
)))
(assert (forall ((arg0@@671 T@U) (arg1@@365 T@U) (arg2@@185 T@U) (arg3@@112 Bool) ) (! (= (type (|lambda#11| arg0@@671 arg1@@365 arg2@@185 arg3@@112)) (MapType6Type refType boolType))
 :qid |funType:lambda#11|
 :pattern ( (|lambda#11| arg0@@671 arg1@@365 arg2@@185 arg3@@112))
)))
(assert (forall ((|l#0@@32| T@U) (|l#1@@10| T@U) (|l#2@@10| T@U) (|l#3@@10| Bool) ($o@@82 T@U) ($f@@12 T@U) ) (! (let ((alpha@@19 (FieldTypeInv0 (type $f@@12))))
 (=> (and (and (and (and (= (type |l#0@@32|) refType) (= (type |l#1@@10|) (MapType0Type refType MapType1Type))) (= (type |l#2@@10|) (FieldType boolType))) (= (type $o@@82) refType)) (= (type $f@@12) (FieldType alpha@@19))) (= (U_2_bool (MapType6Select (|lambda#11| |l#0@@32| |l#1@@10| |l#2@@10| |l#3@@10|) $o@@82 $f@@12))  (=> (and (not (= $o@@82 |l#0@@32|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@10| $o@@82) |l#2@@10|))) |l#3@@10|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5042|
 :pattern ( (MapType6Select (|lambda#11| |l#0@@32| |l#1@@10| |l#2@@10| |l#3@@10|) $o@@82 $f@@12))
)))
(assert (forall ((arg0@@672 T@U) (arg1@@366 T@U) (arg2@@186 T@U) (arg3@@113 Bool) ) (! (= (type (|lambda#12| arg0@@672 arg1@@366 arg2@@186 arg3@@113)) (MapType6Type refType boolType))
 :qid |funType:lambda#12|
 :pattern ( (|lambda#12| arg0@@672 arg1@@366 arg2@@186 arg3@@113))
)))
(assert (forall ((|l#0@@33| T@U) (|l#1@@11| T@U) (|l#2@@11| T@U) (|l#3@@11| Bool) ($o@@83 T@U) ($f@@13 T@U) ) (! (let ((alpha@@20 (FieldTypeInv0 (type $f@@13))))
 (=> (and (and (and (and (= (type |l#0@@33|) refType) (= (type |l#1@@11|) (MapType0Type refType MapType1Type))) (= (type |l#2@@11|) (FieldType boolType))) (= (type $o@@83) refType)) (= (type $f@@13) (FieldType alpha@@20))) (= (U_2_bool (MapType6Select (|lambda#12| |l#0@@33| |l#1@@11| |l#2@@11| |l#3@@11|) $o@@83 $f@@13))  (=> (and (not (= $o@@83 |l#0@@33|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@11| $o@@83) |l#2@@11|))) |l#3@@11|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5043|
 :pattern ( (MapType6Select (|lambda#12| |l#0@@33| |l#1@@11| |l#2@@11| |l#3@@11|) $o@@83 $f@@13))
)))
(assert (forall ((arg0@@673 T@U) (arg1@@367 T@U) (arg2@@187 T@U) (arg3@@114 Bool) ) (! (= (type (|lambda#13| arg0@@673 arg1@@367 arg2@@187 arg3@@114)) (MapType6Type refType boolType))
 :qid |funType:lambda#13|
 :pattern ( (|lambda#13| arg0@@673 arg1@@367 arg2@@187 arg3@@114))
)))
(assert (forall ((|l#0@@34| T@U) (|l#1@@12| T@U) (|l#2@@12| T@U) (|l#3@@12| Bool) ($o@@84 T@U) ($f@@14 T@U) ) (! (let ((alpha@@21 (FieldTypeInv0 (type $f@@14))))
 (=> (and (and (and (and (= (type |l#0@@34|) refType) (= (type |l#1@@12|) (MapType0Type refType MapType1Type))) (= (type |l#2@@12|) (FieldType boolType))) (= (type $o@@84) refType)) (= (type $f@@14) (FieldType alpha@@21))) (= (U_2_bool (MapType6Select (|lambda#13| |l#0@@34| |l#1@@12| |l#2@@12| |l#3@@12|) $o@@84 $f@@14))  (=> (and (not (= $o@@84 |l#0@@34|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@12| $o@@84) |l#2@@12|))) |l#3@@12|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5044|
 :pattern ( (MapType6Select (|lambda#13| |l#0@@34| |l#1@@12| |l#2@@12| |l#3@@12|) $o@@84 $f@@14))
)))
(assert (forall ((arg0@@674 T@U) (arg1@@368 T@U) (arg2@@188 T@U) (arg3@@115 Bool) ) (! (= (type (|lambda#14| arg0@@674 arg1@@368 arg2@@188 arg3@@115)) (MapType6Type refType boolType))
 :qid |funType:lambda#14|
 :pattern ( (|lambda#14| arg0@@674 arg1@@368 arg2@@188 arg3@@115))
)))
(assert (forall ((|l#0@@35| T@U) (|l#1@@13| T@U) (|l#2@@13| T@U) (|l#3@@13| Bool) ($o@@85 T@U) ($f@@15 T@U) ) (! (let ((alpha@@22 (FieldTypeInv0 (type $f@@15))))
 (=> (and (and (and (and (= (type |l#0@@35|) refType) (= (type |l#1@@13|) (MapType0Type refType MapType1Type))) (= (type |l#2@@13|) (FieldType boolType))) (= (type $o@@85) refType)) (= (type $f@@15) (FieldType alpha@@22))) (= (U_2_bool (MapType6Select (|lambda#14| |l#0@@35| |l#1@@13| |l#2@@13| |l#3@@13|) $o@@85 $f@@15))  (=> (and (not (= $o@@85 |l#0@@35|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@13| $o@@85) |l#2@@13|))) |l#3@@13|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5045|
 :pattern ( (MapType6Select (|lambda#14| |l#0@@35| |l#1@@13| |l#2@@13| |l#3@@13|) $o@@85 $f@@15))
)))
(assert (forall ((arg0@@675 T@U) (arg1@@369 T@U) (arg2@@189 T@U) (arg3@@116 Bool) ) (! (= (type (|lambda#15| arg0@@675 arg1@@369 arg2@@189 arg3@@116)) (MapType6Type refType boolType))
 :qid |funType:lambda#15|
 :pattern ( (|lambda#15| arg0@@675 arg1@@369 arg2@@189 arg3@@116))
)))
(assert (forall ((|l#0@@36| T@U) (|l#1@@14| T@U) (|l#2@@14| T@U) (|l#3@@14| Bool) ($o@@86 T@U) ($f@@16 T@U) ) (! (let ((alpha@@23 (FieldTypeInv0 (type $f@@16))))
 (=> (and (and (and (and (= (type |l#0@@36|) refType) (= (type |l#1@@14|) (MapType0Type refType MapType1Type))) (= (type |l#2@@14|) (FieldType boolType))) (= (type $o@@86) refType)) (= (type $f@@16) (FieldType alpha@@23))) (= (U_2_bool (MapType6Select (|lambda#15| |l#0@@36| |l#1@@14| |l#2@@14| |l#3@@14|) $o@@86 $f@@16))  (=> (and (not (= $o@@86 |l#0@@36|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@14| $o@@86) |l#2@@14|))) |l#3@@14|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5046|
 :pattern ( (MapType6Select (|lambda#15| |l#0@@36| |l#1@@14| |l#2@@14| |l#3@@14|) $o@@86 $f@@16))
)))
(assert (forall ((arg0@@676 T@U) (arg1@@370 T@U) (arg2@@190 T@U) (arg3@@117 Bool) ) (! (= (type (|lambda#16| arg0@@676 arg1@@370 arg2@@190 arg3@@117)) (MapType6Type refType boolType))
 :qid |funType:lambda#16|
 :pattern ( (|lambda#16| arg0@@676 arg1@@370 arg2@@190 arg3@@117))
)))
(assert (forall ((|l#0@@37| T@U) (|l#1@@15| T@U) (|l#2@@15| T@U) (|l#3@@15| Bool) ($o@@87 T@U) ($f@@17 T@U) ) (! (let ((alpha@@24 (FieldTypeInv0 (type $f@@17))))
 (=> (and (and (and (and (= (type |l#0@@37|) refType) (= (type |l#1@@15|) (MapType0Type refType MapType1Type))) (= (type |l#2@@15|) (FieldType boolType))) (= (type $o@@87) refType)) (= (type $f@@17) (FieldType alpha@@24))) (= (U_2_bool (MapType6Select (|lambda#16| |l#0@@37| |l#1@@15| |l#2@@15| |l#3@@15|) $o@@87 $f@@17))  (=> (and (not (= $o@@87 |l#0@@37|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@15| $o@@87) |l#2@@15|))) |l#3@@15|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5047|
 :pattern ( (MapType6Select (|lambda#16| |l#0@@37| |l#1@@15| |l#2@@15| |l#3@@15|) $o@@87 $f@@17))
)))
(assert (forall ((arg0@@677 T@U) (arg1@@371 T@U) (arg2@@191 T@U) (arg3@@118 Bool) ) (! (= (type (|lambda#17| arg0@@677 arg1@@371 arg2@@191 arg3@@118)) (MapType6Type refType boolType))
 :qid |funType:lambda#17|
 :pattern ( (|lambda#17| arg0@@677 arg1@@371 arg2@@191 arg3@@118))
)))
(assert (forall ((|l#0@@38| T@U) (|l#1@@16| T@U) (|l#2@@16| T@U) (|l#3@@16| Bool) ($o@@88 T@U) ($f@@18 T@U) ) (! (let ((alpha@@25 (FieldTypeInv0 (type $f@@18))))
 (=> (and (and (and (and (= (type |l#0@@38|) refType) (= (type |l#1@@16|) (MapType0Type refType MapType1Type))) (= (type |l#2@@16|) (FieldType boolType))) (= (type $o@@88) refType)) (= (type $f@@18) (FieldType alpha@@25))) (= (U_2_bool (MapType6Select (|lambda#17| |l#0@@38| |l#1@@16| |l#2@@16| |l#3@@16|) $o@@88 $f@@18))  (=> (and (not (= $o@@88 |l#0@@38|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@16| $o@@88) |l#2@@16|))) |l#3@@16|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5048|
 :pattern ( (MapType6Select (|lambda#17| |l#0@@38| |l#1@@16| |l#2@@16| |l#3@@16|) $o@@88 $f@@18))
)))
(assert (forall ((arg0@@678 T@U) (arg1@@372 T@U) (arg2@@192 T@U) (arg3@@119 Bool) ) (! (= (type (|lambda#18| arg0@@678 arg1@@372 arg2@@192 arg3@@119)) (MapType6Type refType boolType))
 :qid |funType:lambda#18|
 :pattern ( (|lambda#18| arg0@@678 arg1@@372 arg2@@192 arg3@@119))
)))
(assert (forall ((|l#0@@39| T@U) (|l#1@@17| T@U) (|l#2@@17| T@U) (|l#3@@17| Bool) ($o@@89 T@U) ($f@@19 T@U) ) (! (let ((alpha@@26 (FieldTypeInv0 (type $f@@19))))
 (=> (and (and (and (and (= (type |l#0@@39|) refType) (= (type |l#1@@17|) (MapType0Type refType MapType1Type))) (= (type |l#2@@17|) (FieldType boolType))) (= (type $o@@89) refType)) (= (type $f@@19) (FieldType alpha@@26))) (= (U_2_bool (MapType6Select (|lambda#18| |l#0@@39| |l#1@@17| |l#2@@17| |l#3@@17|) $o@@89 $f@@19))  (=> (and (not (= $o@@89 |l#0@@39|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@17| $o@@89) |l#2@@17|))) |l#3@@17|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5049|
 :pattern ( (MapType6Select (|lambda#18| |l#0@@39| |l#1@@17| |l#2@@17| |l#3@@17|) $o@@89 $f@@19))
)))
(assert (forall ((arg0@@679 T@U) (arg1@@373 T@U) (arg2@@193 T@U) (arg3@@120 Bool) ) (! (= (type (|lambda#19| arg0@@679 arg1@@373 arg2@@193 arg3@@120)) (MapType6Type refType boolType))
 :qid |funType:lambda#19|
 :pattern ( (|lambda#19| arg0@@679 arg1@@373 arg2@@193 arg3@@120))
)))
(assert (forall ((|l#0@@40| T@U) (|l#1@@18| T@U) (|l#2@@18| T@U) (|l#3@@18| Bool) ($o@@90 T@U) ($f@@20 T@U) ) (! (let ((alpha@@27 (FieldTypeInv0 (type $f@@20))))
 (=> (and (and (and (and (= (type |l#0@@40|) refType) (= (type |l#1@@18|) (MapType0Type refType MapType1Type))) (= (type |l#2@@18|) (FieldType boolType))) (= (type $o@@90) refType)) (= (type $f@@20) (FieldType alpha@@27))) (= (U_2_bool (MapType6Select (|lambda#19| |l#0@@40| |l#1@@18| |l#2@@18| |l#3@@18|) $o@@90 $f@@20))  (=> (and (not (= $o@@90 |l#0@@40|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@18| $o@@90) |l#2@@18|))) |l#3@@18|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5050|
 :pattern ( (MapType6Select (|lambda#19| |l#0@@40| |l#1@@18| |l#2@@18| |l#3@@18|) $o@@90 $f@@20))
)))
(assert (forall ((arg0@@680 T@U) (arg1@@374 T@U) (arg2@@194 T@U) (arg3@@121 Bool) ) (! (= (type (|lambda#20| arg0@@680 arg1@@374 arg2@@194 arg3@@121)) (MapType6Type refType boolType))
 :qid |funType:lambda#20|
 :pattern ( (|lambda#20| arg0@@680 arg1@@374 arg2@@194 arg3@@121))
)))
(assert (forall ((|l#0@@41| T@U) (|l#1@@19| T@U) (|l#2@@19| T@U) (|l#3@@19| Bool) ($o@@91 T@U) ($f@@21 T@U) ) (! (let ((alpha@@28 (FieldTypeInv0 (type $f@@21))))
 (=> (and (and (and (and (= (type |l#0@@41|) refType) (= (type |l#1@@19|) (MapType0Type refType MapType1Type))) (= (type |l#2@@19|) (FieldType boolType))) (= (type $o@@91) refType)) (= (type $f@@21) (FieldType alpha@@28))) (= (U_2_bool (MapType6Select (|lambda#20| |l#0@@41| |l#1@@19| |l#2@@19| |l#3@@19|) $o@@91 $f@@21))  (=> (and (not (= $o@@91 |l#0@@41|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@19| $o@@91) |l#2@@19|))) |l#3@@19|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5051|
 :pattern ( (MapType6Select (|lambda#20| |l#0@@41| |l#1@@19| |l#2@@19| |l#3@@19|) $o@@91 $f@@21))
)))
(assert (forall ((arg0@@681 T@U) (arg1@@375 T@U) (arg2@@195 T@U) (arg3@@122 Bool) ) (! (= (type (|lambda#21| arg0@@681 arg1@@375 arg2@@195 arg3@@122)) (MapType6Type refType boolType))
 :qid |funType:lambda#21|
 :pattern ( (|lambda#21| arg0@@681 arg1@@375 arg2@@195 arg3@@122))
)))
(assert (forall ((|l#0@@42| T@U) (|l#1@@20| T@U) (|l#2@@20| T@U) (|l#3@@20| Bool) ($o@@92 T@U) ($f@@22 T@U) ) (! (let ((alpha@@29 (FieldTypeInv0 (type $f@@22))))
 (=> (and (and (and (and (= (type |l#0@@42|) refType) (= (type |l#1@@20|) (MapType0Type refType MapType1Type))) (= (type |l#2@@20|) (FieldType boolType))) (= (type $o@@92) refType)) (= (type $f@@22) (FieldType alpha@@29))) (= (U_2_bool (MapType6Select (|lambda#21| |l#0@@42| |l#1@@20| |l#2@@20| |l#3@@20|) $o@@92 $f@@22))  (=> (and (not (= $o@@92 |l#0@@42|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@20| $o@@92) |l#2@@20|))) |l#3@@20|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5052|
 :pattern ( (MapType6Select (|lambda#21| |l#0@@42| |l#1@@20| |l#2@@20| |l#3@@20|) $o@@92 $f@@22))
)))
(assert (forall ((arg0@@682 T@U) (arg1@@376 T@U) (arg2@@196 T@U) (arg3@@123 Bool) ) (! (= (type (|lambda#22| arg0@@682 arg1@@376 arg2@@196 arg3@@123)) (MapType6Type refType boolType))
 :qid |funType:lambda#22|
 :pattern ( (|lambda#22| arg0@@682 arg1@@376 arg2@@196 arg3@@123))
)))
(assert (forall ((|l#0@@43| T@U) (|l#1@@21| T@U) (|l#2@@21| T@U) (|l#3@@21| Bool) ($o@@93 T@U) ($f@@23 T@U) ) (! (let ((alpha@@30 (FieldTypeInv0 (type $f@@23))))
 (=> (and (and (and (and (= (type |l#0@@43|) refType) (= (type |l#1@@21|) (MapType0Type refType MapType1Type))) (= (type |l#2@@21|) (FieldType boolType))) (= (type $o@@93) refType)) (= (type $f@@23) (FieldType alpha@@30))) (= (U_2_bool (MapType6Select (|lambda#22| |l#0@@43| |l#1@@21| |l#2@@21| |l#3@@21|) $o@@93 $f@@23))  (=> (and (not (= $o@@93 |l#0@@43|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@21| $o@@93) |l#2@@21|))) |l#3@@21|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5053|
 :pattern ( (MapType6Select (|lambda#22| |l#0@@43| |l#1@@21| |l#2@@21| |l#3@@21|) $o@@93 $f@@23))
)))
(assert (forall ((arg0@@683 T@U) (arg1@@377 T@U) (arg2@@197 T@U) (arg3@@124 Bool) ) (! (= (type (|lambda#23| arg0@@683 arg1@@377 arg2@@197 arg3@@124)) (MapType6Type refType boolType))
 :qid |funType:lambda#23|
 :pattern ( (|lambda#23| arg0@@683 arg1@@377 arg2@@197 arg3@@124))
)))
(assert (forall ((|l#0@@44| T@U) (|l#1@@22| T@U) (|l#2@@22| T@U) (|l#3@@22| Bool) ($o@@94 T@U) ($f@@24 T@U) ) (! (let ((alpha@@31 (FieldTypeInv0 (type $f@@24))))
 (=> (and (and (and (and (= (type |l#0@@44|) refType) (= (type |l#1@@22|) (MapType0Type refType MapType1Type))) (= (type |l#2@@22|) (FieldType boolType))) (= (type $o@@94) refType)) (= (type $f@@24) (FieldType alpha@@31))) (= (U_2_bool (MapType6Select (|lambda#23| |l#0@@44| |l#1@@22| |l#2@@22| |l#3@@22|) $o@@94 $f@@24))  (=> (and (not (= $o@@94 |l#0@@44|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@22| $o@@94) |l#2@@22|))) |l#3@@22|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5054|
 :pattern ( (MapType6Select (|lambda#23| |l#0@@44| |l#1@@22| |l#2@@22| |l#3@@22|) $o@@94 $f@@24))
)))
(assert (forall ((arg0@@684 T@U) (arg1@@378 T@U) (arg2@@198 T@U) (arg3@@125 Bool) ) (! (= (type (|lambda#24| arg0@@684 arg1@@378 arg2@@198 arg3@@125)) (MapType6Type refType boolType))
 :qid |funType:lambda#24|
 :pattern ( (|lambda#24| arg0@@684 arg1@@378 arg2@@198 arg3@@125))
)))
(assert (forall ((|l#0@@45| T@U) (|l#1@@23| T@U) (|l#2@@23| T@U) (|l#3@@23| Bool) ($o@@95 T@U) ($f@@25 T@U) ) (! (let ((alpha@@32 (FieldTypeInv0 (type $f@@25))))
 (=> (and (and (and (and (= (type |l#0@@45|) refType) (= (type |l#1@@23|) (MapType0Type refType MapType1Type))) (= (type |l#2@@23|) (FieldType boolType))) (= (type $o@@95) refType)) (= (type $f@@25) (FieldType alpha@@32))) (= (U_2_bool (MapType6Select (|lambda#24| |l#0@@45| |l#1@@23| |l#2@@23| |l#3@@23|) $o@@95 $f@@25))  (=> (and (not (= $o@@95 |l#0@@45|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@23| $o@@95) |l#2@@23|))) |l#3@@23|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5055|
 :pattern ( (MapType6Select (|lambda#24| |l#0@@45| |l#1@@23| |l#2@@23| |l#3@@23|) $o@@95 $f@@25))
)))
(assert (forall ((arg0@@685 T@U) (arg1@@379 T@U) (arg2@@199 T@U) (arg3@@126 Bool) ) (! (= (type (|lambda#25| arg0@@685 arg1@@379 arg2@@199 arg3@@126)) (MapType6Type refType boolType))
 :qid |funType:lambda#25|
 :pattern ( (|lambda#25| arg0@@685 arg1@@379 arg2@@199 arg3@@126))
)))
(assert (forall ((|l#0@@46| T@U) (|l#1@@24| T@U) (|l#2@@24| T@U) (|l#3@@24| Bool) ($o@@96 T@U) ($f@@26 T@U) ) (! (let ((alpha@@33 (FieldTypeInv0 (type $f@@26))))
 (=> (and (and (and (and (= (type |l#0@@46|) refType) (= (type |l#1@@24|) (MapType0Type refType MapType1Type))) (= (type |l#2@@24|) (FieldType boolType))) (= (type $o@@96) refType)) (= (type $f@@26) (FieldType alpha@@33))) (= (U_2_bool (MapType6Select (|lambda#25| |l#0@@46| |l#1@@24| |l#2@@24| |l#3@@24|) $o@@96 $f@@26))  (=> (and (not (= $o@@96 |l#0@@46|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@24| $o@@96) |l#2@@24|))) |l#3@@24|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5056|
 :pattern ( (MapType6Select (|lambda#25| |l#0@@46| |l#1@@24| |l#2@@24| |l#3@@24|) $o@@96 $f@@26))
)))
(assert (forall ((arg0@@686 T@U) (arg1@@380 T@U) (arg2@@200 T@U) (arg3@@127 Bool) ) (! (= (type (|lambda#26| arg0@@686 arg1@@380 arg2@@200 arg3@@127)) (MapType6Type refType boolType))
 :qid |funType:lambda#26|
 :pattern ( (|lambda#26| arg0@@686 arg1@@380 arg2@@200 arg3@@127))
)))
(assert (forall ((|l#0@@47| T@U) (|l#1@@25| T@U) (|l#2@@25| T@U) (|l#3@@25| Bool) ($o@@97 T@U) ($f@@27 T@U) ) (! (let ((alpha@@34 (FieldTypeInv0 (type $f@@27))))
 (=> (and (and (and (and (= (type |l#0@@47|) refType) (= (type |l#1@@25|) (MapType0Type refType MapType1Type))) (= (type |l#2@@25|) (FieldType boolType))) (= (type $o@@97) refType)) (= (type $f@@27) (FieldType alpha@@34))) (= (U_2_bool (MapType6Select (|lambda#26| |l#0@@47| |l#1@@25| |l#2@@25| |l#3@@25|) $o@@97 $f@@27))  (=> (and (not (= $o@@97 |l#0@@47|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@25| $o@@97) |l#2@@25|))) |l#3@@25|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5057|
 :pattern ( (MapType6Select (|lambda#26| |l#0@@47| |l#1@@25| |l#2@@25| |l#3@@25|) $o@@97 $f@@27))
)))
(assert (forall ((arg0@@687 T@U) (arg1@@381 T@U) (arg2@@201 T@U) (arg3@@128 Bool) ) (! (= (type (|lambda#27| arg0@@687 arg1@@381 arg2@@201 arg3@@128)) (MapType6Type refType boolType))
 :qid |funType:lambda#27|
 :pattern ( (|lambda#27| arg0@@687 arg1@@381 arg2@@201 arg3@@128))
)))
(assert (forall ((|l#0@@48| T@U) (|l#1@@26| T@U) (|l#2@@26| T@U) (|l#3@@26| Bool) ($o@@98 T@U) ($f@@28 T@U) ) (! (let ((alpha@@35 (FieldTypeInv0 (type $f@@28))))
 (=> (and (and (and (and (= (type |l#0@@48|) refType) (= (type |l#1@@26|) (MapType0Type refType MapType1Type))) (= (type |l#2@@26|) (FieldType boolType))) (= (type $o@@98) refType)) (= (type $f@@28) (FieldType alpha@@35))) (= (U_2_bool (MapType6Select (|lambda#27| |l#0@@48| |l#1@@26| |l#2@@26| |l#3@@26|) $o@@98 $f@@28))  (=> (and (not (= $o@@98 |l#0@@48|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@26| $o@@98) |l#2@@26|))) |l#3@@26|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5058|
 :pattern ( (MapType6Select (|lambda#27| |l#0@@48| |l#1@@26| |l#2@@26| |l#3@@26|) $o@@98 $f@@28))
)))
(assert (forall ((arg0@@688 T@U) (arg1@@382 T@U) (arg2@@202 T@U) (arg3@@129 Bool) ) (! (= (type (|lambda#28| arg0@@688 arg1@@382 arg2@@202 arg3@@129)) (MapType6Type refType boolType))
 :qid |funType:lambda#28|
 :pattern ( (|lambda#28| arg0@@688 arg1@@382 arg2@@202 arg3@@129))
)))
(assert (forall ((|l#0@@49| T@U) (|l#1@@27| T@U) (|l#2@@27| T@U) (|l#3@@27| Bool) ($o@@99 T@U) ($f@@29 T@U) ) (! (let ((alpha@@36 (FieldTypeInv0 (type $f@@29))))
 (=> (and (and (and (and (= (type |l#0@@49|) refType) (= (type |l#1@@27|) (MapType0Type refType MapType1Type))) (= (type |l#2@@27|) (FieldType boolType))) (= (type $o@@99) refType)) (= (type $f@@29) (FieldType alpha@@36))) (= (U_2_bool (MapType6Select (|lambda#28| |l#0@@49| |l#1@@27| |l#2@@27| |l#3@@27|) $o@@99 $f@@29))  (=> (and (not (= $o@@99 |l#0@@49|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@27| $o@@99) |l#2@@27|))) |l#3@@27|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5059|
 :pattern ( (MapType6Select (|lambda#28| |l#0@@49| |l#1@@27| |l#2@@27| |l#3@@27|) $o@@99 $f@@29))
)))
(assert (forall ((arg0@@689 T@U) (arg1@@383 T@U) (arg2@@203 T@U) (arg3@@130 Bool) ) (! (= (type (|lambda#29| arg0@@689 arg1@@383 arg2@@203 arg3@@130)) (MapType6Type refType boolType))
 :qid |funType:lambda#29|
 :pattern ( (|lambda#29| arg0@@689 arg1@@383 arg2@@203 arg3@@130))
)))
(assert (forall ((|l#0@@50| T@U) (|l#1@@28| T@U) (|l#2@@28| T@U) (|l#3@@28| Bool) ($o@@100 T@U) ($f@@30 T@U) ) (! (let ((alpha@@37 (FieldTypeInv0 (type $f@@30))))
 (=> (and (and (and (and (= (type |l#0@@50|) refType) (= (type |l#1@@28|) (MapType0Type refType MapType1Type))) (= (type |l#2@@28|) (FieldType boolType))) (= (type $o@@100) refType)) (= (type $f@@30) (FieldType alpha@@37))) (= (U_2_bool (MapType6Select (|lambda#29| |l#0@@50| |l#1@@28| |l#2@@28| |l#3@@28|) $o@@100 $f@@30))  (=> (and (not (= $o@@100 |l#0@@50|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@28| $o@@100) |l#2@@28|))) |l#3@@28|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5060|
 :pattern ( (MapType6Select (|lambda#29| |l#0@@50| |l#1@@28| |l#2@@28| |l#3@@28|) $o@@100 $f@@30))
)))
(assert (forall ((arg0@@690 T@U) (arg1@@384 T@U) (arg2@@204 T@U) (arg3@@131 Bool) ) (! (= (type (|lambda#30| arg0@@690 arg1@@384 arg2@@204 arg3@@131)) (MapType6Type refType boolType))
 :qid |funType:lambda#30|
 :pattern ( (|lambda#30| arg0@@690 arg1@@384 arg2@@204 arg3@@131))
)))
(assert (forall ((|l#0@@51| T@U) (|l#1@@29| T@U) (|l#2@@29| T@U) (|l#3@@29| Bool) ($o@@101 T@U) ($f@@31 T@U) ) (! (let ((alpha@@38 (FieldTypeInv0 (type $f@@31))))
 (=> (and (and (and (and (= (type |l#0@@51|) refType) (= (type |l#1@@29|) (MapType0Type refType MapType1Type))) (= (type |l#2@@29|) (FieldType boolType))) (= (type $o@@101) refType)) (= (type $f@@31) (FieldType alpha@@38))) (= (U_2_bool (MapType6Select (|lambda#30| |l#0@@51| |l#1@@29| |l#2@@29| |l#3@@29|) $o@@101 $f@@31))  (=> (and (not (= $o@@101 |l#0@@51|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@29| $o@@101) |l#2@@29|))) |l#3@@29|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5061|
 :pattern ( (MapType6Select (|lambda#30| |l#0@@51| |l#1@@29| |l#2@@29| |l#3@@29|) $o@@101 $f@@31))
)))
(assert (forall ((arg0@@691 T@U) (arg1@@385 T@U) (arg2@@205 T@U) (arg3@@132 Bool) ) (! (= (type (|lambda#31| arg0@@691 arg1@@385 arg2@@205 arg3@@132)) (MapType6Type refType boolType))
 :qid |funType:lambda#31|
 :pattern ( (|lambda#31| arg0@@691 arg1@@385 arg2@@205 arg3@@132))
)))
(assert (forall ((|l#0@@52| T@U) (|l#1@@30| T@U) (|l#2@@30| T@U) (|l#3@@30| Bool) ($o@@102 T@U) ($f@@32 T@U) ) (! (let ((alpha@@39 (FieldTypeInv0 (type $f@@32))))
 (=> (and (and (and (and (= (type |l#0@@52|) refType) (= (type |l#1@@30|) (MapType0Type refType MapType1Type))) (= (type |l#2@@30|) (FieldType boolType))) (= (type $o@@102) refType)) (= (type $f@@32) (FieldType alpha@@39))) (= (U_2_bool (MapType6Select (|lambda#31| |l#0@@52| |l#1@@30| |l#2@@30| |l#3@@30|) $o@@102 $f@@32))  (=> (and (not (= $o@@102 |l#0@@52|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@30| $o@@102) |l#2@@30|))) |l#3@@30|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5062|
 :pattern ( (MapType6Select (|lambda#31| |l#0@@52| |l#1@@30| |l#2@@30| |l#3@@30|) $o@@102 $f@@32))
)))
(assert (forall ((arg0@@692 T@U) (arg1@@386 T@U) (arg2@@206 T@U) (arg3@@133 Bool) ) (! (= (type (|lambda#32| arg0@@692 arg1@@386 arg2@@206 arg3@@133)) (MapType6Type refType boolType))
 :qid |funType:lambda#32|
 :pattern ( (|lambda#32| arg0@@692 arg1@@386 arg2@@206 arg3@@133))
)))
(assert (forall ((|l#0@@53| T@U) (|l#1@@31| T@U) (|l#2@@31| T@U) (|l#3@@31| Bool) ($o@@103 T@U) ($f@@33 T@U) ) (! (let ((alpha@@40 (FieldTypeInv0 (type $f@@33))))
 (=> (and (and (and (and (= (type |l#0@@53|) refType) (= (type |l#1@@31|) (MapType0Type refType MapType1Type))) (= (type |l#2@@31|) (FieldType boolType))) (= (type $o@@103) refType)) (= (type $f@@33) (FieldType alpha@@40))) (= (U_2_bool (MapType6Select (|lambda#32| |l#0@@53| |l#1@@31| |l#2@@31| |l#3@@31|) $o@@103 $f@@33))  (=> (and (not (= $o@@103 |l#0@@53|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@31| $o@@103) |l#2@@31|))) |l#3@@31|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5063|
 :pattern ( (MapType6Select (|lambda#32| |l#0@@53| |l#1@@31| |l#2@@31| |l#3@@31|) $o@@103 $f@@33))
)))
(assert (forall ((arg0@@693 T@U) (arg1@@387 T@U) (arg2@@207 T@U) (arg3@@134 Bool) ) (! (= (type (|lambda#33| arg0@@693 arg1@@387 arg2@@207 arg3@@134)) (MapType6Type refType boolType))
 :qid |funType:lambda#33|
 :pattern ( (|lambda#33| arg0@@693 arg1@@387 arg2@@207 arg3@@134))
)))
(assert (forall ((|l#0@@54| T@U) (|l#1@@32| T@U) (|l#2@@32| T@U) (|l#3@@32| Bool) ($o@@104 T@U) ($f@@34 T@U) ) (! (let ((alpha@@41 (FieldTypeInv0 (type $f@@34))))
 (=> (and (and (and (and (= (type |l#0@@54|) refType) (= (type |l#1@@32|) (MapType0Type refType MapType1Type))) (= (type |l#2@@32|) (FieldType boolType))) (= (type $o@@104) refType)) (= (type $f@@34) (FieldType alpha@@41))) (= (U_2_bool (MapType6Select (|lambda#33| |l#0@@54| |l#1@@32| |l#2@@32| |l#3@@32|) $o@@104 $f@@34))  (=> (and (not (= $o@@104 |l#0@@54|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@32| $o@@104) |l#2@@32|))) |l#3@@32|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5064|
 :pattern ( (MapType6Select (|lambda#33| |l#0@@54| |l#1@@32| |l#2@@32| |l#3@@32|) $o@@104 $f@@34))
)))
(assert (forall ((arg0@@694 T@U) (arg1@@388 T@U) (arg2@@208 T@U) (arg3@@135 Bool) ) (! (= (type (|lambda#34| arg0@@694 arg1@@388 arg2@@208 arg3@@135)) (MapType6Type refType boolType))
 :qid |funType:lambda#34|
 :pattern ( (|lambda#34| arg0@@694 arg1@@388 arg2@@208 arg3@@135))
)))
(assert (forall ((|l#0@@55| T@U) (|l#1@@33| T@U) (|l#2@@33| T@U) (|l#3@@33| Bool) ($o@@105 T@U) ($f@@35 T@U) ) (! (let ((alpha@@42 (FieldTypeInv0 (type $f@@35))))
 (=> (and (and (and (and (= (type |l#0@@55|) refType) (= (type |l#1@@33|) (MapType0Type refType MapType1Type))) (= (type |l#2@@33|) (FieldType boolType))) (= (type $o@@105) refType)) (= (type $f@@35) (FieldType alpha@@42))) (= (U_2_bool (MapType6Select (|lambda#34| |l#0@@55| |l#1@@33| |l#2@@33| |l#3@@33|) $o@@105 $f@@35))  (=> (and (not (= $o@@105 |l#0@@55|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@33| $o@@105) |l#2@@33|))) |l#3@@33|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5065|
 :pattern ( (MapType6Select (|lambda#34| |l#0@@55| |l#1@@33| |l#2@@33| |l#3@@33|) $o@@105 $f@@35))
)))
(assert (forall ((arg0@@695 T@U) (arg1@@389 T@U) (arg2@@209 T@U) (arg3@@136 Bool) ) (! (= (type (|lambda#35| arg0@@695 arg1@@389 arg2@@209 arg3@@136)) (MapType6Type refType boolType))
 :qid |funType:lambda#35|
 :pattern ( (|lambda#35| arg0@@695 arg1@@389 arg2@@209 arg3@@136))
)))
(assert (forall ((|l#0@@56| T@U) (|l#1@@34| T@U) (|l#2@@34| T@U) (|l#3@@34| Bool) ($o@@106 T@U) ($f@@36 T@U) ) (! (let ((alpha@@43 (FieldTypeInv0 (type $f@@36))))
 (=> (and (and (and (and (= (type |l#0@@56|) refType) (= (type |l#1@@34|) (MapType0Type refType MapType1Type))) (= (type |l#2@@34|) (FieldType boolType))) (= (type $o@@106) refType)) (= (type $f@@36) (FieldType alpha@@43))) (= (U_2_bool (MapType6Select (|lambda#35| |l#0@@56| |l#1@@34| |l#2@@34| |l#3@@34|) $o@@106 $f@@36))  (=> (and (not (= $o@@106 |l#0@@56|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@34| $o@@106) |l#2@@34|))) |l#3@@34|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5066|
 :pattern ( (MapType6Select (|lambda#35| |l#0@@56| |l#1@@34| |l#2@@34| |l#3@@34|) $o@@106 $f@@36))
)))
(assert (forall ((arg0@@696 T@U) (arg1@@390 T@U) (arg2@@210 T@U) (arg3@@137 Bool) ) (! (= (type (|lambda#36| arg0@@696 arg1@@390 arg2@@210 arg3@@137)) (MapType6Type refType boolType))
 :qid |funType:lambda#36|
 :pattern ( (|lambda#36| arg0@@696 arg1@@390 arg2@@210 arg3@@137))
)))
(assert (forall ((|l#0@@57| T@U) (|l#1@@35| T@U) (|l#2@@35| T@U) (|l#3@@35| Bool) ($o@@107 T@U) ($f@@37 T@U) ) (! (let ((alpha@@44 (FieldTypeInv0 (type $f@@37))))
 (=> (and (and (and (and (= (type |l#0@@57|) refType) (= (type |l#1@@35|) (MapType0Type refType MapType1Type))) (= (type |l#2@@35|) (FieldType boolType))) (= (type $o@@107) refType)) (= (type $f@@37) (FieldType alpha@@44))) (= (U_2_bool (MapType6Select (|lambda#36| |l#0@@57| |l#1@@35| |l#2@@35| |l#3@@35|) $o@@107 $f@@37))  (=> (and (not (= $o@@107 |l#0@@57|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@35| $o@@107) |l#2@@35|))) |l#3@@35|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5067|
 :pattern ( (MapType6Select (|lambda#36| |l#0@@57| |l#1@@35| |l#2@@35| |l#3@@35|) $o@@107 $f@@37))
)))
(assert (forall ((arg0@@697 T@U) (arg1@@391 T@U) (arg2@@211 T@U) (arg3@@138 Bool) ) (! (= (type (|lambda#37| arg0@@697 arg1@@391 arg2@@211 arg3@@138)) (MapType6Type refType boolType))
 :qid |funType:lambda#37|
 :pattern ( (|lambda#37| arg0@@697 arg1@@391 arg2@@211 arg3@@138))
)))
(assert (forall ((|l#0@@58| T@U) (|l#1@@36| T@U) (|l#2@@36| T@U) (|l#3@@36| Bool) ($o@@108 T@U) ($f@@38 T@U) ) (! (let ((alpha@@45 (FieldTypeInv0 (type $f@@38))))
 (=> (and (and (and (and (= (type |l#0@@58|) refType) (= (type |l#1@@36|) (MapType0Type refType MapType1Type))) (= (type |l#2@@36|) (FieldType boolType))) (= (type $o@@108) refType)) (= (type $f@@38) (FieldType alpha@@45))) (= (U_2_bool (MapType6Select (|lambda#37| |l#0@@58| |l#1@@36| |l#2@@36| |l#3@@36|) $o@@108 $f@@38))  (=> (and (not (= $o@@108 |l#0@@58|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@36| $o@@108) |l#2@@36|))) |l#3@@36|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5068|
 :pattern ( (MapType6Select (|lambda#37| |l#0@@58| |l#1@@36| |l#2@@36| |l#3@@36|) $o@@108 $f@@38))
)))
(assert (forall ((arg0@@698 T@U) (arg1@@392 T@U) (arg2@@212 T@U) (arg3@@139 Bool) ) (! (= (type (|lambda#38| arg0@@698 arg1@@392 arg2@@212 arg3@@139)) (MapType6Type refType boolType))
 :qid |funType:lambda#38|
 :pattern ( (|lambda#38| arg0@@698 arg1@@392 arg2@@212 arg3@@139))
)))
(assert (forall ((|l#0@@59| T@U) (|l#1@@37| T@U) (|l#2@@37| T@U) (|l#3@@37| Bool) ($o@@109 T@U) ($f@@39 T@U) ) (! (let ((alpha@@46 (FieldTypeInv0 (type $f@@39))))
 (=> (and (and (and (and (= (type |l#0@@59|) refType) (= (type |l#1@@37|) (MapType0Type refType MapType1Type))) (= (type |l#2@@37|) (FieldType boolType))) (= (type $o@@109) refType)) (= (type $f@@39) (FieldType alpha@@46))) (= (U_2_bool (MapType6Select (|lambda#38| |l#0@@59| |l#1@@37| |l#2@@37| |l#3@@37|) $o@@109 $f@@39))  (=> (and (not (= $o@@109 |l#0@@59|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@37| $o@@109) |l#2@@37|))) |l#3@@37|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5069|
 :pattern ( (MapType6Select (|lambda#38| |l#0@@59| |l#1@@37| |l#2@@37| |l#3@@37|) $o@@109 $f@@39))
)))
(assert (forall ((arg0@@699 T@U) (arg1@@393 T@U) (arg2@@213 T@U) (arg3@@140 Bool) ) (! (= (type (|lambda#39| arg0@@699 arg1@@393 arg2@@213 arg3@@140)) (MapType6Type refType boolType))
 :qid |funType:lambda#39|
 :pattern ( (|lambda#39| arg0@@699 arg1@@393 arg2@@213 arg3@@140))
)))
(assert (forall ((|l#0@@60| T@U) (|l#1@@38| T@U) (|l#2@@38| T@U) (|l#3@@38| Bool) ($o@@110 T@U) ($f@@40 T@U) ) (! (let ((alpha@@47 (FieldTypeInv0 (type $f@@40))))
 (=> (and (and (and (and (= (type |l#0@@60|) refType) (= (type |l#1@@38|) (MapType0Type refType MapType1Type))) (= (type |l#2@@38|) (FieldType boolType))) (= (type $o@@110) refType)) (= (type $f@@40) (FieldType alpha@@47))) (= (U_2_bool (MapType6Select (|lambda#39| |l#0@@60| |l#1@@38| |l#2@@38| |l#3@@38|) $o@@110 $f@@40))  (=> (and (not (= $o@@110 |l#0@@60|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@38| $o@@110) |l#2@@38|))) |l#3@@38|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5070|
 :pattern ( (MapType6Select (|lambda#39| |l#0@@60| |l#1@@38| |l#2@@38| |l#3@@38|) $o@@110 $f@@40))
)))
(assert (forall ((arg0@@700 T@U) (arg1@@394 T@U) (arg2@@214 T@U) (arg3@@141 Bool) ) (! (= (type (|lambda#40| arg0@@700 arg1@@394 arg2@@214 arg3@@141)) (MapType6Type refType boolType))
 :qid |funType:lambda#40|
 :pattern ( (|lambda#40| arg0@@700 arg1@@394 arg2@@214 arg3@@141))
)))
(assert (forall ((|l#0@@61| T@U) (|l#1@@39| T@U) (|l#2@@39| T@U) (|l#3@@39| Bool) ($o@@111 T@U) ($f@@41 T@U) ) (! (let ((alpha@@48 (FieldTypeInv0 (type $f@@41))))
 (=> (and (and (and (and (= (type |l#0@@61|) refType) (= (type |l#1@@39|) (MapType0Type refType MapType1Type))) (= (type |l#2@@39|) (FieldType boolType))) (= (type $o@@111) refType)) (= (type $f@@41) (FieldType alpha@@48))) (= (U_2_bool (MapType6Select (|lambda#40| |l#0@@61| |l#1@@39| |l#2@@39| |l#3@@39|) $o@@111 $f@@41))  (=> (and (not (= $o@@111 |l#0@@61|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@39| $o@@111) |l#2@@39|))) |l#3@@39|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5071|
 :pattern ( (MapType6Select (|lambda#40| |l#0@@61| |l#1@@39| |l#2@@39| |l#3@@39|) $o@@111 $f@@41))
)))
(assert (forall ((arg0@@701 T@U) (arg1@@395 T@U) (arg2@@215 T@U) (arg3@@142 Bool) ) (! (= (type (|lambda#41| arg0@@701 arg1@@395 arg2@@215 arg3@@142)) (MapType6Type refType boolType))
 :qid |funType:lambda#41|
 :pattern ( (|lambda#41| arg0@@701 arg1@@395 arg2@@215 arg3@@142))
)))
(assert (forall ((|l#0@@62| T@U) (|l#1@@40| T@U) (|l#2@@40| T@U) (|l#3@@40| Bool) ($o@@112 T@U) ($f@@42 T@U) ) (! (let ((alpha@@49 (FieldTypeInv0 (type $f@@42))))
 (=> (and (and (and (and (= (type |l#0@@62|) refType) (= (type |l#1@@40|) (MapType0Type refType MapType1Type))) (= (type |l#2@@40|) (FieldType boolType))) (= (type $o@@112) refType)) (= (type $f@@42) (FieldType alpha@@49))) (= (U_2_bool (MapType6Select (|lambda#41| |l#0@@62| |l#1@@40| |l#2@@40| |l#3@@40|) $o@@112 $f@@42))  (=> (and (not (= $o@@112 |l#0@@62|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@40| $o@@112) |l#2@@40|))) |l#3@@40|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5072|
 :pattern ( (MapType6Select (|lambda#41| |l#0@@62| |l#1@@40| |l#2@@40| |l#3@@40|) $o@@112 $f@@42))
)))
(assert (forall ((arg0@@702 T@U) (arg1@@396 T@U) (arg2@@216 T@U) (arg3@@143 Bool) ) (! (= (type (|lambda#42| arg0@@702 arg1@@396 arg2@@216 arg3@@143)) (MapType6Type refType boolType))
 :qid |funType:lambda#42|
 :pattern ( (|lambda#42| arg0@@702 arg1@@396 arg2@@216 arg3@@143))
)))
(assert (forall ((|l#0@@63| T@U) (|l#1@@41| T@U) (|l#2@@41| T@U) (|l#3@@41| Bool) ($o@@113 T@U) ($f@@43 T@U) ) (! (let ((alpha@@50 (FieldTypeInv0 (type $f@@43))))
 (=> (and (and (and (and (= (type |l#0@@63|) refType) (= (type |l#1@@41|) (MapType0Type refType MapType1Type))) (= (type |l#2@@41|) (FieldType boolType))) (= (type $o@@113) refType)) (= (type $f@@43) (FieldType alpha@@50))) (= (U_2_bool (MapType6Select (|lambda#42| |l#0@@63| |l#1@@41| |l#2@@41| |l#3@@41|) $o@@113 $f@@43))  (=> (and (not (= $o@@113 |l#0@@63|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@41| $o@@113) |l#2@@41|))) |l#3@@41|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5073|
 :pattern ( (MapType6Select (|lambda#42| |l#0@@63| |l#1@@41| |l#2@@41| |l#3@@41|) $o@@113 $f@@43))
)))
(assert (forall ((arg0@@703 T@U) (arg1@@397 T@U) (arg2@@217 T@U) (arg3@@144 Bool) ) (! (= (type (|lambda#43| arg0@@703 arg1@@397 arg2@@217 arg3@@144)) (MapType6Type refType boolType))
 :qid |funType:lambda#43|
 :pattern ( (|lambda#43| arg0@@703 arg1@@397 arg2@@217 arg3@@144))
)))
(assert (forall ((|l#0@@64| T@U) (|l#1@@42| T@U) (|l#2@@42| T@U) (|l#3@@42| Bool) ($o@@114 T@U) ($f@@44 T@U) ) (! (let ((alpha@@51 (FieldTypeInv0 (type $f@@44))))
 (=> (and (and (and (and (= (type |l#0@@64|) refType) (= (type |l#1@@42|) (MapType0Type refType MapType1Type))) (= (type |l#2@@42|) (FieldType boolType))) (= (type $o@@114) refType)) (= (type $f@@44) (FieldType alpha@@51))) (= (U_2_bool (MapType6Select (|lambda#43| |l#0@@64| |l#1@@42| |l#2@@42| |l#3@@42|) $o@@114 $f@@44))  (=> (and (not (= $o@@114 |l#0@@64|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@42| $o@@114) |l#2@@42|))) |l#3@@42|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5074|
 :pattern ( (MapType6Select (|lambda#43| |l#0@@64| |l#1@@42| |l#2@@42| |l#3@@42|) $o@@114 $f@@44))
)))
(assert (forall ((|l#0@@65| T@U) (|l#1@@43| T@U) (|$y#0| T@U) ) (!  (=> (and (and (= (type |l#0@@65|) TyType) (= (type |l#1@@43|) DatatypeTypeType)) (= (type |$y#0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#44| |l#0@@65| |l#1@@43|) |$y#0|))  (and ($IsBox |$y#0| |l#0@@65|) (PivotBetree.BetreeNode.KeyInDomain |l#1@@43| ($Unbox (SeqType BoxType) |$y#0|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |5075|
 :pattern ( (MapType0Select (|lambda#44| |l#0@@65| |l#1@@43|) |$y#0|))
)))
(assert (forall ((arg0@@704 T@U) (arg1@@398 T@U) (arg2@@218 T@U) (arg3@@145 Bool) ) (! (= (type (|lambda#46| arg0@@704 arg1@@398 arg2@@218 arg3@@145)) (MapType6Type refType boolType))
 :qid |funType:lambda#46|
 :pattern ( (|lambda#46| arg0@@704 arg1@@398 arg2@@218 arg3@@145))
)))
(assert (forall ((|l#0@@66| T@U) (|l#1@@44| T@U) (|l#2@@43| T@U) (|l#3@@43| Bool) ($o@@115 T@U) ($f@@45 T@U) ) (! (let ((alpha@@52 (FieldTypeInv0 (type $f@@45))))
 (=> (and (and (and (and (= (type |l#0@@66|) refType) (= (type |l#1@@44|) (MapType0Type refType MapType1Type))) (= (type |l#2@@43|) (FieldType boolType))) (= (type $o@@115) refType)) (= (type $f@@45) (FieldType alpha@@52))) (= (U_2_bool (MapType6Select (|lambda#46| |l#0@@66| |l#1@@44| |l#2@@43| |l#3@@43|) $o@@115 $f@@45))  (=> (and (not (= $o@@115 |l#0@@66|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@44| $o@@115) |l#2@@43|))) |l#3@@43|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5076|
 :pattern ( (MapType6Select (|lambda#46| |l#0@@66| |l#1@@44| |l#2@@43| |l#3@@43|) $o@@115 $f@@45))
)))
(assert (forall ((arg0@@705 T@U) (arg1@@399 T@U) (arg2@@219 T@U) (arg3@@146 Bool) ) (! (= (type (|lambda#47| arg0@@705 arg1@@399 arg2@@219 arg3@@146)) (MapType6Type refType boolType))
 :qid |funType:lambda#47|
 :pattern ( (|lambda#47| arg0@@705 arg1@@399 arg2@@219 arg3@@146))
)))
(assert (forall ((|l#0@@67| T@U) (|l#1@@45| T@U) (|l#2@@44| T@U) (|l#3@@44| Bool) ($o@@116 T@U) ($f@@46 T@U) ) (! (let ((alpha@@53 (FieldTypeInv0 (type $f@@46))))
 (=> (and (and (and (and (= (type |l#0@@67|) refType) (= (type |l#1@@45|) (MapType0Type refType MapType1Type))) (= (type |l#2@@44|) (FieldType boolType))) (= (type $o@@116) refType)) (= (type $f@@46) (FieldType alpha@@53))) (= (U_2_bool (MapType6Select (|lambda#47| |l#0@@67| |l#1@@45| |l#2@@44| |l#3@@44|) $o@@116 $f@@46))  (=> (and (not (= $o@@116 |l#0@@67|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@45| $o@@116) |l#2@@44|))) |l#3@@44|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5077|
 :pattern ( (MapType6Select (|lambda#47| |l#0@@67| |l#1@@45| |l#2@@44| |l#3@@44|) $o@@116 $f@@46))
)))
(assert (forall ((arg0@@706 T@U) (arg1@@400 T@U) (arg2@@220 T@U) (arg3@@147 Bool) ) (! (= (type (|lambda#49| arg0@@706 arg1@@400 arg2@@220 arg3@@147)) (MapType6Type refType boolType))
 :qid |funType:lambda#49|
 :pattern ( (|lambda#49| arg0@@706 arg1@@400 arg2@@220 arg3@@147))
)))
(assert (forall ((|l#0@@68| T@U) (|l#1@@46| T@U) (|l#2@@45| T@U) (|l#3@@45| Bool) ($o@@117 T@U) ($f@@47 T@U) ) (! (let ((alpha@@54 (FieldTypeInv0 (type $f@@47))))
 (=> (and (and (and (and (= (type |l#0@@68|) refType) (= (type |l#1@@46|) (MapType0Type refType MapType1Type))) (= (type |l#2@@45|) (FieldType boolType))) (= (type $o@@117) refType)) (= (type $f@@47) (FieldType alpha@@54))) (= (U_2_bool (MapType6Select (|lambda#49| |l#0@@68| |l#1@@46| |l#2@@45| |l#3@@45|) $o@@117 $f@@47))  (=> (and (not (= $o@@117 |l#0@@68|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@46| $o@@117) |l#2@@45|))) |l#3@@45|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5078|
 :pattern ( (MapType6Select (|lambda#49| |l#0@@68| |l#1@@46| |l#2@@45| |l#3@@45|) $o@@117 $f@@47))
)))
(assert (forall ((arg0@@707 T@U) (arg1@@401 T@U) (arg2@@221 T@U) (arg3@@148 Bool) ) (! (= (type (|lambda#50| arg0@@707 arg1@@401 arg2@@221 arg3@@148)) (MapType6Type refType boolType))
 :qid |funType:lambda#50|
 :pattern ( (|lambda#50| arg0@@707 arg1@@401 arg2@@221 arg3@@148))
)))
(assert (forall ((|l#0@@69| T@U) (|l#1@@47| T@U) (|l#2@@46| T@U) (|l#3@@46| Bool) ($o@@118 T@U) ($f@@48 T@U) ) (! (let ((alpha@@55 (FieldTypeInv0 (type $f@@48))))
 (=> (and (and (and (and (= (type |l#0@@69|) refType) (= (type |l#1@@47|) (MapType0Type refType MapType1Type))) (= (type |l#2@@46|) (FieldType boolType))) (= (type $o@@118) refType)) (= (type $f@@48) (FieldType alpha@@55))) (= (U_2_bool (MapType6Select (|lambda#50| |l#0@@69| |l#1@@47| |l#2@@46| |l#3@@46|) $o@@118 $f@@48))  (=> (and (not (= $o@@118 |l#0@@69|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@47| $o@@118) |l#2@@46|))) |l#3@@46|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5079|
 :pattern ( (MapType6Select (|lambda#50| |l#0@@69| |l#1@@47| |l#2@@46| |l#3@@46|) $o@@118 $f@@48))
)))
(assert (forall ((arg0@@708 T@U) (arg1@@402 T@U) (arg2@@222 T@U) (arg3@@149 Bool) ) (! (= (type (|lambda#51| arg0@@708 arg1@@402 arg2@@222 arg3@@149)) (MapType6Type refType boolType))
 :qid |funType:lambda#51|
 :pattern ( (|lambda#51| arg0@@708 arg1@@402 arg2@@222 arg3@@149))
)))
(assert (forall ((|l#0@@70| T@U) (|l#1@@48| T@U) (|l#2@@47| T@U) (|l#3@@47| Bool) ($o@@119 T@U) ($f@@49 T@U) ) (! (let ((alpha@@56 (FieldTypeInv0 (type $f@@49))))
 (=> (and (and (and (and (= (type |l#0@@70|) refType) (= (type |l#1@@48|) (MapType0Type refType MapType1Type))) (= (type |l#2@@47|) (FieldType boolType))) (= (type $o@@119) refType)) (= (type $f@@49) (FieldType alpha@@56))) (= (U_2_bool (MapType6Select (|lambda#51| |l#0@@70| |l#1@@48| |l#2@@47| |l#3@@47|) $o@@119 $f@@49))  (=> (and (not (= $o@@119 |l#0@@70|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@48| $o@@119) |l#2@@47|))) |l#3@@47|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5080|
 :pattern ( (MapType6Select (|lambda#51| |l#0@@70| |l#1@@48| |l#2@@47| |l#3@@47|) $o@@119 $f@@49))
)))
(assert (forall ((arg0@@709 T@U) (arg1@@403 T@U) (arg2@@223 T@U) (arg3@@150 Bool) ) (! (= (type (|lambda#52| arg0@@709 arg1@@403 arg2@@223 arg3@@150)) (MapType6Type refType boolType))
 :qid |funType:lambda#52|
 :pattern ( (|lambda#52| arg0@@709 arg1@@403 arg2@@223 arg3@@150))
)))
(assert (forall ((|l#0@@71| T@U) (|l#1@@49| T@U) (|l#2@@48| T@U) (|l#3@@48| Bool) ($o@@120 T@U) ($f@@50 T@U) ) (! (let ((alpha@@57 (FieldTypeInv0 (type $f@@50))))
 (=> (and (and (and (and (= (type |l#0@@71|) refType) (= (type |l#1@@49|) (MapType0Type refType MapType1Type))) (= (type |l#2@@48|) (FieldType boolType))) (= (type $o@@120) refType)) (= (type $f@@50) (FieldType alpha@@57))) (= (U_2_bool (MapType6Select (|lambda#52| |l#0@@71| |l#1@@49| |l#2@@48| |l#3@@48|) $o@@120 $f@@50))  (=> (and (not (= $o@@120 |l#0@@71|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@49| $o@@120) |l#2@@48|))) |l#3@@48|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5081|
 :pattern ( (MapType6Select (|lambda#52| |l#0@@71| |l#1@@49| |l#2@@48| |l#3@@48|) $o@@120 $f@@50))
)))
(assert (forall ((arg0@@710 T@U) (arg1@@404 T@U) (arg2@@224 T@U) (arg3@@151 Bool) ) (! (= (type (|lambda#53| arg0@@710 arg1@@404 arg2@@224 arg3@@151)) (MapType6Type refType boolType))
 :qid |funType:lambda#53|
 :pattern ( (|lambda#53| arg0@@710 arg1@@404 arg2@@224 arg3@@151))
)))
(assert (forall ((|l#0@@72| T@U) (|l#1@@50| T@U) (|l#2@@49| T@U) (|l#3@@49| Bool) ($o@@121 T@U) ($f@@51 T@U) ) (! (let ((alpha@@58 (FieldTypeInv0 (type $f@@51))))
 (=> (and (and (and (and (= (type |l#0@@72|) refType) (= (type |l#1@@50|) (MapType0Type refType MapType1Type))) (= (type |l#2@@49|) (FieldType boolType))) (= (type $o@@121) refType)) (= (type $f@@51) (FieldType alpha@@58))) (= (U_2_bool (MapType6Select (|lambda#53| |l#0@@72| |l#1@@50| |l#2@@49| |l#3@@49|) $o@@121 $f@@51))  (=> (and (not (= $o@@121 |l#0@@72|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@50| $o@@121) |l#2@@49|))) |l#3@@49|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5082|
 :pattern ( (MapType6Select (|lambda#53| |l#0@@72| |l#1@@50| |l#2@@49| |l#3@@49|) $o@@121 $f@@51))
)))
(assert (forall ((arg0@@711 T@U) (arg1@@405 T@U) (arg2@@225 T@U) (arg3@@152 Bool) ) (! (= (type (|lambda#54| arg0@@711 arg1@@405 arg2@@225 arg3@@152)) (MapType6Type refType boolType))
 :qid |funType:lambda#54|
 :pattern ( (|lambda#54| arg0@@711 arg1@@405 arg2@@225 arg3@@152))
)))
(assert (forall ((|l#0@@73| T@U) (|l#1@@51| T@U) (|l#2@@50| T@U) (|l#3@@50| Bool) ($o@@122 T@U) ($f@@52 T@U) ) (! (let ((alpha@@59 (FieldTypeInv0 (type $f@@52))))
 (=> (and (and (and (and (= (type |l#0@@73|) refType) (= (type |l#1@@51|) (MapType0Type refType MapType1Type))) (= (type |l#2@@50|) (FieldType boolType))) (= (type $o@@122) refType)) (= (type $f@@52) (FieldType alpha@@59))) (= (U_2_bool (MapType6Select (|lambda#54| |l#0@@73| |l#1@@51| |l#2@@50| |l#3@@50|) $o@@122 $f@@52))  (=> (and (not (= $o@@122 |l#0@@73|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@51| $o@@122) |l#2@@50|))) |l#3@@50|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5083|
 :pattern ( (MapType6Select (|lambda#54| |l#0@@73| |l#1@@51| |l#2@@50| |l#3@@50|) $o@@122 $f@@52))
)))
(assert (forall ((arg0@@712 T@U) (arg1@@406 T@U) (arg2@@226 T@U) (arg3@@153 Bool) ) (! (= (type (|lambda#55| arg0@@712 arg1@@406 arg2@@226 arg3@@153)) (MapType6Type refType boolType))
 :qid |funType:lambda#55|
 :pattern ( (|lambda#55| arg0@@712 arg1@@406 arg2@@226 arg3@@153))
)))
(assert (forall ((|l#0@@74| T@U) (|l#1@@52| T@U) (|l#2@@51| T@U) (|l#3@@51| Bool) ($o@@123 T@U) ($f@@53 T@U) ) (! (let ((alpha@@60 (FieldTypeInv0 (type $f@@53))))
 (=> (and (and (and (and (= (type |l#0@@74|) refType) (= (type |l#1@@52|) (MapType0Type refType MapType1Type))) (= (type |l#2@@51|) (FieldType boolType))) (= (type $o@@123) refType)) (= (type $f@@53) (FieldType alpha@@60))) (= (U_2_bool (MapType6Select (|lambda#55| |l#0@@74| |l#1@@52| |l#2@@51| |l#3@@51|) $o@@123 $f@@53))  (=> (and (not (= $o@@123 |l#0@@74|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@52| $o@@123) |l#2@@51|))) |l#3@@51|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5084|
 :pattern ( (MapType6Select (|lambda#55| |l#0@@74| |l#1@@52| |l#2@@51| |l#3@@51|) $o@@123 $f@@53))
)))
(assert (forall ((arg0@@713 T@U) (arg1@@407 T@U) (arg2@@227 T@U) (arg3@@154 Bool) ) (! (= (type (|lambda#56| arg0@@713 arg1@@407 arg2@@227 arg3@@154)) (MapType6Type refType boolType))
 :qid |funType:lambda#56|
 :pattern ( (|lambda#56| arg0@@713 arg1@@407 arg2@@227 arg3@@154))
)))
(assert (forall ((|l#0@@75| T@U) (|l#1@@53| T@U) (|l#2@@52| T@U) (|l#3@@52| Bool) ($o@@124 T@U) ($f@@54 T@U) ) (! (let ((alpha@@61 (FieldTypeInv0 (type $f@@54))))
 (=> (and (and (and (and (= (type |l#0@@75|) refType) (= (type |l#1@@53|) (MapType0Type refType MapType1Type))) (= (type |l#2@@52|) (FieldType boolType))) (= (type $o@@124) refType)) (= (type $f@@54) (FieldType alpha@@61))) (= (U_2_bool (MapType6Select (|lambda#56| |l#0@@75| |l#1@@53| |l#2@@52| |l#3@@52|) $o@@124 $f@@54))  (=> (and (not (= $o@@124 |l#0@@75|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@53| $o@@124) |l#2@@52|))) |l#3@@52|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5085|
 :pattern ( (MapType6Select (|lambda#56| |l#0@@75| |l#1@@53| |l#2@@52| |l#3@@52|) $o@@124 $f@@54))
)))
(assert (forall ((arg0@@714 T@U) (arg1@@408 T@U) (arg2@@228 T@U) (arg3@@155 Bool) ) (! (= (type (|lambda#57| arg0@@714 arg1@@408 arg2@@228 arg3@@155)) (MapType6Type refType boolType))
 :qid |funType:lambda#57|
 :pattern ( (|lambda#57| arg0@@714 arg1@@408 arg2@@228 arg3@@155))
)))
(assert (forall ((|l#0@@76| T@U) (|l#1@@54| T@U) (|l#2@@53| T@U) (|l#3@@53| Bool) ($o@@125 T@U) ($f@@55 T@U) ) (! (let ((alpha@@62 (FieldTypeInv0 (type $f@@55))))
 (=> (and (and (and (and (= (type |l#0@@76|) refType) (= (type |l#1@@54|) (MapType0Type refType MapType1Type))) (= (type |l#2@@53|) (FieldType boolType))) (= (type $o@@125) refType)) (= (type $f@@55) (FieldType alpha@@62))) (= (U_2_bool (MapType6Select (|lambda#57| |l#0@@76| |l#1@@54| |l#2@@53| |l#3@@53|) $o@@125 $f@@55))  (=> (and (not (= $o@@125 |l#0@@76|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@54| $o@@125) |l#2@@53|))) |l#3@@53|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5086|
 :pattern ( (MapType6Select (|lambda#57| |l#0@@76| |l#1@@54| |l#2@@53| |l#3@@53|) $o@@125 $f@@55))
)))
(assert (forall ((arg0@@715 T@U) (arg1@@409 T@U) (arg2@@229 T@U) (arg3@@156 Bool) ) (! (= (type (|lambda#58| arg0@@715 arg1@@409 arg2@@229 arg3@@156)) (MapType6Type refType boolType))
 :qid |funType:lambda#58|
 :pattern ( (|lambda#58| arg0@@715 arg1@@409 arg2@@229 arg3@@156))
)))
(assert (forall ((|l#0@@77| T@U) (|l#1@@55| T@U) (|l#2@@54| T@U) (|l#3@@54| Bool) ($o@@126 T@U) ($f@@56 T@U) ) (! (let ((alpha@@63 (FieldTypeInv0 (type $f@@56))))
 (=> (and (and (and (and (= (type |l#0@@77|) refType) (= (type |l#1@@55|) (MapType0Type refType MapType1Type))) (= (type |l#2@@54|) (FieldType boolType))) (= (type $o@@126) refType)) (= (type $f@@56) (FieldType alpha@@63))) (= (U_2_bool (MapType6Select (|lambda#58| |l#0@@77| |l#1@@55| |l#2@@54| |l#3@@54|) $o@@126 $f@@56))  (=> (and (not (= $o@@126 |l#0@@77|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@55| $o@@126) |l#2@@54|))) |l#3@@54|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5087|
 :pattern ( (MapType6Select (|lambda#58| |l#0@@77| |l#1@@55| |l#2@@54| |l#3@@54|) $o@@126 $f@@56))
)))
(assert (forall ((arg0@@716 T@U) (arg1@@410 T@U) (arg2@@230 T@U) (arg3@@157 Bool) ) (! (= (type (|lambda#59| arg0@@716 arg1@@410 arg2@@230 arg3@@157)) (MapType6Type refType boolType))
 :qid |funType:lambda#59|
 :pattern ( (|lambda#59| arg0@@716 arg1@@410 arg2@@230 arg3@@157))
)))
(assert (forall ((|l#0@@78| T@U) (|l#1@@56| T@U) (|l#2@@55| T@U) (|l#3@@55| Bool) ($o@@127 T@U) ($f@@57 T@U) ) (! (let ((alpha@@64 (FieldTypeInv0 (type $f@@57))))
 (=> (and (and (and (and (= (type |l#0@@78|) refType) (= (type |l#1@@56|) (MapType0Type refType MapType1Type))) (= (type |l#2@@55|) (FieldType boolType))) (= (type $o@@127) refType)) (= (type $f@@57) (FieldType alpha@@64))) (= (U_2_bool (MapType6Select (|lambda#59| |l#0@@78| |l#1@@56| |l#2@@55| |l#3@@55|) $o@@127 $f@@57))  (=> (and (not (= $o@@127 |l#0@@78|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@56| $o@@127) |l#2@@55|))) |l#3@@55|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5088|
 :pattern ( (MapType6Select (|lambda#59| |l#0@@78| |l#1@@56| |l#2@@55| |l#3@@55|) $o@@127 $f@@57))
)))
(assert (forall ((arg0@@717 T@U) (arg1@@411 T@U) (arg2@@231 T@U) (arg3@@158 Bool) ) (! (= (type (|lambda#60| arg0@@717 arg1@@411 arg2@@231 arg3@@158)) (MapType6Type refType boolType))
 :qid |funType:lambda#60|
 :pattern ( (|lambda#60| arg0@@717 arg1@@411 arg2@@231 arg3@@158))
)))
(assert (forall ((|l#0@@79| T@U) (|l#1@@57| T@U) (|l#2@@56| T@U) (|l#3@@56| Bool) ($o@@128 T@U) ($f@@58 T@U) ) (! (let ((alpha@@65 (FieldTypeInv0 (type $f@@58))))
 (=> (and (and (and (and (= (type |l#0@@79|) refType) (= (type |l#1@@57|) (MapType0Type refType MapType1Type))) (= (type |l#2@@56|) (FieldType boolType))) (= (type $o@@128) refType)) (= (type $f@@58) (FieldType alpha@@65))) (= (U_2_bool (MapType6Select (|lambda#60| |l#0@@79| |l#1@@57| |l#2@@56| |l#3@@56|) $o@@128 $f@@58))  (=> (and (not (= $o@@128 |l#0@@79|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@57| $o@@128) |l#2@@56|))) |l#3@@56|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5089|
 :pattern ( (MapType6Select (|lambda#60| |l#0@@79| |l#1@@57| |l#2@@56| |l#3@@56|) $o@@128 $f@@58))
)))
(assert (forall ((arg0@@718 T@U) (arg1@@412 T@U) (arg2@@232 T@U) (arg3@@159 Bool) ) (! (= (type (|lambda#61| arg0@@718 arg1@@412 arg2@@232 arg3@@159)) (MapType6Type refType boolType))
 :qid |funType:lambda#61|
 :pattern ( (|lambda#61| arg0@@718 arg1@@412 arg2@@232 arg3@@159))
)))
(assert (forall ((|l#0@@80| T@U) (|l#1@@58| T@U) (|l#2@@57| T@U) (|l#3@@57| Bool) ($o@@129 T@U) ($f@@59 T@U) ) (! (let ((alpha@@66 (FieldTypeInv0 (type $f@@59))))
 (=> (and (and (and (and (= (type |l#0@@80|) refType) (= (type |l#1@@58|) (MapType0Type refType MapType1Type))) (= (type |l#2@@57|) (FieldType boolType))) (= (type $o@@129) refType)) (= (type $f@@59) (FieldType alpha@@66))) (= (U_2_bool (MapType6Select (|lambda#61| |l#0@@80| |l#1@@58| |l#2@@57| |l#3@@57|) $o@@129 $f@@59))  (=> (and (not (= $o@@129 |l#0@@80|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@58| $o@@129) |l#2@@57|))) |l#3@@57|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5090|
 :pattern ( (MapType6Select (|lambda#61| |l#0@@80| |l#1@@58| |l#2@@57| |l#3@@57|) $o@@129 $f@@59))
)))
(assert (forall ((arg0@@719 T@U) (arg1@@413 T@U) (arg2@@233 T@U) (arg3@@160 Bool) ) (! (= (type (|lambda#62| arg0@@719 arg1@@413 arg2@@233 arg3@@160)) (MapType6Type refType boolType))
 :qid |funType:lambda#62|
 :pattern ( (|lambda#62| arg0@@719 arg1@@413 arg2@@233 arg3@@160))
)))
(assert (forall ((|l#0@@81| T@U) (|l#1@@59| T@U) (|l#2@@58| T@U) (|l#3@@58| Bool) ($o@@130 T@U) ($f@@60 T@U) ) (! (let ((alpha@@67 (FieldTypeInv0 (type $f@@60))))
 (=> (and (and (and (and (= (type |l#0@@81|) refType) (= (type |l#1@@59|) (MapType0Type refType MapType1Type))) (= (type |l#2@@58|) (FieldType boolType))) (= (type $o@@130) refType)) (= (type $f@@60) (FieldType alpha@@67))) (= (U_2_bool (MapType6Select (|lambda#62| |l#0@@81| |l#1@@59| |l#2@@58| |l#3@@58|) $o@@130 $f@@60))  (=> (and (not (= $o@@130 |l#0@@81|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@59| $o@@130) |l#2@@58|))) |l#3@@58|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5091|
 :pattern ( (MapType6Select (|lambda#62| |l#0@@81| |l#1@@59| |l#2@@58| |l#3@@58|) $o@@130 $f@@60))
)))
(assert (forall ((arg0@@720 T@U) (arg1@@414 T@U) (arg2@@234 T@U) (arg3@@161 Bool) ) (! (= (type (|lambda#63| arg0@@720 arg1@@414 arg2@@234 arg3@@161)) (MapType6Type refType boolType))
 :qid |funType:lambda#63|
 :pattern ( (|lambda#63| arg0@@720 arg1@@414 arg2@@234 arg3@@161))
)))
(assert (forall ((|l#0@@82| T@U) (|l#1@@60| T@U) (|l#2@@59| T@U) (|l#3@@59| Bool) ($o@@131 T@U) ($f@@61 T@U) ) (! (let ((alpha@@68 (FieldTypeInv0 (type $f@@61))))
 (=> (and (and (and (and (= (type |l#0@@82|) refType) (= (type |l#1@@60|) (MapType0Type refType MapType1Type))) (= (type |l#2@@59|) (FieldType boolType))) (= (type $o@@131) refType)) (= (type $f@@61) (FieldType alpha@@68))) (= (U_2_bool (MapType6Select (|lambda#63| |l#0@@82| |l#1@@60| |l#2@@59| |l#3@@59|) $o@@131 $f@@61))  (=> (and (not (= $o@@131 |l#0@@82|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@60| $o@@131) |l#2@@59|))) |l#3@@59|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5092|
 :pattern ( (MapType6Select (|lambda#63| |l#0@@82| |l#1@@60| |l#2@@59| |l#3@@59|) $o@@131 $f@@61))
)))
(assert (forall ((arg0@@721 T@U) (arg1@@415 T@U) (arg2@@235 T@U) (arg3@@162 Bool) ) (! (= (type (|lambda#64| arg0@@721 arg1@@415 arg2@@235 arg3@@162)) (MapType6Type refType boolType))
 :qid |funType:lambda#64|
 :pattern ( (|lambda#64| arg0@@721 arg1@@415 arg2@@235 arg3@@162))
)))
(assert (forall ((|l#0@@83| T@U) (|l#1@@61| T@U) (|l#2@@60| T@U) (|l#3@@60| Bool) ($o@@132 T@U) ($f@@62 T@U) ) (! (let ((alpha@@69 (FieldTypeInv0 (type $f@@62))))
 (=> (and (and (and (and (= (type |l#0@@83|) refType) (= (type |l#1@@61|) (MapType0Type refType MapType1Type))) (= (type |l#2@@60|) (FieldType boolType))) (= (type $o@@132) refType)) (= (type $f@@62) (FieldType alpha@@69))) (= (U_2_bool (MapType6Select (|lambda#64| |l#0@@83| |l#1@@61| |l#2@@60| |l#3@@60|) $o@@132 $f@@62))  (=> (and (not (= $o@@132 |l#0@@83|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@61| $o@@132) |l#2@@60|))) |l#3@@60|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5093|
 :pattern ( (MapType6Select (|lambda#64| |l#0@@83| |l#1@@61| |l#2@@60| |l#3@@60|) $o@@132 $f@@62))
)))
(assert (forall ((arg0@@722 T@U) (arg1@@416 T@U) (arg2@@236 T@U) (arg3@@163 Bool) ) (! (= (type (|lambda#65| arg0@@722 arg1@@416 arg2@@236 arg3@@163)) (MapType6Type refType boolType))
 :qid |funType:lambda#65|
 :pattern ( (|lambda#65| arg0@@722 arg1@@416 arg2@@236 arg3@@163))
)))
(assert (forall ((|l#0@@84| T@U) (|l#1@@62| T@U) (|l#2@@61| T@U) (|l#3@@61| Bool) ($o@@133 T@U) ($f@@63 T@U) ) (! (let ((alpha@@70 (FieldTypeInv0 (type $f@@63))))
 (=> (and (and (and (and (= (type |l#0@@84|) refType) (= (type |l#1@@62|) (MapType0Type refType MapType1Type))) (= (type |l#2@@61|) (FieldType boolType))) (= (type $o@@133) refType)) (= (type $f@@63) (FieldType alpha@@70))) (= (U_2_bool (MapType6Select (|lambda#65| |l#0@@84| |l#1@@62| |l#2@@61| |l#3@@61|) $o@@133 $f@@63))  (=> (and (not (= $o@@133 |l#0@@84|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@62| $o@@133) |l#2@@61|))) |l#3@@61|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5094|
 :pattern ( (MapType6Select (|lambda#65| |l#0@@84| |l#1@@62| |l#2@@61| |l#3@@61|) $o@@133 $f@@63))
)))
(assert (forall ((arg0@@723 T@U) (arg1@@417 T@U) (arg2@@237 T@U) (arg3@@164 Bool) ) (! (= (type (|lambda#66| arg0@@723 arg1@@417 arg2@@237 arg3@@164)) (MapType6Type refType boolType))
 :qid |funType:lambda#66|
 :pattern ( (|lambda#66| arg0@@723 arg1@@417 arg2@@237 arg3@@164))
)))
(assert (forall ((|l#0@@85| T@U) (|l#1@@63| T@U) (|l#2@@62| T@U) (|l#3@@62| Bool) ($o@@134 T@U) ($f@@64 T@U) ) (! (let ((alpha@@71 (FieldTypeInv0 (type $f@@64))))
 (=> (and (and (and (and (= (type |l#0@@85|) refType) (= (type |l#1@@63|) (MapType0Type refType MapType1Type))) (= (type |l#2@@62|) (FieldType boolType))) (= (type $o@@134) refType)) (= (type $f@@64) (FieldType alpha@@71))) (= (U_2_bool (MapType6Select (|lambda#66| |l#0@@85| |l#1@@63| |l#2@@62| |l#3@@62|) $o@@134 $f@@64))  (=> (and (not (= $o@@134 |l#0@@85|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@63| $o@@134) |l#2@@62|))) |l#3@@62|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5095|
 :pattern ( (MapType6Select (|lambda#66| |l#0@@85| |l#1@@63| |l#2@@62| |l#3@@62|) $o@@134 $f@@64))
)))
(assert (forall ((arg0@@724 T@U) (arg1@@418 T@U) (arg2@@238 T@U) (arg3@@165 Bool) ) (! (= (type (|lambda#67| arg0@@724 arg1@@418 arg2@@238 arg3@@165)) (MapType6Type refType boolType))
 :qid |funType:lambda#67|
 :pattern ( (|lambda#67| arg0@@724 arg1@@418 arg2@@238 arg3@@165))
)))
(assert (forall ((|l#0@@86| T@U) (|l#1@@64| T@U) (|l#2@@63| T@U) (|l#3@@63| Bool) ($o@@135 T@U) ($f@@65 T@U) ) (! (let ((alpha@@72 (FieldTypeInv0 (type $f@@65))))
 (=> (and (and (and (and (= (type |l#0@@86|) refType) (= (type |l#1@@64|) (MapType0Type refType MapType1Type))) (= (type |l#2@@63|) (FieldType boolType))) (= (type $o@@135) refType)) (= (type $f@@65) (FieldType alpha@@72))) (= (U_2_bool (MapType6Select (|lambda#67| |l#0@@86| |l#1@@64| |l#2@@63| |l#3@@63|) $o@@135 $f@@65))  (=> (and (not (= $o@@135 |l#0@@86|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@64| $o@@135) |l#2@@63|))) |l#3@@63|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5096|
 :pattern ( (MapType6Select (|lambda#67| |l#0@@86| |l#1@@64| |l#2@@63| |l#3@@63|) $o@@135 $f@@65))
)))
(assert (forall ((arg0@@725 T@U) (arg1@@419 T@U) (arg2@@239 T@U) (arg3@@166 Bool) ) (! (= (type (|lambda#68| arg0@@725 arg1@@419 arg2@@239 arg3@@166)) (MapType6Type refType boolType))
 :qid |funType:lambda#68|
 :pattern ( (|lambda#68| arg0@@725 arg1@@419 arg2@@239 arg3@@166))
)))
(assert (forall ((|l#0@@87| T@U) (|l#1@@65| T@U) (|l#2@@64| T@U) (|l#3@@64| Bool) ($o@@136 T@U) ($f@@66 T@U) ) (! (let ((alpha@@73 (FieldTypeInv0 (type $f@@66))))
 (=> (and (and (and (and (= (type |l#0@@87|) refType) (= (type |l#1@@65|) (MapType0Type refType MapType1Type))) (= (type |l#2@@64|) (FieldType boolType))) (= (type $o@@136) refType)) (= (type $f@@66) (FieldType alpha@@73))) (= (U_2_bool (MapType6Select (|lambda#68| |l#0@@87| |l#1@@65| |l#2@@64| |l#3@@64|) $o@@136 $f@@66))  (=> (and (not (= $o@@136 |l#0@@87|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@65| $o@@136) |l#2@@64|))) |l#3@@64|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5097|
 :pattern ( (MapType6Select (|lambda#68| |l#0@@87| |l#1@@65| |l#2@@64| |l#3@@64|) $o@@136 $f@@66))
)))
(assert (forall ((arg0@@726 T@U) (arg1@@420 T@U) (arg2@@240 T@U) (arg3@@167 Bool) ) (! (= (type (|lambda#69| arg0@@726 arg1@@420 arg2@@240 arg3@@167)) (MapType6Type refType boolType))
 :qid |funType:lambda#69|
 :pattern ( (|lambda#69| arg0@@726 arg1@@420 arg2@@240 arg3@@167))
)))
(assert (forall ((|l#0@@88| T@U) (|l#1@@66| T@U) (|l#2@@65| T@U) (|l#3@@65| Bool) ($o@@137 T@U) ($f@@67 T@U) ) (! (let ((alpha@@74 (FieldTypeInv0 (type $f@@67))))
 (=> (and (and (and (and (= (type |l#0@@88|) refType) (= (type |l#1@@66|) (MapType0Type refType MapType1Type))) (= (type |l#2@@65|) (FieldType boolType))) (= (type $o@@137) refType)) (= (type $f@@67) (FieldType alpha@@74))) (= (U_2_bool (MapType6Select (|lambda#69| |l#0@@88| |l#1@@66| |l#2@@65| |l#3@@65|) $o@@137 $f@@67))  (=> (and (not (= $o@@137 |l#0@@88|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@66| $o@@137) |l#2@@65|))) |l#3@@65|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5098|
 :pattern ( (MapType6Select (|lambda#69| |l#0@@88| |l#1@@66| |l#2@@65| |l#3@@65|) $o@@137 $f@@67))
)))
(assert (forall ((arg0@@727 T@U) (arg1@@421 T@U) (arg2@@241 T@U) (arg3@@168 Bool) ) (! (= (type (|lambda#70| arg0@@727 arg1@@421 arg2@@241 arg3@@168)) (MapType6Type refType boolType))
 :qid |funType:lambda#70|
 :pattern ( (|lambda#70| arg0@@727 arg1@@421 arg2@@241 arg3@@168))
)))
(assert (forall ((|l#0@@89| T@U) (|l#1@@67| T@U) (|l#2@@66| T@U) (|l#3@@66| Bool) ($o@@138 T@U) ($f@@68 T@U) ) (! (let ((alpha@@75 (FieldTypeInv0 (type $f@@68))))
 (=> (and (and (and (and (= (type |l#0@@89|) refType) (= (type |l#1@@67|) (MapType0Type refType MapType1Type))) (= (type |l#2@@66|) (FieldType boolType))) (= (type $o@@138) refType)) (= (type $f@@68) (FieldType alpha@@75))) (= (U_2_bool (MapType6Select (|lambda#70| |l#0@@89| |l#1@@67| |l#2@@66| |l#3@@66|) $o@@138 $f@@68))  (=> (and (not (= $o@@138 |l#0@@89|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@67| $o@@138) |l#2@@66|))) |l#3@@66|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5099|
 :pattern ( (MapType6Select (|lambda#70| |l#0@@89| |l#1@@67| |l#2@@66| |l#3@@66|) $o@@138 $f@@68))
)))
(assert (forall ((arg0@@728 T@U) (arg1@@422 T@U) (arg2@@242 T@U) (arg3@@169 Bool) ) (! (= (type (|lambda#71| arg0@@728 arg1@@422 arg2@@242 arg3@@169)) (MapType6Type refType boolType))
 :qid |funType:lambda#71|
 :pattern ( (|lambda#71| arg0@@728 arg1@@422 arg2@@242 arg3@@169))
)))
(assert (forall ((|l#0@@90| T@U) (|l#1@@68| T@U) (|l#2@@67| T@U) (|l#3@@67| Bool) ($o@@139 T@U) ($f@@69 T@U) ) (! (let ((alpha@@76 (FieldTypeInv0 (type $f@@69))))
 (=> (and (and (and (and (= (type |l#0@@90|) refType) (= (type |l#1@@68|) (MapType0Type refType MapType1Type))) (= (type |l#2@@67|) (FieldType boolType))) (= (type $o@@139) refType)) (= (type $f@@69) (FieldType alpha@@76))) (= (U_2_bool (MapType6Select (|lambda#71| |l#0@@90| |l#1@@68| |l#2@@67| |l#3@@67|) $o@@139 $f@@69))  (=> (and (not (= $o@@139 |l#0@@90|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@68| $o@@139) |l#2@@67|))) |l#3@@67|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5100|
 :pattern ( (MapType6Select (|lambda#71| |l#0@@90| |l#1@@68| |l#2@@67| |l#3@@67|) $o@@139 $f@@69))
)))
(assert (forall ((arg0@@729 T@U) (arg1@@423 T@U) (arg2@@243 T@U) (arg3@@170 Bool) ) (! (= (type (|lambda#72| arg0@@729 arg1@@423 arg2@@243 arg3@@170)) (MapType6Type refType boolType))
 :qid |funType:lambda#72|
 :pattern ( (|lambda#72| arg0@@729 arg1@@423 arg2@@243 arg3@@170))
)))
(assert (forall ((|l#0@@91| T@U) (|l#1@@69| T@U) (|l#2@@68| T@U) (|l#3@@68| Bool) ($o@@140 T@U) ($f@@70 T@U) ) (! (let ((alpha@@77 (FieldTypeInv0 (type $f@@70))))
 (=> (and (and (and (and (= (type |l#0@@91|) refType) (= (type |l#1@@69|) (MapType0Type refType MapType1Type))) (= (type |l#2@@68|) (FieldType boolType))) (= (type $o@@140) refType)) (= (type $f@@70) (FieldType alpha@@77))) (= (U_2_bool (MapType6Select (|lambda#72| |l#0@@91| |l#1@@69| |l#2@@68| |l#3@@68|) $o@@140 $f@@70))  (=> (and (not (= $o@@140 |l#0@@91|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@69| $o@@140) |l#2@@68|))) |l#3@@68|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5101|
 :pattern ( (MapType6Select (|lambda#72| |l#0@@91| |l#1@@69| |l#2@@68| |l#3@@68|) $o@@140 $f@@70))
)))
(assert (forall ((arg0@@730 T@U) (arg1@@424 T@U) (arg2@@244 T@U) (arg3@@171 Bool) ) (! (= (type (|lambda#73| arg0@@730 arg1@@424 arg2@@244 arg3@@171)) (MapType6Type refType boolType))
 :qid |funType:lambda#73|
 :pattern ( (|lambda#73| arg0@@730 arg1@@424 arg2@@244 arg3@@171))
)))
(assert (forall ((|l#0@@92| T@U) (|l#1@@70| T@U) (|l#2@@69| T@U) (|l#3@@69| Bool) ($o@@141 T@U) ($f@@71 T@U) ) (! (let ((alpha@@78 (FieldTypeInv0 (type $f@@71))))
 (=> (and (and (and (and (= (type |l#0@@92|) refType) (= (type |l#1@@70|) (MapType0Type refType MapType1Type))) (= (type |l#2@@69|) (FieldType boolType))) (= (type $o@@141) refType)) (= (type $f@@71) (FieldType alpha@@78))) (= (U_2_bool (MapType6Select (|lambda#73| |l#0@@92| |l#1@@70| |l#2@@69| |l#3@@69|) $o@@141 $f@@71))  (=> (and (not (= $o@@141 |l#0@@92|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@70| $o@@141) |l#2@@69|))) |l#3@@69|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5102|
 :pattern ( (MapType6Select (|lambda#73| |l#0@@92| |l#1@@70| |l#2@@69| |l#3@@69|) $o@@141 $f@@71))
)))
(assert (forall ((arg0@@731 T@U) (arg1@@425 T@U) (arg2@@245 T@U) (arg3@@172 Bool) ) (! (= (type (|lambda#74| arg0@@731 arg1@@425 arg2@@245 arg3@@172)) (MapType6Type refType boolType))
 :qid |funType:lambda#74|
 :pattern ( (|lambda#74| arg0@@731 arg1@@425 arg2@@245 arg3@@172))
)))
(assert (forall ((|l#0@@93| T@U) (|l#1@@71| T@U) (|l#2@@70| T@U) (|l#3@@70| Bool) ($o@@142 T@U) ($f@@72 T@U) ) (! (let ((alpha@@79 (FieldTypeInv0 (type $f@@72))))
 (=> (and (and (and (and (= (type |l#0@@93|) refType) (= (type |l#1@@71|) (MapType0Type refType MapType1Type))) (= (type |l#2@@70|) (FieldType boolType))) (= (type $o@@142) refType)) (= (type $f@@72) (FieldType alpha@@79))) (= (U_2_bool (MapType6Select (|lambda#74| |l#0@@93| |l#1@@71| |l#2@@70| |l#3@@70|) $o@@142 $f@@72))  (=> (and (not (= $o@@142 |l#0@@93|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@71| $o@@142) |l#2@@70|))) |l#3@@70|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5103|
 :pattern ( (MapType6Select (|lambda#74| |l#0@@93| |l#1@@71| |l#2@@70| |l#3@@70|) $o@@142 $f@@72))
)))
(assert (forall ((arg0@@732 T@U) (arg1@@426 T@U) (arg2@@246 T@U) (arg3@@173 Bool) ) (! (= (type (|lambda#75| arg0@@732 arg1@@426 arg2@@246 arg3@@173)) (MapType6Type refType boolType))
 :qid |funType:lambda#75|
 :pattern ( (|lambda#75| arg0@@732 arg1@@426 arg2@@246 arg3@@173))
)))
(assert (forall ((|l#0@@94| T@U) (|l#1@@72| T@U) (|l#2@@71| T@U) (|l#3@@71| Bool) ($o@@143 T@U) ($f@@73 T@U) ) (! (let ((alpha@@80 (FieldTypeInv0 (type $f@@73))))
 (=> (and (and (and (and (= (type |l#0@@94|) refType) (= (type |l#1@@72|) (MapType0Type refType MapType1Type))) (= (type |l#2@@71|) (FieldType boolType))) (= (type $o@@143) refType)) (= (type $f@@73) (FieldType alpha@@80))) (= (U_2_bool (MapType6Select (|lambda#75| |l#0@@94| |l#1@@72| |l#2@@71| |l#3@@71|) $o@@143 $f@@73))  (=> (and (not (= $o@@143 |l#0@@94|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@72| $o@@143) |l#2@@71|))) |l#3@@71|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5104|
 :pattern ( (MapType6Select (|lambda#75| |l#0@@94| |l#1@@72| |l#2@@71| |l#3@@71|) $o@@143 $f@@73))
)))
(assert (forall ((arg0@@733 T@U) (arg1@@427 T@U) (arg2@@247 T@U) (arg3@@174 Bool) ) (! (= (type (|lambda#76| arg0@@733 arg1@@427 arg2@@247 arg3@@174)) (MapType6Type refType boolType))
 :qid |funType:lambda#76|
 :pattern ( (|lambda#76| arg0@@733 arg1@@427 arg2@@247 arg3@@174))
)))
(assert (forall ((|l#0@@95| T@U) (|l#1@@73| T@U) (|l#2@@72| T@U) (|l#3@@72| Bool) ($o@@144 T@U) ($f@@74 T@U) ) (! (let ((alpha@@81 (FieldTypeInv0 (type $f@@74))))
 (=> (and (and (and (and (= (type |l#0@@95|) refType) (= (type |l#1@@73|) (MapType0Type refType MapType1Type))) (= (type |l#2@@72|) (FieldType boolType))) (= (type $o@@144) refType)) (= (type $f@@74) (FieldType alpha@@81))) (= (U_2_bool (MapType6Select (|lambda#76| |l#0@@95| |l#1@@73| |l#2@@72| |l#3@@72|) $o@@144 $f@@74))  (=> (and (not (= $o@@144 |l#0@@95|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@73| $o@@144) |l#2@@72|))) |l#3@@72|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5105|
 :pattern ( (MapType6Select (|lambda#76| |l#0@@95| |l#1@@73| |l#2@@72| |l#3@@72|) $o@@144 $f@@74))
)))
(assert (forall ((arg0@@734 T@U) (arg1@@428 T@U) (arg2@@248 T@U) (arg3@@175 Bool) ) (! (= (type (|lambda#77| arg0@@734 arg1@@428 arg2@@248 arg3@@175)) (MapType6Type refType boolType))
 :qid |funType:lambda#77|
 :pattern ( (|lambda#77| arg0@@734 arg1@@428 arg2@@248 arg3@@175))
)))
(assert (forall ((|l#0@@96| T@U) (|l#1@@74| T@U) (|l#2@@73| T@U) (|l#3@@73| Bool) ($o@@145 T@U) ($f@@75 T@U) ) (! (let ((alpha@@82 (FieldTypeInv0 (type $f@@75))))
 (=> (and (and (and (and (= (type |l#0@@96|) refType) (= (type |l#1@@74|) (MapType0Type refType MapType1Type))) (= (type |l#2@@73|) (FieldType boolType))) (= (type $o@@145) refType)) (= (type $f@@75) (FieldType alpha@@82))) (= (U_2_bool (MapType6Select (|lambda#77| |l#0@@96| |l#1@@74| |l#2@@73| |l#3@@73|) $o@@145 $f@@75))  (=> (and (not (= $o@@145 |l#0@@96|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@74| $o@@145) |l#2@@73|))) |l#3@@73|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5106|
 :pattern ( (MapType6Select (|lambda#77| |l#0@@96| |l#1@@74| |l#2@@73| |l#3@@73|) $o@@145 $f@@75))
)))
(assert (forall ((arg0@@735 T@U) (arg1@@429 T@U) (arg2@@249 T@U) (arg3@@176 Bool) ) (! (= (type (|lambda#78| arg0@@735 arg1@@429 arg2@@249 arg3@@176)) (MapType6Type refType boolType))
 :qid |funType:lambda#78|
 :pattern ( (|lambda#78| arg0@@735 arg1@@429 arg2@@249 arg3@@176))
)))
(assert (forall ((|l#0@@97| T@U) (|l#1@@75| T@U) (|l#2@@74| T@U) (|l#3@@74| Bool) ($o@@146 T@U) ($f@@76 T@U) ) (! (let ((alpha@@83 (FieldTypeInv0 (type $f@@76))))
 (=> (and (and (and (and (= (type |l#0@@97|) refType) (= (type |l#1@@75|) (MapType0Type refType MapType1Type))) (= (type |l#2@@74|) (FieldType boolType))) (= (type $o@@146) refType)) (= (type $f@@76) (FieldType alpha@@83))) (= (U_2_bool (MapType6Select (|lambda#78| |l#0@@97| |l#1@@75| |l#2@@74| |l#3@@74|) $o@@146 $f@@76))  (=> (and (not (= $o@@146 |l#0@@97|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@75| $o@@146) |l#2@@74|))) |l#3@@74|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5107|
 :pattern ( (MapType6Select (|lambda#78| |l#0@@97| |l#1@@75| |l#2@@74| |l#3@@74|) $o@@146 $f@@76))
)))
(assert (forall ((arg0@@736 T@U) (arg1@@430 T@U) (arg2@@250 T@U) (arg3@@177 Bool) ) (! (= (type (|lambda#79| arg0@@736 arg1@@430 arg2@@250 arg3@@177)) (MapType6Type refType boolType))
 :qid |funType:lambda#79|
 :pattern ( (|lambda#79| arg0@@736 arg1@@430 arg2@@250 arg3@@177))
)))
(assert (forall ((|l#0@@98| T@U) (|l#1@@76| T@U) (|l#2@@75| T@U) (|l#3@@75| Bool) ($o@@147 T@U) ($f@@77 T@U) ) (! (let ((alpha@@84 (FieldTypeInv0 (type $f@@77))))
 (=> (and (and (and (and (= (type |l#0@@98|) refType) (= (type |l#1@@76|) (MapType0Type refType MapType1Type))) (= (type |l#2@@75|) (FieldType boolType))) (= (type $o@@147) refType)) (= (type $f@@77) (FieldType alpha@@84))) (= (U_2_bool (MapType6Select (|lambda#79| |l#0@@98| |l#1@@76| |l#2@@75| |l#3@@75|) $o@@147 $f@@77))  (=> (and (not (= $o@@147 |l#0@@98|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@76| $o@@147) |l#2@@75|))) |l#3@@75|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5108|
 :pattern ( (MapType6Select (|lambda#79| |l#0@@98| |l#1@@76| |l#2@@75| |l#3@@75|) $o@@147 $f@@77))
)))
(assert (forall ((arg0@@737 T@U) (arg1@@431 T@U) (arg2@@251 T@U) (arg3@@178 Bool) ) (! (= (type (|lambda#80| arg0@@737 arg1@@431 arg2@@251 arg3@@178)) (MapType6Type refType boolType))
 :qid |funType:lambda#80|
 :pattern ( (|lambda#80| arg0@@737 arg1@@431 arg2@@251 arg3@@178))
)))
(assert (forall ((|l#0@@99| T@U) (|l#1@@77| T@U) (|l#2@@76| T@U) (|l#3@@76| Bool) ($o@@148 T@U) ($f@@78 T@U) ) (! (let ((alpha@@85 (FieldTypeInv0 (type $f@@78))))
 (=> (and (and (and (and (= (type |l#0@@99|) refType) (= (type |l#1@@77|) (MapType0Type refType MapType1Type))) (= (type |l#2@@76|) (FieldType boolType))) (= (type $o@@148) refType)) (= (type $f@@78) (FieldType alpha@@85))) (= (U_2_bool (MapType6Select (|lambda#80| |l#0@@99| |l#1@@77| |l#2@@76| |l#3@@76|) $o@@148 $f@@78))  (=> (and (not (= $o@@148 |l#0@@99|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@77| $o@@148) |l#2@@76|))) |l#3@@76|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5109|
 :pattern ( (MapType6Select (|lambda#80| |l#0@@99| |l#1@@77| |l#2@@76| |l#3@@76|) $o@@148 $f@@78))
)))
(assert (forall ((arg0@@738 T@U) (arg1@@432 T@U) (arg2@@252 T@U) (arg3@@179 Bool) ) (! (= (type (|lambda#81| arg0@@738 arg1@@432 arg2@@252 arg3@@179)) (MapType6Type refType boolType))
 :qid |funType:lambda#81|
 :pattern ( (|lambda#81| arg0@@738 arg1@@432 arg2@@252 arg3@@179))
)))
(assert (forall ((|l#0@@100| T@U) (|l#1@@78| T@U) (|l#2@@77| T@U) (|l#3@@77| Bool) ($o@@149 T@U) ($f@@79 T@U) ) (! (let ((alpha@@86 (FieldTypeInv0 (type $f@@79))))
 (=> (and (and (and (and (= (type |l#0@@100|) refType) (= (type |l#1@@78|) (MapType0Type refType MapType1Type))) (= (type |l#2@@77|) (FieldType boolType))) (= (type $o@@149) refType)) (= (type $f@@79) (FieldType alpha@@86))) (= (U_2_bool (MapType6Select (|lambda#81| |l#0@@100| |l#1@@78| |l#2@@77| |l#3@@77|) $o@@149 $f@@79))  (=> (and (not (= $o@@149 |l#0@@100|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@78| $o@@149) |l#2@@77|))) |l#3@@77|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5110|
 :pattern ( (MapType6Select (|lambda#81| |l#0@@100| |l#1@@78| |l#2@@77| |l#3@@77|) $o@@149 $f@@79))
)))
(assert (forall ((arg0@@739 T@U) (arg1@@433 T@U) (arg2@@253 T@U) (arg3@@180 Bool) ) (! (= (type (|lambda#82| arg0@@739 arg1@@433 arg2@@253 arg3@@180)) (MapType6Type refType boolType))
 :qid |funType:lambda#82|
 :pattern ( (|lambda#82| arg0@@739 arg1@@433 arg2@@253 arg3@@180))
)))
(assert (forall ((|l#0@@101| T@U) (|l#1@@79| T@U) (|l#2@@78| T@U) (|l#3@@78| Bool) ($o@@150 T@U) ($f@@80 T@U) ) (! (let ((alpha@@87 (FieldTypeInv0 (type $f@@80))))
 (=> (and (and (and (and (= (type |l#0@@101|) refType) (= (type |l#1@@79|) (MapType0Type refType MapType1Type))) (= (type |l#2@@78|) (FieldType boolType))) (= (type $o@@150) refType)) (= (type $f@@80) (FieldType alpha@@87))) (= (U_2_bool (MapType6Select (|lambda#82| |l#0@@101| |l#1@@79| |l#2@@78| |l#3@@78|) $o@@150 $f@@80))  (=> (and (not (= $o@@150 |l#0@@101|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@79| $o@@150) |l#2@@78|))) |l#3@@78|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5111|
 :pattern ( (MapType6Select (|lambda#82| |l#0@@101| |l#1@@79| |l#2@@78| |l#3@@78|) $o@@150 $f@@80))
)))
(assert (forall ((arg0@@740 T@U) (arg1@@434 T@U) (arg2@@254 T@U) (arg3@@181 Bool) ) (! (= (type (|lambda#83| arg0@@740 arg1@@434 arg2@@254 arg3@@181)) (MapType6Type refType boolType))
 :qid |funType:lambda#83|
 :pattern ( (|lambda#83| arg0@@740 arg1@@434 arg2@@254 arg3@@181))
)))
(assert (forall ((|l#0@@102| T@U) (|l#1@@80| T@U) (|l#2@@79| T@U) (|l#3@@79| Bool) ($o@@151 T@U) ($f@@81 T@U) ) (! (let ((alpha@@88 (FieldTypeInv0 (type $f@@81))))
 (=> (and (and (and (and (= (type |l#0@@102|) refType) (= (type |l#1@@80|) (MapType0Type refType MapType1Type))) (= (type |l#2@@79|) (FieldType boolType))) (= (type $o@@151) refType)) (= (type $f@@81) (FieldType alpha@@88))) (= (U_2_bool (MapType6Select (|lambda#83| |l#0@@102| |l#1@@80| |l#2@@79| |l#3@@79|) $o@@151 $f@@81))  (=> (and (not (= $o@@151 |l#0@@102|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@80| $o@@151) |l#2@@79|))) |l#3@@79|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5112|
 :pattern ( (MapType6Select (|lambda#83| |l#0@@102| |l#1@@80| |l#2@@79| |l#3@@79|) $o@@151 $f@@81))
)))
(assert (forall ((arg0@@741 T@U) (arg1@@435 T@U) (arg2@@255 T@U) (arg3@@182 Bool) ) (! (= (type (|lambda#84| arg0@@741 arg1@@435 arg2@@255 arg3@@182)) (MapType6Type refType boolType))
 :qid |funType:lambda#84|
 :pattern ( (|lambda#84| arg0@@741 arg1@@435 arg2@@255 arg3@@182))
)))
(assert (forall ((|l#0@@103| T@U) (|l#1@@81| T@U) (|l#2@@80| T@U) (|l#3@@80| Bool) ($o@@152 T@U) ($f@@82 T@U) ) (! (let ((alpha@@89 (FieldTypeInv0 (type $f@@82))))
 (=> (and (and (and (and (= (type |l#0@@103|) refType) (= (type |l#1@@81|) (MapType0Type refType MapType1Type))) (= (type |l#2@@80|) (FieldType boolType))) (= (type $o@@152) refType)) (= (type $f@@82) (FieldType alpha@@89))) (= (U_2_bool (MapType6Select (|lambda#84| |l#0@@103| |l#1@@81| |l#2@@80| |l#3@@80|) $o@@152 $f@@82))  (=> (and (not (= $o@@152 |l#0@@103|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@81| $o@@152) |l#2@@80|))) |l#3@@80|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5113|
 :pattern ( (MapType6Select (|lambda#84| |l#0@@103| |l#1@@81| |l#2@@80| |l#3@@80|) $o@@152 $f@@82))
)))
(assert (forall ((arg0@@742 T@U) (arg1@@436 T@U) (arg2@@256 T@U) (arg3@@183 Bool) ) (! (= (type (|lambda#85| arg0@@742 arg1@@436 arg2@@256 arg3@@183)) (MapType6Type refType boolType))
 :qid |funType:lambda#85|
 :pattern ( (|lambda#85| arg0@@742 arg1@@436 arg2@@256 arg3@@183))
)))
(assert (forall ((|l#0@@104| T@U) (|l#1@@82| T@U) (|l#2@@81| T@U) (|l#3@@81| Bool) ($o@@153 T@U) ($f@@83 T@U) ) (! (let ((alpha@@90 (FieldTypeInv0 (type $f@@83))))
 (=> (and (and (and (and (= (type |l#0@@104|) refType) (= (type |l#1@@82|) (MapType0Type refType MapType1Type))) (= (type |l#2@@81|) (FieldType boolType))) (= (type $o@@153) refType)) (= (type $f@@83) (FieldType alpha@@90))) (= (U_2_bool (MapType6Select (|lambda#85| |l#0@@104| |l#1@@82| |l#2@@81| |l#3@@81|) $o@@153 $f@@83))  (=> (and (not (= $o@@153 |l#0@@104|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@82| $o@@153) |l#2@@81|))) |l#3@@81|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5114|
 :pattern ( (MapType6Select (|lambda#85| |l#0@@104| |l#1@@82| |l#2@@81| |l#3@@81|) $o@@153 $f@@83))
)))
(assert (forall ((arg0@@743 T@U) (arg1@@437 T@U) (arg2@@257 T@U) (arg3@@184 Bool) ) (! (= (type (|lambda#86| arg0@@743 arg1@@437 arg2@@257 arg3@@184)) (MapType6Type refType boolType))
 :qid |funType:lambda#86|
 :pattern ( (|lambda#86| arg0@@743 arg1@@437 arg2@@257 arg3@@184))
)))
(assert (forall ((|l#0@@105| T@U) (|l#1@@83| T@U) (|l#2@@82| T@U) (|l#3@@82| Bool) ($o@@154 T@U) ($f@@84 T@U) ) (! (let ((alpha@@91 (FieldTypeInv0 (type $f@@84))))
 (=> (and (and (and (and (= (type |l#0@@105|) refType) (= (type |l#1@@83|) (MapType0Type refType MapType1Type))) (= (type |l#2@@82|) (FieldType boolType))) (= (type $o@@154) refType)) (= (type $f@@84) (FieldType alpha@@91))) (= (U_2_bool (MapType6Select (|lambda#86| |l#0@@105| |l#1@@83| |l#2@@82| |l#3@@82|) $o@@154 $f@@84))  (=> (and (not (= $o@@154 |l#0@@105|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@83| $o@@154) |l#2@@82|))) |l#3@@82|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5115|
 :pattern ( (MapType6Select (|lambda#86| |l#0@@105| |l#1@@83| |l#2@@82| |l#3@@82|) $o@@154 $f@@84))
)))
(assert (forall ((arg0@@744 T@U) (arg1@@438 T@U) (arg2@@258 T@U) (arg3@@185 Bool) ) (! (= (type (|lambda#87| arg0@@744 arg1@@438 arg2@@258 arg3@@185)) (MapType6Type refType boolType))
 :qid |funType:lambda#87|
 :pattern ( (|lambda#87| arg0@@744 arg1@@438 arg2@@258 arg3@@185))
)))
(assert (forall ((|l#0@@106| T@U) (|l#1@@84| T@U) (|l#2@@83| T@U) (|l#3@@83| Bool) ($o@@155 T@U) ($f@@85 T@U) ) (! (let ((alpha@@92 (FieldTypeInv0 (type $f@@85))))
 (=> (and (and (and (and (= (type |l#0@@106|) refType) (= (type |l#1@@84|) (MapType0Type refType MapType1Type))) (= (type |l#2@@83|) (FieldType boolType))) (= (type $o@@155) refType)) (= (type $f@@85) (FieldType alpha@@92))) (= (U_2_bool (MapType6Select (|lambda#87| |l#0@@106| |l#1@@84| |l#2@@83| |l#3@@83|) $o@@155 $f@@85))  (=> (and (not (= $o@@155 |l#0@@106|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@84| $o@@155) |l#2@@83|))) |l#3@@83|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5116|
 :pattern ( (MapType6Select (|lambda#87| |l#0@@106| |l#1@@84| |l#2@@83| |l#3@@83|) $o@@155 $f@@85))
)))
(assert (forall ((arg0@@745 T@U) (arg1@@439 T@U) (arg2@@259 T@U) (arg3@@186 Bool) ) (! (= (type (|lambda#88| arg0@@745 arg1@@439 arg2@@259 arg3@@186)) (MapType6Type refType boolType))
 :qid |funType:lambda#88|
 :pattern ( (|lambda#88| arg0@@745 arg1@@439 arg2@@259 arg3@@186))
)))
(assert (forall ((|l#0@@107| T@U) (|l#1@@85| T@U) (|l#2@@84| T@U) (|l#3@@84| Bool) ($o@@156 T@U) ($f@@86 T@U) ) (! (let ((alpha@@93 (FieldTypeInv0 (type $f@@86))))
 (=> (and (and (and (and (= (type |l#0@@107|) refType) (= (type |l#1@@85|) (MapType0Type refType MapType1Type))) (= (type |l#2@@84|) (FieldType boolType))) (= (type $o@@156) refType)) (= (type $f@@86) (FieldType alpha@@93))) (= (U_2_bool (MapType6Select (|lambda#88| |l#0@@107| |l#1@@85| |l#2@@84| |l#3@@84|) $o@@156 $f@@86))  (=> (and (not (= $o@@156 |l#0@@107|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@85| $o@@156) |l#2@@84|))) |l#3@@84|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5117|
 :pattern ( (MapType6Select (|lambda#88| |l#0@@107| |l#1@@85| |l#2@@84| |l#3@@84|) $o@@156 $f@@86))
)))
(assert (forall ((arg0@@746 T@U) (arg1@@440 T@U) (arg2@@260 T@U) (arg3@@187 Bool) ) (! (= (type (|lambda#89| arg0@@746 arg1@@440 arg2@@260 arg3@@187)) (MapType6Type refType boolType))
 :qid |funType:lambda#89|
 :pattern ( (|lambda#89| arg0@@746 arg1@@440 arg2@@260 arg3@@187))
)))
(assert (forall ((|l#0@@108| T@U) (|l#1@@86| T@U) (|l#2@@85| T@U) (|l#3@@85| Bool) ($o@@157 T@U) ($f@@87 T@U) ) (! (let ((alpha@@94 (FieldTypeInv0 (type $f@@87))))
 (=> (and (and (and (and (= (type |l#0@@108|) refType) (= (type |l#1@@86|) (MapType0Type refType MapType1Type))) (= (type |l#2@@85|) (FieldType boolType))) (= (type $o@@157) refType)) (= (type $f@@87) (FieldType alpha@@94))) (= (U_2_bool (MapType6Select (|lambda#89| |l#0@@108| |l#1@@86| |l#2@@85| |l#3@@85|) $o@@157 $f@@87))  (=> (and (not (= $o@@157 |l#0@@108|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@86| $o@@157) |l#2@@85|))) |l#3@@85|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5118|
 :pattern ( (MapType6Select (|lambda#89| |l#0@@108| |l#1@@86| |l#2@@85| |l#3@@85|) $o@@157 $f@@87))
)))
(assert (forall ((arg0@@747 T@U) (arg1@@441 T@U) (arg2@@261 T@U) (arg3@@188 Bool) ) (! (= (type (|lambda#90| arg0@@747 arg1@@441 arg2@@261 arg3@@188)) (MapType6Type refType boolType))
 :qid |funType:lambda#90|
 :pattern ( (|lambda#90| arg0@@747 arg1@@441 arg2@@261 arg3@@188))
)))
(assert (forall ((|l#0@@109| T@U) (|l#1@@87| T@U) (|l#2@@86| T@U) (|l#3@@86| Bool) ($o@@158 T@U) ($f@@88 T@U) ) (! (let ((alpha@@95 (FieldTypeInv0 (type $f@@88))))
 (=> (and (and (and (and (= (type |l#0@@109|) refType) (= (type |l#1@@87|) (MapType0Type refType MapType1Type))) (= (type |l#2@@86|) (FieldType boolType))) (= (type $o@@158) refType)) (= (type $f@@88) (FieldType alpha@@95))) (= (U_2_bool (MapType6Select (|lambda#90| |l#0@@109| |l#1@@87| |l#2@@86| |l#3@@86|) $o@@158 $f@@88))  (=> (and (not (= $o@@158 |l#0@@109|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@87| $o@@158) |l#2@@86|))) |l#3@@86|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5119|
 :pattern ( (MapType6Select (|lambda#90| |l#0@@109| |l#1@@87| |l#2@@86| |l#3@@86|) $o@@158 $f@@88))
)))
(assert (forall ((arg0@@748 T@U) (arg1@@442 T@U) (arg2@@262 T@U) (arg3@@189 Bool) ) (! (= (type (|lambda#91| arg0@@748 arg1@@442 arg2@@262 arg3@@189)) (MapType6Type refType boolType))
 :qid |funType:lambda#91|
 :pattern ( (|lambda#91| arg0@@748 arg1@@442 arg2@@262 arg3@@189))
)))
(assert (forall ((|l#0@@110| T@U) (|l#1@@88| T@U) (|l#2@@87| T@U) (|l#3@@87| Bool) ($o@@159 T@U) ($f@@89 T@U) ) (! (let ((alpha@@96 (FieldTypeInv0 (type $f@@89))))
 (=> (and (and (and (and (= (type |l#0@@110|) refType) (= (type |l#1@@88|) (MapType0Type refType MapType1Type))) (= (type |l#2@@87|) (FieldType boolType))) (= (type $o@@159) refType)) (= (type $f@@89) (FieldType alpha@@96))) (= (U_2_bool (MapType6Select (|lambda#91| |l#0@@110| |l#1@@88| |l#2@@87| |l#3@@87|) $o@@159 $f@@89))  (=> (and (not (= $o@@159 |l#0@@110|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@88| $o@@159) |l#2@@87|))) |l#3@@87|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5120|
 :pattern ( (MapType6Select (|lambda#91| |l#0@@110| |l#1@@88| |l#2@@87| |l#3@@87|) $o@@159 $f@@89))
)))
(assert (forall ((arg0@@749 T@U) (arg1@@443 T@U) (arg2@@263 T@U) (arg3@@190 Bool) ) (! (= (type (|lambda#92| arg0@@749 arg1@@443 arg2@@263 arg3@@190)) (MapType6Type refType boolType))
 :qid |funType:lambda#92|
 :pattern ( (|lambda#92| arg0@@749 arg1@@443 arg2@@263 arg3@@190))
)))
(assert (forall ((|l#0@@111| T@U) (|l#1@@89| T@U) (|l#2@@88| T@U) (|l#3@@88| Bool) ($o@@160 T@U) ($f@@90 T@U) ) (! (let ((alpha@@97 (FieldTypeInv0 (type $f@@90))))
 (=> (and (and (and (and (= (type |l#0@@111|) refType) (= (type |l#1@@89|) (MapType0Type refType MapType1Type))) (= (type |l#2@@88|) (FieldType boolType))) (= (type $o@@160) refType)) (= (type $f@@90) (FieldType alpha@@97))) (= (U_2_bool (MapType6Select (|lambda#92| |l#0@@111| |l#1@@89| |l#2@@88| |l#3@@88|) $o@@160 $f@@90))  (=> (and (not (= $o@@160 |l#0@@111|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@89| $o@@160) |l#2@@88|))) |l#3@@88|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5121|
 :pattern ( (MapType6Select (|lambda#92| |l#0@@111| |l#1@@89| |l#2@@88| |l#3@@88|) $o@@160 $f@@90))
)))
(assert (forall ((arg0@@750 T@U) (arg1@@444 T@U) (arg2@@264 T@U) (arg3@@191 Bool) ) (! (= (type (|lambda#93| arg0@@750 arg1@@444 arg2@@264 arg3@@191)) (MapType6Type refType boolType))
 :qid |funType:lambda#93|
 :pattern ( (|lambda#93| arg0@@750 arg1@@444 arg2@@264 arg3@@191))
)))
(assert (forall ((|l#0@@112| T@U) (|l#1@@90| T@U) (|l#2@@89| T@U) (|l#3@@89| Bool) ($o@@161 T@U) ($f@@91 T@U) ) (! (let ((alpha@@98 (FieldTypeInv0 (type $f@@91))))
 (=> (and (and (and (and (= (type |l#0@@112|) refType) (= (type |l#1@@90|) (MapType0Type refType MapType1Type))) (= (type |l#2@@89|) (FieldType boolType))) (= (type $o@@161) refType)) (= (type $f@@91) (FieldType alpha@@98))) (= (U_2_bool (MapType6Select (|lambda#93| |l#0@@112| |l#1@@90| |l#2@@89| |l#3@@89|) $o@@161 $f@@91))  (=> (and (not (= $o@@161 |l#0@@112|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@90| $o@@161) |l#2@@89|))) |l#3@@89|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5122|
 :pattern ( (MapType6Select (|lambda#93| |l#0@@112| |l#1@@90| |l#2@@89| |l#3@@89|) $o@@161 $f@@91))
)))
(assert (forall ((arg0@@751 T@U) (arg1@@445 T@U) (arg2@@265 T@U) (arg3@@192 Bool) ) (! (= (type (|lambda#94| arg0@@751 arg1@@445 arg2@@265 arg3@@192)) (MapType6Type refType boolType))
 :qid |funType:lambda#94|
 :pattern ( (|lambda#94| arg0@@751 arg1@@445 arg2@@265 arg3@@192))
)))
(assert (forall ((|l#0@@113| T@U) (|l#1@@91| T@U) (|l#2@@90| T@U) (|l#3@@90| Bool) ($o@@162 T@U) ($f@@92 T@U) ) (! (let ((alpha@@99 (FieldTypeInv0 (type $f@@92))))
 (=> (and (and (and (and (= (type |l#0@@113|) refType) (= (type |l#1@@91|) (MapType0Type refType MapType1Type))) (= (type |l#2@@90|) (FieldType boolType))) (= (type $o@@162) refType)) (= (type $f@@92) (FieldType alpha@@99))) (= (U_2_bool (MapType6Select (|lambda#94| |l#0@@113| |l#1@@91| |l#2@@90| |l#3@@90|) $o@@162 $f@@92))  (=> (and (not (= $o@@162 |l#0@@113|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@91| $o@@162) |l#2@@90|))) |l#3@@90|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5123|
 :pattern ( (MapType6Select (|lambda#94| |l#0@@113| |l#1@@91| |l#2@@90| |l#3@@90|) $o@@162 $f@@92))
)))
(assert (forall ((arg0@@752 T@U) (arg1@@446 T@U) (arg2@@266 T@U) (arg3@@193 Bool) ) (! (= (type (|lambda#95| arg0@@752 arg1@@446 arg2@@266 arg3@@193)) (MapType6Type refType boolType))
 :qid |funType:lambda#95|
 :pattern ( (|lambda#95| arg0@@752 arg1@@446 arg2@@266 arg3@@193))
)))
(assert (forall ((|l#0@@114| T@U) (|l#1@@92| T@U) (|l#2@@91| T@U) (|l#3@@91| Bool) ($o@@163 T@U) ($f@@93 T@U) ) (! (let ((alpha@@100 (FieldTypeInv0 (type $f@@93))))
 (=> (and (and (and (and (= (type |l#0@@114|) refType) (= (type |l#1@@92|) (MapType0Type refType MapType1Type))) (= (type |l#2@@91|) (FieldType boolType))) (= (type $o@@163) refType)) (= (type $f@@93) (FieldType alpha@@100))) (= (U_2_bool (MapType6Select (|lambda#95| |l#0@@114| |l#1@@92| |l#2@@91| |l#3@@91|) $o@@163 $f@@93))  (=> (and (not (= $o@@163 |l#0@@114|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@92| $o@@163) |l#2@@91|))) |l#3@@91|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5124|
 :pattern ( (MapType6Select (|lambda#95| |l#0@@114| |l#1@@92| |l#2@@91| |l#3@@91|) $o@@163 $f@@93))
)))
(assert (forall ((arg0@@753 T@U) (arg1@@447 T@U) (arg2@@267 T@U) (arg3@@194 Bool) ) (! (= (type (|lambda#96| arg0@@753 arg1@@447 arg2@@267 arg3@@194)) (MapType6Type refType boolType))
 :qid |funType:lambda#96|
 :pattern ( (|lambda#96| arg0@@753 arg1@@447 arg2@@267 arg3@@194))
)))
(assert (forall ((|l#0@@115| T@U) (|l#1@@93| T@U) (|l#2@@92| T@U) (|l#3@@92| Bool) ($o@@164 T@U) ($f@@94 T@U) ) (! (let ((alpha@@101 (FieldTypeInv0 (type $f@@94))))
 (=> (and (and (and (and (= (type |l#0@@115|) refType) (= (type |l#1@@93|) (MapType0Type refType MapType1Type))) (= (type |l#2@@92|) (FieldType boolType))) (= (type $o@@164) refType)) (= (type $f@@94) (FieldType alpha@@101))) (= (U_2_bool (MapType6Select (|lambda#96| |l#0@@115| |l#1@@93| |l#2@@92| |l#3@@92|) $o@@164 $f@@94))  (=> (and (not (= $o@@164 |l#0@@115|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@93| $o@@164) |l#2@@92|))) |l#3@@92|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5125|
 :pattern ( (MapType6Select (|lambda#96| |l#0@@115| |l#1@@93| |l#2@@92| |l#3@@92|) $o@@164 $f@@94))
)))
(assert (forall ((arg0@@754 T@U) (arg1@@448 T@U) (arg2@@268 T@U) (arg3@@195 Bool) ) (! (= (type (|lambda#97| arg0@@754 arg1@@448 arg2@@268 arg3@@195)) (MapType6Type refType boolType))
 :qid |funType:lambda#97|
 :pattern ( (|lambda#97| arg0@@754 arg1@@448 arg2@@268 arg3@@195))
)))
(assert (forall ((|l#0@@116| T@U) (|l#1@@94| T@U) (|l#2@@93| T@U) (|l#3@@93| Bool) ($o@@165 T@U) ($f@@95 T@U) ) (! (let ((alpha@@102 (FieldTypeInv0 (type $f@@95))))
 (=> (and (and (and (and (= (type |l#0@@116|) refType) (= (type |l#1@@94|) (MapType0Type refType MapType1Type))) (= (type |l#2@@93|) (FieldType boolType))) (= (type $o@@165) refType)) (= (type $f@@95) (FieldType alpha@@102))) (= (U_2_bool (MapType6Select (|lambda#97| |l#0@@116| |l#1@@94| |l#2@@93| |l#3@@93|) $o@@165 $f@@95))  (=> (and (not (= $o@@165 |l#0@@116|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@94| $o@@165) |l#2@@93|))) |l#3@@93|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5126|
 :pattern ( (MapType6Select (|lambda#97| |l#0@@116| |l#1@@94| |l#2@@93| |l#3@@93|) $o@@165 $f@@95))
)))
(assert (forall ((arg0@@755 T@U) (arg1@@449 T@U) (arg2@@269 T@U) (arg3@@196 Bool) ) (! (= (type (|lambda#98| arg0@@755 arg1@@449 arg2@@269 arg3@@196)) (MapType6Type refType boolType))
 :qid |funType:lambda#98|
 :pattern ( (|lambda#98| arg0@@755 arg1@@449 arg2@@269 arg3@@196))
)))
(assert (forall ((|l#0@@117| T@U) (|l#1@@95| T@U) (|l#2@@94| T@U) (|l#3@@94| Bool) ($o@@166 T@U) ($f@@96 T@U) ) (! (let ((alpha@@103 (FieldTypeInv0 (type $f@@96))))
 (=> (and (and (and (and (= (type |l#0@@117|) refType) (= (type |l#1@@95|) (MapType0Type refType MapType1Type))) (= (type |l#2@@94|) (FieldType boolType))) (= (type $o@@166) refType)) (= (type $f@@96) (FieldType alpha@@103))) (= (U_2_bool (MapType6Select (|lambda#98| |l#0@@117| |l#1@@95| |l#2@@94| |l#3@@94|) $o@@166 $f@@96))  (=> (and (not (= $o@@166 |l#0@@117|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@95| $o@@166) |l#2@@94|))) |l#3@@94|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5127|
 :pattern ( (MapType6Select (|lambda#98| |l#0@@117| |l#1@@95| |l#2@@94| |l#3@@94|) $o@@166 $f@@96))
)))
(assert (forall ((arg0@@756 T@U) (arg1@@450 T@U) (arg2@@270 T@U) (arg3@@197 Bool) ) (! (= (type (|lambda#99| arg0@@756 arg1@@450 arg2@@270 arg3@@197)) (MapType6Type refType boolType))
 :qid |funType:lambda#99|
 :pattern ( (|lambda#99| arg0@@756 arg1@@450 arg2@@270 arg3@@197))
)))
(assert (forall ((|l#0@@118| T@U) (|l#1@@96| T@U) (|l#2@@95| T@U) (|l#3@@95| Bool) ($o@@167 T@U) ($f@@97 T@U) ) (! (let ((alpha@@104 (FieldTypeInv0 (type $f@@97))))
 (=> (and (and (and (and (= (type |l#0@@118|) refType) (= (type |l#1@@96|) (MapType0Type refType MapType1Type))) (= (type |l#2@@95|) (FieldType boolType))) (= (type $o@@167) refType)) (= (type $f@@97) (FieldType alpha@@104))) (= (U_2_bool (MapType6Select (|lambda#99| |l#0@@118| |l#1@@96| |l#2@@95| |l#3@@95|) $o@@167 $f@@97))  (=> (and (not (= $o@@167 |l#0@@118|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@96| $o@@167) |l#2@@95|))) |l#3@@95|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5128|
 :pattern ( (MapType6Select (|lambda#99| |l#0@@118| |l#1@@96| |l#2@@95| |l#3@@95|) $o@@167 $f@@97))
)))
(assert (forall ((arg0@@757 T@U) (arg1@@451 T@U) (arg2@@271 T@U) (arg3@@198 Bool) ) (! (= (type (|lambda#100| arg0@@757 arg1@@451 arg2@@271 arg3@@198)) (MapType6Type refType boolType))
 :qid |funType:lambda#100|
 :pattern ( (|lambda#100| arg0@@757 arg1@@451 arg2@@271 arg3@@198))
)))
(assert (forall ((|l#0@@119| T@U) (|l#1@@97| T@U) (|l#2@@96| T@U) (|l#3@@96| Bool) ($o@@168 T@U) ($f@@98 T@U) ) (! (let ((alpha@@105 (FieldTypeInv0 (type $f@@98))))
 (=> (and (and (and (and (= (type |l#0@@119|) refType) (= (type |l#1@@97|) (MapType0Type refType MapType1Type))) (= (type |l#2@@96|) (FieldType boolType))) (= (type $o@@168) refType)) (= (type $f@@98) (FieldType alpha@@105))) (= (U_2_bool (MapType6Select (|lambda#100| |l#0@@119| |l#1@@97| |l#2@@96| |l#3@@96|) $o@@168 $f@@98))  (=> (and (not (= $o@@168 |l#0@@119|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@97| $o@@168) |l#2@@96|))) |l#3@@96|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5129|
 :pattern ( (MapType6Select (|lambda#100| |l#0@@119| |l#1@@97| |l#2@@96| |l#3@@96|) $o@@168 $f@@98))
)))
(assert (forall ((arg0@@758 T@U) (arg1@@452 T@U) (arg2@@272 T@U) (arg3@@199 Bool) ) (! (= (type (|lambda#101| arg0@@758 arg1@@452 arg2@@272 arg3@@199)) (MapType6Type refType boolType))
 :qid |funType:lambda#101|
 :pattern ( (|lambda#101| arg0@@758 arg1@@452 arg2@@272 arg3@@199))
)))
(assert (forall ((|l#0@@120| T@U) (|l#1@@98| T@U) (|l#2@@97| T@U) (|l#3@@97| Bool) ($o@@169 T@U) ($f@@99 T@U) ) (! (let ((alpha@@106 (FieldTypeInv0 (type $f@@99))))
 (=> (and (and (and (and (= (type |l#0@@120|) refType) (= (type |l#1@@98|) (MapType0Type refType MapType1Type))) (= (type |l#2@@97|) (FieldType boolType))) (= (type $o@@169) refType)) (= (type $f@@99) (FieldType alpha@@106))) (= (U_2_bool (MapType6Select (|lambda#101| |l#0@@120| |l#1@@98| |l#2@@97| |l#3@@97|) $o@@169 $f@@99))  (=> (and (not (= $o@@169 |l#0@@120|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@98| $o@@169) |l#2@@97|))) |l#3@@97|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5130|
 :pattern ( (MapType6Select (|lambda#101| |l#0@@120| |l#1@@98| |l#2@@97| |l#3@@97|) $o@@169 $f@@99))
)))
(assert (forall ((arg0@@759 T@U) (arg1@@453 T@U) (arg2@@273 T@U) (arg3@@200 Bool) ) (! (= (type (|lambda#102| arg0@@759 arg1@@453 arg2@@273 arg3@@200)) (MapType6Type refType boolType))
 :qid |funType:lambda#102|
 :pattern ( (|lambda#102| arg0@@759 arg1@@453 arg2@@273 arg3@@200))
)))
(assert (forall ((|l#0@@121| T@U) (|l#1@@99| T@U) (|l#2@@98| T@U) (|l#3@@98| Bool) ($o@@170 T@U) ($f@@100 T@U) ) (! (let ((alpha@@107 (FieldTypeInv0 (type $f@@100))))
 (=> (and (and (and (and (= (type |l#0@@121|) refType) (= (type |l#1@@99|) (MapType0Type refType MapType1Type))) (= (type |l#2@@98|) (FieldType boolType))) (= (type $o@@170) refType)) (= (type $f@@100) (FieldType alpha@@107))) (= (U_2_bool (MapType6Select (|lambda#102| |l#0@@121| |l#1@@99| |l#2@@98| |l#3@@98|) $o@@170 $f@@100))  (=> (and (not (= $o@@170 |l#0@@121|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@99| $o@@170) |l#2@@98|))) |l#3@@98|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5131|
 :pattern ( (MapType6Select (|lambda#102| |l#0@@121| |l#1@@99| |l#2@@98| |l#3@@98|) $o@@170 $f@@100))
)))
(assert (forall ((arg0@@760 T@U) (arg1@@454 T@U) (arg2@@274 T@U) (arg3@@201 Bool) ) (! (= (type (|lambda#103| arg0@@760 arg1@@454 arg2@@274 arg3@@201)) (MapType6Type refType boolType))
 :qid |funType:lambda#103|
 :pattern ( (|lambda#103| arg0@@760 arg1@@454 arg2@@274 arg3@@201))
)))
(assert (forall ((|l#0@@122| T@U) (|l#1@@100| T@U) (|l#2@@99| T@U) (|l#3@@99| Bool) ($o@@171 T@U) ($f@@101 T@U) ) (! (let ((alpha@@108 (FieldTypeInv0 (type $f@@101))))
 (=> (and (and (and (and (= (type |l#0@@122|) refType) (= (type |l#1@@100|) (MapType0Type refType MapType1Type))) (= (type |l#2@@99|) (FieldType boolType))) (= (type $o@@171) refType)) (= (type $f@@101) (FieldType alpha@@108))) (= (U_2_bool (MapType6Select (|lambda#103| |l#0@@122| |l#1@@100| |l#2@@99| |l#3@@99|) $o@@171 $f@@101))  (=> (and (not (= $o@@171 |l#0@@122|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@100| $o@@171) |l#2@@99|))) |l#3@@99|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5132|
 :pattern ( (MapType6Select (|lambda#103| |l#0@@122| |l#1@@100| |l#2@@99| |l#3@@99|) $o@@171 $f@@101))
)))
(assert (forall ((arg0@@761 T@U) (arg1@@455 T@U) (arg2@@275 T@U) (arg3@@202 Bool) ) (! (= (type (|lambda#104| arg0@@761 arg1@@455 arg2@@275 arg3@@202)) (MapType6Type refType boolType))
 :qid |funType:lambda#104|
 :pattern ( (|lambda#104| arg0@@761 arg1@@455 arg2@@275 arg3@@202))
)))
(assert (forall ((|l#0@@123| T@U) (|l#1@@101| T@U) (|l#2@@100| T@U) (|l#3@@100| Bool) ($o@@172 T@U) ($f@@102 T@U) ) (! (let ((alpha@@109 (FieldTypeInv0 (type $f@@102))))
 (=> (and (and (and (and (= (type |l#0@@123|) refType) (= (type |l#1@@101|) (MapType0Type refType MapType1Type))) (= (type |l#2@@100|) (FieldType boolType))) (= (type $o@@172) refType)) (= (type $f@@102) (FieldType alpha@@109))) (= (U_2_bool (MapType6Select (|lambda#104| |l#0@@123| |l#1@@101| |l#2@@100| |l#3@@100|) $o@@172 $f@@102))  (=> (and (not (= $o@@172 |l#0@@123|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@101| $o@@172) |l#2@@100|))) |l#3@@100|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5133|
 :pattern ( (MapType6Select (|lambda#104| |l#0@@123| |l#1@@101| |l#2@@100| |l#3@@100|) $o@@172 $f@@102))
)))
(assert (forall ((arg0@@762 T@U) (arg1@@456 T@U) (arg2@@276 T@U) (arg3@@203 Bool) ) (! (= (type (|lambda#105| arg0@@762 arg1@@456 arg2@@276 arg3@@203)) (MapType6Type refType boolType))
 :qid |funType:lambda#105|
 :pattern ( (|lambda#105| arg0@@762 arg1@@456 arg2@@276 arg3@@203))
)))
(assert (forall ((|l#0@@124| T@U) (|l#1@@102| T@U) (|l#2@@101| T@U) (|l#3@@101| Bool) ($o@@173 T@U) ($f@@103 T@U) ) (! (let ((alpha@@110 (FieldTypeInv0 (type $f@@103))))
 (=> (and (and (and (and (= (type |l#0@@124|) refType) (= (type |l#1@@102|) (MapType0Type refType MapType1Type))) (= (type |l#2@@101|) (FieldType boolType))) (= (type $o@@173) refType)) (= (type $f@@103) (FieldType alpha@@110))) (= (U_2_bool (MapType6Select (|lambda#105| |l#0@@124| |l#1@@102| |l#2@@101| |l#3@@101|) $o@@173 $f@@103))  (=> (and (not (= $o@@173 |l#0@@124|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@102| $o@@173) |l#2@@101|))) |l#3@@101|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5134|
 :pattern ( (MapType6Select (|lambda#105| |l#0@@124| |l#1@@102| |l#2@@101| |l#3@@101|) $o@@173 $f@@103))
)))
(assert (forall ((arg0@@763 T@U) (arg1@@457 T@U) (arg2@@277 T@U) (arg3@@204 Bool) ) (! (= (type (|lambda#106| arg0@@763 arg1@@457 arg2@@277 arg3@@204)) (MapType6Type refType boolType))
 :qid |funType:lambda#106|
 :pattern ( (|lambda#106| arg0@@763 arg1@@457 arg2@@277 arg3@@204))
)))
(assert (forall ((|l#0@@125| T@U) (|l#1@@103| T@U) (|l#2@@102| T@U) (|l#3@@102| Bool) ($o@@174 T@U) ($f@@104 T@U) ) (! (let ((alpha@@111 (FieldTypeInv0 (type $f@@104))))
 (=> (and (and (and (and (= (type |l#0@@125|) refType) (= (type |l#1@@103|) (MapType0Type refType MapType1Type))) (= (type |l#2@@102|) (FieldType boolType))) (= (type $o@@174) refType)) (= (type $f@@104) (FieldType alpha@@111))) (= (U_2_bool (MapType6Select (|lambda#106| |l#0@@125| |l#1@@103| |l#2@@102| |l#3@@102|) $o@@174 $f@@104))  (=> (and (not (= $o@@174 |l#0@@125|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@103| $o@@174) |l#2@@102|))) |l#3@@102|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5135|
 :pattern ( (MapType6Select (|lambda#106| |l#0@@125| |l#1@@103| |l#2@@102| |l#3@@102|) $o@@174 $f@@104))
)))
(assert (forall ((arg0@@764 T@U) (arg1@@458 T@U) (arg2@@278 T@U) (arg3@@205 Bool) ) (! (= (type (|lambda#107| arg0@@764 arg1@@458 arg2@@278 arg3@@205)) (MapType6Type refType boolType))
 :qid |funType:lambda#107|
 :pattern ( (|lambda#107| arg0@@764 arg1@@458 arg2@@278 arg3@@205))
)))
(assert (forall ((|l#0@@126| T@U) (|l#1@@104| T@U) (|l#2@@103| T@U) (|l#3@@103| Bool) ($o@@175 T@U) ($f@@105 T@U) ) (! (let ((alpha@@112 (FieldTypeInv0 (type $f@@105))))
 (=> (and (and (and (and (= (type |l#0@@126|) refType) (= (type |l#1@@104|) (MapType0Type refType MapType1Type))) (= (type |l#2@@103|) (FieldType boolType))) (= (type $o@@175) refType)) (= (type $f@@105) (FieldType alpha@@112))) (= (U_2_bool (MapType6Select (|lambda#107| |l#0@@126| |l#1@@104| |l#2@@103| |l#3@@103|) $o@@175 $f@@105))  (=> (and (not (= $o@@175 |l#0@@126|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@104| $o@@175) |l#2@@103|))) |l#3@@103|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5136|
 :pattern ( (MapType6Select (|lambda#107| |l#0@@126| |l#1@@104| |l#2@@103| |l#3@@103|) $o@@175 $f@@105))
)))
(assert (forall ((arg0@@765 T@U) (arg1@@459 T@U) (arg2@@279 T@U) (arg3@@206 Bool) ) (! (= (type (|lambda#108| arg0@@765 arg1@@459 arg2@@279 arg3@@206)) (MapType6Type refType boolType))
 :qid |funType:lambda#108|
 :pattern ( (|lambda#108| arg0@@765 arg1@@459 arg2@@279 arg3@@206))
)))
(assert (forall ((|l#0@@127| T@U) (|l#1@@105| T@U) (|l#2@@104| T@U) (|l#3@@104| Bool) ($o@@176 T@U) ($f@@106 T@U) ) (! (let ((alpha@@113 (FieldTypeInv0 (type $f@@106))))
 (=> (and (and (and (and (= (type |l#0@@127|) refType) (= (type |l#1@@105|) (MapType0Type refType MapType1Type))) (= (type |l#2@@104|) (FieldType boolType))) (= (type $o@@176) refType)) (= (type $f@@106) (FieldType alpha@@113))) (= (U_2_bool (MapType6Select (|lambda#108| |l#0@@127| |l#1@@105| |l#2@@104| |l#3@@104|) $o@@176 $f@@106))  (=> (and (not (= $o@@176 |l#0@@127|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@105| $o@@176) |l#2@@104|))) |l#3@@104|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5137|
 :pattern ( (MapType6Select (|lambda#108| |l#0@@127| |l#1@@105| |l#2@@104| |l#3@@104|) $o@@176 $f@@106))
)))
(assert (forall ((arg0@@766 T@U) (arg1@@460 T@U) (arg2@@280 T@U) (arg3@@207 Bool) ) (! (= (type (|lambda#109| arg0@@766 arg1@@460 arg2@@280 arg3@@207)) (MapType6Type refType boolType))
 :qid |funType:lambda#109|
 :pattern ( (|lambda#109| arg0@@766 arg1@@460 arg2@@280 arg3@@207))
)))
(assert (forall ((|l#0@@128| T@U) (|l#1@@106| T@U) (|l#2@@105| T@U) (|l#3@@105| Bool) ($o@@177 T@U) ($f@@107 T@U) ) (! (let ((alpha@@114 (FieldTypeInv0 (type $f@@107))))
 (=> (and (and (and (and (= (type |l#0@@128|) refType) (= (type |l#1@@106|) (MapType0Type refType MapType1Type))) (= (type |l#2@@105|) (FieldType boolType))) (= (type $o@@177) refType)) (= (type $f@@107) (FieldType alpha@@114))) (= (U_2_bool (MapType6Select (|lambda#109| |l#0@@128| |l#1@@106| |l#2@@105| |l#3@@105|) $o@@177 $f@@107))  (=> (and (not (= $o@@177 |l#0@@128|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@106| $o@@177) |l#2@@105|))) |l#3@@105|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5138|
 :pattern ( (MapType6Select (|lambda#109| |l#0@@128| |l#1@@106| |l#2@@105| |l#3@@105|) $o@@177 $f@@107))
)))
(assert (forall ((arg0@@767 T@U) (arg1@@461 T@U) (arg2@@281 T@U) (arg3@@208 Bool) ) (! (= (type (|lambda#110| arg0@@767 arg1@@461 arg2@@281 arg3@@208)) (MapType6Type refType boolType))
 :qid |funType:lambda#110|
 :pattern ( (|lambda#110| arg0@@767 arg1@@461 arg2@@281 arg3@@208))
)))
(assert (forall ((|l#0@@129| T@U) (|l#1@@107| T@U) (|l#2@@106| T@U) (|l#3@@106| Bool) ($o@@178 T@U) ($f@@108 T@U) ) (! (let ((alpha@@115 (FieldTypeInv0 (type $f@@108))))
 (=> (and (and (and (and (= (type |l#0@@129|) refType) (= (type |l#1@@107|) (MapType0Type refType MapType1Type))) (= (type |l#2@@106|) (FieldType boolType))) (= (type $o@@178) refType)) (= (type $f@@108) (FieldType alpha@@115))) (= (U_2_bool (MapType6Select (|lambda#110| |l#0@@129| |l#1@@107| |l#2@@106| |l#3@@106|) $o@@178 $f@@108))  (=> (and (not (= $o@@178 |l#0@@129|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@107| $o@@178) |l#2@@106|))) |l#3@@106|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5139|
 :pattern ( (MapType6Select (|lambda#110| |l#0@@129| |l#1@@107| |l#2@@106| |l#3@@106|) $o@@178 $f@@108))
)))
(assert (forall ((arg0@@768 T@U) (arg1@@462 T@U) (arg2@@282 T@U) (arg3@@209 Bool) ) (! (= (type (|lambda#111| arg0@@768 arg1@@462 arg2@@282 arg3@@209)) (MapType6Type refType boolType))
 :qid |funType:lambda#111|
 :pattern ( (|lambda#111| arg0@@768 arg1@@462 arg2@@282 arg3@@209))
)))
(assert (forall ((|l#0@@130| T@U) (|l#1@@108| T@U) (|l#2@@107| T@U) (|l#3@@107| Bool) ($o@@179 T@U) ($f@@109 T@U) ) (! (let ((alpha@@116 (FieldTypeInv0 (type $f@@109))))
 (=> (and (and (and (and (= (type |l#0@@130|) refType) (= (type |l#1@@108|) (MapType0Type refType MapType1Type))) (= (type |l#2@@107|) (FieldType boolType))) (= (type $o@@179) refType)) (= (type $f@@109) (FieldType alpha@@116))) (= (U_2_bool (MapType6Select (|lambda#111| |l#0@@130| |l#1@@108| |l#2@@107| |l#3@@107|) $o@@179 $f@@109))  (=> (and (not (= $o@@179 |l#0@@130|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@108| $o@@179) |l#2@@107|))) |l#3@@107|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5140|
 :pattern ( (MapType6Select (|lambda#111| |l#0@@130| |l#1@@108| |l#2@@107| |l#3@@107|) $o@@179 $f@@109))
)))
(assert (forall ((arg0@@769 T@U) (arg1@@463 T@U) (arg2@@283 T@U) (arg3@@210 Bool) ) (! (= (type (|lambda#112| arg0@@769 arg1@@463 arg2@@283 arg3@@210)) (MapType6Type refType boolType))
 :qid |funType:lambda#112|
 :pattern ( (|lambda#112| arg0@@769 arg1@@463 arg2@@283 arg3@@210))
)))
(assert (forall ((|l#0@@131| T@U) (|l#1@@109| T@U) (|l#2@@108| T@U) (|l#3@@108| Bool) ($o@@180 T@U) ($f@@110 T@U) ) (! (let ((alpha@@117 (FieldTypeInv0 (type $f@@110))))
 (=> (and (and (and (and (= (type |l#0@@131|) refType) (= (type |l#1@@109|) (MapType0Type refType MapType1Type))) (= (type |l#2@@108|) (FieldType boolType))) (= (type $o@@180) refType)) (= (type $f@@110) (FieldType alpha@@117))) (= (U_2_bool (MapType6Select (|lambda#112| |l#0@@131| |l#1@@109| |l#2@@108| |l#3@@108|) $o@@180 $f@@110))  (=> (and (not (= $o@@180 |l#0@@131|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@109| $o@@180) |l#2@@108|))) |l#3@@108|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5141|
 :pattern ( (MapType6Select (|lambda#112| |l#0@@131| |l#1@@109| |l#2@@108| |l#3@@108|) $o@@180 $f@@110))
)))
(assert (forall ((arg0@@770 T@U) (arg1@@464 T@U) (arg2@@284 T@U) (arg3@@211 Bool) ) (! (= (type (|lambda#113| arg0@@770 arg1@@464 arg2@@284 arg3@@211)) (MapType6Type refType boolType))
 :qid |funType:lambda#113|
 :pattern ( (|lambda#113| arg0@@770 arg1@@464 arg2@@284 arg3@@211))
)))
(assert (forall ((|l#0@@132| T@U) (|l#1@@110| T@U) (|l#2@@109| T@U) (|l#3@@109| Bool) ($o@@181 T@U) ($f@@111 T@U) ) (! (let ((alpha@@118 (FieldTypeInv0 (type $f@@111))))
 (=> (and (and (and (and (= (type |l#0@@132|) refType) (= (type |l#1@@110|) (MapType0Type refType MapType1Type))) (= (type |l#2@@109|) (FieldType boolType))) (= (type $o@@181) refType)) (= (type $f@@111) (FieldType alpha@@118))) (= (U_2_bool (MapType6Select (|lambda#113| |l#0@@132| |l#1@@110| |l#2@@109| |l#3@@109|) $o@@181 $f@@111))  (=> (and (not (= $o@@181 |l#0@@132|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@110| $o@@181) |l#2@@109|))) |l#3@@109|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5142|
 :pattern ( (MapType6Select (|lambda#113| |l#0@@132| |l#1@@110| |l#2@@109| |l#3@@109|) $o@@181 $f@@111))
)))
(assert (forall ((arg0@@771 T@U) (arg1@@465 T@U) (arg2@@285 T@U) (arg3@@212 Bool) ) (! (= (type (|lambda#114| arg0@@771 arg1@@465 arg2@@285 arg3@@212)) (MapType6Type refType boolType))
 :qid |funType:lambda#114|
 :pattern ( (|lambda#114| arg0@@771 arg1@@465 arg2@@285 arg3@@212))
)))
(assert (forall ((|l#0@@133| T@U) (|l#1@@111| T@U) (|l#2@@110| T@U) (|l#3@@110| Bool) ($o@@182 T@U) ($f@@112 T@U) ) (! (let ((alpha@@119 (FieldTypeInv0 (type $f@@112))))
 (=> (and (and (and (and (= (type |l#0@@133|) refType) (= (type |l#1@@111|) (MapType0Type refType MapType1Type))) (= (type |l#2@@110|) (FieldType boolType))) (= (type $o@@182) refType)) (= (type $f@@112) (FieldType alpha@@119))) (= (U_2_bool (MapType6Select (|lambda#114| |l#0@@133| |l#1@@111| |l#2@@110| |l#3@@110|) $o@@182 $f@@112))  (=> (and (not (= $o@@182 |l#0@@133|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@111| $o@@182) |l#2@@110|))) |l#3@@110|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5143|
 :pattern ( (MapType6Select (|lambda#114| |l#0@@133| |l#1@@111| |l#2@@110| |l#3@@110|) $o@@182 $f@@112))
)))
(assert (forall ((arg0@@772 T@U) (arg1@@466 T@U) (arg2@@286 T@U) (arg3@@213 Bool) ) (! (= (type (|lambda#115| arg0@@772 arg1@@466 arg2@@286 arg3@@213)) (MapType6Type refType boolType))
 :qid |funType:lambda#115|
 :pattern ( (|lambda#115| arg0@@772 arg1@@466 arg2@@286 arg3@@213))
)))
(assert (forall ((|l#0@@134| T@U) (|l#1@@112| T@U) (|l#2@@111| T@U) (|l#3@@111| Bool) ($o@@183 T@U) ($f@@113 T@U) ) (! (let ((alpha@@120 (FieldTypeInv0 (type $f@@113))))
 (=> (and (and (and (and (= (type |l#0@@134|) refType) (= (type |l#1@@112|) (MapType0Type refType MapType1Type))) (= (type |l#2@@111|) (FieldType boolType))) (= (type $o@@183) refType)) (= (type $f@@113) (FieldType alpha@@120))) (= (U_2_bool (MapType6Select (|lambda#115| |l#0@@134| |l#1@@112| |l#2@@111| |l#3@@111|) $o@@183 $f@@113))  (=> (and (not (= $o@@183 |l#0@@134|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@112| $o@@183) |l#2@@111|))) |l#3@@111|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5144|
 :pattern ( (MapType6Select (|lambda#115| |l#0@@134| |l#1@@112| |l#2@@111| |l#3@@111|) $o@@183 $f@@113))
)))
(assert (forall ((arg0@@773 T@U) (arg1@@467 T@U) (arg2@@287 T@U) (arg3@@214 Bool) ) (! (= (type (|lambda#116| arg0@@773 arg1@@467 arg2@@287 arg3@@214)) (MapType6Type refType boolType))
 :qid |funType:lambda#116|
 :pattern ( (|lambda#116| arg0@@773 arg1@@467 arg2@@287 arg3@@214))
)))
(assert (forall ((|l#0@@135| T@U) (|l#1@@113| T@U) (|l#2@@112| T@U) (|l#3@@112| Bool) ($o@@184 T@U) ($f@@114 T@U) ) (! (let ((alpha@@121 (FieldTypeInv0 (type $f@@114))))
 (=> (and (and (and (and (= (type |l#0@@135|) refType) (= (type |l#1@@113|) (MapType0Type refType MapType1Type))) (= (type |l#2@@112|) (FieldType boolType))) (= (type $o@@184) refType)) (= (type $f@@114) (FieldType alpha@@121))) (= (U_2_bool (MapType6Select (|lambda#116| |l#0@@135| |l#1@@113| |l#2@@112| |l#3@@112|) $o@@184 $f@@114))  (=> (and (not (= $o@@184 |l#0@@135|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@113| $o@@184) |l#2@@112|))) |l#3@@112|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5145|
 :pattern ( (MapType6Select (|lambda#116| |l#0@@135| |l#1@@113| |l#2@@112| |l#3@@112|) $o@@184 $f@@114))
)))
(assert (forall ((arg0@@774 T@U) (arg1@@468 T@U) (arg2@@288 T@U) (arg3@@215 Bool) ) (! (= (type (|lambda#117| arg0@@774 arg1@@468 arg2@@288 arg3@@215)) (MapType6Type refType boolType))
 :qid |funType:lambda#117|
 :pattern ( (|lambda#117| arg0@@774 arg1@@468 arg2@@288 arg3@@215))
)))
(assert (forall ((|l#0@@136| T@U) (|l#1@@114| T@U) (|l#2@@113| T@U) (|l#3@@113| Bool) ($o@@185 T@U) ($f@@115 T@U) ) (! (let ((alpha@@122 (FieldTypeInv0 (type $f@@115))))
 (=> (and (and (and (and (= (type |l#0@@136|) refType) (= (type |l#1@@114|) (MapType0Type refType MapType1Type))) (= (type |l#2@@113|) (FieldType boolType))) (= (type $o@@185) refType)) (= (type $f@@115) (FieldType alpha@@122))) (= (U_2_bool (MapType6Select (|lambda#117| |l#0@@136| |l#1@@114| |l#2@@113| |l#3@@113|) $o@@185 $f@@115))  (=> (and (not (= $o@@185 |l#0@@136|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@114| $o@@185) |l#2@@113|))) |l#3@@113|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5146|
 :pattern ( (MapType6Select (|lambda#117| |l#0@@136| |l#1@@114| |l#2@@113| |l#3@@113|) $o@@185 $f@@115))
)))
(assert (forall ((arg0@@775 T@U) (arg1@@469 T@U) (arg2@@289 T@U) (arg3@@216 Bool) ) (! (= (type (|lambda#118| arg0@@775 arg1@@469 arg2@@289 arg3@@216)) (MapType6Type refType boolType))
 :qid |funType:lambda#118|
 :pattern ( (|lambda#118| arg0@@775 arg1@@469 arg2@@289 arg3@@216))
)))
(assert (forall ((|l#0@@137| T@U) (|l#1@@115| T@U) (|l#2@@114| T@U) (|l#3@@114| Bool) ($o@@186 T@U) ($f@@116 T@U) ) (! (let ((alpha@@123 (FieldTypeInv0 (type $f@@116))))
 (=> (and (and (and (and (= (type |l#0@@137|) refType) (= (type |l#1@@115|) (MapType0Type refType MapType1Type))) (= (type |l#2@@114|) (FieldType boolType))) (= (type $o@@186) refType)) (= (type $f@@116) (FieldType alpha@@123))) (= (U_2_bool (MapType6Select (|lambda#118| |l#0@@137| |l#1@@115| |l#2@@114| |l#3@@114|) $o@@186 $f@@116))  (=> (and (not (= $o@@186 |l#0@@137|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@115| $o@@186) |l#2@@114|))) |l#3@@114|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5147|
 :pattern ( (MapType6Select (|lambda#118| |l#0@@137| |l#1@@115| |l#2@@114| |l#3@@114|) $o@@186 $f@@116))
)))
(assert (forall ((arg0@@776 T@U) (arg1@@470 T@U) (arg2@@290 T@U) (arg3@@217 Bool) ) (! (= (type (|lambda#119| arg0@@776 arg1@@470 arg2@@290 arg3@@217)) (MapType6Type refType boolType))
 :qid |funType:lambda#119|
 :pattern ( (|lambda#119| arg0@@776 arg1@@470 arg2@@290 arg3@@217))
)))
(assert (forall ((|l#0@@138| T@U) (|l#1@@116| T@U) (|l#2@@115| T@U) (|l#3@@115| Bool) ($o@@187 T@U) ($f@@117 T@U) ) (! (let ((alpha@@124 (FieldTypeInv0 (type $f@@117))))
 (=> (and (and (and (and (= (type |l#0@@138|) refType) (= (type |l#1@@116|) (MapType0Type refType MapType1Type))) (= (type |l#2@@115|) (FieldType boolType))) (= (type $o@@187) refType)) (= (type $f@@117) (FieldType alpha@@124))) (= (U_2_bool (MapType6Select (|lambda#119| |l#0@@138| |l#1@@116| |l#2@@115| |l#3@@115|) $o@@187 $f@@117))  (=> (and (not (= $o@@187 |l#0@@138|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@116| $o@@187) |l#2@@115|))) |l#3@@115|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5148|
 :pattern ( (MapType6Select (|lambda#119| |l#0@@138| |l#1@@116| |l#2@@115| |l#3@@115|) $o@@187 $f@@117))
)))
(assert (forall ((arg0@@777 T@U) (arg1@@471 T@U) (arg2@@291 T@U) (arg3@@218 Bool) ) (! (= (type (|lambda#120| arg0@@777 arg1@@471 arg2@@291 arg3@@218)) (MapType6Type refType boolType))
 :qid |funType:lambda#120|
 :pattern ( (|lambda#120| arg0@@777 arg1@@471 arg2@@291 arg3@@218))
)))
(assert (forall ((|l#0@@139| T@U) (|l#1@@117| T@U) (|l#2@@116| T@U) (|l#3@@116| Bool) ($o@@188 T@U) ($f@@118 T@U) ) (! (let ((alpha@@125 (FieldTypeInv0 (type $f@@118))))
 (=> (and (and (and (and (= (type |l#0@@139|) refType) (= (type |l#1@@117|) (MapType0Type refType MapType1Type))) (= (type |l#2@@116|) (FieldType boolType))) (= (type $o@@188) refType)) (= (type $f@@118) (FieldType alpha@@125))) (= (U_2_bool (MapType6Select (|lambda#120| |l#0@@139| |l#1@@117| |l#2@@116| |l#3@@116|) $o@@188 $f@@118))  (=> (and (not (= $o@@188 |l#0@@139|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@117| $o@@188) |l#2@@116|))) |l#3@@116|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5149|
 :pattern ( (MapType6Select (|lambda#120| |l#0@@139| |l#1@@117| |l#2@@116| |l#3@@116|) $o@@188 $f@@118))
)))
(assert (forall ((arg0@@778 T@U) (arg1@@472 T@U) (arg2@@292 T@U) (arg3@@219 Bool) ) (! (= (type (|lambda#121| arg0@@778 arg1@@472 arg2@@292 arg3@@219)) (MapType6Type refType boolType))
 :qid |funType:lambda#121|
 :pattern ( (|lambda#121| arg0@@778 arg1@@472 arg2@@292 arg3@@219))
)))
(assert (forall ((|l#0@@140| T@U) (|l#1@@118| T@U) (|l#2@@117| T@U) (|l#3@@117| Bool) ($o@@189 T@U) ($f@@119 T@U) ) (! (let ((alpha@@126 (FieldTypeInv0 (type $f@@119))))
 (=> (and (and (and (and (= (type |l#0@@140|) refType) (= (type |l#1@@118|) (MapType0Type refType MapType1Type))) (= (type |l#2@@117|) (FieldType boolType))) (= (type $o@@189) refType)) (= (type $f@@119) (FieldType alpha@@126))) (= (U_2_bool (MapType6Select (|lambda#121| |l#0@@140| |l#1@@118| |l#2@@117| |l#3@@117|) $o@@189 $f@@119))  (=> (and (not (= $o@@189 |l#0@@140|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@118| $o@@189) |l#2@@117|))) |l#3@@117|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5150|
 :pattern ( (MapType6Select (|lambda#121| |l#0@@140| |l#1@@118| |l#2@@117| |l#3@@117|) $o@@189 $f@@119))
)))
(assert (forall ((arg0@@779 T@U) (arg1@@473 T@U) (arg2@@293 T@U) (arg3@@220 Bool) ) (! (= (type (|lambda#122| arg0@@779 arg1@@473 arg2@@293 arg3@@220)) (MapType6Type refType boolType))
 :qid |funType:lambda#122|
 :pattern ( (|lambda#122| arg0@@779 arg1@@473 arg2@@293 arg3@@220))
)))
(assert (forall ((|l#0@@141| T@U) (|l#1@@119| T@U) (|l#2@@118| T@U) (|l#3@@118| Bool) ($o@@190 T@U) ($f@@120 T@U) ) (! (let ((alpha@@127 (FieldTypeInv0 (type $f@@120))))
 (=> (and (and (and (and (= (type |l#0@@141|) refType) (= (type |l#1@@119|) (MapType0Type refType MapType1Type))) (= (type |l#2@@118|) (FieldType boolType))) (= (type $o@@190) refType)) (= (type $f@@120) (FieldType alpha@@127))) (= (U_2_bool (MapType6Select (|lambda#122| |l#0@@141| |l#1@@119| |l#2@@118| |l#3@@118|) $o@@190 $f@@120))  (=> (and (not (= $o@@190 |l#0@@141|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@119| $o@@190) |l#2@@118|))) |l#3@@118|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5151|
 :pattern ( (MapType6Select (|lambda#122| |l#0@@141| |l#1@@119| |l#2@@118| |l#3@@118|) $o@@190 $f@@120))
)))
(assert (forall ((arg0@@780 T@U) (arg1@@474 T@U) (arg2@@294 T@U) (arg3@@221 Bool) ) (! (= (type (|lambda#123| arg0@@780 arg1@@474 arg2@@294 arg3@@221)) (MapType6Type refType boolType))
 :qid |funType:lambda#123|
 :pattern ( (|lambda#123| arg0@@780 arg1@@474 arg2@@294 arg3@@221))
)))
(assert (forall ((|l#0@@142| T@U) (|l#1@@120| T@U) (|l#2@@119| T@U) (|l#3@@119| Bool) ($o@@191 T@U) ($f@@121 T@U) ) (! (let ((alpha@@128 (FieldTypeInv0 (type $f@@121))))
 (=> (and (and (and (and (= (type |l#0@@142|) refType) (= (type |l#1@@120|) (MapType0Type refType MapType1Type))) (= (type |l#2@@119|) (FieldType boolType))) (= (type $o@@191) refType)) (= (type $f@@121) (FieldType alpha@@128))) (= (U_2_bool (MapType6Select (|lambda#123| |l#0@@142| |l#1@@120| |l#2@@119| |l#3@@119|) $o@@191 $f@@121))  (=> (and (not (= $o@@191 |l#0@@142|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@120| $o@@191) |l#2@@119|))) |l#3@@119|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5152|
 :pattern ( (MapType6Select (|lambda#123| |l#0@@142| |l#1@@120| |l#2@@119| |l#3@@119|) $o@@191 $f@@121))
)))
(assert (forall ((arg0@@781 T@U) (arg1@@475 T@U) (arg2@@295 T@U) (arg3@@222 Bool) ) (! (= (type (|lambda#124| arg0@@781 arg1@@475 arg2@@295 arg3@@222)) (MapType6Type refType boolType))
 :qid |funType:lambda#124|
 :pattern ( (|lambda#124| arg0@@781 arg1@@475 arg2@@295 arg3@@222))
)))
(assert (forall ((|l#0@@143| T@U) (|l#1@@121| T@U) (|l#2@@120| T@U) (|l#3@@120| Bool) ($o@@192 T@U) ($f@@122 T@U) ) (! (let ((alpha@@129 (FieldTypeInv0 (type $f@@122))))
 (=> (and (and (and (and (= (type |l#0@@143|) refType) (= (type |l#1@@121|) (MapType0Type refType MapType1Type))) (= (type |l#2@@120|) (FieldType boolType))) (= (type $o@@192) refType)) (= (type $f@@122) (FieldType alpha@@129))) (= (U_2_bool (MapType6Select (|lambda#124| |l#0@@143| |l#1@@121| |l#2@@120| |l#3@@120|) $o@@192 $f@@122))  (=> (and (not (= $o@@192 |l#0@@143|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@121| $o@@192) |l#2@@120|))) |l#3@@120|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5153|
 :pattern ( (MapType6Select (|lambda#124| |l#0@@143| |l#1@@121| |l#2@@120| |l#3@@120|) $o@@192 $f@@122))
)))
(assert (forall ((arg0@@782 T@U) (arg1@@476 T@U) (arg2@@296 T@U) (arg3@@223 Bool) ) (! (= (type (|lambda#125| arg0@@782 arg1@@476 arg2@@296 arg3@@223)) (MapType6Type refType boolType))
 :qid |funType:lambda#125|
 :pattern ( (|lambda#125| arg0@@782 arg1@@476 arg2@@296 arg3@@223))
)))
(assert (forall ((|l#0@@144| T@U) (|l#1@@122| T@U) (|l#2@@121| T@U) (|l#3@@121| Bool) ($o@@193 T@U) ($f@@123 T@U) ) (! (let ((alpha@@130 (FieldTypeInv0 (type $f@@123))))
 (=> (and (and (and (and (= (type |l#0@@144|) refType) (= (type |l#1@@122|) (MapType0Type refType MapType1Type))) (= (type |l#2@@121|) (FieldType boolType))) (= (type $o@@193) refType)) (= (type $f@@123) (FieldType alpha@@130))) (= (U_2_bool (MapType6Select (|lambda#125| |l#0@@144| |l#1@@122| |l#2@@121| |l#3@@121|) $o@@193 $f@@123))  (=> (and (not (= $o@@193 |l#0@@144|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@122| $o@@193) |l#2@@121|))) |l#3@@121|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5154|
 :pattern ( (MapType6Select (|lambda#125| |l#0@@144| |l#1@@122| |l#2@@121| |l#3@@121|) $o@@193 $f@@123))
)))
(assert (forall ((arg0@@783 T@U) (arg1@@477 T@U) (arg2@@297 T@U) (arg3@@224 Bool) ) (! (= (type (|lambda#126| arg0@@783 arg1@@477 arg2@@297 arg3@@224)) (MapType6Type refType boolType))
 :qid |funType:lambda#126|
 :pattern ( (|lambda#126| arg0@@783 arg1@@477 arg2@@297 arg3@@224))
)))
(assert (forall ((|l#0@@145| T@U) (|l#1@@123| T@U) (|l#2@@122| T@U) (|l#3@@122| Bool) ($o@@194 T@U) ($f@@124 T@U) ) (! (let ((alpha@@131 (FieldTypeInv0 (type $f@@124))))
 (=> (and (and (and (and (= (type |l#0@@145|) refType) (= (type |l#1@@123|) (MapType0Type refType MapType1Type))) (= (type |l#2@@122|) (FieldType boolType))) (= (type $o@@194) refType)) (= (type $f@@124) (FieldType alpha@@131))) (= (U_2_bool (MapType6Select (|lambda#126| |l#0@@145| |l#1@@123| |l#2@@122| |l#3@@122|) $o@@194 $f@@124))  (=> (and (not (= $o@@194 |l#0@@145|)) (U_2_bool (MapType1Select (MapType0Select |l#1@@123| $o@@194) |l#2@@122|))) |l#3@@122|))))
 :qid |DafnyPreludebpl.129:1|
 :skolemid |5155|
 :pattern ( (MapType6Select (|lambda#126| |l#0@@145| |l#1@@123| |l#2@@122| |l#3@@122|) $o@@194 $f@@124))
)))
(assert (forall ((|l#0@@146| T@U) (|l#1@@124| T@U) (|$l#0#heap#0| T@U) (|$l#0#i#0| T@U) ) (!  (=> (and (and (and (= (type |l#0@@146|) TyType) (= (type |l#1@@124|) (SeqType BoxType))) (= (type |$l#0#heap#0|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0|) BoxType)) (= (MapType2Select (|lambda#127| |l#0@@146| |l#1@@124|) |$l#0#heap#0| |$l#0#i#0|) ($Box (bool_2_U (LinearMaybe.__default.has |l#0@@146| (|Seq#Index| |l#1@@124| (U_2_int ($Unbox intType |$l#0#i#0|))))))))
 :qid |unknown.0:0|
 :skolemid |5156|
 :pattern ( (MapType2Select (|lambda#127| |l#0@@146| |l#1@@124|) |$l#0#heap#0| |$l#0#i#0|))
)))
(assert (forall ((|l#0@@147| T@U) (|l#1@@125| Int) (|l#2@@123| Int) (|$l#0#heap#0@@0| T@U) (|$l#0#i#0@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@147|) TyType) (= (type |$l#0#heap#0@@0|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@0|) BoxType)) (= (U_2_bool (MapType2Select (|lambda#128| |l#0@@147| |l#1@@125| |l#2@@123|) |$l#0#heap#0@@0| |$l#0#i#0@@0|))  (and ($IsBox |$l#0#i#0@@0| |l#0@@147|) (and (INTERNAL_le_boogie |l#1@@125| (U_2_int ($Unbox intType |$l#0#i#0@@0|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$l#0#i#0@@0|)) |l#2@@123|)))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |5157|
 :pattern ( (MapType2Select (|lambda#128| |l#0@@147| |l#1@@125| |l#2@@123|) |$l#0#heap#0@@0| |$l#0#i#0@@0|))
)))
(assert (forall ((|l#0@@148| Bool) (|$l#0#o#0| T@U) ) (!  (=> (= (type |$l#0#o#0|) refType) (= (U_2_bool (MapType0Select (|lambda#129| |l#0@@148|) |$l#0#o#0|)) |l#0@@148|))
 :qid |unknown.0:0|
 :skolemid |5158|
 :pattern ( (MapType0Select (|lambda#129| |l#0@@148|) |$l#0#o#0|))
)))
(assert (forall ((|l#0@@149| T@U) (|$l#0#heap#0@@1| T@U) (|$l#0#i#0@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@149|) (MapType0Type BoxType boolType)) (= (type |$l#0#heap#0@@1|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@1|) BoxType)) (= (MapType2Select (|lambda#130| |l#0@@149|) |$l#0#heap#0@@1| |$l#0#i#0@@1|) |l#0@@149|))
 :qid |LinearSequencesdfy.69:25|
 :skolemid |5159|
 :pattern ( (MapType2Select (|lambda#130| |l#0@@149|) |$l#0#heap#0@@1| |$l#0#i#0@@1|))
)))
(assert (forall ((|l#0@@150| T@U) (|$l#0#ly#0| T@U) ) (!  (=> (and (= (type |l#0@@150|) HandleTypeType) (= (type |$l#0#ly#0|) LayerTypeType)) (= (MapType0Select (|lambda#131| |l#0@@150|) |$l#0#ly#0|) |l#0@@150|))
 :qid |LinearSequencesdfy.69:25|
 :skolemid |5160|
 :pattern ( (MapType0Select (|lambda#131| |l#0@@150|) |$l#0#ly#0|))
)))
(assert (forall ((|l#0@@151| T@U) (|$w#0| T@U) ) (!  (=> (and (= (type |l#0@@151|) TyType) (= (type |$w#0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#137| |l#0@@151|) |$w#0|))  (and ($IsBox |$w#0| |l#0@@151|) (TotalKMMapMod.__default.AnyKey ($Unbox (SeqType BoxType) |$w#0|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |5161|
 :pattern ( (MapType0Select (|lambda#137| |l#0@@151|) |$w#0|))
)))
(assert (forall ((|l#0@@152| T@U) (|$w#0@@0| T@U) ) (!  (=> (and (= (type |l#0@@152|) BoxType) (= (type |$w#0@@0|) BoxType)) (= (MapType0Select (|lambda#138| |l#0@@152|) |$w#0@@0|) |l#0@@152|))
 :qid |TotalMapsdfyTotalKMMapMod.28:5|
 :skolemid |5162|
 :pattern ( (MapType0Select (|lambda#138| |l#0@@152|) |$w#0@@0|))
)))
(assert (forall ((|l#0@@153| T@U) (|l#1@@126| T@U) (|l#2@@124| Int) (|$y#0@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@153|) TyType) (= (type |l#1@@126|) (MapType0Type BoxType intType))) (= (type |$y#0@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#141| |l#0@@153| |l#1@@126| |l#2@@124|) |$y#0@@0|))  (and ($IsBox |$y#0@@0| |l#0@@153|) (> (U_2_int (MapType0Select |l#1@@126| |$y#0@@0|)) |l#2@@124|))))
 :qid |unknown.0:0|
 :skolemid |5163|
 :pattern ( (MapType0Select (|lambda#141| |l#0@@153| |l#1@@126| |l#2@@124|) |$y#0@@0|))
)))
(assert (forall ((|l#0@@154| T@U) (|l#1@@127| T@U) (|$y#0@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@154|) TyType) (= (type |l#1@@127|) (MapType0Type BoxType boolType))) (= (type |$y#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#143| |l#0@@154| |l#1@@127|) |$y#0@@1|))  (and ($IsBox |$y#0@@1| |l#0@@154|) (U_2_bool (MapType0Select |l#1@@127| |$y#0@@1|)))))
 :qid |unknown.0:0|
 :skolemid |5164|
 :pattern ( (MapType0Select (|lambda#143| |l#0@@154| |l#1@@127|) |$y#0@@1|))
)))
(assert (forall ((|l#0@@155| T@U) (|l#1@@128| T@U) (|l#2@@125| T@U) (|l#3@@123| T@U) (|$l#0#heap#0@@2| T@U) (|$l#0#i#0@@2| T@U) ) (!  (=> (and (and (and (and (and (= (type |l#0@@155|) TyType) (= (type |l#1@@128|) TyType)) (= (type |l#2@@125|) HandleTypeType)) (= (type |l#3@@123|) (SeqType BoxType))) (= (type |$l#0#heap#0@@2|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@2|) BoxType)) (= (MapType2Select (|lambda#149| |l#0@@155| |l#1@@128| |l#2@@125| |l#3@@123|) |$l#0#heap#0@@2| |$l#0#i#0@@2|) (Apply1 |l#0@@155| |l#1@@128| |$l#0#heap#0@@2| |l#2@@125| (|Seq#Index| |l#3@@123| (U_2_int ($Unbox intType |$l#0#i#0@@2|))))))
 :qid |unknown.0:0|
 :skolemid |5165|
 :pattern ( (MapType2Select (|lambda#149| |l#0@@155| |l#1@@128| |l#2@@125| |l#3@@123|) |$l#0#heap#0@@2| |$l#0#i#0@@2|))
)))
(assert (forall ((|l#0@@156| T@U) (|l#1@@129| Int) (|l#2@@126| Int) (|l#3@@124| T@U) (|l#4| T@U) (|l#5| T@U) (|l#6| T@U) (|$l#0#heap#0@@3| T@U) (|$l#0#i#0@@3| T@U) ) (!  (=> (and (and (and (and (and (and (= (type |l#0@@156|) TyType) (= (type |l#3@@124|) TyType)) (= (type |l#4|) TyType)) (= (type |l#5|) HandleTypeType)) (= (type |l#6|) (SeqType BoxType))) (= (type |$l#0#heap#0@@3|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@3|) BoxType)) (= (U_2_bool (MapType2Select (|lambda#150| |l#0@@156| |l#1@@129| |l#2@@126| |l#3@@124| |l#4| |l#5| |l#6|) |$l#0#heap#0@@3| |$l#0#i#0@@3|))  (and ($IsBox |$l#0#i#0@@3| |l#0@@156|) (and (and (INTERNAL_le_boogie |l#1@@129| (U_2_int ($Unbox intType |$l#0#i#0@@3|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$l#0#i#0@@3|)) |l#2@@126|)) (Requires1 |l#3@@124| |l#4| |$l#0#heap#0@@3| |l#5| (|Seq#Index| |l#6| (U_2_int ($Unbox intType |$l#0#i#0@@3|))))))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |5166|
 :pattern ( (MapType2Select (|lambda#150| |l#0@@156| |l#1@@129| |l#2@@126| |l#3@@124| |l#4| |l#5| |l#6|) |$l#0#heap#0@@3| |$l#0#i#0@@3|))
)))
(assert (forall ((arg0@@784 T@U) (arg1@@478 Int) (arg2@@298 Int) (arg3@@225 T@U) (arg4@@58 T@U) (arg5@@22 T@U) (arg6@@8 T@U) (arg7@@4 T@U) (arg8@@4 T@U) (arg9@@2 T@U) (arg10@@2 T@U) (arg11 T@U) (arg12 T@U) ) (! (= (type (|lambda#151| arg0@@784 arg1@@478 arg2@@298 arg3@@225 arg4@@58 arg5@@22 arg6@@8 arg7@@4 arg8@@4 arg9@@2 arg10@@2 arg11 arg12)) (MapType0Type refType boolType))
 :qid |funType:lambda#151|
 :pattern ( (|lambda#151| arg0@@784 arg1@@478 arg2@@298 arg3@@225 arg4@@58 arg5@@22 arg6@@8 arg7@@4 arg8@@4 arg9@@2 arg10@@2 arg11 arg12))
)))
(assert (forall ((|l#0@@157| T@U) (|l#1@@130| Int) (|l#2@@127| Int) (|l#3@@125| T@U) (|l#4@@0| T@U) (|l#5@@0| T@U) (|l#6@@0| T@U) (|l#7| T@U) (|l#8| T@U) (|l#9| T@U) (|l#10| T@U) (|l#11| T@U) (|l#12| T@U) (|$l#0#o#0@@0| T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (and (= (type |l#0@@157|) TyType) (= (type |l#3@@125|) TyType)) (= (type |l#4@@0|) TyType)) (= (type |l#5@@0|) (MapType0Type refType MapType1Type))) (= (type |l#6@@0|) HandleTypeType)) (= (type |l#7|) (SeqType BoxType))) (= (type |l#8|) TyType)) (= (type |l#9|) TyType)) (= (type |l#10|) (MapType0Type refType MapType1Type))) (= (type |l#11|) HandleTypeType)) (= (type |l#12|) (SeqType BoxType))) (= (type |$l#0#o#0@@0|) refType)) (= (U_2_bool (MapType0Select (|lambda#151| |l#0@@157| |l#1@@130| |l#2@@127| |l#3@@125| |l#4@@0| |l#5@@0| |l#6@@0| |l#7| |l#8| |l#9| |l#10| |l#11| |l#12|) |$l#0#o#0@@0|)) (exists ((|i#3@@11| Int) (|o#0| T@U) ) (!  (and (= (type |o#0|) refType) (and (and ($Is |o#0| |l#0@@157|) (and (and (INTERNAL_le_boogie |l#1@@130| |i#3@@11|) (INTERNAL_lt_boogie |i#3@@11| |l#2@@127|)) (U_2_bool (MapType0Select (Reads1 |l#3@@125| |l#4@@0| |l#5@@0| |l#6@@0| (|Seq#Index| |l#7| |i#3@@11|)) ($Box |o#0|))))) (= ($Box |$l#0#o#0@@0|) ($Box |o#0|))))
 :qid |Sequencesidfy.142:17|
 :skolemid |3277|
 :pattern ( (MapType0Select (Reads1 |l#8| |l#9| |l#10| |l#11| (|Seq#Index| |l#12| |i#3@@11|)) ($Box |o#0|)))
))))
 :qid |unknown.0:0|
 :skolemid |5167|
 :pattern ( (MapType0Select (|lambda#151| |l#0@@157| |l#1@@130| |l#2@@127| |l#3@@125| |l#4@@0| |l#5@@0| |l#6@@0| |l#7| |l#8| |l#9| |l#10| |l#11| |l#12|) |$l#0#o#0@@0|))
)))
(assert (forall ((|l#0@@158| T@U) (|l#1@@131| Int) (|l#2@@128| Int) (|l#3@@126| T@U) (|l#4@@1| T@U) (|l#5@@1| T@U) (|l#6@@1| T@U) (|l#7@@0| T@U) (|l#8@@0| T@U) (|l#9@@0| T@U) (|l#10@@0| T@U) (|$l#0#heap#0@@4| T@U) (|$l#0#i#0@@4| T@U) ) (!  (=> (and (and (and (and (and (and (and (and (and (and (= (type |l#0@@158|) TyType) (= (type |l#3@@126|) TyType)) (= (type |l#4@@1|) TyType)) (= (type |l#5@@1|) HandleTypeType)) (= (type |l#6@@1|) (SeqType BoxType))) (= (type |l#7@@0|) TyType)) (= (type |l#8@@0|) TyType)) (= (type |l#9@@0|) HandleTypeType)) (= (type |l#10@@0|) (SeqType BoxType))) (= (type |$l#0#heap#0@@4|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@4|) BoxType)) (= (MapType2Select (|lambda#152| |l#0@@158| |l#1@@131| |l#2@@128| |l#3@@126| |l#4@@1| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |l#9@@0| |l#10@@0|) |$l#0#heap#0@@4| |$l#0#i#0@@4|) (SetRef_to_SetBox (|lambda#151| |l#0@@158| |l#1@@131| |l#2@@128| |l#3@@126| |l#4@@1| |$l#0#heap#0@@4| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |$l#0#heap#0@@4| |l#9@@0| |l#10@@0|))))
 :qid |unknown.0:0|
 :skolemid |5168|
 :pattern ( (MapType2Select (|lambda#152| |l#0@@158| |l#1@@131| |l#2@@128| |l#3@@126| |l#4@@1| |l#5@@1| |l#6@@1| |l#7@@0| |l#8@@0| |l#9@@0| |l#10@@0|) |$l#0#heap#0@@4| |$l#0#i#0@@4|))
)))
(assert (forall ((|$l#2#heap#0| T@U) (|$l#2#a#0| T@U) (|$l#2#e#0| T@U) ) (!  (=> (and (and (= (type |$l#2#heap#0|) (MapType0Type refType MapType1Type)) (= (type |$l#2#a#0|) BoxType)) (= (type |$l#2#e#0|) BoxType)) (= (MapType3Select |lambda#164| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|) ($Box (|Set#Union| ($Unbox (MapType0Type BoxType boolType) |$l#2#a#0|) ($Unbox (MapType0Type BoxType boolType) |$l#2#e#0|)))))
 :qid |DafnyPreludebpl.545:12|
 :skolemid |5169|
 :pattern ( (MapType3Select |lambda#164| |$l#2#heap#0| |$l#2#a#0| |$l#2#e#0|))
)))
(assert (forall ((|l#0@@159| T@U) (|l#1@@132| T@U) (|$l#2#heap#0@@0| T@U) (|$l#2#a#0@@0| T@U) (|$l#2#e#0@@0| T@U) ) (!  (=> (and (and (and (and (= (type |l#0@@159|) TyType) (= (type |l#1@@132|) TyType)) (= (type |$l#2#heap#0@@0|) (MapType0Type refType MapType1Type))) (= (type |$l#2#a#0@@0|) BoxType)) (= (type |$l#2#e#0@@0|) BoxType)) (= (U_2_bool (MapType3Select (|lambda#165| |l#0@@159| |l#1@@132|) |$l#2#heap#0@@0| |$l#2#a#0@@0| |$l#2#e#0@@0|))  (and ($IsBox |$l#2#a#0@@0| |l#0@@159|) ($IsBox |$l#2#e#0@@0| |l#1@@132|))))
 :qid |unknown.0:0|
 :skolemid |5170|
 :pattern ( (MapType3Select (|lambda#165| |l#0@@159| |l#1@@132|) |$l#2#heap#0@@0| |$l#2#a#0@@0| |$l#2#e#0@@0|))
)))
(assert (forall ((|l#0@@160| T@U) (|$l#2#heap#0@@1| T@U) (|$l#2#a#0@@1| T@U) (|$l#2#e#0@@1| T@U) ) (!  (=> (and (and (and (= (type |l#0@@160|) (MapType0Type BoxType boolType)) (= (type |$l#2#heap#0@@1|) (MapType0Type refType MapType1Type))) (= (type |$l#2#a#0@@1|) BoxType)) (= (type |$l#2#e#0@@1|) BoxType)) (= (MapType3Select (|lambda#167| |l#0@@160|) |$l#2#heap#0@@1| |$l#2#a#0@@1| |$l#2#e#0@@1|) |l#0@@160|))
 :qid |Sequencesidfy.350:15|
 :skolemid |5171|
 :pattern ( (MapType3Select (|lambda#167| |l#0@@160|) |$l#2#heap#0@@1| |$l#2#a#0@@1| |$l#2#e#0@@1|))
)))
(assert (forall ((|l#0@@161| T@U) (|l#1@@133| T@U) (|l#2@@129| T@U) (|$w#0@@1| T@U) ) (!  (=> (and (and (and (= (type |l#0@@161|) TyType) (= (type |l#1@@133|) (MapType0Type BoxType boolType))) (= (type |l#2@@129|) BoxType)) (= (type |$w#0@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#184| |l#0@@161| |l#1@@133| |l#2@@129|) |$w#0@@1|))  (and ($IsBox |$w#0@@1| |l#0@@161|) (and (U_2_bool (MapType0Select |l#1@@133| |$w#0@@1|)) (not (= |$w#0@@1| |l#2@@129|))))))
 :qid |unknown.0:0|
 :skolemid |5172|
 :pattern ( (MapType0Select (|lambda#184| |l#0@@161| |l#1@@133| |l#2@@129|) |$w#0@@1|))
)))
(assert (forall ((|l#0@@162| T@U) (|$w#0@@2| T@U) ) (!  (=> (and (= (type |l#0@@162|) (MapType0Type BoxType BoxType)) (= (type |$w#0@@2|) BoxType)) (= (MapType0Select (|lambda#185| |l#0@@162|) |$w#0@@2|) (MapType0Select |l#0@@162| |$w#0@@2|)))
 :qid |MapRemovesdfy.22:44|
 :skolemid |5173|
 :pattern ( (MapType0Select (|lambda#185| |l#0@@162|) |$w#0@@2|))
)))
(assert (forall ((|l#0@@163| T@U) (|l#1@@134| T@U) (|l#2@@130| T@U) (|$w#0@@3| T@U) ) (!  (=> (and (and (and (= (type |l#0@@163|) TyType) (= (type |l#1@@134|) (MapType0Type BoxType boolType))) (= (type |l#2@@130|) (MapType0Type BoxType boolType))) (= (type |$w#0@@3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#190| |l#0@@163| |l#1@@134| |l#2@@130|) |$w#0@@3|))  (and ($IsBox |$w#0@@3| |l#0@@163|) (and (U_2_bool (MapType0Select |l#1@@134| |$w#0@@3|)) (not (U_2_bool (MapType0Select |l#2@@130| |$w#0@@3|)))))))
 :qid |unknown.0:0|
 :skolemid |5174|
 :pattern ( (MapType0Select (|lambda#190| |l#0@@163| |l#1@@134| |l#2@@130|) |$w#0@@3|))
)))
(assert (forall ((|l#0@@164| T@U) (|l#1@@135| T@U) (|l#2@@131| T@U) (|$w#0@@4| T@U) ) (!  (=> (and (and (and (= (type |l#0@@164|) TyType) (= (type |l#1@@135|) TyType)) (= (type |l#2@@131|) (IMapType BoxType BoxType))) (= (type |$w#0@@4|) BoxType)) (= (MapType0Select (|lambda#195| |l#0@@164| |l#1@@135| |l#2@@131|) |$w#0@@4|) (let ((|a#0@@219| (|$let#8_a| |l#0@@164| |l#1@@135| |l#2@@131| |$w#0@@4|)))
|a#0@@219|)))
 :qid |unknown.0:0|
 :skolemid |5175|
 :pattern ( (MapType0Select (|lambda#195| |l#0@@164| |l#1@@135| |l#2@@131|) |$w#0@@4|))
)))
(assert (forall ((|l#0@@165| T@U) (|l#1@@136| T@U) (|l#2@@132| T@U) (|$w#0@@5| T@U) ) (!  (=> (and (and (and (= (type |l#0@@165|) TyType) (= (type |l#1@@136|) (MapType0Type BoxType boolType))) (= (type |l#2@@132|) (MapType0Type BoxType boolType))) (= (type |$w#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#206| |l#0@@165| |l#1@@136| |l#2@@132|) |$w#0@@5|))  (and ($IsBox |$w#0@@5| |l#0@@165|) (and (U_2_bool (MapType0Select |l#1@@136| |$w#0@@5|)) (U_2_bool (MapType0Select |l#2@@132| |$w#0@@5|))))))
 :qid |unknown.0:0|
 :skolemid |5176|
 :pattern ( (MapType0Select (|lambda#206| |l#0@@165| |l#1@@136| |l#2@@132|) |$w#0@@5|))
)))
(assert (forall ((|l#0@@166| T@U) (|l#1@@137| T@U) (|l#2@@133| T@U) (|$w#0@@6| T@U) ) (!  (=> (and (and (and (= (type |l#0@@166|) (MapType0Type BoxType boolType)) (= (type |l#1@@137|) (MapType0Type BoxType BoxType))) (= (type |l#2@@133|) (MapType0Type BoxType BoxType))) (= (type |$w#0@@6|) BoxType)) (= (MapType0Select (|lambda#221| |l#0@@166| |l#1@@137| |l#2@@133|) |$w#0@@6|) (ite (U_2_bool (MapType0Select |l#0@@166| |$w#0@@6|)) (MapType0Select |l#1@@137| |$w#0@@6|) (MapType0Select |l#2@@133| |$w#0@@6|))))
 :qid |Mapsidfy.134:52|
 :skolemid |5177|
 :pattern ( (MapType0Select (|lambda#221| |l#0@@166| |l#1@@137| |l#2@@133|) |$w#0@@6|))
)))
(assert (forall ((|l#0@@167| T@U) (|l#1@@138| T@U) (|l#2@@134| T@U) (|l#3@@127| T@U) (|l#4@@2| T@U) (|$w#0@@7| T@U) ) (!  (=> (and (and (and (and (and (= (type |l#0@@167|) (MapType0Type BoxType boolType)) (= (type |l#1@@138|) (MapType0Type BoxType BoxType))) (= (type |l#2@@134|) (MapType0Type BoxType boolType))) (= (type |l#3@@127|) (MapType0Type BoxType BoxType))) (= (type |l#4@@2|) (MapType0Type BoxType BoxType))) (= (type |$w#0@@7|) BoxType)) (= (MapType0Select (|lambda#241| |l#0@@167| |l#1@@138| |l#2@@134| |l#3@@127| |l#4@@2|) |$w#0@@7|) (ite (U_2_bool (MapType0Select |l#0@@167| |$w#0@@7|)) (MapType0Select |l#1@@138| |$w#0@@7|) (ite (U_2_bool (MapType0Select |l#2@@134| |$w#0@@7|)) (MapType0Select |l#3@@127| |$w#0@@7|) (MapType0Select |l#4@@2| |$w#0@@7|)))))
 :qid |Mapsidfy.212:9|
 :skolemid |5178|
 :pattern ( (MapType0Select (|lambda#241| |l#0@@167| |l#1@@138| |l#2@@134| |l#3@@127| |l#4@@2|) |$w#0@@7|))
)))
(assert (forall ((|l#0@@168| T@U) (|l#1@@139| Int) (|l#2@@135| Int) (|$y#0@@2| T@U) ) (!  (=> (and (= (type |l#0@@168|) TyType) (= (type |$y#0@@2|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#248| |l#0@@168| |l#1@@139| |l#2@@135|) |$y#0@@2|))  (and ($IsBox |$y#0@@2| |l#0@@168|) (and (INTERNAL_le_boogie |l#1@@139| (U_2_int ($Unbox intType |$y#0@@2|))) (INTERNAL_lt_boogie (U_2_int ($Unbox intType |$y#0@@2|)) |l#2@@135|)))))
 :qid |DafnyPreludebpl.22:1|
 :skolemid |5179|
 :pattern ( (MapType0Select (|lambda#248| |l#0@@168| |l#1@@139| |l#2@@135|) |$y#0@@2|))
)))
(assert (forall ((|l#0@@169| T@U) (|l#1@@140| T@U) (|$l#0#heap#0@@5| T@U) (|$l#0#i#0@@5| T@U) ) (!  (=> (and (and (and (= (type |l#0@@169|) (SeqType BoxType)) (= (type |l#1@@140|) (MapType0Type BoxType boolType))) (= (type |$l#0#heap#0@@5|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@5|) BoxType)) (= (MapType2Select (|lambda#264| |l#0@@169| |l#1@@140|) |$l#0#heap#0@@5| |$l#0#i#0@@5|) ($Box (Buffers.Buffer.ApplyFilter ($Unbox DatatypeTypeType (|Seq#Index| |l#0@@169| (U_2_int ($Unbox intType |$l#0#i#0@@5|)))) |l#1@@140|))))
 :qid |Buffersidfy.55:63|
 :skolemid |5180|
 :pattern ( (MapType2Select (|lambda#264| |l#0@@169| |l#1@@140|) |$l#0#heap#0@@5| |$l#0#i#0@@5|))
)))
(assert (forall ((|l#0@@170| T@U) (|$y#0@@3| T@U) ) (!  (=> (and (= (type |l#0@@170|) TyType) (= (type |$y#0@@3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#279| |l#0@@170|) |$y#0@@3|))  (and ($IsBox |$y#0@@3| |l#0@@170|) (Buffers.__default.AnyKey ($Unbox (SeqType BoxType) |$y#0@@3|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |5181|
 :pattern ( (MapType0Select (|lambda#279| |l#0@@170|) |$y#0@@3|))
)))
(assert (forall ((|l#0@@171| T@U) (|l#1@@141| Int) (|$y#2| T@U) ) (!  (=> (and (= (type |l#0@@171|) TyType) (= (type |$y#2|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#283| |l#0@@171| |l#1@@141|) |$y#2|))  (and ($IsBox |$y#2| |l#0@@171|) (Byte__Order.__default.lt (U_2_int ($Unbox intType |$y#2|)) |l#1@@141|))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |5182|
 :pattern ( (MapType0Select (|lambda#283| |l#0@@171| |l#1@@141|) |$y#2|))
)))
(assert (forall ((|l#0@@172| T@U) (|l#1@@142| T@U) (|l#2@@136| Int) (|$y#3| T@U) ) (!  (=> (and (and (= (type |l#0@@172|) TyType) (= (type |l#1@@142|) LayerTypeType)) (= (type |$y#3|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#285| |l#0@@172| |l#1@@142| |l#2@@136|) |$y#3|))  (and ($IsBox |$y#3| |l#0@@172|) (Byte__Order.__default.lte |l#1@@142| |l#2@@136| (U_2_int ($Unbox intType |$y#3|))))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |5183|
 :pattern ( (MapType0Select (|lambda#285| |l#0@@172| |l#1@@142| |l#2@@136|) |$y#3|))
)))
(assert (forall ((|l#0@@173| T@U) (|l#1@@143| T@U) (|$y#1| T@U) ) (!  (=> (and (and (= (type |l#0@@173|) TyType) (= (type |l#1@@143|) (SeqType BoxType))) (= (type |$y#1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#295| |l#0@@173| |l#1@@143|) |$y#1|))  (and ($IsBox |$y#1| |l#0@@173|) (|Seq#Contains| |l#1@@143| |$y#1|))))
 :qid |NativeTypessdfy.6:31|
 :skolemid |5184|
 :pattern ( (MapType0Select (|lambda#295| |l#0@@173| |l#1@@143|) |$y#1|))
)))
(assert (forall ((|l#0@@174| T@U) (|l#1@@144| T@U) (|$y#2@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@174|) TyType) (= (type |l#1@@144|) (SeqType BoxType))) (= (type |$y#2@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#299| |l#0@@174| |l#1@@144|) |$y#2@@0|))  (and ($IsBox |$y#2@@0| |l#0@@174|) (Lexicographic__Byte__Order.__default.lt ($Unbox (SeqType BoxType) |$y#2@@0|) |l#1@@144|))))
 :qid |unknown.0:0|
 :skolemid |5185|
 :pattern ( (MapType0Select (|lambda#299| |l#0@@174| |l#1@@144|) |$y#2@@0|))
)))
(assert (forall ((|l#0@@175| T@U) (|l#1@@145| T@U) (|$y#3@@0| T@U) ) (!  (=> (and (and (= (type |l#0@@175|) TyType) (= (type |l#1@@145|) (SeqType BoxType))) (= (type |$y#3@@0|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#301| |l#0@@175| |l#1@@145|) |$y#3@@0|))  (and ($IsBox |$y#3@@0| |l#0@@175|) (Lexicographic__Byte__Order.__default.lte |l#1@@145| ($Unbox (SeqType BoxType) |$y#3@@0|)))))
 :qid |unknown.0:0|
 :skolemid |5186|
 :pattern ( (MapType0Select (|lambda#301| |l#0@@175| |l#1@@145|) |$y#3@@0|))
)))
(assert (forall ((|l#0@@176| T@U) (|$l#0#heap#0@@6| T@U) (|$l#0#i#0@@6| T@U) ) (!  (=> (and (and (= (type |l#0@@176|) (SeqType BoxType)) (= (type |$l#0#heap#0@@6|) (MapType0Type refType MapType1Type))) (= (type |$l#0#i#0@@6|) BoxType)) (= (MapType2Select (|lambda#315| |l#0@@176|) |$l#0#heap#0@@6| |$l#0#i#0@@6|) ($Box (|#Upperbounded_Lexicographic_Byte_Order.Element.Element| ($Unbox (SeqType BoxType) (|Seq#Index| |l#0@@176| (U_2_int ($Unbox intType |$l#0#i#0@@6|))))))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.961:23|
 :skolemid |5187|
 :pattern ( (MapType2Select (|lambda#315| |l#0@@176|) |$l#0#heap#0@@6| |$l#0#i#0@@6|))
)))
(assert (forall ((|l#0@@177| T@U) (|l#1@@146| T@U) (|$y#2@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@177|) TyType) (= (type |l#1@@146|) DatatypeTypeType)) (= (type |$y#2@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#325| |l#0@@177| |l#1@@146|) |$y#2@@1|))  (and ($IsBox |$y#2@@1| |l#0@@177|) (Upperbounded__Lexicographic__Byte__Order.__default.lt ($Unbox DatatypeTypeType |$y#2@@1|) |l#1@@146|))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:12|
 :skolemid |5188|
 :pattern ( (MapType0Select (|lambda#325| |l#0@@177| |l#1@@146|) |$y#2@@1|))
)))
(assert (forall ((|l#0@@178| T@U) (|l#1@@147| T@U) (|$y#3@@1| T@U) ) (!  (=> (and (and (= (type |l#0@@178|) TyType) (= (type |l#1@@147|) DatatypeTypeType)) (= (type |$y#3@@1|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#327| |l#0@@178| |l#1@@147|) |$y#3@@1|))  (and ($IsBox |$y#3@@1| |l#0@@178|) (Upperbounded__Lexicographic__Byte__Order.__default.lte |l#1@@147| ($Unbox DatatypeTypeType |$y#3@@1|)))))
 :qid |totalorderidfyUpperboundedLexicographicByteOrder.957:12|
 :skolemid |5189|
 :pattern ( (MapType0Select (|lambda#327| |l#0@@178| |l#1@@147|) |$y#3@@1|))
)))
(assert (forall ((|l#0@@179| T@U) (|l#1@@148| T@U) (|l#2@@137| T@U) (|l#3@@128| Int) (|$y#0@@4| T@U) ) (!  (=> (and (and (and (= (type |l#0@@179|) TyType) (= (type |l#1@@148|) (SeqType BoxType))) (= (type |l#2@@137|) (SeqType BoxType))) (= (type |$y#0@@4|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#351| |l#0@@179| |l#1@@148| |l#2@@137| |l#3@@128|) |$y#0@@4|))  (and ($IsBox |$y#0@@4| |l#0@@179|) (and (BoundedPivotsLib.__default.BoundedKey |l#1@@148| ($Unbox (SeqType BoxType) |$y#0@@4|)) (= (BoundedPivotsLib.__default.Route |l#2@@137| ($Unbox (SeqType BoxType) |$y#0@@4|)) |l#3@@128|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |5190|
 :pattern ( (MapType0Select (|lambda#351| |l#0@@179| |l#1@@148| |l#2@@137| |l#3@@128|) |$y#0@@4|))
)))
(assert (forall ((|l#0@@180| T@U) (|l#1@@149| T@U) (|$y#0@@5| T@U) ) (!  (=> (and (and (= (type |l#0@@180|) TyType) (= (type |l#1@@149|) DatatypeTypeType)) (= (type |$y#0@@5|) BoxType)) (= (U_2_bool (MapType0Select (|lambda#353| |l#0@@180| |l#1@@149|) |$y#0@@5|))  (and ($IsBox |$y#0@@5| |l#0@@180|) (DomainMod.Domain.Contains |l#1@@149| ($Unbox (SeqType BoxType) |$y#0@@5|)))))
 :qid |KeyTypesdfy.10:8|
 :skolemid |5191|
 :pattern ( (MapType0Select (|lambda#353| |l#0@@180| |l#1@@149|) |$y#0@@5|))
)))
(declare-fun ControlFlow (Int Int) Int)
(declare-fun this@@325 () T@U)
(declare-fun |out#0@@6| () T@U)
(declare-fun $_Frame@0 () T@U)
(declare-fun $Heap@@108 () T@U)
(declare-fun |newChild#Z#0@0| () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun |b$reqreads#2@0| () Bool)
(declare-fun $_Frame@0@@0 () T@U)
(declare-fun |replacement#0@@17| () T@U)
(declare-fun |b$reqreads#3@0| () Bool)
(declare-fun |let#0#0#0| () T@U)
(declare-fun |##children#0@0| () T@U)
(declare-fun |##pt#0@0| () T@U)
(declare-fun |##key#0@0| () T@U)
(declare-fun |b$reqreads#4@0| () Bool)
(declare-fun StartFuel_Sequences._default.Range () T@U)
(declare-fun StartFuelAssert_Sequences._default.Range () T@U)
(declare-fun StartFuel_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuelAssert_Sequences._default.ApplyOpaque () T@U)
(declare-fun StartFuel_Sequences._default.remove () T@U)
(declare-fun StartFuelAssert_Sequences._default.remove () T@U)
(declare-fun StartFuel_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuelAssert_Sequences._default.RemoveOneValue () T@U)
(declare-fun StartFuelAssert_Sequences._default.insert () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace1with2 () T@U)
(declare-fun StartFuel_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuelAssert_Sequences._default.replace2with1 () T@U)
(declare-fun StartFuel_Sequences._default.concat () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat () T@U)
(declare-fun StartFuel_Sequences._default.concat3 () T@U)
(declare-fun StartFuelAssert_Sequences._default.concat3 () T@U)
(declare-fun StartFuel_Sequences._default.concatSeq () T@U)
(declare-fun StartFuelAssert_Sequences._default.concatSeq () T@U)
(declare-fun StartFuel_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsPrefix () T@U)
(declare-fun StartFuel_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuelAssert_Sequences._default.IsSuffix () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexIterate () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndex () T@U)
(declare-fun StartFuel_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqOfLength () T@U)
(declare-fun StartFuel_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuelAssert_Sequences._default.SeqIndexUpdate () T@U)
(declare-fun StartFuel_Sequences._default.Zip () T@U)
(declare-fun StartFuelAssert_Sequences._default.Zip () T@U)
(declare-fun StartFuelAssert_Sequences._default.Unzip () T@U)
(declare-fun StartFuel_Sequences._default.Flatten () T@U)
(declare-fun StartFuelAssert_Sequences._default.Flatten () T@U)
(declare-fun StartFuel_Sequences._default.seqMax () T@U)
(declare-fun StartFuelAssert_Sequences._default.seqMax () T@U)
(declare-fun StartFuel_Sequences._default.fill () T@U)
(declare-fun StartFuelAssert_Sequences._default.fill () T@U)
(declare-fun StartFuel_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemoveStrong () T@U)
(declare-fun StartFuel_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuelAssert_Maps._default.MapRemove1Strong () T@U)
(declare-fun StartFuel_Maps._default.IMapInvert () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapInvert () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove () T@U)
(declare-fun StartFuel_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapRemove1 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferA () T@U)
(declare-fun StartFuel_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.MapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.MapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferA () T@U)
(declare-fun StartFuel_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnionPreferB () T@U)
(declare-fun StartFuel_Maps._default.IMapUnion () T@U)
(declare-fun StartFuelAssert_Maps._default.IMapUnion () T@U)
(declare-fun StartFuel_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuelAssert_Maps._default.MapDisjointUnion3 () T@U)
(declare-fun StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet () T@U)
(declare-fun StartFuelAssert_SeqComparison._default.lte () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.lte () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuel_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum () T@U)
(declare-fun StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt () T@U)
(declare-fun StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft () T@U)
(declare-fun StartFuelAssert_BoundedPivotsLib._default.CutoffForRight () T@U)
(declare-fun StartFuelAssert_DomainMod.Domain.SaneKeys () T@U)
(declare-fun |b$reqreads#0@0| () Bool)
(declare-fun |b$reqreads#1@0| () Bool)
(assert  (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (and (= (type this@@325) DatatypeTypeType) (= (type |replacement#0@@17|) DatatypeTypeType)) (= (type $Heap@@108) (MapType0Type refType MapType1Type))) (= (type |out#0@@6|) (SeqType BoxType))) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type $_Frame@0) (MapType6Type refType boolType))) (= (type |newChild#Z#0@0|) DatatypeTypeType)) (= (type $_Frame@0@@0) (MapType6Type refType boolType))) (= (type |let#0#0#0|) DatatypeTypeType)) (= (type |##children#0@0|) (SeqType BoxType))) (= (type |##pt#0@0|) (SeqType BoxType))) (= (type |##key#0@0|) (SeqType BoxType))) (= (type StartFuel_Sequences._default.Range) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Range) LayerTypeType)) (= (type StartFuel_Sequences._default.ApplyOpaque) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.ApplyOpaque) LayerTypeType)) (= (type StartFuel_Sequences._default.remove) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.remove) LayerTypeType)) (= (type StartFuel_Sequences._default.RemoveOneValue) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.RemoveOneValue) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.insert) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.replace1with2) LayerTypeType)) (= (type StartFuel_Sequences._default.replace2with1) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.replace2with1) LayerTypeType)) (= (type StartFuel_Sequences._default.concat) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concat) LayerTypeType)) (= (type StartFuel_Sequences._default.concat3) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concat3) LayerTypeType)) (= (type StartFuel_Sequences._default.concatSeq) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.concatSeq) LayerTypeType)) (= (type StartFuel_Sequences._default.IsPrefix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.IsPrefix) LayerTypeType)) (= (type StartFuel_Sequences._default.IsSuffix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.IsSuffix) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndexIterate) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqIndex) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndex) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqOfLength) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqOfLength) LayerTypeType)) (= (type StartFuel_Sequences._default.SeqIndexUpdate) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.SeqIndexUpdate) LayerTypeType)) (= (type StartFuel_Sequences._default.Zip) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Zip) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Unzip) LayerTypeType)) (= (type StartFuel_Sequences._default.Flatten) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.Flatten) LayerTypeType)) (= (type StartFuel_Sequences._default.seqMax) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.seqMax) LayerTypeType)) (= (type StartFuel_Sequences._default.fill) LayerTypeType)) (= (type StartFuelAssert_Sequences._default.fill) LayerTypeType)) (= (type StartFuel_Maps._default.MapRemoveStrong) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemoveStrong) LayerTypeType)) (= (type StartFuel_Maps._default.MapRemove1Strong) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapRemove1Strong) LayerTypeType)) (= (type StartFuel_Maps._default.IMapInvert) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapInvert) LayerTypeType)) (= (type StartFuel_Maps._default.IMapRemove) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapRemove) LayerTypeType)) (= (type StartFuel_Maps._default.IMapRemove1) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapRemove1) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapDisjointUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnionPreferA) LayerTypeType)) (= (type StartFuel_Maps._default.MapUnionPreferB) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnionPreferB) LayerTypeType)) (= (type StartFuel_Maps._default.MapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnionPreferA) LayerTypeType)) (= (type StartFuel_Maps._default.IMapUnionPreferB) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnionPreferB) LayerTypeType)) (= (type StartFuel_Maps._default.IMapUnion) LayerTypeType)) (= (type StartFuelAssert_Maps._default.IMapUnion) LayerTypeType)) (= (type StartFuel_Maps._default.MapDisjointUnion3) LayerTypeType)) (= (type StartFuelAssert_Maps._default.MapDisjointUnion3) LayerTypeType)) (= (type StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) LayerTypeType)) (= (type StartFuelAssert_SeqComparison._default.lte) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.lte) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuel_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum) LayerTypeType)) (= (type StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) LayerTypeType)) (= (type StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft) LayerTypeType)) (= (type StartFuelAssert_BoundedPivotsLib._default.CutoffForRight) LayerTypeType)) (= (type StartFuelAssert_DomainMod.Domain.SaneKeys) LayerTypeType)))
(push 1)
(set-info :boogie-vc-id CheckWellformed$$PivotBetree.Path.ReplacedChildren)
(set-option :timeout 0)
(set-option :rlimit 16350000)
(assert (not
 (=> (= (ControlFlow 0 0) 666700) (let ((GeneratedUnifiedExit_correct  (and (=> (= (ControlFlow 0 666669) (- 0 682140)) (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (=> (|PivotBetree.__default.WFChildren#canCall| |out#0@@6|) (or (PivotBetree.__default.WFChildren ($LS $LZ) |out#0@@6|) (U_2_bool (Lit (bool_2_U true))))))))) (=> (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (=> (|PivotBetree.__default.WFChildren#canCall| |out#0@@6|) (or (PivotBetree.__default.WFChildren ($LS $LZ) |out#0@@6|) (U_2_bool (Lit (bool_2_U true)))))))) (and (=> (= (ControlFlow 0 666669) (- 0 682190)) (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (=> (|PivotBetree.__default.WFChildren#canCall| |out#0@@6|) (or (PivotBetree.__default.WFChildren ($LS $LZ) |out#0@@6|) (forall ((|i#0@@184| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@184|) (INTERNAL_lt_boogie |i#0@@184| (|Seq#Length| |out#0@@6|))) (PivotBetree.BetreeNode.WF ($LS ($LS $LZ)) ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#0@@184|))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2161|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#0@@184|)))
)))))))) (=> (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (=> (|PivotBetree.__default.WFChildren#canCall| |out#0@@6|) (or (PivotBetree.__default.WFChildren ($LS $LZ) |out#0@@6|) (forall ((|i#0@@185| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#0@@185|) (INTERNAL_lt_boogie |i#0@@185| (|Seq#Length| |out#0@@6|))) (PivotBetree.BetreeNode.WF ($LS ($LS $LZ)) ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#0@@185|))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2161|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#0@@185|)))
))))))) (and (=> (= (ControlFlow 0 666669) (- 0 682286)) (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (= (|Seq#Length| |out#0@@6|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)))))))) (=> (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (= (|Seq#Length| |out#0@@6|) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))) (=> (= (ControlFlow 0 666669) (- 0 682330)) (=> (|PivotBetree.Path.ChildrenHaveMatchingDomains#canCall| this@@325 |out#0@@6|) (or (PivotBetree.Path.ChildrenHaveMatchingDomains this@@325 |out#0@@6|) (=> (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (forall ((|i#1@@74| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#1@@74|) (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#1@@74|)) (and (and (PivotBetree.BetreeNode.WF ($LS ($LS $LZ)) ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#1@@74|))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#1@@74|)))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#1@@74|))) (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#1@@74|))))))
 :qid |PivotBetreebrokenidfy.498:18|
 :skolemid |2164|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#1@@74|)))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |out#0@@6| |i#1@@74|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#1@@74|))
))))))))))))))
(let ((anon4_Else_correct  (=> (= $_Frame@0 (|lambda#82| null $Heap@@108 alloc false)) (=> (and (and ($Is |newChild#Z#0@0| Tclass.PivotBetree.BetreeNode) ($IsAlloc |newChild#Z#0@0| Tclass.PivotBetree.BetreeNode $Heap@@108)) ($IsAlloc this@@325 Tclass.PivotBetree.Path $Heap@@108)) (and (=> (= (ControlFlow 0 184660) (- 0 674742)) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325))) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (and (=> (= (ControlFlow 0 184660) (- 0 674758)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 674822)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 674920)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#16| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#16|) (INTERNAL_lt_boogie |i#16| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#16|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2197|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#16|)))
)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675064)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675176)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#17| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#17|) (INTERNAL_lt_boogie |i#17| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#17|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#17|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2198|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#17|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675358)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 2))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675458)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675544)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675610)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (forall ((|i#18| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#18|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#18|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#18|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#18|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#18|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#18|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2201|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#18|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#18|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#18|))
))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 675804)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))))) (and (=> (= (ControlFlow 0 184660) (- 0 675834)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676006)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676296)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))) (=> (and (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (= |b$reqreads#2@0| (forall (($o@@195 T@U) ($f@@125 T@U) ) (! (let ((alpha@@132 (FieldTypeInv0 (type $f@@125))))
 (=> (and (and (= (type $o@@195) refType) (= (type $f@@125) (FieldType alpha@@132))) false) (U_2_bool (MapType6Select $_Frame@0@@0 $o@@195 $f@@125))))
 :qid |PivotBetreebrokenidfy.512:23|
 :skolemid |2203|
 :no-pattern (type $o@@195)
 :no-pattern (type $f@@125)
 :no-pattern (U_2_int $o@@195)
 :no-pattern (U_2_bool $o@@195)
 :no-pattern (U_2_int $f@@125)
 :no-pattern (U_2_bool $f@@125)
)))) (=> (and (and (|PivotBetree.Path.Subpath#canCall| this@@325) (PivotBetree.Path.Path_q (PivotBetree.Path.Subpath this@@325))) (and ($IsAlloc (PivotBetree.Path.Subpath this@@325) Tclass.PivotBetree.Path $Heap@@108) ($IsAlloc |replacement#0@@17| Tclass.PivotBetree.BetreeNode $Heap@@108))) (and (=> (= (ControlFlow 0 184660) (- 0 676510)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676578)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676688)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (forall ((|i#19| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#19|) (INTERNAL_lt_boogie |i#19| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#19|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2204|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#19|)))
)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676848)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 676974)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (forall ((|i#20| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#20|) (INTERNAL_lt_boogie |i#20| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#20|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#20|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2205|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#20|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677178)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 2))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677290)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677386)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677456)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (forall ((|i#21| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#21|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#21|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#21|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#21|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#21|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#21|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2208|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#21|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#21|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#21|))
))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677674)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677774)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 677916)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (forall ((|i#22| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#22|) (INTERNAL_lt_boogie |i#22| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#22|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2210|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#22|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678108)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678266)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (forall ((|i#23| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#23|) (INTERNAL_lt_boogie |i#23| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#23|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#23|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2211|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#23|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678502)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 2))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678646)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678774)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 678876)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (forall ((|i#24| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#24|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#24|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#24|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#24|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#24|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#24|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2214|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#24|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#24|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) |i#24|))
))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 679126)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))))) (and (=> (= (ControlFlow 0 184660) (- 0 679186)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 679412)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325)))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 679778)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key (PivotBetree.Path.Subpath this@@325))) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))) 1)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 679986)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680046)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325))) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) (forall ((|i#25| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#25|) (INTERNAL_lt_boogie |i#25| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325)))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#25|))))
 :qid |PivotBetreebrokenidfy.99:18|
 :skolemid |2216|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node (PivotBetree.Path.Subpath this@@325))) |i#25|)))
)))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680160)) (=> (|PivotBetree.Path.Valid#canCall| (PivotBetree.Path.Subpath this@@325)) (or (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325))) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath (PivotBetree.Path.Subpath this@@325))))))) (=> (PivotBetree.Path.Valid ($LS $LZ) (PivotBetree.Path.Subpath this@@325)) (and (=> (= (ControlFlow 0 184660) (- 0 680216)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680262)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680330)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (forall ((|i#26| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#26|) (INTERNAL_lt_boogie |i#26| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|) |i#26|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2218|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|) |i#26|)))
)))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680438)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680517)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (forall ((|i#27| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#27|) (INTERNAL_lt_boogie |i#27| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|) |i#27|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|) |i#27|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2219|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|) |i#27|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680654)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|)) 2))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680724)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LocalStructure |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (= (|Seq#Length| (PivotBetree.BetreeNode.children |replacement#0@@17|)) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable |replacement#0@@17|))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680783)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children |replacement#0@@17|)))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680831)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.WF#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.WF ($LS $LZ) |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| |replacement#0@@17|) (or (PivotBetree.BetreeNode.LinkedChildren |replacement#0@@17|) (=> (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|) (forall ((|i#28| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#28|) (and (and (PivotBetree.BetreeNode.ValidChildIndex |replacement#0@@17| |i#28|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |replacement#0@@17|) |i#28|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |replacement#0@@17|) |i#28|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |replacement#0@@17|) |i#28|))) (PivotBetree.BetreeNode.DomainRoutedToChild |replacement#0@@17| |i#28|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2222|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild |replacement#0@@17| |i#28|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children |replacement#0@@17|) |i#28|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex |replacement#0@@17| |i#28|))
))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 680977)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (PivotBetree.BetreeNode.BetreeNode_q |replacement#0@@17|)))) (and (=> (= (ControlFlow 0 184660) (- 0 680998)) (=> (|PivotBetree.Path.ValidReplacement#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (or (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain |replacement#0@@17|) (PivotBetree.BetreeNode.MyDomain (PivotBetree.Path.Target ($LS ($LS $LZ)) (PivotBetree.Path.Subpath this@@325))))))) (=> (and (PivotBetree.Path.ValidReplacement (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (= |b$reqreads#3@0| (forall (($o@@196 T@U) ($f@@126 T@U) ) (! (let ((alpha@@133 (FieldTypeInv0 (type $f@@126))))
 (=> (and (and (= (type $o@@196) refType) (= (type $f@@126) (FieldType alpha@@133))) false) (U_2_bool (MapType6Select $_Frame@0@@0 $o@@196 $f@@126))))
 :qid |PivotBetreebrokenidfy.512:33|
 :skolemid |2224|
 :no-pattern (type $o@@196)
 :no-pattern (type $f@@126)
 :no-pattern (U_2_int $o@@196)
 :no-pattern (U_2_bool $o@@196)
 :no-pattern (U_2_int $f@@126)
 :no-pattern (U_2_bool $f@@126)
)))) (and (=> (= (ControlFlow 0 184660) (- 0 681062)) (or (<= 0 (PivotBetree.Path.depth this@@325)) (= (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325)))) (=> (or (<= 0 (PivotBetree.Path.depth this@@325)) (= (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325))) (and (=> (= (ControlFlow 0 184660) (- 0 681084)) (or (or (<= 0 (LitInt 0)) (< (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325))) (= (LitInt 1) (LitInt 0)))) (=> (or (or (<= 0 (LitInt 0)) (< (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325))) (= (LitInt 1) (LitInt 0))) (and (=> (= (ControlFlow 0 184660) (- 0 681118)) (or (< (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325)) (and (= (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325)) (< (LitInt 1) (LitInt 0))))) (=> (or (< (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325)) (and (= (PivotBetree.Path.depth (PivotBetree.Path.Subpath this@@325)) (PivotBetree.Path.depth this@@325)) (< (LitInt 1) (LitInt 0)))) (=> (and (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|) (= |let#0#0#0| (PivotBetree.Path.Substitute ($LS $LZ) (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|))) (=> (and (and (and (|PivotBetree.Path.Subpath#canCall| this@@325) (|PivotBetree.Path.Substitute#canCall| (PivotBetree.Path.Subpath this@@325) |replacement#0@@17|)) ($Is |let#0#0#0| Tclass.PivotBetree.BetreeNode)) (and (= |newChild#Z#0@0| |let#0#0#0|) (PivotBetree.Path.Path_q this@@325))) (and (=> (= (ControlFlow 0 184660) (- 0 681209)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (= |##children#0@0| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (=> (and (and ($IsAlloc |##children#0@0| (TSeq Tclass.PivotBetree.BetreeNode) $Heap@@108) (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)))) (and (PivotBetree.Path.Path_q this@@325) (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))) (and (=> (= (ControlFlow 0 184660) (- 0 681258)) (=> (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (or (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true)))))) (and (=> (= (ControlFlow 0 184660) (- 0 681286)) (=> (|PivotBetree.__default.WFChildren#canCall| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (or (PivotBetree.__default.WFChildren ($LS $LZ) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (forall ((|i#29| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#29|) (INTERNAL_lt_boogie |i#29| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))) (PivotBetree.BetreeNode.WF ($LS ($LS $LZ)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#29|))))
 :qid |PivotBetreebrokenidfy.40:16|
 :skolemid |2225|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#29|)))
))))) (=> (and (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (PivotBetree.Path.Path_q this@@325)) (and (=> (= (ControlFlow 0 184660) (- 0 681390)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (PivotBetree.Path.Path_q this@@325) (and (=> (= (ControlFlow 0 184660) (- 0 681400)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (PivotBetree.Path.Path_q this@@325) (=> (and (and (= |##pt#0@0| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) ($IsAlloc |##pt#0@0| (TSeq Tclass.Upperbounded__Lexicographic__Byte__Order.Element) $Heap@@108)) (and (= |##key#0@0| (PivotBetree.Path.key this@@325)) ($IsAlloc |##key#0@0| Tclass.KeyType.Key $Heap@@108))) (and (=> (= (ControlFlow 0 184660) (- 0 681448)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted |##pt#0@0|)))) (and (=> (= (ControlFlow 0 184660) (- 0 681463)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (forall ((|i#30| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#30|) (INTERNAL_lt_boogie |i#30| (BoundedPivotsLib.__default.NumBuckets |##pt#0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| |i#30|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2228|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| |i#30|)))
))))) (and (=> (= (ControlFlow 0 184660) (- 0 681514)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.ElementsAreKeys |##pt#0@0|) (U_2_bool (Lit (bool_2_U true)))))))) (and (=> (= (ControlFlow 0 184660) (- 0 681538)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.ElementsAreKeys |##pt#0@0|) (forall ((|i#31| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#31|) (INTERNAL_lt_boogie |i#31| (|Seq#Length| |##pt#0@0|))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| |i#31|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| |i#31|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2229|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| |i#31|)))
))))))) (and (=> (= (ControlFlow 0 184660) (- 0 681612)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| |##pt#0@0|) (or (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (INTERNAL_ge_boogie (|Seq#Length| |##pt#0@0|) 2)))) (=> (BoundedPivotsLib.__default.WFPivots |##pt#0@0|) (and (=> (= (ControlFlow 0 184660) (- 0 681632)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| |##pt#0@0| |##key#0@0|) (or (BoundedPivotsLib.__default.BoundedKey |##pt#0@0| |##key#0@0|) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement |##key#0@0|))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 681729)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| |##pt#0@0| |##key#0@0|) (or (BoundedPivotsLib.__default.BoundedKey |##pt#0@0| |##key#0@0|) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement |##key#0@0|)) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))))))))))))) (and (=> (= (ControlFlow 0 184660) (- 0 681891)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| |##pt#0@0| |##key#0@0|) (or (BoundedPivotsLib.__default.BoundedKey |##pt#0@0| |##key#0@0|) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement |##key#0@0|) ($Unbox DatatypeTypeType (|Seq#Index| |##pt#0@0| (INTERNAL_sub_boogie (|Seq#Length| |##pt#0@0|) 1)))))))))) (=> (BoundedPivotsLib.__default.BoundedKey |##pt#0@0| |##key#0@0|) (=> (and (= |b$reqreads#4@0| (forall (($o@@197 T@U) ($f@@127 T@U) ) (! (let ((alpha@@134 (FieldTypeInv0 (type $f@@127))))
 (=> (and (and (= (type $o@@197) refType) (= (type $f@@127) (FieldType alpha@@134))) false) (U_2_bool (MapType6Select $_Frame@0@@0 $o@@197 $f@@127))))
 :qid |PivotBetreebrokenidfy.516:21|
 :skolemid |2232|
 :no-pattern (type $o@@197)
 :no-pattern (type $f@@127)
 :no-pattern (U_2_int $o@@197)
 :no-pattern (U_2_bool $o@@197)
 :no-pattern (U_2_int $f@@127)
 :no-pattern (U_2_bool $f@@127)
))) (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325))) (and (=> (= (ControlFlow 0 184660) (- 0 682002)) (and (<= 0 (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325))) (< (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)))))) (=> (and (<= 0 (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325))) (< (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))) (=> (= (PivotBetree.Path.ReplacedChildren ($LS $LZ) this@@325 |replacement#0@@17|) (|Seq#Update| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) (BoundedPivotsLib.__default.Route (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) ($Box |newChild#Z#0@0|))) (=> (and (and (PivotBetree.Path.Path_q this@@325) (and (and (PivotBetree.Path.Path_q this@@325) (PivotBetree.Path.Path_q this@@325)) (|BoundedPivotsLib.__default.Route#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)))) (and ($Is (PivotBetree.Path.ReplacedChildren ($LS $LZ) this@@325 |replacement#0@@17|) (TSeq Tclass.PivotBetree.BetreeNode)) (= (PivotBetree.Path.ReplacedChildren ($LS $LZ) this@@325 |replacement#0@@17|) |out#0@@6|))) (and (=> (= (ControlFlow 0 184660) (- 0 682137)) |b$reqreads#2@0|) (=> |b$reqreads#2@0| (and (=> (= (ControlFlow 0 184660) (- 0 682138)) |b$reqreads#3@0|) (=> |b$reqreads#3@0| (and (=> (= (ControlFlow 0 184660) (- 0 682139)) |b$reqreads#4@0|) (=> |b$reqreads#4@0| (=> (= (ControlFlow 0 184660) 666669) GeneratedUnifiedExit_correct)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
(let ((anon4_Then_correct  (=> ($Is (PivotBetree.Path.ReplacedChildren ($LS $LZ) this@@325 |replacement#0@@17|) (TSeq Tclass.PivotBetree.BetreeNode)) (=> (and ($IsAlloc this@@325 Tclass.PivotBetree.Path $Heap@@108) ($IsAlloc |out#0@@6| (TSeq Tclass.PivotBetree.BetreeNode) $Heap@@108)) (and (=> (= (ControlFlow 0 184658) (- 0 671605)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 671661)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 671751)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#9| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#9|) (INTERNAL_lt_boogie |i#9| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#9|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2183|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#9|)))
)))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 671887)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 671991)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#10| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#10|) (INTERNAL_lt_boogie |i#10| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#10|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#10|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2184|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#10|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672165)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 2))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672257)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672335)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672393)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (forall ((|i#11| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#11|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#11|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#11|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#11|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#11|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#11|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2187|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#11|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#11|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#11|))
))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672579)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672659)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672773)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#12| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#12|) (INTERNAL_lt_boogie |i#12| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#12|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2189|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#12|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 672933)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673061)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#13| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#13|) (INTERNAL_lt_boogie |i#13| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#13|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#13|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2190|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#13|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673259)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 2))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673375)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673477)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673559)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (forall ((|i#14| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#14|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#14|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#14|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#14|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#14|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#14|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2193|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#14|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#14|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#14|))
))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673769)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))))))) (and (=> (= (ControlFlow 0 184658) (- 0 673815)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 674003)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 674309)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))))) (and (=> (= (ControlFlow 0 184658) (- 0 674479)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@325)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)))))))) (and (=> (= (ControlFlow 0 184658) (- 0 674527)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@325)) (forall ((|i#15| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#15|) (INTERNAL_lt_boogie |i#15| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#15|))))
 :qid |PivotBetreebrokenidfy.99:18|
 :skolemid |2195|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#15|)))
)))))))) (and (=> (= (ControlFlow 0 184658) (- 0 674625)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath this@@325)))))) (=> (and (PivotBetree.Path.Valid ($LS $LZ) this@@325) (= (ControlFlow 0 184658) (- 0 674671))) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325))))))))))))))))))))))))))))))))
(let ((anon0_correct  (=> (= $_Frame@0@@0 (|lambda#81| null $Heap@@108 alloc false)) (=> (and (and (= (AsFuelBottom StartFuel_Sequences._default.NoDupes) StartFuel_Sequences._default.NoDupes) (= (AsFuelBottom StartFuelAssert_Sequences._default.NoDupes) StartFuelAssert_Sequences._default.NoDupes)) (and (= (AsFuelBottom StartFuel_Sequences._default.Range) StartFuel_Sequences._default.Range) (= (AsFuelBottom StartFuelAssert_Sequences._default.Range) StartFuelAssert_Sequences._default.Range))) (=> (and (and (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.ApplyOpaque) StartFuel_Sequences._default.ApplyOpaque) (= (AsFuelBottom StartFuelAssert_Sequences._default.ApplyOpaque) StartFuelAssert_Sequences._default.ApplyOpaque)) (and (= (AsFuelBottom StartFuel_Sequences._default.remove) StartFuel_Sequences._default.remove) (= (AsFuelBottom StartFuelAssert_Sequences._default.remove) StartFuelAssert_Sequences._default.remove))) (and (and (= (AsFuelBottom StartFuel_Sequences._default.RemoveOneValue) StartFuel_Sequences._default.RemoveOneValue) (= (AsFuelBottom StartFuelAssert_Sequences._default.RemoveOneValue) StartFuelAssert_Sequences._default.RemoveOneValue)) (and (= (AsFuelBottom StartFuel_Sequences._default.insert) StartFuel_Sequences._default.insert) (= (AsFuelBottom StartFuelAssert_Sequences._default.insert) StartFuelAssert_Sequences._default.insert)))) (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.replace1with2) StartFuel_Sequences._default.replace1with2) (= (AsFuelBottom StartFuelAssert_Sequences._default.replace1with2) StartFuelAssert_Sequences._default.replace1with2)) (and (= (AsFuelBottom StartFuel_Sequences._default.replace2with1) StartFuel_Sequences._default.replace2with1) (= (AsFuelBottom StartFuelAssert_Sequences._default.replace2with1) StartFuelAssert_Sequences._default.replace2with1))) (and (and (= (AsFuelBottom StartFuel_Sequences._default.concat) StartFuel_Sequences._default.concat) (= (AsFuelBottom StartFuelAssert_Sequences._default.concat) StartFuelAssert_Sequences._default.concat)) (and (= (AsFuelBottom StartFuel_Sequences._default.concat3) StartFuel_Sequences._default.concat3) (= (AsFuelBottom StartFuelAssert_Sequences._default.concat3) StartFuelAssert_Sequences._default.concat3))))) (and (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.concatSeq) StartFuel_Sequences._default.concatSeq) (= (AsFuelBottom StartFuelAssert_Sequences._default.concatSeq) StartFuelAssert_Sequences._default.concatSeq)) (and (= (AsFuelBottom StartFuel_Sequences._default.IsPrefix) StartFuel_Sequences._default.IsPrefix) (= (AsFuelBottom StartFuelAssert_Sequences._default.IsPrefix) StartFuelAssert_Sequences._default.IsPrefix))) (and (and (= (AsFuelBottom StartFuel_Sequences._default.IsSuffix) StartFuel_Sequences._default.IsSuffix) (= (AsFuelBottom StartFuelAssert_Sequences._default.IsSuffix) StartFuelAssert_Sequences._default.IsSuffix)) (and (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexIterate) StartFuel_Sequences._default.SeqIndexIterate) (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexIterate) StartFuelAssert_Sequences._default.SeqIndexIterate)))) (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.SeqIndex) StartFuel_Sequences._default.SeqIndex) (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndex) StartFuelAssert_Sequences._default.SeqIndex)) (and (= (AsFuelBottom StartFuel_Sequences._default.SeqOfLength) StartFuel_Sequences._default.SeqOfLength) (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqOfLength) StartFuelAssert_Sequences._default.SeqOfLength))) (and (and (= (AsFuelBottom StartFuel_Sequences._default.SeqIndexUpdate) StartFuel_Sequences._default.SeqIndexUpdate) (= (AsFuelBottom StartFuelAssert_Sequences._default.SeqIndexUpdate) StartFuelAssert_Sequences._default.SeqIndexUpdate)) (and (= (AsFuelBottom StartFuel_Sequences._default.Zip) StartFuel_Sequences._default.Zip) (= (AsFuelBottom StartFuelAssert_Sequences._default.Zip) StartFuelAssert_Sequences._default.Zip)))))) (=> (and (and (and (and (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.Unzip) StartFuel_Sequences._default.Unzip) (= (AsFuelBottom StartFuelAssert_Sequences._default.Unzip) StartFuelAssert_Sequences._default.Unzip)) (and (= (AsFuelBottom StartFuel_Sequences._default.FlattenShape) StartFuel_Sequences._default.FlattenShape) (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenShape) StartFuelAssert_Sequences._default.FlattenShape))) (and (and (= (AsFuelBottom StartFuel_Sequences._default.FlattenLength) StartFuel_Sequences._default.FlattenLength) (= (AsFuelBottom StartFuelAssert_Sequences._default.FlattenLength) StartFuelAssert_Sequences._default.FlattenLength)) (and (= (AsFuelBottom StartFuel_Sequences._default.Flatten) StartFuel_Sequences._default.Flatten) (= (AsFuelBottom StartFuelAssert_Sequences._default.Flatten) StartFuelAssert_Sequences._default.Flatten)))) (and (and (and (= (AsFuelBottom StartFuel_Sequences._default.seqMax) StartFuel_Sequences._default.seqMax) (= (AsFuelBottom StartFuelAssert_Sequences._default.seqMax) StartFuelAssert_Sequences._default.seqMax)) (and (= (AsFuelBottom StartFuel_Sequences._default.fill) StartFuel_Sequences._default.fill) (= (AsFuelBottom StartFuelAssert_Sequences._default.fill) StartFuelAssert_Sequences._default.fill))) (and (and (= (AsFuelBottom StartFuel_MapRemove_s._default.MapRemove1) StartFuel_MapRemove_s._default.MapRemove1) (= (AsFuelBottom StartFuelAssert_MapRemove_s._default.MapRemove1) StartFuelAssert_MapRemove_s._default.MapRemove1)) (and (= (AsFuelBottom StartFuel_Maps._default.MapRemove) StartFuel_Maps._default.MapRemove) (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove) StartFuelAssert_Maps._default.MapRemove))))) (and (and (and (and (= (AsFuelBottom StartFuel_Maps._default.MapRemoveStrong) StartFuel_Maps._default.MapRemoveStrong) (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemoveStrong) StartFuelAssert_Maps._default.MapRemoveStrong)) (and (= (AsFuelBottom StartFuel_Maps._default.MapRemove1Strong) StartFuel_Maps._default.MapRemove1Strong) (= (AsFuelBottom StartFuelAssert_Maps._default.MapRemove1Strong) StartFuelAssert_Maps._default.MapRemove1Strong))) (and (and (= (AsFuelBottom StartFuel_Maps._default.IMapInvert) StartFuel_Maps._default.IMapInvert) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapInvert) StartFuelAssert_Maps._default.IMapInvert)) (and (= (AsFuelBottom StartFuel_Maps._default.IMapRemove) StartFuel_Maps._default.IMapRemove) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove) StartFuelAssert_Maps._default.IMapRemove)))) (and (and (and (= (AsFuelBottom StartFuel_Maps._default.IMapRemove1) StartFuel_Maps._default.IMapRemove1) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapRemove1) StartFuelAssert_Maps._default.IMapRemove1)) (and (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion) StartFuel_Maps._default.MapDisjointUnion) (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion) StartFuelAssert_Maps._default.MapDisjointUnion))) (and (and (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferA) StartFuel_Maps._default.MapUnionPreferA) (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferA) StartFuelAssert_Maps._default.MapUnionPreferA)) (and (= (AsFuelBottom StartFuel_Maps._default.MapUnionPreferB) StartFuel_Maps._default.MapUnionPreferB) (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnionPreferB) StartFuelAssert_Maps._default.MapUnionPreferB)))))) (and (and (and (and (and (= (AsFuelBottom StartFuel_Maps._default.MapUnion) StartFuel_Maps._default.MapUnion) (= (AsFuelBottom StartFuelAssert_Maps._default.MapUnion) StartFuelAssert_Maps._default.MapUnion)) (and (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferA) StartFuel_Maps._default.IMapUnionPreferA) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferA) StartFuelAssert_Maps._default.IMapUnionPreferA))) (and (and (= (AsFuelBottom StartFuel_Maps._default.IMapUnionPreferB) StartFuel_Maps._default.IMapUnionPreferB) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnionPreferB) StartFuelAssert_Maps._default.IMapUnionPreferB)) (and (= (AsFuelBottom StartFuel_Maps._default.IMapUnion) StartFuel_Maps._default.IMapUnion) (= (AsFuelBottom StartFuelAssert_Maps._default.IMapUnion) StartFuelAssert_Maps._default.IMapUnion)))) (and (and (and (= (AsFuelBottom StartFuel_Maps._default.MapDisjointUnion3) StartFuel_Maps._default.MapDisjointUnion3) (= (AsFuelBottom StartFuelAssert_Maps._default.MapDisjointUnion3) StartFuelAssert_Maps._default.MapDisjointUnion3)) (and (= (AsFuelBottom StartFuel_MsgHistoryMod.MsgHistory.LSNSet) StartFuel_MsgHistoryMod.MsgHistory.LSNSet) (= (AsFuelBottom StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet) StartFuelAssert_MsgHistoryMod.MsgHistory.LSNSet))) (and (and (= (AsFuelBottom StartFuel_SeqComparison._default.lte) StartFuel_SeqComparison._default.lte) (= (AsFuelBottom StartFuelAssert_SeqComparison._default.lte) StartFuelAssert_SeqComparison._default.lte)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.lte) StartFuel_Byte_Order._default.lte) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.lte) StartFuelAssert_Byte_Order._default.lte))))) (and (and (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.ltedef) StartFuel_Byte_Order._default.ltedef) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.ltedef) StartFuelAssert_Byte_Order._default.ltedef)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGte))) (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Byte_Order._default.binarySearchIndexOfFirstKeyGt)))) (and (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.NotMinimum) StartFuel_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.NotMinimum) StartFuelAssert_Byte_Order._default.NotMinimum)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.SortedSeqForMap) StartFuel_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Byte_Order._default.SortedSeqForMap))) (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.minimum) StartFuel_Byte_Order._default.minimum) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.minimum) StartFuelAssert_Byte_Order._default.minimum)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.minimumOpt) StartFuel_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.minimumOpt) StartFuelAssert_Byte_Order._default.minimumOpt))))))) (and (and (and (and (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.maximum) StartFuel_Byte_Order._default.maximum) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.maximum) StartFuelAssert_Byte_Order._default.maximum)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.maximumOpt) StartFuel_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.maximumOpt) StartFuelAssert_Byte_Order._default.maximumOpt))) (and (and (= (AsFuelBottom StartFuel_Byte_Order._default.IsSorted) StartFuel_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.IsSorted) StartFuelAssert_Byte_Order._default.IsSorted)) (and (= (AsFuelBottom StartFuel_Byte_Order._default.IsStrictlySorted) StartFuel_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuelAssert_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Byte_Order._default.IsStrictlySorted)))) (and (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte)) (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound))) (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt)) (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.NotMinimum) StartFuel_Lexicographic_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum) StartFuelAssert_Lexicographic_Byte_Order._default.NotMinimum))))) (and (and (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuel_Lexicographic_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Lexicographic_Byte_Order._default.SortedSeqForMap)) (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.minimum) StartFuel_Lexicographic_Byte_Order._default.minimum) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.minimum) StartFuelAssert_Lexicographic_Byte_Order._default.minimum))) (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.minimumOpt) StartFuel_Lexicographic_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt) StartFuelAssert_Lexicographic_Byte_Order._default.minimumOpt)) (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.maximum) StartFuel_Lexicographic_Byte_Order._default.maximum) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.maximum) StartFuelAssert_Lexicographic_Byte_Order._default.maximum)))) (and (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.maximumOpt) StartFuel_Lexicographic_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt) StartFuelAssert_Lexicographic_Byte_Order._default.maximumOpt)) (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.IsSorted) StartFuel_Lexicographic_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted) StartFuelAssert_Lexicographic_Byte_Order._default.IsSorted))) (and (and (= (AsFuelBottom StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuel_Lexicographic_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Lexicographic_Byte_Order._default.IsStrictlySorted)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGte)))))) (and (and (and (and (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGteWithLowerBound)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.binarySearchIndexOfFirstKeyGt))) (and (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.NotMinimum)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.SortedSeqForMap)))) (and (and (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimum) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimum)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.minimumOpt))) (and (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximum) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximum)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.maximumOpt))))) (and (and (and (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsSorted)) (and (= (AsFuelBottom StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuel_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) (= (AsFuelBottom StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted) StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted))) (and (and (= (AsFuelBottom StartFuel_BoundedPivotsLib._default.CutoffForLeft) StartFuel_BoundedPivotsLib._default.CutoffForLeft) (= (AsFuelBottom StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft) StartFuelAssert_BoundedPivotsLib._default.CutoffForLeft)) (and (= (AsFuelBottom StartFuel_BoundedPivotsLib._default.CutoffForRight) StartFuel_BoundedPivotsLib._default.CutoffForRight) (= (AsFuelBottom StartFuelAssert_BoundedPivotsLib._default.CutoffForRight) StartFuelAssert_BoundedPivotsLib._default.CutoffForRight)))) (and (and (and (= (AsFuelBottom StartFuel_DomainMod.Domain.SaneKeys) StartFuel_DomainMod.Domain.SaneKeys) (= (AsFuelBottom StartFuelAssert_DomainMod.Domain.SaneKeys) StartFuelAssert_DomainMod.Domain.SaneKeys)) (and ($IsAlloc this@@325 Tclass.PivotBetree.Path $Heap@@108) (= |b$reqreads#0@0| (forall (($o@@198 T@U) ($f@@128 T@U) ) (! (let ((alpha@@135 (FieldTypeInv0 (type $f@@128))))
 (=> (and (and (= (type $o@@198) refType) (= (type $f@@128) (FieldType alpha@@135))) false) (U_2_bool (MapType6Select $_Frame@0@@0 $o@@198 $f@@128))))
 :qid |PivotBetreebrokenidfy.506:16|
 :skolemid |2167|
 :no-pattern (type $o@@198)
 :no-pattern (type $f@@128)
 :no-pattern (U_2_int $o@@198)
 :no-pattern (U_2_bool $o@@198)
 :no-pattern (U_2_int $f@@128)
 :no-pattern (U_2_bool $f@@128)
))))) (and (and (|PivotBetree.Path.Valid#canCall| this@@325) (PivotBetree.Path.Valid ($LS $LZ) this@@325)) (and ($IsAlloc this@@325 Tclass.PivotBetree.Path $Heap@@108) ($IsAlloc |replacement#0@@17| Tclass.PivotBetree.BetreeNode $Heap@@108)))))))) (and (=> (= (ControlFlow 0 184654) (- 0 668453)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (U_2_bool (Lit (bool_2_U true)))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 668509)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 668599)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#2@@21| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#2@@21|) (INTERNAL_lt_boogie |i#2@@21| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#2@@21|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2168|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#2@@21|)))
)))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 668735)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 668839)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#3@@12| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#3@@12|) (INTERNAL_lt_boogie |i#3@@12| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#3@@12|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#3@@12|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2169|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#3@@12|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669013)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 2))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669105)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669183)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669241)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (forall ((|i#4@@3| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#4@@3|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#4@@3|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#4@@3|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#4@@3|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#4@@3|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#4@@3|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2172|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#4@@3|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#4@@3|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#4@@3|))
))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669427)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (U_2_bool (Lit (bool_2_U true)))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669507)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (Upperbounded__Lexicographic__Byte__Order.__default.IsStrictlySorted StartFuelAssert_Upperbounded_Lexicographic_Byte_Order._default.IsStrictlySorted (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669621)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#5@@0| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#5@@0|) (INTERNAL_lt_boogie |i#5@@0| (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#5@@0|))))
 :qid |BoundedPivotsLibidfy.56:16|
 :skolemid |2174|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#5@@0|)))
)))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669781)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (U_2_bool (Lit (bool_2_U true))))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 669909)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (=> (|BoundedPivotsLib.__default.ElementsAreKeys#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.ElementsAreKeys (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (forall ((|i#6@@1| Int) ) (!  (=> (and (and (INTERNAL_le_boogie 0 |i#6@@1|) (INTERNAL_lt_boogie |i#6@@1| (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#6@@1|)))) (BoundedPivotsLib.__default.ElementIsKey ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#6@@1|))))
 :qid |BoundedPivotsLibidfy.39:16|
 :skolemid |2175|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) |i#6@@1|)))
)))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670107)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|BoundedPivotsLib.__default.WFPivots#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (or (BoundedPivotsLib.__default.WFPivots (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) (INTERNAL_ge_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 2))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670223)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LocalStructure#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LocalStructure (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (= (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))) (BoundedPivotsLib.__default.NumBuckets (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670325)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (PivotBetree.__default.WFChildren ($LS ($LS $LZ)) (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670407)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|PivotBetree.BetreeNode.WF#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.WF ($LS $LZ) (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (=> (|PivotBetree.BetreeNode.LinkedChildren#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.LinkedChildren (PivotBetree.Path.node this@@325)) (=> (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)) (forall ((|i#7| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#7|) (and (and (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#7|) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#7|)))) (PivotBetree.BetreeNode.LocalStructure ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#7|))))) (|DomainMod.Domain#Equal| (PivotBetree.BetreeNode.MyDomain ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#7|))) (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#7|)))
 :qid |PivotBetreebrokenidfy.66:17|
 :skolemid |2178|
 :pattern ( (PivotBetree.BetreeNode.DomainRoutedToChild (PivotBetree.Path.node this@@325) |i#7|))
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#7|)))
 :pattern ( (PivotBetree.BetreeNode.ValidChildIndex (PivotBetree.Path.node this@@325) |i#7|))
))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670617)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670663)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0))) (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (LitInt 0)))) (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 670851)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lte#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lte (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.Element.Max__Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (and (and (Upperbounded__Lexicographic__Byte__Order.Element.Element_q (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.Element_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1))))) (Lexicographic__Byte__Order.__default.lte (Upperbounded__Lexicographic__Byte__Order.Element.e (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325))) (Upperbounded__Lexicographic__Byte__Order.Element.e ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 671157)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (|PivotBetree.BetreeNode.KeyInDomain#canCall| (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (or (PivotBetree.BetreeNode.KeyInDomain (PivotBetree.Path.node this@@325) (PivotBetree.Path.key this@@325)) (=> (|BoundedPivotsLib.__default.BoundedKey#canCall| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (or (BoundedPivotsLib.__default.BoundedKey (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (PivotBetree.Path.key this@@325)) (=> (|Upperbounded__Lexicographic__Byte__Order.__default.lt#canCall| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (or (Upperbounded__Lexicographic__Byte__Order.__default.lt (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))) (not (|Upperbounded__Lexicographic__Byte__Order.Element#Equal| (BoundedPivotsLib.__default.KeyToElement (PivotBetree.Path.key this@@325)) ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325)) (INTERNAL_sub_boogie (|Seq#Length| (PivotBetree.BetreeNode.pivotTable (PivotBetree.Path.node this@@325))) 1)))))))))))))) (and (=> (= (ControlFlow 0 184654) (- 0 671327)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@325)) (PivotBetree.BetreeNode.BetreeNode_q (PivotBetree.Path.node this@@325)))))))) (and (=> (= (ControlFlow 0 184654) (- 0 671375)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (=> (|PivotBetree.BetreeNode.IsIndex#canCall| (PivotBetree.Path.node this@@325)) (or (PivotBetree.BetreeNode.IsIndex (PivotBetree.Path.node this@@325)) (forall ((|i#8| Int) ) (!  (=> (and (INTERNAL_le_boogie 0 |i#8|) (INTERNAL_lt_boogie |i#8| (|Seq#Length| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325))))) (PivotBetree.BetreeNode.BetreeNode_q ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#8|))))
 :qid |PivotBetreebrokenidfy.99:18|
 :skolemid |2180|
 :pattern ( ($Unbox DatatypeTypeType (|Seq#Index| (PivotBetree.BetreeNode.children (PivotBetree.Path.node this@@325)) |i#8|)))
)))))))) (and (=> (= (ControlFlow 0 184654) (- 0 671473)) (=> (|PivotBetree.Path.Valid#canCall| this@@325) (or (PivotBetree.Path.Valid ($LS $LZ) this@@325) (=> (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)) (PivotBetree.Path.Valid ($LS ($LS $LZ)) (PivotBetree.Path.Subpath this@@325)))))) (=> (and (PivotBetree.Path.Valid ($LS $LZ) this@@325) (= |b$reqreads#1@0| (forall (($o@@199 T@U) ($f@@129 T@U) ) (! (let ((alpha@@136 (FieldTypeInv0 (type $f@@129))))
 (=> (and (and (= (type $o@@199) refType) (= (type $f@@129) (FieldType alpha@@136))) false) (U_2_bool (MapType6Select $_Frame@0@@0 $o@@199 $f@@129))))
 :qid |PivotBetreebrokenidfy.507:16|
 :skolemid |2182|
 :no-pattern (type $o@@199)
 :no-pattern (type $f@@129)
 :no-pattern (U_2_int $o@@199)
 :no-pattern (U_2_bool $o@@199)
 :no-pattern (U_2_int $f@@129)
 :no-pattern (U_2_bool $f@@129)
)))) (=> (and (and (|PivotBetree.Path.ValidReplacement#canCall| this@@325 |replacement#0@@17|) (PivotBetree.Path.ValidReplacement this@@325 |replacement#0@@17|)) (and (PivotBetree.Path.Path_q this@@325) (INTERNAL_lt_boogie 0 (PivotBetree.Path.depth this@@325)))) (and (=> (= (ControlFlow 0 184654) (- 0 671563)) |b$reqreads#0@0|) (=> |b$reqreads#0@0| (and (=> (= (ControlFlow 0 184654) (- 0 671564)) |b$reqreads#1@0|) (=> |b$reqreads#1@0| (=> (PivotBetree.Path.Path_q this@@325) (and (=> (= (ControlFlow 0 184654) 184658) anon4_Then_correct) (=> (= (ControlFlow 0 184654) 184660) anon4_Else_correct))))))))))))))))))))))))))))))))))))))))
(let ((PreconditionGeneratedEntry_correct  (=> (and (and (and ($IsGoodHeap $Heap@@108) ($IsHeapAnchor $Heap@@108)) (and ($Is this@@325 Tclass.PivotBetree.Path) ($IsAlloc this@@325 Tclass.PivotBetree.Path $Heap@@108))) (and (and ($Is |replacement#0@@17| Tclass.PivotBetree.BetreeNode) ($Is |out#0@@6| (TSeq Tclass.PivotBetree.BetreeNode))) (and (= 62 $FunctionContextHeight) (= (ControlFlow 0 666700) 184654)))) anon0_correct)))
PreconditionGeneratedEntry_correct))))))
))
(check-sat)
(get-info :reason-unknown)
(get-value ((ControlFlow 0 0)))
(get-value ((ControlFlow 0 666700)))
(get-value ((ControlFlow 0 184654)))
(get-value ((ControlFlow 0 184660)))
(get-value ((ControlFlow 0 666669)))
(assert (not (= (ControlFlow 0 666669) (- 682190))))
(check-sat)
(pop 1)
; Invalid
